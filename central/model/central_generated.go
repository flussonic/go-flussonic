// Code generated by cmd/main. DO NOT EDIT.
package model

// Command name.
type AgentCommandHandlingCommand string

const (
	// Hello command.
	AgentCommandHandlingCommandHello AgentCommandHandlingCommand = "hello"
	// Contains info about agent's IP and MAC addresses.
	//
	AgentCommandHandlingCommandDescription AgentCommandHandlingCommand = "description"
	// Telling agent that specific streampoint should be connected.
	//
	AgentCommandHandlingCommandStreampointConnect AgentCommandHandlingCommand = "streampoint_connect"
	// Agent successfully connected to streampoint.
	//
	AgentCommandHandlingCommandStreampointConnected AgentCommandHandlingCommand = "streampoint_connected"
	// Failed to connect to streampoint.
	//
	AgentCommandHandlingCommandStreampointConnectFailure AgentCommandHandlingCommand = "streampoint_connect_failure"
	// Telling agent that streampoint should be disconnected.
	//
	AgentCommandHandlingCommandStreampointDisconnect AgentCommandHandlingCommand = "streampoint_disconnect"
	// Streampoint is disconnected.
	//
	AgentCommandHandlingCommandStreampointDisconnected AgentCommandHandlingCommand = "streampoint_disconnected"
	// Telling agent that it should reset.
	//
	AgentCommandHandlingCommandReset AgentCommandHandlingCommand = "reset"
	// Telling agent that it should reboot.
	//
	AgentCommandHandlingCommandReboot AgentCommandHandlingCommand = "reboot"
	// Telling agent that it should disconnect.
	//
	AgentCommandHandlingCommandDisconnect AgentCommandHandlingCommand = "disconnect"
)

// Error message explaining why command failed.
// If command was successful, this field absent.
type AgentCommandHandlingError string

const (
	// Failed to write/read command because of IO timeout.
	AgentCommandHandlingErrorTimeout AgentCommandHandlingError = "timeout"
	// Failed to write/read command because connection was closed.
	AgentCommandHandlingErrorConnectionClosed AgentCommandHandlingError = "connection_closed"
)

// Why agent failed to connect.
type AgentConnectFailedReason string

const (
	// Server encountered an internal error.
	AgentConnectFailedReasonInternalServerError AgentConnectFailedReason = "internal_server_error"
	// Failed to authenticate agent.
	AgentConnectFailedReasonAuthenticationFailed AgentConnectFailedReason = "authentication_failed"
)

// Why agent disconnected
type AgentDisconnectedReason string

const (
	// No ping from agent for more than 1 minute
	AgentDisconnectedReasonPingTimeout AgentDisconnectedReason = "ping_timeout"
	// Failed to set write deadline
	AgentDisconnectedReasonSetWriteDeadlineFail AgentDisconnectedReason = "set_write_deadline_fail"
	// Failed to set read deadline
	AgentDisconnectedReasonSetReadDeadlineFail AgentDisconnectedReason = "set_read_deadline_fail"
	// Connection was closed by agent
	AgentDisconnectedReasonAgentClosedConnection AgentDisconnectedReason = "agent_closed_connection"
)

// agent_id
type AgentID string

// Why agent failed to make streampoint location.
type AgentMakeStreampointLocationErrorReason string

const (
	// Streamer misses streampoint key.
	// Usually it means that streamer's Rproxy config is not configured yet by Central.
	// In case of using Central without config provision enabled (`CLUSTER_NODE_CONFIG_PROVISION_ENABLED = false`),
	// you should configure Rproxy manually.
	//
	AgentMakeStreampointLocationErrorReasonStreamerMissesStreampointKey AgentMakeStreampointLocationErrorReason = "streamer_misses_streampoint_key"
)

// agent://ID identification for `via` configuration option
type AgentURL string

// auth_backend_name
type AuthBackendName string

// When to perform midrolls.
type AuthResponseV1AdInjectMidrollInsertBy string

const (
	// All ad files are played in the specified order once every `midroll_interval`.
	//
	AuthResponseV1AdInjectMidrollInsertByInterval AuthResponseV1AdInjectMidrollInsertBy = "interval"
	// You can use this option if your stream has SCTE-35 or SCTE-104 markers.
	//
	// The ad files are played in the specified order (looped, from the beginning of the array)
	// until a marker for switching to the main stream is received,
	// or until the end of the advertisement slot (whichever comes first).
	//
	AuthResponseV1AdInjectMidrollInsertBySplicing AuthResponseV1AdInjectMidrollInsertBy = "splicing"
)

// Balancing mode
type BalancerConfigMode string

const (
	// Bandwidth usage
	BalancerConfigModeUsage BalancerConfigMode = "usage"
	// Total clients number
	BalancerConfigModeClients BalancerConfigMode = "clients"
	// Total output bitrate
	BalancerConfigModeBitrate BalancerConfigMode = "bitrate"
	// Streams number
	BalancerConfigModeStreams BalancerConfigMode = "streams"
)

// base64
type Base64 string

// bytes
type Bytes int

// Status of the healthcheck.
type CentralHealthcheckStatusStatus string

const (
	// Peer is healthy.
	//
	CentralHealthcheckStatusStatusOk CentralHealthcheckStatusStatus = "ok"
	// Peer has errors.
	//
	CentralHealthcheckStatusStatusError CentralHealthcheckStatusStatus = "error"
)

// Role of node
type CentralNodeRoleRole string

const (
	// The "streamer" role is used for nodes where Flussonic Media Server is deployed.
	CentralNodeRoleRoleStreamer CentralNodeRoleRole = "streamer"
	// The "inference" role is used for nodes where Flussonic Vision Inference is deployed. On "inference" nodes, Central provisions streams with the "vision" parameter set.
	CentralNodeRoleRoleInference CentralNodeRoleRole = "inference"
	// The "identification" role is used for nodes where Flussonic Vision Identification is deployed. Central fetches enriched episodes with persons from Flussonic Identification Service.
	CentralNodeRoleRoleIdentification CentralNodeRoleRole = "identification"
)

// Layout role of streamer.
type CentralStreamerLayoutPredictionItemRole string

const (
	// Streamer is used as ingest.
	//
	CentralStreamerLayoutPredictionItemRoleIngest CentralStreamerLayoutPredictionItemRole = "ingest"
	// Streamer is used as inference.
	//
	CentralStreamerLayoutPredictionItemRoleInference CentralStreamerLayoutPredictionItemRole = "inference"
	// Streamer is used as dvr backup.
	//
	CentralStreamerLayoutPredictionItemRoleDvrBackup CentralStreamerLayoutPredictionItemRole = "dvr_backup"
)

// client_count
type ClientCount int

// External config status
type ConfigExternalErrorStatusStatus string

const (
	// External config is successfully loaded, parsed and applied.
	ConfigExternalErrorStatusStatusLoaded ConfigExternalErrorStatusStatus = "loaded"
	// Valid external config could not be obtained because of error
	ConfigExternalErrorStatusStatusError ConfigExternalErrorStatusStatus = "error"
)

// Conditions of the error occurrence.
type ConfigExternalErrorStatusWhile string

const (
	// Configuration server returned an error while performing a background batch refresh.
	ConfigExternalErrorStatusWhileRefresh ConfigExternalErrorStatusWhile = "refresh"
	// Configuration server returned an error while requesting a stream configuration for the first time.
	ConfigExternalErrorStatusWhileRequest ConfigExternalErrorStatusWhile = "request"
	// Configuration server returned an error while resolving srt port.
	ConfigExternalErrorStatusWhileSrtPortResolve ConfigExternalErrorStatusWhile = "srt_port_resolve"
)

// date_time
type DateTime string

// disk_device
type DiskDevice string

// disk_path
type DiskPath string

// drm_resource_id
type DrmResourceID string

// dvr_name
type DvrName string

// dvr_url
type DvrURL string

// Type of the entity.
type EntityEventEntityType string

const (
	EntityEventEntityTypeAgent    EntityEventEntityType = "agent"
	EntityEventEntityTypeStream   EntityEventEntityType = "stream"
	EntityEventEntityTypeStreamer EntityEventEntityType = "streamer"
)

type EpisodeOriginatorSource string

const (
	// Episode was updated by an api.
	//
	EpisodeOriginatorSourceAPI EpisodeOriginatorSource = "api"
	// Episode was updated by an inference node.
	//
	EpisodeOriginatorSourceInference EpisodeOriginatorSource = "inference"
	// Episode was updated by a motion detector.
	//
	EpisodeOriginatorSourceMotionDetector EpisodeOriginatorSource = "motion_detector"
)

// event_sink_name
type EventSinkName string

// float
type Float float64

// hexbinary
type Hexbinary string

// ip
type IP string

// input_url
type InputURL string

// ipv4
type Ipv4 string

// iso3166
type Iso3166 string

// Whether it is a file with a finite start and end time or a live stream.
type MediaInfoSpecificFlowType string

const (
	MediaInfoSpecificFlowTypeFile      MediaInfoSpecificFlowType = "file"
	MediaInfoSpecificFlowTypeStream    MediaInfoSpecificFlowType = "stream"
	MediaInfoSpecificFlowTypeDvrFile   MediaInfoSpecificFlowType = "dvr_file"
	MediaInfoSpecificFlowTypeDvrStream MediaInfoSpecificFlowType = "dvr_stream"
)

// media_name
type MediaName string

// megabytes
type Megabytes int

// microseconds
type Microseconds int

// milliseconds
type Milliseconds float64

// network_port
type NetworkPort int

// password
type Password string

// percent
type Percent int

// pixels
type Pixels int

// Playback type for which the HTTP headers apply.
type PlaybackHeadersPlayback string

const (
	PlaybackHeadersPlaybackLive PlaybackHeadersPlayback = "live"
	PlaybackHeadersPlaybackDvr  PlaybackHeadersPlayback = "dvr"
)

// query_session_key
type QuerySessionKey string

// seconds
type Seconds int

// server_name
type ServerName string

// server_version
type ServerVersion string

// snowflake_id
type SnowflakeID int

// sort_index
type SortIndex int

// speed
type Speed int

// This parameter allows to manage subtitles in an output stream.
type StreamConfigInputDvbocr string

const (
	// An output stream will have a track containing subtitles converted to a text format (WebVTT).
	StreamConfigInputDvbocrReplace StreamConfigInputDvbocr = "replace"
	// An output stream will have two tracks containing subtitles:
	// the original track with subtitles in DVB and a new track with text subtitles.
	//
	StreamConfigInputDvbocrAdd StreamConfigInputDvbocr = "add"
)

// Whether to enable SCTE-35 ad insertion markers signaling in HLS manifest.
// Ad markers can be included in SCTE-35 (`scte35`), AWS (`aws`), EXT-X-DATERANGE (`rfc8216`) formats or not included (`false`).
type StreamConfigMediaHlsScte35 string

const (
	// AWS format
	StreamConfigMediaHlsScte35Aws StreamConfigMediaHlsScte35 = "aws"
	// ANSI SCTE35 format
	StreamConfigMediaHlsScte35Scte35 StreamConfigMediaHlsScte35 = "scte35"
	// Apple RFC 8216 EXT-X-DATERANGE format
	StreamConfigMediaHlsScte35Rfc8216 StreamConfigMediaHlsScte35 = "rfc8216"
)

// Synchronization mode for audio captured from the Decklink card.
type StreamInputDecklinkApts interface{}

const (
	// Synchronization by video.
	StreamInputDecklinkAptsVideo = "video"
	// Synchronization according to the timing reference signal.
	StreamInputDecklinkAptsRef = "ref"
	// Equivalent of 'video'.
	StreamInputDecklinkApts1 = 1
	// Equivalent of 'ref'.
	StreamInputDecklinkApts3 = 3
)

// Preferred pixel format for captured video.
type StreamInputDecklinkPixel string

const (
	// rgb color model and 8 bits per pixel.
	StreamInputDecklinkPixelRgb8 StreamInputDecklinkPixel = "rgb8"
	// rgb color model and 10 bits per pixel.
	StreamInputDecklinkPixelRgb10 StreamInputDecklinkPixel = "rgb10"
	// rgb color model and 12 bits per pixel.
	StreamInputDecklinkPixelRgb12 StreamInputDecklinkPixel = "rgb12"
	// YUV color model and 8 bits per pixel.
	StreamInputDecklinkPixelYuv8 StreamInputDecklinkPixel = "yuv8"
	// YUV color model and 10 bits per pixel.
	StreamInputDecklinkPixelYuv10 StreamInputDecklinkPixel = "yuv10"
	// equivalent of `yuv8`.
	StreamInputDecklinkPixel8 StreamInputDecklinkPixel = "8"
	// equivalent of `yuv10`.
	StreamInputDecklinkPixel10 StreamInputDecklinkPixel = "10"
)

// Synchronization mode for video captured from the Decklink card.
type StreamInputDecklinkVpts interface{}

const (
	// Synchronization by audio.
	StreamInputDecklinkVptsAudio = "audio"
	// Synchronization according to the timing reference signal.
	StreamInputDecklinkVptsRef = "ref"
	// Equivalent of 'audio'.
	StreamInputDecklinkVpts2 = 2
	// Equivalent of 'ref'.
	StreamInputDecklinkVpts3 = 3
)

// Preferred pixel format for captured video.
type StreamInputDektecPixel string

const (
	// rgb color model and 8 bits per pixel.
	StreamInputDektecPixelRgb8 StreamInputDektecPixel = "rgb8"
	// rgb color model and 10 bits per pixel.
	StreamInputDektecPixelRgb10 StreamInputDektecPixel = "rgb10"
	// rgb color model and 12 bits per pixel.
	StreamInputDektecPixelRgb12 StreamInputDektecPixel = "rgb12"
	// YUV color model and 8 bits per pixel.
	StreamInputDektecPixelYuv8 StreamInputDektecPixel = "yuv8"
	// YUV color model and 10 bits per pixel.
	StreamInputDektecPixelYuv10 StreamInputDektecPixel = "yuv10"
	// equivalent of `yuv8`.
	StreamInputDektecPixel8 StreamInputDektecPixel = "8"
	// equivalent of `yuv10`.
	StreamInputDektecPixel10 StreamInputDektecPixel = "10"
)

// Source for PTS for input stream.
type StreamInputDektecPtsSource string

const (
	// Generates PTS based on the system clock, aligned to a perfect frame duration. This provides a smooth, jitter-free playback timeline when the source timing is unreliable.
	StreamInputDektecPtsSourceAligned StreamInputDektecPtsSource = "aligned"
	// PTS from embedded 54mhz timestamp from SDI VANC.
	StreamInputDektecPtsSourceSdi StreamInputDektecPtsSource = "sdi"
	// PTS from current time of day dektec api.
	StreamInputDektecPtsSourceTod StreamInputDektecPtsSource = "tod"
	// PTS from clock_gettime wall-clock time.
	StreamInputDektecPtsSourceUs StreamInputDektecPtsSource = "us"
)

// The mixing mode for the `mixer://` input type.
type StreamInputMixerMixerStrategy string

const (
	// Mix all input tracks.
	StreamInputMixerMixerStrategyAll StreamInputMixerMixerStrategy = "all"
	// Mix only a first video track of the first input with a first audio track of the second input.
	StreamInputMixerMixerStrategyFirstVideoAudio StreamInputMixerMixerStrategy = "first_video_audio"
)

// This configuration is deprecated. Use `dvbocr` configuration field in stream.
//
// This parameter allows to manage subtitles in an output stream.
type StreamInputMpegtsSpecificSubtitles string

const (
	// An output stream will have no subtitles track.
	StreamInputMpegtsSpecificSubtitlesDrop StreamInputMpegtsSpecificSubtitles = "drop"
	// An output stream will have a subtitles track in DVB, without conversion to text (default behavior).
	StreamInputMpegtsSpecificSubtitlesAccept StreamInputMpegtsSpecificSubtitles = "accept"
	// An output stream will have a track containing subtitles converted to a text format (WebVTT).
	StreamInputMpegtsSpecificSubtitlesOcrReplace StreamInputMpegtsSpecificSubtitles = "ocr_replace"
	// An output stream will have two tracks containing subtitles:
	// the original track with subtitles in DVB and a new track with text subtitles.
	//
	StreamInputMpegtsSpecificSubtitlesOcrAdd StreamInputMpegtsSpecificSubtitles = "ocr_add"
)

// This configuration is deprecated. Use `dvbocr` configuration field in stream.
//
// This parameter allows to manage subtitles in an output stream.
type StreamInputSrtPublishSpecificSubtitles string

const (
	// An output stream will have no subtitles track.
	StreamInputSrtPublishSpecificSubtitlesDrop StreamInputSrtPublishSpecificSubtitles = "drop"
	// An output stream will have a subtitles track in DVB, without conversion to text (default behavior).
	StreamInputSrtPublishSpecificSubtitlesAccept StreamInputSrtPublishSpecificSubtitles = "accept"
	// An output stream will have a track containing subtitles converted to a text format (WebVTT).
	StreamInputSrtPublishSpecificSubtitlesOcrReplace StreamInputSrtPublishSpecificSubtitles = "ocr_replace"
	// An output stream will have two tracks containing subtitles:
	// the original track with subtitles in DVB and a new track with text subtitles.
	//
	StreamInputSrtPublishSpecificSubtitlesOcrAdd StreamInputSrtPublishSpecificSubtitles = "ocr_add"
)

// This parameter is used when encoding with Nvidia NVENC.
// You can remove duplicate frames that were produced after deinterlacing, preventing increased bitrate, by one of two methods.
type TcDecoderDeinterlaceRate string

const (
	// From field sequence `1a 1b 2a 2b 3a 3b` we get frame sequence `1a1b 2a2b 3a3b`.
	// The FPS stays the same.
	//
	TcDecoderDeinterlaceRateFrame TcDecoderDeinterlaceRate = "frame"
	// Fields `1a 1b 2a 2b 3a 3b` transform into `1a1b 1b2a 2a2b 2b3a` frames.
	// The FPS increases two times after transcoding.
	//
	TcDecoderDeinterlaceRateField TcDecoderDeinterlaceRate = "field"
)

// Position to burn text.
type TcLabelPosition string

const (
	TcLabelPositionTl TcLabelPosition = "tl"
	TcLabelPositionBl TcLabelPosition = "bl"
	TcLabelPositionTr TcLabelPosition = "tr"
	TcLabelPositionBr TcLabelPosition = "br"
	TcLabelPositionC  TcLabelPosition = "c"
	TcLabelPositionCt TcLabelPosition = "ct"
	TcLabelPositionCb TcLabelPosition = "cb"
)

// Position to place the logo.
type TcLogoPosition string

const (
	TcLogoPositionTl TcLogoPosition = "tl"
	TcLogoPositionTr TcLogoPosition = "tr"
	TcLogoPositionBl TcLogoPosition = "bl"
	TcLogoPositionBr TcLogoPosition = "br"
	TcLogoPositionC  TcLogoPosition = "c"
)

// The algorithm of the picture resizing: crop, scale, or fit.
type TcSizeStrategy string

const (
	TcSizeStrategyCrop  TcSizeStrategy = "crop"
	TcSizeStrategyScale TcSizeStrategy = "scale"
	TcSizeStrategyFit   TcSizeStrategy = "fit"
)

// The video codec.
type TcVideoOptsCodec string

const (
	TcVideoOptsCodecH264 TcVideoOptsCodec = "h264"
	TcVideoOptsCodecHevc TcVideoOptsCodec = "hevc"
	TcVideoOptsCodecAv1  TcVideoOptsCodec = "av1"
	TcVideoOptsCodecMp2v TcVideoOptsCodec = "mp2v"
)

// The number of audio channels in an output stream.
type TiAudioAacSpecChannels int

const (
	TiAudioAacSpecChannels1 TiAudioAacSpecChannels = 1
	TiAudioAacSpecChannels2 TiAudioAacSpecChannels = 2
	TiAudioAacSpecChannels3 TiAudioAacSpecChannels = 3
	TiAudioAacSpecChannels4 TiAudioAacSpecChannels = 4
	TiAudioAacSpecChannels5 TiAudioAacSpecChannels = 5
	TiAudioAacSpecChannels6 TiAudioAacSpecChannels = 6
	TiAudioAacSpecChannels7 TiAudioAacSpecChannels = 7
)

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// The allowed values are:
// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
type TiAudioAacSpecSampleRate int

const (
	TiAudioAacSpecSampleRate96000 TiAudioAacSpecSampleRate = 96000
	TiAudioAacSpecSampleRate88200 TiAudioAacSpecSampleRate = 88200
	TiAudioAacSpecSampleRate64000 TiAudioAacSpecSampleRate = 64000
	TiAudioAacSpecSampleRate48000 TiAudioAacSpecSampleRate = 48000
	TiAudioAacSpecSampleRate44100 TiAudioAacSpecSampleRate = 44100
	TiAudioAacSpecSampleRate32000 TiAudioAacSpecSampleRate = 32000
	TiAudioAacSpecSampleRate24000 TiAudioAacSpecSampleRate = 24000
	TiAudioAacSpecSampleRate22050 TiAudioAacSpecSampleRate = 22050
	TiAudioAacSpecSampleRate16000 TiAudioAacSpecSampleRate = 16000
	TiAudioAacSpecSampleRate12000 TiAudioAacSpecSampleRate = 12000
	TiAudioAacSpecSampleRate11025 TiAudioAacSpecSampleRate = 11025
	TiAudioAacSpecSampleRate8000  TiAudioAacSpecSampleRate = 8000
	TiAudioAacSpecSampleRate0     TiAudioAacSpecSampleRate = 0
)

// The number of audio channels in an output stream.
type TiAudioAc3SpecChannels int

const (
	TiAudioAc3SpecChannels1 TiAudioAc3SpecChannels = 1
	TiAudioAc3SpecChannels2 TiAudioAc3SpecChannels = 2
	TiAudioAc3SpecChannels3 TiAudioAc3SpecChannels = 3
	TiAudioAc3SpecChannels4 TiAudioAc3SpecChannels = 4
	TiAudioAc3SpecChannels5 TiAudioAc3SpecChannels = 5
	TiAudioAc3SpecChannels6 TiAudioAc3SpecChannels = 6
)

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// The allowed values are:
// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
type TiAudioAc3SpecSampleRate int

const (
	TiAudioAc3SpecSampleRate48000 TiAudioAc3SpecSampleRate = 48000
	TiAudioAc3SpecSampleRate44100 TiAudioAc3SpecSampleRate = 44100
	TiAudioAc3SpecSampleRate32000 TiAudioAc3SpecSampleRate = 32000
	TiAudioAc3SpecSampleRate0     TiAudioAc3SpecSampleRate = 0
)

// The number of audio channels in an output stream.
type TiAudioMp2aSpecChannels int

const (
	TiAudioMp2aSpecChannels1 TiAudioMp2aSpecChannels = 1
	TiAudioMp2aSpecChannels2 TiAudioMp2aSpecChannels = 2
)

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// The allowed values are:
// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
type TiAudioMp2aSpecSampleRate int

const (
	TiAudioMp2aSpecSampleRate48000 TiAudioMp2aSpecSampleRate = 48000
	TiAudioMp2aSpecSampleRate44100 TiAudioMp2aSpecSampleRate = 44100
	TiAudioMp2aSpecSampleRate32000 TiAudioMp2aSpecSampleRate = 32000
	TiAudioMp2aSpecSampleRate24000 TiAudioMp2aSpecSampleRate = 24000
	TiAudioMp2aSpecSampleRate22050 TiAudioMp2aSpecSampleRate = 22050
	TiAudioMp2aSpecSampleRate16000 TiAudioMp2aSpecSampleRate = 16000
	TiAudioMp2aSpecSampleRate0     TiAudioMp2aSpecSampleRate = 0
)

// The number of audio channels in an output stream.
type TiAudioMp3SpecChannels int

const (
	TiAudioMp3SpecChannels1 TiAudioMp3SpecChannels = 1
	TiAudioMp3SpecChannels2 TiAudioMp3SpecChannels = 2
)

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// The allowed values are:
// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
type TiAudioMp3SpecSampleRate int

const (
	TiAudioMp3SpecSampleRate48000 TiAudioMp3SpecSampleRate = 48000
	TiAudioMp3SpecSampleRate44100 TiAudioMp3SpecSampleRate = 44100
	TiAudioMp3SpecSampleRate32000 TiAudioMp3SpecSampleRate = 32000
	TiAudioMp3SpecSampleRate24000 TiAudioMp3SpecSampleRate = 24000
	TiAudioMp3SpecSampleRate22050 TiAudioMp3SpecSampleRate = 22050
	TiAudioMp3SpecSampleRate16000 TiAudioMp3SpecSampleRate = 16000
	TiAudioMp3SpecSampleRate12000 TiAudioMp3SpecSampleRate = 12000
	TiAudioMp3SpecSampleRate11025 TiAudioMp3SpecSampleRate = 11025
	TiAudioMp3SpecSampleRate8000  TiAudioMp3SpecSampleRate = 8000
	TiAudioMp3SpecSampleRate0     TiAudioMp3SpecSampleRate = 0
)

// The number of audio channels in an output stream.
type TiAudioOpusSpecChannels int

const (
	TiAudioOpusSpecChannels1 TiAudioOpusSpecChannels = 1
	TiAudioOpusSpecChannels2 TiAudioOpusSpecChannels = 2
	TiAudioOpusSpecChannels3 TiAudioOpusSpecChannels = 3
	TiAudioOpusSpecChannels4 TiAudioOpusSpecChannels = 4
	TiAudioOpusSpecChannels5 TiAudioOpusSpecChannels = 5
	TiAudioOpusSpecChannels6 TiAudioOpusSpecChannels = 6
)

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// The allowed values are:
// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
type TiAudioOpusSpecSampleRate int

const (
	TiAudioOpusSpecSampleRate48000 TiAudioOpusSpecSampleRate = 48000
	TiAudioOpusSpecSampleRate24000 TiAudioOpusSpecSampleRate = 24000
	TiAudioOpusSpecSampleRate16000 TiAudioOpusSpecSampleRate = 16000
	TiAudioOpusSpecSampleRate12000 TiAudioOpusSpecSampleRate = 12000
	TiAudioOpusSpecSampleRate8000  TiAudioOpusSpecSampleRate = 8000
	TiAudioOpusSpecSampleRate0     TiAudioOpusSpecSampleRate = 0
)

// The number of audio channels in an output stream.
type TiAudioPcmaSpecChannels int

const (
	TiAudioPcmaSpecChannels1 TiAudioPcmaSpecChannels = 1
)

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// The allowed values are:
// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
type TiAudioPcmaSpecSampleRate int

const (
	TiAudioPcmaSpecSampleRate8000 TiAudioPcmaSpecSampleRate = 8000
	TiAudioPcmaSpecSampleRate0    TiAudioPcmaSpecSampleRate = 0
)

// ticks
type Ticks float64

// url
type URL string

// uuid
type UUID string

// Contains only alphanumeric characters (a-z, A-Z, 0-9), underscores (_), hyphens (-) and periods (.).
type UnixName string

// Unix timestamp in seconds
type Utc int

// Unix timestamp in milliseconds
type UtcMs int

// The algorithm used for video analytics.
type VisionSpecAlg string

const (
	// The algorithm for face recognition is used.
	VisionSpecAlgFaces VisionSpecAlg = "faces"
	// The algorithm for license plate recognition is used.
	VisionSpecAlgPlates VisionSpecAlg = "plates"
)

// Initiator of event
type AgentInitiator string

const (
	// Event initiated by agent.
	AgentInitiatorAgent AgentInitiator = "agent"
	// Event initiated by endpoint.
	AgentInitiatorEndpoint AgentInitiator = "endpoint"
)

type AuthURL string

type BmDisplayMode string

// Name of decision reason for node incompatibility with the stream
type CentralNodeLayoutDecisionReason string

const (
	// Stream doesn't have labels that match all the node's required labels.
	CentralNodeLayoutDecisionReasonStreamMissesNodeRequiredLabels CentralNodeLayoutDecisionReason = "stream_misses_node_required_labels"
	// Node doesn't have labels that match all the stream's required labels.
	CentralNodeLayoutDecisionReasonNodeMissesStreamRequiredLabels CentralNodeLayoutDecisionReason = "node_misses_stream_required_labels"
	// Channel limit of previous node was exceeded
	CentralNodeLayoutDecisionReasonNodeChannelLimitExceeded CentralNodeLayoutDecisionReason = "node_channel_limit_exceeded"
	// Estimated disk space load exceeds the threshold for the streamer's DVR.
	CentralNodeLayoutDecisionReasonStreamerDvrSizeExceeded CentralNodeLayoutDecisionReason = "streamer_dvr_size_exceeded"
	// Node is not available for transcoding.
	CentralNodeLayoutDecisionReasonNodeNotAvailableForTranscoding CentralNodeLayoutDecisionReason = "node_not_available_for_transcoding"
	// Node is offline.
	CentralNodeLayoutDecisionReasonNodeOffline CentralNodeLayoutDecisionReason = "node_offline"
	// Bandwidth load exceeds the threshold for the streamer defined by
	// [total_bandwidth](https://flussonic.com/doc/api/central/#tag/streamer/operation/streamer_get/response__0%7Ctotal_bandwidth).
	//
	CentralNodeLayoutDecisionReasonStreamerTotalBandwidthExceeded CentralNodeLayoutDecisionReason = "streamer_total_bandwidth_exceeded"
	// The node's namespace does not match the stream's namespace.
	CentralNodeLayoutDecisionReasonNamespaceMismatch CentralNodeLayoutDecisionReason = "namespace_mismatch"
)

// Reason why layout was changed
type CentralStreamLayoutChangeReason string

const (
	// Stream doesn't have labels that match all the node's required labels.
	CentralStreamLayoutChangeReasonStreamMissesNodeRequiredLabels CentralStreamLayoutChangeReason = "stream_misses_node_required_labels"
	// Node doesn't have labels that match all the stream's required labels.
	CentralStreamLayoutChangeReasonNodeMissesStreamRequiredLabels CentralStreamLayoutChangeReason = "node_misses_stream_required_labels"
	// Previous node become offline
	CentralStreamLayoutChangeReasonNodeBecomeOffline CentralStreamLayoutChangeReason = "node_become_offline"
	// Stream has been disabled
	CentralStreamLayoutChangeReasonStreamDisabled CentralStreamLayoutChangeReason = "stream_disabled"
	// Node has been deleted
	CentralStreamLayoutChangeReasonNodeDeleted CentralStreamLayoutChangeReason = "node_deleted"
	// Channel limit of previous node was exceeded
	CentralStreamLayoutChangeReasonNodeChannelLimitExceeded CentralStreamLayoutChangeReason = "node_channel_limit_exceeded"
	// Other stream has same agent_id in its inputs, but different ingest.
	//
	CentralStreamLayoutChangeReasonMultistreamAgentIngestConflict CentralStreamLayoutChangeReason = "multistream_agent_ingest_conflict"
	// Estimated disk space load exceeds the threshold for the streamer's DVR.
	//
	CentralStreamLayoutChangeReasonStreamerDvrSizeExceeded CentralStreamLayoutChangeReason = "streamer_dvr_size_exceeded"
	// Bandwidth load exceeds the threshold for the streamer defined by [total_bandwidth](https://flussonic.com/doc/api/central/#tag/streamer/operation/streamer_get/response__0%7Ctotal_bandwidth).
	//
	CentralStreamLayoutChangeReasonStreamerTotalBandwidthExceeded CentralStreamLayoutChangeReason = "streamer_total_bandwidth_exceeded"
	// There is an available node with better match for stream labels than the one currently in use.
	//
	CentralStreamLayoutChangeReasonPreferredLabelsBetterMatch CentralStreamLayoutChangeReason = "preferred_labels_better_match"
	// Stream has not been distributed to node yet.
	CentralStreamLayoutChangeReasonNotDistributed CentralStreamLayoutChangeReason = "not_distributed"
	// DVR backups have been adjusted to match [dvr.redundancy_factor](https://flussonic.com/doc/api/central/#tag/stream/operation/stream_get/response%7Cdvr%7Credundancy_factor).
	//
	CentralStreamLayoutChangeReasonDvrRedundancyAdjust CentralStreamLayoutChangeReason = "dvr_redundancy_adjust"
	// Node has high cpu and can not operate normally.
	CentralStreamLayoutChangeReasonNodeCpuPressure CentralStreamLayoutChangeReason = "node_cpu_pressure"
	// Layout was changed by API call and the change_reason field was empty.
	// If the change_reason is not empty this value is not used.
	//
	CentralStreamLayoutChangeReasonRelayoutByAPI CentralStreamLayoutChangeReason = "relayout_by_api"
	// The node's namespace does not match the stream's namespace.
	CentralStreamLayoutChangeReasonNamespaceMismatch CentralStreamLayoutChangeReason = "namespace_mismatch"
)

// Service or admin user who changed the layout of the stream using an API call.
type CentralStreamLayoutOriginator string

const (
	// Layout was changed via layouter.
	CentralStreamLayoutOriginatorLayouter CentralStreamLayoutOriginator = "layouter"
	// Layout was changed via something other.
	CentralStreamLayoutOriginatorOther CentralStreamLayoutOriginator = "other"
)

// Collective status of certain object's metric.
type ClusterHealthStatus string

const (
	// Indicates that the entity is fully functional and performing optimally.
	ClusterHealthStatusOperational ClusterHealthStatus = "operational"
	// Indicates that the entity is partly functional but performing optimally.
	ClusterHealthStatusDegradated ClusterHealthStatus = "degradated"
	// Indicates that the entity is mostly non-functional, reduced performance.
	ClusterHealthStatusPartialOutage ClusterHealthStatus = "partial_outage"
	// Indicates that the entity is non-functional.
	ClusterHealthStatusOutage ClusterHealthStatus = "outage"
	// Indicates that the entity is disabled
	ClusterHealthStatusDisabled ClusterHealthStatus = "disabled"
)

type ConfigPathSegment interface{}

type DeinterlaceSettings interface{}

type DrmSystem string

type DvrRaidLevel int

const (
	// RAID level 0
	DvrRaidLevel0 DvrRaidLevel = 0
)

type EpisodeCloseReason string

const (
	// Episode was closed because of no activity was detected in it.
	EpisodeCloseReasonTimeout EpisodeCloseReason = "timeout"
)

type FrameAppCodec string

const (
	FrameAppCodecMpegts FrameAppCodec = "mpegts"
	FrameAppCodecObject FrameAppCodec = "object"
	FrameAppCodecEit    FrameAppCodec = "eit"
	FrameAppCodecScte27 FrameAppCodec = "scte27"
	FrameAppCodecScte35 FrameAppCodec = "scte35"
	FrameAppCodecKlv    FrameAppCodec = "klv"
	FrameAppCodecEmpty  FrameAppCodec = "empty"
)

type FrameAudioCodec string

const (
	FrameAudioCodecAac  FrameAudioCodec = "aac"
	FrameAudioCodecMp3  FrameAudioCodec = "mp3"
	FrameAudioCodecMp2a FrameAudioCodec = "mp2a"
	FrameAudioCodecOpus FrameAudioCodec = "opus"
	FrameAudioCodecAc3  FrameAudioCodec = "ac3"
	FrameAudioCodecEac3 FrameAudioCodec = "eac3"
	FrameAudioCodecPcma FrameAudioCodec = "pcma"
	FrameAudioCodecPcmu FrameAudioCodec = "pcmu"
)

type FrameAudioRawCodec string

const (
	FrameAudioRawCodecPcm FrameAudioRawCodec = "pcm"
)

type FrameCodec string

type FrameContent string

const (
	FrameContentAudio       FrameContent = "audio"
	FrameContentVideo       FrameContent = "video"
	FrameContentText        FrameContent = "text"
	FrameContentMetadata    FrameContent = "metadata"
	FrameContentApplication FrameContent = "application"
)

type FrameRawCodec string

const (
	FrameRawCodecYuv       FrameRawCodec = "yuv"
	FrameRawCodecUyvy422   FrameRawCodec = "uyvy422"
	FrameRawCodecYuyv422   FrameRawCodec = "yuyv422"
	FrameRawCodecYuv422p10 FrameRawCodec = "yuv422p10"
	FrameRawCodecArgb      FrameRawCodec = "argb"
	FrameRawCodecRgb48     FrameRawCodec = "rgb48"
	FrameRawCodecV210      FrameRawCodec = "v210"
	FrameRawCodecPcm       FrameRawCodec = "pcm"
	FrameRawCodecR210      FrameRawCodec = "r210"
)

type FrameTextCodec string

const (
	FrameTextCodecTtxt     FrameTextCodec = "ttxt"
	FrameTextCodecText     FrameTextCodec = "text"
	FrameTextCodecWvtt     FrameTextCodec = "wvtt"
	FrameTextCodecTtml     FrameTextCodec = "ttml"
	FrameTextCodecSubtitle FrameTextCodec = "subtitle"
	FrameTextCodecId3t     FrameTextCodec = "id3t"
	FrameTextCodecOnvif    FrameTextCodec = "onvif"
	FrameTextCodecTx3g     FrameTextCodec = "tx3g"
)

type FrameVideoCodec string

const (
	FrameVideoCodecH264   FrameVideoCodec = "h264"
	FrameVideoCodecHevc   FrameVideoCodec = "hevc"
	FrameVideoCodecMp2v   FrameVideoCodec = "mp2v"
	FrameVideoCodecVp9    FrameVideoCodec = "vp9"
	FrameVideoCodecMjpeg  FrameVideoCodec = "mjpeg"
	FrameVideoCodecScreen FrameVideoCodec = "screen"
	FrameVideoCodecJpeg   FrameVideoCodec = "jpeg"
	FrameVideoCodecAv1    FrameVideoCodec = "av1"
	FrameVideoCodecJ2k    FrameVideoCodec = "j2k"
)

type FrameVideoPixFmt string

const (
	FrameVideoPixFmtYuv420p   FrameVideoPixFmt = "yuv420p"
	FrameVideoPixFmtYuvj420p  FrameVideoPixFmt = "yuvj420p"
	FrameVideoPixFmtYuv422p   FrameVideoPixFmt = "yuv422p"
	FrameVideoPixFmtYuv444p   FrameVideoPixFmt = "yuv444p"
	FrameVideoPixFmtYuv420p10 FrameVideoPixFmt = "yuv420p10"
	FrameVideoPixFmtYuv422p10 FrameVideoPixFmt = "yuv422p10"
	FrameVideoPixFmtYuv444p10 FrameVideoPixFmt = "yuv444p10"
	FrameVideoPixFmtYuv420p12 FrameVideoPixFmt = "yuv420p12"
	FrameVideoPixFmtYuv422p12 FrameVideoPixFmt = "yuv422p12"
	FrameVideoPixFmtYuv444p12 FrameVideoPixFmt = "yuv444p12"
	FrameVideoPixFmtGray8     FrameVideoPixFmt = "gray8"
	FrameVideoPixFmtGray10    FrameVideoPixFmt = "gray10"
	FrameVideoPixFmtGray12    FrameVideoPixFmt = "gray12"
	FrameVideoPixFmtNv12      FrameVideoPixFmt = "nv12"
	FrameVideoPixFmtP016      FrameVideoPixFmt = "p016"
	FrameVideoPixFmtV210      FrameVideoPixFmt = "v210"
	FrameVideoPixFmtUyvy422   FrameVideoPixFmt = "uyvy422"
	FrameVideoPixFmtYuyv422   FrameVideoPixFmt = "yuyv422"
	FrameVideoPixFmtRgb48     FrameVideoPixFmt = "rgb48"
	FrameVideoPixFmtArgb      FrameVideoPixFmt = "argb"
	FrameVideoPixFmtX2rgb10be FrameVideoPixFmt = "x2rgb10be"
)

type GenlockStatus string

const (
	GenlockStatusNoRef        GenlockStatus = "no_ref"
	GenlockStatusLocking      GenlockStatus = "locking"
	GenlockStatusLocked       GenlockStatus = "locked"
	GenlockStatusInvalid      GenlockStatus = "invalid"
	GenlockStatusNotSupported GenlockStatus = "not_supported"
	GenlockStatusUnknown      GenlockStatus = "unknown"
)

type H264Level string

type HevcLevel string

type InterlaceSettings interface{}

type LicenseType string

type ListenSpec interface{}

// The level of logging according to event importance. Several values separated by comma.
type Loglevel string

const (
	// Logging disabled.
	LoglevelNone Loglevel = "none"
	// Messages of all types are logged.
	LoglevelDebug Loglevel = "debug"
	// Log info messages.
	LoglevelInfo Loglevel = "info"
	// Log notices.
	LoglevelNotice Loglevel = "notice"
	// Log warnings.
	LoglevelWarning Loglevel = "warning"
	// Log errors.
	LoglevelError Loglevel = "error"
	// Log alerts.
	LoglevelAlert Loglevel = "alert"
	// Log critical messages.
	LoglevelCritical Loglevel = "critical"
)

type Mp2vLevel string

const (
	Mp2vLevelLow      Mp2vLevel = "low"
	Mp2vLevelMain     Mp2vLevel = "main"
	Mp2vLevelHigh     Mp2vLevel = "high"
	Mp2vLevelHigh1440 Mp2vLevel = "high1440"
)

type MpegtsLangTrack string

type NamedBy string

const (
	// Media is described in file on local disk
	NamedByConfig NamedBy = "config"
	// Media was started and configured by user request: play or publish
	//
	NamedByUser NamedBy = "user"
	// Media was sourced from another streamer via `source` directive
	NamedByRemote NamedBy = "remote"
	// Media was configured via config_external backend
	NamedByExternal NamedBy = "external"
)

type OutputAudio string

const (
	// Keep the original audio codec.
	OutputAudioKeep OutputAudio = "keep"
	// Keep AAC if available or transcode to AAC; delete other tracks if any.
	OutputAudioAac OutputAudio = "aac"
	// Add AAC if it was not available already while keeping the original track.
	OutputAudioAddAac OutputAudio = "add_aac"
	// Make silence in audio track by using AAC codec. Replace original non-AAC track to AAC.
	OutputAudioAacSilence OutputAudio = "aac_silence"
	// Make silence in audio track by using original audio codec.
	OutputAudioKeepSilence OutputAudio = "keep_silence"
)

type OutputMpegtsAc3 string

const (
	OutputMpegtsAc3SystemB OutputMpegtsAc3 = "system_b"
	OutputMpegtsAc3SystemA OutputMpegtsAc3 = "system_a"
	OutputMpegtsAc3Keep    OutputMpegtsAc3 = "keep"
)

type PreviousServerState string

type Protocol string

const (
	ProtocolCopy         Protocol = "copy"
	ProtocolFake         Protocol = "fake"
	ProtocolRTP          Protocol = "rtp"
	ProtocolRtmp         Protocol = "rtmp"
	ProtocolRtmps        Protocol = "rtmps"
	ProtocolRtmpe        Protocol = "rtmpe"
	ProtocolRtsp         Protocol = "rtsp"
	ProtocolRtspUDP      Protocol = "rtsp-udp"
	ProtocolRtsp2        Protocol = "rtsp2"
	ProtocolRtsps        Protocol = "rtsps"
	ProtocolEst          Protocol = "est"
	ProtocolSrt          Protocol = "srt"
	ProtocolMseld        Protocol = "mseld"
	ProtocolShoutcast    Protocol = "shoutcast"
	ProtocolShoutcasts   Protocol = "shoutcasts"
	ProtocolWebrtc       Protocol = "webrtc"
	ProtocolHls          Protocol = "hls"
	ProtocolHlss         Protocol = "hlss"
	ProtocolHls2         Protocol = "hls2"
	ProtocolHlss2        Protocol = "hlss2"
	ProtocolLlhls        Protocol = "llhls"
	ProtocolCmaf         Protocol = "cmaf"
	ProtocolDash         Protocol = "dash"
	ProtocolMss          Protocol = "mss"
	ProtocolM4s          Protocol = "m4s"
	ProtocolM4ss         Protocol = "m4ss"
	ProtocolM4f          Protocol = "m4f"
	ProtocolM4fs         Protocol = "m4fs"
	ProtocolTshttp       Protocol = "tshttp"
	ProtocolTshttps      Protocol = "tshttps"
	ProtocolTstcp        Protocol = "tstcp"
	ProtocolTsssl        Protocol = "tsssl"
	ProtocolFlv          Protocol = "flv"
	ProtocolAnnexb       Protocol = "annexb"
	ProtocolUDP          Protocol = "udp"
	ProtocolUdp1         Protocol = "udp1"
	ProtocolUdp2         Protocol = "udp2"
	ProtocolUdp3         Protocol = "udp3"
	ProtocolMptsUDP      Protocol = "mpts-udp"
	ProtocolMptsHTTP     Protocol = "mpts-http"
	ProtocolMptsHTTPS    Protocol = "mpts-https"
	ProtocolMptsDvb      Protocol = "mpts-dvb"
	ProtocolDvb          Protocol = "dvb"
	ProtocolDecklink     Protocol = "decklink"
	ProtocolDektec       Protocol = "dektec"
	ProtocolDektecAsi    Protocol = "dektec-asi"
	ProtocolV4l          Protocol = "v4l"
	ProtocolV4l2         Protocol = "v4l2"
	ProtocolPlaylist     Protocol = "playlist"
	ProtocolMixer        Protocol = "mixer"
	ProtocolMosaic       Protocol = "mosaic"
	ProtocolMosaic2      Protocol = "mosaic2"
	ProtocolTimeshift    Protocol = "timeshift"
	ProtocolFile         Protocol = "file"
	ProtocolDownload     Protocol = "download"
	ProtocolMbr          Protocol = "mbr"
	ProtocolMp4          Protocol = "mp4"
	ProtocolLogo         Protocol = "logo"
	ProtocolJpeg         Protocol = "jpeg"
	ProtocolMjpeg        Protocol = "mjpeg"
	ProtocolH323         Protocol = "h323"
	ProtocolAdInjector   Protocol = "ad_injector"
	ProtocolFfmpeg       Protocol = "ffmpeg"
	ProtocolTransponder  Protocol = "transponder"
	ProtocolAPI          Protocol = "api"
	ProtocolJSONManifest Protocol = "json_manifest"
	ProtocolPlayer       Protocol = "player"
	ProtocolNdi          Protocol = "ndi"
	ProtocolFrip         Protocol = "frip"
	ProtocolSt2110       Protocol = "st2110"
	ProtocolBackup       Protocol = "backup"
	ProtocolMxl          Protocol = "mxl"
)

type PusherStandbyStatus string

const (
	PusherStandbyStatusActive  PusherStandbyStatus = "active"
	PusherStandbyStatusWaiting PusherStandbyStatus = "waiting"
)

type PusherStatus interface{}

type RaidDiskMode string

const (
	// Flussonic reads the data from and writes it to the hard drive, removing the data according to the DVR settings.
	// The default mode.
	//
	RaidDiskModeNormal RaidDiskMode = "normal"
	// Flussonic migrates the data from the current hard drive to other hard drives in the array on the fly, cleaning up the current hard drive.
	// You can check that Flussonic finished migrating the data, when there aren't any calls to this hard drive.
	// In the meantime, Flussonic continues archive recording, so it isn't interrupted. You don't need to restart Flussonic after you remove the disk.
	// Use this option if you need to extract the hard drive and don't want to lose the data.
	//
	RaidDiskModeMigrate RaidDiskMode = "migrate"
	// Flussonic reads the data from the hard drive, restricting any writing to it. Use this option in the following cases:
	// Flussonic reads the data from the hard drive until the data on it expires. Then Flussonic deletes the data.
	// * If the hard drive is worn out and you can't write the data to the hard drive, delete files, update the index, or copy the data to another hard drive.
	// * If the hard drive stores the records written in the `keep` mode and you want to store the data permanently.
	//
	RaidDiskModeReadonly RaidDiskMode = "readonly"
	// Flussonic copies all the data from the old hard drive that's going to fail and stops writing the data to this hard drive.
	// Flussonic doesn't delete the data from the hard drive, unlike in `migrate` mode, so you can still access the archive.
	// Use this option in an emergency.
	//
	RaidDiskModeRescue RaidDiskMode = "rescue"
	// Flussonic stops writing new data on this hard drive. When the data becomes obsolete, Flussonic deletes it, updating the index.
	// Use this option when you want to replace a hard drive, for example, with a larger one.
	//
	RaidDiskModeAbandon RaidDiskMode = "abandon"
	// Flussonic writes the data to the hard drive, but doesn't delete it.
	// Use this option if you need to store the entire archive permanently.
	//
	RaidDiskModeKeep RaidDiskMode = "keep"
)

type RcMethod string

const (
	// The encoder will not encode a stream to be DVB compliant.
	// However, VBR (Variable Bit Rate) produces better compression compared to CBR at about the same quality.
	//
	RcMethodVbr RcMethod = "vbr"
	// The encoder will produce a DVB compliant stream.
	// The bitrate of the output stream will be stable to fit the fixed-bandwidth channel.
	// In other words, we guarantee that the bitrate has a certain upper bound in a sliding window.
	//
	RcMethodCbr RcMethod = "cbr"
	// The encoder will encode the video once in CBR,
	// then it will encode it second time in CBR but using the information from the previous pass to improve quality.
	//
	RcMethodCbr2pass RcMethod = "cbr2pass"
)

// Reason of the error.
type RequestErrorReason string

const (
	// New configuration does not match reference.
	RequestErrorReasonValidationError RequestErrorReason = "validation_error"
	// Streamer could not get reply from the configuration server.
	RequestErrorReasonNetworkError RequestErrorReason = "network_error"
	// Configuration server returned an malformed json body.
	RequestErrorReasonMalformedJSON RequestErrorReason = "malformed_json"
	// Configuration server received an invalid request, e.g. required headers is missing or invalid authorization.
	RequestErrorReasonInvalidRequest RequestErrorReason = "invalid_request"
	// Configuration server returned an error for an unknown reason.
	RequestErrorReasonUnknown RequestErrorReason = "unknown"
)

type ScaleAlgorithm string

type ServerStatsStreamerStatus string

const (
	// The configuration file is not found at `/etc/flussonic/flussonic.conf`.
	ServerStatsStreamerStatusNoConfig ServerStatsStreamerStatus = "no_config"
	// There are some errors in the config file saved at `/etc/flussonic/flussonic.conf`.
	// Try checking logs and `text_alerts` for details.
	//
	ServerStatsStreamerStatusBrokenConfig ServerStatsStreamerStatus = "broken_config"
	// There are some errors during external config receiving or validating.
	// Try checking logs and `config_external_error` for details.
	//
	ServerStatsStreamerStatusConfigExternalError ServerStatsStreamerStatus = "config_external_error"
	// The license cannot be activated. Please contact the support team.
	ServerStatsStreamerStatusLicenseFailure ServerStatsStreamerStatus = "license_failure"
	// The license file is not found at `/etc/flussonic/license.txt`.
	ServerStatsStreamerStatusNoLicense ServerStatsStreamerStatus = "no_license"
	// The server is starting.
	ServerStatsStreamerStatusStarting ServerStatsStreamerStatus = "starting"
	// Normal operation mode.
	ServerStatsStreamerStatusRunning ServerStatsStreamerStatus = "running"
)

type SessionKey interface{}

type SessionStatus string

const (
	SessionStatusEstablishing SessionStatus = "establishing"
	SessionStatusRunning      SessionStatus = "running"
	SessionStatusStalling     SessionStatus = "stalling"
	SessionStatusFinished     SessionStatus = "finished"
)

type StreamStatus string

const (
	// Input is OK, stream is ready to be served to your audience.
	StreamStatusRunning StreamStatus = "running"
	// Flussonic awaits for input (publish) or it's an 'on demand' stream waiting for client.
	StreamStatusWaiting StreamStatus = "waiting"
	// Something is wrong and Flussonic is not able to serve the stream to your audience.
	StreamStatusError StreamStatus = "error"
)

type TcBitrate interface{}

type TcDeviceid interface{}

type TcFPS interface{}

type TcPreset string

const (
	TcPresetSlow      TcPreset = "slow"
	TcPresetMedium    TcPreset = "medium"
	TcPresetFast      TcPreset = "fast"
	TcPresetVeryfast  TcPreset = "veryfast"
	TcPresetUltrafast TcPreset = "ultrafast"
)

type TcProfile string

const (
	TcProfileSimple   TcProfile = "simple"
	TcProfileBaseline TcProfile = "baseline"
	TcProfileMain     TcProfile = "main"
	TcProfileMain10   TcProfile = "main10"
	TcProfileHigh     TcProfile = "high"
	TcProfileHigh10   TcProfile = "high10"
	TcProfileHigh422  TcProfile = "high422"
	TcProfileHigh444  TcProfile = "high444"
)

type TcReconfigSupport interface{}

type ThumbnailsEnabledSpec any

type TlsVersion string

const (
	TlsVersionTlsv1  TlsVersion = "tlsv1"
	TlsVersionTlsv11 TlsVersion = "tlsv1.1"
	TlsVersionTlsv12 TlsVersion = "tlsv1.2"
	TlsVersionTlsv13 TlsVersion = "tlsv1.3"
)

type TranscoderDevice string

const (
	TranscoderDeviceCpu   TranscoderDevice = "cpu"
	TranscoderDeviceQsv   TranscoderDevice = "qsv"
	TranscoderDeviceNvenc TranscoderDevice = "nvenc"
	TranscoderDeviceCoder TranscoderDevice = "coder"
)

type TranscoderResizeMode string

const (
	TranscoderResizeModeVic  TranscoderResizeMode = "vic"
	TranscoderResizeModeCuda TranscoderResizeMode = "cuda"
)

type TranscoderTarget string

const (
	// The resulting stream is ready to be transmitted over Ultra HD television networks
	// i.e. H.264 4K (2160p) with higher bitrate, BT.2020 colors
	// and AAC audio
	//
	TranscoderTargetUhdtv TranscoderTarget = "uhdtv"
	// The resulting stream is ready to be transmitted over HD television networks,
	// i.e. H.264 1080p with BT.709 colors
	// and AAC audio
	//
	TranscoderTargetHdtv TranscoderTarget = "hdtv"
	// The resulting stream is ready to be transmitted over older European (PAL) television networks,
	// i.e. H.264 576i video with lower bitrate, BT.470 colors, 16:11 SAR
	// and AAC audio
	//
	TranscoderTargetSdtvPal TranscoderTarget = "sdtv_pal"
	// The resulting stream is ready to be transmitted over older American (NTSC) television networks,
	// i.e. H.264 480i video with lower bitrate, SMPTE 170M colors, 40:33 SAR
	// and AC-3 audio
	//
	TranscoderTargetSdtvNtsc TranscoderTarget = "sdtv_ntsc"
)

type URLPrefix interface{}

type VbiLine int

type VbiService string

type VideoFormat string

const (
	// pal 720x576 @ 50Hz interlace SMPTE-259
	VideoFormatPal VideoFormat = "pal"
	// Similar PAL
	VideoFormat625I50 VideoFormat = "625i50"
	// NTSC 720x480 @ 59.94Hz interlace SMPTE-259
	VideoFormatNtsc VideoFormat = "ntsc"
	// Similar NTSC
	VideoFormat525I2997 VideoFormat = "525i29.97"
	// Similar NTSC
	VideoFormat525I29 VideoFormat = "525i29"
	// 1280x720 @ 23.98Hz progressive SMPTE-296
	VideoFormat720P2398 VideoFormat = "720p23.98"
	// Similar 720p23.98
	VideoFormat720P23   VideoFormat = "720p23"
	VideoFormat720P24   VideoFormat = "720p24"
	VideoFormat720P25   VideoFormat = "720p25"
	VideoFormat720P2997 VideoFormat = "720p29.97"
	VideoFormat720P29   VideoFormat = "720p29"
	VideoFormat720P30   VideoFormat = "720p30"
	VideoFormat720P50   VideoFormat = "720p50"
	VideoFormat720P5994 VideoFormat = "720p59.94"
	VideoFormat720P59   VideoFormat = "720p59"
	VideoFormat720P60   VideoFormat = "720p60"
	// 1920x1080 @ 23.98Hz progressive SMPTE-274
	VideoFormat1080P2398 VideoFormat = "1080p23.98"
	VideoFormat1080P23   VideoFormat = "1080p23"
	VideoFormat1080P24   VideoFormat = "1080p24"
	VideoFormat1080P25   VideoFormat = "1080p25"
	VideoFormat1080P2997 VideoFormat = "1080p29.97"
	VideoFormat1080P29   VideoFormat = "1080p29"
	VideoFormat1080P30   VideoFormat = "1080p30"
	// 1920x1080 @ 23.98Hz progressive Progressive segmented Frame SMPTE-274
	VideoFormat1080Psf2398 VideoFormat = "1080psf23.98"
	VideoFormat1080Psf23   VideoFormat = "1080psf23"
	VideoFormat1080Psf24   VideoFormat = "1080psf24"
	VideoFormat1080Psf25   VideoFormat = "1080psf25"
	VideoFormat1080Psf2997 VideoFormat = "1080psf29.97"
	VideoFormat1080Psf29   VideoFormat = "1080psf29"
	VideoFormat1080Psf30   VideoFormat = "1080psf30"
	VideoFormat1080I50     VideoFormat = "1080i50"
	VideoFormat1080I5994   VideoFormat = "1080i59.94"
	VideoFormat1080I60     VideoFormat = "1080i60"
	// 1920x1080 @ 50Hz progressive annex A or annex B depending hardware SMPTE-274
	VideoFormat1080P50 VideoFormat = "1080p50"
	// 1920x1080 @ 50Hz progressive annex B SMPTE-274
	VideoFormat1080P50b   VideoFormat = "1080p50b"
	VideoFormat1080P5994  VideoFormat = "1080p59.94"
	VideoFormat1080P59    VideoFormat = "1080p59"
	VideoFormat1080P5994B VideoFormat = "1080p59.94b"
	VideoFormat1080P59b   VideoFormat = "1080p59b"
	VideoFormat1080P60    VideoFormat = "1080p60"
	VideoFormat1080P60b   VideoFormat = "1080p60b"
	// 4k 3840x2160 @ 50Hz progressive SMPTE-2036
	VideoFormat2160P50    VideoFormat = "2160p50"
	VideoFormat2160P50b   VideoFormat = "2160p50b"
	VideoFormat2160P5994  VideoFormat = "2160p59.94"
	VideoFormat2160P59    VideoFormat = "2160p59"
	VideoFormat2160P5994B VideoFormat = "2160p59.94b"
	VideoFormat2160P59b   VideoFormat = "2160p59b"
	VideoFormat2160P60    VideoFormat = "2160p60"
	VideoFormat2160P60b   VideoFormat = "2160p60b"
	VideoFormat2160P23    VideoFormat = "2160p23"
	VideoFormat2160P24    VideoFormat = "2160p24"
	VideoFormat2160P25    VideoFormat = "2160p25"
	VideoFormat2160P29    VideoFormat = "2160p29"
	VideoFormat2160P30    VideoFormat = "2160p30"
)

type VisionDetector string

const (
	VisionDetectorFaces    VisionDetector = "faces"
	VisionDetectorVehicles VisionDetector = "vehicles"
	VisionDetectorMotion   VisionDetector = "motion"
	VisionDetectorQrCodes  VisionDetector = "qr-codes"
	VisionDetectorHumans   VisionDetector = "humans"
)

type VisionImageMimetype string

const (
	// jpeg
	VisionImageMimetypeImageJpeg VisionImageMimetype = "image/jpeg"
)

// Object class
type VisionObjectClass string

const (
	VisionObjectClassFace         VisionObjectClass = "face"
	VisionObjectClassLicensePlate VisionObjectClass = "license_plate"
	VisionObjectClassVehicle      VisionObjectClass = "vehicle"
	VisionObjectClassHuman        VisionObjectClass = "human"
)

type VisionPersonOriginator string

const (
	// Person is created by operator or external system via API.
	// For example, when you add the person in Watcher UI, it has `originator=api`.
	// But when you edit an automatically created person in UI, `originator=identification_service` remains.
	//
	VisionPersonOriginatorAPI VisionPersonOriginator = "api"
	// Person is created automatically by the Identification service
	// because no matching person was found in the persons database.
	//
	// The Identification service stores unrecognized persons and matches new episodes with them
	// in case if it becomes known who this is (i.e. if operator edits such person in UI to specify name).
	//
	VisionPersonOriginatorIdentificationService VisionPersonOriginator = "identification_service"
)

// Emergency type of the vehicle, e.g. ambulance, police, firetruck.
type VisionVehicleEmergencySubtype string

const (
	// ambulance car
	VisionVehicleEmergencySubtypeAmbulance VisionVehicleEmergencySubtype = "ambulance"
	// police car
	VisionVehicleEmergencySubtypePolice VisionVehicleEmergencySubtype = "police"
	// firetruck car
	VisionVehicleEmergencySubtypeFiretruck VisionVehicleEmergencySubtype = "firetruck"
)

// Shows from which side the vehicle was detected.
type VisionVehicleFacingSide string

const (
	// The vehicle was detected from the front.
	VisionVehicleFacingSideFront VisionVehicleFacingSide = "front"
	// The vehicle was detected from the rear.
	VisionVehicleFacingSideRear VisionVehicleFacingSide = "rear"
)

// The purpose of the vehicle, e.g. emergency or regular.
// Police, ambulance cars and firetrucks are being detected by the videoanalytics as `emergency`.
// Any other type of vehicle is marked as `regular`.
type VisionVehiclePurpose string

const (
	// Regular car
	VisionVehiclePurposeRegular VisionVehiclePurpose = "regular"
	// Emergency vehicle (police, ambulance or firetruck)
	VisionVehiclePurposeEmergency VisionVehiclePurpose = "emergency"
)

type WebrtcPreferVideoCodec string

type WebrtcTransport string

const (
	WebrtcTransportUDP WebrtcTransport = "udp"
	WebrtcTransportTCP WebrtcTransport = "tcp"
)

type APICall interface {
	// Creation date and time
	// Format: date_time (date_time)
	// Example: 2021-01-30T08:30:00.432567Z
	CreatedAt() *DateTime
	// Creation date and time
	// Format: date_time (date_time)
	// Example: 2021-01-30T08:30:00.432567Z
	SetCreatedAt(DateTime) APICall
	// Microseconds that this request took
	// Format: microseconds (microseconds)
	Duration() *Microseconds
	// Microseconds that this request took
	// Format: microseconds (microseconds)
	SetDuration(Microseconds) APICall
	// IP address of the caller.
	// Format: ip (ip)
	// Example: 192.34.32.10
	IP() *IP
	// IP address of the caller.
	// Format: ip (ip)
	// Example: 192.34.32.10
	SetIP(IP) APICall
	// API method ID.
	// Example: streams_list
	OperationID() *string
	// API method ID.
	// Example: streams_list
	SetOperationID(string) APICall
	// The program produced the API call. Content of `X-Originator` header.
	// Example: flussonic
	Originator() *string
	// The program produced the API call. Content of `X-Originator` header.
	// Example: flussonic
	SetOriginator(string) APICall
	// Payload data transmitter in the API call.
	Payload() *string
	// Payload data transmitter in the API call.
	SetPayload(string) APICall
	// Internal request-id for this operation
	RequestID() *string
	// Internal request-id for this operation
	SetRequestID(string) APICall
	// Request status code.
	Status() *int
	// Request status code.
	SetStatus(int) APICall
	// The type of the device from which the API call was produced.
	// Example: Flussonic 24.04
	UserAgent() *string
	// The type of the device from which the API call was produced.
	// Example: Flussonic 24.04
	SetUserAgent(string) APICall
}

type APICallEvent interface {
	// Creation date and time
	// Format: date_time (date_time)
	// Example: 2021-01-30T08:30:00.432567Z
	CreatedAt() *DateTime
	// Creation date and time
	// Format: date_time (date_time)
	// Example: 2021-01-30T08:30:00.432567Z
	SetCreatedAt(DateTime) APICallEvent
	// Microseconds that this request took
	// Format: microseconds (microseconds)
	Duration() *Microseconds
	// Microseconds that this request took
	// Format: microseconds (microseconds)
	SetDuration(Microseconds) APICallEvent
	// Unique identifier of the entity.
	// For example, for `agent` it is `agent_id` field.
	EntityID() *string
	// Unique identifier of the entity.
	// For example, for `agent` it is `agent_id` field.
	SetEntityID(string) APICallEvent
	// Type of the entity.
	EntityType() *EntityEventEntityType
	// Type of the entity.
	SetEntityType(EntityEventEntityType) APICallEvent
	// The api call.
	Event() string
	// The api call.
	SetEvent(string) APICallEvent
	// Event identifier.
	EventID() *int
	// Event identifier.
	SetEventID(int) APICallEvent
	// IP address of the caller.
	// Format: ip (ip)
	// Example: 192.34.32.10
	IP() *IP
	// IP address of the caller.
	// Format: ip (ip)
	// Example: 192.34.32.10
	SetIP(IP) APICallEvent
	// API method ID.
	// Example: streams_list
	OperationID() *string
	// API method ID.
	// Example: streams_list
	SetOperationID(string) APICallEvent
	// The program produced the API call. Content of `X-Originator` header.
	// Example: flussonic
	Originator() *string
	// The program produced the API call. Content of `X-Originator` header.
	// Example: flussonic
	SetOriginator(string) APICallEvent
	// The api call path.
	Path() *string
	// The api call path.
	SetPath(string) APICallEvent
	// Payload data transmitter in the API call.
	Payload() *string
	// Payload data transmitter in the API call.
	SetPayload(string) APICallEvent
	// The api call query string.
	Qs() *string
	// The api call query string.
	SetQs(string) APICallEvent
	// Internal request-id for this operation
	RequestID() *string
	// Internal request-id for this operation
	SetRequestID(string) APICallEvent
	// Originator of event.
	// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
	// is configured as HTTP/HTTPS url.
	// Example: flussonic.host
	Server() *string
	// Originator of event.
	// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
	// is configured as HTTP/HTTPS url.
	// Example: flussonic.host
	SetServer(string) APICallEvent
	// Request status code.
	Status() *int
	// Request status code.
	SetStatus(int) APICallEvent
	// Unique identifier of the operation.
	// You can use this field to search for events related to same operation.
	// Value of this field is taken from the `X-Trace-Id` header.
	// If `X-Trace-Id` header is not set, it will be generated automatically.
	// Service will use the value of this field to make outgoing requests.
	// Format: uuid (uuid)
	// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
	TraceID() *UUID
	// Unique identifier of the operation.
	// You can use this field to search for events related to same operation.
	// Value of this field is taken from the `X-Trace-Id` header.
	// If `X-Trace-Id` header is not set, it will be generated automatically.
	// Service will use the value of this field to make outgoing requests.
	// Format: uuid (uuid)
	// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
	SetTraceID(UUID) APICallEvent
	// The type of the device from which the API call was produced.
	// Example: Flussonic 24.04
	UserAgent() *string
	// The type of the device from which the API call was produced.
	// Example: Flussonic 24.04
	SetUserAgent(string) APICallEvent
	// The time of the event registration on the server.
	// Format: utc_ms (Unix timestamp in milliseconds)
	UtcMs() *UtcMs
	// The time of the event registration on the server.
	// Format: utc_ms (Unix timestamp in milliseconds)
	SetUtcMs(UtcMs) APICallEvent
}

// This object describes one API token with its unique text, permissions, etc.
// Required: key, name
type APIToken interface {
	// A list of scopes that restrict the permissions of this API token.
	// The system sets these scopes based on the context and limitations present when the token is created.
	// For example, this can be used to specify a particular user or other constraints.
	// The token cannot have permissions beyond those defined in this array.
	// Examples: [user/15]
	AuthScopes() []string
	// A list of scopes that restrict the permissions of this API token.
	// The system sets these scopes based on the context and limitations present when the token is created.
	// For example, this can be used to specify a particular user or other constraints.
	// The token cannot have permissions beyond those defined in this array.
	// Examples: [user/15]
	SetAuthScopes([]string) APIToken
	// Unique secret string generated by server.
	// Examples: $5$tz/6I0KpagoQ9kQN$nnnKQCxuhCOCaZ7q9WEWvHo6.dRb2hawYofHPdAhHV., 1234, IJCo3KGLBf6NAqMCGgHf5gNhpl9
	Key() string
	// Unique secret string generated by server.
	// Examples: $5$tz/6I0KpagoQ9kQN$nnnKQCxuhCOCaZ7q9WEWvHo6.dRb2hawYofHPdAhHV., 1234, IJCo3KGLBf6NAqMCGgHf5gNhpl9
	SetKey(string) APIToken
	// unique name of the token that can be used to distinguish tokens
	// Examples: inference_server, root
	Name() string
	// unique name of the token that can be used to distinguish tokens
	// Examples: inference_server, root
	SetName(string) APIToken
	// list of independent permissions, available for this token
	Permissions() []APITokenPermission
	// list of independent permissions, available for this token
	SetPermissions([]APITokenPermission) APIToken
}

// Required: scopes
type APITokenPermission interface {
	// executing this function (if it is a function) is allowed
	Execute() *bool
	// executing this function (if it is a function) is allowed
	SetExecute(bool) APITokenPermission
	// listing items is allowed
	List() *bool
	// listing items is allowed
	SetList(bool) APITokenPermission
	// reading one item is allowed
	Read() *bool
	// reading one item is allowed
	SetRead(bool) APITokenPermission
	// List of permission scopes that will be intersected
	// Each scope is a name of the collection or a function with nested resource name
	// that is covered with this permission
	// Examples: [*], [streams/*], [streams/location1%2F*]
	Scopes() []string
	// List of permission scopes that will be intersected
	// Each scope is a name of the collection or a function with nested resource name
	// that is covered with this permission
	// Examples: [*], [streams/*], [streams/location1%2F*]
	SetScopes([]string) APITokenPermission
	// writing/updating/deletion one item is allowed
	Write() *bool
	// writing/updating/deletion one item is allowed
	SetWrite(bool) APITokenPermission
}

type APITokensList interface {
	// List of available api tokens
	APITokens() []APIToken
	// List of available api tokens
	SetAPITokens([]APIToken) APITokensList
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	EstimatedCount() *int
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	SetEstimatedCount(int) APITokensList
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	Next() *string
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	SetNext(string) APITokensList
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	Prev() *string
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	SetPrev(string) APITokensList
	// An object with a list of different timings measured during this API call.
	Timing() any
	// An object with a list of different timings measured during this API call.
	SetTiming(any) APITokensList
	// Collection returns the collection items
	Collection() []APIToken
}

// Required: login, password
type AdminCredentials interface {
	// Login
	// Example: secretlogin
	Login() string
	// Login
	// Example: secretlogin
	SetLogin(string) AdminCredentials
	// Password
	// Format: password (password)
	// Example: passw
	Password() Password
	// Password
	// Format: password (password)
	// Example: passw
	SetPassword(Password) AdminCredentials
}

type AgentCommandHandling interface {
	// Command name.
	// Example: streampoint_connect
	Command() *AgentCommandHandlingCommand
	// Command name.
	// Example: streampoint_connect
	SetCommand(AgentCommandHandlingCommand) AgentCommandHandling
	// Unique identifier of the entity.
	// For example, for `agent` it is `agent_id` field.
	EntityID() *string
	// Unique identifier of the entity.
	// For example, for `agent` it is `agent_id` field.
	SetEntityID(string) AgentCommandHandling
	// Type of the entity.
	EntityType() *EntityEventEntityType
	// Type of the entity.
	SetEntityType(EntityEventEntityType) AgentCommandHandling
	// Error message explaining why command failed.
	// If command was successful, this field absent.
	Error() *AgentCommandHandlingError
	// Error message explaining why command failed.
	// If command was successful, this field absent.
	SetError(AgentCommandHandlingError) AgentCommandHandling
	// Event of handling commands via the interaction protocol between the agent and the endpoint.
	Event() string
	// Event of handling commands via the interaction protocol between the agent and the endpoint.
	SetEvent(string) AgentCommandHandling
	// Event identifier.
	EventID() *int
	// Event identifier.
	SetEventID(int) AgentCommandHandling
	Initiator() *AgentInitiator
	SetInitiator(AgentInitiator) AgentCommandHandling
	// Payload of the command.
	Payload() *string
	// Payload of the command.
	SetPayload(string) AgentCommandHandling
	// Originator of event.
	// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
	// is configured as HTTP/HTTPS url.
	// Example: flussonic.host
	Server() *string
	// Originator of event.
	// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
	// is configured as HTTP/HTTPS url.
	// Example: flussonic.host
	SetServer(string) AgentCommandHandling
	// Unique identifier of the operation.
	// You can use this field to search for events related to same operation.
	// Value of this field is taken from the `X-Trace-Id` header.
	// If `X-Trace-Id` header is not set, it will be generated automatically.
	// Service will use the value of this field to make outgoing requests.
	// Format: uuid (uuid)
	// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
	TraceID() *UUID
	// Unique identifier of the operation.
	// You can use this field to search for events related to same operation.
	// Value of this field is taken from the `X-Trace-Id` header.
	// If `X-Trace-Id` header is not set, it will be generated automatically.
	// Service will use the value of this field to make outgoing requests.
	// Format: uuid (uuid)
	// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
	SetTraceID(UUID) AgentCommandHandling
	// The time of the event registration on the server.
	// Format: utc_ms (Unix timestamp in milliseconds)
	UtcMs() *UtcMs
	// The time of the event registration on the server.
	// Format: utc_ms (Unix timestamp in milliseconds)
	SetUtcMs(UtcMs) AgentCommandHandling
}

type AgentConfigBase interface {
	// Agent identifier
	// Example: 1234567
	ID() *string
	// Agent identifier
	// Example: 1234567
	SetID(string) AgentConfigBase
	// Agent authentication key.
	Key() *string
	// Agent authentication key.
	SetKey(string) AgentConfigBase
	// Agents's metrics and other statistical information.
	Stats() WatcherAgentStats
	// Agents's metrics and other statistical information.
	SetStats(WatcherAgentStats) AgentConfigBase
}

type AgentConnectFailed interface {
	// Unique identifier of the entity.
	// For example, for `agent` it is `agent_id` field.
	EntityID() *string
	// Unique identifier of the entity.
	// For example, for `agent` it is `agent_id` field.
	SetEntityID(string) AgentConnectFailed
	// Type of the entity.
	EntityType() *EntityEventEntityType
	// Type of the entity.
	SetEntityType(EntityEventEntityType) AgentConnectFailed
	// Agent failed to connect to endpoint.
	Event() string
	// Agent failed to connect to endpoint.
	SetEvent(string) AgentConnectFailed
	// Event identifier.
	EventID() *int
	// Event identifier.
	SetEventID(int) AgentConnectFailed
	// Additional information about the error.
	Message() *string
	// Additional information about the error.
	SetMessage(string) AgentConnectFailed
	// Why agent failed to connect.
	Reason() *AgentConnectFailedReason
	// Why agent failed to connect.
	SetReason(AgentConnectFailedReason) AgentConnectFailed
	// Originator of event.
	// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
	// is configured as HTTP/HTTPS url.
	// Example: flussonic.host
	Server() *string
	// Originator of event.
	// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
	// is configured as HTTP/HTTPS url.
	// Example: flussonic.host
	SetServer(string) AgentConnectFailed
	// Unique identifier of the operation.
	// You can use this field to search for events related to same operation.
	// Value of this field is taken from the `X-Trace-Id` header.
	// If `X-Trace-Id` header is not set, it will be generated automatically.
	// Service will use the value of this field to make outgoing requests.
	// Format: uuid (uuid)
	// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
	TraceID() *UUID
	// Unique identifier of the operation.
	// You can use this field to search for events related to same operation.
	// Value of this field is taken from the `X-Trace-Id` header.
	// If `X-Trace-Id` header is not set, it will be generated automatically.
	// Service will use the value of this field to make outgoing requests.
	// Format: uuid (uuid)
	// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
	SetTraceID(UUID) AgentConnectFailed
	// The time of the event registration on the server.
	// Format: utc_ms (Unix timestamp in milliseconds)
	UtcMs() *UtcMs
	// The time of the event registration on the server.
	// Format: utc_ms (Unix timestamp in milliseconds)
	SetUtcMs(UtcMs) AgentConnectFailed
}

type AgentConnected interface {
	// Unique identifier of the entity.
	// For example, for `agent` it is `agent_id` field.
	EntityID() *string
	// Unique identifier of the entity.
	// For example, for `agent` it is `agent_id` field.
	SetEntityID(string) AgentConnected
	// Type of the entity.
	EntityType() *EntityEventEntityType
	// Type of the entity.
	SetEntityType(EntityEventEntityType) AgentConnected
	// Agent successfully connected to endpoint.
	Event() string
	// Agent successfully connected to endpoint.
	SetEvent(string) AgentConnected
	// Event identifier.
	EventID() *int
	// Event identifier.
	SetEventID(int) AgentConnected
	// Originator of event.
	// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
	// is configured as HTTP/HTTPS url.
	// Example: flussonic.host
	Server() *string
	// Originator of event.
	// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
	// is configured as HTTP/HTTPS url.
	// Example: flussonic.host
	SetServer(string) AgentConnected
	// Unique identifier of the operation.
	// You can use this field to search for events related to same operation.
	// Value of this field is taken from the `X-Trace-Id` header.
	// If `X-Trace-Id` header is not set, it will be generated automatically.
	// Service will use the value of this field to make outgoing requests.
	// Format: uuid (uuid)
	// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
	TraceID() *UUID
	// Unique identifier of the operation.
	// You can use this field to search for events related to same operation.
	// Value of this field is taken from the `X-Trace-Id` header.
	// If `X-Trace-Id` header is not set, it will be generated automatically.
	// Service will use the value of this field to make outgoing requests.
	// Format: uuid (uuid)
	// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
	SetTraceID(UUID) AgentConnected
	// The time of the event registration on the server.
	// Format: utc_ms (Unix timestamp in milliseconds)
	UtcMs() *UtcMs
	// The time of the event registration on the server.
	// Format: utc_ms (Unix timestamp in milliseconds)
	SetUtcMs(UtcMs) AgentConnected
}

type AgentDisconnected interface {
	// Unique identifier of the entity.
	// For example, for `agent` it is `agent_id` field.
	EntityID() *string
	// Unique identifier of the entity.
	// For example, for `agent` it is `agent_id` field.
	SetEntityID(string) AgentDisconnected
	// Type of the entity.
	EntityType() *EntityEventEntityType
	// Type of the entity.
	SetEntityType(EntityEventEntityType) AgentDisconnected
	// Agent disconnected from endpoint.
	Event() string
	// Agent disconnected from endpoint.
	SetEvent(string) AgentDisconnected
	// Event identifier.
	EventID() *int
	// Event identifier.
	SetEventID(int) AgentDisconnected
	Initiator() *AgentInitiator
	SetInitiator(AgentInitiator) AgentDisconnected
	// Why agent disconnected
	Reason() *AgentDisconnectedReason
	// Why agent disconnected
	SetReason(AgentDisconnectedReason) AgentDisconnected
	// Originator of event.
	// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
	// is configured as HTTP/HTTPS url.
	// Example: flussonic.host
	Server() *string
	// Originator of event.
	// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
	// is configured as HTTP/HTTPS url.
	// Example: flussonic.host
	SetServer(string) AgentDisconnected
	// Unique identifier of the operation.
	// You can use this field to search for events related to same operation.
	// Value of this field is taken from the `X-Trace-Id` header.
	// If `X-Trace-Id` header is not set, it will be generated automatically.
	// Service will use the value of this field to make outgoing requests.
	// Format: uuid (uuid)
	// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
	TraceID() *UUID
	// Unique identifier of the operation.
	// You can use this field to search for events related to same operation.
	// Value of this field is taken from the `X-Trace-Id` header.
	// If `X-Trace-Id` header is not set, it will be generated automatically.
	// Service will use the value of this field to make outgoing requests.
	// Format: uuid (uuid)
	// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
	SetTraceID(UUID) AgentDisconnected
	// The time of the event registration on the server.
	// Format: utc_ms (Unix timestamp in milliseconds)
	UtcMs() *UtcMs
	// The time of the event registration on the server.
	// Format: utc_ms (Unix timestamp in milliseconds)
	SetUtcMs(UtcMs) AgentDisconnected
}

type AgentMakeStreampointLocationError interface {
	// Unique identifier of the entity.
	// For example, for `agent` it is `agent_id` field.
	EntityID() *string
	// Unique identifier of the entity.
	// For example, for `agent` it is `agent_id` field.
	SetEntityID(string) AgentMakeStreampointLocationError
	// Type of the entity.
	EntityType() *EntityEventEntityType
	// Type of the entity.
	SetEntityType(EntityEventEntityType) AgentMakeStreampointLocationError
	// Failed to make streampoint location for agent.
	Event() *string
	// Failed to make streampoint location for agent.
	SetEvent(string) AgentMakeStreampointLocationError
	// Event identifier.
	EventID() *int
	// Event identifier.
	SetEventID(int) AgentMakeStreampointLocationError
	// Additional information about the error.
	Message() *string
	// Additional information about the error.
	SetMessage(string) AgentMakeStreampointLocationError
	// Why agent failed to make streampoint location.
	Reason() *AgentMakeStreampointLocationErrorReason
	// Why agent failed to make streampoint location.
	SetReason(AgentMakeStreampointLocationErrorReason) AgentMakeStreampointLocationError
	// Originator of event.
	// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
	// is configured as HTTP/HTTPS url.
	// Example: flussonic.host
	Server() *string
	// Originator of event.
	// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
	// is configured as HTTP/HTTPS url.
	// Example: flussonic.host
	SetServer(string) AgentMakeStreampointLocationError
	// The hostname of current agent's streampoint.
	Streampoint() *string
	// The hostname of current agent's streampoint.
	SetStreampoint(string) AgentMakeStreampointLocationError
	// Unique identifier of the operation.
	// You can use this field to search for events related to same operation.
	// Value of this field is taken from the `X-Trace-Id` header.
	// If `X-Trace-Id` header is not set, it will be generated automatically.
	// Service will use the value of this field to make outgoing requests.
	// Format: uuid (uuid)
	// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
	TraceID() *UUID
	// Unique identifier of the operation.
	// You can use this field to search for events related to same operation.
	// Value of this field is taken from the `X-Trace-Id` header.
	// If `X-Trace-Id` header is not set, it will be generated automatically.
	// Service will use the value of this field to make outgoing requests.
	// Format: uuid (uuid)
	// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
	SetTraceID(UUID) AgentMakeStreampointLocationError
	// The time of the event registration on the server.
	// Format: utc_ms (Unix timestamp in milliseconds)
	UtcMs() *UtcMs
	// The time of the event registration on the server.
	// Format: utc_ms (Unix timestamp in milliseconds)
	SetUtcMs(UtcMs) AgentMakeStreampointLocationError
}

// Required: name
type AuthBackendConfig interface {
	// Explicit list of countries (two-letter country codes according to ISO 3166-1) that have access to the content without any other checks.
	// Flussonic uses the MaxMind GeoLite2 Country database to map a country to a block of IP addresses.
	// New releases of GeoIP2 databases come out more often than the releases of Flussonic server, so sometimes the used database can become outdated.
	// Therefore we recommend you to install a separate GeoIP2 library and set up Flussonic to use it.
	// Example: [RU US]
	AllowCountries() []string
	// Explicit list of countries (two-letter country codes according to ISO 3166-1) that have access to the content without any other checks.
	// Flussonic uses the MaxMind GeoLite2 Country database to map a country to a block of IP addresses.
	// New releases of GeoIP2 databases come out more often than the releases of Flussonic server, so sometimes the used database can become outdated.
	// Therefore we recommend you to install a separate GeoIP2 library and set up Flussonic to use it.
	// Example: [RU US]
	SetAllowCountries([]string) AuthBackendConfig
	// This option defines the default behavior when all backends are not responding (usually, because of errors in HTTP responses) and the session is not started yet.
	// If this option is enabled, all clients or devices except those listed in `deny` option will have access to the content.
	// If this option is disabled, all clients or devices except those listed in `allow` option will not have access to the content.
	AllowDefault() *bool
	// This option defines the default behavior when all backends are not responding (usually, because of errors in HTTP responses) and the session is not started yet.
	// If this option is enabled, all clients or devices except those listed in `deny` option will have access to the content.
	// If this option is disabled, all clients or devices except those listed in `allow` option will not have access to the content.
	SetAllowDefault(bool) AuthBackendConfig
	// Explicit list of IP-addresses or subnet masks that have access to the content without any other checks.
	// Example: [127.0.0.1 10.10.0.0/24]
	AllowIps() []string
	// Explicit list of IP-addresses or subnet masks that have access to the content without any other checks.
	// Example: [127.0.0.1 10.10.0.0/24]
	SetAllowIps([]string) AuthBackendConfig
	// Explicit list of tokens that give access to the content without any other checks.
	// Example: [test_token1 test_token2]
	AllowTokens() []string
	// Explicit list of tokens that give access to the content without any other checks.
	// Example: [test_token1 test_token2]
	SetAllowTokens([]string) AuthBackendConfig
	// Explicit list of user agents (set-top boxes or browsers) that have access to the content without any other checks.
	// Example: [AppleWebKit/533.3 (KHTML, like Gecko) VLC/3.0.8 LibVLC/3.0.8]
	AllowUas() []string
	// Explicit list of user agents (set-top boxes or browsers) that have access to the content without any other checks.
	// Example: [AppleWebKit/533.3 (KHTML, like Gecko) VLC/3.0.8 LibVLC/3.0.8]
	SetAllowUas([]string) AuthBackendConfig
	// URL(s) of the HTTP backend(s).
	Backends() []AuthBackendURL
	// URL(s) of the HTTP backend(s).
	SetBackends([]AuthBackendURL) AuthBackendConfig
	// Explicit list of countries (two-letter country codes according to ISO 3166-1) that are banned from accessing the content.
	// Flussonic uses the MaxMind GeoLite2 Country database to map a country to a block of IP addresses.
	// New releases of GeoIP2 databases come out more often than the releases of Flussonic server, so sometimes the used database can become outdated.
	// Therefore we recommend you to install a separate GeoIP2 library and set up Flussonic to use it.
	// Example: [RU GB]
	DenyCountries() []string
	// Explicit list of countries (two-letter country codes according to ISO 3166-1) that are banned from accessing the content.
	// Flussonic uses the MaxMind GeoLite2 Country database to map a country to a block of IP addresses.
	// New releases of GeoIP2 databases come out more often than the releases of Flussonic server, so sometimes the used database can become outdated.
	// Therefore we recommend you to install a separate GeoIP2 library and set up Flussonic to use it.
	// Example: [RU GB]
	SetDenyCountries([]string) AuthBackendConfig
	// Explicit list of IP-addresses or subnet masks that are banned from accessing the content.
	// Example: [8.8.8.8 10.10.0.0/24]
	DenyIps() []string
	// Explicit list of IP-addresses or subnet masks that are banned from accessing the content.
	// Example: [8.8.8.8 10.10.0.0/24]
	SetDenyIps([]string) AuthBackendConfig
	// Explicit list of tokens that deny access to the content and stop any other checks.
	// Example: [test_token3 test_token4]
	DenyTokens() []string
	// Explicit list of tokens that deny access to the content and stop any other checks.
	// Example: [test_token3 test_token4]
	SetDenyTokens([]string) AuthBackendConfig
	// The list of user agents (set-top boxes or browsers) that are banned from accessing the content.
	// Example: [Mobile Safari/533.3 VLC/3.0.8 LibVLC/3.0.8]
	DenyUas() []string
	// The list of user agents (set-top boxes or browsers) that are banned from accessing the content.
	// Example: [Mobile Safari/533.3 VLC/3.0.8 LibVLC/3.0.8]
	SetDenyUas([]string) AuthBackendConfig
	// Globally unique [`auth_backend`](https://flussonic.com/doc/complex-authorization-with-backends/) name.
	// Format: auth_backend_name (auth_backend_name)
	Name() AuthBackendName
	// Globally unique [`auth_backend`](https://flussonic.com/doc/complex-authorization-with-backends/) name.
	// Format: auth_backend_name (auth_backend_name)
	SetName(AuthBackendName) AuthBackendConfig
}

// Required: url
type AuthBackendURL interface {
	// The URL of an HTTP backend.
	// Example: http://stalker-1.iptv.net/auth.php
	URL() string
	// The URL of an HTTP backend.
	// Example: http://stalker-1.iptv.net/auth.php
	SetURL(string) AuthBackendURL
}

type AuthBackendsList interface {
	// Configurations of the authorization backends.
	AuthBackends() []AuthBackendConfig
	// Configurations of the authorization backends.
	SetAuthBackends([]AuthBackendConfig) AuthBackendsList
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	EstimatedCount() *int
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	SetEstimatedCount(int) AuthBackendsList
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	Next() *string
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	SetNext(string) AuthBackendsList
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	Prev() *string
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	SetPrev(string) AuthBackendsList
	// An object with a list of different timings measured during this API call.
	Timing() any
	// An object with a list of different timings measured during this API call.
	SetTiming(any) AuthBackendsList
	// Collection returns the collection items
	Collection() []AuthBackendConfig
}

type AuthResponseV1 interface {
	// Configuration of injecting advertising video clips into played stream.
	AdInject() AuthResponseV1AdInject
	// Configuration of injecting advertising video clips into played stream.
	SetAdInject(AuthResponseV1AdInject) AuthResponseV1
	// Permitted DVR intervals.
	// By default when no allowed_dvr_ranges defined all archive is available for requests.
	// Empty list means no access.
	AllowedDvrRanges() []AuthResponseV1AllowedDvrRangesItem
	// Permitted DVR intervals.
	// By default when no allowed_dvr_ranges defined all archive is available for requests.
	// Empty list means no access.
	SetAllowedDvrRanges([]AuthResponseV1AllowedDvrRangesItem) AuthResponseV1
}

// Configuration of injecting advertising video clips into played stream.
type AuthResponseV1AdInject interface {
	// The paths to the mid-roll advertising files in a VOD location.
	// You may choose the mid-roll mode using the `midroll_insert_by` parameter.
	// The order of mid-roll playback is defined by the order of values in the array.
	// Example: [ad_vod/midroll1.mp4 ad_vod/midroll2.mp4]
	Midroll() []string
	// The paths to the mid-roll advertising files in a VOD location.
	// You may choose the mid-roll mode using the `midroll_insert_by` parameter.
	// The order of mid-roll playback is defined by the order of values in the array.
	// Example: [ad_vod/midroll1.mp4 ad_vod/midroll2.mp4]
	SetMidroll([]string) AuthResponseV1AdInject
	// When to perform midrolls.
	MidrollInsertBy() *AuthResponseV1AdInjectMidrollInsertBy
	// When to perform midrolls.
	SetMidrollInsertBy(AuthResponseV1AdInjectMidrollInsertBy) AuthResponseV1AdInject
	// The interval between showing mid-roll advertisement files.
	// Use with `midroll_insert_by=interval` only.
	// Example: 180
	MidrollInterval() *int
	// The interval between showing mid-roll advertisement files.
	// Use with `midroll_insert_by=interval` only.
	// Example: 180
	SetMidrollInterval(int) AuthResponseV1AdInject
	// You can use this option to choose SCTE-35 or SCTE-104 markers having this program_id only for this mid-roll.
	// Use with `midroll_insert_by=splicing` only.
	// Example: 1
	MidrollProgramID() *int
	// You can use this option to choose SCTE-35 or SCTE-104 markers having this program_id only for this mid-roll.
	// Use with `midroll_insert_by=splicing` only.
	// Example: 1
	SetMidrollProgramID(int) AuthResponseV1AdInject
	// The paths to the pre-roll advertising files in a VOD location.
	// All the pre-roll files are played before switching to the main stream:
	// * live main stream is *replaced* by the pre-roll so the content may be overlapped by the ads.
	// * VOD main stream is entirely played after the pre-roll without overlapping like in a playlist.
	// The order of pre-roll playback is defined by the order of values in the array.
	// Example: [ad_vod/preroll1.mp4]
	Preroll() []string
	// The paths to the pre-roll advertising files in a VOD location.
	// All the pre-roll files are played before switching to the main stream:
	// * live main stream is *replaced* by the pre-roll so the content may be overlapped by the ads.
	// * VOD main stream is entirely played after the pre-roll without overlapping like in a playlist.
	// The order of pre-roll playback is defined by the order of values in the array.
	// Example: [ad_vod/preroll1.mp4]
	SetPreroll([]string) AuthResponseV1AdInject
	// The version of ad insertion mechanism used by Flussonic:
	// * `v=1` is an extension of the authorization system, it works with HLS and DASH protocols only.
	// The ad is inserted to the manifest (playlist), so plugins such as AdBlock can detect and block the advertisement.
	// * `v=2` (default) provides more resistance to ad blockers.
	// The ad replaces the stream segments within the play session so that it is impossible to distinguish
	// whether it is a main stream segment or an ad segment.
	// It also allows you to customize the advertisements for a particular user.
	// Besides, it works with a single-period as well as a multi-period DASH.
	// Example: 2
	V() *int
	// The version of ad insertion mechanism used by Flussonic:
	// * `v=1` is an extension of the authorization system, it works with HLS and DASH protocols only.
	// The ad is inserted to the manifest (playlist), so plugins such as AdBlock can detect and block the advertisement.
	// * `v=2` (default) provides more resistance to ad blockers.
	// The ad replaces the stream segments within the play session so that it is impossible to distinguish
	// whether it is a main stream segment or an ad segment.
	// It also allows you to customize the advertisements for a particular user.
	// Besides, it works with a single-period as well as a multi-period DASH.
	// Example: 2
	SetV(int) AuthResponseV1AdInject
}

// 'opened_at' or 'closed_at' can be omitted (not both), which means open interval.
type AuthResponseV1AllowedDvrRangesItem interface {
	// End of the interval, exclusive.
	// Format: utc (Unix timestamp in seconds)
	// Example: 1.71002e+09
	ClosedAt() *Utc
	// End of the interval, exclusive.
	// Format: utc (Unix timestamp in seconds)
	// Example: 1.71002e+09
	SetClosedAt(Utc) AuthResponseV1AllowedDvrRangesItem
	// Start of the interval, inclusive.
	// Format: utc (Unix timestamp in seconds)
	// Example: 1.71001e+09
	OpenedAt() *Utc
	// Start of the interval, inclusive.
	// Format: utc (Unix timestamp in seconds)
	// Example: 1.71001e+09
	SetOpenedAt(Utc) AuthResponseV1AllowedDvrRangesItem
}

type AuthSpec interface {
	// Explicit list of countries (two-letter country codes according to ISO 3166-1) that have access to the content without any other checks.
	// Flussonic uses the MaxMind GeoLite2 Country database to map a country to a block of IP addresses.
	// New releases of GeoIP2 databases come out more often than the releases of Flussonic server, so sometimes the used database can become outdated.
	// Therefore we recommend you to install a separate GeoIP2 library and set up Flussonic to use it.
	// Example: [US DE GB]
	AllowedCountries() []Iso3166
	// Explicit list of countries (two-letter country codes according to ISO 3166-1) that have access to the content without any other checks.
	// Flussonic uses the MaxMind GeoLite2 Country database to map a country to a block of IP addresses.
	// New releases of GeoIP2 databases come out more often than the releases of Flussonic server, so sometimes the used database can become outdated.
	// Therefore we recommend you to install a separate GeoIP2 library and set up Flussonic to use it.
	// Example: [US DE GB]
	SetAllowedCountries([]Iso3166) AuthSpec
	// Explicit list of countries (two-letter country codes according to ISO 3166-1) that are banned from accessing the content.
	// Flussonic uses the MaxMind GeoLite2 Country database to map a country to a block of IP addresses.
	// New releases of GeoIP2 databases come out more often than the releases of Flussonic server, so sometimes the used database can become outdated.
	// Therefore we recommend you to install a separate GeoIP2 library and set up Flussonic to use it.
	// Example: [US DE GB]
	DisallowedCountries() []Iso3166
	// Explicit list of countries (two-letter country codes according to ISO 3166-1) that are banned from accessing the content.
	// Flussonic uses the MaxMind GeoLite2 Country database to map a country to a block of IP addresses.
	// New releases of GeoIP2 databases come out more often than the releases of Flussonic server, so sometimes the used database can become outdated.
	// Therefore we recommend you to install a separate GeoIP2 library and set up Flussonic to use it.
	// Example: [US DE GB]
	SetDisallowedCountries([]Iso3166) AuthSpec
	// Specifying the domains, within which playing this video is allowed.
	// This does not work for those clients that do not pass the value of Referer HTTP header.
	// Example: [mycompany.com]
	Domains() []string
	// Specifying the domains, within which playing this video is allowed.
	// This does not work for those clients that do not pass the value of Referer HTTP header.
	// Example: [mycompany.com]
	SetDomains([]string) AuthSpec
	// Some additional options.
	Extra() map[string]string
	// Some additional options.
	SetExtra(map[string]string) AuthSpec
	// The maximal number of streams or files the user can view simultaneously.
	// This limitation allows to prevent users from full restreaming to their servers.
	// Example: 5000
	MaxSessions() *int
	// The maximal number of streams or files the user can view simultaneously.
	// This limitation allows to prevent users from full restreaming to their servers.
	// Example: 5000
	SetMaxSessions(int) AuthSpec
	// A list of keys to generate a session ID value, allowing to configure the authorization scheme
	// which is a hash sum calculated as follows: `hash(name + ip + proto)`.
	// This parameter allows to finish one session and start another one with the same authorization token.
	// The keys `name`,`ip`, and `proto` are required.
	// Example: [name token proto ip]
	SessionKeys() []SessionKey
	// A list of keys to generate a session ID value, allowing to configure the authorization scheme
	// which is a hash sum calculated as follows: `hash(name + ip + proto)`.
	// This parameter allows to finish one session and start another one with the same authorization token.
	// The keys `name`,`ip`, and `proto` are required.
	// Example: [name token proto ip]
	SetSessionKeys([]SessionKey) AuthSpec
	// If this option is enabled and `max_sessions` limitation is used, the extra sessions are interrupted not immediately, but in 30 or 90 seconds.
	// This can be useful for middlewares that cannot generate a new token for every new stream or file request
	// and therefore need time to understand that all sessions are being used.
	// Example: false
	SoftLimitation() *bool
	// If this option is enabled and `max_sessions` limitation is used, the extra sessions are interrupted not immediately, but in 30 or 90 seconds.
	// This can be useful for middlewares that cannot generate a new token for every new stream or file request
	// and therefore need time to understand that all sessions are being used.
	// Example: false
	SetSoftLimitation(bool) AuthSpec
	// The URL of an HTTP backend.
	// Example: http://middleware-address/auth/v2
	URL() *AuthURL
	// The URL of an HTTP backend.
	// Example: http://middleware-address/auth/v2
	SetURL(AuthURL) AuthSpec
}

type BackupConfig interface {
	// The time (in seconds) for Flussonic to switch to the fallback source if the main source stops sending audio frames.
	// Example: 5
	AudioTimeout() *int
	// The time (in seconds) for Flussonic to switch to the fallback source if the main source stops sending audio frames.
	// Example: 5
	SetAudioTimeout(int) BackupConfig
	// Whether or not to record a backup to DVR.
	// Set to `False` by default (backup is not recorded).
	Dvr() *bool
	// Whether or not to record a backup to DVR.
	// Set to `False` by default (backup is not recorded).
	SetDvr(bool) BackupConfig
	// Path to the backup file in a VOD location on the server (**not on the local disk!**).
	// The backup file is played to fill in a time interval when the source is down.
	// Example: vod/blank.mp4
	File() *string
	// Path to the backup file in a VOD location on the server (**not on the local disk!**).
	// The backup file is played to fill in a time interval when the source is down.
	// Example: vod/blank.mp4
	SetFile(string) BackupConfig
	// The time (in seconds) for Flussonic to switch to the fallback source if the main source stops sending frames.
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// This option takes any type of frames into account.
	// If you do not specify timeout specifically for a fallback source, then in the absence of frames, `source_timeout` of the main source will be used.
	// Example: 10
	Timeout() *int
	// The time (in seconds) for Flussonic to switch to the fallback source if the main source stops sending frames.
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// This option takes any type of frames into account.
	// If you do not specify timeout specifically for a fallback source, then in the absence of frames, `source_timeout` of the main source will be used.
	// Example: 10
	SetTimeout(int) BackupConfig
	// Whether or not to transcode the backup file. Set to `True` by default.
	// If set to `False`, backup file frames will bypass as-is to the output stream.
	// Should not be set to `False` unless the backup file has the same stream characteristics
	// as the live stream.
	Transcode() *bool
	// Whether or not to transcode the backup file. Set to `True` by default.
	// If set to `False`, backup file frames will bypass as-is to the output stream.
	// Should not be set to `False` unless the backup file has the same stream characteristics
	// as the live stream.
	SetTranscode(bool) BackupConfig
	// The time (in seconds) for Flussonic to switch to the fallback source if the main source stops sending video frames.
	// Example: 4
	VideoTimeout() *int
	// The time (in seconds) for Flussonic to switch to the fallback source if the main source stops sending video frames.
	// Example: 4
	SetVideoTimeout(int) BackupConfig
}

type BalancerConfig interface {
	// Balancing mode
	Mode() *BalancerConfigMode
	// Balancing mode
	SetMode(BalancerConfigMode) BalancerConfig
	// Globally unique balancer name.
	// Format: media_name (media_name)
	Name() *MediaName
	// Globally unique balancer name.
	// Format: media_name (media_name)
	SetName(MediaName) BalancerConfig
	// Balancer will distribute requests between these servers.
	Servers() []BalancerServerConfig
	// Balancer will distribute requests between these servers.
	SetServers([]BalancerServerConfig) BalancerConfig
}

type BalancerServerConfig interface {
	// Client will be redirected to the peer if its IP belongs to one of these countries.
	Countries() []Iso3166
	// Client will be redirected to the peer if its IP belongs to one of these countries.
	SetCountries([]Iso3166) BalancerServerConfig
	// This flag allows to redirect a request to this peer if "countries" list not matched.
	CountriesDefault() *bool
	// This flag allows to redirect a request to this peer if "countries" list not matched.
	SetCountriesDefault(bool) BalancerServerConfig
	// Maximum allowed bitrate, request is redirecting if current bitrate is lower.
	// Format: speed (speed)
	MaxBitrate() *Speed
	// Maximum allowed bitrate, request is redirecting if current bitrate is lower.
	// Format: speed (speed)
	SetMaxBitrate(Speed) BalancerServerConfig
	// Hostname of the peer. Can refer to globally defined peer.
	// Format: server_name (server_name)
	Name() *ServerName
	// Hostname of the peer. Can refer to globally defined peer.
	// Format: server_name (server_name)
	SetName(ServerName) BalancerServerConfig
}

type BalancersList interface {
	// The list of balancers.
	Balancers() []BalancerConfig
	// The list of balancers.
	SetBalancers([]BalancerConfig) BalancersList
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	EstimatedCount() *int
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	SetEstimatedCount(int) BalancersList
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	Next() *string
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	SetNext(string) BalancersList
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	Prev() *string
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	SetPrev(string) BalancersList
	// An object with a list of different timings measured during this API call.
	Timing() any
	// An object with a list of different timings measured during this API call.
	SetTiming(any) BalancersList
	// Collection returns the collection items
	Collection() []BalancerConfig
}

type CentralAgentConfig interface {
	// Agent identifier
	// Example: 1234567
	ID() *string
	// Agent identifier
	// Example: 1234567
	SetID(string) CentralAgentConfig
	// Agent authentication key.
	Key() *string
	// Agent authentication key.
	SetKey(string) CentralAgentConfig
	// Current layout of agent.
	// This field will be ignored for agents with an existing stream on update, use `stream.layout` instead.
	// Central will provide configuration to nodes based on this layout.
	Layout() CentralStreamLayoutBase
	// Current layout of agent.
	// This field will be ignored for agents with an existing stream on update, use `stream.layout` instead.
	// Central will provide configuration to nodes based on this layout.
	SetLayout(CentralStreamLayoutBase) CentralAgentConfig
	// Agents's metrics and other statistical information.
	Stats() WatcherAgentStats
	// Agents's metrics and other statistical information.
	SetStats(WatcherAgentStats) CentralAgentConfig
}

type CentralAgentLayoutList interface {
	// List of agent layouts
	Layouts() []CentralAgentLayoutListItem
	// List of agent layouts
	SetLayouts([]CentralAgentLayoutListItem) CentralAgentLayoutList
}

type CentralAgentLayoutListItem interface {
	// Time when the node change occurred
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	CreatedAt() *UtcMs
	// Time when the node change occurred
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	SetCreatedAt(UtcMs) CentralAgentLayoutListItem
	// ID of the agent
	ID() *string
	// ID of the agent
	SetID(string) CentralAgentLayoutListItem
	// Hostname of current ingest on which the stream is being captured
	// Format: server_name (server_name)
	Ingest() *ServerName
	// Hostname of current ingest on which the stream is being captured
	// Format: server_name (server_name)
	SetIngest(ServerName) CentralAgentLayoutListItem
	// Service or admin user who changed the layout of the stream using an API call.
	Originator() *CentralStreamLayoutOriginator
	// Service or admin user who changed the layout of the stream using an API call.
	SetOriginator(CentralStreamLayoutOriginator) CentralAgentLayoutListItem
}

type CentralAgentsList interface {
	// The list of Agents fetched according to the query parameters.
	Agents() []CentralAgentConfig
	// The list of Agents fetched according to the query parameters.
	SetAgents([]CentralAgentConfig) CentralAgentsList
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	EstimatedCount() *int
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	SetEstimatedCount(int) CentralAgentsList
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	Next() *string
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	SetNext(string) CentralAgentsList
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	Prev() *string
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	SetPrev(string) CentralAgentsList
	// An object with a list of different timings measured during this API call.
	Timing() any
	// An object with a list of different timings measured during this API call.
	SetTiming(any) CentralAgentsList
	// Collection returns the collection items
	Collection() []CentralAgentConfig
}

// Required: database, api_key
type CentralConfig interface {
	// API_KEY is used to access Central API
	// Example: api_key
	APIKey() string
	// API_KEY is used to access Central API
	// Example: api_key
	SetAPIKey(string) CentralConfig
	// API URL used for setting the hostname and port under which Central is accessible by Flussonic for CONFIG_EXTERNAL and http_proxy requests
	// Format: url (url)
	// Example: http://central.ru:9019/streamer/api/v3
	APIURL() *URL
	// API URL used for setting the hostname and port under which Central is accessible by Flussonic for CONFIG_EXTERNAL and http_proxy requests
	// Format: url (url)
	// Example: http://central.ru:9019/streamer/api/v3
	SetAPIURL(URL) CentralConfig
	// Describes how entral interacts with nodes in the cluster
	Cluster() CentralConfigCluster
	// Describes how entral interacts with nodes in the cluster
	SetCluster(CentralConfigCluster) CentralConfig
	// You can use the default value or increase it to reduce server load, but increase time for the streamer to receive changes.
	// Example: 5000
	ConfigExternalReconciliationInterval() *float64
	// You can use the default value or increase it to reduce server load, but increase time for the streamer to receive changes.
	// Example: 5000
	SetConfigExternalReconciliationInterval(float64) CentralConfig
	// The configuration of database connection
	Database() CentralConfigDatabase
	// The configuration of database connection
	SetDatabase(CentralConfigDatabase) CentralConfig
	// Credentials for administrator access to the server.
	EditAuth() AdminCredentials
	// Credentials for administrator access to the server.
	SetEditAuth(AdminCredentials) CentralConfig
	// Delay in milliseconds after which episodes from the buffer will be inserted into the database.
	// Set 0 to disable buffer accumulation before inserting episodes into the database.
	// Format: milliseconds (milliseconds)
	// Example: 3000
	EpisodesBufferDelay() *Milliseconds
	// Delay in milliseconds after which episodes from the buffer will be inserted into the database.
	// Set 0 to disable buffer accumulation before inserting episodes into the database.
	// Format: milliseconds (milliseconds)
	// Example: 3000
	SetEpisodesBufferDelay(Milliseconds) CentralConfig
	// Limit on the number of episodes in the buffer.
	// If the number of episodes in the buffer exceeds the limit, the insertion into the database will be done instantly, regardless of the limit.
	// Set 0 to disable buffer accumulation before inserting episodes into the database.
	// Example: 100
	EpisodesBufferLimit() *float64
	// Limit on the number of episodes in the buffer.
	// If the number of episodes in the buffer exceeds the limit, the insertion into the database will be done instantly, regardless of the limit.
	// Set 0 to disable buffer accumulation before inserting episodes into the database.
	// Example: 100
	SetEpisodesBufferLimit(float64) CentralConfig
	// Enables layouter
	// Example: false
	LayouterEnabled() *string
	// Enables layouter
	// Example: false
	SetLayouterEnabled(string) CentralConfig
	// Interval in milliseconds between layouter runs
	// Format: milliseconds (milliseconds)
	// Example: 30000
	LayouterSleepingInterval() *Milliseconds
	// Interval in milliseconds between layouter runs
	// Format: milliseconds (milliseconds)
	// Example: 30000
	SetLayouterSleepingInterval(Milliseconds) CentralConfig
	// The configuration of network listeners.
	Listeners() Listeners
	// The configuration of network listeners.
	SetListeners(Listeners) CentralConfig
	// Enables logging HTTP-requests
	// Example: false
	LogRequests() *string
	// Enables logging HTTP-requests
	// Example: false
	SetLogRequests(string) CentralConfig
	// Set logging level
	// Example: error
	Loglevel() *Loglevel
	// Set logging level
	// Example: error
	SetLoglevel(Loglevel) CentralConfig
	// URL (agent or collector) that is used to collect traces and spans with configuration in query parameters.
	// FORMAT: `http://{JAEGER-URL}?service_name={CENTRAL_NAME}` (The prefix central will be added to the service name)
	// Format: url (url)
	// Example: http://jaeger-server:14268/v1/traces?service_name=some-name
	OpentelemetryURL() *URL
	// URL (agent or collector) that is used to collect traces and spans with configuration in query parameters.
	// FORMAT: `http://{JAEGER-URL}?service_name={CENTRAL_NAME}` (The prefix central will be added to the service name)
	// Format: url (url)
	// Example: http://jaeger-server:14268/v1/traces?service_name=some-name
	SetOpentelemetryURL(URL) CentralConfig
	// The configuration of Redis connection.
	// If not specified, Central will store temporary data in memory.
	// Using Redis is useful in multi-instance installation to store data between instances. In other cases specifying this field is not recommended.
	Redis() CentralConfigRedis
	// The configuration of Redis connection.
	// If not specified, Central will store temporary data in memory.
	// Using Redis is useful in multi-instance installation to store data between instances. In other cases specifying this field is not recommended.
	SetRedis(CentralConfigRedis) CentralConfig
	// Unique server ID generated on a first start or license change.
	// Should not changing until running on the same hardware.
	// Format: uuid (uuid)
	ServerID() *UUID
	// Unique server ID generated on a first start or license change.
	// Should not changing until running on the same hardware.
	// Format: uuid (uuid)
	SetServerID(UUID) CentralConfig
	// Server runtime stats
	Stats() CentralStats
	// Server runtime stats
	SetStats(CentralStats) CentralConfig
	// The number of failed health checks in the last hour after which the streamer is considered unhealthy.
	// Useful for identifying unstable streamer.
	// Example: 5
	StreamerHealthcheckFailsThreshold() *float64
	// The number of failed health checks in the last hour after which the streamer is considered unhealthy.
	// Useful for identifying unstable streamer.
	// Example: 5
	SetStreamerHealthcheckFailsThreshold(float64) CentralConfig
}

type CentralConfigCluster interface {
	// If enabled Central will provide [configuration](#tag/streamer/operation/streamer_save%7Cbody__0%7Cconfig) to nodes in cluster.
	// Also, Central will automatically provide `config_external` configuration to nodes.
	// You must disable this option if you are using orchestration system for deployment and management.
	// Example: true
	NodeConfigProvisionEnabled() *bool
	// If enabled Central will provide [configuration](#tag/streamer/operation/streamer_save%7Cbody__0%7Cconfig) to nodes in cluster.
	// Also, Central will automatically provide `config_external` configuration to nodes.
	// You must disable this option if you are using orchestration system for deployment and management.
	// Example: true
	SetNodeConfigProvisionEnabled(bool) CentralConfigCluster
	// Number of retries for sending requests to streamers
	// Example: 5
	StreamerConnectorRetries() *int
	// Number of retries for sending requests to streamers
	// Example: 5
	SetStreamerConnectorRetries(int) CentralConfigCluster
}

// Required: url
type CentralConfigDatabase interface {
	// The number of retries for Central to connect with its database
	// Example: 20
	ConnectMaxRetries() *int
	// The number of retries for Central to connect with its database
	// Example: 20
	SetConnectMaxRetries(int) CentralConfigDatabase
	// Timeout of retry for Central to connect with its database
	// Example: 2s
	ConnectRetryTimeout() *string
	// Timeout of retry for Central to connect with its database
	// Example: 2s
	SetConnectRetryTimeout(string) CentralConfigDatabase
	// Max connection pool size that Central use to connect with database
	// Example: 40
	MaxConnections() *int
	// Max connection pool size that Central use to connect with database
	// Example: 40
	SetMaxConnections(int) CentralConfigDatabase
	// Connection string to PostgreSQL database.
	// Format: `postgres://[user[:password]@][host][:port][/dbname][?param1=value1&...&paramN=valueN]`
	// Allowed parameters:
	// - `sslmode` - configuring SSL connection to the database.
	// This parameter defines whether and how SSL should be used to connect to the database.
	// Possible values include `disable`, `allow`, `prefer`, `require`, `verify-ca`, and `verify-full`.
	// - `default_query_exec_mode` - if you use PgBouncer, it's necessary to set this parameter to `cache_describe`.
	// Example: postgres://central:pass@localhost:5432/central_dev
	URL() string
	// Connection string to PostgreSQL database.
	// Format: `postgres://[user[:password]@][host][:port][/dbname][?param1=value1&...&paramN=valueN]`
	// Allowed parameters:
	// - `sslmode` - configuring SSL connection to the database.
	// This parameter defines whether and how SSL should be used to connect to the database.
	// Possible values include `disable`, `allow`, `prefer`, `require`, `verify-ca`, and `verify-full`.
	// - `default_query_exec_mode` - if you use PgBouncer, it's necessary to set this parameter to `cache_describe`.
	// Example: postgres://central:pass@localhost:5432/central_dev
	SetURL(string) CentralConfigDatabase
}

type CentralConfigRedis interface {
	// The number of retries for Central to connect with its database
	// Example: 20
	ConnectMaxRetries() *int
	// The number of retries for Central to connect with its database
	// Example: 20
	SetConnectMaxRetries(int) CentralConfigRedis
	// Timeout of retry for Central to connect with its database
	// Example: 2s
	ConnectRetryTimeout() *string
	// Timeout of retry for Central to connect with its database
	// Example: 2s
	SetConnectRetryTimeout(string) CentralConfigRedis
	// Max connection pool size that Central use to connect with database
	// Example: 40
	MaxConnections() *int
	// Max connection pool size that Central use to connect with database
	// Example: 40
	SetMaxConnections(int) CentralConfigRedis
	// Connection string to Redis database
	// Format: `redis://[:<password>]@<host>:<port>/<db>`
	// Example: redis://:pass@localhost:6379
	URL() *string
	// Connection string to Redis database
	// Format: `redis://[:<password>]@<host>:<port>/<db>`
	// Example: redis://:pass@localhost:6379
	SetURL(string) CentralConfigRedis
}

// Predictions for disk usage.
type CentralDiskPredictions interface {
	// Estimated disk usage in percent.
	// This value is estimated on the based on streamer disk space and current configurations of streams processed by the streamer,
	// which specify the rate of data writing to disk by them and the duration of their data storage.
	// Note: This value represents what percentage of the disk will be filled when all streams on the streamer reach the point where the disk is static.
	// It can be greater than 100% if streamer can't store estimated amount of data.
	// Format: percent (percent)
	EstimatedDiskUsage() *Percent
	// Estimated disk usage in percent.
	// This value is estimated on the based on streamer disk space and current configurations of streams processed by the streamer,
	// which specify the rate of data writing to disk by them and the duration of their data storage.
	// Note: This value represents what percentage of the disk will be filled when all streams on the streamer reach the point where the disk is static.
	// It can be greater than 100% if streamer can't store estimated amount of data.
	// Format: percent (percent)
	SetEstimatedDiskUsage(Percent) CentralDiskPredictions
}

type CentralDvrConfig interface {
	// DVR configuration name.
	// Format: dvr_name (dvr_name)
	Name() *DvrName
	// DVR configuration name.
	// Format: dvr_name (dvr_name)
	SetName(DvrName) CentralDvrConfig
}

type CentralDvrsList interface {
	// List of available dvr storages
	Dvrs() []CentralDvrConfig
	// List of available dvr storages
	SetDvrs([]CentralDvrConfig) CentralDvrsList
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	EstimatedCount() *int
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	SetEstimatedCount(int) CentralDvrsList
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	Next() *string
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	SetNext(string) CentralDvrsList
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	Prev() *string
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	SetPrev(string) CentralDvrsList
	// An object with a list of different timings measured during this API call.
	Timing() any
	// An object with a list of different timings measured during this API call.
	SetTiming(any) CentralDvrsList
	// Collection returns the collection items
	Collection() []CentralDvrConfig
}

type CentralEvent interface {
	// Number of updated agents (without streams) layouts.
	AgentsUpdated() *int
	// Number of updated agents (without streams) layouts.
	SetAgentsUpdated(int) CentralEvent
	// Command name.
	// Example: streampoint_connect
	Command() *AgentCommandHandlingCommand
	// Command name.
	// Example: streampoint_connect
	SetCommand(AgentCommandHandlingCommand) CentralEvent
	// Creation date and time
	// Format: date_time (date_time)
	// Example: 2021-01-30T08:30:00.432567Z
	CreatedAt() *DateTime
	// Creation date and time
	// Format: date_time (date_time)
	// Example: 2021-01-30T08:30:00.432567Z
	SetCreatedAt(DateTime) CentralEvent
	// Microseconds that this request took
	// Format: microseconds (microseconds)
	Duration() *Microseconds
	// Microseconds that this request took
	// Format: microseconds (microseconds)
	SetDuration(Microseconds) CentralEvent
	// Entity configuration containing only those fields that are supported by Layouter.
	// For supported fields see [Layouter Schema](https://flussonic.com/doc/api/layouter/)
	EntityBody() any
	// Entity configuration containing only those fields that are supported by Layouter.
	// For supported fields see [Layouter Schema](https://flussonic.com/doc/api/layouter/)
	SetEntityBody(any) CentralEvent
	// Unique identifier of the entity.
	// For example, for `agent` it is `agent_id` field.
	EntityID() *string
	// Unique identifier of the entity.
	// For example, for `agent` it is `agent_id` field.
	SetEntityID(string) CentralEvent
	// Type of the entity.
	EntityType() *EntityEventEntityType
	// Type of the entity.
	SetEntityType(EntityEventEntityType) CentralEvent
	// Error message explaining why command failed.
	// If command was successful, this field absent.
	// /structured error
	Error() any
	// Error message explaining why command failed.
	// If command was successful, this field absent.
	// /structured error
	SetError(any) CentralEvent
	// Server started booting./Server started successfully./Database error./The api call./Event of handling commands via the interaction protocol between the agent and the endpoint./Agent failed to connect to endpoint./Agent successfully connected to endpoint./Agent disconnected from endpoint./Failed to make streampoint location for agent.
	// /Layouter process agents (without streams) success./Layouter process agents (without streams) error./Layouter process streams success./Layouter process streams error./Entity fetched by Layouter. It may be Streamer, Stream or Agent.
	// /Result of processing fetched entities
	// /Layouter started fetching entities for processing
	Event() string
	// Server started booting./Server started successfully./Database error./The api call./Event of handling commands via the interaction protocol between the agent and the endpoint./Agent failed to connect to endpoint./Agent successfully connected to endpoint./Agent disconnected from endpoint./Failed to make streampoint location for agent.
	// /Layouter process agents (without streams) success./Layouter process agents (without streams) error./Layouter process streams success./Layouter process streams error./Entity fetched by Layouter. It may be Streamer, Stream or Agent.
	// /Result of processing fetched entities
	// /Layouter started fetching entities for processing
	SetEvent(string) CentralEvent
	// Event identifier.
	EventID() *int
	// Event identifier.
	SetEventID(int) CentralEvent
	// Full version of service with the build number.
	FullVersion() *string
	// Full version of service with the build number.
	SetFullVersion(string) CentralEvent
	Initiator() *AgentInitiator
	SetInitiator(AgentInitiator) CentralEvent
	// The ID of the started instance.
	InstanceID() *string
	// The ID of the started instance.
	SetInstanceID(string) CentralEvent
	// IP address of the caller.
	// Format: ip (ip)
	// Example: 192.34.32.10
	IP() *IP
	// IP address of the caller.
	// Format: ip (ip)
	// Example: 192.34.32.10
	SetIP(IP) CentralEvent
	// The error message./Additional information about the error.
	Message() *string
	// The error message./Additional information about the error.
	SetMessage(string) CentralEvent
	// API method ID.
	// Example: streams_list
	OperationID() *string
	// API method ID.
	// Example: streams_list
	SetOperationID(string) CentralEvent
	// The program produced the API call. Content of `X-Originator` header.
	// Example: flussonic
	Originator() *string
	// The program produced the API call. Content of `X-Originator` header.
	// Example: flussonic
	SetOriginator(string) CentralEvent
	// The api call path.
	Path() *string
	// The api call path.
	SetPath(string) CentralEvent
	// Payload data transmitter in the API call./Payload of the command.
	Payload() *string
	// Payload data transmitter in the API call./Payload of the command.
	SetPayload(string) CentralEvent
	PreviousState() *PreviousServerState
	SetPreviousState(PreviousServerState) CentralEvent
	// The api call query string.
	Qs() *string
	// The api call query string.
	SetQs(string) CentralEvent
	// The query that caused the error.
	Query() *string
	// The query that caused the error.
	SetQuery(string) CentralEvent
	// Why agent failed to connect./Why agent disconnected/Why agent failed to make streampoint location.
	Reason() any
	// Why agent failed to connect./Why agent disconnected/Why agent failed to make streampoint location.
	SetReason(any) CentralEvent
	// List of relayouts made by Layouter
	Relayouts() []CentralStreamLayoutListItem
	// List of relayouts made by Layouter
	SetRelayouts([]CentralStreamLayoutListItem) CentralEvent
	// Internal request-id for this operation
	RequestID() *string
	// Internal request-id for this operation
	SetRequestID(string) CentralEvent
	// Originator of event.
	// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
	// is configured as HTTP/HTTPS url.
	// Example: flussonic.host
	Server() *string
	// Originator of event.
	// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
	// is configured as HTTP/HTTPS url.
	// Example: flussonic.host
	SetServer(string) CentralEvent
	// Request status code.
	Status() *int
	// Request status code.
	SetStatus(int) CentralEvent
	// The hostname of current agent's streampoint.
	Streampoint() *string
	// The hostname of current agent's streampoint.
	SetStreampoint(string) CentralEvent
	// Number of updated streams layouts.
	StreamsUpdated() *int
	// Number of updated streams layouts.
	SetStreamsUpdated(int) CentralEvent
	// Unique identifier of the operation.
	// You can use this field to search for events related to same operation.
	// Value of this field is taken from the `X-Trace-Id` header.
	// If `X-Trace-Id` header is not set, it will be generated automatically.
	// Service will use the value of this field to make outgoing requests.
	// Format: uuid (uuid)
	// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
	TraceID() *UUID
	// Unique identifier of the operation.
	// You can use this field to search for events related to same operation.
	// Value of this field is taken from the `X-Trace-Id` header.
	// If `X-Trace-Id` header is not set, it will be generated automatically.
	// Service will use the value of this field to make outgoing requests.
	// Format: uuid (uuid)
	// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
	SetTraceID(UUID) CentralEvent
	// The type of the device from which the API call was produced.
	// Example: Flussonic 24.04
	UserAgent() *string
	// The type of the device from which the API call was produced.
	// Example: Flussonic 24.04
	SetUserAgent(string) CentralEvent
	// The time of the event registration on the server.
	// Format: utc_ms (Unix timestamp in milliseconds)
	UtcMs() *UtcMs
	// The time of the event registration on the server.
	// Format: utc_ms (Unix timestamp in milliseconds)
	SetUtcMs(UtcMs) CentralEvent
	// Version of service./Version of Service.
	Version() *string
	// Version of service./Version of Service.
	SetVersion(string) CentralEvent
}

type CentralEventsList interface {
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	EstimatedCount() *int
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	SetEstimatedCount(int) CentralEventsList
	// List of central events
	Events() []CentralEvent
	// List of central events
	SetEvents([]CentralEvent) CentralEventsList
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	Next() *string
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	SetNext(string) CentralEventsList
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	Prev() *string
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	SetPrev(string) CentralEventsList
	// An object with a list of different timings measured during this API call.
	Timing() any
	// An object with a list of different timings measured during this API call.
	SetTiming(any) CentralEventsList
	// Collection returns the collection items
	Collection() []CentralEvent
}

// Status of Central healthcheck.
type CentralHealthcheckStatus interface {
	// List of healthcheck checks with their results.
	Checks() CentralHealthcheckStatusChecks
	// List of healthcheck checks with their results.
	SetChecks(CentralHealthcheckStatusChecks) CentralHealthcheckStatus
	// Status of the healthcheck.
	Status() *CentralHealthcheckStatusStatus
	// Status of the healthcheck.
	SetStatus(CentralHealthcheckStatusStatus) CentralHealthcheckStatus
	// Unix timestamp of the last status change.
	// Format: utc_ms (Unix timestamp in milliseconds)
	StatusChangedAt() *UtcMs
	// Unix timestamp of the last status change.
	// Format: utc_ms (Unix timestamp in milliseconds)
	SetStatusChangedAt(UtcMs) CentralHealthcheckStatus
}

// List of healthcheck checks with their results.
type CentralHealthcheckStatusChecks interface {
	// `true` if peer has no `error` in
	// [stats.config_external_status](https://flussonic.com/doc/api/central/#tag/streamer/operation/streamer_get/response__0%7Cstats%7Cconfig_external_status) field.
	ConfigExternalOk() *bool
	// `true` if peer has no `error` in
	// [stats.config_external_status](https://flussonic.com/doc/api/central/#tag/streamer/operation/streamer_get/response__0%7Cstats%7Cconfig_external_status) field.
	SetConfigExternalOk(bool) CentralHealthcheckStatusChecks
	// `true` if peer has no `error` in
	// [stats.config_error](https://flussonic.com/doc/api/central/#tag/streamer/operation/streamer_get/response__0%7Cstats%7Cconfig_error) field.
	ConfigOk() *bool
	// `true` if peer has no `error` in
	// [stats.config_error](https://flussonic.com/doc/api/central/#tag/streamer/operation/streamer_get/response__0%7Cstats%7Cconfig_error) field.
	SetConfigOk(bool) CentralHealthcheckStatusChecks
	// List of errors details
	ErrorsDetails() []CentralHealthcheckStatusChecksErrorsDetailsItem
	// List of errors details
	SetErrorsDetails([]CentralHealthcheckStatusChecksErrorsDetailsItem) CentralHealthcheckStatusChecks
	// `true` if peer is reachable from central by its credentials
	Reachable() *bool
	// `true` if peer is reachable from central by its credentials
	SetReachable(bool) CentralHealthcheckStatusChecks
	// `true` if rproxy configuration is valid
	RproxyOk() *bool
	// `true` if rproxy configuration is valid
	SetRproxyOk(bool) CentralHealthcheckStatusChecks
	// `true` if peer is running
	Running() *bool
	// `true` if peer is running
	SetRunning(bool) CentralHealthcheckStatusChecks
	// `true` if server time is synchronized between peer and central
	TimeSynchronized() *bool
	// `true` if server time is synchronized between peer and central
	SetTimeSynchronized(bool) CentralHealthcheckStatusChecks
	// `true` if peer has a valid cluster key
	ValidClusterKey() *bool
	// `true` if peer has a valid cluster key
	SetValidClusterKey(bool) CentralHealthcheckStatusChecks
}

// Error details
type CentralHealthcheckStatusChecksErrorsDetailsItem interface {
	// Error message
	Error() *string
	// Error message
	SetError(string) CentralHealthcheckStatusChecksErrorsDetailsItem
	// Failed healthcheck rule name
	Rule() *string
	// Failed healthcheck rule name
	SetRule(string) CentralHealthcheckStatusChecksErrorsDetailsItem
}

type CentralIdentificationNode interface {
	// The URL for provisioning of configuration from the managing server to the streamer.
	// This URL does not have to be public but must be accessible from the managing server.
	// The API URL can also be used as Public and/or Private payload URL if they are not set.
	// When used as Public payload URL, the API URL shall be public to allow playback from this streamer.
	// Format: url (url)
	// Example: http://streamer.local:8080
	APIURL() *URL
	// The URL for provisioning of configuration from the managing server to the streamer.
	// This URL does not have to be public but must be accessible from the managing server.
	// The API URL can also be used as Public and/or Private payload URL if they are not set.
	// When used as Public payload URL, the API URL shall be public to allow playback from this streamer.
	// Format: url (url)
	// Example: http://streamer.local:8080
	SetAPIURL(URL) CentralIdentificationNode
	// Maximal number of streams.
	// Example: 5
	ChannelLimit() *int
	// Maximal number of streams.
	// Example: 5
	SetChannelLimit(int) CentralIdentificationNode
	// The key for authorization for inter-Flussonic connections.
	// All cluster peers should have the same cluster key.
	// Example: xS6i6Q3DCc5nEvnu
	ClusterKey() *string
	// The key for authorization for inter-Flussonic connections.
	// All cluster peers should have the same cluster key.
	// Example: xS6i6Q3DCc5nEvnu
	SetClusterKey(string) CentralIdentificationNode
	// CPU limit in percents.
	// Format: percent (percent)
	// Example: 10
	CpuLimit() *Percent
	// CPU limit in percents.
	// Format: percent (percent)
	// Example: 10
	SetCpuLimit(Percent) CentralIdentificationNode
	// How often the peer will try to get the data from the remote server via internal API.
	// Format: milliseconds (milliseconds)
	// Example: 1000
	FetchTimeout() *Milliseconds
	// How often the peer will try to get the data from the remote server via internal API.
	// Format: milliseconds (milliseconds)
	// Example: 1000
	SetFetchTimeout(Milliseconds) CentralIdentificationNode
	// Streamer's identifier in the cluster.
	// The managing server may try using this hostname to access the streamer
	// if API URL is not specified.
	// Format: server_name (server_name)
	// Example: peer.example.com
	Hostname() *ServerName
	// Streamer's identifier in the cluster.
	// The managing server may try using this hostname to access the streamer
	// if API URL is not specified.
	// Format: server_name (server_name)
	// Example: peer.example.com
	SetHostname(ServerName) CentralIdentificationNode
	// Deprecated field. Will be deleted at 23.09
	// Maximal output bitrate of the peer.
	// Format: speed (speed)
	MaxBitrate() *Speed
	// Deprecated field. Will be deleted at 23.09
	// Maximal output bitrate of the peer.
	// Format: speed (speed)
	SetMaxBitrate(Speed) CentralIdentificationNode
	// Streamer's logical namespace, used for interacting with streams of the same namespace. By default, a streamer has no assigned namespace. In this default state, it can interact with streams that also have no assigned namespace. If a namespace is explicitly set, the streamer will only interact with streams possessing that specific namespace.
	// For example, the layouter will distribute streams only to streamers with the same namespace. The `dynamic_streams_list` endpoint will operate exclusively within a single namespace.
	// ***Use case:***
	// Namespaces provide strict, system-wide resource isolation, fundamentally separating streams and streamers into independent segments. This ensures no interaction, archive access, inference processing, or layout operations occur between different namespaces.
	// Unlike labels, which offer flexible, attribute-based layout control within a namespace, namespaces define an absolute boundary: resources from one namespace cannot interact with resources from another.
	// ***Important:***
	// A namespace can only be assigned when the streamer is created and cannot be changed afterwards.
	// Format: unix_name (Contains only alphanumeric characters (a-z, A-Z, 0-9), underscores (_), hyphens (-) and periods (.).)
	// Pattern: ^[a-zA-Z0-9_.-]+$
	// Example: example
	Namespace() *UnixName
	// Streamer's logical namespace, used for interacting with streams of the same namespace. By default, a streamer has no assigned namespace. In this default state, it can interact with streams that also have no assigned namespace. If a namespace is explicitly set, the streamer will only interact with streams possessing that specific namespace.
	// For example, the layouter will distribute streams only to streamers with the same namespace. The `dynamic_streams_list` endpoint will operate exclusively within a single namespace.
	// ***Use case:***
	// Namespaces provide strict, system-wide resource isolation, fundamentally separating streams and streamers into independent segments. This ensures no interaction, archive access, inference processing, or layout operations occur between different namespaces.
	// Unlike labels, which offer flexible, attribute-based layout control within a namespace, namespaces define an absolute boundary: resources from one namespace cannot interact with resources from another.
	// ***Important:***
	// A namespace can only be assigned when the streamer is created and cannot be changed afterwards.
	// Format: unix_name (Contains only alphanumeric characters (a-z, A-Z, 0-9), underscores (_), hyphens (-) and periods (.).)
	// Pattern: ^[a-zA-Z0-9_.-]+$
	// Example: example
	SetNamespace(UnixName) CentralIdentificationNode
	// Role of node
	Role() *CentralNodeRoleRole
	// Role of node
	SetRole(CentralNodeRoleRole) CentralIdentificationNode
	// The time after which deleted streams on this server are considered to be inactive
	// and cannot be used in the `cluster_ingest` mechanism.
	// Format: milliseconds (milliseconds)
	// Example: 1000
	StaleTimeout() *Milliseconds
	// The time after which deleted streams on this server are considered to be inactive
	// and cannot be used in the `cluster_ingest` mechanism.
	// Format: milliseconds (milliseconds)
	// Example: 1000
	SetStaleTimeout(Milliseconds) CentralIdentificationNode
	// Statistics on peers in the cluster.
	Stats() PeerStats
	// Statistics on peers in the cluster.
	SetStats(PeerStats) CentralIdentificationNode
}

type CentralInferenceNode interface {
	// The URL for provisioning of configuration from the managing server to the streamer.
	// This URL does not have to be public but must be accessible from the managing server.
	// The API URL can also be used as Public and/or Private payload URL if they are not set.
	// When used as Public payload URL, the API URL shall be public to allow playback from this streamer.
	// Format: url (url)
	// Example: http://streamer.local:8080
	APIURL() *URL
	// The URL for provisioning of configuration from the managing server to the streamer.
	// This URL does not have to be public but must be accessible from the managing server.
	// The API URL can also be used as Public and/or Private payload URL if they are not set.
	// When used as Public payload URL, the API URL shall be public to allow playback from this streamer.
	// Format: url (url)
	// Example: http://streamer.local:8080
	SetAPIURL(URL) CentralInferenceNode
	// Maximal number of streams.
	// Example: 5
	ChannelLimit() *int
	// Maximal number of streams.
	// Example: 5
	SetChannelLimit(int) CentralInferenceNode
	// The key for authorization for inter-Flussonic connections.
	// All cluster peers should have the same cluster key.
	// Example: xS6i6Q3DCc5nEvnu
	ClusterKey() *string
	// The key for authorization for inter-Flussonic connections.
	// All cluster peers should have the same cluster key.
	// Example: xS6i6Q3DCc5nEvnu
	SetClusterKey(string) CentralInferenceNode
	// CPU limit in percents.
	// Format: percent (percent)
	// Example: 10
	CpuLimit() *Percent
	// CPU limit in percents.
	// Format: percent (percent)
	// Example: 10
	SetCpuLimit(Percent) CentralInferenceNode
	// How often the peer will try to get the data from the remote server via internal API.
	// Format: milliseconds (milliseconds)
	// Example: 1000
	FetchTimeout() *Milliseconds
	// How often the peer will try to get the data from the remote server via internal API.
	// Format: milliseconds (milliseconds)
	// Example: 1000
	SetFetchTimeout(Milliseconds) CentralInferenceNode
	// Streamer's identifier in the cluster.
	// The managing server may try using this hostname to access the streamer
	// if API URL is not specified.
	// Format: server_name (server_name)
	// Example: peer.example.com
	Hostname() *ServerName
	// Streamer's identifier in the cluster.
	// The managing server may try using this hostname to access the streamer
	// if API URL is not specified.
	// Format: server_name (server_name)
	// Example: peer.example.com
	SetHostname(ServerName) CentralInferenceNode
	Labels() map[string]UnixName
	SetLabels(map[string]UnixName) CentralInferenceNode
	// Deprecated field. Will be deleted at 23.09
	// Maximal output bitrate of the peer.
	// Format: speed (speed)
	MaxBitrate() *Speed
	// Deprecated field. Will be deleted at 23.09
	// Maximal output bitrate of the peer.
	// Format: speed (speed)
	SetMaxBitrate(Speed) CentralInferenceNode
	// Streamer's logical namespace, used for interacting with streams of the same namespace. By default, a streamer has no assigned namespace. In this default state, it can interact with streams that also have no assigned namespace. If a namespace is explicitly set, the streamer will only interact with streams possessing that specific namespace.
	// For example, the layouter will distribute streams only to streamers with the same namespace. The `dynamic_streams_list` endpoint will operate exclusively within a single namespace.
	// ***Use case:***
	// Namespaces provide strict, system-wide resource isolation, fundamentally separating streams and streamers into independent segments. This ensures no interaction, archive access, inference processing, or layout operations occur between different namespaces.
	// Unlike labels, which offer flexible, attribute-based layout control within a namespace, namespaces define an absolute boundary: resources from one namespace cannot interact with resources from another.
	// ***Important:***
	// A namespace can only be assigned when the streamer is created and cannot be changed afterwards.
	// Format: unix_name (Contains only alphanumeric characters (a-z, A-Z, 0-9), underscores (_), hyphens (-) and periods (.).)
	// Pattern: ^[a-zA-Z0-9_.-]+$
	// Example: example
	Namespace() *UnixName
	// Streamer's logical namespace, used for interacting with streams of the same namespace. By default, a streamer has no assigned namespace. In this default state, it can interact with streams that also have no assigned namespace. If a namespace is explicitly set, the streamer will only interact with streams possessing that specific namespace.
	// For example, the layouter will distribute streams only to streamers with the same namespace. The `dynamic_streams_list` endpoint will operate exclusively within a single namespace.
	// ***Use case:***
	// Namespaces provide strict, system-wide resource isolation, fundamentally separating streams and streamers into independent segments. This ensures no interaction, archive access, inference processing, or layout operations occur between different namespaces.
	// Unlike labels, which offer flexible, attribute-based layout control within a namespace, namespaces define an absolute boundary: resources from one namespace cannot interact with resources from another.
	// ***Important:***
	// A namespace can only be assigned when the streamer is created and cannot be changed afterwards.
	// Format: unix_name (Contains only alphanumeric characters (a-z, A-Z, 0-9), underscores (_), hyphens (-) and periods (.).)
	// Pattern: ^[a-zA-Z0-9_.-]+$
	// Example: example
	SetNamespace(UnixName) CentralInferenceNode
	// Role of node
	Role() *CentralNodeRoleRole
	// Role of node
	SetRole(CentralNodeRoleRole) CentralInferenceNode
	// The time after which deleted streams on this server are considered to be inactive
	// and cannot be used in the `cluster_ingest` mechanism.
	// Format: milliseconds (milliseconds)
	// Example: 1000
	StaleTimeout() *Milliseconds
	// The time after which deleted streams on this server are considered to be inactive
	// and cannot be used in the `cluster_ingest` mechanism.
	// Format: milliseconds (milliseconds)
	// Example: 1000
	SetStaleTimeout(Milliseconds) CentralInferenceNode
	// Statistics on peers in the cluster.
	Stats() PeerStats
	// Statistics on peers in the cluster.
	SetStats(PeerStats) CentralInferenceNode
}

type CentralNodeLayoutDecision interface {
	// Hostname of streamer
	// Format: server_name (server_name)
	// Example: streamer1.com
	Hostname() *ServerName
	// Hostname of streamer
	// Format: server_name (server_name)
	// Example: streamer1.com
	SetHostname(ServerName) CentralNodeLayoutDecision
	// This field is true if the stream can be layouted on this node.
	// Example: false
	NodeDecision() *bool
	// This field is true if the stream can be layouted on this node.
	// Example: false
	SetNodeDecision(bool) CentralNodeLayoutDecision
	// List of decision reasons explaining why the stream cannot be layouted on this node. This field may be empty if stream can be layouted on this node.
	// Example: [stream_misses_node_required_labels node_misses_stream_required_labels node_channel_limit_exceeded]
	Reasons() []CentralNodeLayoutDecisionReason
	// List of decision reasons explaining why the stream cannot be layouted on this node. This field may be empty if stream can be layouted on this node.
	// Example: [stream_misses_node_required_labels node_misses_stream_required_labels node_channel_limit_exceeded]
	SetReasons([]CentralNodeLayoutDecisionReason) CentralNodeLayoutDecision
	// Role of node
	Role() *CentralNodeRoleRole
	// Role of node
	SetRole(CentralNodeRoleRole) CentralNodeLayoutDecision
}

type CentralNodeRole interface {
	// Role of node
	Role() *CentralNodeRoleRole
	// Role of node
	SetRole(CentralNodeRoleRole) CentralNodeRole
}

// Cluster stats
type CentralStats interface {
	// Unique runtime ID of this instance. Updated with the restart.
	// Format: uuid (uuid)
	// Example: 61893b15-75b2-4fcb-b4cf-ae1dd0858ea2
	ID() *UUID
	// Unique runtime ID of this instance. Updated with the restart.
	// Format: uuid (uuid)
	// Example: 61893b15-75b2-4fcb-b4cf-ae1dd0858ea2
	SetID(UUID) CentralStats
	// Package version of the server. Might be simple a number of release like 21.11 or longer if you have a rolling release installed.
	// Format: server_version (server_version)
	// Example: 23.10
	ServerVersion() *ServerVersion
	// Package version of the server. Might be simple a number of release like 21.11 or longer if you have a rolling release installed.
	// Format: server_version (server_version)
	// Example: 23.10
	SetServerVersion(ServerVersion) CentralStats
	// Boot time of this instance.
	// Format: utc (Unix timestamp in seconds)
	// Example: 1.639337825e+09
	StartedAt() *Utc
	// Boot time of this instance.
	// Format: utc (Unix timestamp in seconds)
	// Example: 1.639337825e+09
	SetStartedAt(Utc) CentralStats
	// The server uptime.
	// Format: seconds (seconds)
	// Example: 4.325502e+06
	Uptime() *Seconds
	// The server uptime.
	// Format: seconds (seconds)
	// Example: 4.325502e+06
	SetUptime(Seconds) CentralStats
}

type CentralStreamConfig interface {
	// Whether to add an audio-only version of an HLS stream.
	// Used to create App Store compliant HLS streams to deliver the content to Apple iOS devices.
	// Example: true
	AddAudioOnly() *bool
	// Whether to add an audio-only version of an HLS stream.
	// Used to create App Store compliant HLS streams to deliver the content to Apple iOS devices.
	// Example: true
	SetAddAudioOnly(bool) CentralStreamConfig
	// If a connected source does not send audio data within this timeout period (in seconds),
	// the source connection is considered to be lost.
	// This is a default configuration for a stream, can be modified for any input.
	// Format: seconds (seconds)
	// Example: 20
	AudioTimeout() *Seconds
	// If a connected source does not send audio data within this timeout period (in seconds),
	// the source connection is considered to be lost.
	// This is a default configuration for a stream, can be modified for any input.
	// Format: seconds (seconds)
	// Example: 20
	SetAudioTimeout(Seconds) CentralStreamConfig
	// This option has sense only for published streams. For all other behavior is undefined and unpredicted.
	// If the value is greater than 0, Central will generate episodes for the stream automatically based on the
	// [stream DVR ranges](https://flussonic.com/doc/api/reference/#tag/stream-dvr/operation/stream_dvr_ranges_list).
	// Each range is considered an episode given that at least timeout seconds passed between these ranges.
	// An episode is created at the start of the publication and is closed after a timeout after the end of publication.
	// If new publication started in less than timeout - two publications will be merged into one episode.
	// Format: seconds (seconds)
	AutogeneratedEpisodesCloseTimeout() *Seconds
	// This option has sense only for published streams. For all other behavior is undefined and unpredicted.
	// If the value is greater than 0, Central will generate episodes for the stream automatically based on the
	// [stream DVR ranges](https://flussonic.com/doc/api/reference/#tag/stream-dvr/operation/stream_dvr_ranges_list).
	// Each range is considered an episode given that at least timeout seconds passed between these ranges.
	// An episode is created at the start of the publication and is closed after a timeout after the end of publication.
	// If new publication started in less than timeout - two publications will be merged into one episode.
	// Format: seconds (seconds)
	SetAutogeneratedEpisodesCloseTimeout(Seconds) CentralStreamConfig
	// When all inputs are down, this can be used to show at least something to users.
	// It is important to understand that backup video behaves differently, not as inputs.
	// It is not a _last input_ in the list. After any input stops sending frames, timer starts.
	// After `source_timeout` seconds backup starts working, while all other inputs are still trying to
	// connect and start working.
	// So backup and all inputs are working in parallel.
	Backup() BackupConfig
	// When all inputs are down, this can be used to show at least something to users.
	// It is important to understand that backup video behaves differently, not as inputs.
	// It is not a _last input_ in the list. After any input stops sending frames, timer starts.
	// After `source_timeout` seconds backup starts working, while all other inputs are still trying to
	// connect and start working.
	// So backup and all inputs are working in parallel.
	SetBackup(BackupConfig) CentralStreamConfig
	// Chunk duration in LL-HLS manifest to be used for tunning latency.
	// Format: milliseconds (milliseconds)
	// Example: 200
	ChunkDuration() *Milliseconds
	// Chunk duration in LL-HLS manifest to be used for tunning latency.
	// Format: milliseconds (milliseconds)
	// Example: 200
	SetChunkDuration(Milliseconds) CentralStreamConfig
	// User-defined claims about the stream parameters.
	// Set this field so that [layouter](https://flussonic.com/doc/api/layouter/) can rely on this data when distributing streams.
	Claims() CentralStreamLayoutConfigClaims
	// User-defined claims about the stream parameters.
	// Set this field so that [layouter](https://flussonic.com/doc/api/layouter/) can rely on this data when distributing streams.
	SetClaims(CentralStreamLayoutConfigClaims) CentralStreamConfig
	// Stream's lifetime after the last client was disconnected (can be expressed in *seconds* or set to `False`).
	// Applicable to on-demand streams **only**.
	// Example: 485
	ClientsTimeout() any
	// Stream's lifetime after the last client was disconnected (can be expressed in *seconds* or set to `False`).
	// Applicable to on-demand streams **only**.
	// Example: 485
	SetClientsTimeout(any) CentralStreamConfig
	// Human-readable description of the stream.
	// Example: This is a test stream
	Comment() *string
	// Human-readable description of the stream.
	// Example: This is a test stream
	SetComment(string) CentralStreamConfig
	// Part of the effective config from the configuration file.
	ConfigOnDisk() StreamConfigStripped
	// Part of the effective config from the configuration file.
	SetConfigOnDisk(StreamConfigStripped) CentralStreamConfig
	// Whether a stream is disabled. Disabled streams are inactive and do not run.
	// Displayed only with the API calls.
	// Example: false
	Disabled() *bool
	// Whether a stream is disabled. Disabled streams are inactive and do not run.
	// Displayed only with the API calls.
	// Example: false
	SetDisabled(bool) CentralStreamConfig
	// Configuraton of Digital Rights Management system (DRM).
	Drm() DrmSpec
	// Configuraton of Digital Rights Management system (DRM).
	SetDrm(DrmSpec) CentralStreamConfig
	// This parameter allows to manage subtitles in an output stream.
	// Example: replace
	Dvbocr() *StreamConfigInputDvbocr
	// This parameter allows to manage subtitles in an output stream.
	// Example: replace
	SetDvbocr(StreamConfigInputDvbocr) CentralStreamConfig
	// DVR configuraton.
	Dvr() StreamDvrSpec
	// DVR configuraton.
	SetDvr(StreamDvrSpec) CentralStreamConfig
	// Whether to extract EPG from the input.
	// Example: true
	EpgEnabled() *bool
	// Whether to extract EPG from the input.
	// Example: true
	SetEpgEnabled(bool) CentralStreamConfig
	// Whether to enable SCTE-35 ad insertion markers signaling in HLS manifest.
	// Ad markers can be included in SCTE-35 (`scte35`), AWS (`aws`), EXT-X-DATERANGE (`rfc8216`) formats or not included (`false`).
	// Example: scte35
	HlsScte35() *StreamConfigMediaHlsScte35
	// Whether to enable SCTE-35 ad insertion markers signaling in HLS manifest.
	// Ad markers can be included in SCTE-35 (`scte35`), AWS (`aws`), EXT-X-DATERANGE (`rfc8216`) formats or not included (`false`).
	// Example: scte35
	SetHlsScte35(StreamConfigMediaHlsScte35) CentralStreamConfig
	// Use this option for fine-grained control over each input track.
	// You can select, rename, change name and title for each video, audio track.
	InputMediaInfo() InputMediaInfo
	// Use this option for fine-grained control over each input track.
	// You can select, rename, change name and title for each video, audio track.
	SetInputMediaInfo(InputMediaInfo) CentralStreamConfig
	// List of stream inputs.
	// ***Important:*** A stream without any inputs can receive video frames **only** if backup file is specified.
	Inputs() []StreamInput
	// List of stream inputs.
	// ***Important:*** A stream without any inputs can receive video frames **only** if backup file is specified.
	SetInputs([]StreamInput) CentralStreamConfig
	// A key to sign jpeg_snapshot requests
	JpegSnapshotSignKey() *string
	// A key to sign jpeg_snapshot requests
	SetJpegSnapshotSignKey(string) CentralStreamConfig
	// Stream labels in key value format.
	// Key is a string in unix_name format (alphanumeric characters, underscores, hyphens and periods).
	// See [Layouter schema](https://flussonic.com/doc/api/layouter/#tag/stream/operation/streams_list/response%7Cstreams%7Clabels)
	// for more details.
	Labels() map[string]UnixName
	// Stream labels in key value format.
	// Key is a string in unix_name format (alphanumeric characters, underscores, hyphens and periods).
	// See [Layouter schema](https://flussonic.com/doc/api/layouter/#tag/stream/operation/streams_list/response%7Cstreams%7Clabels)
	// for more details.
	SetLabels(map[string]UnixName) CentralStreamConfig
	// Current layout of stream. Central will provide configuration to nodes based on this layout.
	Layout() CentralStreamLayout
	// Current layout of stream. Central will provide configuration to nodes based on this layout.
	SetLayout(CentralStreamLayout) CentralStreamConfig
	// The maximum time that Media Server will set for attempts to reconnect to sources when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	MaxRetryTimeout() *Seconds
	// The maximum time that Media Server will set for attempts to reconnect to sources when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	SetMaxRetryTimeout(Seconds) CentralStreamConfig
	// Deprecated field. Will be deleted at 23.12
	// The param is deprecated and now used only for onvif_url and onvif_profile options.
	Meta() map[string]string
	// Deprecated field. Will be deleted at 23.12
	// The param is deprecated and now used only for onvif_url and onvif_profile options.
	SetMeta(map[string]string) CentralStreamConfig
	// It allows to specify pack information about ac3 for outgoing MPEGTS-TS streams. The default value is `system_b`.
	MpegtsAc3() *OutputMpegtsAc3
	// It allows to specify pack information about ac3 for outgoing MPEGTS-TS streams. The default value is `system_b`.
	SetMpegtsAc3(OutputMpegtsAc3) CentralStreamConfig
	// This parameter sets PIDs values for outgoing MPEG-TS streams. PID contains information about the TS package content and can be decoded according to special service tables.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks. Tracks are numbered starting from one.
	// The code `a1=123` sets a PID value for the first audio track. It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, `t0=100` sets PID=101 for the first track, 102 for the second, and so on. Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	MpegtsPids() OutputMpegtsPids
	// This parameter sets PIDs values for outgoing MPEG-TS streams. PID contains information about the TS package content and can be decoded according to special service tables.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks. Tracks are numbered starting from one.
	// The code `a1=123` sets a PID value for the first audio track. It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, `t0=100` sets PID=101 for the first track, 102 for the second, and so on. Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	SetMpegtsPids(OutputMpegtsPids) CentralStreamConfig
	// Globally unique stream name.
	// Note that the name could not be changed after the stream is created.
	// Format: media_name (media_name)
	// Examples: Decklink-Stream, Dektec-Stream, hockey1, mylive/bunny, test_stream
	Name() MediaName
	// Globally unique stream name.
	// Note that the name could not be changed after the stream is created.
	// Format: media_name (media_name)
	// Examples: Decklink-Stream, Dektec-Stream, hockey1, mylive/bunny, test_stream
	SetName(MediaName) CentralStreamConfig
	// Where the stream is initialized: config, user play/publication, or remote
	// cluster server.
	// Example: config
	NamedBy() *NamedBy
	// Where the stream is initialized: config, user play/publication, or remote
	// cluster server.
	// Example: config
	SetNamedBy(NamedBy) CentralStreamConfig
	// Stream's logical namespace. Stream operations are only possible on streamers within the same namespace. By default, a stream has no assigned namespace. In this default state, it can interact with streamers that also have no assigned namespace. If a namespace is explicitly set, the stream will only interact with streamers possessing that specific namespace.
	// For example, the layouter will distribute streams only to streamers with the same namespace. The `dynamic_streams_list` endpoint will operate exclusively within a single namespace.
	// ***Use case:***
	// Namespaces provide strict, system-wide resource isolation, fundamentally separating streams and streamers into independent segments. This ensures no interaction, archive access, inference processing, or layout operations occur between different namespaces.
	// Unlike labels, which offer flexible, attribute-based layout control within a namespace, namespaces define an absolute boundary: resources from one namespace cannot interact with resources from another.
	// ***Important:***
	// A namespace can only be assigned when the stream is created and cannot be changed afterwards.
	// Format: unix_name (Contains only alphanumeric characters (a-z, A-Z, 0-9), underscores (_), hyphens (-) and periods (.).)
	// Pattern: ^[a-zA-Z0-9_.-]+$
	// Example: example
	Namespace() *UnixName
	// Stream's logical namespace. Stream operations are only possible on streamers within the same namespace. By default, a stream has no assigned namespace. In this default state, it can interact with streamers that also have no assigned namespace. If a namespace is explicitly set, the stream will only interact with streamers possessing that specific namespace.
	// For example, the layouter will distribute streams only to streamers with the same namespace. The `dynamic_streams_list` endpoint will operate exclusively within a single namespace.
	// ***Use case:***
	// Namespaces provide strict, system-wide resource isolation, fundamentally separating streams and streamers into independent segments. This ensures no interaction, archive access, inference processing, or layout operations occur between different namespaces.
	// Unlike labels, which offer flexible, attribute-based layout control within a namespace, namespaces define an absolute boundary: resources from one namespace cannot interact with resources from another.
	// ***Important:***
	// A namespace can only be assigned when the stream is created and cannot be changed afterwards.
	// Format: unix_name (Contains only alphanumeric characters (a-z, A-Z, 0-9), underscores (_), hyphens (-) and periods (.).)
	// Pattern: ^[a-zA-Z0-9_.-]+$
	// Example: example
	SetNamespace(UnixName) CentralStreamConfig
	// Configuration of authorization backend for play sessions.
	OnPlay() AuthSpec
	// Configuration of authorization backend for play sessions.
	SetOnPlay(AuthSpec) CentralStreamConfig
	// Configuration of authorization backend for publish sessions.
	OnPublish() AuthSpec
	// Configuration of authorization backend for publish sessions.
	SetOnPublish(AuthSpec) CentralStreamConfig
	// This parameter sets playback HTTP headers for streams.
	PlaybackHeaders() []PlaybackHeaders
	// This parameter sets playback HTTP headers for streams.
	SetPlaybackHeaders([]PlaybackHeaders) CentralStreamConfig
	// Position of the stream in order of streams in the config file, if declared.
	// Format: sort_index (sort_index)
	// Example: 2
	Position() *SortIndex
	// Position of the stream in order of streams in the config file, if declared.
	// Format: sort_index (sort_index)
	// Example: 2
	SetPosition(SortIndex) CentralStreamConfig
	// The time (in seconds) that Media Server reserves for preloading the data, i. e. *buffering*.
	// Prepush is always defined through GoP, but this option provides you with a more flexible way
	// to configure the buffer size, e. g. a 1-3 or 7-10 seconds time interval.
	// The bigger the buffer size, the better the user experience is for the users
	// with a bad internet connection. However, the latency also increases.
	// If set to `False` to remove the latency, the stream's start time
	// increases. To decrease it, reduce the GoP size and make the bitrate higher
	// or the video quality lower.
	// Example: false
	Prepush() any
	// The time (in seconds) that Media Server reserves for preloading the data, i. e. *buffering*.
	// Prepush is always defined through GoP, but this option provides you with a more flexible way
	// to configure the buffer size, e. g. a 1-3 or 7-10 seconds time interval.
	// The bigger the buffer size, the better the user experience is for the users
	// with a bad internet connection. However, the latency also increases.
	// If set to `False` to remove the latency, the stream's start time
	// increases. To decrease it, reduce the GoP size and make the bitrate higher
	// or the video quality lower.
	// Example: false
	SetPrepush(any) CentralStreamConfig
	// Configuration to allow/forbid playing the stream via various protocols.
	// - If the `whitelist` option is set to 'true', the server allows a playback only for listed protocols;
	// - If the `whitelist` option is set to 'false', the server forbids a playback for listed protocols;
	// - Server allows a playback for all the protocols by default.
	Protocols() PlayProtocolsSpec
	// Configuration to allow/forbid playing the stream via various protocols.
	// - If the `whitelist` option is set to 'true', the server allows a playback only for listed protocols;
	// - If the `whitelist` option is set to 'false', the server forbids a playback for listed protocols;
	// - Server allows a playback for all the protocols by default.
	SetProtocols(PlayProtocolsSpec) CentralStreamConfig
	// Deprecated field. Will be deleted at 25.03
	// Human-readable name of the content provider. Used, for example, for MPEG-TS.
	// Deprecated, use `input_media_info.provider` instead
	// Example: SportsTV
	Provider() *string
	// Deprecated field. Will be deleted at 25.03
	// Human-readable name of the content provider. Used, for example, for MPEG-TS.
	// Deprecated, use `input_media_info.provider` instead
	// Example: SportsTV
	SetProvider(string) CentralStreamConfig
	// A list of pushes. When a server initiates the connection and sends a stream
	// to other server(s), it is called a `push`.
	Pushes() []StreamPush
	// A list of pushes. When a server initiates the connection and sends a stream
	// to other server(s), it is called a `push`.
	SetPushes([]StreamPush) CentralStreamConfig
	// How often to re-check secondary inputs. If this option is not set than check is never performed.
	// Format: seconds (seconds)
	// Example: 120
	RecheckSecondaryInputsInterval() *Seconds
	// How often to re-check secondary inputs. If this option is not set than check is never performed.
	// Format: seconds (seconds)
	// Example: 120
	SetRecheckSecondaryInputsInterval(Seconds) CentralStreamConfig
	// Number of attempts for the server to reconnect to a data source.
	// Applicable to on-demand streams **only**. If not defined, server will constantly try to reconnect (unlimited number of retries).
	// If the input does not become active after specified amount of attempts, stream shuts down till the next user request.
	RetryLimit() *int
	// Number of attempts for the server to reconnect to a data source.
	// Applicable to on-demand streams **only**. If not defined, server will constantly try to reconnect (unlimited number of retries).
	// If the input does not become active after specified amount of attempts, stream shuts down till the next user request.
	SetRetryLimit(int) CentralStreamConfig
	// Number of segments stored in memory for the segment-based protocols, such as HLS and DASH.
	// Added to HLS live manifest. Do not forget that one more segment is stored for stale clients
	// that come too late, but the latest segment is not shown in the manifest.
	// Example: 4
	SegmentCount() *int
	// Number of segments stored in memory for the segment-based protocols, such as HLS and DASH.
	// Added to HLS live manifest. Do not forget that one more segment is stored for stale clients
	// that come too late, but the latest segment is not shown in the manifest.
	// Example: 4
	SetSegmentCount(int) CentralStreamConfig
	// The time of the segment duration. Used for the protocols like HLS or DASH.
	// The disk config offers this value in seconds.
	// Example: 5000
	SegmentDuration() *Milliseconds
	// The time of the segment duration. Used for the protocols like HLS or DASH.
	// The disk config offers this value in seconds.
	// Example: 5000
	SetSegmentDuration(Milliseconds) CentralStreamConfig
	// If a connected source does not send any data within this timeout period (in seconds),
	// the source connection is considered to be lost.
	// This is a default configuration for a stream, can be modified for any input.
	// Example: 10
	SourceTimeout() any
	// If a connected source does not send any data within this timeout period (in seconds),
	// the source connection is considered to be lost.
	// This is a default configuration for a stream, can be modified for any input.
	// Example: 10
	SetSourceTimeout(any) CentralStreamConfig
	// SRT2 publishing configuration for a stream.
	Srt2Publish() SrtConfig
	// SRT2 publishing configuration for a stream.
	SetSrt2Publish(SrtConfig) CentralStreamConfig
	// Deprecated field. Will be deleted at 24.06
	// Stream name was resolved via `srt_port_resolve` call.
	// See [endpoint](https://flussonic.com/doc/api/config-external/#tag/srt/operation/srt_port_resolve)
	// and [listener](https://flussonic.com/doc/api/reference/#tag/config/operation/config_save%7Cbody%7Clisteners%7Csrt)
	// for feature description.
	// This parameter now lives in `stats` object.
	// Example: false
	SrtPortResolve() *bool
	// Deprecated field. Will be deleted at 24.06
	// Stream name was resolved via `srt_port_resolve` call.
	// See [endpoint](https://flussonic.com/doc/api/config-external/#tag/srt/operation/srt_port_resolve)
	// and [listener](https://flussonic.com/doc/api/reference/#tag/config/operation/config_save%7Cbody%7Clisteners%7Csrt)
	// for feature description.
	// This parameter now lives in `stats` object.
	// Example: false
	SetSrtPortResolve(bool) CentralStreamConfig
	// SRT publishing configuration for a stream.
	SrtPublish() SrtConfig
	// SRT publishing configuration for a stream.
	SetSrtPublish(SrtConfig) CentralStreamConfig
	// Whether a stream is `static` or not.
	// If set to `True` the server will try to keep this stream running even if
	// there are no viewers or errors encountered.
	// Streamer restarts *all* `static` streams even if any internal errors occur
	// and the `static` streams crash.
	// Example: true
	Static() *bool
	// Whether a stream is `static` or not.
	// If set to `True` the server will try to keep this stream running even if
	// there are no viewers or errors encountered.
	// Streamer restarts *all* `static` streams even if any internal errors occur
	// and the `static` streams crash.
	// Example: true
	SetStatic(bool) CentralStreamConfig
	// Stream's metrics and other statistical information.
	Stats() StreamStats
	// Stream's metrics and other statistical information.
	SetStats(StreamStats) CentralStreamConfig
	// Template of the stream.
	// Format: media_name (media_name)
	// Example: sports-hd
	Template() *MediaName
	// Template of the stream.
	// Format: media_name (media_name)
	// Example: sports-hd
	SetTemplate(MediaName) CentralStreamConfig
	// Configuration of thumbnails generator.
	Thumbnails() ThumbnailsSpec
	// Configuration of thumbnails generator.
	SetThumbnails(ThumbnailsSpec) CentralStreamConfig
	// Human-readable title of the stream. Provided for SDT MPEG-TS table or
	// SDP RTSP title parameter.
	// Example: Hockey channel
	Title() *string
	// Human-readable title of the stream. Provided for SDT MPEG-TS table or
	// SDP RTSP title parameter.
	// Example: Hockey channel
	SetTitle(string) CentralStreamConfig
	// Configuration of the transcoder settings.
	// Examples: map[]
	Transcoder() TranscoderOpts
	// Configuration of the transcoder settings.
	// Examples: map[]
	SetTranscoder(TranscoderOpts) CentralStreamConfig
	// Transport protocol for WebRTC.
	Transport() *WebrtcTransport
	// Transport protocol for WebRTC.
	SetTransport(WebrtcTransport) CentralStreamConfig
	// The time of the last change of any stream field.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637098611e+12
	UpdatedAt() UtcMs
	// The time of the last change of any stream field.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637098611e+12
	SetUpdatedAt(UtcMs) CentralStreamConfig
	// A string starting the addresses of separate segments within a *segment-based* playlists (HLS or DASH).
	// Each sub-playlist is stored on Media Server.
	// If set to `false`, the configured value in a template will be disabled.
	URLPrefix() *URLPrefix
	// A string starting the addresses of separate segments within a *segment-based* playlists (HLS or DASH).
	// Each sub-playlist is stored on Media Server.
	// If set to `false`, the configured value in a template will be disabled.
	SetURLPrefix(*URLPrefix) CentralStreamConfig
	// If a connected source does not send video data within this timeout period (in seconds),
	// the source connection is considered to be lost.
	// This is a default configuration for a stream, can be modified for any input.
	// Format: seconds (seconds)
	// Example: 20
	VideoTimeout() *Seconds
	// If a connected source does not send video data within this timeout period (in seconds),
	// the source connection is considered to be lost.
	// This is a default configuration for a stream, can be modified for any input.
	// Format: seconds (seconds)
	// Example: 20
	SetVideoTimeout(Seconds) CentralStreamConfig
	// Video analytics parameters.
	Vision() VisionSpec
	// Video analytics parameters.
	SetVision(VisionSpec) CentralStreamConfig
	// WebRTC play configuration for a stream.
	WebrtcAbr() WebrtcAbrOpts
	// WebRTC play configuration for a stream.
	SetWebrtcAbr(WebrtcAbrOpts) CentralStreamConfig
}

// Required: updated_at
type CentralStreamConfigAdditional interface {
	// This option has sense only for published streams. For all other behavior is undefined and unpredicted.
	// If the value is greater than 0, Central will generate episodes for the stream automatically based on the
	// [stream DVR ranges](https://flussonic.com/doc/api/reference/#tag/stream-dvr/operation/stream_dvr_ranges_list).
	// Each range is considered an episode given that at least timeout seconds passed between these ranges.
	// An episode is created at the start of the publication and is closed after a timeout after the end of publication.
	// If new publication started in less than timeout - two publications will be merged into one episode.
	// Format: seconds (seconds)
	AutogeneratedEpisodesCloseTimeout() *Seconds
	// This option has sense only for published streams. For all other behavior is undefined and unpredicted.
	// If the value is greater than 0, Central will generate episodes for the stream automatically based on the
	// [stream DVR ranges](https://flussonic.com/doc/api/reference/#tag/stream-dvr/operation/stream_dvr_ranges_list).
	// Each range is considered an episode given that at least timeout seconds passed between these ranges.
	// An episode is created at the start of the publication and is closed after a timeout after the end of publication.
	// If new publication started in less than timeout - two publications will be merged into one episode.
	// Format: seconds (seconds)
	SetAutogeneratedEpisodesCloseTimeout(Seconds) CentralStreamConfigAdditional
	// Stream's logical namespace. Stream operations are only possible on streamers within the same namespace. By default, a stream has no assigned namespace. In this default state, it can interact with streamers that also have no assigned namespace. If a namespace is explicitly set, the stream will only interact with streamers possessing that specific namespace.
	// For example, the layouter will distribute streams only to streamers with the same namespace. The `dynamic_streams_list` endpoint will operate exclusively within a single namespace.
	// ***Use case:***
	// Namespaces provide strict, system-wide resource isolation, fundamentally separating streams and streamers into independent segments. This ensures no interaction, archive access, inference processing, or layout operations occur between different namespaces.
	// Unlike labels, which offer flexible, attribute-based layout control within a namespace, namespaces define an absolute boundary: resources from one namespace cannot interact with resources from another.
	// ***Important:***
	// A namespace can only be assigned when the stream is created and cannot be changed afterwards.
	// Format: unix_name (Contains only alphanumeric characters (a-z, A-Z, 0-9), underscores (_), hyphens (-) and periods (.).)
	// Pattern: ^[a-zA-Z0-9_.-]+$
	// Example: example
	Namespace() *UnixName
	// Stream's logical namespace. Stream operations are only possible on streamers within the same namespace. By default, a stream has no assigned namespace. In this default state, it can interact with streamers that also have no assigned namespace. If a namespace is explicitly set, the stream will only interact with streamers possessing that specific namespace.
	// For example, the layouter will distribute streams only to streamers with the same namespace. The `dynamic_streams_list` endpoint will operate exclusively within a single namespace.
	// ***Use case:***
	// Namespaces provide strict, system-wide resource isolation, fundamentally separating streams and streamers into independent segments. This ensures no interaction, archive access, inference processing, or layout operations occur between different namespaces.
	// Unlike labels, which offer flexible, attribute-based layout control within a namespace, namespaces define an absolute boundary: resources from one namespace cannot interact with resources from another.
	// ***Important:***
	// A namespace can only be assigned when the stream is created and cannot be changed afterwards.
	// Format: unix_name (Contains only alphanumeric characters (a-z, A-Z, 0-9), underscores (_), hyphens (-) and periods (.).)
	// Pattern: ^[a-zA-Z0-9_.-]+$
	// Example: example
	SetNamespace(UnixName) CentralStreamConfigAdditional
	// The time of the last change of any stream field.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637098611e+12
	UpdatedAt() UtcMs
	// The time of the last change of any stream field.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637098611e+12
	SetUpdatedAt(UtcMs) CentralStreamConfigAdditional
}

type CentralStreamLayout interface {
	// Reason why layout was changed
	ChangeReason() *CentralStreamLayoutChangeReason
	// Reason why layout was changed
	SetChangeReason(CentralStreamLayoutChangeReason) CentralStreamLayout
	// Time when the node change occurred
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	CreatedAt() *UtcMs
	// Time when the node change occurred
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	SetCreatedAt(UtcMs) CentralStreamLayout
	// Current nodes on which the dvr backup is saving
	DvrBackups() []ServerName
	// Current nodes on which the dvr backup is saving
	SetDvrBackups([]ServerName) CentralStreamLayout
	// Hostname of node on which the stream was captured before failover.
	// This field is used to restore the [layout.ingest](https://flussonic.com/doc/api/central/#tag/stream/operation/stream_get/response%7Clayout%7Cingest)
	// after failover.
	// Format: server_name (server_name)
	FailoverFrom() *ServerName
	// Hostname of node on which the stream was captured before failover.
	// This field is used to restore the [layout.ingest](https://flussonic.com/doc/api/central/#tag/stream/operation/stream_get/response%7Clayout%7Cingest)
	// after failover.
	// Format: server_name (server_name)
	SetFailoverFrom(ServerName) CentralStreamLayout
	// Hostname of current inference node on which stream analytics running.
	// Format: server_name (server_name)
	Inference() *ServerName
	// Hostname of current inference node on which stream analytics running.
	// Format: server_name (server_name)
	SetInference(ServerName) CentralStreamLayout
	// Hostname of current ingest on which the stream is being captured
	// Format: server_name (server_name)
	Ingest() *ServerName
	// Hostname of current ingest on which the stream is being captured
	// Format: server_name (server_name)
	SetIngest(ServerName) CentralStreamLayout
	// History of layout ingest. This field includes only 5 last records.
	// This field is only returned with explicit `include_ingest_history=true` query param.
	IngestHistory() []CentralStreamLayoutBase
	// History of layout ingest. This field includes only 5 last records.
	// This field is only returned with explicit `include_ingest_history=true` query param.
	SetIngestHistory([]CentralStreamLayoutBase) CentralStreamLayout
	// List of decisions made by [layouter](https://flussonic.com/doc/api/layouter/) for each node.
	// These decisions are used to determine the final layout of the stream.
	NodeLayoutDecisions() []CentralNodeLayoutDecision
	// List of decisions made by [layouter](https://flussonic.com/doc/api/layouter/) for each node.
	// These decisions are used to determine the final layout of the stream.
	SetNodeLayoutDecisions([]CentralNodeLayoutDecision) CentralStreamLayout
	// Service or admin user who changed the layout of the stream using an API call.
	Originator() *CentralStreamLayoutOriginator
	// Service or admin user who changed the layout of the stream using an API call.
	SetOriginator(CentralStreamLayoutOriginator) CentralStreamLayout
}

type CentralStreamLayoutBase interface {
	// Time when the node change occurred
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	CreatedAt() *UtcMs
	// Time when the node change occurred
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	SetCreatedAt(UtcMs) CentralStreamLayoutBase
	// Hostname of current ingest on which the stream is being captured
	// Format: server_name (server_name)
	Ingest() *ServerName
	// Hostname of current ingest on which the stream is being captured
	// Format: server_name (server_name)
	SetIngest(ServerName) CentralStreamLayoutBase
	// Service or admin user who changed the layout of the stream using an API call.
	Originator() *CentralStreamLayoutOriginator
	// Service or admin user who changed the layout of the stream using an API call.
	SetOriginator(CentralStreamLayoutOriginator) CentralStreamLayoutBase
}

type CentralStreamLayoutConfig interface {
	// User-defined claims about the stream parameters.
	// Set this field so that [layouter](https://flussonic.com/doc/api/layouter/) can rely on this data when distributing streams.
	Claims() CentralStreamLayoutConfigClaims
	// User-defined claims about the stream parameters.
	// Set this field so that [layouter](https://flussonic.com/doc/api/layouter/) can rely on this data when distributing streams.
	SetClaims(CentralStreamLayoutConfigClaims) CentralStreamLayoutConfig
	// Current layout of stream. Central will provide configuration to nodes based on this layout.
	Layout() CentralStreamLayout
	// Current layout of stream. Central will provide configuration to nodes based on this layout.
	SetLayout(CentralStreamLayout) CentralStreamLayoutConfig
}

// User-defined claims about the stream parameters.
// Set this field so that [layouter](https://flussonic.com/doc/api/layouter/) can rely on this data when distributing streams.
type CentralStreamLayoutConfigClaims interface {
	// Stream bitrate in kbps.
	// This value is used to calculate disk and network consumption.
	// Format: speed (speed)
	// Example: 2543
	Bitrate() *Speed
	// Stream bitrate in kbps.
	// This value is used to calculate disk and network consumption.
	// Format: speed (speed)
	// Example: 2543
	SetBitrate(Speed) CentralStreamLayoutConfigClaims
}

type CentralStreamLayoutList interface {
	// List of streams layouts
	Layouts() []CentralStreamLayoutListItem
	// List of streams layouts
	SetLayouts([]CentralStreamLayoutListItem) CentralStreamLayoutList
}

type CentralStreamLayoutListItem interface {
	// Reason why layout was changed
	ChangeReason() *CentralStreamLayoutChangeReason
	// Reason why layout was changed
	SetChangeReason(CentralStreamLayoutChangeReason) CentralStreamLayoutListItem
	// Time when the node change occurred
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	CreatedAt() *UtcMs
	// Time when the node change occurred
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	SetCreatedAt(UtcMs) CentralStreamLayoutListItem
	// Current nodes on which the dvr backup is saving
	DvrBackups() []ServerName
	// Current nodes on which the dvr backup is saving
	SetDvrBackups([]ServerName) CentralStreamLayoutListItem
	// Hostname of node on which the stream was captured before failover.
	// This field is used to restore the [layout.ingest](https://flussonic.com/doc/api/central/#tag/stream/operation/stream_get/response%7Clayout%7Cingest)
	// after failover.
	// Format: server_name (server_name)
	FailoverFrom() *ServerName
	// Hostname of node on which the stream was captured before failover.
	// This field is used to restore the [layout.ingest](https://flussonic.com/doc/api/central/#tag/stream/operation/stream_get/response%7Clayout%7Cingest)
	// after failover.
	// Format: server_name (server_name)
	SetFailoverFrom(ServerName) CentralStreamLayoutListItem
	// Hostname of current inference node on which stream analytics running.
	// Format: server_name (server_name)
	Inference() *ServerName
	// Hostname of current inference node on which stream analytics running.
	// Format: server_name (server_name)
	SetInference(ServerName) CentralStreamLayoutListItem
	// Hostname of current ingest on which the stream is being captured
	// Format: server_name (server_name)
	Ingest() *ServerName
	// Hostname of current ingest on which the stream is being captured
	// Format: server_name (server_name)
	SetIngest(ServerName) CentralStreamLayoutListItem
	// History of layout ingest. This field includes only 5 last records.
	// This field is only returned with explicit `include_ingest_history=true` query param.
	IngestHistory() []CentralStreamLayoutBase
	// History of layout ingest. This field includes only 5 last records.
	// This field is only returned with explicit `include_ingest_history=true` query param.
	SetIngestHistory([]CentralStreamLayoutBase) CentralStreamLayoutListItem
	// Name of the stream
	Name() *string
	// Name of the stream
	SetName(string) CentralStreamLayoutListItem
	// List of decisions made by [layouter](https://flussonic.com/doc/api/layouter/) for each node.
	// These decisions are used to determine the final layout of the stream.
	NodeLayoutDecisions() []CentralNodeLayoutDecision
	// List of decisions made by [layouter](https://flussonic.com/doc/api/layouter/) for each node.
	// These decisions are used to determine the final layout of the stream.
	SetNodeLayoutDecisions([]CentralNodeLayoutDecision) CentralStreamLayoutListItem
	// Service or admin user who changed the layout of the stream using an API call.
	Originator() *CentralStreamLayoutOriginator
	// Service or admin user who changed the layout of the stream using an API call.
	SetOriginator(CentralStreamLayoutOriginator) CentralStreamLayoutListItem
}

type CentralStreamLayoutPrediction interface {
	// List of streams layout changes
	Changes() []CentralStreamLayoutListItem
	// List of streams layout changes
	SetChanges([]CentralStreamLayoutListItem) CentralStreamLayoutPrediction
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	EstimatedCount() *int
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	SetEstimatedCount(int) CentralStreamLayoutPrediction
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	Next() *string
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	SetNext(string) CentralStreamLayoutPrediction
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	Prev() *string
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	SetPrev(string) CentralStreamLayoutPrediction
	// An object with a list of different timings measured during this API call.
	Timing() any
	// An object with a list of different timings measured during this API call.
	SetTiming(any) CentralStreamLayoutPrediction
	// Collection returns the collection items
	Collection() []CentralStreamLayoutListItem
}

type CentralStreamLayouts interface {
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	EstimatedCount() *int
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	SetEstimatedCount(int) CentralStreamLayouts
	// List of streams layouts records according to the query parameters.
	Layouts() []CentralStreamLayout
	// List of streams layouts records according to the query parameters.
	SetLayouts([]CentralStreamLayout) CentralStreamLayouts
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	Next() *string
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	SetNext(string) CentralStreamLayouts
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	Prev() *string
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	SetPrev(string) CentralStreamLayouts
	// An object with a list of different timings measured during this API call.
	Timing() any
	// An object with a list of different timings measured during this API call.
	SetTiming(any) CentralStreamLayouts
	// Collection returns the collection items
	Collection() []CentralStreamLayout
}

type CentralStreamerLayoutPrediction interface {
	// Predicted layout based on changed properties of streamer grouped by hostname and role.
	// The result does not contain unchanged streamers.
	// If streamer config was not changed, the result will be empty.
	Changes() []CentralStreamerLayoutPredictionItem
	// Predicted layout based on changed properties of streamer grouped by hostname and role.
	// The result does not contain unchanged streamers.
	// If streamer config was not changed, the result will be empty.
	SetChanges([]CentralStreamerLayoutPredictionItem) CentralStreamerLayoutPrediction
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	EstimatedCount() *int
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	SetEstimatedCount(int) CentralStreamerLayoutPrediction
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	Next() *string
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	SetNext(string) CentralStreamerLayoutPrediction
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	Prev() *string
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	SetPrev(string) CentralStreamerLayoutPrediction
	// An object with a list of different timings measured during this API call.
	Timing() any
	// An object with a list of different timings measured during this API call.
	SetTiming(any) CentralStreamerLayoutPrediction
	// Collection returns the collection items
	Collection() []CentralStreamerLayoutPredictionItem
}

type CentralStreamerLayoutPredictionItem interface {
	// Number of streams assigned to the streamer after the layouter iteration.
	// Example: 123
	After() *int
	// Number of streams assigned to the streamer after the layouter iteration.
	// Example: 123
	SetAfter(int) CentralStreamerLayoutPredictionItem
	// Number of streams assigned to the streamer before the layouter iteration.
	// Example: 321
	Before() *int
	// Number of streams assigned to the streamer before the layouter iteration.
	// Example: 321
	SetBefore(int) CentralStreamerLayoutPredictionItem
	// `after - before` value.
	// Example: 1
	Delta() *int
	// `after - before` value.
	// Example: 1
	SetDelta(int) CentralStreamerLayoutPredictionItem
	// Hostname of streamer
	// Format: server_name (server_name)
	// Example: streamer1
	Hostname() *ServerName
	// Hostname of streamer
	// Format: server_name (server_name)
	// Example: streamer1
	SetHostname(ServerName) CentralStreamerLayoutPredictionItem
	// Layout role of streamer.
	// Example: ingest
	Role() *CentralStreamerLayoutPredictionItemRole
	// Layout role of streamer.
	// Example: ingest
	SetRole(CentralStreamerLayoutPredictionItemRole) CentralStreamerLayoutPredictionItem
}

type CentralStreamerNode interface {
	// The URL for provisioning of configuration from the managing server to the streamer.
	// This URL does not have to be public but must be accessible from the managing server.
	// The API URL can also be used as Public and/or Private payload URL if they are not set.
	// When used as Public payload URL, the API URL shall be public to allow playback from this streamer.
	// Format: url (url)
	// Example: http://streamer.local:8080
	APIURL() *URL
	// The URL for provisioning of configuration from the managing server to the streamer.
	// This URL does not have to be public but must be accessible from the managing server.
	// The API URL can also be used as Public and/or Private payload URL if they are not set.
	// When used as Public payload URL, the API URL shall be public to allow playback from this streamer.
	// Format: url (url)
	// Example: http://streamer.local:8080
	SetAPIURL(URL) CentralStreamerNode
	// Maximal number of streams.
	// Example: 5
	ChannelLimit() *int
	// Maximal number of streams.
	// Example: 5
	SetChannelLimit(int) CentralStreamerNode
	// The key for authorization for inter-Flussonic connections.
	// All cluster peers should have the same cluster key.
	// Example: xS6i6Q3DCc5nEvnu
	ClusterKey() *string
	// The key for authorization for inter-Flussonic connections.
	// All cluster peers should have the same cluster key.
	// Example: xS6i6Q3DCc5nEvnu
	SetClusterKey(string) CentralStreamerNode
	// Flussonic Media Server configuration which will be provided to Streamer
	Config() CentralStreamerNodeConfig
	// Flussonic Media Server configuration which will be provided to Streamer
	SetConfig(CentralStreamerNodeConfig) CentralStreamerNode
	// CPU limit in percents.
	// Format: percent (percent)
	// Example: 10
	CpuLimit() *Percent
	// CPU limit in percents.
	// Format: percent (percent)
	// Example: 10
	SetCpuLimit(Percent) CentralStreamerNode
	// The configuration of the DVRs
	Dvrs() []DvrConfig
	// The configuration of the DVRs
	SetDvrs([]DvrConfig) CentralStreamerNode
	// How often the peer will try to get the data from the remote server via internal API.
	// Format: milliseconds (milliseconds)
	// Example: 1000
	FetchTimeout() *Milliseconds
	// How often the peer will try to get the data from the remote server via internal API.
	// Format: milliseconds (milliseconds)
	// Example: 1000
	SetFetchTimeout(Milliseconds) CentralStreamerNode
	// Streamer's identifier in the cluster.
	// The managing server may try using this hostname to access the streamer
	// if API URL is not specified.
	// Format: server_name (server_name)
	// Example: peer.example.com
	Hostname() *ServerName
	// Streamer's identifier in the cluster.
	// The managing server may try using this hostname to access the streamer
	// if API URL is not specified.
	// Format: server_name (server_name)
	// Example: peer.example.com
	SetHostname(ServerName) CentralStreamerNode
	// Flag indicating the Streamer's ability to act as a restreamer.
	// See [dynamic_streams_list](https://flussonic.com/doc/api/config-external/#tag/stream/operation/dynamic_streams_list)
	// operation for more info
	IsRestreamer() *bool
	// Flag indicating the Streamer's ability to act as a restreamer.
	// See [dynamic_streams_list](https://flussonic.com/doc/api/config-external/#tag/stream/operation/dynamic_streams_list)
	// operation for more info
	SetIsRestreamer(bool) CentralStreamerNode
	Labels() map[string]UnixName
	SetLabels(map[string]UnixName) CentralStreamerNode
	// Deprecated field. Will be deleted at 23.09
	// Maximal output bitrate of the peer.
	// Format: speed (speed)
	MaxBitrate() *Speed
	// Deprecated field. Will be deleted at 23.09
	// Maximal output bitrate of the peer.
	// Format: speed (speed)
	SetMaxBitrate(Speed) CentralStreamerNode
	// Streamer's logical namespace, used for interacting with streams of the same namespace. By default, a streamer has no assigned namespace. In this default state, it can interact with streams that also have no assigned namespace. If a namespace is explicitly set, the streamer will only interact with streams possessing that specific namespace.
	// For example, the layouter will distribute streams only to streamers with the same namespace. The `dynamic_streams_list` endpoint will operate exclusively within a single namespace.
	// ***Use case:***
	// Namespaces provide strict, system-wide resource isolation, fundamentally separating streams and streamers into independent segments. This ensures no interaction, archive access, inference processing, or layout operations occur between different namespaces.
	// Unlike labels, which offer flexible, attribute-based layout control within a namespace, namespaces define an absolute boundary: resources from one namespace cannot interact with resources from another.
	// ***Important:***
	// A namespace can only be assigned when the streamer is created and cannot be changed afterwards.
	// Format: unix_name (Contains only alphanumeric characters (a-z, A-Z, 0-9), underscores (_), hyphens (-) and periods (.).)
	// Pattern: ^[a-zA-Z0-9_.-]+$
	// Example: example
	Namespace() *UnixName
	// Streamer's logical namespace, used for interacting with streams of the same namespace. By default, a streamer has no assigned namespace. In this default state, it can interact with streams that also have no assigned namespace. If a namespace is explicitly set, the streamer will only interact with streams possessing that specific namespace.
	// For example, the layouter will distribute streams only to streamers with the same namespace. The `dynamic_streams_list` endpoint will operate exclusively within a single namespace.
	// ***Use case:***
	// Namespaces provide strict, system-wide resource isolation, fundamentally separating streams and streamers into independent segments. This ensures no interaction, archive access, inference processing, or layout operations occur between different namespaces.
	// Unlike labels, which offer flexible, attribute-based layout control within a namespace, namespaces define an absolute boundary: resources from one namespace cannot interact with resources from another.
	// ***Important:***
	// A namespace can only be assigned when the streamer is created and cannot be changed afterwards.
	// Format: unix_name (Contains only alphanumeric characters (a-z, A-Z, 0-9), underscores (_), hyphens (-) and periods (.).)
	// Pattern: ^[a-zA-Z0-9_.-]+$
	// Example: example
	SetNamespace(UnixName) CentralStreamerNode
	// The internal address for communication in a local network (by default, it is equal to API URL).
	// Format: url (url)
	// Example: http://streamer.local
	PrivatePayloadURL() *URL
	// The internal address for communication in a local network (by default, it is equal to API URL).
	// Format: url (url)
	// Example: http://streamer.local
	SetPrivatePayloadURL(URL) CentralStreamerNode
	// The public address that is exposed to clients. It can also contain a port number.
	// The client will be redirected to this URL and port when requesting for the stream captured on the peer
	// even if other `http` port is set in the peer's own config.
	// Format: url (url)
	// Example: http://public.example.com
	PublicPayloadURL() *URL
	// The public address that is exposed to clients. It can also contain a port number.
	// The client will be redirected to this URL and port when requesting for the stream captured on the peer
	// even if other `http` port is set in the peer's own config.
	// Format: url (url)
	// Example: http://public.example.com
	SetPublicPayloadURL(URL) CentralStreamerNode
	// Role of node
	Role() *CentralNodeRoleRole
	// Role of node
	SetRole(CentralNodeRoleRole) CentralStreamerNode
	// The time after which deleted streams on this server are considered to be inactive
	// and cannot be used in the `cluster_ingest` mechanism.
	// Format: milliseconds (milliseconds)
	// Example: 1000
	StaleTimeout() *Milliseconds
	// The time after which deleted streams on this server are considered to be inactive
	// and cannot be used in the `cluster_ingest` mechanism.
	// Format: milliseconds (milliseconds)
	// Example: 1000
	SetStaleTimeout(Milliseconds) CentralStreamerNode
	// Statistics on peers in the cluster.
	Stats() PeerStats
	// Statistics on peers in the cluster.
	SetStats(PeerStats) CentralStreamerNode
	// Server network bandwidth limit in kbit.
	// This value is used to calculate the current network load status.
	// Format: speed (speed)
	// Example: 1024
	TotalBandwidth() *Speed
	// Server network bandwidth limit in kbit.
	// This value is used to calculate the current network load status.
	// Format: speed (speed)
	// Example: 1024
	SetTotalBandwidth(Speed) CentralStreamerNode
}

// Flussonic Media Server configuration which will be provided to Streamer
type CentralStreamerNodeConfig interface {
	// The cluster key to unite several servers with the same key into a cluster.
	// Example: xS6i6Q3DCc5nEvnu
	ClusterKey() *string
	// The cluster key to unite several servers with the same key into a cluster.
	// Example: xS6i6Q3DCc5nEvnu
	SetClusterKey(string) CentralStreamerNodeConfig
	// The configuration of event notifications
	EventSinks() []EventSinkConfig
	// The configuration of event notifications
	SetEventSinks([]EventSinkConfig) CentralStreamerNodeConfig
	// List of HTTP prefixes that can be handled via call to remote http server
	HTTPProxies() []HTTPProxyConfig
	// List of HTTP prefixes that can be handled via call to remote http server
	SetHTTPProxies([]HTTPProxyConfig) CentralStreamerNodeConfig
	// The configuration of the port forwarding.
	Rproxy() RproxyConfig
	// The configuration of the port forwarding.
	SetRproxy(RproxyConfig) CentralStreamerNodeConfig
	// The configuration of server domain name and aliases
	ServerNames() []ServerNameConfig
	// The configuration of server domain name and aliases
	SetServerNames([]ServerNameConfig) CentralStreamerNodeConfig
}

type CentralStreamsList interface {
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	EstimatedCount() *int
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	SetEstimatedCount(int) CentralStreamsList
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	Next() *string
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	SetNext(string) CentralStreamsList
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	Prev() *string
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	SetPrev(string) CentralStreamsList
	// List of fetched streams according to the query parameters.
	Streams() []CentralStreamConfig
	// List of fetched streams according to the query parameters.
	SetStreams([]CentralStreamConfig) CentralStreamsList
	// An object with a list of different timings measured during this API call.
	Timing() any
	// An object with a list of different timings measured during this API call.
	SetTiming(any) CentralStreamsList
	// Collection returns the collection items
	Collection() []CentralStreamConfig
}

type ClosedCaptions interface {
	// Language of closed captions.
	// Example: eng
	Language() *string
	// Language of closed captions.
	// Example: eng
	SetLanguage(string) ClosedCaptions
	// Under what name the audio track will be displayed on the player.
	// Example: English
	Name() *string
	// Under what name the audio track will be displayed on the player.
	// Example: English
	SetName(string) ClosedCaptions
}

// Number of entities, grouped by status
type ClusterHealthMetricsTotal interface {
	// Number of degraded entities
	Degradated() *int
	// Number of degraded entities
	SetDegradated(int) ClusterHealthMetricsTotal
	// Number of disabled entities
	Disabled() *int
	// Number of disabled entities
	SetDisabled(int) ClusterHealthMetricsTotal
	// Number of operational entities
	Operational() *int
	// Number of operational entities
	SetOperational(int) ClusterHealthMetricsTotal
	// Number of outage entities
	Outage() *int
	// Number of outage entities
	SetOutage(int) ClusterHealthMetricsTotal
	// Number of partial outage entities
	PartialOutage() *int
	// Number of partial outage entities
	SetPartialOutage(int) ClusterHealthMetricsTotal
	// Total number of entities
	Total() *int
	// Total number of entities
	SetTotal(int) ClusterHealthMetricsTotal
}

type ClusterHealthStats interface {
	// Number of agents, grouped by status
	AgentMetricsTotal() ClusterHealthMetricsTotal
	// Number of agents, grouped by status
	SetAgentMetricsTotal(ClusterHealthMetricsTotal) ClusterHealthStats
	// Metrics collection time
	// Format: utc_ms (Unix timestamp in milliseconds)
	CollectedAt() *UtcMs
	// Metrics collection time
	// Format: utc_ms (Unix timestamp in milliseconds)
	SetCollectedAt(UtcMs) ClusterHealthStats
	// Unique server ID generated on a first run.
	// Format: uuid (uuid)
	// Example: 123e4567-e89b-12d3-a456-426655440000
	ServerID() *UUID
	// Unique server ID generated on a first run.
	// Format: uuid (uuid)
	// Example: 123e4567-e89b-12d3-a456-426655440000
	SetServerID(UUID) ClusterHealthStats
	// Number of streams, grouped by status
	StreamMetricsTotal() ClusterHealthMetricsTotal
	// Number of streams, grouped by status
	SetStreamMetricsTotal(ClusterHealthMetricsTotal) ClusterHealthStats
	// Cluster total bitrate metrics
	StreamerBitrateMetricsTotal() ClusterHealthStatsStreamerBitrateMetricsTotal
	// Cluster total bitrate metrics
	SetStreamerBitrateMetricsTotal(ClusterHealthStatsStreamerBitrateMetricsTotal) ClusterHealthStats
	// Streamer stats
	StreamerMetrics() []ClusterHealthStreamerStats
	// Streamer stats
	SetStreamerMetrics([]ClusterHealthStreamerStats) ClusterHealthStats
	// Number of streamers, grouped by status
	StreamerMetricsTotal() ClusterHealthMetricsTotal
	// Number of streamers, grouped by status
	SetStreamerMetricsTotal(ClusterHealthMetricsTotal) ClusterHealthStats
	// The running version of instance in format TAGCNUM. TAG is a five-digit number that contains the year number, month number, and version number. CNUM is a four-digit number that indicates the commit number. Number 240100023 represents version 24.01-23.
	// Example: 2.40100023e+08
	Version() *int
	// The running version of instance in format TAGCNUM. TAG is a five-digit number that contains the year number, month number, and version number. CNUM is a four-digit number that indicates the commit number. Number 240100023 represents version 24.01-23.
	// Example: 2.40100023e+08
	SetVersion(int) ClusterHealthStats
}

// Cluster total bitrate metrics
type ClusterHealthStatsStreamerBitrateMetricsTotal interface {
	// Current incoming speed (bitrate) of the data transmission over the network of all streamers.
	// Format: speed (speed)
	InputKbit() *Speed
	// Current incoming speed (bitrate) of the data transmission over the network of all streamers.
	// Format: speed (speed)
	SetInputKbit(Speed) ClusterHealthStatsStreamerBitrateMetricsTotal
	// Current outgoing speed (bitrate) of the data transmission over the network of all streamers.
	// Format: speed (speed)
	OutputKbit() *Speed
	// Current outgoing speed (bitrate) of the data transmission over the network of all streamers.
	// Format: speed (speed)
	SetOutputKbit(Speed) ClusterHealthStatsStreamerBitrateMetricsTotal
}

// Streamer stats
// Required: hostname
type ClusterHealthStreamerStats interface {
	// Streamer agents info.
	AgentMetrics() ClusterHealthStreamerStatsAgentMetrics
	// Streamer agents info.
	SetAgentMetrics(ClusterHealthStreamerStatsAgentMetrics) ClusterHealthStreamerStats
	// Streamer config info.
	Config() ClusterHealthStreamerStatsConfig
	// Streamer config info.
	SetConfig(ClusterHealthStreamerStatsConfig) ClusterHealthStreamerStats
	// CPU usage info.
	Cpu() ClusterHealthStreamerStatsCpu
	// CPU usage info.
	SetCpu(ClusterHealthStreamerStatsCpu) ClusterHealthStreamerStats
	// Hostname of streamer.
	// Format: server_name (server_name)
	Hostname() ServerName
	// Hostname of streamer.
	// Format: server_name (server_name)
	SetHostname(ServerName) ClusterHealthStreamerStats
	// Memory usage info.
	Memory() ClusterHealthStreamerStatsMemory
	// Memory usage info.
	SetMemory(ClusterHealthStreamerStatsMemory) ClusterHealthStreamerStats
	// Network IO info.
	Network() ClusterHealthStreamerStatsNetwork
	// Network IO info.
	SetNetwork(ClusterHealthStreamerStatsNetwork) ClusterHealthStreamerStats
	Status() *ClusterHealthStatus
	SetStatus(ClusterHealthStatus) ClusterHealthStreamerStats
	// Total disk usage info.
	Storage() ClusterHealthStreamerStatsStorage
	// Total disk usage info.
	SetStorage(ClusterHealthStreamerStatsStorage) ClusterHealthStreamerStats
	// Streamer streams info.
	StreamMetrics() ClusterHealthStreamerStatsStreamMetrics
	// Streamer streams info.
	SetStreamMetrics(ClusterHealthStreamerStatsStreamMetrics) ClusterHealthStreamerStats
	// The server uptime.
	// Format: seconds (seconds)
	// Example: 4.325502e+06
	Uptime() *Seconds
	// The server uptime.
	// Format: seconds (seconds)
	// Example: 4.325502e+06
	SetUptime(Seconds) ClusterHealthStreamerStats
}

// Streamer agents info.
type ClusterHealthStreamerStatsAgentMetrics interface {
	// Number of degraded entities
	Degradated() *int
	// Number of degraded entities
	SetDegradated(int) ClusterHealthStreamerStatsAgentMetrics
	// Number of disabled entities
	Disabled() *int
	// Number of disabled entities
	SetDisabled(int) ClusterHealthStreamerStatsAgentMetrics
	// Number of operational entities
	Operational() *int
	// Number of operational entities
	SetOperational(int) ClusterHealthStreamerStatsAgentMetrics
	// Number of outage entities
	Outage() *int
	// Number of outage entities
	SetOutage(int) ClusterHealthStreamerStatsAgentMetrics
	// Number of partial outage entities
	PartialOutage() *int
	// Number of partial outage entities
	SetPartialOutage(int) ClusterHealthStreamerStatsAgentMetrics
	Status() *ClusterHealthStatus
	SetStatus(ClusterHealthStatus) ClusterHealthStreamerStatsAgentMetrics
	// Total number of entities
	Total() *int
	// Total number of entities
	SetTotal(int) ClusterHealthStreamerStatsAgentMetrics
}

// Streamer config info.
type ClusterHealthStreamerStatsConfig interface {
	Status() *ClusterHealthStatus
	SetStatus(ClusterHealthStatus) ClusterHealthStreamerStatsConfig
}

// CPU usage info.
type ClusterHealthStreamerStatsCpu interface {
	Status() *ClusterHealthStatus
	SetStatus(ClusterHealthStatus) ClusterHealthStreamerStatsCpu
	// CPU usage on the server.
	// Format: percent (percent)
	// Example: 48
	Usage() *Percent
	// CPU usage on the server.
	// Format: percent (percent)
	// Example: 48
	SetUsage(Percent) ClusterHealthStreamerStatsCpu
}

// Memory usage info.
type ClusterHealthStreamerStatsMemory interface {
	Status() *ClusterHealthStatus
	SetStatus(ClusterHealthStatus) ClusterHealthStreamerStatsMemory
	// Memory usage on the server.
	// Format: percent (percent)
	// Example: 27
	Usage() *Percent
	// Memory usage on the server.
	// Format: percent (percent)
	// Example: 27
	SetUsage(Percent) ClusterHealthStreamerStatsMemory
}

// Network IO info.
type ClusterHealthStreamerStatsNetwork interface {
	// Inbound network info on the server.
	InKbit() ClusterHealthStreamerStatsNetworkInKbit
	// Inbound network info on the server.
	SetInKbit(ClusterHealthStreamerStatsNetworkInKbit) ClusterHealthStreamerStatsNetwork
	// Outbound network info on the server.
	OutKbit() ClusterHealthStreamerStatsNetworkOutKbit
	// Outbound network info on the server.
	SetOutKbit(ClusterHealthStreamerStatsNetworkOutKbit) ClusterHealthStreamerStatsNetwork
}

// Inbound network info on the server.
type ClusterHealthStreamerStatsNetworkInKbit interface {
	Status() *ClusterHealthStatus
	SetStatus(ClusterHealthStatus) ClusterHealthStreamerStatsNetworkInKbit
	// Inbound network usage on the server.
	// Format: speed (speed)
	Usage() *Speed
	// Inbound network usage on the server.
	// Format: speed (speed)
	SetUsage(Speed) ClusterHealthStreamerStatsNetworkInKbit
}

// Outbound network info on the server.
type ClusterHealthStreamerStatsNetworkOutKbit interface {
	Status() *ClusterHealthStatus
	SetStatus(ClusterHealthStatus) ClusterHealthStreamerStatsNetworkOutKbit
	// Outbound network usage on the server.
	// Format: speed (speed)
	Usage() *Speed
	// Outbound network usage on the server.
	// Format: speed (speed)
	SetUsage(Speed) ClusterHealthStreamerStatsNetworkOutKbit
}

// Total disk usage info.
type ClusterHealthStreamerStatsStorage interface {
	Status() *ClusterHealthStatus
	SetStatus(ClusterHealthStatus) ClusterHealthStreamerStatsStorage
	// Total disk space usage on the server.
	// Format: percent (percent)
	// Example: 18
	Usage() *Percent
	// Total disk space usage on the server.
	// Format: percent (percent)
	// Example: 18
	SetUsage(Percent) ClusterHealthStreamerStatsStorage
}

// Streamer streams info.
type ClusterHealthStreamerStatsStreamMetrics interface {
	// Number of degraded entities
	Degradated() *int
	// Number of degraded entities
	SetDegradated(int) ClusterHealthStreamerStatsStreamMetrics
	// Number of disabled entities
	Disabled() *int
	// Number of disabled entities
	SetDisabled(int) ClusterHealthStreamerStatsStreamMetrics
	// Number of operational entities
	Operational() *int
	// Number of operational entities
	SetOperational(int) ClusterHealthStreamerStatsStreamMetrics
	// Number of outage entities
	Outage() *int
	// Number of outage entities
	SetOutage(int) ClusterHealthStreamerStatsStreamMetrics
	// Number of partial outage entities
	PartialOutage() *int
	// Number of partial outage entities
	SetPartialOutage(int) ClusterHealthStreamerStatsStreamMetrics
	Status() *ClusterHealthStatus
	SetStatus(ClusterHealthStatus) ClusterHealthStreamerStatsStreamMetrics
	// Total number of entities
	Total() *int
	// Total number of entities
	SetTotal(int) ClusterHealthStreamerStatsStreamMetrics
}

type CollectionResponse interface {
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	EstimatedCount() *int
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	SetEstimatedCount(int) CollectionResponse
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	Next() *string
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	SetNext(string) CollectionResponse
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	Prev() *string
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	SetPrev(string) CollectionResponse
	// An object with a list of different timings measured during this API call.
	Timing() any
	// An object with a list of different timings measured during this API call.
	SetTiming(any) CollectionResponse
}

type ConfigErrorStatus interface {
	// The column number pointing to where the error was detected.
	// Example: 20
	Col() *int
	// The column number pointing to where the error was detected.
	// Example: 20
	SetCol(int) ConfigErrorStatus
	// Partial configuration that can be recovered if an error occurs.
	Config() any
	// Partial configuration that can be recovered if an error occurs.
	SetConfig(any) ConfigErrorStatus
	// Some other details that may help to identify the error.
	Detail() any
	// Some other details that may help to identify the error.
	SetDetail(any) ConfigErrorStatus
	// Short error description.
	// Example: bad_url
	Error() *string
	// Short error description.
	// Example: bad_url
	SetError(string) ConfigErrorStatus
	// Last column with something valid.
	// Example: 5
	FirstErrorCol() *int
	// Last column with something valid.
	// Example: 5
	SetFirstErrorCol(int) ConfigErrorStatus
	// If an error takes up to several lines, it is the first line where the error was detected.
	// Example: 14
	FirstErrorLine() *int
	// If an error takes up to several lines, it is the first line where the error was detected.
	// Example: 14
	SetFirstErrorLine(int) ConfigErrorStatus
	// Line number pointing to where an error was detected.
	// Example: 15
	Line() *int
	// Line number pointing to where an error was detected.
	// Example: 15
	SetLine(int) ConfigErrorStatus
	// Config path to the erroneous element.
	// Example: [streams 0 inputs 0 url input_url]
	Path() []ConfigPathSegment
	// Config path to the erroneous element.
	// Example: [streams 0 inputs 0 url input_url]
	SetPath([]ConfigPathSegment) ConfigErrorStatus
}

type ConfigExternalErrorStatus interface {
	// HTTP response code
	Code() *int
	// HTTP response code
	SetCode(int) ConfigExternalErrorStatus
	// Detailed error description (optional)
	Detail() *string
	// Detailed error description (optional)
	SetDetail(string) ConfigExternalErrorStatus
	// Error description (optional)
	// Example: invalid_authorization
	Error() *string
	// Error description (optional)
	// Example: invalid_authorization
	SetError(string) ConfigExternalErrorStatus
	// Config path to the erroneous element.
	// Example: [streams 0 inputs 0 url input_url]
	Path() []ConfigPathSegment
	// Config path to the erroneous element.
	// Example: [streams 0 inputs 0 url input_url]
	SetPath([]ConfigPathSegment) ConfigExternalErrorStatus
	Reason() *RequestErrorReason
	SetReason(RequestErrorReason) ConfigExternalErrorStatus
	// External config status
	Status() *ConfigExternalErrorStatusStatus
	// External config status
	SetStatus(ConfigExternalErrorStatusStatus) ConfigExternalErrorStatus
	// Conditions of the error occurrence.
	While() *ConfigExternalErrorStatusWhile
	// Conditions of the error occurrence.
	SetWhile(ConfigExternalErrorStatusWhile) ConfigExternalErrorStatus
}

type DatabaseError interface {
	// Database error.
	Event() string
	// Database error.
	SetEvent(string) DatabaseError
	// Event identifier.
	EventID() *int
	// Event identifier.
	SetEventID(int) DatabaseError
	// The error message.
	Message() *string
	// The error message.
	SetMessage(string) DatabaseError
	// The query that caused the error.
	Query() *string
	// The query that caused the error.
	SetQuery(string) DatabaseError
	// Originator of event.
	// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
	// is configured as HTTP/HTTPS url.
	// Example: flussonic.host
	Server() *string
	// Originator of event.
	// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
	// is configured as HTTP/HTTPS url.
	// Example: flussonic.host
	SetServer(string) DatabaseError
	// Unique identifier of the operation.
	// You can use this field to search for events related to same operation.
	// Value of this field is taken from the `X-Trace-Id` header.
	// If `X-Trace-Id` header is not set, it will be generated automatically.
	// Service will use the value of this field to make outgoing requests.
	// Format: uuid (uuid)
	// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
	TraceID() *UUID
	// Unique identifier of the operation.
	// You can use this field to search for events related to same operation.
	// Value of this field is taken from the `X-Trace-Id` header.
	// If `X-Trace-Id` header is not set, it will be generated automatically.
	// Service will use the value of this field to make outgoing requests.
	// Format: uuid (uuid)
	// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
	SetTraceID(UUID) DatabaseError
	// The time of the event registration on the server.
	// Format: utc_ms (Unix timestamp in milliseconds)
	UtcMs() *UtcMs
	// The time of the event registration on the server.
	// Format: utc_ms (Unix timestamp in milliseconds)
	SetUtcMs(UtcMs) DatabaseError
}

type DrmBase interface {
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	Encryption() *string
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	SetEncryption(string) DrmBase
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	Expires() *int
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	SetExpires(int) DrmBase
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	Keyserver() *string
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	SetKeyserver(string) DrmBase
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	ResourceID() *DrmResourceID
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	SetResourceID(DrmResourceID) DrmBase
}

type DrmCpixBase interface {
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	Encryption() *string
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	SetEncryption(string) DrmCpixBase
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	Expires() *int
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	SetExpires(int) DrmCpixBase
	// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
	// It is employed only one time in any session.
	// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
	// Usually, IV is received from a DRM provider.
	Iv() *string
	// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
	// It is employed only one time in any session.
	// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
	// Usually, IV is received from a DRM provider.
	SetIv(string) DrmCpixBase
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	Keyserver() *string
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	SetKeyserver(string) DrmCpixBase
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	ResourceID() *DrmResourceID
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	SetResourceID(DrmResourceID) DrmCpixBase
	// This parameter is used to specify applicable DRM systems.
	// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
	Systems() []DrmSystem
	// This parameter is used to specify applicable DRM systems.
	// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
	SetSystems([]DrmSystem) DrmCpixBase
}

type DrmEncKey interface {
	// Encryption Key in hex or file. Length must be 128 bit.
	// Example: 0x76359e1212952a6db42b41eeb94ceb29
	Key() *string
	// Encryption Key in hex or file. Length must be 128 bit.
	// Example: 0x76359e1212952a6db42b41eeb94ceb29
	SetKey(string) DrmEncKey
}

type DrmEncKeyURL interface {
	// Http link which specifies how to obtain the key. It is URI attribute of HLS manifest EXT-X-KEY method.
	URL() *string
	// Http link which specifies how to obtain the key. It is URI attribute of HLS manifest EXT-X-KEY method.
	SetURL(string) DrmEncKeyURL
}

type DrmIv interface {
	// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
	// It is employed only one time in any session.
	// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
	// Usually, IV is received from a DRM provider.
	Iv() *string
	// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
	// It is employed only one time in any session.
	// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
	// Usually, IV is received from a DRM provider.
	SetIv(string) DrmIv
}

type DrmKeyosBase interface {
	// A unique identifier of the content, used for Widevine DRM.
	// By default, it is equal to the stream name.
	ContentID() *string
	// A unique identifier of the content, used for Widevine DRM.
	// By default, it is equal to the stream name.
	SetContentID(string) DrmKeyosBase
	// Path to end user certificate file.
	EndUserCert() *string
	// Path to end user certificate file.
	SetEndUserCert(string) DrmKeyosBase
	// Path to end user private key file
	EndUserPrivateKey() *string
	// Path to end user private key file
	SetEndUserPrivateKey(string) DrmKeyosBase
	// Deprecated field. Will be deleted at 25.04
	// A unique identifier of the user
	Userkey() *string
	// Deprecated field. Will be deleted at 25.04
	// A unique identifier of the user
	SetUserkey(string) DrmKeyosBase
}

type DrmSpec interface {
	// ID of the Irdeto DRM account.
	AccountID() *string
	// ID of the Irdeto DRM account.
	SetAccountID(string) DrmSpec
	// AES (Advanced Encryption Standard) key. Used for Widevine DRM.
	AesKey() *string
	// AES (Advanced Encryption Standard) key. Used for Widevine DRM.
	SetAesKey(string) DrmSpec
	// Authentication server for DRMtoday.
	// Example: https://auth.drmtoday.com
	AuthServer() *string
	// Authentication server for DRMtoday.
	// Example: https://auth.drmtoday.com
	SetAuthServer(string) DrmSpec
	// A unique identifier of the content, used for Widevine DRM.
	// By default, it is equal to the stream name.
	ContentID() *string
	// A unique identifier of the content, used for Widevine DRM.
	// By default, it is equal to the stream name.
	SetContentID(string) DrmSpec
	// The uuid of the CPIX/SPEKE ingest configuration
	CpixConfigID() *string
	// The uuid of the CPIX/SPEKE ingest configuration
	SetCpixConfigID(string) DrmSpec
	// An API authentication token that is generated when you sign up for the PallyCon service at https://login.pallycon.com/.
	EncToken() *string
	// An API authentication token that is generated when you sign up for the PallyCon service at https://login.pallycon.com/.
	SetEncToken(string) DrmSpec
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	Encryption() *string
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	SetEncryption(string) DrmSpec
	// Path to end user certificate file.
	EndUserCert() *string
	// Path to end user certificate file.
	SetEndUserCert(string) DrmSpec
	// Path to end user private key file
	EndUserPrivateKey() *string
	// Path to end user private key file
	SetEndUserPrivateKey(string) DrmSpec
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	Expires() *int
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	SetExpires(int) DrmSpec
	// Whether to use FairPlay system for key generation.
	// If set to `false`, the requests for FairPlay encryption key are disabled.
	Fp() *string
	// Whether to use FairPlay system for key generation.
	// If set to `false`, the requests for FairPlay encryption key are disabled.
	SetFp(string) DrmSpec
	// This parameter is used for encryption of HLS streams.
	// For successful playback of an AES128 encrypted HLS streams on some modern devices (running on Tizen 5),
	// set this pareameter to `false`.
	HlsExtXKeyIv() *bool
	// This parameter is used for encryption of HLS streams.
	// For successful playback of an AES128 encrypted HLS streams on some modern devices (running on Tizen 5),
	// set this pareameter to `false`.
	SetHlsExtXKeyIv(bool) DrmSpec
	// A hostname of Irdeto DRM key server.
	IcHost() *string
	// A hostname of Irdeto DRM key server.
	SetIcHost(string) DrmSpec
	// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
	// It is employed only one time in any session.
	// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
	// Usually, IV is received from a DRM provider.
	Iv() *string
	// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
	// It is employed only one time in any session.
	// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
	// Usually, IV is received from a DRM provider.
	SetIv(string) DrmSpec
	// Encryption Key in hex or file. Length must be 128 bit.
	// Example: 0x76359e1212952a6db42b41eeb94ceb29
	Key() *string
	// Encryption Key in hex or file. Length must be 128 bit.
	// Example: 0x76359e1212952a6db42b41eeb94ceb29
	SetKey(string) DrmSpec
	// An arbitrary Base64-encoded string of 30 bytes.
	// It is necessary for PlayReady to create an encryption key.
	Keyseed() *string
	// An arbitrary Base64-encoded string of 30 bytes.
	// It is necessary for PlayReady to create an encryption key.
	SetKeyseed(string) DrmSpec
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	Keyserver() *string
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	SetKeyserver(string) DrmSpec
	// License URL, used for PlayReady DRM.
	// Format: url (url)
	LaURL() *URL
	// License URL, used for PlayReady DRM.
	// Format: url (url)
	SetLaURL(URL) DrmSpec
	// Axinom Management Key
	ManagementKey() *string
	// Axinom Management Key
	SetManagementKey(string) DrmSpec
	// The uuid of the merchant at DRMtoday.
	MerchantID() *string
	// The uuid of the merchant at DRMtoday.
	SetMerchantID(string) DrmSpec
	// A password for API account./A password for authorization of a user on a key server.
	Password() *string
	// A password for API account./A password for authorization of a user on a key server.
	SetPassword(string) DrmSpec
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	ResourceID() *DrmResourceID
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	SetResourceID(DrmResourceID) DrmSpec
	// A part of the keyserver's URL: `https://SITE.solocoo.tv/SITEadmintools/papi/SECRET/method`.
	Secret() *string
	// A part of the keyserver's URL: `https://SITE.solocoo.tv/SITEadmintools/papi/SECRET/method`.
	SetSecret(string) DrmSpec
	// A unique ID of the signer.
	// Flussonic uses it to connect to the key server when using test key for Widevine DRM.
	Signer() *string
	// A unique ID of the signer.
	// Flussonic uses it to connect to the key server when using test key for Widevine DRM.
	SetSigner(string) DrmSpec
	// A part of the keyserver's URL: `https://SITE.solocoo.tv/SITEadmintools/papi/SECRET/method`.
	Site() *string
	// A part of the keyserver's URL: `https://SITE.solocoo.tv/SITEadmintools/papi/SECRET/method`.
	SetSite(string) DrmSpec
	// This parameter is used to specify applicable DRM systems.
	// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
	Systems() []DrmSystem
	// This parameter is used to specify applicable DRM systems.
	// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
	SetSystems([]DrmSystem) DrmSpec
	// Axinom Tenant Id
	TenantID() *string
	// Axinom Tenant Id
	SetTenantID(string) DrmSpec
	// Http link which specifies how to obtain the key. It is URI attribute of HLS manifest EXT-X-KEY method.
	URL() *string
	// Http link which specifies how to obtain the key. It is URI attribute of HLS manifest EXT-X-KEY method.
	SetURL(string) DrmSpec
	// A user name for authorization of a user on a key server.
	User() *string
	// A user name for authorization of a user on a key server.
	SetUser(string) DrmSpec
	// The URL sent to the client for watching the content.
	// Example: https://public-keyserver.mycompany.com
	UserKeyserver() *string
	// The URL sent to the client for watching the content.
	// Example: https://public-keyserver.mycompany.com
	SetUserKeyserver(string) DrmSpec
	// A user name of the Irdeto DRM user.
	UserName() *string
	// A user name of the Irdeto DRM user.
	SetUserName(string) DrmSpec
	// A custom key server path
	// Example: 12345/nks/conax
	UserPath() *string
	// A custom key server path
	// Example: 12345/nks/conax
	SetUserPath(string) DrmSpec
	// Deprecated field. Will be deleted at 25.04
	// A unique identifier of the user
	Userkey() *string
	// Deprecated field. Will be deleted at 25.04
	// A unique identifier of the user
	SetUserkey(string) DrmSpec
	// The login name of an API account.
	Username() *string
	// The login name of an API account.
	SetUsername(string) DrmSpec
	// FIXME: Aes128
	// /FIXME: Axinom
	// /BuyDRM
	// /Clear Key is a lightweight DRM mode, where decryption keys are provided directly to the player. Its easy to
	// integrate (simple JSON key/KID), requires minimal infrastructure, and can work via a license URL or with
	// client-embedded keys.
	// /FIXME: Conax
	// /FIXME: Cpix
	// /FIXME: DRMtoday
	// /FIXME: Ezdrm
	// /FIXME: Ezdrm classic
	// /FIXME: GS DRM
	// /FIXME: Irdeto
	// /KeyOs
	// /FIXME: Pallycon
	// /FIXME: Playready
	// /FIXME: Sample AES
	// /Sample AES which uses KEYFORMAT=identity. It allows to encrypt and decrypt content using clear text AES key.
	// The identity value for KEYFORMAT should be used only for testing.
	// /FIXME: Solocoo
	// /FIXME: Verimatrix
	// /FIXME: Widevine
	Vendor() string
	// FIXME: Aes128
	// /FIXME: Axinom
	// /BuyDRM
	// /Clear Key is a lightweight DRM mode, where decryption keys are provided directly to the player. Its easy to
	// integrate (simple JSON key/KID), requires minimal infrastructure, and can work via a license URL or with
	// client-embedded keys.
	// /FIXME: Conax
	// /FIXME: Cpix
	// /FIXME: DRMtoday
	// /FIXME: Ezdrm
	// /FIXME: Ezdrm classic
	// /FIXME: GS DRM
	// /FIXME: Irdeto
	// /KeyOs
	// /FIXME: Pallycon
	// /FIXME: Playready
	// /FIXME: Sample AES
	// /Sample AES which uses KEYFORMAT=identity. It allows to encrypt and decrypt content using clear text AES key.
	// The identity value for KEYFORMAT should be used only for testing.
	// /FIXME: Solocoo
	// /FIXME: Verimatrix
	// /FIXME: Widevine
	SetVendor(string) DrmSpec
}

type DrmSystems interface {
	// This parameter is used to specify applicable DRM systems.
	// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
	Systems() []DrmSystem
	// This parameter is used to specify applicable DRM systems.
	// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
	SetSystems([]DrmSystem) DrmSystems
}

type DrmVendorAes128 interface {
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	Encryption() *string
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	SetEncryption(string) DrmVendorAes128
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	Expires() *int
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	SetExpires(int) DrmVendorAes128
	// This parameter is used for encryption of HLS streams.
	// For successful playback of an AES128 encrypted HLS streams on some modern devices (running on Tizen 5),
	// set this pareameter to `false`.
	HlsExtXKeyIv() *bool
	// This parameter is used for encryption of HLS streams.
	// For successful playback of an AES128 encrypted HLS streams on some modern devices (running on Tizen 5),
	// set this pareameter to `false`.
	SetHlsExtXKeyIv(bool) DrmVendorAes128
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	Keyserver() *string
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	SetKeyserver(string) DrmVendorAes128
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	ResourceID() *DrmResourceID
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	SetResourceID(DrmResourceID) DrmVendorAes128
	// FIXME: Aes128
	Vendor() string
	// FIXME: Aes128
	SetVendor(string) DrmVendorAes128
}

type DrmVendorAxinom interface {
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	Encryption() *string
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	SetEncryption(string) DrmVendorAxinom
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	Expires() *int
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	SetExpires(int) DrmVendorAxinom
	// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
	// It is employed only one time in any session.
	// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
	// Usually, IV is received from a DRM provider.
	Iv() *string
	// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
	// It is employed only one time in any session.
	// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
	// Usually, IV is received from a DRM provider.
	SetIv(string) DrmVendorAxinom
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	Keyserver() *string
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	SetKeyserver(string) DrmVendorAxinom
	// Axinom Management Key
	ManagementKey() *string
	// Axinom Management Key
	SetManagementKey(string) DrmVendorAxinom
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	ResourceID() *DrmResourceID
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	SetResourceID(DrmResourceID) DrmVendorAxinom
	// This parameter is used to specify applicable DRM systems.
	// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
	Systems() []DrmSystem
	// This parameter is used to specify applicable DRM systems.
	// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
	SetSystems([]DrmSystem) DrmVendorAxinom
	// Axinom Tenant Id
	TenantID() *string
	// Axinom Tenant Id
	SetTenantID(string) DrmVendorAxinom
	// FIXME: Axinom
	Vendor() string
	// FIXME: Axinom
	SetVendor(string) DrmVendorAxinom
}

type DrmVendorBuydrm interface {
	// A unique identifier of the content, used for Widevine DRM.
	// By default, it is equal to the stream name.
	ContentID() *string
	// A unique identifier of the content, used for Widevine DRM.
	// By default, it is equal to the stream name.
	SetContentID(string) DrmVendorBuydrm
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	Encryption() *string
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	SetEncryption(string) DrmVendorBuydrm
	// Path to end user certificate file.
	EndUserCert() *string
	// Path to end user certificate file.
	SetEndUserCert(string) DrmVendorBuydrm
	// Path to end user private key file
	EndUserPrivateKey() *string
	// Path to end user private key file
	SetEndUserPrivateKey(string) DrmVendorBuydrm
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	Expires() *int
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	SetExpires(int) DrmVendorBuydrm
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	Keyserver() *string
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	SetKeyserver(string) DrmVendorBuydrm
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	ResourceID() *DrmResourceID
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	SetResourceID(DrmResourceID) DrmVendorBuydrm
	// Deprecated field. Will be deleted at 25.04
	// A unique identifier of the user
	Userkey() *string
	// Deprecated field. Will be deleted at 25.04
	// A unique identifier of the user
	SetUserkey(string) DrmVendorBuydrm
	// BuyDRM
	Vendor() string
	// BuyDRM
	SetVendor(string) DrmVendorBuydrm
}

type DrmVendorClearkey interface {
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	Encryption() *string
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	SetEncryption(string) DrmVendorClearkey
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	Expires() *int
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	SetExpires(int) DrmVendorClearkey
	// Encryption Key in hex or file. Length must be 128 bit.
	// Example: 0x76359e1212952a6db42b41eeb94ceb29
	Key() *string
	// Encryption Key in hex or file. Length must be 128 bit.
	// Example: 0x76359e1212952a6db42b41eeb94ceb29
	SetKey(string) DrmVendorClearkey
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	Keyserver() *string
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	SetKeyserver(string) DrmVendorClearkey
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	ResourceID() *DrmResourceID
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	SetResourceID(DrmResourceID) DrmVendorClearkey
	// Clear Key is a lightweight DRM mode, where decryption keys are provided directly to the player. Its easy to
	// integrate (simple JSON key/KID), requires minimal infrastructure, and can work via a license URL or with
	// client-embedded keys.
	Vendor() string
	// Clear Key is a lightweight DRM mode, where decryption keys are provided directly to the player. Its easy to
	// integrate (simple JSON key/KID), requires minimal infrastructure, and can work via a license URL or with
	// client-embedded keys.
	SetVendor(string) DrmVendorClearkey
}

type DrmVendorConax interface {
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	Encryption() *string
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	SetEncryption(string) DrmVendorConax
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	Expires() *int
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	SetExpires(int) DrmVendorConax
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	Keyserver() *string
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	SetKeyserver(string) DrmVendorConax
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	ResourceID() *DrmResourceID
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	SetResourceID(DrmResourceID) DrmVendorConax
	// This parameter is used to specify applicable DRM systems.
	// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
	Systems() []DrmSystem
	// This parameter is used to specify applicable DRM systems.
	// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
	SetSystems([]DrmSystem) DrmVendorConax
	// A custom key server path
	// Example: 12345/nks/conax
	UserPath() *string
	// A custom key server path
	// Example: 12345/nks/conax
	SetUserPath(string) DrmVendorConax
	// FIXME: Conax
	Vendor() string
	// FIXME: Conax
	SetVendor(string) DrmVendorConax
}

type DrmVendorCpix interface {
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	Encryption() *string
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	SetEncryption(string) DrmVendorCpix
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	Expires() *int
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	SetExpires(int) DrmVendorCpix
	// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
	// It is employed only one time in any session.
	// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
	// Usually, IV is received from a DRM provider.
	Iv() *string
	// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
	// It is employed only one time in any session.
	// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
	// Usually, IV is received from a DRM provider.
	SetIv(string) DrmVendorCpix
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	Keyserver() *string
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	SetKeyserver(string) DrmVendorCpix
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	ResourceID() *DrmResourceID
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	SetResourceID(DrmResourceID) DrmVendorCpix
	// This parameter is used to specify applicable DRM systems.
	// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
	Systems() []DrmSystem
	// This parameter is used to specify applicable DRM systems.
	// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
	SetSystems([]DrmSystem) DrmVendorCpix
	// FIXME: Cpix
	Vendor() string
	// FIXME: Cpix
	SetVendor(string) DrmVendorCpix
}

type DrmVendorDrmtoday interface {
	// Authentication server for DRMtoday.
	// Example: https://auth.drmtoday.com
	AuthServer() *string
	// Authentication server for DRMtoday.
	// Example: https://auth.drmtoday.com
	SetAuthServer(string) DrmVendorDrmtoday
	// The uuid of the CPIX/SPEKE ingest configuration
	CpixConfigID() *string
	// The uuid of the CPIX/SPEKE ingest configuration
	SetCpixConfigID(string) DrmVendorDrmtoday
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	Encryption() *string
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	SetEncryption(string) DrmVendorDrmtoday
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	Expires() *int
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	SetExpires(int) DrmVendorDrmtoday
	// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
	// It is employed only one time in any session.
	// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
	// Usually, IV is received from a DRM provider.
	Iv() *string
	// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
	// It is employed only one time in any session.
	// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
	// Usually, IV is received from a DRM provider.
	SetIv(string) DrmVendorDrmtoday
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	Keyserver() *string
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	SetKeyserver(string) DrmVendorDrmtoday
	// The uuid of the merchant at DRMtoday.
	MerchantID() *string
	// The uuid of the merchant at DRMtoday.
	SetMerchantID(string) DrmVendorDrmtoday
	// A password for API account.
	Password() *string
	// A password for API account.
	SetPassword(string) DrmVendorDrmtoday
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	ResourceID() *DrmResourceID
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	SetResourceID(DrmResourceID) DrmVendorDrmtoday
	// This parameter is used to specify applicable DRM systems.
	// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
	Systems() []DrmSystem
	// This parameter is used to specify applicable DRM systems.
	// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
	SetSystems([]DrmSystem) DrmVendorDrmtoday
	// The login name of an API account.
	Username() *string
	// The login name of an API account.
	SetUsername(string) DrmVendorDrmtoday
	// FIXME: DRMtoday
	Vendor() string
	// FIXME: DRMtoday
	SetVendor(string) DrmVendorDrmtoday
}

type DrmVendorEzdrm interface {
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	Encryption() *string
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	SetEncryption(string) DrmVendorEzdrm
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	Expires() *int
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	SetExpires(int) DrmVendorEzdrm
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	Keyserver() *string
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	SetKeyserver(string) DrmVendorEzdrm
	// A password for authorization of a user on a key server.
	Password() *string
	// A password for authorization of a user on a key server.
	SetPassword(string) DrmVendorEzdrm
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	ResourceID() *DrmResourceID
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	SetResourceID(DrmResourceID) DrmVendorEzdrm
	// A user name for authorization of a user on a key server.
	User() *string
	// A user name for authorization of a user on a key server.
	SetUser(string) DrmVendorEzdrm
	// FIXME: Ezdrm
	Vendor() string
	// FIXME: Ezdrm
	SetVendor(string) DrmVendorEzdrm
}

type DrmVendorEzdrmClassic interface {
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	Encryption() *string
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	SetEncryption(string) DrmVendorEzdrmClassic
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	Expires() *int
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	SetExpires(int) DrmVendorEzdrmClassic
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	Keyserver() *string
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	SetKeyserver(string) DrmVendorEzdrmClassic
	// A password for authorization of a user on a key server.
	Password() *string
	// A password for authorization of a user on a key server.
	SetPassword(string) DrmVendorEzdrmClassic
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	ResourceID() *DrmResourceID
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	SetResourceID(DrmResourceID) DrmVendorEzdrmClassic
	// A user name for authorization of a user on a key server.
	User() *string
	// A user name for authorization of a user on a key server.
	SetUser(string) DrmVendorEzdrmClassic
	// FIXME: Ezdrm classic
	Vendor() string
	// FIXME: Ezdrm classic
	SetVendor(string) DrmVendorEzdrmClassic
}

type DrmVendorGsdrm interface {
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	Encryption() *string
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	SetEncryption(string) DrmVendorGsdrm
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	Expires() *int
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	SetExpires(int) DrmVendorGsdrm
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	Keyserver() *string
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	SetKeyserver(string) DrmVendorGsdrm
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	ResourceID() *DrmResourceID
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	SetResourceID(DrmResourceID) DrmVendorGsdrm
	// FIXME: GS DRM
	Vendor() string
	// FIXME: GS DRM
	SetVendor(string) DrmVendorGsdrm
}

type DrmVendorIrdeto interface {
	// ID of the Irdeto DRM account.
	AccountID() *string
	// ID of the Irdeto DRM account.
	SetAccountID(string) DrmVendorIrdeto
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	Encryption() *string
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	SetEncryption(string) DrmVendorIrdeto
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	Expires() *int
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	SetExpires(int) DrmVendorIrdeto
	// A hostname of Irdeto DRM key server.
	IcHost() *string
	// A hostname of Irdeto DRM key server.
	SetIcHost(string) DrmVendorIrdeto
	// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
	// It is employed only one time in any session.
	// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
	// Usually, IV is received from a DRM provider.
	Iv() *string
	// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
	// It is employed only one time in any session.
	// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
	// Usually, IV is received from a DRM provider.
	SetIv(string) DrmVendorIrdeto
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	Keyserver() *string
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	SetKeyserver(string) DrmVendorIrdeto
	// A password for authorization of a user on a key server.
	Password() *string
	// A password for authorization of a user on a key server.
	SetPassword(string) DrmVendorIrdeto
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	ResourceID() *DrmResourceID
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	SetResourceID(DrmResourceID) DrmVendorIrdeto
	// This parameter is used to specify applicable DRM systems.
	// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
	Systems() []DrmSystem
	// This parameter is used to specify applicable DRM systems.
	// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
	SetSystems([]DrmSystem) DrmVendorIrdeto
	// A user name of the Irdeto DRM user.
	UserName() *string
	// A user name of the Irdeto DRM user.
	SetUserName(string) DrmVendorIrdeto
	// FIXME: Irdeto
	Vendor() string
	// FIXME: Irdeto
	SetVendor(string) DrmVendorIrdeto
}

type DrmVendorKeyos interface {
	// A unique identifier of the content, used for Widevine DRM.
	// By default, it is equal to the stream name.
	ContentID() *string
	// A unique identifier of the content, used for Widevine DRM.
	// By default, it is equal to the stream name.
	SetContentID(string) DrmVendorKeyos
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	Encryption() *string
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	SetEncryption(string) DrmVendorKeyos
	// Path to end user certificate file.
	EndUserCert() *string
	// Path to end user certificate file.
	SetEndUserCert(string) DrmVendorKeyos
	// Path to end user private key file
	EndUserPrivateKey() *string
	// Path to end user private key file
	SetEndUserPrivateKey(string) DrmVendorKeyos
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	Expires() *int
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	SetExpires(int) DrmVendorKeyos
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	Keyserver() *string
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	SetKeyserver(string) DrmVendorKeyos
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	ResourceID() *DrmResourceID
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	SetResourceID(DrmResourceID) DrmVendorKeyos
	// Deprecated field. Will be deleted at 25.04
	// A unique identifier of the user
	Userkey() *string
	// Deprecated field. Will be deleted at 25.04
	// A unique identifier of the user
	SetUserkey(string) DrmVendorKeyos
	// KeyOs
	Vendor() string
	// KeyOs
	SetVendor(string) DrmVendorKeyos
}

type DrmVendorPallycon interface {
	// An API authentication token that is generated when you sign up for the PallyCon service at https://login.pallycon.com/.
	EncToken() *string
	// An API authentication token that is generated when you sign up for the PallyCon service at https://login.pallycon.com/.
	SetEncToken(string) DrmVendorPallycon
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	Encryption() *string
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	SetEncryption(string) DrmVendorPallycon
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	Expires() *int
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	SetExpires(int) DrmVendorPallycon
	// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
	// It is employed only one time in any session.
	// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
	// Usually, IV is received from a DRM provider.
	Iv() *string
	// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
	// It is employed only one time in any session.
	// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
	// Usually, IV is received from a DRM provider.
	SetIv(string) DrmVendorPallycon
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	Keyserver() *string
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	SetKeyserver(string) DrmVendorPallycon
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	ResourceID() *DrmResourceID
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	SetResourceID(DrmResourceID) DrmVendorPallycon
	// This parameter is used to specify applicable DRM systems.
	// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
	Systems() []DrmSystem
	// This parameter is used to specify applicable DRM systems.
	// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
	SetSystems([]DrmSystem) DrmVendorPallycon
	// FIXME: Pallycon
	Vendor() string
	// FIXME: Pallycon
	SetVendor(string) DrmVendorPallycon
}

type DrmVendorPlayready interface {
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	Encryption() *string
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	SetEncryption(string) DrmVendorPlayready
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	Expires() *int
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	SetExpires(int) DrmVendorPlayready
	// An arbitrary Base64-encoded string of 30 bytes.
	// It is necessary for PlayReady to create an encryption key.
	Keyseed() *string
	// An arbitrary Base64-encoded string of 30 bytes.
	// It is necessary for PlayReady to create an encryption key.
	SetKeyseed(string) DrmVendorPlayready
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	Keyserver() *string
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	SetKeyserver(string) DrmVendorPlayready
	// License URL, used for PlayReady DRM.
	// Format: url (url)
	LaURL() *URL
	// License URL, used for PlayReady DRM.
	// Format: url (url)
	SetLaURL(URL) DrmVendorPlayready
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	ResourceID() *DrmResourceID
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	SetResourceID(DrmResourceID) DrmVendorPlayready
	// FIXME: Playready
	Vendor() string
	// FIXME: Playready
	SetVendor(string) DrmVendorPlayready
}

type DrmVendorSampleAes interface {
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	Encryption() *string
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	SetEncryption(string) DrmVendorSampleAes
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	Expires() *int
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	SetExpires(int) DrmVendorSampleAes
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	Keyserver() *string
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	SetKeyserver(string) DrmVendorSampleAes
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	ResourceID() *DrmResourceID
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	SetResourceID(DrmResourceID) DrmVendorSampleAes
	// FIXME: Sample AES
	Vendor() string
	// FIXME: Sample AES
	SetVendor(string) DrmVendorSampleAes
}

type DrmVendorSampleAesIdentity interface {
	// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
	// It is employed only one time in any session.
	// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
	// Usually, IV is received from a DRM provider.
	Iv() *string
	// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
	// It is employed only one time in any session.
	// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
	// Usually, IV is received from a DRM provider.
	SetIv(string) DrmVendorSampleAesIdentity
	// Encryption Key in hex or file. Length must be 128 bit.
	// Example: 0x76359e1212952a6db42b41eeb94ceb29
	Key() *string
	// Encryption Key in hex or file. Length must be 128 bit.
	// Example: 0x76359e1212952a6db42b41eeb94ceb29
	SetKey(string) DrmVendorSampleAesIdentity
	// Http link which specifies how to obtain the key. It is URI attribute of HLS manifest EXT-X-KEY method.
	URL() *string
	// Http link which specifies how to obtain the key. It is URI attribute of HLS manifest EXT-X-KEY method.
	SetURL(string) DrmVendorSampleAesIdentity
	// Sample AES which uses KEYFORMAT=identity. It allows to encrypt and decrypt content using clear text AES key.
	// The identity value for KEYFORMAT should be used only for testing.
	Vendor() string
	// Sample AES which uses KEYFORMAT=identity. It allows to encrypt and decrypt content using clear text AES key.
	// The identity value for KEYFORMAT should be used only for testing.
	SetVendor(string) DrmVendorSampleAesIdentity
}

type DrmVendorSolocoo interface {
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	Encryption() *string
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	SetEncryption(string) DrmVendorSolocoo
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	Expires() *int
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	SetExpires(int) DrmVendorSolocoo
	// Whether to use FairPlay system for key generation.
	// If set to `false`, the requests for FairPlay encryption key are disabled.
	Fp() *string
	// Whether to use FairPlay system for key generation.
	// If set to `false`, the requests for FairPlay encryption key are disabled.
	SetFp(string) DrmVendorSolocoo
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	Keyserver() *string
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	SetKeyserver(string) DrmVendorSolocoo
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	ResourceID() *DrmResourceID
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	SetResourceID(DrmResourceID) DrmVendorSolocoo
	// A part of the keyserver's URL: `https://SITE.solocoo.tv/SITEadmintools/papi/SECRET/method`.
	Secret() *string
	// A part of the keyserver's URL: `https://SITE.solocoo.tv/SITEadmintools/papi/SECRET/method`.
	SetSecret(string) DrmVendorSolocoo
	// A part of the keyserver's URL: `https://SITE.solocoo.tv/SITEadmintools/papi/SECRET/method`.
	Site() *string
	// A part of the keyserver's URL: `https://SITE.solocoo.tv/SITEadmintools/papi/SECRET/method`.
	SetSite(string) DrmVendorSolocoo
	// FIXME: Solocoo
	Vendor() string
	// FIXME: Solocoo
	SetVendor(string) DrmVendorSolocoo
}

type DrmVendorVerimatrix interface {
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	Encryption() *string
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	SetEncryption(string) DrmVendorVerimatrix
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	Expires() *int
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	SetExpires(int) DrmVendorVerimatrix
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	Keyserver() *string
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	SetKeyserver(string) DrmVendorVerimatrix
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	ResourceID() *DrmResourceID
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	SetResourceID(DrmResourceID) DrmVendorVerimatrix
	// The URL sent to the client for watching the content.
	// Example: https://public-keyserver.mycompany.com
	UserKeyserver() *string
	// The URL sent to the client for watching the content.
	// Example: https://public-keyserver.mycompany.com
	SetUserKeyserver(string) DrmVendorVerimatrix
	// FIXME: Verimatrix
	Vendor() string
	// FIXME: Verimatrix
	SetVendor(string) DrmVendorVerimatrix
}

type DrmVendorWidevine interface {
	// AES (Advanced Encryption Standard) key. Used for Widevine DRM.
	AesKey() *string
	// AES (Advanced Encryption Standard) key. Used for Widevine DRM.
	SetAesKey(string) DrmVendorWidevine
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	Encryption() *string
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	SetEncryption(string) DrmVendorWidevine
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	Expires() *int
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	SetExpires(int) DrmVendorWidevine
	// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
	// It is employed only one time in any session.
	// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
	// Usually, IV is received from a DRM provider.
	Iv() *string
	// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
	// It is employed only one time in any session.
	// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
	// Usually, IV is received from a DRM provider.
	SetIv(string) DrmVendorWidevine
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	Keyserver() *string
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	SetKeyserver(string) DrmVendorWidevine
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	ResourceID() *DrmResourceID
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	SetResourceID(DrmResourceID) DrmVendorWidevine
	// A unique ID of the signer.
	// Flussonic uses it to connect to the key server when using test key for Widevine DRM.
	Signer() *string
	// A unique ID of the signer.
	// Flussonic uses it to connect to the key server when using test key for Widevine DRM.
	SetSigner(string) DrmVendorWidevine
	// FIXME: Widevine
	Vendor() string
	// FIXME: Widevine
	SetVendor(string) DrmVendorWidevine
}

type DvrBaseConfig interface {
	// Maximum disk consumption in percents. When this limit is reached,
	// the oldest segment of the recording will be overridden by later data.
	// It important to understand that this is not a "per-stream" option, this option means
	// that cleaning of this stream will be triggered if overall disk usage reaches this number.
	// If you have all streams with configuration 98% and one stream with 95%, it will be permanently
	// empty.
	// Format: percent (percent)
	// Example: 98
	DiskUsageLimit() *Percent
	// Maximum disk consumption in percents. When this limit is reached,
	// the oldest segment of the recording will be overridden by later data.
	// It important to understand that this is not a "per-stream" option, this option means
	// that cleaning of this stream will be triggered if overall disk usage reaches this number.
	// If you have all streams with configuration 98% and one stream with 95%, it will be permanently
	// empty.
	// Format: percent (percent)
	// Example: 98
	SetDiskUsageLimit(Percent) DvrBaseConfig
	// Additional archive depth in seconds for episodes. If set, episodes and their corresponding DVR record
	// will be saved for `expiration + episodes_expiration` seconds.
	// The archive clean-up within `[expiration, expiration+episodes_expiration]` seconds of the
	// recording performed depending on [external_episodes_list](https://flussonic.com/doc/api/config-external/#tag/dvr/operation/external_episodes_list)
	// response of `episodes_url`.
	// Anything older than `expiration+episodes_expiration` seconds will
	// be cleaned even if `episodes_url` does not respond.
	// Format: seconds (seconds)
	// Examples: 6.048e+06
	EpisodesExpiration() *Seconds
	// Additional archive depth in seconds for episodes. If set, episodes and their corresponding DVR record
	// will be saved for `expiration + episodes_expiration` seconds.
	// The archive clean-up within `[expiration, expiration+episodes_expiration]` seconds of the
	// recording performed depending on [external_episodes_list](https://flussonic.com/doc/api/config-external/#tag/dvr/operation/external_episodes_list)
	// response of `episodes_url`.
	// Anything older than `expiration+episodes_expiration` seconds will
	// be cleaned even if `episodes_url` does not respond.
	// Format: seconds (seconds)
	// Examples: 6.048e+06
	SetEpisodesExpiration(Seconds) DvrBaseConfig
	// External URL that will be triggered for fetching episodes list.
	// Take a look at config_external API for method `external_episodes_list`.
	// If the `episodes_url` not set or responds with any HTTP code other than `200` or `501` or does not respond within a timeout,
	// the archive clean-up is only performed by `episodes_expiration` time while `expiration` and `storage_limit` are ignored until the `episodes_url` restores.
	// If `episodes_url` is a blank string, then current config_external API endpoint will be used to request episodes.
	// It is most common usage of this field.
	// Examples: , http://central-host.local/config-external/episodes
	EpisodesURL() *string
	// External URL that will be triggered for fetching episodes list.
	// Take a look at config_external API for method `external_episodes_list`.
	// If the `episodes_url` not set or responds with any HTTP code other than `200` or `501` or does not respond within a timeout,
	// the archive clean-up is only performed by `episodes_expiration` time while `expiration` and `storage_limit` are ignored until the `episodes_url` restores.
	// If `episodes_url` is a blank string, then current config_external API endpoint will be used to request episodes.
	// It is most common usage of this field.
	// Examples: , http://central-host.local/config-external/episodes
	SetEpisodesURL(string) DvrBaseConfig
	// Archive depth - a period (in seconds) back from the current moment during which the
	// contigious part of archive is stored.
	// As time goes, the parts of the recording which are older than the archive depth are deleted.
	// If you have option `episodes_expiration` enabled, then some parts of DVR that are
	// locked by episode signalling mechanism may be kept more than this `expiration` depth.
	// If `episodes_url` does not respond, the archive clean-up by `expiration` is not performed;
	// only the archive with expired episodes (`episodes_expiration`) is cleaned up until the `episodes_url` restores.
	// Format: seconds (seconds)
	// Examples: 604800
	Expiration() *Seconds
	// Archive depth - a period (in seconds) back from the current moment during which the
	// contigious part of archive is stored.
	// As time goes, the parts of the recording which are older than the archive depth are deleted.
	// If you have option `episodes_expiration` enabled, then some parts of DVR that are
	// locked by episode signalling mechanism may be kept more than this `expiration` depth.
	// If `episodes_url` does not respond, the archive clean-up by `expiration` is not performed;
	// only the archive with expired episodes (`episodes_expiration`) is cleaned up until the `episodes_url` restores.
	// Format: seconds (seconds)
	// Examples: 604800
	SetExpiration(Seconds) DvrBaseConfig
	// One or several time intervals for recording by schedule.
	// The beginning and the end of each interval are set in "hhmm" format (without leading zeros ) according to UTC standard.
	// For example, `2330` is for 23:30, `800` - for 08:00. The interval can go over midnight, e.g. 22:00-1:30. In this case it is set as follows: `[2200,130]`.
	// Scheduled recording can be useful for the channels with part-time broadcasting.
	// It allows to save disk space significantly.
	// Example: [[800 1600] [2200 130]]
	Schedule() [][]int
	// One or several time intervals for recording by schedule.
	// The beginning and the end of each interval are set in "hhmm" format (without leading zeros ) according to UTC standard.
	// For example, `2330` is for 23:30, `800` - for 08:00. The interval can go over midnight, e.g. 22:00-1:30. In this case it is set as follows: `[2200,130]`.
	// Scheduled recording can be useful for the channels with part-time broadcasting.
	// It allows to save disk space significantly.
	// Example: [[800 1600] [2200 130]]
	SetSchedule([][]int) DvrBaseConfig
	// Maximum disk consumption in bytes. When this limit is reached,
	// the oldest segment of the recording will be overridden by later data.
	// This option affects both continuous recording and locked episodes (see `episodes_url`).
	// If `episodes_url` does not respond, the archive clean-up by `storage_limit` is not performed
	// to avoid deleting the recordings that should not be deleted.
	// Format: bytes (bytes)
	// Example: 4e+11
	StorageLimit() *Bytes
	// Maximum disk consumption in bytes. When this limit is reached,
	// the oldest segment of the recording will be overridden by later data.
	// This option affects both continuous recording and locked episodes (see `episodes_url`).
	// If `episodes_url` does not respond, the archive clean-up by `storage_limit` is not performed
	// to avoid deleting the recordings that should not be deleted.
	// Format: bytes (bytes)
	// Example: 4e+11
	SetStorageLimit(Bytes) DvrBaseConfig
}

// This list of stats can be used to monitor health of invidiual disk in storage.
// There are several layers of indexes in internal database, here you can validate
// integrity of data.
type DvrCapacityStats interface {
	// The number of blobs on the disk that are enlisted in individual stream indexes.
	// It must be equal to blobs_count_db and can be different in case of software
	// or hardware errors.
	BlobsCount() *int
	// The number of blobs on the disk that are enlisted in individual stream indexes.
	// It must be equal to blobs_count_db and can be different in case of software
	// or hardware errors.
	SetBlobsCount(int) DvrCapacityStats
	// The number of blobs on the disk according to centralized Raid DB that is
	// used to allocate blobs across whole storage.
	BlobsCountDb() *int
	// The number of blobs on the disk according to centralized Raid DB that is
	// used to allocate blobs across whole storage.
	SetBlobsCountDb(int) DvrCapacityStats
	// Disk capacity in bytes.
	// Format: bytes (bytes)
	Size() *Bytes
	// Disk capacity in bytes.
	// Format: bytes (bytes)
	SetSize(Bytes) DvrCapacityStats
	// Disk utilization percentage.
	// Format: percent (percent)
	Usage() *Percent
	// Disk utilization percentage.
	// Format: percent (percent)
	SetUsage(Percent) DvrCapacityStats
	// Used disk space in bytes according to linux metrics. It must be equal (almost equal) to
	// `used_index`. If it differs more than in 1%, then it means that there are lot of unknown files.
	// If this disk is used exclusively for Raid, then it may mean that some blobs are lost from
	// database and repairing is required.
	// Format: bytes (bytes)
	Used() *Bytes
	// Used disk space in bytes according to linux metrics. It must be equal (almost equal) to
	// `used_index`. If it differs more than in 1%, then it means that there are lot of unknown files.
	// If this disk is used exclusively for Raid, then it may mean that some blobs are lost from
	// database and repairing is required.
	// Format: bytes (bytes)
	SetUsed(Bytes) DvrCapacityStats
	// Used disk space in bytes according to internal database index.
	// Format: bytes (bytes)
	UsedIndex() *Bytes
	// Used disk space in bytes according to internal database index.
	// Format: bytes (bytes)
	SetUsedIndex(Bytes) DvrCapacityStats
}

type DvrConfig interface {
	// The number of disks to write the archive.
	Active() *int
	// The number of disks to write the archive.
	SetActive(int) DvrConfig
	// If this parameter is set to 'true' (by default),
	// Flussonic will check if the disks were mounted properly before writing to them.
	CheckMount() *bool
	// If this parameter is set to 'true' (by default),
	// Flussonic will check if the disks were mounted properly before writing to them.
	SetCheckMount(bool) DvrConfig
	// Maximum disk consumption in percents. When this limit is reached,
	// the oldest segment of the recording will be overridden by later data.
	// It important to understand that this is not a "per-stream" option, this option means
	// that cleaning of this stream will be triggered if overall disk usage reaches this number.
	// If you have all streams with configuration 98% and one stream with 95%, it will be permanently
	// empty.
	// Format: percent (percent)
	// Example: 98
	DiskUsageLimit() *Percent
	// Maximum disk consumption in percents. When this limit is reached,
	// the oldest segment of the recording will be overridden by later data.
	// It important to understand that this is not a "per-stream" option, this option means
	// that cleaning of this stream will be triggered if overall disk usage reaches this number.
	// If you have all streams with configuration 98% and one stream with 95%, it will be permanently
	// empty.
	// Format: percent (percent)
	// Example: 98
	SetDiskUsageLimit(Percent) DvrConfig
	// RAID disks mounted on the server.
	Disks() []RaidDiskConfig
	// RAID disks mounted on the server.
	SetDisks([]RaidDiskConfig) DvrConfig
	// Additional archive depth in seconds for episodes. If set, episodes and their corresponding DVR record
	// will be saved for `expiration + episodes_expiration` seconds.
	// The archive clean-up within `[expiration, expiration+episodes_expiration]` seconds of the
	// recording performed depending on [external_episodes_list](https://flussonic.com/doc/api/config-external/#tag/dvr/operation/external_episodes_list)
	// response of `episodes_url`.
	// Anything older than `expiration+episodes_expiration` seconds will
	// be cleaned even if `episodes_url` does not respond.
	// Format: seconds (seconds)
	// Examples: 6.048e+06
	EpisodesExpiration() *Seconds
	// Additional archive depth in seconds for episodes. If set, episodes and their corresponding DVR record
	// will be saved for `expiration + episodes_expiration` seconds.
	// The archive clean-up within `[expiration, expiration+episodes_expiration]` seconds of the
	// recording performed depending on [external_episodes_list](https://flussonic.com/doc/api/config-external/#tag/dvr/operation/external_episodes_list)
	// response of `episodes_url`.
	// Anything older than `expiration+episodes_expiration` seconds will
	// be cleaned even if `episodes_url` does not respond.
	// Format: seconds (seconds)
	// Examples: 6.048e+06
	SetEpisodesExpiration(Seconds) DvrConfig
	// External URL that will be triggered for fetching episodes list.
	// Take a look at config_external API for method `external_episodes_list`.
	// If the `episodes_url` not set or responds with any HTTP code other than `200` or `501` or does not respond within a timeout,
	// the archive clean-up is only performed by `episodes_expiration` time while `expiration` and `storage_limit` are ignored until the `episodes_url` restores.
	// If `episodes_url` is a blank string, then current config_external API endpoint will be used to request episodes.
	// It is most common usage of this field.
	// Examples: , http://central-host.local/config-external/episodes
	EpisodesURL() *string
	// External URL that will be triggered for fetching episodes list.
	// Take a look at config_external API for method `external_episodes_list`.
	// If the `episodes_url` not set or responds with any HTTP code other than `200` or `501` or does not respond within a timeout,
	// the archive clean-up is only performed by `episodes_expiration` time while `expiration` and `storage_limit` are ignored until the `episodes_url` restores.
	// If `episodes_url` is a blank string, then current config_external API endpoint will be used to request episodes.
	// It is most common usage of this field.
	// Examples: , http://central-host.local/config-external/episodes
	SetEpisodesURL(string) DvrConfig
	// Archive depth - a period (in seconds) back from the current moment during which the
	// contigious part of archive is stored.
	// As time goes, the parts of the recording which are older than the archive depth are deleted.
	// If you have option `episodes_expiration` enabled, then some parts of DVR that are
	// locked by episode signalling mechanism may be kept more than this `expiration` depth.
	// If `episodes_url` does not respond, the archive clean-up by `expiration` is not performed;
	// only the archive with expired episodes (`episodes_expiration`) is cleaned up until the `episodes_url` restores.
	// Format: seconds (seconds)
	// Examples: 604800
	Expiration() *Seconds
	// Archive depth - a period (in seconds) back from the current moment during which the
	// contigious part of archive is stored.
	// As time goes, the parts of the recording which are older than the archive depth are deleted.
	// If you have option `episodes_expiration` enabled, then some parts of DVR that are
	// locked by episode signalling mechanism may be kept more than this `expiration` depth.
	// If `episodes_url` does not respond, the archive clean-up by `expiration` is not performed;
	// only the archive with expired episodes (`episodes_expiration`) is cleaned up until the `episodes_url` restores.
	// Format: seconds (seconds)
	// Examples: 604800
	SetExpiration(Seconds) DvrConfig
	// A directory on an SSD disk where the data will be cached.
	// Format: disk_path (disk_path)
	Index() *DiskPath
	// A directory on an SSD disk where the data will be cached.
	// Format: disk_path (disk_path)
	SetIndex(DiskPath) DvrConfig
	// DVR configuration name.
	// Format: dvr_name (dvr_name)
	Name() DvrName
	// DVR configuration name.
	// Format: dvr_name (dvr_name)
	SetName(DvrName) DvrConfig
	// This value is present if RAID (redundant array of independent disks) is enabled. Learn more in [Flussonic RAID for DVR](https://flussonic.com/doc/extend-video-storage-on-fly/).
	Raid() *DvrRaidLevel
	// This value is present if RAID (redundant array of independent disks) is enabled. Learn more in [Flussonic RAID for DVR](https://flussonic.com/doc/extend-video-storage-on-fly/).
	SetRaid(DvrRaidLevel) DvrConfig
	// A path where the DVR archive is stored.
	// Format: dvr_url (dvr_url)
	Root() DvrURL
	// A path where the DVR archive is stored.
	// Format: dvr_url (dvr_url)
	SetRoot(DvrURL) DvrConfig
	// One or several time intervals for recording by schedule.
	// The beginning and the end of each interval are set in "hhmm" format (without leading zeros ) according to UTC standard.
	// For example, `2330` is for 23:30, `800` - for 08:00. The interval can go over midnight, e.g. 22:00-1:30. In this case it is set as follows: `[2200,130]`.
	// Scheduled recording can be useful for the channels with part-time broadcasting.
	// It allows to save disk space significantly.
	// Example: [[800 1600] [2200 130]]
	Schedule() [][]int
	// One or several time intervals for recording by schedule.
	// The beginning and the end of each interval are set in "hhmm" format (without leading zeros ) according to UTC standard.
	// For example, `2330` is for 23:30, `800` - for 08:00. The interval can go over midnight, e.g. 22:00-1:30. In this case it is set as follows: `[2200,130]`.
	// Scheduled recording can be useful for the channels with part-time broadcasting.
	// It allows to save disk space significantly.
	// Example: [[800 1600] [2200 130]]
	SetSchedule([][]int) DvrConfig
	// The runtime statistics about DVR.
	Stats() DvrStorageConfigStats
	// The runtime statistics about DVR.
	SetStats(DvrStorageConfigStats) DvrConfig
	// Maximum disk consumption in bytes. When this limit is reached,
	// the oldest segment of the recording will be overridden by later data.
	// This option affects both continuous recording and locked episodes (see `episodes_url`).
	// If `episodes_url` does not respond, the archive clean-up by `storage_limit` is not performed
	// to avoid deleting the recordings that should not be deleted.
	// Format: bytes (bytes)
	// Example: 4e+11
	StorageLimit() *Bytes
	// Maximum disk consumption in bytes. When this limit is reached,
	// the oldest segment of the recording will be overridden by later data.
	// This option affects both continuous recording and locked episodes (see `episodes_url`).
	// If `episodes_url` does not respond, the archive clean-up by `storage_limit` is not performed
	// to avoid deleting the recordings that should not be deleted.
	// Format: bytes (bytes)
	// Example: 4e+11
	SetStorageLimit(Bytes) DvrConfig
}

// Required: from, depth, ranges
type DvrInfo interface {
	// The size of the recorded archive.
	// Format: bytes (bytes)
	// Example: 1.296e+11
	Bytes() *Bytes
	// The size of the recorded archive.
	// Format: bytes (bytes)
	// Example: 1.296e+11
	SetBytes(Bytes) DvrInfo
	// The time interval between the start of the *first* recording segment and the end of the *last* one.
	// Format: seconds (seconds)
	// Example: 259200
	Depth() Seconds
	// The time interval between the start of the *first* recording segment and the end of the *last* one.
	// Format: seconds (seconds)
	// Example: 259200
	SetDepth(Seconds) DvrInfo
	// Deprecated field. Will be deleted at 25.07
	// The size of the recorded archive. Please, use bytes instead.
	// Format: bytes (bytes)
	// Example: 1.099511627776e+12
	DiskSize() *Bytes
	// Deprecated field. Will be deleted at 25.07
	// The size of the recorded archive. Please, use bytes instead.
	// Format: bytes (bytes)
	// Example: 1.099511627776e+12
	SetDiskSize(Bytes) DvrInfo
	// A total duration of the recorded segments, excluding recording gaps.
	// It can be smaller than depth if you have gaps.
	// Format: seconds (seconds)
	// Example: 172800
	Duration() *Seconds
	// A total duration of the recorded segments, excluding recording gaps.
	// It can be smaller than depth if you have gaps.
	// Format: seconds (seconds)
	// Example: 172800
	SetDuration(Seconds) DvrInfo
	// The UTC timestamp of the first recording in this archive.
	// Format: utc (Unix timestamp in seconds)
	// Example: 1.641045644e+09
	From() Utc
	// The UTC timestamp of the first recording in this archive.
	// Format: utc (Unix timestamp in seconds)
	// Example: 1.641045644e+09
	SetFrom(Utc) DvrInfo
	// Deprecated field. Will be deleted at 24.09
	// The list of DVR ranges. The param is replaced with `ranges_list` method.
	Ranges() []DvrRange
	// Deprecated field. Will be deleted at 24.09
	// The list of DVR ranges. The param is replaced with `ranges_list` method.
	SetRanges([]DvrRange) DvrInfo
}

type DvrRange interface {
	// The the of the last recorded data.
	// Please notice that closed_at could be changed. There are two reasons.
	// - Cleaner process reduced data. Read [more](https://flussonic.com/doc/api/reference/#tag/stream/operation/stream_get/response%7Cdvr%7Cepisodes_url).
	// - Recording is still working. Near real-time value means that DVR is active at the moment.
	// This is a replacement for `duration` field
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	ClosedAt() *UtcMs
	// The the of the last recorded data.
	// Please notice that closed_at could be changed. There are two reasons.
	// - Cleaner process reduced data. Read [more](https://flussonic.com/doc/api/reference/#tag/stream/operation/stream_get/response%7Cdvr%7Cepisodes_url).
	// - Recording is still working. Near real-time value means that DVR is active at the moment.
	// This is a replacement for `duration` field
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetClosedAt(UtcMs) DvrRange
	// Deprecated field. Will be deleted at 24.11
	// The duration of the recorded DVR range.
	// Use closed_at instead of this field.
	// Format: seconds (seconds)
	// Example: 28800
	Duration() *Seconds
	// Deprecated field. Will be deleted at 24.11
	// The duration of the recorded DVR range.
	// Use closed_at instead of this field.
	// Format: seconds (seconds)
	// Example: 28800
	SetDuration(Seconds) DvrRange
	// Deprecated field. Will be deleted at 24.11
	// The beginning of the recorded DVR range. Use opened_at instead.
	// Mention that opened_at has milliseconds
	// Format: utc (Unix timestamp in seconds)
	// Example: 1.525186456e+09
	From() *Utc
	// Deprecated field. Will be deleted at 24.11
	// The beginning of the recorded DVR range. Use opened_at instead.
	// Mention that opened_at has milliseconds
	// Format: utc (Unix timestamp in seconds)
	// Example: 1.525186456e+09
	SetFrom(Utc) DvrRange
	// The time when this range was started. Naming is standard for whole flussonic ecosystem.
	// Is a replacement for field `from`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	OpenedAt() *UtcMs
	// The time when this range was started. Naming is standard for whole flussonic ecosystem.
	// Is a replacement for field `from`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetOpenedAt(UtcMs) DvrRange
}

// Required: name, root
type DvrStorageConfig interface {
	// The number of disks to write the archive.
	Active() *int
	// The number of disks to write the archive.
	SetActive(int) DvrStorageConfig
	// If this parameter is set to 'true' (by default),
	// Flussonic will check if the disks were mounted properly before writing to them.
	CheckMount() *bool
	// If this parameter is set to 'true' (by default),
	// Flussonic will check if the disks were mounted properly before writing to them.
	SetCheckMount(bool) DvrStorageConfig
	// RAID disks mounted on the server.
	Disks() []RaidDiskConfig
	// RAID disks mounted on the server.
	SetDisks([]RaidDiskConfig) DvrStorageConfig
	// A directory on an SSD disk where the data will be cached.
	// Format: disk_path (disk_path)
	Index() *DiskPath
	// A directory on an SSD disk where the data will be cached.
	// Format: disk_path (disk_path)
	SetIndex(DiskPath) DvrStorageConfig
	// DVR configuration name.
	// Format: dvr_name (dvr_name)
	Name() DvrName
	// DVR configuration name.
	// Format: dvr_name (dvr_name)
	SetName(DvrName) DvrStorageConfig
	// This value is present if RAID (redundant array of independent disks) is enabled. Learn more in [Flussonic RAID for DVR](https://flussonic.com/doc/extend-video-storage-on-fly/).
	Raid() *DvrRaidLevel
	// This value is present if RAID (redundant array of independent disks) is enabled. Learn more in [Flussonic RAID for DVR](https://flussonic.com/doc/extend-video-storage-on-fly/).
	SetRaid(DvrRaidLevel) DvrStorageConfig
	// A path where the DVR archive is stored.
	// Format: dvr_url (dvr_url)
	Root() DvrURL
	// A path where the DVR archive is stored.
	// Format: dvr_url (dvr_url)
	SetRoot(DvrURL) DvrStorageConfig
	// The runtime statistics about DVR.
	Stats() DvrStorageConfigStats
	// The runtime statistics about DVR.
	SetStats(DvrStorageConfigStats) DvrStorageConfig
}

// The runtime statistics about DVR.
type DvrStorageConfigStats interface {
	// The number of blobs on the disk that are enlisted in individual stream indexes.
	// It must be equal to blobs_count_db and can be different in case of software
	// or hardware errors.
	BlobsCount() *int
	// The number of blobs on the disk that are enlisted in individual stream indexes.
	// It must be equal to blobs_count_db and can be different in case of software
	// or hardware errors.
	SetBlobsCount(int) DvrStorageConfigStats
	// The number of blobs on the disk according to centralized Raid DB that is
	// used to allocate blobs across whole storage.
	BlobsCountDb() *int
	// The number of blobs on the disk according to centralized Raid DB that is
	// used to allocate blobs across whole storage.
	SetBlobsCountDb(int) DvrStorageConfigStats
	// The runtime DVR errors.
	Errors() DvrStorageErrors
	// The runtime DVR errors.
	SetErrors(DvrStorageErrors) DvrStorageConfigStats
	// Disk capacity in bytes.
	// Format: bytes (bytes)
	Size() *Bytes
	// Disk capacity in bytes.
	// Format: bytes (bytes)
	SetSize(Bytes) DvrStorageConfigStats
	// Disk utilization percentage.
	// Format: percent (percent)
	Usage() *Percent
	// Disk utilization percentage.
	// Format: percent (percent)
	SetUsage(Percent) DvrStorageConfigStats
	// Used disk space in bytes according to linux metrics. It must be equal (almost equal) to
	// `used_index`. If it differs more than in 1%, then it means that there are lot of unknown files.
	// If this disk is used exclusively for Raid, then it may mean that some blobs are lost from
	// database and repairing is required.
	// Format: bytes (bytes)
	Used() *Bytes
	// Used disk space in bytes according to linux metrics. It must be equal (almost equal) to
	// `used_index`. If it differs more than in 1%, then it means that there are lot of unknown files.
	// If this disk is used exclusively for Raid, then it may mean that some blobs are lost from
	// database and repairing is required.
	// Format: bytes (bytes)
	SetUsed(Bytes) DvrStorageConfigStats
	// Used disk space in bytes according to internal database index.
	// Format: bytes (bytes)
	UsedIndex() *Bytes
	// Used disk space in bytes according to internal database index.
	// Format: bytes (bytes)
	SetUsedIndex(Bytes) DvrStorageConfigStats
}

type DvrStorageErrors interface {
	// Total number of collapsed segments while writing to the archive. Collapsed segments are pack of segments written together occur due to lack of storage performance.
	CollapsedWriteCount() *int
	// Total number of collapsed segments while writing to the archive. Collapsed segments are pack of segments written together occur due to lack of storage performance.
	SetCollapsedWriteCount(int) DvrStorageErrors
	// Total number of errors while deleting from the archive.
	DeleteErrors() *int
	// Total number of errors while deleting from the archive.
	SetDeleteErrors(int) DvrStorageErrors
	// Total number of dropped segments while writing to the archive.
	DropWriteCount() *int
	// Total number of dropped segments while writing to the archive.
	SetDropWriteCount(int) DvrStorageErrors
	// Total number of errors while reading the archive.
	ReadErrors() *int
	// Total number of errors while reading the archive.
	SetReadErrors(int) DvrStorageErrors
	// Total number of errors while writing to the archive.
	WriteErrors() *int
	// Total number of errors while writing to the archive.
	SetWriteErrors(int) DvrStorageErrors
}

type DvrStorageStats interface {
	// The runtime DVR errors.
	Errors() DvrStorageErrors
	// The runtime DVR errors.
	SetErrors(DvrStorageErrors) DvrStorageStats
}

type EntityEvent interface {
	// Unique identifier of the entity.
	// For example, for `agent` it is `agent_id` field.
	EntityID() *string
	// Unique identifier of the entity.
	// For example, for `agent` it is `agent_id` field.
	SetEntityID(string) EntityEvent
	// Type of the entity.
	EntityType() *EntityEventEntityType
	// Type of the entity.
	SetEntityType(EntityEventEntityType) EntityEvent
	// Event identifier.
	EventID() *int
	// Event identifier.
	SetEventID(int) EntityEvent
	// Originator of event.
	// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
	// is configured as HTTP/HTTPS url.
	// Example: flussonic.host
	Server() *string
	// Originator of event.
	// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
	// is configured as HTTP/HTTPS url.
	// Example: flussonic.host
	SetServer(string) EntityEvent
	// Unique identifier of the operation.
	// You can use this field to search for events related to same operation.
	// Value of this field is taken from the `X-Trace-Id` header.
	// If `X-Trace-Id` header is not set, it will be generated automatically.
	// Service will use the value of this field to make outgoing requests.
	// Format: uuid (uuid)
	// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
	TraceID() *UUID
	// Unique identifier of the operation.
	// You can use this field to search for events related to same operation.
	// Value of this field is taken from the `X-Trace-Id` header.
	// If `X-Trace-Id` header is not set, it will be generated automatically.
	// Service will use the value of this field to make outgoing requests.
	// Format: uuid (uuid)
	// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
	SetTraceID(UUID) EntityEvent
	// The time of the event registration on the server.
	// Format: utc_ms (Unix timestamp in milliseconds)
	UtcMs() *UtcMs
	// The time of the event registration on the server.
	// Format: utc_ms (Unix timestamp in milliseconds)
	SetUtcMs(UtcMs) EntityEvent
}

type Episode interface {
	// The reason for closing the episode.
	CloseReason() *EpisodeCloseReason
	// The reason for closing the episode.
	SetCloseReason(EpisodeCloseReason) Episode
	// Episode emitter can decide that episode considered closed and will not grow further.
	// `closed_at` MUST NOT change, it must be emitted only once.
	// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
	// of the episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	ClosedAt() *UtcMs
	// Episode emitter can decide that episode considered closed and will not grow further.
	// `closed_at` MUST NOT change, it must be emitted only once.
	// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
	// of the episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetClosedAt(UtcMs) Episode
	// Detections associated with this episode
	Detections() any
	// Detections associated with this episode
	SetDetections(any) Episode
	// The time when the episode appeared in the service relative to the server time.
	EpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps
	// The time when the episode appeared in the service relative to the server time.
	SetEpisodeAppearanceTimestamps(EpisodeAppearanceTimestamps) Episode
	// Unique identifier of the episode. Must be created by the system that first creates this episode.
	// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
	// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
	// handle very long integers.
	// Format: snowflake_id (snowflake_id)
	// Examples: 1.722279170848854e+18
	EpisodeID() SnowflakeID
	// Unique identifier of the episode. Must be created by the system that first creates this episode.
	// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
	// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
	// handle very long integers.
	// Format: snowflake_id (snowflake_id)
	// Examples: 1.722279170848854e+18
	SetEpisodeID(SnowflakeID) Episode
	// Generic stream episode/Face is detected/Vehicle is detected/Human is detected/Episode matches context search text query/QR-code is detected/Custom episode type.
	// Use this field to define your own episode types when integrating custom analytics.
	// If episode type is not specified, episode will be saved with `generic` type.
	EpisodeType() *string
	// Generic stream episode/Face is detected/Vehicle is detected/Human is detected/Episode matches context search text query/QR-code is detected/Custom episode type.
	// Use this field to define your own episode types when integrating custom analytics.
	// If episode type is not specified, episode will be saved with `generic` type.
	SetEpisodeType(string) Episode
	// The fingerprint of the detected face
	Fingerprint() VisionFaceFingerprint
	// The fingerprint of the detected face
	SetFingerprint(VisionFaceFingerprint) Episode
	// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
	// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
	// Format: base64 (base64)
	FramePreview() *Base64
	// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
	// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
	// Format: base64 (base64)
	SetFramePreview(Base64) Episode
	// Indicates if no license plate is detected on this vehicle
	LicensePlateMissing() *bool
	// Indicates if no license plate is detected on this vehicle
	SetLicensePlateMissing(bool) Episode
	// Recognized vehicle's license plate number
	LicensePlateText() *string
	// Recognized vehicle's license plate number
	SetLicensePlateText(string) Episode
	// Maximum matching score between the text query and episode.
	// Examples: 0.2345
	MatchScore() *float64
	// Maximum matching score between the text query and episode.
	// Examples: 0.2345
	SetMatchScore(float64) Episode
	// List of matched persons with similarity metric.
	// Videoanalytics identification service enriches episode's data and fills this field
	// with the list of persons that are similar to the face detected in this episode.
	MatchedPersons() []VisionPersonMatch
	// List of matched persons with similarity metric.
	// Videoanalytics identification service enriches episode's data and fills this field
	// with the list of persons that are similar to the face detected in this episode.
	SetMatchedPersons([]VisionPersonMatch) Episode
	// Stream name on which this episode exists.
	// Format: media_name (media_name)
	Media() MediaName
	// Stream name on which this episode exists.
	// Format: media_name (media_name)
	SetMedia(MediaName) Episode
	// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
	// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
	// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
	// sort as by `opened_at`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	OpenedAt() UtcMs
	// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
	// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
	// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
	// sort as by `opened_at`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetOpenedAt(UtcMs) Episode
	// This describes the way this episode was updated, whether via an inference node or an API.
	// In the case of an inference node, its hostname will be provided.
	Originator() EpisodeOriginator
	// This describes the way this episode was updated, whether via an inference node or an API.
	// In the case of an inference node, its hostname will be provided.
	SetOriginator(EpisodeOriginator) Episode
	// Raw data extracted from QR-code/Custom episode payload. Use this field to provide additional information about the episode.
	Payload() any
	// Raw data extracted from QR-code/Custom episode payload. Use this field to provide additional information about the episode.
	SetPayload(any) Episode
	// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// /Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Preview contains an image of person's face and has a resolution about 200 x 200 pixels with maximum size about 10 kilobytes.
	// /Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Preview contains an image of vehicle's license plate and has a resolution about 160 x 64 pixels with maximum size about 10 kilobytes.
	Preview() *Base64
	// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// /Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Preview contains an image of person's face and has a resolution about 200 x 200 pixels with maximum size about 10 kilobytes.
	// /Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Preview contains an image of vehicle's license plate and has a resolution about 160 x 64 pixels with maximum size about 10 kilobytes.
	SetPreview(Base64) Episode
	// The time when the preview of this episode is available.
	// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
	// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
	// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
	// for details.
	// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	PreviewTimestamp() *UtcMs
	// The time when the preview of this episode is available.
	// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
	// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
	// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
	// for details.
	// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetPreviewTimestamp(UtcMs) Episode
	// DVR recording status: fully recorded, not recorded, or partially recorded
	RecordingStatus() *string
	// DVR recording status: fully recorded, not recorded, or partially recorded
	SetRecordingStatus(string) Episode
	// This field can be used as indication of the fact that some system have checked and ensured that
	// this episode has really started at some time, that may differ from `opened_at`.
	// For example video analytics will use this field for the time when this episode was confirmed as confident.
	// May be not relevant for television systems.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	StartedAt() *UtcMs
	// This field can be used as indication of the fact that some system have checked and ensured that
	// this episode has really started at some time, that may differ from `opened_at`.
	// For example video analytics will use this field for the time when this episode was confirmed as confident.
	// May be not relevant for television systems.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetStartedAt(UtcMs) Episode
	// The time of last change of the episode.
	// System that processes episodes and can send them to other systems, MUST update this field
	// on any changes in this episode.
	// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
	// this `updated_at` can be used as a sort key for fetching fresh updates.
	// Consumer of the episodes can use `updated_at` in the following scenario:
	// * fetch all exisiting episodes from the source
	// * take biggest `updated_at` from this dataset, it will be T
	// * ask source for all episodes with `updated_at > T`
	// This algorithm can be used for fetching update stream from the source.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637098611e+12
	UpdatedAt() UtcMs
	// The time of last change of the episode.
	// System that processes episodes and can send them to other systems, MUST update this field
	// on any changes in this episode.
	// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
	// this `updated_at` can be used as a sort key for fetching fresh updates.
	// Consumer of the episodes can use `updated_at` in the following scenario:
	// * fetch all exisiting episodes from the source
	// * take biggest `updated_at` from this dataset, it will be T
	// * ask source for all episodes with `updated_at > T`
	// This algorithm can be used for fetching update stream from the source.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637098611e+12
	SetUpdatedAt(UtcMs) Episode
	// Emergency type of the vehicle.
	VehicleEmergencySubtype() *VisionVehicleEmergencySubtype
	// Emergency type of the vehicle.
	SetVehicleEmergencySubtype(VisionVehicleEmergencySubtype) Episode
	// Shows from which side the vehicle was detected.
	VehicleFacingSide() *VisionVehicleFacingSide
	// Shows from which side the vehicle was detected.
	SetVehicleFacingSide(VisionVehicleFacingSide) Episode
	// The purpose of the vehicle, e.g. emergency or regular.
	VehiclePurpose() *VisionVehiclePurpose
	// The purpose of the vehicle, e.g. emergency or regular.
	SetVehiclePurpose(VisionVehiclePurpose) Episode
}

type EpisodeAppearanceTimestamps interface {
	// The time when this episode was fetched by Central.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637098611e+12
	CentralTimestamp() *UtcMs
	// The time when this episode was fetched by Central.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637098611e+12
	SetCentralTimestamp(UtcMs) EpisodeAppearanceTimestamps
	// The time when this episode was created in inference service.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	InferenceTimestamp() *UtcMs
	// The time when this episode was created in inference service.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	SetInferenceTimestamp(UtcMs) EpisodeAppearanceTimestamps
}

// # Definition
// Episode is a record about continious part of one video stream.
// It is used in video analytics, television systems, etc. for describing one continious and logically
// consolidated part of video stream.
// For example, episode can describe one TV show or a part of video when the car with specific license plate
// passed the camera view.
// Different systems in our ecosystem can emit and consume episodes of different `episode_type`.
// # Alternatives
// What episodes are not:
// * they cannot combine multiple streams. If you have multicamera view on the scene, you will have to create many episodes and join then in another system
// * they cannot be multipart. Only one continious uninterrupted episode. However, it is ok for them to overlap.
// # Updates
// Episodes are supposed to be streamable and updatable.
// If you consume episodes, you must be ready to see old `episode_id`
// with new updated data. You MUST overwrite previous data.
// If you emit episodes and you change any fields, you MUST accumulate previous data of episode and send full copy of
// updated episode.
// # Borders
// Episode have two mandatory fields: `opened_at` and `updated_at`, they are default borders of the episode:
// beginning and the end.
// Sometimes you need to look at another fields: `started_at` and `closed_at`.
// `started_at` appears when episode emitter decides that beginning of the episode should be different from `opened_at`,
// for example if video analytics has analysed previous frames and decided that this object appeared earlier.
// `closed_at` can appear if episode source have decided that episode will not continue anymore, for example
// car have run out of camera view. However, `updated_at` can be still changed, if any other system will add
// more data there, for example detected licence plates of some other auxiliary information.
// Required: episode_id, media, opened_at, updated_at
type EpisodeBase interface {
	// The reason for closing the episode.
	CloseReason() *EpisodeCloseReason
	// The reason for closing the episode.
	SetCloseReason(EpisodeCloseReason) EpisodeBase
	// Episode emitter can decide that episode considered closed and will not grow further.
	// `closed_at` MUST NOT change, it must be emitted only once.
	// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
	// of the episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	ClosedAt() *UtcMs
	// Episode emitter can decide that episode considered closed and will not grow further.
	// `closed_at` MUST NOT change, it must be emitted only once.
	// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
	// of the episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetClosedAt(UtcMs) EpisodeBase
	// The time when the episode appeared in the service relative to the server time.
	EpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps
	// The time when the episode appeared in the service relative to the server time.
	SetEpisodeAppearanceTimestamps(EpisodeAppearanceTimestamps) EpisodeBase
	// Unique identifier of the episode. Must be created by the system that first creates this episode.
	// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
	// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
	// handle very long integers.
	// Format: snowflake_id (snowflake_id)
	// Examples: 1.722279170848854e+18
	EpisodeID() SnowflakeID
	// Unique identifier of the episode. Must be created by the system that first creates this episode.
	// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
	// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
	// handle very long integers.
	// Format: snowflake_id (snowflake_id)
	// Examples: 1.722279170848854e+18
	SetEpisodeID(SnowflakeID) EpisodeBase
	// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
	// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
	// Format: base64 (base64)
	FramePreview() *Base64
	// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
	// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
	// Format: base64 (base64)
	SetFramePreview(Base64) EpisodeBase
	// Stream name on which this episode exists.
	// Format: media_name (media_name)
	Media() MediaName
	// Stream name on which this episode exists.
	// Format: media_name (media_name)
	SetMedia(MediaName) EpisodeBase
	// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
	// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
	// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
	// sort as by `opened_at`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	OpenedAt() UtcMs
	// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
	// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
	// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
	// sort as by `opened_at`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetOpenedAt(UtcMs) EpisodeBase
	// This describes the way this episode was updated, whether via an inference node or an API.
	// In the case of an inference node, its hostname will be provided.
	Originator() EpisodeOriginator
	// This describes the way this episode was updated, whether via an inference node or an API.
	// In the case of an inference node, its hostname will be provided.
	SetOriginator(EpisodeOriginator) EpisodeBase
	// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Format: base64 (base64)
	Preview() *Base64
	// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Format: base64 (base64)
	SetPreview(Base64) EpisodeBase
	// The time when the preview of this episode is available.
	// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
	// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
	// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
	// for details.
	// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	PreviewTimestamp() *UtcMs
	// The time when the preview of this episode is available.
	// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
	// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
	// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
	// for details.
	// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetPreviewTimestamp(UtcMs) EpisodeBase
	// DVR recording status: fully recorded, not recorded, or partially recorded
	RecordingStatus() *string
	// DVR recording status: fully recorded, not recorded, or partially recorded
	SetRecordingStatus(string) EpisodeBase
	// This field can be used as indication of the fact that some system have checked and ensured that
	// this episode has really started at some time, that may differ from `opened_at`.
	// For example video analytics will use this field for the time when this episode was confirmed as confident.
	// May be not relevant for television systems.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	StartedAt() *UtcMs
	// This field can be used as indication of the fact that some system have checked and ensured that
	// this episode has really started at some time, that may differ from `opened_at`.
	// For example video analytics will use this field for the time when this episode was confirmed as confident.
	// May be not relevant for television systems.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetStartedAt(UtcMs) EpisodeBase
	// The time of last change of the episode.
	// System that processes episodes and can send them to other systems, MUST update this field
	// on any changes in this episode.
	// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
	// this `updated_at` can be used as a sort key for fetching fresh updates.
	// Consumer of the episodes can use `updated_at` in the following scenario:
	// * fetch all exisiting episodes from the source
	// * take biggest `updated_at` from this dataset, it will be T
	// * ask source for all episodes with `updated_at > T`
	// This algorithm can be used for fetching update stream from the source.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637098611e+12
	UpdatedAt() UtcMs
	// The time of last change of the episode.
	// System that processes episodes and can send them to other systems, MUST update this field
	// on any changes in this episode.
	// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
	// this `updated_at` can be used as a sort key for fetching fresh updates.
	// Consumer of the episodes can use `updated_at` in the following scenario:
	// * fetch all exisiting episodes from the source
	// * take biggest `updated_at` from this dataset, it will be T
	// * ask source for all episodes with `updated_at > T`
	// This algorithm can be used for fetching update stream from the source.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637098611e+12
	SetUpdatedAt(UtcMs) EpisodeBase
}

type EpisodeCustom interface {
	// The reason for closing the episode.
	CloseReason() *EpisodeCloseReason
	// The reason for closing the episode.
	SetCloseReason(EpisodeCloseReason) EpisodeCustom
	// Episode emitter can decide that episode considered closed and will not grow further.
	// `closed_at` MUST NOT change, it must be emitted only once.
	// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
	// of the episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	ClosedAt() *UtcMs
	// Episode emitter can decide that episode considered closed and will not grow further.
	// `closed_at` MUST NOT change, it must be emitted only once.
	// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
	// of the episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetClosedAt(UtcMs) EpisodeCustom
	// The time when the episode appeared in the service relative to the server time.
	EpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps
	// The time when the episode appeared in the service relative to the server time.
	SetEpisodeAppearanceTimestamps(EpisodeAppearanceTimestamps) EpisodeCustom
	// Unique identifier of the episode. Must be created by the system that first creates this episode.
	// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
	// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
	// handle very long integers.
	// Format: snowflake_id (snowflake_id)
	// Examples: 1.722279170848854e+18
	EpisodeID() SnowflakeID
	// Unique identifier of the episode. Must be created by the system that first creates this episode.
	// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
	// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
	// handle very long integers.
	// Format: snowflake_id (snowflake_id)
	// Examples: 1.722279170848854e+18
	SetEpisodeID(SnowflakeID) EpisodeCustom
	// Custom episode type.
	// Use this field to define your own episode types when integrating custom analytics.
	// If episode type is not specified, episode will be saved with `generic` type.
	EpisodeType() *string
	// Custom episode type.
	// Use this field to define your own episode types when integrating custom analytics.
	// If episode type is not specified, episode will be saved with `generic` type.
	SetEpisodeType(string) EpisodeCustom
	// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
	// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
	// Format: base64 (base64)
	FramePreview() *Base64
	// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
	// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
	// Format: base64 (base64)
	SetFramePreview(Base64) EpisodeCustom
	// Stream name on which this episode exists.
	// Format: media_name (media_name)
	Media() MediaName
	// Stream name on which this episode exists.
	// Format: media_name (media_name)
	SetMedia(MediaName) EpisodeCustom
	// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
	// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
	// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
	// sort as by `opened_at`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	OpenedAt() UtcMs
	// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
	// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
	// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
	// sort as by `opened_at`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetOpenedAt(UtcMs) EpisodeCustom
	// This describes the way this episode was updated, whether via an inference node or an API.
	// In the case of an inference node, its hostname will be provided.
	Originator() EpisodeOriginator
	// This describes the way this episode was updated, whether via an inference node or an API.
	// In the case of an inference node, its hostname will be provided.
	SetOriginator(EpisodeOriginator) EpisodeCustom
	// Custom episode payload. Use this field to provide additional information about the episode.
	Payload() any
	// Custom episode payload. Use this field to provide additional information about the episode.
	SetPayload(any) EpisodeCustom
	// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Format: base64 (base64)
	Preview() *Base64
	// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Format: base64 (base64)
	SetPreview(Base64) EpisodeCustom
	// The time when the preview of this episode is available.
	// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
	// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
	// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
	// for details.
	// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	PreviewTimestamp() *UtcMs
	// The time when the preview of this episode is available.
	// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
	// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
	// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
	// for details.
	// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetPreviewTimestamp(UtcMs) EpisodeCustom
	// DVR recording status: fully recorded, not recorded, or partially recorded
	RecordingStatus() *string
	// DVR recording status: fully recorded, not recorded, or partially recorded
	SetRecordingStatus(string) EpisodeCustom
	// This field can be used as indication of the fact that some system have checked and ensured that
	// this episode has really started at some time, that may differ from `opened_at`.
	// For example video analytics will use this field for the time when this episode was confirmed as confident.
	// May be not relevant for television systems.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	StartedAt() *UtcMs
	// This field can be used as indication of the fact that some system have checked and ensured that
	// this episode has really started at some time, that may differ from `opened_at`.
	// For example video analytics will use this field for the time when this episode was confirmed as confident.
	// May be not relevant for television systems.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetStartedAt(UtcMs) EpisodeCustom
	// The time of last change of the episode.
	// System that processes episodes and can send them to other systems, MUST update this field
	// on any changes in this episode.
	// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
	// this `updated_at` can be used as a sort key for fetching fresh updates.
	// Consumer of the episodes can use `updated_at` in the following scenario:
	// * fetch all exisiting episodes from the source
	// * take biggest `updated_at` from this dataset, it will be T
	// * ask source for all episodes with `updated_at > T`
	// This algorithm can be used for fetching update stream from the source.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637098611e+12
	UpdatedAt() UtcMs
	// The time of last change of the episode.
	// System that processes episodes and can send them to other systems, MUST update this field
	// on any changes in this episode.
	// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
	// this `updated_at` can be used as a sort key for fetching fresh updates.
	// Consumer of the episodes can use `updated_at` in the following scenario:
	// * fetch all exisiting episodes from the source
	// * take biggest `updated_at` from this dataset, it will be T
	// * ask source for all episodes with `updated_at > T`
	// This algorithm can be used for fetching update stream from the source.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637098611e+12
	SetUpdatedAt(UtcMs) EpisodeCustom
}

type EpisodeGeneric interface {
	// The reason for closing the episode.
	CloseReason() *EpisodeCloseReason
	// The reason for closing the episode.
	SetCloseReason(EpisodeCloseReason) EpisodeGeneric
	// Episode emitter can decide that episode considered closed and will not grow further.
	// `closed_at` MUST NOT change, it must be emitted only once.
	// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
	// of the episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	ClosedAt() *UtcMs
	// Episode emitter can decide that episode considered closed and will not grow further.
	// `closed_at` MUST NOT change, it must be emitted only once.
	// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
	// of the episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetClosedAt(UtcMs) EpisodeGeneric
	// The time when the episode appeared in the service relative to the server time.
	EpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps
	// The time when the episode appeared in the service relative to the server time.
	SetEpisodeAppearanceTimestamps(EpisodeAppearanceTimestamps) EpisodeGeneric
	// Unique identifier of the episode. Must be created by the system that first creates this episode.
	// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
	// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
	// handle very long integers.
	// Format: snowflake_id (snowflake_id)
	// Examples: 1.722279170848854e+18
	EpisodeID() SnowflakeID
	// Unique identifier of the episode. Must be created by the system that first creates this episode.
	// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
	// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
	// handle very long integers.
	// Format: snowflake_id (snowflake_id)
	// Examples: 1.722279170848854e+18
	SetEpisodeID(SnowflakeID) EpisodeGeneric
	// Generic stream episode
	EpisodeType() *string
	// Generic stream episode
	SetEpisodeType(string) EpisodeGeneric
	// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
	// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
	// Format: base64 (base64)
	FramePreview() *Base64
	// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
	// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
	// Format: base64 (base64)
	SetFramePreview(Base64) EpisodeGeneric
	// Stream name on which this episode exists.
	// Format: media_name (media_name)
	Media() MediaName
	// Stream name on which this episode exists.
	// Format: media_name (media_name)
	SetMedia(MediaName) EpisodeGeneric
	// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
	// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
	// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
	// sort as by `opened_at`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	OpenedAt() UtcMs
	// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
	// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
	// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
	// sort as by `opened_at`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetOpenedAt(UtcMs) EpisodeGeneric
	// This describes the way this episode was updated, whether via an inference node or an API.
	// In the case of an inference node, its hostname will be provided.
	Originator() EpisodeOriginator
	// This describes the way this episode was updated, whether via an inference node or an API.
	// In the case of an inference node, its hostname will be provided.
	SetOriginator(EpisodeOriginator) EpisodeGeneric
	// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Format: base64 (base64)
	Preview() *Base64
	// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Format: base64 (base64)
	SetPreview(Base64) EpisodeGeneric
	// The time when the preview of this episode is available.
	// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
	// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
	// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
	// for details.
	// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	PreviewTimestamp() *UtcMs
	// The time when the preview of this episode is available.
	// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
	// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
	// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
	// for details.
	// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetPreviewTimestamp(UtcMs) EpisodeGeneric
	// DVR recording status: fully recorded, not recorded, or partially recorded
	RecordingStatus() *string
	// DVR recording status: fully recorded, not recorded, or partially recorded
	SetRecordingStatus(string) EpisodeGeneric
	// This field can be used as indication of the fact that some system have checked and ensured that
	// this episode has really started at some time, that may differ from `opened_at`.
	// For example video analytics will use this field for the time when this episode was confirmed as confident.
	// May be not relevant for television systems.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	StartedAt() *UtcMs
	// This field can be used as indication of the fact that some system have checked and ensured that
	// this episode has really started at some time, that may differ from `opened_at`.
	// For example video analytics will use this field for the time when this episode was confirmed as confident.
	// May be not relevant for television systems.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetStartedAt(UtcMs) EpisodeGeneric
	// The time of last change of the episode.
	// System that processes episodes and can send them to other systems, MUST update this field
	// on any changes in this episode.
	// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
	// this `updated_at` can be used as a sort key for fetching fresh updates.
	// Consumer of the episodes can use `updated_at` in the following scenario:
	// * fetch all exisiting episodes from the source
	// * take biggest `updated_at` from this dataset, it will be T
	// * ask source for all episodes with `updated_at > T`
	// This algorithm can be used for fetching update stream from the source.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637098611e+12
	UpdatedAt() UtcMs
	// The time of last change of the episode.
	// System that processes episodes and can send them to other systems, MUST update this field
	// on any changes in this episode.
	// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
	// this `updated_at` can be used as a sort key for fetching fresh updates.
	// Consumer of the episodes can use `updated_at` in the following scenario:
	// * fetch all exisiting episodes from the source
	// * take biggest `updated_at` from this dataset, it will be T
	// * ask source for all episodes with `updated_at > T`
	// This algorithm can be used for fetching update stream from the source.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637098611e+12
	SetUpdatedAt(UtcMs) EpisodeGeneric
}

// Required: source
type EpisodeOriginator interface {
	// This field will provide hostname if the source is an inference node or motion detector.
	// Example: example.com
	Hostname() *string
	// This field will provide hostname if the source is an inference node or motion detector.
	// Example: example.com
	SetHostname(string) EpisodeOriginator
	Source() EpisodeOriginatorSource
	SetSource(EpisodeOriginatorSource) EpisodeOriginator
}

type EpisodesList interface {
	// The list of Episodes fetched according to the query parameters.
	Episodes() []Episode
	// The list of Episodes fetched according to the query parameters.
	SetEpisodes([]Episode) EpisodesList
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	EstimatedCount() *int
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	SetEstimatedCount(int) EpisodesList
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	Next() *string
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	SetNext(string) EpisodesList
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	Prev() *string
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	SetPrev(string) EpisodesList
	// An object with a list of different timings measured during this API call.
	Timing() any
	// An object with a list of different timings measured during this API call.
	SetTiming(any) EpisodesList
	// Collection returns the collection items
	Collection() []Episode
}

type Error interface {
	// an application-specific error code, expressed as a string value
	Code() *string
	// an application-specific error code, expressed as a string value
	SetCode(string) Error
	// a unique identifier for this particular occurrence of the problem
	ID() *string
	// a unique identifier for this particular occurrence of the problem
	SetID(string) Error
	// a meta object containing non-standard meta-information about the error.
	Meta() map[string]string
	// a meta object containing non-standard meta-information about the error.
	SetMeta(map[string]string) Error
	// an object containing references to the source of the error
	Source() ErrorSource
	// an object containing references to the source of the error
	SetSource(ErrorSource) Error
	// the HTTP status code applicable to this problem, expressed as a string value
	Status() *string
	// the HTTP status code applicable to this problem, expressed as a string value
	SetStatus(string) Error
	// a short, human-readable summary of the problem that SHOULD NOT change from
	// occurrence to occurrence of the problem, except for purposes of localization
	Title() *string
	// a short, human-readable summary of the problem that SHOULD NOT change from
	// occurrence to occurrence of the problem, except for purposes of localization
	SetTitle(string) Error
}

type ErrorResponse interface {
	// List of structured errors
	Errors() []Error
	// List of structured errors
	SetErrors([]Error) ErrorResponse
}

// an object containing references to the source of the error
type ErrorSource interface {
	// a string indicating which URI query parameter caused the error.
	Parameter() *string
	// a string indicating which URI query parameter caused the error.
	SetParameter(string) ErrorSource
	// a JSON Pointer [RFC6901] to the associated entity in the request document
	// [e.g. `"/data"` for a primary data object, or `"/data/attributes/title"` for a specific attribute].
	Pointer() *string
	// a JSON Pointer [RFC6901] to the associated entity in the request document
	// [e.g. `"/data"` for a primary data object, or `"/data/attributes/title"` for a specific attribute].
	SetPointer(string) ErrorSource
}

type EventDefault interface {
	// Event identifier.
	EventID() *int
	// Event identifier.
	SetEventID(int) EventDefault
	// Originator of event.
	// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
	// is configured as HTTP/HTTPS url.
	// Example: flussonic.host
	Server() *string
	// Originator of event.
	// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
	// is configured as HTTP/HTTPS url.
	// Example: flussonic.host
	SetServer(string) EventDefault
	// Unique identifier of the operation.
	// You can use this field to search for events related to same operation.
	// Value of this field is taken from the `X-Trace-Id` header.
	// If `X-Trace-Id` header is not set, it will be generated automatically.
	// Service will use the value of this field to make outgoing requests.
	// Format: uuid (uuid)
	// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
	TraceID() *UUID
	// Unique identifier of the operation.
	// You can use this field to search for events related to same operation.
	// Value of this field is taken from the `X-Trace-Id` header.
	// If `X-Trace-Id` header is not set, it will be generated automatically.
	// Service will use the value of this field to make outgoing requests.
	// Format: uuid (uuid)
	// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
	SetTraceID(UUID) EventDefault
	// The time of the event registration on the server.
	// Format: utc_ms (Unix timestamp in milliseconds)
	UtcMs() *UtcMs
	// The time of the event registration on the server.
	// Format: utc_ms (Unix timestamp in milliseconds)
	SetUtcMs(UtcMs) EventDefault
}

// Required: name, url
type EventSinkConfig interface {
	// If specified, only the events that match **every** filter in the filter set will not be be passed to the event sink target.
	// That is, if even one of the conditions is not satisfied, an event will be processed.
	// Each filter (condition) has several possible values. For an event to satisfy the condition,
	// an event should match **any** of the specified values, not all of them.
	// Examples: [map[event:[stream_stopped, stream_started, source_*]]]
	Except() []map[string][]string
	// If specified, only the events that match **every** filter in the filter set will not be be passed to the event sink target.
	// That is, if even one of the conditions is not satisfied, an event will be processed.
	// Each filter (condition) has several possible values. For an event to satisfy the condition,
	// an event should match **any** of the specified values, not all of them.
	// Examples: [map[event:[stream_stopped, stream_started, source_*]]]
	SetExcept([]map[string][]string) EventSinkConfig
	// Some additional options.
	Extra() map[string]string
	// Some additional options.
	SetExtra(map[string]string) EventSinkConfig
	// Specify logging level for this sink. Anything more verbose than it will not get into this sink.
	Level() *Loglevel
	// Specify logging level for this sink. Anything more verbose than it will not get into this sink.
	SetLevel(Loglevel) EventSinkConfig
	// Maximal number of log files with events (JSON or text) that can be stored on a disk.
	// When this limit is reached, log rotation is performed: the oldest files will be overridden by later data.
	// Example: 100
	MaxDepth() *int
	// Maximal number of log files with events (JSON or text) that can be stored on a disk.
	// When this limit is reached, log rotation is performed: the oldest files will be overridden by later data.
	// Example: 100
	SetMaxDepth(int) EventSinkConfig
	// Maximum size of a log file.
	// When this limit is reached, log rotation is performed: the oldest events will be overridden by later data.
	// Format: bytes (bytes)
	// Example: 10000
	MaxSize() *Bytes
	// Maximum size of a log file.
	// When this limit is reached, log rotation is performed: the oldest events will be overridden by later data.
	// Format: bytes (bytes)
	// Example: 10000
	SetMaxSize(Bytes) EventSinkConfig
	// Globally unique event sink name.
	// Format: event_sink_name (event_sink_name)
	// Example: my_json_sink
	Name() EventSinkName
	// Globally unique event sink name.
	// Format: event_sink_name (event_sink_name)
	// Example: my_json_sink
	SetName(EventSinkName) EventSinkConfig
	// If specified, only the events that match **every** filter in the filter set will be passed to the event sink target.
	// That is, if even one of the conditions is not satisfied, an event will **not** be processed.
	// Each filter (condition) has several possible values. For an event to satisfy the condition,
	// an event should match **any** of the specified values, not all of them.
	// Examples: [map[event:[listener_start], group:[system_overloaded]]]
	Only() []map[string][]string
	// If specified, only the events that match **every** filter in the filter set will be passed to the event sink target.
	// That is, if even one of the conditions is not satisfied, an event will **not** be processed.
	// Each filter (condition) has several possible values. For an event to satisfy the condition,
	// an event should match **any** of the specified values, not all of them.
	// Examples: [map[event:[listener_start], group:[system_overloaded]]]
	SetOnly([]map[string][]string) EventSinkConfig
	// If an error occurs (`HTTP 500` or any other error), then *Flussonic* will try to buffer events and send them later.
	// The option defines the **number** of events to keep in memory for further delivery.
	// The default value is `unlimited`.
	// Example: 1000
	ResendLimit() *int
	// If an error occurs (`HTTP 500` or any other error), then *Flussonic* will try to buffer events and send them later.
	// The option defines the **number** of events to keep in memory for further delivery.
	// The default value is `unlimited`.
	// Example: 1000
	SetResendLimit(int) EventSinkConfig
	// How often *Flussonic* will try to resend non-confirmed events to the handler (in seconds).
	// Example: 10
	ResendTimeout() *int
	// How often *Flussonic* will try to resend non-confirmed events to the handler (in seconds).
	// Example: 10
	SetResendTimeout(int) EventSinkConfig
	// The delay (in seconds) before sending an event to the sink after saving it into the buffer.
	// This parameter allows to lower frequency of sending events.
	// If there are more than 100 events in the buffer, all of them will be sent to the sink without any delay.
	// Format: seconds (seconds)
	// Example: 1
	ThrottleDelay() *Seconds
	// The delay (in seconds) before sending an event to the sink after saving it into the buffer.
	// This parameter allows to lower frequency of sending events.
	// If there are more than 100 events in the buffer, all of them will be sent to the sink without any delay.
	// Format: seconds (seconds)
	// Example: 1
	SetThrottleDelay(Seconds) EventSinkConfig
	// Path where events are sent.
	// * For event handler, it is the URL of an HTTP handler or the path to a lua script:  `http://URL`, `https://URL`, or `path_to_lua_script.lua`.
	// * For event logging, it is the path to a log file (human-readable text file or JSON): `log://path_to_log_file.log` or `jsonlog://path_to_log_file.json`.
	// Pattern: ^(log|jsonlog|http|https)://.+$|^pid://<[0-9]+\.[0-9]+\.[0-9]+>$
	// Example: jsonlog:///var/log/events-json.log
	URL() string
	// Path where events are sent.
	// * For event handler, it is the URL of an HTTP handler or the path to a lua script:  `http://URL`, `https://URL`, or `path_to_lua_script.lua`.
	// * For event logging, it is the path to a log file (human-readable text file or JSON): `log://path_to_log_file.log` or `jsonlog://path_to_log_file.json`.
	// Pattern: ^(log|jsonlog|http|https)://.+$|^pid://<[0-9]+\.[0-9]+\.[0-9]+>$
	// Example: jsonlog:///var/log/events-json.log
	SetURL(string) EventSinkConfig
}

// Required: opened_at, updated_at
type ExternalEpisode interface {
	// The time when this episode was closed.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	ClosedAt() *UtcMs
	// The time when this episode was closed.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	SetClosedAt(UtcMs) ExternalEpisode
	// The time when this episode was created.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	OpenedAt() UtcMs
	// The time when this episode was created.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	SetOpenedAt(UtcMs) ExternalEpisode
	// The time of last detection associated with this episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637098611e+12
	UpdatedAt() UtcMs
	// The time of last detection associated with this episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637098611e+12
	SetUpdatedAt(UtcMs) ExternalEpisode
}

type ExternalEpisodesList interface {
	// The list of Episodes fetched according to the query parameters.
	Episodes() []ExternalEpisode
	// The list of Episodes fetched according to the query parameters.
	SetEpisodes([]ExternalEpisode) ExternalEpisodesList
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	EstimatedCount() *int
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	SetEstimatedCount(int) ExternalEpisodesList
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	Next() *string
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	SetNext(string) ExternalEpisodesList
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	Prev() *string
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	SetPrev(string) ExternalEpisodesList
	// An object with a list of different timings measured during this API call.
	Timing() any
	// An object with a list of different timings measured during this API call.
	SetTiming(any) ExternalEpisodesList
	// Collection returns the collection items
	Collection() []ExternalEpisode
}

type ForwardPortsConfig interface {
	// The handler name.
	Handler() *string
	// The handler name.
	SetHandler(string) ForwardPortsConfig
	// The handler options.
	Options() any
	// The handler options.
	SetOptions(any) ForwardPortsConfig
}

type GenrefStatus interface {
	// If true genref port is a physical port, else genref port is a virtual port (internal clock-lock feature).
	External() *bool
	// If true genref port is a physical port, else genref port is a virtual port (internal clock-lock feature).
	SetExternal(bool) GenrefStatus
	// Detected genref input port number.
	Port() *int
	// Detected genref input port number.
	SetPort(int) GenrefStatus
	// Configured reference signal video standard.
	Vstd() *string
	// Configured reference signal video standard.
	SetVstd(string) GenrefStatus
	// Detected (actual) reference signal video standard.
	VstdDetected() *string
	// Detected (actual) reference signal video standard.
	SetVstdDetected(string) GenrefStatus
}

// Here are counters for h264/h265 decoder.
type H26xDecoderCounters interface {
	// Number of NAL units, which `forbidden_zero_bit` is set to one.
	DiscardedBrokenNalCount() *int
	// Number of NAL units, which `forbidden_zero_bit` is set to one.
	SetDiscardedBrokenNalCount(int) H26xDecoderCounters
	// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
	// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
	// This counter shows number of discarded `Fragmentation Units`
	DiscardedFuCount() *int
	// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
	// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
	// This counter shows number of discarded `Fragmentation Units`
	SetDiscardedFuCount(int) H26xDecoderCounters
	// Number of discarded NAL units.
	DiscardedNalCount() *int
	// Number of discarded NAL units.
	SetDiscardedNalCount(int) H26xDecoderCounters
	// Number of NAL units, which type is not allowed in `non-interleaved packetization mode`.
	DiscardedNotAllowedNalCount() *int
	// Number of NAL units, which type is not allowed in `non-interleaved packetization mode`.
	SetDiscardedNotAllowedNalCount(int) H26xDecoderCounters
	// Number of discarded `SEI` NAL units
	DiscardedSeiCount() *int
	// Number of discarded `SEI` NAL units
	SetDiscardedSeiCount(int) H26xDecoderCounters
	// There is workaround to not interrupt `FU` sequence if `end-FU` followed by `middle-FU`.
	// This counter shows how many time the workaround was applied.
	FuEndThenMiddleWorkaroundCount() *int
	// There is workaround to not interrupt `FU` sequence if `end-FU` followed by `middle-FU`.
	// This counter shows how many time the workaround was applied.
	SetFuEndThenMiddleWorkaroundCount(int) H26xDecoderCounters
	// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
	// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
	// This counter shows number of `Fragmentation Units` which `Start bit` and `End bit` are set to one in the same `FU` header
	FuHasBothStartEndBitsCount() *int
	// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
	// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
	// This counter shows number of `Fragmentation Units` which `Start bit` and `End bit` are set to one in the same `FU` header
	SetFuHasBothStartEndBitsCount(int) H26xDecoderCounters
	// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
	// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
	// `Fragmentation Units` pattern must have a `Start FU`, `End FU` and could have `FUs` between these ones.
	// This counter indicates how many times pattern was broken.
	FuPatternIsBrokenCount() *int
	// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
	// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
	// `Fragmentation Units` pattern must have a `Start FU`, `End FU` and could have `FUs` between these ones.
	// This counter indicates how many times pattern was broken.
	SetFuPatternIsBrokenCount(int) H26xDecoderCounters
	// NAL deframentation could be interrupted by unexpected NAL or broken/incomplete packet.
	// If NAL deframentation is interrupted then incomplete fragment of NAL is not discarded and used in decoding process.
	// This counter indicates how many incomplete NALs were used.
	IncompleteNalCount() *int
	// NAL deframentation could be interrupted by unexpected NAL or broken/incomplete packet.
	// If NAL deframentation is interrupted then incomplete fragment of NAL is not discarded and used in decoding process.
	// This counter indicates how many incomplete NALs were used.
	SetIncompleteNalCount(int) H26xDecoderCounters
	// Number of `SEI` NAL units with bad payload
	InvalidSeiPayloadCount() *int
	// Number of `SEI` NAL units with bad payload
	SetInvalidSeiPayloadCount(int) H26xDecoderCounters
	// Number of `SEI` NAL units with invalid size
	InvalidSeiSizeCount() *int
	// Number of `SEI` NAL units with invalid size
	SetInvalidSeiSizeCount(int) H26xDecoderCounters
	// Number of `SEI` NAL units with invalid type
	InvalidSeiTypeCount() *int
	// Number of `SEI` NAL units with invalid type
	SetInvalidSeiTypeCount(int) H26xDecoderCounters
	// How many NAL `AGGREGATION` units handled by this decoder.
	NalAggregationCount() *int
	// How many NAL `AGGREGATION` units handled by this decoder.
	SetNalAggregationCount(int) H26xDecoderCounters
	// How many NAL `AUD` units handled by this decoder.
	NalAudCount() *int
	// How many NAL `AUD` units handled by this decoder.
	SetNalAudCount(int) H26xDecoderCounters
	// How many NAL units handled by this decoder.
	NalCount() *int
	// How many NAL units handled by this decoder.
	SetNalCount(int) H26xDecoderCounters
	// How many NAL `FILLER` units handled by this decoder.
	NalFillerCount() *int
	// How many NAL `FILLER` units handled by this decoder.
	SetNalFillerCount(int) H26xDecoderCounters
	// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
	// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
	// This counter shows how many `Fragmentation Units` handled by this decoder.
	NalFuCount() *int
	// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
	// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
	// This counter shows how many `Fragmentation Units` handled by this decoder.
	SetNalFuCount(int) H26xDecoderCounters
	// How many NAL `IDR` units handled by this decoder.
	NalIdrCount() *int
	// How many NAL `IDR` units handled by this decoder.
	SetNalIdrCount(int) H26xDecoderCounters
	// How many other NAL units handled by this decoder.
	NalOtherCount() *int
	// How many other NAL units handled by this decoder.
	SetNalOtherCount(int) H26xDecoderCounters
	// How many NAL `PPS` units handled by this decoder.
	NalPpsCount() *int
	// How many NAL `PPS` units handled by this decoder.
	SetNalPpsCount(int) H26xDecoderCounters
	// How many NAL `SEI` units handled by this decoder.
	NalSeiCount() *int
	// How many NAL `SEI` units handled by this decoder.
	SetNalSeiCount(int) H26xDecoderCounters
	// How many NAL `SINGLE` units handled by this decoder.
	NalSingleCount() *int
	// How many NAL `SINGLE` units handled by this decoder.
	SetNalSingleCount(int) H26xDecoderCounters
	// How many NAL `SLICE` units handled by this decoder.
	NalSliceCount() *int
	// How many NAL `SLICE` units handled by this decoder.
	SetNalSliceCount(int) H26xDecoderCounters
	// How many NAL `SPS` units handled by this decoder.
	NalSpsCount() *int
	// How many NAL `SPS` units handled by this decoder.
	SetNalSpsCount(int) H26xDecoderCounters
	// How many NAL `STAP_A` units handled by this decoder.
	NalStapACount() *int
	// How many NAL `STAP_A` units handled by this decoder.
	SetNalStapACount(int) H26xDecoderCounters
	// How many NAL `VPS` units handled by this decoder.
	NalVpsCount() *int
	// How many NAL `VPS` units handled by this decoder.
	SetNalVpsCount(int) H26xDecoderCounters
}

// Required: prefix, url
type HTTPProxyConfig interface {
	// If this flag is set, then streamer will redirect from "/" to this proxy configuration.
	Mainpage() *bool
	// If this flag is set, then streamer will redirect from "/" to this proxy configuration.
	SetMainpage(bool) HTTPProxyConfig
	// HTTP prefix that will be intercepted by this http proxy configuration
	// Format: media_name (media_name)
	Prefix() MediaName
	// HTTP prefix that will be intercepted by this http proxy configuration
	// Format: media_name (media_name)
	SetPrefix(MediaName) HTTPProxyConfig
	// The runtime statistics about http proxy
	Stats() HTTPProxyStats
	// The runtime statistics about http proxy
	SetStats(HTTPProxyStats) HTTPProxyConfig
	// Upstream url
	// Format: url (url)
	URL() URL
	// Upstream url
	// Format: url (url)
	SetURL(URL) HTTPProxyConfig
}

type HTTPProxyStats interface {
	// Number of requests with HTTP code 1xx (e.g. protocol upgrades)
	// Example: 1000
	HTTP100() *int
	// Number of requests with HTTP code 1xx (e.g. protocol upgrades)
	// Example: 1000
	SetHTTP100(int) HTTPProxyStats
	// Number of requests with HTTP code 2xx
	// Example: 1000
	HTTP200() *int
	// Number of requests with HTTP code 2xx
	// Example: 1000
	SetHTTP200(int) HTTPProxyStats
	// Number of requests with HTTP code 3xx
	// Example: 10
	HTTP300() *int
	// Number of requests with HTTP code 3xx
	// Example: 10
	SetHTTP300(int) HTTPProxyStats
	// Number of requests with HTTP code 4xx
	// Example: 10
	HTTP400() *int
	// Number of requests with HTTP code 4xx
	// Example: 10
	SetHTTP400(int) HTTPProxyStats
	// Number of requests with HTTP code 5xx
	// Example: 10
	HTTP500() *int
	// Number of requests with HTTP code 5xx
	// Example: 10
	SetHTTP500(int) HTTPProxyStats
	// Total number of requests with protocol upgrade (e.g. websocket)
	// Example: 1000
	ProtocolUpgrades() *int
	// Total number of requests with protocol upgrade (e.g. websocket)
	// Example: 1000
	SetProtocolUpgrades(int) HTTPProxyStats
	// Number of requests with error on proxy itself
	// Example: 10
	ProxyError() *int
	// Number of requests with error on proxy itself
	// Example: 10
	SetProxyError(int) HTTPProxyStats
	// Number of requests with connection errors - econnrefused, etc
	// Example: 10
	ProxyErrorConnection() *int
	// Number of requests with connection errors - econnrefused, etc
	// Example: 10
	SetProxyErrorConnection(int) HTTPProxyStats
	// Total number of requests this prefix received
	// Example: 1000
	Requests() *int
	// Total number of requests this prefix received
	// Example: 1000
	SetRequests(int) HTTPProxyStats
	// Number of API calls that took more than 500ms and less than 1s
	// Example: 2
	Time1000Ms() *int
	// Number of API calls that took more than 500ms and less than 1s
	// Example: 2
	SetTime1000Ms(int) HTTPProxyStats
	// Number of API calls that took less than 100ms
	// Example: 10
	Time100Ms() *int
	// Number of API calls that took less than 100ms
	// Example: 10
	SetTime100Ms(int) HTTPProxyStats
	// Number of API calls that took more than 1s and less than 5s
	// Example: 2
	Time5000Ms() *int
	// Number of API calls that took more than 1s and less than 5s
	// Example: 2
	SetTime5000Ms(int) HTTPProxyStats
	// Number of API calls that took more than 100ms and less than 500ms
	// Example: 5
	Time500Ms() *int
	// Number of API calls that took more than 100ms and less than 500ms
	// Example: 5
	SetTime500Ms(int) HTTPProxyStats
	// Number of API calls that took more than 5s
	// Example: 1
	TimeLongms() *int
	// Number of API calls that took more than 5s
	// Example: 1
	SetTimeLongms(int) HTTPProxyStats
}

// Agent counters
type InputAgentCounters interface {
	// These errors indicate that the agent does not have enough buffer size to handle outgoing traffic.
	ErrorsBufferOverrun() *int
	// These errors indicate that the agent does not have enough buffer size to handle outgoing traffic.
	SetErrorsBufferOverrun(int) InputAgentCounters
	// The agent was unable to open the requested connection. These errors may indicate problems opening the TCP socket on the agent or the remote host is unreacheable.
	ErrorsConnFailed() *int
	// The agent was unable to open the requested connection. These errors may indicate problems opening the TCP socket on the agent or the remote host is unreacheable.
	SetErrorsConnFailed(int) InputAgentCounters
	// These errors indicate that the agent is receiving invalid requests.
	ErrorsInvalidRequest() *int
	// These errors indicate that the agent is receiving invalid requests.
	SetErrorsInvalidRequest(int) InputAgentCounters
	// These errors indicate that the agent does not have enough memory to establish a connection to the remote host.
	ErrorsOutOfMemory() *int
	// These errors indicate that the agent does not have enough memory to establish a connection to the remote host.
	SetErrorsOutOfMemory(int) InputAgentCounters
	// Unknown errors counter.
	ErrorsUnknown() *int
	// Unknown errors counter.
	SetErrorsUnknown(int) InputAgentCounters
}

// Here are grouped different counters for sessions: generic and errors
type InputCounters interface {
	// How many Ad markers passed to this stream from the inputs.
	AdSplicesIngested() *int
	// How many Ad markers passed to this stream from the inputs.
	SetAdSplicesIngested(int) InputCounters
	// How many Ad markers inserted to this stream by user.
	AdSplicesInserted() *int
	// How many Ad markers inserted to this stream by user.
	SetAdSplicesInserted(int) InputCounters
	Agent() InputAgentCounters
	SetAgent(InputAgentCounters) InputCounters
	// Number of bytes received by this stream from live sources.
	// It will be counted before transcoding and will sum all inputs working together.
	// Format: bytes (bytes)
	Bytes() *Bytes
	// Number of bytes received by this stream from live sources.
	// It will be counted before transcoding and will sum all inputs working together.
	// Format: bytes (bytes)
	SetBytes(Bytes) InputCounters
	// Number of bytes received by this stream when downloading from remote DVR.
	// Format: bytes (bytes)
	BytesDvr() *Bytes
	// Number of bytes received by this stream when downloading from remote DVR.
	// Format: bytes (bytes)
	SetBytesDvr(Bytes) InputCounters
	// Sum of all other specific errors in the last minute
	// Example: 0
	ErrorRate() *int
	// Sum of all other specific errors in the last minute
	// Example: 0
	SetErrorRate(int) InputCounters
	// Sum of all other specific errors. Can be used for triggering alert on any error
	// Example: 0
	Errors() *int
	// Sum of all other specific errors. Can be used for triggering alert on any error
	// Example: 0
	SetErrors(int) InputCounters
	// How many times we've got 403 (eaccess).
	Errors403() *int
	// How many times we've got 403 (eaccess).
	SetErrors403(int) InputCounters
	// How many times we've got 404 (enoent).
	Errors404() *int
	// How many times we've got 404 (enoent).
	SetErrors404(int) InputCounters
	// How many times we've got 500 (backend error).
	Errors500() *int
	// How many times we've got 500 (backend error).
	SetErrors500(int) InputCounters
	// Demultiplexing was done right, but content is broken.
	ErrorsBrokenPayload() *int
	// Demultiplexing was done right, but content is broken.
	SetErrorsBrokenPayload(int) InputCounters
	// How many times input was restarted due to internal crash.
	// This may happen due to unhandled input.
	ErrorsCrashed() *int
	// How many times input was restarted due to internal crash.
	// This may happen due to unhandled input.
	SetErrorsCrashed(int) InputCounters
	// Decoder reset count due to abnormal DTS change. Can happen in MPEG-TS, RTP.
	ErrorsDecoderReset() *int
	// Decoder reset count due to abnormal DTS change. Can happen in MPEG-TS, RTP.
	SetErrorsDecoderReset(int) InputCounters
	// This can be used as a `TS_sync_loss` - how many times MPEG-TS sync was lost.
	// Also this counter refers to RTSP desync, when camera starts dropping TCP data and
	// we have to find packet boundaries.
	// Here we write count of such resynchronizations.
	ErrorsDesync() *int
	// This can be used as a `TS_sync_loss` - how many times MPEG-TS sync was lost.
	// Also this counter refers to RTSP desync, when camera starts dropping TCP data and
	// we have to find packet boundaries.
	// Here we write count of such resynchronizations.
	SetErrorsDesync(int) InputCounters
	// Dropped frames count due timestamp adjustment.
	ErrorsDroppedFrames() *int
	// Dropped frames count due timestamp adjustment.
	SetErrorsDroppedFrames(int) InputCounters
	// RTP, MPEG-TS or other protocols have enough information to tell how many packets were lost
	ErrorsLostPackets() *int
	// RTP, MPEG-TS or other protocols have enough information to tell how many packets were lost
	SetErrorsLostPackets(int) InputCounters
	// how many times PAT was missing during 0,5 seconds or pid 0 misses PAT
	// `PAT_error`
	ErrorsTSPat() *int
	// how many times PAT was missing during 0,5 seconds or pid 0 misses PAT
	// `PAT_error`
	SetErrorsTSPat(int) InputCounters
	// How many times have received PAT that was missing required service (program)
	ErrorsTSServiceLost() *int
	// How many times have received PAT that was missing required service (program)
	SetErrorsTSServiceLost(int) InputCounters
	// Number of connection restarts to fix ts_stuck issue. Can happen in RTSP.
	ErrorsTSStuckRestarts() *int
	// Number of connection restarts to fix ts_stuck issue. Can happen in RTSP.
	SetErrorsTSStuckRestarts(int) InputCounters
	// Number of frames passed to this stream from the inputs.
	Frames() *int
	// Number of frames passed to this stream from the inputs.
	SetFrames(int) InputCounters
	// Aggregated: how many times this stream has switched between different inputs.
	// Individual input: number of times switched to this input.
	InputSwitches() *int
	// Aggregated: how many times this stream has switched between different inputs.
	// Individual input: number of times switched to this input.
	SetInputSwitches(int) InputCounters
	// Number of secondary inputs that have some problems.
	// Example: 0
	InvalidSecondaryInputs() *int
	// Number of secondary inputs that have some problems.
	// Example: 0
	SetInvalidSecondaryInputs(int) InputCounters
	// Indicates, how often does media_info changes
	MediaInfoChanges() *int
	// Indicates, how often does media_info changes
	SetMediaInfoChanges(int) InputCounters
	MotionDetector() InputMotionDetectorCounters
	SetMotionDetector(InputMotionDetectorCounters) InputCounters
	// How many seconds has this stream had no frames.
	// Format: seconds (seconds)
	NumSecNoData() *Seconds
	// How many seconds has this stream had no frames.
	// Format: seconds (seconds)
	SetNumSecNoData(Seconds) InputCounters
	// How many seconds has this stream played from primary input.
	// Format: seconds (seconds)
	NumSecOnPrimaryInput() *Seconds
	// How many seconds has this stream played from primary input.
	// Format: seconds (seconds)
	SetNumSecOnPrimaryInput(Seconds) InputCounters
	// How many seconds has this stream played from secondary inputs.
	// Format: seconds (seconds)
	NumSecOnSecondaryInput() *Seconds
	// How many seconds has this stream played from secondary inputs.
	// Format: seconds (seconds)
	SetNumSecOnSecondaryInput(Seconds) InputCounters
	// Per pid statistics calculated for MPEG-TS input
	Pids() []InputPidCounters
	// Per pid statistics calculated for MPEG-TS input
	SetPids([]InputPidCounters) InputCounters
	// Source may send frames not in the order they should be played. It will be catched and reordered.
	// This counter indicates how many times did it happened.
	ReorderCount() *int
	// Source may send frames not in the order they should be played. It will be catched and reordered.
	// This counter indicates how many times did it happened.
	SetReorderCount(int) InputCounters
	// Source may send frames timestamps faster or slower than realtime.
	// Live stream will catch it and resync. This counter indicates how many times did it happened.
	ResyncCountDrift() *int
	// Source may send frames timestamps faster or slower than realtime.
	// Live stream will catch it and resync. This counter indicates how many times did it happened.
	SetResyncCountDrift(int) InputCounters
	// Source may change timestamps without any signalling. This counter indicates how bad is the source
	ResyncCountJump() *int
	// Source may change timestamps without any signalling. This counter indicates how bad is the source
	SetResyncCountJump(int) InputCounters
	// Stream timestamps are synchronized with real time. This counter tells, how many times
	// it was syncronized after source reconnect.
	ResyncCountNormal() *int
	// Stream timestamps are synchronized with real time. This counter tells, how many times
	// it was syncronized after source reconnect.
	SetResyncCountNormal(int) InputCounters
	// How many times has this stream retried to connect to source
	Retries() *int
	// How many times has this stream retried to connect to source
	SetRetries(int) InputCounters
	// Per channel statistics calculated for RTP input
	RTPChannels() []InputRTPCounters
	// Per channel statistics calculated for RTP input
	SetRTPChannels([]InputRTPCounters) InputCounters
	Sdi() InputSdiCounters
	SetSdi(InputSdiCounters) InputCounters
	Srt() InputSrtCounters
	SetSrt(InputSrtCounters) InputCounters
	// Number of secondary inputs that have no problems.
	// Example: 2
	ValidSecondaryInputs() *int
	// Number of secondary inputs that have no problems.
	// Example: 2
	SetValidSecondaryInputs(int) InputCounters
}

type InputMediaInfo interface {
	// The program ID for MPEG TS streams.
	// Example: 110
	ProgramID() *int
	// The program ID for MPEG TS streams.
	// Example: 110
	SetProgramID(int) InputMediaInfo
	// The media provider of this content.
	// Example: Netflix
	Provider() *string
	// The media provider of this content.
	// Example: Netflix
	SetProvider(string) InputMediaInfo
	// The identifier of the transport stream for MPEG TS streams.
	// Example: 253
	StreamID() *int
	// The identifier of the transport stream for MPEG TS streams.
	// Example: 253
	SetStreamID(int) InputMediaInfo
	// Human-readable title of the media.
	// Example: Bunny
	Title() *string
	// Human-readable title of the media.
	// Example: Bunny
	SetTitle(string) InputMediaInfo
	// Just like a regular `track_info`, but with matching rules,
	// that allow to select which input track must be mapped to output
	Tracks() []InputTrackInfo
	// Just like a regular `track_info`, but with matching rules,
	// that allow to select which input track must be mapped to output
	SetTracks([]InputTrackInfo) InputMediaInfo
}

// Specific counters to get insights on current state of getting events from cameras.
// Designed to be used by analyzers, monitoring and alerting tools
type InputMotionDetectorCounters interface {
	// Number of collected episodes.
	EpisodesCount() *int
	// Number of collected episodes.
	SetEpisodesCount(int) InputMotionDetectorCounters
	// Number of responses with broken content.
	ErrorsBrokenPayload() *int
	// Number of responses with broken content.
	SetErrorsBrokenPayload(int) InputMotionDetectorCounters
	// `ONVIF Event Handling Test Specification` says that valid values for `CurrentTime` and `TerminationTime` are
	// `TerminationTime >= CurrentTime + InitialTerminationTime`.
	// How many responses did not met the condition.
	ErrorsIncorrectTimeValuesCount() *int
	// `ONVIF Event Handling Test Specification` says that valid values for `CurrentTime` and `TerminationTime` are
	// `TerminationTime >= CurrentTime + InitialTerminationTime`.
	// How many responses did not met the condition.
	SetErrorsIncorrectTimeValuesCount(int) InputMotionDetectorCounters
	// Number of failed request attempts because of no agent connected.
	ErrorsNoAgentConnected() *int
	// Number of failed request attempts because of no agent connected.
	SetErrorsNoAgentConnected(int) InputMotionDetectorCounters
	// Number of attempts to request disabled or unsupported ONVIF service
	ErrorsNoServiceCount() *int
	// Number of attempts to request disabled or unsupported ONVIF service
	SetErrorsNoServiceCount(int) InputMotionDetectorCounters
	// Number of not authorized requests
	ErrorsNotAuthorizedCount() *int
	// Number of not authorized requests
	SetErrorsNotAuthorizedCount(int) InputMotionDetectorCounters
	// Number of failed requests because of bad url or network issues.
	ErrorsURLUnreachableCount() *int
	// Number of failed requests because of bad url or network issues.
	SetErrorsURLUnreachableCount(int) InputMotionDetectorCounters
	// Number of detected motions.
	MotionDetectedCount() *int
	// Number of detected motions.
	SetMotionDetectedCount(int) InputMotionDetectorCounters
}

// Required: pid
type InputPidCounters interface {
	// How many PES packets were started not from startcode
	BrokenPesCount() *int
	// How many PES packets were started not from startcode
	SetBrokenPesCount(int) InputPidCounters
	// How many bytes were discarded due to lack of PES startcode
	BrokenPesSum() *int
	// How many bytes were discarded due to lack of PES startcode
	SetBrokenPesSum(int) InputPidCounters
	// How many times PTS was less than PCR or previous PTS
	CorrectedBackwardPts() *int
	// How many times PTS was less than PCR or previous PTS
	SetCorrectedBackwardPts(int) InputPidCounters
	// Unhandled crashes inside mpegts decoding process due
	Crashed() *int
	// Unhandled crashes inside mpegts decoding process due
	SetCrashed(int) InputPidCounters
	// How many times was discarded too big ES buffer without making a frame of it
	DiscardedBufferCount() *int
	// How many times was discarded too big ES buffer without making a frame of it
	SetDiscardedBufferCount(int) InputPidCounters
	// How many bytes were lost due to discarding ES buffer
	DiscardedBufferSum() *int
	// How many bytes were lost due to discarding ES buffer
	SetDiscardedBufferSum(int) InputPidCounters
	// Time on this PID jumped back from reference PTS and it was not a roll over zero
	DtsGoesBackwards() *int
	// Time on this PID jumped back from reference PTS and it was not a roll over zero
	SetDtsGoesBackwards(int) InputPidCounters
	// Time on this PID jumped forward too far away from reference PTS
	DtsJumpForward() *int
	// Time on this PID jumped forward too far away from reference PTS
	SetDtsJumpForward(int) InputPidCounters
	// Packets without payload and adaptation field
	EmptyPackets() *int
	// Packets without payload and adaptation field
	SetEmptyPackets(int) InputPidCounters
	// Packets with adaptation field larger than packet size
	ErrorsAdaptationBroken() *int
	// Packets with adaptation field larger than packet size
	SetErrorsAdaptationBroken(int) InputPidCounters
	// How many times pid has been lost
	ErrorsPidLost() *int
	// How many times pid has been lost
	SetErrorsPidLost(int) InputPidCounters
	// how many MPEG-TS packets were received with non-contigious contiuity counters.
	// `Continuity_count_error`
	// Example: 0
	ErrorsTSCc() *int
	// how many MPEG-TS packets were received with non-contigious contiuity counters.
	// `Continuity_count_error`
	// Example: 0
	SetErrorsTSCc(int) InputPidCounters
	// how many times PMT was not received after 0,5 seconds
	// `PMT_error`
	ErrorsTSPmt() *int
	// how many times PMT was not received after 0,5 seconds
	// `PMT_error`
	SetErrorsTSPmt(int) InputPidCounters
	// How many times have received PSI entry with broken checksum
	// `CRC_error`
	ErrorsTSPsiChecksum() *int
	// How many times have received PSI entry with broken checksum
	// `CRC_error`
	SetErrorsTSPsiChecksum(int) InputPidCounters
	// Amount of scrambled TS packets
	ErrorsTSScrambled() *int
	// Amount of scrambled TS packets
	SetErrorsTSScrambled(int) InputPidCounters
	// How many MPEG-TS packets with Transport Error Indicator were received
	// `Transport_error`, 2.1
	ErrorsTSTei() *int
	// How many MPEG-TS packets with Transport Error Indicator were received
	// `Transport_error`, 2.1
	SetErrorsTSTei(int) InputPidCounters
	// How many H264(5) NAL fillers were seen in the input
	FillersCount() *int
	// How many H264(5) NAL fillers were seen in the input
	SetFillersCount(int) InputPidCounters
	// How many bytes were seen in NAL fillers
	FillersSum() *int
	// How many bytes were seen in NAL fillers
	SetFillersSum(int) InputPidCounters
	// Frame count on this pid
	Frames() *int
	// Frame count on this pid
	SetFrames(int) InputPidCounters
	// How many MPEG-TS packets with 188 bytes on this pid received
	Packets() *int
	// How many MPEG-TS packets with 188 bytes on this pid received
	SetPackets(int) InputPidCounters
	// How many PES packets were on the Padding streamId
	PaddingPesCount() *int
	// How many PES packets were on the Padding streamId
	SetPaddingPesCount(int) InputPidCounters
	// How many bytes were in PES packets on the Padding streamId
	PaddingPesSum() *int
	// How many bytes were in PES packets on the Padding streamId
	SetPaddingPesSum(int) InputPidCounters
	// If PTS is drifting away from PCR, it can be resynchronized with PCR. This is a resync count
	PcrResync() *int
	// If PTS is drifting away from PCR, it can be resynchronized with PCR. This is a resync count
	SetPcrResync(int) InputPidCounters
	// Related MPEG-TS pid with following problems
	Pid() int
	// Related MPEG-TS pid with following problems
	SetPid(int) InputPidCounters
	// What program does have this pid
	Pnr() *int
	// What program does have this pid
	SetPnr(int) InputPidCounters
	// In case of CC error last frame can be repeated. This is a count of repeated frames
	RepeatedFrames() *int
	// In case of CC error last frame can be repeated. This is a count of repeated frames
	SetRepeatedFrames(int) InputPidCounters
	// Jumps of timestamps inside a MPEG-TS stream
	TimeCorrections() *int
	// Jumps of timestamps inside a MPEG-TS stream
	SetTimeCorrections(int) InputPidCounters
	// Jump of the PTS was so big from previous, that had to flush all frames and restart parsing
	TooLargeDtsJump() *int
	// Jump of the PTS was so big from previous, that had to flush all frames and restart parsing
	SetTooLargeDtsJump(int) InputPidCounters
}

type InputRTPCounters interface {
	// How many bytes received for this channel
	Bytes() *int
	// How many bytes received for this channel
	SetBytes(int) InputRTPCounters
	// RTP channel number
	// Example: 0
	ChannelID() int
	// RTP channel number
	// Example: 0
	SetChannelID(int) InputRTPCounters
	// Content of the track transmitted in the channel
	// Example: video
	Content() *string
	// Content of the track transmitted in the channel
	// Example: video
	SetContent(string) InputRTPCounters
	// Number of NAL units, which `forbidden_zero_bit` is set to one.
	DiscardedBrokenNalCount() *int
	// Number of NAL units, which `forbidden_zero_bit` is set to one.
	SetDiscardedBrokenNalCount(int) InputRTPCounters
	// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
	// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
	// This counter shows number of discarded `Fragmentation Units`
	DiscardedFuCount() *int
	// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
	// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
	// This counter shows number of discarded `Fragmentation Units`
	SetDiscardedFuCount(int) InputRTPCounters
	// Number of discarded NAL units.
	DiscardedNalCount() *int
	// Number of discarded NAL units.
	SetDiscardedNalCount(int) InputRTPCounters
	// Number of NAL units, which type is not allowed in `non-interleaved packetization mode`.
	DiscardedNotAllowedNalCount() *int
	// Number of NAL units, which type is not allowed in `non-interleaved packetization mode`.
	SetDiscardedNotAllowedNalCount(int) InputRTPCounters
	// Number of discarded `SEI` NAL units
	DiscardedSeiCount() *int
	// Number of discarded `SEI` NAL units
	SetDiscardedSeiCount(int) InputRTPCounters
	// Demultiplexing was done right, but content is broken.
	ErrorsBrokenPayload() *int
	// Demultiplexing was done right, but content is broken.
	SetErrorsBrokenPayload(int) InputRTPCounters
	// Number of frames which dts is same as previous frame dts.
	ErrorsDtsStuck() *int
	// Number of frames which dts is same as previous frame dts.
	SetErrorsDtsStuck(int) InputRTPCounters
	// RTP have enough information to tell how many packets were lost
	ErrorsLostPackets() *int
	// RTP have enough information to tell how many packets were lost
	SetErrorsLostPackets(int) InputRTPCounters
	// How many frames received for this channel
	Frames() *int
	// How many frames received for this channel
	SetFrames(int) InputRTPCounters
	// There is workaround to not interrupt `FU` sequence if `end-FU` followed by `middle-FU`.
	// This counter shows how many time the workaround was applied.
	FuEndThenMiddleWorkaroundCount() *int
	// There is workaround to not interrupt `FU` sequence if `end-FU` followed by `middle-FU`.
	// This counter shows how many time the workaround was applied.
	SetFuEndThenMiddleWorkaroundCount(int) InputRTPCounters
	// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
	// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
	// This counter shows number of `Fragmentation Units` which `Start bit` and `End bit` are set to one in the same `FU` header
	FuHasBothStartEndBitsCount() *int
	// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
	// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
	// This counter shows number of `Fragmentation Units` which `Start bit` and `End bit` are set to one in the same `FU` header
	SetFuHasBothStartEndBitsCount(int) InputRTPCounters
	// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
	// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
	// `Fragmentation Units` pattern must have a `Start FU`, `End FU` and could have `FUs` between these ones.
	// This counter indicates how many times pattern was broken.
	FuPatternIsBrokenCount() *int
	// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
	// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
	// `Fragmentation Units` pattern must have a `Start FU`, `End FU` and could have `FUs` between these ones.
	// This counter indicates how many times pattern was broken.
	SetFuPatternIsBrokenCount(int) InputRTPCounters
	// NAL deframentation could be interrupted by unexpected NAL or broken/incomplete packet.
	// If NAL deframentation is interrupted then incomplete fragment of NAL is not discarded and used in decoding process.
	// This counter indicates how many incomplete NALs were used.
	IncompleteNalCount() *int
	// NAL deframentation could be interrupted by unexpected NAL or broken/incomplete packet.
	// If NAL deframentation is interrupted then incomplete fragment of NAL is not discarded and used in decoding process.
	// This counter indicates how many incomplete NALs were used.
	SetIncompleteNalCount(int) InputRTPCounters
	// Number of `SEI` NAL units with bad payload
	InvalidSeiPayloadCount() *int
	// Number of `SEI` NAL units with bad payload
	SetInvalidSeiPayloadCount(int) InputRTPCounters
	// Number of `SEI` NAL units with invalid size
	InvalidSeiSizeCount() *int
	// Number of `SEI` NAL units with invalid size
	SetInvalidSeiSizeCount(int) InputRTPCounters
	// Number of `SEI` NAL units with invalid type
	InvalidSeiTypeCount() *int
	// Number of `SEI` NAL units with invalid type
	SetInvalidSeiTypeCount(int) InputRTPCounters
	// Number of RTP packets which marker bit is set to one.
	MarkerPacketsCount() *int
	// Number of RTP packets which marker bit is set to one.
	SetMarkerPacketsCount(int) InputRTPCounters
	// How many NACK messages are sent for this channel
	NackCount() *int
	// How many NACK messages are sent for this channel
	SetNackCount(int) InputRTPCounters
	// How many NAL `AGGREGATION` units handled by this decoder.
	NalAggregationCount() *int
	// How many NAL `AGGREGATION` units handled by this decoder.
	SetNalAggregationCount(int) InputRTPCounters
	// How many NAL `AUD` units handled by this decoder.
	NalAudCount() *int
	// How many NAL `AUD` units handled by this decoder.
	SetNalAudCount(int) InputRTPCounters
	// How many NAL units handled by this decoder.
	NalCount() *int
	// How many NAL units handled by this decoder.
	SetNalCount(int) InputRTPCounters
	// How many NAL `FILLER` units handled by this decoder.
	NalFillerCount() *int
	// How many NAL `FILLER` units handled by this decoder.
	SetNalFillerCount(int) InputRTPCounters
	// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
	// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
	// This counter shows how many `Fragmentation Units` handled by this decoder.
	NalFuCount() *int
	// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
	// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
	// This counter shows how many `Fragmentation Units` handled by this decoder.
	SetNalFuCount(int) InputRTPCounters
	// How many NAL `IDR` units handled by this decoder.
	NalIdrCount() *int
	// How many NAL `IDR` units handled by this decoder.
	SetNalIdrCount(int) InputRTPCounters
	// How many other NAL units handled by this decoder.
	NalOtherCount() *int
	// How many other NAL units handled by this decoder.
	SetNalOtherCount(int) InputRTPCounters
	// How many NAL `PPS` units handled by this decoder.
	NalPpsCount() *int
	// How many NAL `PPS` units handled by this decoder.
	SetNalPpsCount(int) InputRTPCounters
	// How many NAL `SEI` units handled by this decoder.
	NalSeiCount() *int
	// How many NAL `SEI` units handled by this decoder.
	SetNalSeiCount(int) InputRTPCounters
	// How many NAL `SINGLE` units handled by this decoder.
	NalSingleCount() *int
	// How many NAL `SINGLE` units handled by this decoder.
	SetNalSingleCount(int) InputRTPCounters
	// How many NAL `SLICE` units handled by this decoder.
	NalSliceCount() *int
	// How many NAL `SLICE` units handled by this decoder.
	SetNalSliceCount(int) InputRTPCounters
	// How many NAL `SPS` units handled by this decoder.
	NalSpsCount() *int
	// How many NAL `SPS` units handled by this decoder.
	SetNalSpsCount(int) InputRTPCounters
	// How many NAL `STAP_A` units handled by this decoder.
	NalStapACount() *int
	// How many NAL `STAP_A` units handled by this decoder.
	SetNalStapACount(int) InputRTPCounters
	// How many NAL `VPS` units handled by this decoder.
	NalVpsCount() *int
	// How many NAL `VPS` units handled by this decoder.
	SetNalVpsCount(int) InputRTPCounters
	// If no marker bit packet is received after 400 RTP packets then decoder switches to `no_marker_mode` and
	// makes frame on each timecode change.
	// This flag shows if decoder works in `no_marker_mode`.
	NoMarkerModeFlag() *bool
	// If no marker bit packet is received after 400 RTP packets then decoder switches to `no_marker_mode` and
	// makes frame on each timecode change.
	// This flag shows if decoder works in `no_marker_mode`.
	SetNoMarkerModeFlag(bool) InputRTPCounters
	// Number of rtp packets rejected due to wrong payload type
	PtRejectCount() *int
	// Number of rtp packets rejected due to wrong payload type
	SetPtRejectCount(int) InputRTPCounters
	// Total size of rejected packets due to wrong payload type (pt_reject_count) rtp packets
	PtRejectSum() *int
	// Total size of rejected packets due to wrong payload type (pt_reject_count) rtp packets
	SetPtRejectSum(int) InputRTPCounters
	// How many RTCP packets received for this channel
	RtcpPackets() *int
	// How many RTCP packets received for this channel
	SetRtcpPackets(int) InputRTPCounters
	// How many RTP packets received for this channel
	RTPPackets() *int
	// How many RTP packets received for this channel
	SetRTPPackets(int) InputRTPCounters
	// Sender wallclock deviation from server time in ms. Positive value means that sender time is ahead of server time.
	SenderClockDeviation() *int
	// Sender wallclock deviation from server time in ms. Positive value means that sender time is ahead of server time.
	SetSenderClockDeviation(int) InputRTPCounters
	// Number of rtcp SR packets which `RTP timestamp` is equal to the previous rtcp SR packet `RTP timestamp`.
	SrTSStuck() *int
	// Number of rtcp SR packets which `RTP timestamp` is equal to the previous rtcp SR packet `RTP timestamp`.
	SetSrTSStuck(int) InputRTPCounters
	// Time on this channel is jumped back from reference wallclock.
	TSGoesBackwards() *int
	// Time on this channel is jumped back from reference wallclock.
	SetTSGoesBackwards(int) InputRTPCounters
	// Time on this channel is jumped forward from reference wallclock.
	TSJumpForward() *int
	// Time on this channel is jumped forward from reference wallclock.
	SetTSJumpForward(int) InputRTPCounters
	// https://datatracker.ietf.org/doc/html/rfc6184#section-4.1
	// access unit: A set of NAL units always containing a primary coded picture.  In addition to the primary coded
	// picture, an access unit may also contain one or more redundant coded pictures or other NAL units not containing
	// slices or slice data partitions of a coded picture.  The decoding of an access unit always results in a
	// decoded picture.
	// There is `marker bit` in RTP packet which is set for the very last packet of the access unit indicated by the RTP timestamp.
	// It is protocol violation if received RTP packet has the same timestamp as previous marker bit packet.
	// This counter is a number of RTP packets which `RTP timestamp` is equal to previous RTP marker bit packet.
	TSStuck() *int
	// https://datatracker.ietf.org/doc/html/rfc6184#section-4.1
	// access unit: A set of NAL units always containing a primary coded picture.  In addition to the primary coded
	// picture, an access unit may also contain one or more redundant coded pictures or other NAL units not containing
	// slices or slice data partitions of a coded picture.  The decoding of an access unit always results in a
	// decoded picture.
	// There is `marker bit` in RTP packet which is set for the very last packet of the access unit indicated by the RTP timestamp.
	// It is protocol violation if received RTP packet has the same timestamp as previous marker bit packet.
	// This counter is a number of RTP packets which `RTP timestamp` is equal to previous RTP marker bit packet.
	SetTSStuck(int) InputRTPCounters
}

// SDI,HDMI and other raw input counters
type InputSdiCounters interface {
	// Gauge of average duration of incoming frame calculated in real time.
	AvgRecvDuration() *int
	// Gauge of average duration of incoming frame calculated in real time.
	SetAvgRecvDuration(int) InputSdiCounters
	// Frames injected to fix client-side SDI stream drift.
	CompensatedFrames() *int
	// Frames injected to fix client-side SDI stream drift.
	SetCompensatedFrames(int) InputSdiCounters
	// Counter of configured audio sdi channels without samples or non valid.
	ErrorLostAudio() *int
	// Counter of configured audio sdi channels without samples or non valid.
	SetErrorLostAudio(int) InputSdiCounters
	// The frame was dropped due to too high CPU load.
	ErrorsCpuStall() *int
	// The frame was dropped due to too high CPU load.
	SetErrorsCpuStall(int) InputSdiCounters
	// Frame data is duplicated from previous frame because the input was too slow.
	ErrorsDuplicate() *int
	// Frame data is duplicated from previous frame because the input was too slow.
	SetErrorsDuplicate(int) InputSdiCounters
	// Frames dropped due to 'No signal'.
	ErrorsNoSignal() *int
	// Frames dropped due to 'No signal'.
	SetErrorsNoSignal(int) InputSdiCounters
	// Frame time is the same as the previous frame.
	ErrorsTSDuplicate() *int
	// Frame time is the same as the previous frame.
	SetErrorsTSDuplicate(int) InputSdiCounters
	// Gauge of maximum deviation from the estimated frame duration.
	PeakDurationDeviation() *int
	// Gauge of maximum deviation from the estimated frame duration.
	SetPeakDurationDeviation(int) InputSdiCounters
}

// SRT specific counters
type InputSrtCounters interface {
	// How many SRT packets were dropped by various reasons
	ErrorDroppedPackets() *int
	// How many SRT packets were dropped by various reasons
	SetErrorDroppedPackets(int) InputSrtCounters
	// How many SRT packets were lost
	ErrorLostPackets() *int
	// How many SRT packets were lost
	SetErrorLostPackets(int) InputSrtCounters
	// Receiver buffering delay
	Latency() *int
	// Receiver buffering delay
	SetLatency(int) InputSrtCounters
	// Total incoming SRT packets counter
	Packets() *int
	// Total incoming SRT packets counter
	SetPackets(int) InputSrtCounters
	// How many packets were retransmitted
	RetransmittedPackets() *int
	// How many packets were retransmitted
	SetRetransmittedPackets(int) InputSrtCounters
	// Round-trip time
	Rtt() *int
	// Round-trip time
	SetRtt(int) InputSrtCounters
}

type InputStats interface {
	// Whether this input is selected as active for the stream.
	// Example: true
	Active() *bool
	// Whether this input is selected as active for the stream.
	// Example: true
	SetActive(bool) InputStats
	// How many Ad markers passed to this stream from the inputs.
	AdSplicesIngested() *int
	// How many Ad markers passed to this stream from the inputs.
	SetAdSplicesIngested(int) InputStats
	// How many Ad markers inserted to this stream by user.
	AdSplicesInserted() *int
	// How many Ad markers inserted to this stream by user.
	SetAdSplicesInserted(int) InputStats
	Agent() InputAgentCounters
	SetAgent(InputAgentCounters) InputStats
	// Number of bytes received by this stream from live sources.
	// It will be counted before transcoding and will sum all inputs working together.
	// Format: bytes (bytes)
	Bytes() *Bytes
	// Number of bytes received by this stream from live sources.
	// It will be counted before transcoding and will sum all inputs working together.
	// Format: bytes (bytes)
	SetBytes(Bytes) InputStats
	// Number of bytes received by this stream when downloading from remote DVR.
	// Format: bytes (bytes)
	BytesDvr() *Bytes
	// Number of bytes received by this stream when downloading from remote DVR.
	// Format: bytes (bytes)
	SetBytesDvr(Bytes) InputStats
	// Indicates that the stream sources have different track sets, which may cause switching problems. The list of tracks to be compared is obtained only when the sources are checked or started, until then the stream is considered normal.
	DivergentInputs() *bool
	// Indicates that the stream sources have different track sets, which may cause switching problems. The list of tracks to be compared is obtained only when the sources are checked or started, until then the stream is considered normal.
	SetDivergentInputs(bool) InputStats
	// Information about DVR that this input has
	DvrInfo() DvrInfo
	// Information about DVR that this input has
	SetDvrInfo(DvrInfo) InputStats
	// Sum of all other specific errors in the last minute
	// Example: 0
	ErrorRate() *int
	// Sum of all other specific errors in the last minute
	// Example: 0
	SetErrorRate(int) InputStats
	// Sum of all other specific errors. Can be used for triggering alert on any error
	// Example: 0
	Errors() *int
	// Sum of all other specific errors. Can be used for triggering alert on any error
	// Example: 0
	SetErrors(int) InputStats
	// How many times we've got 403 (eaccess).
	Errors403() *int
	// How many times we've got 403 (eaccess).
	SetErrors403(int) InputStats
	// How many times we've got 404 (enoent).
	Errors404() *int
	// How many times we've got 404 (enoent).
	SetErrors404(int) InputStats
	// How many times we've got 500 (backend error).
	Errors500() *int
	// How many times we've got 500 (backend error).
	SetErrors500(int) InputStats
	// Demultiplexing was done right, but content is broken.
	ErrorsBrokenPayload() *int
	// Demultiplexing was done right, but content is broken.
	SetErrorsBrokenPayload(int) InputStats
	// How many times input was restarted due to internal crash.
	// This may happen due to unhandled input.
	ErrorsCrashed() *int
	// How many times input was restarted due to internal crash.
	// This may happen due to unhandled input.
	SetErrorsCrashed(int) InputStats
	// Decoder reset count due to abnormal DTS change. Can happen in MPEG-TS, RTP.
	ErrorsDecoderReset() *int
	// Decoder reset count due to abnormal DTS change. Can happen in MPEG-TS, RTP.
	SetErrorsDecoderReset(int) InputStats
	// This can be used as a `TS_sync_loss` - how many times MPEG-TS sync was lost.
	// Also this counter refers to RTSP desync, when camera starts dropping TCP data and
	// we have to find packet boundaries.
	// Here we write count of such resynchronizations.
	ErrorsDesync() *int
	// This can be used as a `TS_sync_loss` - how many times MPEG-TS sync was lost.
	// Also this counter refers to RTSP desync, when camera starts dropping TCP data and
	// we have to find packet boundaries.
	// Here we write count of such resynchronizations.
	SetErrorsDesync(int) InputStats
	// Dropped frames count due timestamp adjustment.
	ErrorsDroppedFrames() *int
	// Dropped frames count due timestamp adjustment.
	SetErrorsDroppedFrames(int) InputStats
	// RTP, MPEG-TS or other protocols have enough information to tell how many packets were lost
	ErrorsLostPackets() *int
	// RTP, MPEG-TS or other protocols have enough information to tell how many packets were lost
	SetErrorsLostPackets(int) InputStats
	// how many times PAT was missing during 0,5 seconds or pid 0 misses PAT
	// `PAT_error`
	ErrorsTSPat() *int
	// how many times PAT was missing during 0,5 seconds or pid 0 misses PAT
	// `PAT_error`
	SetErrorsTSPat(int) InputStats
	// How many times have received PAT that was missing required service (program)
	ErrorsTSServiceLost() *int
	// How many times have received PAT that was missing required service (program)
	SetErrorsTSServiceLost(int) InputStats
	// Number of connection restarts to fix ts_stuck issue. Can happen in RTSP.
	ErrorsTSStuckRestarts() *int
	// Number of connection restarts to fix ts_stuck issue. Can happen in RTSP.
	SetErrorsTSStuckRestarts(int) InputStats
	// Number of frames passed to this stream from the inputs.
	Frames() *int
	// Number of frames passed to this stream from the inputs.
	SetFrames(int) InputStats
	// Aggregated: how many times this stream has switched between different inputs.
	// Individual input: number of times switched to this input.
	InputSwitches() *int
	// Aggregated: how many times this stream has switched between different inputs.
	// Individual input: number of times switched to this input.
	SetInputSwitches(int) InputStats
	// Number of secondary inputs that have some problems.
	// Example: 0
	InvalidSecondaryInputs() *int
	// Number of secondary inputs that have some problems.
	// Example: 0
	SetInvalidSecondaryInputs(int) InputStats
	// IP address of the connected peer.
	// Example: 172.16.25.73
	IP() *string
	// IP address of the connected peer.
	// Example: 172.16.25.73
	SetIP(string) InputStats
	// Technical description of the input content.
	MediaInfo() MediaInfo
	// Technical description of the input content.
	SetMediaInfo(MediaInfo) InputStats
	// Indicates, how often does media_info changes
	MediaInfoChanges() *int
	// Indicates, how often does media_info changes
	SetMediaInfoChanges(int) InputStats
	MotionDetector() InputMotionDetectorCounters
	SetMotionDetector(InputMotionDetectorCounters) InputStats
	// How many seconds has this stream had no frames.
	// Format: seconds (seconds)
	NumSecNoData() *Seconds
	// How many seconds has this stream had no frames.
	// Format: seconds (seconds)
	SetNumSecNoData(Seconds) InputStats
	// How many seconds has this stream played from primary input.
	// Format: seconds (seconds)
	NumSecOnPrimaryInput() *Seconds
	// How many seconds has this stream played from primary input.
	// Format: seconds (seconds)
	SetNumSecOnPrimaryInput(Seconds) InputStats
	// How many seconds has this stream played from secondary inputs.
	// Format: seconds (seconds)
	NumSecOnSecondaryInput() *Seconds
	// How many seconds has this stream played from secondary inputs.
	// Format: seconds (seconds)
	SetNumSecOnSecondaryInput(Seconds) InputStats
	// The time when this session was created.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	OpenedAt() *UtcMs
	// The time when this session was created.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	SetOpenedAt(UtcMs) InputStats
	// Per pid statistics calculated for MPEG-TS input
	Pids() []InputPidCounters
	// Per pid statistics calculated for MPEG-TS input
	SetPids([]InputPidCounters) InputStats
	// Protocol used for the data transmission in the session.
	// Example: dash
	Proto() *Protocol
	// Protocol used for the data transmission in the session.
	// Example: dash
	SetProto(Protocol) InputStats
	// Source may send frames not in the order they should be played. It will be catched and reordered.
	// This counter indicates how many times did it happened.
	ReorderCount() *int
	// Source may send frames not in the order they should be played. It will be catched and reordered.
	// This counter indicates how many times did it happened.
	SetReorderCount(int) InputStats
	// Source may send frames timestamps faster or slower than realtime.
	// Live stream will catch it and resync. This counter indicates how many times did it happened.
	ResyncCountDrift() *int
	// Source may send frames timestamps faster or slower than realtime.
	// Live stream will catch it and resync. This counter indicates how many times did it happened.
	SetResyncCountDrift(int) InputStats
	// Source may change timestamps without any signalling. This counter indicates how bad is the source
	ResyncCountJump() *int
	// Source may change timestamps without any signalling. This counter indicates how bad is the source
	SetResyncCountJump(int) InputStats
	// Stream timestamps are synchronized with real time. This counter tells, how many times
	// it was syncronized after source reconnect.
	ResyncCountNormal() *int
	// Stream timestamps are synchronized with real time. This counter tells, how many times
	// it was syncronized after source reconnect.
	SetResyncCountNormal(int) InputStats
	// How many times has this stream retried to connect to source
	Retries() *int
	// How many times has this stream retried to connect to source
	SetRetries(int) InputStats
	// Per channel statistics calculated for RTP input
	RTPChannels() []InputRTPCounters
	// Per channel statistics calculated for RTP input
	SetRTPChannels([]InputRTPCounters) InputStats
	Sdi() InputSdiCounters
	SetSdi(InputSdiCounters) InputStats
	Srt() InputSrtCounters
	SetSrt(InputSrtCounters) InputStats
	// The time period during which no frames were received from the stream's input.
	// Format: ticks (ticks)
	// Example: 1284
	TSDelay() *Ticks
	// The time period during which no frames were received from the stream's input.
	// Format: ticks (ticks)
	// Example: 1284
	SetTSDelay(Ticks) InputStats
	// The time period during which no frames were received per each track according to `media_info`
	// Example: [1284]
	TSDelayPerTracks() []Ticks
	// The time period during which no frames were received per each track according to `media_info`
	// Example: [1284]
	SetTSDelayPerTracks([]Ticks) InputStats
	// Deprecated field. Will be deleted at 25.03
	// Final URL after redirects.
	// Deprecated because was never actually used.
	// Format: url (url)
	// Example: udp://239.0.0.1:1234
	URL() *URL
	// Deprecated field. Will be deleted at 25.03
	// Final URL after redirects.
	// Deprecated because was never actually used.
	// Format: url (url)
	// Example: udp://239.0.0.1:1234
	SetURL(URL) InputStats
	// Client's user agent for selected protocol.
	// Example: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML. like Gecko) Chrome/90.0.4430.72 Safari/537.36
	UserAgent() *string
	// Client's user agent for selected protocol.
	// Example: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML. like Gecko) Chrome/90.0.4430.72 Safari/537.36
	SetUserAgent(string) InputStats
	// Number of secondary inputs that have no problems.
	// Example: 2
	ValidSecondaryInputs() *int
	// Number of secondary inputs that have no problems.
	// Example: 2
	SetValidSecondaryInputs(int) InputStats
}

type InputTrackInfo interface {
	// Set of matching rules that will be checked
	// to select from input tracks
	Match() InputTrackInfoMatch
	// Set of matching rules that will be checked
	// to select from input tracks
	SetMatch(InputTrackInfoMatch) InputTrackInfo
}

type InputTrackInfoMatch interface {
	// Select input codec
	// Example: ac3
	Codec() *FrameCodec
	// Select input codec
	// Example: ac3
	SetCodec(FrameCodec) InputTrackInfoMatch
	// SUnfortunately, the sources may change the index of track without notice.
	// Please, use matching by index only and only if no other match option is suitable.
	// Example: 2
	Index() *int
	// SUnfortunately, the sources may change the index of track without notice.
	// Please, use matching by index only and only if no other match option is suitable.
	// Example: 2
	SetIndex(int) InputTrackInfoMatch
	// Select input track language
	// Example: eng
	Language() *string
	// Select input track language
	// Example: eng
	SetLanguage(string) InputTrackInfoMatch
}

type LayouterEntityFetched interface {
	// Entity configuration containing only those fields that are supported by Layouter.
	// For supported fields see [Layouter Schema](https://flussonic.com/doc/api/layouter/)
	EntityBody() any
	// Entity configuration containing only those fields that are supported by Layouter.
	// For supported fields see [Layouter Schema](https://flussonic.com/doc/api/layouter/)
	SetEntityBody(any) LayouterEntityFetched
	// Unique identifier of the entity.
	// For example, for `agent` it is `agent_id` field.
	EntityID() *string
	// Unique identifier of the entity.
	// For example, for `agent` it is `agent_id` field.
	SetEntityID(string) LayouterEntityFetched
	// Type of the entity.
	EntityType() *EntityEventEntityType
	// Type of the entity.
	SetEntityType(EntityEventEntityType) LayouterEntityFetched
	// Entity fetched by Layouter. It may be Streamer, Stream or Agent.
	Event() string
	// Entity fetched by Layouter. It may be Streamer, Stream or Agent.
	SetEvent(string) LayouterEntityFetched
	// Event identifier.
	EventID() *int
	// Event identifier.
	SetEventID(int) LayouterEntityFetched
	// Originator of event.
	// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
	// is configured as HTTP/HTTPS url.
	// Example: flussonic.host
	Server() *string
	// Originator of event.
	// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
	// is configured as HTTP/HTTPS url.
	// Example: flussonic.host
	SetServer(string) LayouterEntityFetched
	// Unique identifier of the operation.
	// You can use this field to search for events related to same operation.
	// Value of this field is taken from the `X-Trace-Id` header.
	// If `X-Trace-Id` header is not set, it will be generated automatically.
	// Service will use the value of this field to make outgoing requests.
	// Format: uuid (uuid)
	// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
	TraceID() *UUID
	// Unique identifier of the operation.
	// You can use this field to search for events related to same operation.
	// Value of this field is taken from the `X-Trace-Id` header.
	// If `X-Trace-Id` header is not set, it will be generated automatically.
	// Service will use the value of this field to make outgoing requests.
	// Format: uuid (uuid)
	// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
	SetTraceID(UUID) LayouterEntityFetched
	// The time of the event registration on the server.
	// Format: utc_ms (Unix timestamp in milliseconds)
	UtcMs() *UtcMs
	// The time of the event registration on the server.
	// Format: utc_ms (Unix timestamp in milliseconds)
	SetUtcMs(UtcMs) LayouterEntityFetched
}

type LayouterFetchingStarted interface {
	// Layouter started fetching entities for processing
	Event() string
	// Layouter started fetching entities for processing
	SetEvent(string) LayouterFetchingStarted
	// Event identifier.
	EventID() *int
	// Event identifier.
	SetEventID(int) LayouterFetchingStarted
	// Originator of event.
	// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
	// is configured as HTTP/HTTPS url.
	// Example: flussonic.host
	Server() *string
	// Originator of event.
	// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
	// is configured as HTTP/HTTPS url.
	// Example: flussonic.host
	SetServer(string) LayouterFetchingStarted
	// Unique identifier of the operation.
	// You can use this field to search for events related to same operation.
	// Value of this field is taken from the `X-Trace-Id` header.
	// If `X-Trace-Id` header is not set, it will be generated automatically.
	// Service will use the value of this field to make outgoing requests.
	// Format: uuid (uuid)
	// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
	TraceID() *UUID
	// Unique identifier of the operation.
	// You can use this field to search for events related to same operation.
	// Value of this field is taken from the `X-Trace-Id` header.
	// If `X-Trace-Id` header is not set, it will be generated automatically.
	// Service will use the value of this field to make outgoing requests.
	// Format: uuid (uuid)
	// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
	SetTraceID(UUID) LayouterFetchingStarted
	// The time of the event registration on the server.
	// Format: utc_ms (Unix timestamp in milliseconds)
	UtcMs() *UtcMs
	// The time of the event registration on the server.
	// Format: utc_ms (Unix timestamp in milliseconds)
	SetUtcMs(UtcMs) LayouterFetchingStarted
}

type LayouterProcessAgentsError interface {
	// structured error
	Error() Error
	// structured error
	SetError(Error) LayouterProcessAgentsError
	// Layouter process agents (without streams) error.
	Event() string
	// Layouter process agents (without streams) error.
	SetEvent(string) LayouterProcessAgentsError
	// Event identifier.
	EventID() *int
	// Event identifier.
	SetEventID(int) LayouterProcessAgentsError
	// Originator of event.
	// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
	// is configured as HTTP/HTTPS url.
	// Example: flussonic.host
	Server() *string
	// Originator of event.
	// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
	// is configured as HTTP/HTTPS url.
	// Example: flussonic.host
	SetServer(string) LayouterProcessAgentsError
	// Unique identifier of the operation.
	// You can use this field to search for events related to same operation.
	// Value of this field is taken from the `X-Trace-Id` header.
	// If `X-Trace-Id` header is not set, it will be generated automatically.
	// Service will use the value of this field to make outgoing requests.
	// Format: uuid (uuid)
	// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
	TraceID() *UUID
	// Unique identifier of the operation.
	// You can use this field to search for events related to same operation.
	// Value of this field is taken from the `X-Trace-Id` header.
	// If `X-Trace-Id` header is not set, it will be generated automatically.
	// Service will use the value of this field to make outgoing requests.
	// Format: uuid (uuid)
	// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
	SetTraceID(UUID) LayouterProcessAgentsError
	// The time of the event registration on the server.
	// Format: utc_ms (Unix timestamp in milliseconds)
	UtcMs() *UtcMs
	// The time of the event registration on the server.
	// Format: utc_ms (Unix timestamp in milliseconds)
	SetUtcMs(UtcMs) LayouterProcessAgentsError
}

type LayouterProcessAgentsSuccess interface {
	// Number of updated agents (without streams) layouts.
	AgentsUpdated() *int
	// Number of updated agents (without streams) layouts.
	SetAgentsUpdated(int) LayouterProcessAgentsSuccess
	// Layouter process agents (without streams) success.
	Event() string
	// Layouter process agents (without streams) success.
	SetEvent(string) LayouterProcessAgentsSuccess
	// Event identifier.
	EventID() *int
	// Event identifier.
	SetEventID(int) LayouterProcessAgentsSuccess
	// Originator of event.
	// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
	// is configured as HTTP/HTTPS url.
	// Example: flussonic.host
	Server() *string
	// Originator of event.
	// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
	// is configured as HTTP/HTTPS url.
	// Example: flussonic.host
	SetServer(string) LayouterProcessAgentsSuccess
	// Unique identifier of the operation.
	// You can use this field to search for events related to same operation.
	// Value of this field is taken from the `X-Trace-Id` header.
	// If `X-Trace-Id` header is not set, it will be generated automatically.
	// Service will use the value of this field to make outgoing requests.
	// Format: uuid (uuid)
	// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
	TraceID() *UUID
	// Unique identifier of the operation.
	// You can use this field to search for events related to same operation.
	// Value of this field is taken from the `X-Trace-Id` header.
	// If `X-Trace-Id` header is not set, it will be generated automatically.
	// Service will use the value of this field to make outgoing requests.
	// Format: uuid (uuid)
	// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
	SetTraceID(UUID) LayouterProcessAgentsSuccess
	// The time of the event registration on the server.
	// Format: utc_ms (Unix timestamp in milliseconds)
	UtcMs() *UtcMs
	// The time of the event registration on the server.
	// Format: utc_ms (Unix timestamp in milliseconds)
	SetUtcMs(UtcMs) LayouterProcessAgentsSuccess
}

type LayouterProcessStreamsError interface {
	// structured error
	Error() Error
	// structured error
	SetError(Error) LayouterProcessStreamsError
	// Layouter process streams error.
	Event() string
	// Layouter process streams error.
	SetEvent(string) LayouterProcessStreamsError
	// Event identifier.
	EventID() *int
	// Event identifier.
	SetEventID(int) LayouterProcessStreamsError
	// Originator of event.
	// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
	// is configured as HTTP/HTTPS url.
	// Example: flussonic.host
	Server() *string
	// Originator of event.
	// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
	// is configured as HTTP/HTTPS url.
	// Example: flussonic.host
	SetServer(string) LayouterProcessStreamsError
	// Unique identifier of the operation.
	// You can use this field to search for events related to same operation.
	// Value of this field is taken from the `X-Trace-Id` header.
	// If `X-Trace-Id` header is not set, it will be generated automatically.
	// Service will use the value of this field to make outgoing requests.
	// Format: uuid (uuid)
	// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
	TraceID() *UUID
	// Unique identifier of the operation.
	// You can use this field to search for events related to same operation.
	// Value of this field is taken from the `X-Trace-Id` header.
	// If `X-Trace-Id` header is not set, it will be generated automatically.
	// Service will use the value of this field to make outgoing requests.
	// Format: uuid (uuid)
	// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
	SetTraceID(UUID) LayouterProcessStreamsError
	// The time of the event registration on the server.
	// Format: utc_ms (Unix timestamp in milliseconds)
	UtcMs() *UtcMs
	// The time of the event registration on the server.
	// Format: utc_ms (Unix timestamp in milliseconds)
	SetUtcMs(UtcMs) LayouterProcessStreamsError
}

type LayouterProcessStreamsSuccess interface {
	// Layouter process streams success.
	Event() string
	// Layouter process streams success.
	SetEvent(string) LayouterProcessStreamsSuccess
	// Event identifier.
	EventID() *int
	// Event identifier.
	SetEventID(int) LayouterProcessStreamsSuccess
	// Originator of event.
	// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
	// is configured as HTTP/HTTPS url.
	// Example: flussonic.host
	Server() *string
	// Originator of event.
	// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
	// is configured as HTTP/HTTPS url.
	// Example: flussonic.host
	SetServer(string) LayouterProcessStreamsSuccess
	// Number of updated streams layouts.
	StreamsUpdated() *int
	// Number of updated streams layouts.
	SetStreamsUpdated(int) LayouterProcessStreamsSuccess
	// Unique identifier of the operation.
	// You can use this field to search for events related to same operation.
	// Value of this field is taken from the `X-Trace-Id` header.
	// If `X-Trace-Id` header is not set, it will be generated automatically.
	// Service will use the value of this field to make outgoing requests.
	// Format: uuid (uuid)
	// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
	TraceID() *UUID
	// Unique identifier of the operation.
	// You can use this field to search for events related to same operation.
	// Value of this field is taken from the `X-Trace-Id` header.
	// If `X-Trace-Id` header is not set, it will be generated automatically.
	// Service will use the value of this field to make outgoing requests.
	// Format: uuid (uuid)
	// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
	SetTraceID(UUID) LayouterProcessStreamsSuccess
	// The time of the event registration on the server.
	// Format: utc_ms (Unix timestamp in milliseconds)
	UtcMs() *UtcMs
	// The time of the event registration on the server.
	// Format: utc_ms (Unix timestamp in milliseconds)
	SetUtcMs(UtcMs) LayouterProcessStreamsSuccess
}

type LayouterProcessingResult interface {
	// Result of processing fetched entities
	Event() string
	// Result of processing fetched entities
	SetEvent(string) LayouterProcessingResult
	// Event identifier.
	EventID() *int
	// Event identifier.
	SetEventID(int) LayouterProcessingResult
	// List of relayouts made by Layouter
	Relayouts() []CentralStreamLayoutListItem
	// List of relayouts made by Layouter
	SetRelayouts([]CentralStreamLayoutListItem) LayouterProcessingResult
	// Originator of event.
	// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
	// is configured as HTTP/HTTPS url.
	// Example: flussonic.host
	Server() *string
	// Originator of event.
	// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
	// is configured as HTTP/HTTPS url.
	// Example: flussonic.host
	SetServer(string) LayouterProcessingResult
	// Unique identifier of the operation.
	// You can use this field to search for events related to same operation.
	// Value of this field is taken from the `X-Trace-Id` header.
	// If `X-Trace-Id` header is not set, it will be generated automatically.
	// Service will use the value of this field to make outgoing requests.
	// Format: uuid (uuid)
	// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
	TraceID() *UUID
	// Unique identifier of the operation.
	// You can use this field to search for events related to same operation.
	// Value of this field is taken from the `X-Trace-Id` header.
	// If `X-Trace-Id` header is not set, it will be generated automatically.
	// Service will use the value of this field to make outgoing requests.
	// Format: uuid (uuid)
	// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
	SetTraceID(UUID) LayouterProcessingResult
	// The time of the event registration on the server.
	// Format: utc_ms (Unix timestamp in milliseconds)
	UtcMs() *UtcMs
	// The time of the event registration on the server.
	// Format: utc_ms (Unix timestamp in milliseconds)
	SetUtcMs(UtcMs) LayouterProcessingResult
}

// Required: port
type ListenConfig interface {
	// Network address that will be used for listening.
	// Example: 10.0.35.1
	Address() *string
	// Network address that will be used for listening.
	// Example: 10.0.35.1
	SetAddress(string) ListenConfig
	// Port that will be used for listening.
	// Format: network_port (network_port)
	// Example: 80
	Port() NetworkPort
	// Port that will be used for listening.
	// Format: network_port (network_port)
	// Example: 80
	SetPort(NetworkPort) ListenConfig
}

type ListenHTTPConfig interface {
	// Network address that will be used for listening.
	// Example: 10.0.35.1
	Address() *string
	// Network address that will be used for listening.
	// Example: 10.0.35.1
	SetAddress(string) ListenHTTPConfig
	// If false, listener do not serve api calls.
	API() *bool
	// If false, listener do not serve api calls.
	SetAPI(bool) ListenHTTPConfig
	// Port that will be used for listening.
	// Format: network_port (network_port)
	// Example: 80
	Port() NetworkPort
	// Port that will be used for listening.
	// Format: network_port (network_port)
	// Example: 80
	SetPort(NetworkPort) ListenHTTPConfig
	// Time from when the connection is accepted to when the request body is fully read
	// Example: 5
	ReadTimeout() *int
	// Time from when the connection is accepted to when the request body is fully read
	// Example: 5
	SetReadTimeout(int) ListenHTTPConfig
	// Time from the end of the request header read to the end of the response write
	// Example: 5
	WriteTimeout() *int
	// Time from the end of the request header read to the end of the response write
	// Example: 5
	SetWriteTimeout(int) ListenHTTPConfig
}

type ListenHTTPConfigParams interface {
	// If false, listener do not serve api calls.
	API() *bool
	// If false, listener do not serve api calls.
	SetAPI(bool) ListenHTTPConfigParams
	// Time from when the connection is accepted to when the request body is fully read
	// Example: 5
	ReadTimeout() *int
	// Time from when the connection is accepted to when the request body is fully read
	// Example: 5
	SetReadTimeout(int) ListenHTTPConfigParams
	// Time from the end of the request header read to the end of the response write
	// Example: 5
	WriteTimeout() *int
	// Time from the end of the request header read to the end of the response write
	// Example: 5
	SetWriteTimeout(int) ListenHTTPConfigParams
}

type ListenHTTPSConfig interface {
	// Network address that will be used for listening.
	// Example: 10.0.35.1
	Address() *string
	// Network address that will be used for listening.
	// Example: 10.0.35.1
	SetAddress(string) ListenHTTPSConfig
	// If false, listener do not serve api calls.
	API() *bool
	// If false, listener do not serve api calls.
	SetAPI(bool) ListenHTTPSConfig
	// Path to ssl certificate
	// Example: /etc/letsencrypt/live/central/fullchain.pem
	Certificate() *string
	// Path to ssl certificate
	// Example: /etc/letsencrypt/live/central/fullchain.pem
	SetCertificate(string) ListenHTTPSConfig
	// Path to ssl certificate key
	// Example: /etc/letsencrypt/live/central/privkey.pem
	CertificateKey() *string
	// Path to ssl certificate key
	// Example: /etc/letsencrypt/live/central/privkey.pem
	SetCertificateKey(string) ListenHTTPSConfig
	// Port that will be used for listening.
	// Format: network_port (network_port)
	// Example: 80
	Port() NetworkPort
	// Port that will be used for listening.
	// Format: network_port (network_port)
	// Example: 80
	SetPort(NetworkPort) ListenHTTPSConfig
	// Time from when the connection is accepted to when the request body is fully read
	// Example: 5
	ReadTimeout() *int
	// Time from when the connection is accepted to when the request body is fully read
	// Example: 5
	SetReadTimeout(int) ListenHTTPSConfig
	// List of SSL protocol versions that will be used for listening.
	// Example: [tlsv1.1 tlsv1.2]
	SslProtocols() []TlsVersion
	// List of SSL protocol versions that will be used for listening.
	// Example: [tlsv1.1 tlsv1.2]
	SetSslProtocols([]TlsVersion) ListenHTTPSConfig
	// Time from the end of the request header read to the end of the response write
	// Example: 5
	WriteTimeout() *int
	// Time from the end of the request header read to the end of the response write
	// Example: 5
	SetWriteTimeout(int) ListenHTTPSConfig
}

type ListenSslConfig interface {
	// Path to ssl certificate
	// Example: /etc/letsencrypt/live/central/fullchain.pem
	Certificate() *string
	// Path to ssl certificate
	// Example: /etc/letsencrypt/live/central/fullchain.pem
	SetCertificate(string) ListenSslConfig
	// Path to ssl certificate key
	// Example: /etc/letsencrypt/live/central/privkey.pem
	CertificateKey() *string
	// Path to ssl certificate key
	// Example: /etc/letsencrypt/live/central/privkey.pem
	SetCertificateKey(string) ListenSslConfig
	// List of SSL protocol versions that will be used for listening.
	// Example: [tlsv1.1 tlsv1.2]
	SslProtocols() []TlsVersion
	// List of SSL protocol versions that will be used for listening.
	// Example: [tlsv1.1 tlsv1.2]
	SetSslProtocols([]TlsVersion) ListenSslConfig
}

type Listeners interface {
	// List of HTTP ports or `host:port` pairs that will be used for listening.
	// Examples: [map[api:false, port:80]]
	HTTP() []ListenHTTPConfig
	// List of HTTP ports or `host:port` pairs that will be used for listening.
	// Examples: [map[api:false, port:80]]
	SetHTTP([]ListenHTTPConfig) Listeners
	// List of HTTPS ports or `host:port` pairs that will be used for listening.
	// Examples: [map[port:443]]
	HTTPS() []ListenHTTPSConfig
	// List of HTTPS ports or `host:port` pairs that will be used for listening.
	// Examples: [map[port:443]]
	SetHTTPS([]ListenHTTPSConfig) Listeners
}

type MediaInfo interface {
	// Duration of the media, if applicable.
	// Format: ticks (ticks)
	Duration() *Ticks
	// Duration of the media, if applicable.
	// Format: ticks (ticks)
	SetDuration(Ticks) MediaInfo
	// Whether it is a file with a finite start and end time or a live stream.
	// Example: stream
	FlowType() *MediaInfoSpecificFlowType
	// Whether it is a file with a finite start and end time or a live stream.
	// Example: stream
	SetFlowType(MediaInfoSpecificFlowType) MediaInfo
	// The program ID for MPEG TS streams.
	// Example: 110
	ProgramID() *int
	// The program ID for MPEG TS streams.
	// Example: 110
	SetProgramID(int) MediaInfo
	// The media provider of this content.
	// Example: Netflix
	Provider() *string
	// The media provider of this content.
	// Example: Netflix
	SetProvider(string) MediaInfo
	// The identifier of the transport stream for MPEG TS streams.
	// Example: 253
	StreamID() *int
	// The identifier of the transport stream for MPEG TS streams.
	// Example: 253
	SetStreamID(int) MediaInfo
	// Human-readable title of the media.
	// Example: Bunny
	Title() *string
	// Human-readable title of the media.
	// Example: Bunny
	SetTitle(string) MediaInfo
	// Information about available tracks (video, audio, or text).
	Tracks() []TrackInfo
	// Information about available tracks (video, audio, or text).
	SetTracks([]TrackInfo) MediaInfo
}

type MediaInfoCommon interface {
	// The program ID for MPEG TS streams.
	// Example: 110
	ProgramID() *int
	// The program ID for MPEG TS streams.
	// Example: 110
	SetProgramID(int) MediaInfoCommon
	// The media provider of this content.
	// Example: Netflix
	Provider() *string
	// The media provider of this content.
	// Example: Netflix
	SetProvider(string) MediaInfoCommon
	// The identifier of the transport stream for MPEG TS streams.
	// Example: 253
	StreamID() *int
	// The identifier of the transport stream for MPEG TS streams.
	// Example: 253
	SetStreamID(int) MediaInfoCommon
	// Human-readable title of the media.
	// Example: Bunny
	Title() *string
	// Human-readable title of the media.
	// Example: Bunny
	SetTitle(string) MediaInfoCommon
}

type MediaInfoSpecific interface {
	// Duration of the media, if applicable.
	// Format: ticks (ticks)
	Duration() *Ticks
	// Duration of the media, if applicable.
	// Format: ticks (ticks)
	SetDuration(Ticks) MediaInfoSpecific
	// Whether it is a file with a finite start and end time or a live stream.
	// Example: stream
	FlowType() *MediaInfoSpecificFlowType
	// Whether it is a file with a finite start and end time or a live stream.
	// Example: stream
	SetFlowType(MediaInfoSpecificFlowType) MediaInfoSpecific
	// Information about available tracks (video, audio, or text).
	Tracks() []TrackInfo
	// Information about available tracks (video, audio, or text).
	SetTracks([]TrackInfo) MediaInfoSpecific
}

type OpenmetricsLabels interface {
}

type OutputMpegtsPids interface {
	// The default algorithm of selecting PID for a track.
	// * `auto`: track PID = PMT PID + track ID,
	// where PMT PID is the PID of Program Map Table and track ID is a number of the track set by Flussonic
	// (usually, all video tracks and then all audio tracks are numbered starting from 1).
	// * `increment`: track PID = previous track PID + 1.
	Default() *string
	// The default algorithm of selecting PID for a track.
	// * `auto`: track PID = PMT PID + track ID,
	// where PMT PID is the PID of Program Map Table and track ID is a number of the track set by Flussonic
	// (usually, all video tracks and then all audio tracks are numbered starting from 1).
	// * `increment`: track PID = previous track PID + 1.
	SetDefault(string) OutputMpegtsPids
	// Information about a particular media track.
	Media() []TransponderPid
	// Information about a particular media track.
	SetMedia([]TransponderPid) OutputMpegtsPids
	// PID of the elementary stream that contains PCR (Program Clock Reference) in the outgoing MPEG-TS stream.
	// PCR is the time label used for synchronization of a stream playback with real time.
	// Additionally, for DVB streams it is used for managing a decoder and its buffer.
	// In this case, PCR gives a signal to the frames with DTS<PCR to be sent to the decoder from the buffer.
	// This mechanism allows to compensate different sizes of frames: if a frame is too big to be played in time with a specified FPS, the frames from the buffer are played.
	Pcr() *int
	// PID of the elementary stream that contains PCR (Program Clock Reference) in the outgoing MPEG-TS stream.
	// PCR is the time label used for synchronization of a stream playback with real time.
	// Additionally, for DVB streams it is used for managing a decoder and its buffer.
	// In this case, PCR gives a signal to the frames with DTS<PCR to be sent to the decoder from the buffer.
	// This mechanism allows to compensate different sizes of frames: if a frame is too big to be played in time with a specified FPS, the frames from the buffer are played.
	SetPcr(int) OutputMpegtsPids
	// PID  of the elementary stream that contains Program Map Table (PMT) in the outgoing MPEG-TS stream.
	// PMT contains the description of each program and lists the PIDs of elementary streams associated with that program.
	// For instance, a transport stream used in digital television might contain three programs, to represent three television channels.
	// Suppose each channel consists of one video stream, one or two audio streams, and any necessary metadata.
	// A receiver wishing to decode one of the three channels merely has to decode the payloads of each PID associated with its program.
	// It can discard the contents of all other PIDs.
	Pmt() *int
	// PID  of the elementary stream that contains Program Map Table (PMT) in the outgoing MPEG-TS stream.
	// PMT contains the description of each program and lists the PIDs of elementary streams associated with that program.
	// For instance, a transport stream used in digital television might contain three programs, to represent three television channels.
	// Suppose each channel consists of one video stream, one or two audio streams, and any necessary metadata.
	// A receiver wishing to decode one of the three channels merely has to decode the payloads of each PID associated with its program.
	// It can discard the contents of all other PIDs.
	SetPmt(int) OutputMpegtsPids
	// PID  of the elementary stream that contains Service Description Table (SDT) in the outgoing MPEG-TS stream.
	// SDT provides information about services contained in MPEG-TS stream.
	Sdt() *int
	// PID  of the elementary stream that contains Service Description Table (SDT) in the outgoing MPEG-TS stream.
	// SDT provides information about services contained in MPEG-TS stream.
	SetSdt(int) OutputMpegtsPids
}

type PartitionStats interface {
	// The block device or file related to a mount path.
	// Format: disk_device (disk_device)
	// Example: sda1
	Device() *DiskDevice
	// The block device or file related to a mount path.
	// Format: disk_device (disk_device)
	// Example: sda1
	SetDevice(DiskDevice) PartitionStats
	// Percentage of IO utilization for device related to a mount path.
	// Format: percent (percent)
	// Example: 42
	IoUtil() *Percent
	// Percentage of IO utilization for device related to a mount path.
	// Format: percent (percent)
	// Example: 42
	SetIoUtil(Percent) PartitionStats
	// Mount path.
	// Format: disk_path (disk_path)
	// Example: _var_lib_docker_overlay2_3684778579db0a4d418fdc1a8a6953b680ab92d179a7d6f9506710d073095e36_merged
	Path() *DiskPath
	// Mount path.
	// Format: disk_path (disk_path)
	// Example: _var_lib_docker_overlay2_3684778579db0a4d418fdc1a8a6953b680ab92d179a7d6f9506710d073095e36_merged
	SetPath(DiskPath) PartitionStats
	// Total number of megabytes shown by the OS for this partition.
	// Format: megabytes (megabytes)
	// Example: 45423
	TotalMb() *Megabytes
	// Total number of megabytes shown by the OS for this partition.
	// Format: megabytes (megabytes)
	// Example: 45423
	SetTotalMb(Megabytes) PartitionStats
	// Percentage of usage of this partition.
	// Format: percent (percent)
	// Example: 30
	Usage() *Percent
	// Percentage of usage of this partition.
	// Format: percent (percent)
	// Example: 30
	SetUsage(Percent) PartitionStats
}

type PeerConfig interface {
	// The URL for provisioning of configuration from the managing server to the streamer.
	// This URL does not have to be public but must be accessible from the managing server.
	// The API URL can also be used as Public and/or Private payload URL if they are not set.
	// When used as Public payload URL, the API URL shall be public to allow playback from this streamer.
	// Format: url (url)
	// Example: http://streamer.local:8080
	APIURL() *URL
	// The URL for provisioning of configuration from the managing server to the streamer.
	// This URL does not have to be public but must be accessible from the managing server.
	// The API URL can also be used as Public and/or Private payload URL if they are not set.
	// When used as Public payload URL, the API URL shall be public to allow playback from this streamer.
	// Format: url (url)
	// Example: http://streamer.local:8080
	SetAPIURL(URL) PeerConfig
	// Maximal number of streams.
	// Example: 5
	ChannelLimit() *int
	// Maximal number of streams.
	// Example: 5
	SetChannelLimit(int) PeerConfig
	// The key for authorization for inter-Flussonic connections.
	// All cluster peers should have the same cluster key.
	// Example: xS6i6Q3DCc5nEvnu
	ClusterKey() *string
	// The key for authorization for inter-Flussonic connections.
	// All cluster peers should have the same cluster key.
	// Example: xS6i6Q3DCc5nEvnu
	SetClusterKey(string) PeerConfig
	// CPU limit in percents.
	// Format: percent (percent)
	// Example: 10
	CpuLimit() *Percent
	// CPU limit in percents.
	// Format: percent (percent)
	// Example: 10
	SetCpuLimit(Percent) PeerConfig
	// How often the peer will try to get the data from the remote server via internal API.
	// Format: milliseconds (milliseconds)
	// Example: 1000
	FetchTimeout() *Milliseconds
	// How often the peer will try to get the data from the remote server via internal API.
	// Format: milliseconds (milliseconds)
	// Example: 1000
	SetFetchTimeout(Milliseconds) PeerConfig
	// Streamer's identifier in the cluster.
	// The managing server may try using this hostname to access the streamer
	// if API URL is not specified.
	// Format: server_name (server_name)
	// Example: peer.example.com
	Hostname() *ServerName
	// Streamer's identifier in the cluster.
	// The managing server may try using this hostname to access the streamer
	// if API URL is not specified.
	// Format: server_name (server_name)
	// Example: peer.example.com
	SetHostname(ServerName) PeerConfig
	// Deprecated field. Will be deleted at 23.09
	// Maximal output bitrate of the peer.
	// Format: speed (speed)
	MaxBitrate() *Speed
	// Deprecated field. Will be deleted at 23.09
	// Maximal output bitrate of the peer.
	// Format: speed (speed)
	SetMaxBitrate(Speed) PeerConfig
	// Streamer's logical namespace, used for interacting with streams of the same namespace. By default, a streamer has no assigned namespace. In this default state, it can interact with streams that also have no assigned namespace. If a namespace is explicitly set, the streamer will only interact with streams possessing that specific namespace.
	// For example, the layouter will distribute streams only to streamers with the same namespace. The `dynamic_streams_list` endpoint will operate exclusively within a single namespace.
	// ***Use case:***
	// Namespaces provide strict, system-wide resource isolation, fundamentally separating streams and streamers into independent segments. This ensures no interaction, archive access, inference processing, or layout operations occur between different namespaces.
	// Unlike labels, which offer flexible, attribute-based layout control within a namespace, namespaces define an absolute boundary: resources from one namespace cannot interact with resources from another.
	// ***Important:***
	// A namespace can only be assigned when the streamer is created and cannot be changed afterwards.
	// Format: unix_name (Contains only alphanumeric characters (a-z, A-Z, 0-9), underscores (_), hyphens (-) and periods (.).)
	// Pattern: ^[a-zA-Z0-9_.-]+$
	// Example: example
	Namespace() *UnixName
	// Streamer's logical namespace, used for interacting with streams of the same namespace. By default, a streamer has no assigned namespace. In this default state, it can interact with streams that also have no assigned namespace. If a namespace is explicitly set, the streamer will only interact with streams possessing that specific namespace.
	// For example, the layouter will distribute streams only to streamers with the same namespace. The `dynamic_streams_list` endpoint will operate exclusively within a single namespace.
	// ***Use case:***
	// Namespaces provide strict, system-wide resource isolation, fundamentally separating streams and streamers into independent segments. This ensures no interaction, archive access, inference processing, or layout operations occur between different namespaces.
	// Unlike labels, which offer flexible, attribute-based layout control within a namespace, namespaces define an absolute boundary: resources from one namespace cannot interact with resources from another.
	// ***Important:***
	// A namespace can only be assigned when the streamer is created and cannot be changed afterwards.
	// Format: unix_name (Contains only alphanumeric characters (a-z, A-Z, 0-9), underscores (_), hyphens (-) and periods (.).)
	// Pattern: ^[a-zA-Z0-9_.-]+$
	// Example: example
	SetNamespace(UnixName) PeerConfig
	// The time after which deleted streams on this server are considered to be inactive
	// and cannot be used in the `cluster_ingest` mechanism.
	// Format: milliseconds (milliseconds)
	// Example: 1000
	StaleTimeout() *Milliseconds
	// The time after which deleted streams on this server are considered to be inactive
	// and cannot be used in the `cluster_ingest` mechanism.
	// Format: milliseconds (milliseconds)
	// Example: 1000
	SetStaleTimeout(Milliseconds) PeerConfig
	// Statistics on peers in the cluster.
	Stats() PeerStats
	// Statistics on peers in the cluster.
	SetStats(PeerStats) PeerConfig
}

type PeerStats interface {
	// Outbound bandwidth usage (load balancing in `usage` mode is based on this value).
	// Format: percent (percent)
	// Example: 67
	BandwidthUsage() *Percent
	// Outbound bandwidth usage (load balancing in `usage` mode is based on this value).
	// Format: percent (percent)
	// Example: 67
	SetBandwidthUsage(Percent) PeerStats
	// Build version
	Build() *int
	// Build version
	SetBuild(int) PeerStats
	// Information about errors in the config file.
	ConfigError() ConfigErrorStatus
	// Information about errors in the config file.
	SetConfigError(ConfigErrorStatus) PeerStats
	// Information about current external config status
	ConfigExternalStatus() ConfigExternalErrorStatus
	// Information about current external config status
	SetConfigExternalStatus(ConfigExternalErrorStatus) PeerStats
	// Current runtime version of config. We do not declare exact structure, but we promise
	// that it will be always comparable and increasing (if server has proper NTP configuration, of course).
	// Right now it is a tuple of server start time and incrementing version of config.
	// Example: [1.636709231e+09 4]
	ConfigVersion() []int
	// Current runtime version of config. We do not declare exact structure, but we promise
	// that it will be always comparable and increasing (if server has proper NTP configuration, of course).
	// Right now it is a tuple of server start time and incrementing version of config.
	// Example: [1.636709231e+09 4]
	SetConfigVersion([]int) PeerStats
	// CPU usage on the server.
	// Format: percent (percent)
	// Example: 48
	CpuUsage() *Percent
	// CPU usage on the server.
	// Format: percent (percent)
	// Example: 48
	SetCpuUsage(Percent) PeerStats
	// Description of an error, if any.
	Error() *string
	// Description of an error, if any.
	SetError(string) PeerStats
	HealthcheckStatus() CentralHealthcheckStatus
	SetHealthcheckStatus(CentralHealthcheckStatus) PeerStats
	// Hostname of your server. Please, use FQDN, do not leave your Linux misconfigured.
	// Example: openapi.flussonic.com
	Hostname() *string
	// Hostname of your server. Please, use FQDN, do not leave your Linux misconfigured.
	// Example: openapi.flussonic.com
	SetHostname(string) PeerStats
	// Unique runtime ID of this instance. Updated with the restart.
	// Format: uuid (uuid)
	// Example: 61893b15-75b2-4fcb-b4cf-ae1dd0858ea2
	ID() *UUID
	// Unique runtime ID of this instance. Updated with the restart.
	// Format: uuid (uuid)
	// Example: 61893b15-75b2-4fcb-b4cf-ae1dd0858ea2
	SetID(UUID) PeerStats
	// Current incoming speed (bitrate) of the data transmission over the network.
	// Format: speed (speed)
	// Example: 400300
	InputKbit() *Speed
	// Current incoming speed (bitrate) of the data transmission over the network.
	// Format: speed (speed)
	// Example: 400300
	SetInputKbit(Speed) PeerStats
	// The flag shows if Flussonic runs on Flussonic Coder.
	IsChassis() *bool
	// The flag shows if Flussonic runs on Flussonic Coder.
	SetIsChassis(bool) PeerStats
	// The code of the license applied on the server.
	// Example: uO8v12HJhNXVj5gM
	LicenseTxt() *string
	// The code of the license applied on the server.
	// Example: uO8v12HJhNXVj5gM
	SetLicenseTxt(string) PeerStats
	// The license type.
	LicenseType() *LicenseType
	// The license type.
	SetLicenseType(LicenseType) PeerStats
	// Memory usage on the server.
	// Format: percent (percent)
	// Example: 27
	MemoryUsage() *Percent
	// Memory usage on the server.
	// Format: percent (percent)
	// Example: 27
	SetMemoryUsage(Percent) PeerStats
	// Notification about a newer version in the repository.
	// Format: server_version (server_version)
	// Example: 22.01
	NextVersion() *ServerVersion
	// Notification about a newer version in the repository.
	// Format: server_version (server_version)
	// Example: 22.01
	SetNextVersion(ServerVersion) PeerStats
	// Current response time
	// Format: utc_ms (Unix timestamp in milliseconds)
	Now() *UtcMs
	// Current response time
	// Format: utc_ms (Unix timestamp in milliseconds)
	SetNow(UtcMs) PeerStats
	// The number of streams that are ready to be served to the clients.
	// Example: 27
	OnlineStreams() *int
	// The number of streams that are ready to be served to the clients.
	// Example: 27
	SetOnlineStreams(int) PeerStats
	// The number of opened files.
	// Example: 5
	OpenedFiles() *int
	// The number of opened files.
	// Example: 5
	SetOpenedFiles(int) PeerStats
	// Current outgoing speed (bitrate) of the data transmission over the network.
	// Format: speed (speed)
	// Example: 500400
	OutputKbit() *Speed
	// Current outgoing speed (bitrate) of the data transmission over the network.
	// Format: speed (speed)
	// Example: 500400
	SetOutputKbit(Speed) PeerStats
	// The list of disk partitions on the server.
	Partitions() []PartitionStats
	// The list of disk partitions on the server.
	SetPartitions([]PartitionStats) PeerStats
	// Predictions of future stats based on the current state of the cluster.
	Predictions() PeerStatsPredictions
	// Predictions of future stats based on the current state of the cluster.
	SetPredictions(PeerStatsPredictions) PeerStats
	// Shows if rproxy is configured.
	Rproxy() *bool
	// Shows if rproxy is configured.
	SetRproxy(bool) PeerStats
	// Shows if rproxy is running.
	RproxyRunning() *bool
	// Shows if rproxy is running.
	SetRproxyRunning(bool) PeerStats
	// Erlang scheduler load.
	// Format: percent (percent)
	// Example: 40
	SchedulerLoad() *Percent
	// Erlang scheduler load.
	// Format: percent (percent)
	// Example: 40
	SetSchedulerLoad(Percent) PeerStats
	// Package version of the server. Might be simple a number of release like 21.11 or longer if you have a rolling release installed.
	// Format: server_version (server_version)
	// Example: 23.04
	ServerVersion() *ServerVersion
	// Package version of the server. Might be simple a number of release like 21.11 or longer if you have a rolling release installed.
	// Format: server_version (server_version)
	// Example: 23.04
	SetServerVersion(ServerVersion) PeerStats
	// Boot time of this instance.
	// Format: utc (Unix timestamp in seconds)
	// Example: 1.639337825e+09
	StartedAt() *Utc
	// Boot time of this instance.
	// Format: utc (Unix timestamp in seconds)
	// Example: 1.639337825e+09
	SetStartedAt(Utc) PeerStats
	// *Flussonic* will always try to start even if there are severe errors that do not
	// allow functioning.
	// `starting` status means you should wait for some time (not more than
	// a minute).
	// `running` status means all configuration was loaded. However, the status does not provide
	// an information about your streams and the quality of provided service.
	// All other statuses mean there are some severe problems on the server
	// that cannot be repaired by Flussonic itself.
	StreamerStatus() *ServerStatsStreamerStatus
	// *Flussonic* will always try to start even if there are severe errors that do not
	// allow functioning.
	// `starting` status means you should wait for some time (not more than
	// a minute).
	// `running` status means all configuration was loaded. However, the status does not provide
	// an information about your streams and the quality of provided service.
	// All other statuses mean there are some severe problems on the server
	// that cannot be repaired by Flussonic itself.
	SetStreamerStatus(ServerStatsStreamerStatus) PeerStats
	// Human-readable format of errors and alerts that need to be fixed.
	// Provided by some *Flussonic* subsystems.
	TextAlerts() map[string]string
	// Human-readable format of errors and alerts that need to be fixed.
	// Provided by some *Flussonic* subsystems.
	SetTextAlerts(map[string]string) PeerStats
	// Deprecated field. Will be deleted at 22.03
	// Total server bandwidth.
	// Format: speed (speed)
	TotalBandwidth() *Speed
	// Deprecated field. Will be deleted at 22.03
	// Total server bandwidth.
	// Format: speed (speed)
	SetTotalBandwidth(Speed) PeerStats
	// The number of clients receiving the streams from the server at the moment of request.
	// Example: 2040
	TotalClients() *int
	// The number of clients receiving the streams from the server at the moment of request.
	// Example: 2040
	SetTotalClients(int) PeerStats
	// The number of streams created on the server.
	// Example: 45
	TotalStreams() *int
	// The number of streams created on the server.
	// Example: 45
	SetTotalStreams(int) PeerStats
	// Shows if the server's CPU can be used for transcoding
	// (i.e. if the `flussonic-transcoder` package is installed on the server).
	Transcoder() *bool
	// Shows if the server's CPU can be used for transcoding
	// (i.e. if the `flussonic-transcoder` package is installed on the server).
	SetTranscoder(bool) PeerStats
	// Statistics on the devices used for transcoding.
	TranscoderDevices() []TranscoderDeviceStats
	// Statistics on the devices used for transcoding.
	SetTranscoderDevices([]TranscoderDeviceStats) PeerStats
	// The server uptime.
	// Format: seconds (seconds)
	// Example: 4.325502e+06
	Uptime() *Seconds
	// The server uptime.
	// Format: seconds (seconds)
	// Example: 4.325502e+06
	SetUptime(Seconds) PeerStats
	// Shows if Flussonic Watcher is enabled in the license.
	Vsaas() *bool
	// Shows if Flussonic Watcher is enabled in the license.
	SetVsaas(bool) PeerStats
	// Shows if Watcher branding is enabled in the license.
	VsaasBranding() *bool
	// Shows if Watcher branding is enabled in the license.
	SetVsaasBranding(bool) PeerStats
	// Shows if Watcher is currently running.
	VsaasRunning() *bool
	// Shows if Watcher is currently running.
	SetVsaasRunning(bool) PeerStats
}

// Predictions of future stats based on the current state of the cluster.
type PeerStatsPredictions interface {
	Disk() CentralDiskPredictions
	SetDisk(CentralDiskPredictions) PeerStatsPredictions
}

type PlayProtocolsSpec interface {
	// Whether to allow or deny API requests, depending on the `whitelist` properties.
	API() *bool
	// Whether to allow or deny API requests, depending on the `whitelist` properties.
	SetAPI(bool) PlayProtocolsSpec
	// Whether to allow or deny an LL-HLS stream playback, depending on the `whitelist` properties.
	Cmaf() *bool
	// Whether to allow or deny an LL-HLS stream playback, depending on the `whitelist` properties.
	SetCmaf(bool) PlayProtocolsSpec
	// Whether to allow or deny a DASH stream playback, depending on the `whitelist` properties.
	Dash() *bool
	// Whether to allow or deny a DASH stream playback, depending on the `whitelist` properties.
	SetDash(bool) PlayProtocolsSpec
	// Whether to allow or deny an HLS stream playback, depending on the `whitelist` properties.
	Hls() *bool
	// Whether to allow or deny an HLS stream playback, depending on the `whitelist` properties.
	SetHls(bool) PlayProtocolsSpec
	// Whether to allow or deny delivering JPEG thumbnails over HTTP(S), depending on the `whitelist` properties.
	Jpeg() *bool
	// Whether to allow or deny delivering JPEG thumbnails over HTTP(S), depending on the `whitelist` properties.
	SetJpeg(bool) PlayProtocolsSpec
	// Whether to allow or deny an M4F stream playback, depending on the `whitelist` properties.
	M4f() *bool
	// Whether to allow or deny an M4F stream playback, depending on the `whitelist` properties.
	SetM4f(bool) PlayProtocolsSpec
	// Whether to allow or deny an M4S stream playback, depending on the `whitelist` properties.
	M4s() *bool
	// Whether to allow or deny an M4S stream playback, depending on the `whitelist` properties.
	SetM4s(bool) PlayProtocolsSpec
	// Whether to allow or deny an MP4 file download over HTTP(S), depending on the `whitelist` properties.
	// Used to export DVR segment(s) in MP4 file.
	Mp4() *bool
	// Whether to allow or deny an MP4 file download over HTTP(S), depending on the `whitelist` properties.
	// Used to export DVR segment(s) in MP4 file.
	SetMp4(bool) PlayProtocolsSpec
	// Whether to allow or deny an MSE-LD stream playback, depending on the `whitelist` properties.
	Mseld() *bool
	// Whether to allow or deny an MSE-LD stream playback, depending on the `whitelist` properties.
	SetMseld(bool) PlayProtocolsSpec
	// Whether to allow or deny an MSS stream playback, depending on the `whitelist` properties.
	Mss() *bool
	// Whether to allow or deny an MSS stream playback, depending on the `whitelist` properties.
	SetMss(bool) PlayProtocolsSpec
	// Whether to allow or deny playback in embed.html, depending on the `whitelist` properties.
	Player() *bool
	// Whether to allow or deny playback in embed.html, depending on the `whitelist` properties.
	SetPlayer(bool) PlayProtocolsSpec
	// Whether to allow or deny an RTMP stream playback, depending on the `whitelist` properties.
	Rtmp() *bool
	// Whether to allow or deny an RTMP stream playback, depending on the `whitelist` properties.
	SetRtmp(bool) PlayProtocolsSpec
	// Whether to allow or deny an RTSP stream playback, depending on the `whitelist` properties.
	Rtsp() *bool
	// Whether to allow or deny an RTSP stream playback, depending on the `whitelist` properties.
	SetRtsp(bool) PlayProtocolsSpec
	// Whether to allow or deny a SHOUTcast/Icecast stream playback, depending on the `whitelist` properties.
	Shoutcast() *bool
	// Whether to allow or deny a SHOUTcast/Icecast stream playback, depending on the `whitelist` properties.
	SetShoutcast(bool) PlayProtocolsSpec
	// Whether to allow or deny an SRT stream playback, depending on the `whitelist` properties.
	Srt() *bool
	// Whether to allow or deny an SRT stream playback, depending on the `whitelist` properties.
	SetSrt(bool) PlayProtocolsSpec
	// Whether to allow or deny an MPEG-TS stream playback over HTTP(S), depending on the `whitelist` properties.
	Tshttp() *bool
	// Whether to allow or deny an MPEG-TS stream playback over HTTP(S), depending on the `whitelist` properties.
	SetTshttp(bool) PlayProtocolsSpec
	// Whether to allow or deny an WebRTC stream playback, depending on the `whitelist` properties.
	Webrtc() *bool
	// Whether to allow or deny an WebRTC stream playback, depending on the `whitelist` properties.
	SetWebrtc(bool) PlayProtocolsSpec
	// - If set to `True`, server **allows** a playback only for listed protocols;
	// - If set to `False`, server **forbids** a playback only for listed protocols;
	Whitelist() *bool
	// - If set to `True`, server **allows** a playback only for listed protocols;
	// - If set to `False`, server **forbids** a playback only for listed protocols;
	SetWhitelist(bool) PlayProtocolsSpec
}

type PlaybackHeaders interface {
	// HTTP headers in name-value format for manifest requests.
	// Example: map[Cache-Control:max-age=3600]
	Headers() map[string]string
	// HTTP headers in name-value format for manifest requests.
	// Example: map[Cache-Control:max-age=3600]
	SetHeaders(map[string]string) PlaybackHeaders
	// Playback type for which the HTTP headers apply.
	// Example: live
	Playback() *PlaybackHeadersPlayback
	// Playback type for which the HTTP headers apply.
	// Example: live
	SetPlayback(PlaybackHeadersPlayback) PlaybackHeaders
	// Configuration to allow/forbid headers for various playback protocols.
	Protocols() PlayProtocolsSpec
	// Configuration to allow/forbid headers for various playback protocols.
	SetProtocols(PlayProtocolsSpec) PlaybackHeaders
	// HTTP headers in name-value format for segment requests.
	// Example: map[Cache-Control:max-age=3600]
	SegmentHeaders() map[string]string
	// HTTP headers in name-value format for segment requests.
	// Example: map[Cache-Control:max-age=3600]
	SetSegmentHeaders(map[string]string) PlaybackHeaders
}

type PushCounters interface {
	// Total amount of bytes sent since the pusher was created.
	// Format: bytes (bytes)
	Bytes() *Bytes
	// Total amount of bytes sent since the pusher was created.
	// Format: bytes (bytes)
	SetBytes(Bytes) PushCounters
	// The encoded bytes count.
	// Format: bytes (bytes)
	EncodedBytes() *Bytes
	// The encoded bytes count.
	// Format: bytes (bytes)
	SetEncodedBytes(Bytes) PushCounters
	// How many times we've got 401 (unauthorized).
	Errors401() *int
	// How many times we've got 401 (unauthorized).
	SetErrors401(int) PushCounters
	// How many times we've got 403 (forbidden).
	Errors403() *int
	// How many times we've got 403 (forbidden).
	SetErrors403(int) PushCounters
	// How many times we've got 404 (enoent).
	Errors404() *int
	// How many times we've got 404 (enoent).
	SetErrors404(int) PushCounters
	// How many times we've got 409 (double_publish_denied).
	Errors409() *int
	// How many times we've got 409 (double_publish_denied).
	SetErrors409(int) PushCounters
	// How many times we've got 500 (server_error).
	Errors500() *int
	// How many times we've got 500 (server_error).
	SetErrors500(int) PushCounters
	// Number of errors during of audio frame decoding to raw format.
	ErrorsAudioFrameDecode() *int
	// Number of errors during of audio frame decoding to raw format.
	SetErrorsAudioFrameDecode(int) PushCounters
	// How many times pusher unexpectedly lost connection with peer
	ErrorsConnectionLost() *int
	// How many times pusher unexpectedly lost connection with peer
	SetErrorsConnectionLost(int) PushCounters
	// How many times internal device buffer was overflowed.
	ErrorsDeviceBufferOverflow() *int
	// How many times internal device buffer was overflowed.
	SetErrorsDeviceBufferOverflow(int) PushCounters
	// How much times pusher was unable to open (attach to) device for pushing
	ErrorsDeviceNotOpened() *int
	// How much times pusher was unable to open (attach to) device for pushing
	SetErrorsDeviceNotOpened(int) PushCounters
	// Number of dropped frames
	ErrorsDroppedFrames() *int
	// Number of dropped frames
	SetErrorsDroppedFrames(int) PushCounters
	// Number of dropped segments
	ErrorsDroppedSegments() *int
	// Number of dropped segments
	SetErrorsDroppedSegments(int) PushCounters
	// How many times pusher did not establish connection because of destination peer is not reached
	ErrorsNoDestination() *int
	// How many times pusher did not establish connection because of destination peer is not reached
	SetErrorsNoDestination(int) PushCounters
	// How many times pusher did not establish connection because of missing or wrong credentials
	ErrorsNotAuthorized() *int
	// How many times pusher did not establish connection because of missing or wrong credentials
	SetErrorsNotAuthorized(int) PushCounters
	// How many times pusher was stopped because of redirect limit is reached
	ErrorsRedirectLimit() *int
	// How many times pusher was stopped because of redirect limit is reached
	SetErrorsRedirectLimit(int) PushCounters
	// How many times pusher was stopped due to overload
	ErrorsStopOverloaded() *int
	// How many times pusher was stopped due to overload
	SetErrorsStopOverloaded(int) PushCounters
	// How many times pusher got TLS errors.
	ErrorsTls() *int
	// How many times pusher got TLS errors.
	SetErrorsTls(int) PushCounters
	// Number of errors during of video frame decoding to raw format.
	ErrorsVideoFrameDecode() *int
	// Number of errors during of video frame decoding to raw format.
	SetErrorsVideoFrameDecode(int) PushCounters
	// Number of frames sent by this pusher.
	Frames() *int
	// Number of frames sent by this pusher.
	SetFrames(int) PushCounters
	// SDI card output clock-lock state.
	GenlockStatus() *GenlockStatus
	// SDI card output clock-lock state.
	SetGenlockStatus(GenlockStatus) PushCounters
	// SDI card reference port (Ref In Port) status.
	GenrefStatus() GenrefStatus
	// SDI card reference port (Ref In Port) status.
	SetGenrefStatus(GenrefStatus) PushCounters
	// The time in milliseconds when the pusher instance was created.
	// Format: utc_ms (Unix timestamp in milliseconds)
	OpenedAt() *UtcMs
	// The time in milliseconds when the pusher instance was created.
	// Format: utc_ms (Unix timestamp in milliseconds)
	SetOpenedAt(UtcMs) PushCounters
	// Per pid statistics for MPEG-TS encoding calculated for the pusher
	Pids() []PushPidCounters
	// Per pid statistics for MPEG-TS encoding calculated for the pusher
	SetPids([]PushPidCounters) PushCounters
	// How many times there were no data to push in pusher queue
	PusherQueueExhaustedCount() *int
	// How many times there were no data to push in pusher queue
	SetPusherQueueExhaustedCount(int) PushCounters
	// How many times pusher was restarted
	PusherRestarts() *int
	// How many times pusher was restarted
	SetPusherRestarts(int) PushCounters
	// Number of retries since the last successful push.
	ResentPackets() *int
	// Number of retries since the last successful push.
	SetResentPackets(int) PushCounters
	// Number of segments sent by this pusher.
	Segments() *int
	// Number of segments sent by this pusher.
	SetSegments(int) PushCounters
	// State of the standby push.
	StandbyStatus() *PusherStandbyStatus
	// State of the standby push.
	SetStandbyStatus(PusherStandbyStatus) PushCounters
	// State of the push session.
	Status() *PusherStatus
	// State of the push session.
	SetStatus(*PusherStatus) PushCounters
	// Deprecated field. Will be deleted at 26.03
	// The fillers bytes count for system traffic. Currently this field is always zero.
	// Format: bytes (bytes)
	SysFillersBytes() *Bytes
	// Deprecated field. Will be deleted at 26.03
	// The fillers bytes count for system traffic. Currently this field is always zero.
	// Format: bytes (bytes)
	SetSysFillersBytes(Bytes) PushCounters
	// The payload bytes count for system traffic.
	// Format: bytes (bytes)
	SysPayloadBytes() *Bytes
	// The payload bytes count for system traffic.
	// Format: bytes (bytes)
	SetSysPayloadBytes(Bytes) PushCounters
	// The stuff packets count for system traffic.
	SysStuffingPackets() *int
	// The stuff packets count for system traffic.
	SetSysStuffingPackets(int) PushCounters
	// Obfuscated URL where to push to
	// Format: input_url (input_url)
	URL() *InputURL
	// Obfuscated URL where to push to
	// Format: input_url (input_url)
	SetURL(InputURL) PushCounters
}

// Required: pid
type PushPidCounters interface {
	// Bitrate on this PID, configured or autotuned.
	// Format: speed (speed)
	Bitrate() *Speed
	// Bitrate on this PID, configured or autotuned.
	// Format: speed (speed)
	SetBitrate(Speed) PushPidCounters
	// Content of the track (e.g. audio, video, text).
	Content() *FrameContent
	// Content of the track (e.g. audio, video, text).
	SetContent(FrameContent) PushPidCounters
	// Number of times a frame was dropped on this PID due to DTS going backward.
	// Each such event currently triggers a full program reset.
	ErrorsDtsGoesBackward() *int
	// Number of times a frame was dropped on this PID due to DTS going backward.
	// Each such event currently triggers a full program reset.
	SetErrorsDtsGoesBackward(int) PushPidCounters
	// Number of times a frame was dropped on this PID due to a forward DTS jump.
	// Each such event currently triggers a full program reset.
	ErrorsDtsJumpsForward() *int
	// Number of times a frame was dropped on this PID due to a forward DTS jump.
	// Each such event currently triggers a full program reset.
	SetErrorsDtsJumpsForward(int) PushPidCounters
	// Number of times this PID was dropped from the output multiplexed stream (e.g., due to prebuffer exhaustion).
	ErrorsPidOff() *int
	// Number of times this PID was dropped from the output multiplexed stream (e.g., due to prebuffer exhaustion).
	SetErrorsPidOff(int) PushPidCounters
	// Number of PID start errors caused by DTS values too far in the future.
	// Each such event currently triggers a full program reset.
	ErrorsStartFutureDts() *int
	// Number of PID start errors caused by DTS values too far in the future.
	// Each such event currently triggers a full program reset.
	SetErrorsStartFutureDts(int) PushPidCounters
	// Number of PID start errors caused by late DTS.
	// Each such event currently triggers a full program reset.
	ErrorsStartLateDts() *int
	// Number of PID start errors caused by late DTS.
	// Each such event currently triggers a full program reset.
	SetErrorsStartLateDts(int) PushPidCounters
	// Number of times a frame was received on an unconfigured PID.
	// Usually occurs after reconfiguration.
	ErrorsUnconfiguredQueue() *int
	// Number of times a frame was received on an unconfigured PID.
	// Usually occurs after reconfiguration.
	SetErrorsUnconfiguredQueue(int) PushPidCounters
	// The number of bytes exceeding the allocated bandwidth.
	// Format: bytes (bytes)
	ExceededBytes() *Bytes
	// The number of bytes exceeding the allocated bandwidth.
	// Format: bytes (bytes)
	SetExceededBytes(Bytes) PushPidCounters
	// The number of PES packets with an instant bitrate boost.
	ExceededFrames() *int
	// The number of PES packets with an instant bitrate boost.
	SetExceededFrames(int) PushPidCounters
	// How many MPEG-TS packets with NAL fillers on this PID produced.
	FillerPackets() *int
	// How many MPEG-TS packets with NAL fillers on this PID produced.
	SetFillerPackets(int) PushPidCounters
	// Deprecated field. Will be deleted at 25.11
	// The filler bytes count.
	// Use `filler_packets` instead.
	// Format: bytes (bytes)
	Fillers() *Bytes
	// Deprecated field. Will be deleted at 25.11
	// The filler bytes count.
	// Use `filler_packets` instead.
	// Format: bytes (bytes)
	SetFillers(Bytes) PushPidCounters
	// Deprecated field. Will be deleted at 25.11
	// How many bytes were seen in NAL fillers.
	// Use `filler_packets` instead.
	// Format: bytes (bytes)
	FillersBytes() *Bytes
	// Deprecated field. Will be deleted at 25.11
	// How many bytes were seen in NAL fillers.
	// Use `filler_packets` instead.
	// Format: bytes (bytes)
	SetFillersBytes(Bytes) PushPidCounters
	// Highest recorded level of the TS buffer.
	// With too big values the HRD buffer may be filling up completely (overflow).
	// Format: milliseconds (milliseconds)
	MaxBuffer() *Milliseconds
	// Highest recorded level of the TS buffer.
	// With too big values the HRD buffer may be filling up completely (overflow).
	// Format: milliseconds (milliseconds)
	SetMaxBuffer(Milliseconds) PushPidCounters
	// Lowest recorded level of the TS buffer.
	// With too small values the HRD buffer may be completely empty (underflow).
	// Format: milliseconds (milliseconds)
	MinBuffer() *Milliseconds
	// Lowest recorded level of the TS buffer.
	// With too small values the HRD buffer may be completely empty (underflow).
	// Format: milliseconds (milliseconds)
	SetMinBuffer(Milliseconds) PushPidCounters
	// How many MPEG-TS packets with 188 bytes on this PID produced.
	Packets() *int
	// How many MPEG-TS packets with 188 bytes on this PID produced.
	SetPackets(int) PushPidCounters
	// Deprecated field. Will be deleted at 25.11
	// The payload bytes count.
	// Use `payload_bytes` instead.
	// Format: bytes (bytes)
	Payload() *Bytes
	// Deprecated field. Will be deleted at 25.11
	// The payload bytes count.
	// Use `payload_bytes` instead.
	// Format: bytes (bytes)
	SetPayload(Bytes) PushPidCounters
	// The payload bytes count.
	// Format: bytes (bytes)
	PayloadBytes() *Bytes
	// The payload bytes count.
	// Format: bytes (bytes)
	SetPayloadBytes(Bytes) PushPidCounters
	// Related MPEG-TS PID.
	Pid() int
	// Related MPEG-TS PID.
	SetPid(int) PushPidCounters
	// Program ID this PID belongs to.
	Pnr() *int
	// Program ID this PID belongs to.
	SetPnr(int) PushPidCounters
	// Deprecated field. Will be deleted at 25.11
	// The stuff packets count.
	// Use `stuffing_packets` instead.
	Stuffing() *int
	// Deprecated field. Will be deleted at 25.11
	// The stuff packets count.
	// Use `stuffing_packets` instead.
	SetStuffing(int) PushPidCounters
	// How many NULL packets (PID 0x1FFF) inserted when no data is scheduled on this PID.
	StuffingPackets() *int
	// How many NULL packets (PID 0x1FFF) inserted when no data is scheduled on this PID.
	SetStuffingPackets(int) PushPidCounters
	// The trimmed bytes count.
	// Format: bytes (bytes)
	TrimmedBytes() *Bytes
	// The trimmed bytes count.
	// Format: bytes (bytes)
	SetTrimmedBytes(Bytes) PushPidCounters
	// The trimmed PES packets count.
	TrimmedFrames() *int
	// The trimmed PES packets count.
	SetTrimmedFrames(int) PushPidCounters
}

// Required: channel_id
type RTPCountersBase interface {
	// How many bytes received for this channel
	Bytes() *int
	// How many bytes received for this channel
	SetBytes(int) RTPCountersBase
	// RTP channel number
	// Example: 0
	ChannelID() int
	// RTP channel number
	// Example: 0
	SetChannelID(int) RTPCountersBase
	// Content of the track transmitted in the channel
	// Example: video
	Content() *string
	// Content of the track transmitted in the channel
	// Example: video
	SetContent(string) RTPCountersBase
	// Demultiplexing was done right, but content is broken.
	ErrorsBrokenPayload() *int
	// Demultiplexing was done right, but content is broken.
	SetErrorsBrokenPayload(int) RTPCountersBase
	// Number of frames which dts is same as previous frame dts.
	ErrorsDtsStuck() *int
	// Number of frames which dts is same as previous frame dts.
	SetErrorsDtsStuck(int) RTPCountersBase
	// RTP have enough information to tell how many packets were lost
	ErrorsLostPackets() *int
	// RTP have enough information to tell how many packets were lost
	SetErrorsLostPackets(int) RTPCountersBase
	// How many frames received for this channel
	Frames() *int
	// How many frames received for this channel
	SetFrames(int) RTPCountersBase
	// Number of RTP packets which marker bit is set to one.
	MarkerPacketsCount() *int
	// Number of RTP packets which marker bit is set to one.
	SetMarkerPacketsCount(int) RTPCountersBase
	// How many NACK messages are sent for this channel
	NackCount() *int
	// How many NACK messages are sent for this channel
	SetNackCount(int) RTPCountersBase
	// If no marker bit packet is received after 400 RTP packets then decoder switches to `no_marker_mode` and
	// makes frame on each timecode change.
	// This flag shows if decoder works in `no_marker_mode`.
	NoMarkerModeFlag() *bool
	// If no marker bit packet is received after 400 RTP packets then decoder switches to `no_marker_mode` and
	// makes frame on each timecode change.
	// This flag shows if decoder works in `no_marker_mode`.
	SetNoMarkerModeFlag(bool) RTPCountersBase
	// Number of rtp packets rejected due to wrong payload type
	PtRejectCount() *int
	// Number of rtp packets rejected due to wrong payload type
	SetPtRejectCount(int) RTPCountersBase
	// Total size of rejected packets due to wrong payload type (pt_reject_count) rtp packets
	PtRejectSum() *int
	// Total size of rejected packets due to wrong payload type (pt_reject_count) rtp packets
	SetPtRejectSum(int) RTPCountersBase
	// How many RTCP packets received for this channel
	RtcpPackets() *int
	// How many RTCP packets received for this channel
	SetRtcpPackets(int) RTPCountersBase
	// How many RTP packets received for this channel
	RTPPackets() *int
	// How many RTP packets received for this channel
	SetRTPPackets(int) RTPCountersBase
	// Sender wallclock deviation from server time in ms. Positive value means that sender time is ahead of server time.
	SenderClockDeviation() *int
	// Sender wallclock deviation from server time in ms. Positive value means that sender time is ahead of server time.
	SetSenderClockDeviation(int) RTPCountersBase
	// Number of rtcp SR packets which `RTP timestamp` is equal to the previous rtcp SR packet `RTP timestamp`.
	SrTSStuck() *int
	// Number of rtcp SR packets which `RTP timestamp` is equal to the previous rtcp SR packet `RTP timestamp`.
	SetSrTSStuck(int) RTPCountersBase
	// Time on this channel is jumped back from reference wallclock.
	TSGoesBackwards() *int
	// Time on this channel is jumped back from reference wallclock.
	SetTSGoesBackwards(int) RTPCountersBase
	// Time on this channel is jumped forward from reference wallclock.
	TSJumpForward() *int
	// Time on this channel is jumped forward from reference wallclock.
	SetTSJumpForward(int) RTPCountersBase
	// https://datatracker.ietf.org/doc/html/rfc6184#section-4.1
	// access unit: A set of NAL units always containing a primary coded picture.  In addition to the primary coded
	// picture, an access unit may also contain one or more redundant coded pictures or other NAL units not containing
	// slices or slice data partitions of a coded picture.  The decoding of an access unit always results in a
	// decoded picture.
	// There is `marker bit` in RTP packet which is set for the very last packet of the access unit indicated by the RTP timestamp.
	// It is protocol violation if received RTP packet has the same timestamp as previous marker bit packet.
	// This counter is a number of RTP packets which `RTP timestamp` is equal to previous RTP marker bit packet.
	TSStuck() *int
	// https://datatracker.ietf.org/doc/html/rfc6184#section-4.1
	// access unit: A set of NAL units always containing a primary coded picture.  In addition to the primary coded
	// picture, an access unit may also contain one or more redundant coded pictures or other NAL units not containing
	// slices or slice data partitions of a coded picture.  The decoding of an access unit always results in a
	// decoded picture.
	// There is `marker bit` in RTP packet which is set for the very last packet of the access unit indicated by the RTP timestamp.
	// It is protocol violation if received RTP packet has the same timestamp as previous marker bit packet.
	// This counter is a number of RTP packets which `RTP timestamp` is equal to previous RTP marker bit packet.
	SetTSStuck(int) RTPCountersBase
}

// Required: path
type RaidDiskConfig interface {
	// The mode of using the disk.
	// Example: keep
	Mode() *RaidDiskMode
	// The mode of using the disk.
	// Example: keep
	SetMode(RaidDiskMode) RaidDiskConfig
	// The path to a mounted disk.
	// Format: disk_path (disk_path)
	// Example: volume1
	Path() DiskPath
	// The path to a mounted disk.
	// Format: disk_path (disk_path)
	// Example: volume1
	SetPath(DiskPath) RaidDiskConfig
	// The runtime statistics about RAID. The statistics shows the state of disks.
	// Learn more in [Flussonic RAID for DVR](https://flussonic.com/doc/extend-video-storage-on-fly/#dvr-flussonic-raid-stats)
	Stats() RaidDiskConfigStats
	// The runtime statistics about RAID. The statistics shows the state of disks.
	// Learn more in [Flussonic RAID for DVR](https://flussonic.com/doc/extend-video-storage-on-fly/#dvr-flussonic-raid-stats)
	SetStats(RaidDiskConfigStats) RaidDiskConfig
}

// The runtime statistics about RAID. The statistics shows the state of disks.
// Learn more in [Flussonic RAID for DVR](https://flussonic.com/doc/extend-video-storage-on-fly/#dvr-flussonic-raid-stats)
type RaidDiskConfigStats interface {
	// The number of blobs on the disk that are enlisted in individual stream indexes.
	// It must be equal to blobs_count_db and can be different in case of software
	// or hardware errors.
	BlobsCount() *int
	// The number of blobs on the disk that are enlisted in individual stream indexes.
	// It must be equal to blobs_count_db and can be different in case of software
	// or hardware errors.
	SetBlobsCount(int) RaidDiskConfigStats
	// The number of blobs on the disk according to centralized Raid DB that is
	// used to allocate blobs across whole storage.
	BlobsCountDb() *int
	// The number of blobs on the disk according to centralized Raid DB that is
	// used to allocate blobs across whole storage.
	SetBlobsCountDb(int) RaidDiskConfigStats
	// Errors of using the disk.
	Errors() RaidDiskErrors
	// Errors of using the disk.
	SetErrors(RaidDiskErrors) RaidDiskConfigStats
	// Disk I/O utilization percentage from `/proc/devstat`.
	// Format: percent (percent)
	IoUsage() *Percent
	// Disk I/O utilization percentage from `/proc/devstat`.
	// Format: percent (percent)
	SetIoUsage(Percent) RaidDiskConfigStats
	// The estimated migration end time, in UTC seconds.
	// Format: utc (Unix timestamp in seconds)
	MigrationEta() *Utc
	// The estimated migration end time, in UTC seconds.
	// Format: utc (Unix timestamp in seconds)
	SetMigrationEta(Utc) RaidDiskConfigStats
	// The speed of copying the last blob, in bytes per second.
	// Format: speed (speed)
	MigrationSpeed() *Speed
	// The speed of copying the last blob, in bytes per second.
	// Format: speed (speed)
	SetMigrationSpeed(Speed) RaidDiskConfigStats
	// The time when the values of `migration_speed` and `migration_eta` were last updated.
	// Format: utc (Unix timestamp in seconds)
	MigrationUpdated() *Utc
	// The time when the values of `migration_speed` and `migration_eta` were last updated.
	// Format: utc (Unix timestamp in seconds)
	SetMigrationUpdated(Utc) RaidDiskConfigStats
	// The mode of using the disk.
	// Example: keep
	Mode() *RaidDiskMode
	// The mode of using the disk.
	// Example: keep
	SetMode(RaidDiskMode) RaidDiskConfigStats
	// Whether the disk is mounted correctly.
	Mounted() *bool
	// Whether the disk is mounted correctly.
	SetMounted(bool) RaidDiskConfigStats
	// Disk capacity in bytes.
	// Format: bytes (bytes)
	Size() *Bytes
	// Disk capacity in bytes.
	// Format: bytes (bytes)
	SetSize(Bytes) RaidDiskConfigStats
	// Disk utilization percentage.
	// Format: percent (percent)
	Usage() *Percent
	// Disk utilization percentage.
	// Format: percent (percent)
	SetUsage(Percent) RaidDiskConfigStats
	// Used disk space in bytes according to linux metrics. It must be equal (almost equal) to
	// `used_index`. If it differs more than in 1%, then it means that there are lot of unknown files.
	// If this disk is used exclusively for Raid, then it may mean that some blobs are lost from
	// database and repairing is required.
	// Format: bytes (bytes)
	Used() *Bytes
	// Used disk space in bytes according to linux metrics. It must be equal (almost equal) to
	// `used_index`. If it differs more than in 1%, then it means that there are lot of unknown files.
	// If this disk is used exclusively for Raid, then it may mean that some blobs are lost from
	// database and repairing is required.
	// Format: bytes (bytes)
	SetUsed(Bytes) RaidDiskConfigStats
	// Used disk space in bytes according to internal database index.
	// Format: bytes (bytes)
	UsedIndex() *Bytes
	// Used disk space in bytes according to internal database index.
	// Format: bytes (bytes)
	SetUsedIndex(Bytes) RaidDiskConfigStats
}

type RaidDiskErrors interface {
	// Total number of connection timeout errors
	// Example: 1
	ConnectionTimeout() *int
	// Total number of connection timeout errors
	// Example: 1
	SetConnectionTimeout(int) RaidDiskErrors
	// Total number of permission denied errors
	// Example: 1
	Eacces() *int
	// Total number of permission denied errors
	// Example: 1
	SetEacces(int) RaidDiskErrors
	// Total number of temporarily unavailable errors
	// Example: 1
	Eagain() *int
	// Total number of temporarily unavailable errors
	// Example: 1
	SetEagain(int) RaidDiskErrors
	// Total number of file busy errors
	// Example: 1
	Ebusy() *int
	// Total number of file busy errors
	// Example: 1
	SetEbusy(int) RaidDiskErrors
	// Total number of connection refused errors
	// Example: 1
	Econnrefused() *int
	// Total number of connection refused errors
	// Example: 1
	SetEconnrefused(int) RaidDiskErrors
	// Total number of disk quota exceeded errors
	// Example: 1
	Edquot() *int
	// Total number of disk quota exceeded errors
	// Example: 1
	SetEdquot(int) RaidDiskErrors
	// Total number of too many open files errors
	// Example: 1
	Emfile() *int
	// Total number of too many open files errors
	// Example: 1
	SetEmfile(int) RaidDiskErrors
	// Total number of no such device errors
	// Example: 1
	Enodev() *int
	// Total number of no such device errors
	// Example: 1
	SetEnodev(int) RaidDiskErrors
	// Total number of no such file or directory errors
	// Example: 1
	Enoent() *int
	// Total number of no such file or directory errors
	// Example: 1
	SetEnoent(int) RaidDiskErrors
	// Total number of no space left on device errors
	// Example: 1
	Enospc() *int
	// Total number of no space left on device errors
	// Example: 1
	SetEnospc(int) RaidDiskErrors
	// Total number of read-only file system errors
	// Example: 1
	Erofs() *int
	// Total number of read-only file system errors
	// Example: 1
	SetErofs(int) RaidDiskErrors
	// Total number of non-existing domain errors
	// Example: 1
	Nxdomain() *int
	// Total number of non-existing domain errors
	// Example: 1
	SetNxdomain(int) RaidDiskErrors
	// Total number of other errors
	// Example: 1
	Other() *int
	// Total number of other errors
	// Example: 1
	SetOther(int) RaidDiskErrors
	// Total number of SSL errors
	// Example: 1
	SslError() *int
	// Total number of SSL errors
	// Example: 1
	SetSslError(int) RaidDiskErrors
}

type RaidDiskStats interface {
	// Errors of using the disk.
	Errors() RaidDiskErrors
	// Errors of using the disk.
	SetErrors(RaidDiskErrors) RaidDiskStats
	// Disk I/O utilization percentage from `/proc/devstat`.
	// Format: percent (percent)
	IoUsage() *Percent
	// Disk I/O utilization percentage from `/proc/devstat`.
	// Format: percent (percent)
	SetIoUsage(Percent) RaidDiskStats
	// The estimated migration end time, in UTC seconds.
	// Format: utc (Unix timestamp in seconds)
	MigrationEta() *Utc
	// The estimated migration end time, in UTC seconds.
	// Format: utc (Unix timestamp in seconds)
	SetMigrationEta(Utc) RaidDiskStats
	// The speed of copying the last blob, in bytes per second.
	// Format: speed (speed)
	MigrationSpeed() *Speed
	// The speed of copying the last blob, in bytes per second.
	// Format: speed (speed)
	SetMigrationSpeed(Speed) RaidDiskStats
	// The time when the values of `migration_speed` and `migration_eta` were last updated.
	// Format: utc (Unix timestamp in seconds)
	MigrationUpdated() *Utc
	// The time when the values of `migration_speed` and `migration_eta` were last updated.
	// Format: utc (Unix timestamp in seconds)
	SetMigrationUpdated(Utc) RaidDiskStats
	// The mode of using the disk.
	// Example: keep
	Mode() *RaidDiskMode
	// The mode of using the disk.
	// Example: keep
	SetMode(RaidDiskMode) RaidDiskStats
	// Whether the disk is mounted correctly.
	Mounted() *bool
	// Whether the disk is mounted correctly.
	SetMounted(bool) RaidDiskStats
}

// Required: streampoint_key
type RproxyConfig interface {
	// Path to authorization backend on the endpoint to check if the Agents are allowed to connect.
	EndpointAuth() *string
	// Path to authorization backend on the endpoint to check if the Agents are allowed to connect.
	SetEndpointAuth(string) RproxyConfig
	// Configuration of port handlers.
	ForwardPorts() map[string]ForwardPortsConfig
	// Configuration of port handlers.
	SetForwardPorts(map[string]ForwardPortsConfig) RproxyConfig
	// The streamer ID key.
	StreampointKey() string
	// The streamer ID key.
	SetStreampointKey(string) RproxyConfig
}

type ServerConfigBase interface {
	// The cluster key to unite several servers with the same key into a cluster.
	// Example: xS6i6Q3DCc5nEvnu
	ClusterKey() *string
	// The cluster key to unite several servers with the same key into a cluster.
	// Example: xS6i6Q3DCc5nEvnu
	SetClusterKey(string) ServerConfigBase
	// The configuration of server domain name and aliases
	ServerNames() []ServerNameConfig
	// The configuration of server domain name and aliases
	SetServerNames([]ServerNameConfig) ServerConfigBase
}

type ServerConfigFull interface {
	// The configuration of event notifications
	EventSinks() []EventSinkConfig
	// The configuration of event notifications
	SetEventSinks([]EventSinkConfig) ServerConfigFull
	// List of HTTP prefixes that can be handled via call to remote http server
	HTTPProxies() []HTTPProxyConfig
	// List of HTTP prefixes that can be handled via call to remote http server
	SetHTTPProxies([]HTTPProxyConfig) ServerConfigFull
	// The configuration of the port forwarding.
	Rproxy() RproxyConfig
	// The configuration of the port forwarding.
	SetRproxy(RproxyConfig) ServerConfigFull
}

// Required: domain
type ServerNameConfig interface {
	// List of domain aliases, used together with the primary name to issue ssl certs
	// Example: [s1.streamer.local s2.streamer.local]
	Aliases() []string
	// List of domain aliases, used together with the primary name to issue ssl certs
	// Example: [s1.streamer.local s2.streamer.local]
	SetAliases([]string) ServerNameConfig
	// Domain names to issue ssl certificates for
	// Example: streamer.local
	Domain() string
	// Domain names to issue ssl certificates for
	// Example: streamer.local
	SetDomain(string) ServerNameConfig
}

type ServerStarted interface {
	// Server started successfully.
	Event() string
	// Server started successfully.
	SetEvent(string) ServerStarted
	// Event identifier.
	EventID() *int
	// Event identifier.
	SetEventID(int) ServerStarted
	// The ID of the started instance.
	InstanceID() *string
	// The ID of the started instance.
	SetInstanceID(string) ServerStarted
	PreviousState() *PreviousServerState
	SetPreviousState(PreviousServerState) ServerStarted
	// Originator of event.
	// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
	// is configured as HTTP/HTTPS url.
	// Example: flussonic.host
	Server() *string
	// Originator of event.
	// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
	// is configured as HTTP/HTTPS url.
	// Example: flussonic.host
	SetServer(string) ServerStarted
	// Unique identifier of the operation.
	// You can use this field to search for events related to same operation.
	// Value of this field is taken from the `X-Trace-Id` header.
	// If `X-Trace-Id` header is not set, it will be generated automatically.
	// Service will use the value of this field to make outgoing requests.
	// Format: uuid (uuid)
	// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
	TraceID() *UUID
	// Unique identifier of the operation.
	// You can use this field to search for events related to same operation.
	// Value of this field is taken from the `X-Trace-Id` header.
	// If `X-Trace-Id` header is not set, it will be generated automatically.
	// Service will use the value of this field to make outgoing requests.
	// Format: uuid (uuid)
	// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
	SetTraceID(UUID) ServerStarted
	// The time of the event registration on the server.
	// Format: utc_ms (Unix timestamp in milliseconds)
	UtcMs() *UtcMs
	// The time of the event registration on the server.
	// Format: utc_ms (Unix timestamp in milliseconds)
	SetUtcMs(UtcMs) ServerStarted
	// Version of Service.
	Version() *string
	// Version of Service.
	SetVersion(string) ServerStarted
}

type ServerStarting interface {
	// Server started booting.
	Event() string
	// Server started booting.
	SetEvent(string) ServerStarting
	// Event identifier.
	EventID() *int
	// Event identifier.
	SetEventID(int) ServerStarting
	// Full version of service with the build number.
	FullVersion() *string
	// Full version of service with the build number.
	SetFullVersion(string) ServerStarting
	// Originator of event.
	// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
	// is configured as HTTP/HTTPS url.
	// Example: flussonic.host
	Server() *string
	// Originator of event.
	// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
	// is configured as HTTP/HTTPS url.
	// Example: flussonic.host
	SetServer(string) ServerStarting
	// Unique identifier of the operation.
	// You can use this field to search for events related to same operation.
	// Value of this field is taken from the `X-Trace-Id` header.
	// If `X-Trace-Id` header is not set, it will be generated automatically.
	// Service will use the value of this field to make outgoing requests.
	// Format: uuid (uuid)
	// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
	TraceID() *UUID
	// Unique identifier of the operation.
	// You can use this field to search for events related to same operation.
	// Value of this field is taken from the `X-Trace-Id` header.
	// If `X-Trace-Id` header is not set, it will be generated automatically.
	// Service will use the value of this field to make outgoing requests.
	// Format: uuid (uuid)
	// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
	SetTraceID(UUID) ServerStarting
	// The time of the event registration on the server.
	// Format: utc_ms (Unix timestamp in milliseconds)
	UtcMs() *UtcMs
	// The time of the event registration on the server.
	// Format: utc_ms (Unix timestamp in milliseconds)
	SetUtcMs(UtcMs) ServerStarting
	// Version of service.
	Version() *string
	// Version of service.
	SetVersion(string) ServerStarting
}

type ServerStatsNetwork interface {
	// Current incoming speed (bitrate) of the data transmission over the network.
	// Format: speed (speed)
	// Example: 400300
	InputKbit() *Speed
	// Current incoming speed (bitrate) of the data transmission over the network.
	// Format: speed (speed)
	// Example: 400300
	SetInputKbit(Speed) ServerStatsNetwork
	// The number of streams that are ready to be served to the clients.
	// Example: 27
	OnlineStreams() *int
	// The number of streams that are ready to be served to the clients.
	// Example: 27
	SetOnlineStreams(int) ServerStatsNetwork
	// The number of opened files.
	// Example: 5
	OpenedFiles() *int
	// The number of opened files.
	// Example: 5
	SetOpenedFiles(int) ServerStatsNetwork
	// Current outgoing speed (bitrate) of the data transmission over the network.
	// Format: speed (speed)
	// Example: 500400
	OutputKbit() *Speed
	// Current outgoing speed (bitrate) of the data transmission over the network.
	// Format: speed (speed)
	// Example: 500400
	SetOutputKbit(Speed) ServerStatsNetwork
	// The number of clients receiving the streams from the server at the moment of request.
	// Example: 2040
	TotalClients() *int
	// The number of clients receiving the streams from the server at the moment of request.
	// Example: 2040
	SetTotalClients(int) ServerStatsNetwork
	// The number of streams created on the server.
	// Example: 45
	TotalStreams() *int
	// The number of streams created on the server.
	// Example: 45
	SetTotalStreams(int) ServerStatsNetwork
}

type ServerStatsStreamer interface {
	// Outbound bandwidth usage (load balancing in `usage` mode is based on this value).
	// Format: percent (percent)
	// Example: 67
	BandwidthUsage() *Percent
	// Outbound bandwidth usage (load balancing in `usage` mode is based on this value).
	// Format: percent (percent)
	// Example: 67
	SetBandwidthUsage(Percent) ServerStatsStreamer
	// Information about errors in the config file.
	ConfigError() ConfigErrorStatus
	// Information about errors in the config file.
	SetConfigError(ConfigErrorStatus) ServerStatsStreamer
	// Information about current external config status
	ConfigExternalStatus() ConfigExternalErrorStatus
	// Information about current external config status
	SetConfigExternalStatus(ConfigExternalErrorStatus) ServerStatsStreamer
	// Current runtime version of config. We do not declare exact structure, but we promise
	// that it will be always comparable and increasing (if server has proper NTP configuration, of course).
	// Right now it is a tuple of server start time and incrementing version of config.
	// Example: [1.636709231e+09 4]
	ConfigVersion() []int
	// Current runtime version of config. We do not declare exact structure, but we promise
	// that it will be always comparable and increasing (if server has proper NTP configuration, of course).
	// Right now it is a tuple of server start time and incrementing version of config.
	// Example: [1.636709231e+09 4]
	SetConfigVersion([]int) ServerStatsStreamer
	// CPU usage on the server.
	// Format: percent (percent)
	// Example: 48
	CpuUsage() *Percent
	// CPU usage on the server.
	// Format: percent (percent)
	// Example: 48
	SetCpuUsage(Percent) ServerStatsStreamer
	// Hostname of your server. Please, use FQDN, do not leave your Linux misconfigured.
	// Example: openapi.flussonic.com
	Hostname() *string
	// Hostname of your server. Please, use FQDN, do not leave your Linux misconfigured.
	// Example: openapi.flussonic.com
	SetHostname(string) ServerStatsStreamer
	// Unique runtime ID of this instance. Updated with the restart.
	// Format: uuid (uuid)
	// Example: 61893b15-75b2-4fcb-b4cf-ae1dd0858ea2
	ID() *UUID
	// Unique runtime ID of this instance. Updated with the restart.
	// Format: uuid (uuid)
	// Example: 61893b15-75b2-4fcb-b4cf-ae1dd0858ea2
	SetID(UUID) ServerStatsStreamer
	// The flag shows if Flussonic runs on Flussonic Coder.
	IsChassis() *bool
	// The flag shows if Flussonic runs on Flussonic Coder.
	SetIsChassis(bool) ServerStatsStreamer
	// The code of the license applied on the server.
	// Example: uO8v12HJhNXVj5gM
	LicenseTxt() *string
	// The code of the license applied on the server.
	// Example: uO8v12HJhNXVj5gM
	SetLicenseTxt(string) ServerStatsStreamer
	// The license type.
	LicenseType() *LicenseType
	// The license type.
	SetLicenseType(LicenseType) ServerStatsStreamer
	// Memory usage on the server.
	// Format: percent (percent)
	// Example: 27
	MemoryUsage() *Percent
	// Memory usage on the server.
	// Format: percent (percent)
	// Example: 27
	SetMemoryUsage(Percent) ServerStatsStreamer
	// Notification about a newer version in the repository.
	// Format: server_version (server_version)
	// Example: 22.01
	NextVersion() *ServerVersion
	// Notification about a newer version in the repository.
	// Format: server_version (server_version)
	// Example: 22.01
	SetNextVersion(ServerVersion) ServerStatsStreamer
	// The list of disk partitions on the server.
	Partitions() []PartitionStats
	// The list of disk partitions on the server.
	SetPartitions([]PartitionStats) ServerStatsStreamer
	// Shows if rproxy is configured.
	Rproxy() *bool
	// Shows if rproxy is configured.
	SetRproxy(bool) ServerStatsStreamer
	// Shows if rproxy is running.
	RproxyRunning() *bool
	// Shows if rproxy is running.
	SetRproxyRunning(bool) ServerStatsStreamer
	// Erlang scheduler load.
	// Format: percent (percent)
	// Example: 40
	SchedulerLoad() *Percent
	// Erlang scheduler load.
	// Format: percent (percent)
	// Example: 40
	SetSchedulerLoad(Percent) ServerStatsStreamer
	// *Flussonic* will always try to start even if there are severe errors that do not
	// allow functioning.
	// `starting` status means you should wait for some time (not more than
	// a minute).
	// `running` status means all configuration was loaded. However, the status does not provide
	// an information about your streams and the quality of provided service.
	// All other statuses mean there are some severe problems on the server
	// that cannot be repaired by Flussonic itself.
	StreamerStatus() *ServerStatsStreamerStatus
	// *Flussonic* will always try to start even if there are severe errors that do not
	// allow functioning.
	// `starting` status means you should wait for some time (not more than
	// a minute).
	// `running` status means all configuration was loaded. However, the status does not provide
	// an information about your streams and the quality of provided service.
	// All other statuses mean there are some severe problems on the server
	// that cannot be repaired by Flussonic itself.
	SetStreamerStatus(ServerStatsStreamerStatus) ServerStatsStreamer
	// Human-readable format of errors and alerts that need to be fixed.
	// Provided by some *Flussonic* subsystems.
	TextAlerts() map[string]string
	// Human-readable format of errors and alerts that need to be fixed.
	// Provided by some *Flussonic* subsystems.
	SetTextAlerts(map[string]string) ServerStatsStreamer
	// Deprecated field. Will be deleted at 22.03
	// Total server bandwidth.
	// Format: speed (speed)
	TotalBandwidth() *Speed
	// Deprecated field. Will be deleted at 22.03
	// Total server bandwidth.
	// Format: speed (speed)
	SetTotalBandwidth(Speed) ServerStatsStreamer
	// Shows if the server's CPU can be used for transcoding
	// (i.e. if the `flussonic-transcoder` package is installed on the server).
	Transcoder() *bool
	// Shows if the server's CPU can be used for transcoding
	// (i.e. if the `flussonic-transcoder` package is installed on the server).
	SetTranscoder(bool) ServerStatsStreamer
	// Statistics on the devices used for transcoding.
	TranscoderDevices() []TranscoderDeviceStats
	// Statistics on the devices used for transcoding.
	SetTranscoderDevices([]TranscoderDeviceStats) ServerStatsStreamer
	// The server uptime.
	// Format: seconds (seconds)
	// Example: 4.325502e+06
	Uptime() *Seconds
	// The server uptime.
	// Format: seconds (seconds)
	// Example: 4.325502e+06
	SetUptime(Seconds) ServerStatsStreamer
	// Shows if Flussonic Watcher is enabled in the license.
	Vsaas() *bool
	// Shows if Flussonic Watcher is enabled in the license.
	SetVsaas(bool) ServerStatsStreamer
	// Shows if Watcher branding is enabled in the license.
	VsaasBranding() *bool
	// Shows if Watcher branding is enabled in the license.
	SetVsaasBranding(bool) ServerStatsStreamer
	// Shows if Watcher is currently running.
	VsaasRunning() *bool
	// Shows if Watcher is currently running.
	SetVsaasRunning(bool) ServerStatsStreamer
}

type ServerStatsWhoami interface {
	// Build version
	Build() *int
	// Build version
	SetBuild(int) ServerStatsWhoami
	// Current response time
	// Format: utc_ms (Unix timestamp in milliseconds)
	Now() *UtcMs
	// Current response time
	// Format: utc_ms (Unix timestamp in milliseconds)
	SetNow(UtcMs) ServerStatsWhoami
	// Package version of the server. Might be simple a number of release like 21.11 or longer if you have a rolling release installed.
	// Format: server_version (server_version)
	// Example: 23.04
	ServerVersion() *ServerVersion
	// Package version of the server. Might be simple a number of release like 21.11 or longer if you have a rolling release installed.
	// Format: server_version (server_version)
	// Example: 23.04
	SetServerVersion(ServerVersion) ServerStatsWhoami
	// Boot time of this instance.
	// Format: utc (Unix timestamp in seconds)
	// Example: 1.639337825e+09
	StartedAt() *Utc
	// Boot time of this instance.
	// Format: utc (Unix timestamp in seconds)
	// Example: 1.639337825e+09
	SetStartedAt(Utc) ServerStatsWhoami
}

type SrtConfig interface {
	// Whether both connection parties must have the same password set (including empty, in other words, with no encryption).
	// If the passwords do not match or only one side is unencrypted, the connection is rejected.
	// The default value is `true`.
	// Example: true
	Enforcedencryption() *bool
	// Whether both connection parties must have the same password set (including empty, in other words, with no encryption).
	// If the passwords do not match or only one side is unencrypted, the connection is rejected.
	// The default value is `true`.
	// Example: true
	SetEnforcedencryption(bool) SrtConfig
	// The latency value for both directions of the socket.
	// By default initial value latency is 0 when transmitting and 120ms when receiving video.
	// Actual value established after connection handshake.
	// Increased value helps tolerate network losses and delays.
	// Format: milliseconds (milliseconds)
	// Example: 150
	Latency() *Milliseconds
	// The latency value for both directions of the socket.
	// By default initial value latency is 0 when transmitting and 120ms when receiving video.
	// Actual value established after connection handshake.
	// Increased value helps tolerate network losses and delays.
	// Format: milliseconds (milliseconds)
	// Example: 150
	SetLatency(Milliseconds) SrtConfig
	// The time, in seconds, that the socket waits for the unsent data before closing.
	// The default value is 180.
	// Format: seconds (seconds)
	// Example: 15
	Linger() *Seconds
	// The time, in seconds, that the socket waits for the unsent data before closing.
	// The default value is 180.
	// Format: seconds (seconds)
	// Example: 15
	SetLinger(Seconds) SrtConfig
	// The minimum SRT version that is required from the peer for SRT publication.
	// Pattern: ^[0-9]+\.[0-9]+\.[0-9]+$
	// Example: 1.1.0
	Minversion() *string
	// The minimum SRT version that is required from the peer for SRT publication.
	// Pattern: ^[0-9]+\.[0-9]+\.[0-9]+$
	// Example: 1.1.0
	SetMinversion(string) SrtConfig
	// The password for the encrypted transmission.
	// Its length should be not less than 10 and not more than 79 characters.
	// Unlike [password](https://flussonic.com/doc/api/reference/#tag/stream/operation/stream_save%7Cbody%7Cpassword),
	// the passphrase is not transmitted openly but is used to encrypt the key that is transmitted by the Caller
	// and decoded by Listener.
	// Example: 9876543210
	Passphrase() *string
	// The password for the encrypted transmission.
	// Its length should be not less than 10 and not more than 79 characters.
	// Unlike [password](https://flussonic.com/doc/api/reference/#tag/stream/operation/stream_save%7Cbody%7Cpassword),
	// the passphrase is not transmitted openly but is used to encrypt the key that is transmitted by the Caller
	// and decoded by Listener.
	// Example: 9876543210
	SetPassphrase(string) SrtConfig
	// Listening port or a `host:port` pair for the SRT configuration.
	// Must be unique on the whole server.
	// Example: 9050
	Port() *ListenSpec
	// Listening port or a `host:port` pair for the SRT configuration.
	// Must be unique on the whole server.
	// Example: 9050
	SetPort(*ListenSpec) SrtConfig
	// A string of maximum 512 characters set on the socket before the connection.
	// This string is a part of a callback that is sent by the caller and regisered by the listener.
	// Based on this information the listener can accept or reject the connection, select the desired data stream, or set an appropriate passphrase for the connection.
	// Its format is `#!::` optionally followed by the parameters:
	// * `r=` - stream name
	// * `m=` - mode expected for the connection: `publish` (if the caller wants to send the stream data) or `request` (if the caller wants to receive the stream).
	// * `password=` - a password for the authorization in a publish session (not recommended, better use `passphrase` option instead)
	// During SRT sessions the following parameters are automaticly added to streamid:
	// * `s=` - the identifier of a session
	// * `a=` - Flussonic version
	// NOTE: you can specify a string in the format you need; to disable this extension, you need specify empty string.
	// Example: #!::r=my-stream,m=publish
	Streamid() *string
	// A string of maximum 512 characters set on the socket before the connection.
	// This string is a part of a callback that is sent by the caller and regisered by the listener.
	// Based on this information the listener can accept or reject the connection, select the desired data stream, or set an appropriate passphrase for the connection.
	// Its format is `#!::` optionally followed by the parameters:
	// * `r=` - stream name
	// * `m=` - mode expected for the connection: `publish` (if the caller wants to send the stream data) or `request` (if the caller wants to receive the stream).
	// * `password=` - a password for the authorization in a publish session (not recommended, better use `passphrase` option instead)
	// During SRT sessions the following parameters are automaticly added to streamid:
	// * `s=` - the identifier of a session
	// * `a=` - Flussonic version
	// NOTE: you can specify a string in the format you need; to disable this extension, you need specify empty string.
	// Example: #!::r=my-stream,m=publish
	SetStreamid(string) SrtConfig
	// Data transmission timeout in seconds.
	// If set to `false` then data transmission time is unlimited. This is a defalut behavior.
	// Example: 10
	Timeout() any
	// Data transmission timeout in seconds.
	// If set to `false` then data transmission time is unlimited. This is a defalut behavior.
	// Example: 10
	SetTimeout(any) SrtConfig
	// Required SRT version.
	// Pattern: ^[0-9]+\.[0-9]+\.[0-9]+$
	// Example: 1.3.0
	Version() *string
	// Required SRT version.
	// Pattern: ^[0-9]+\.[0-9]+\.[0-9]+$
	// Example: 1.3.0
	SetVersion(string) SrtConfig
}

type SrtConfigBase interface {
	// Whether both connection parties must have the same password set (including empty, in other words, with no encryption).
	// If the passwords do not match or only one side is unencrypted, the connection is rejected.
	// The default value is `true`.
	// Example: true
	Enforcedencryption() *bool
	// Whether both connection parties must have the same password set (including empty, in other words, with no encryption).
	// If the passwords do not match or only one side is unencrypted, the connection is rejected.
	// The default value is `true`.
	// Example: true
	SetEnforcedencryption(bool) SrtConfigBase
	// The latency value for both directions of the socket.
	// By default initial value latency is 0 when transmitting and 120ms when receiving video.
	// Actual value established after connection handshake.
	// Increased value helps tolerate network losses and delays.
	// Format: milliseconds (milliseconds)
	// Example: 150
	Latency() *Milliseconds
	// The latency value for both directions of the socket.
	// By default initial value latency is 0 when transmitting and 120ms when receiving video.
	// Actual value established after connection handshake.
	// Increased value helps tolerate network losses and delays.
	// Format: milliseconds (milliseconds)
	// Example: 150
	SetLatency(Milliseconds) SrtConfigBase
	// The time, in seconds, that the socket waits for the unsent data before closing.
	// The default value is 180.
	// Format: seconds (seconds)
	// Example: 15
	Linger() *Seconds
	// The time, in seconds, that the socket waits for the unsent data before closing.
	// The default value is 180.
	// Format: seconds (seconds)
	// Example: 15
	SetLinger(Seconds) SrtConfigBase
	// The minimum SRT version that is required from the peer for SRT publication.
	// Pattern: ^[0-9]+\.[0-9]+\.[0-9]+$
	// Example: 1.1.0
	Minversion() *string
	// The minimum SRT version that is required from the peer for SRT publication.
	// Pattern: ^[0-9]+\.[0-9]+\.[0-9]+$
	// Example: 1.1.0
	SetMinversion(string) SrtConfigBase
	// The password for the encrypted transmission.
	// Its length should be not less than 10 and not more than 79 characters.
	// Unlike [password](https://flussonic.com/doc/api/reference/#tag/stream/operation/stream_save%7Cbody%7Cpassword),
	// the passphrase is not transmitted openly but is used to encrypt the key that is transmitted by the Caller
	// and decoded by Listener.
	// Example: 9876543210
	Passphrase() *string
	// The password for the encrypted transmission.
	// Its length should be not less than 10 and not more than 79 characters.
	// Unlike [password](https://flussonic.com/doc/api/reference/#tag/stream/operation/stream_save%7Cbody%7Cpassword),
	// the passphrase is not transmitted openly but is used to encrypt the key that is transmitted by the Caller
	// and decoded by Listener.
	// Example: 9876543210
	SetPassphrase(string) SrtConfigBase
	// A string of maximum 512 characters set on the socket before the connection.
	// This string is a part of a callback that is sent by the caller and regisered by the listener.
	// Based on this information the listener can accept or reject the connection, select the desired data stream, or set an appropriate passphrase for the connection.
	// Its format is `#!::` optionally followed by the parameters:
	// * `r=` - stream name
	// * `m=` - mode expected for the connection: `publish` (if the caller wants to send the stream data) or `request` (if the caller wants to receive the stream).
	// * `password=` - a password for the authorization in a publish session (not recommended, better use `passphrase` option instead)
	// During SRT sessions the following parameters are automaticly added to streamid:
	// * `s=` - the identifier of a session
	// * `a=` - Flussonic version
	// NOTE: you can specify a string in the format you need; to disable this extension, you need specify empty string.
	// Example: #!::r=my-stream,m=publish
	Streamid() *string
	// A string of maximum 512 characters set on the socket before the connection.
	// This string is a part of a callback that is sent by the caller and regisered by the listener.
	// Based on this information the listener can accept or reject the connection, select the desired data stream, or set an appropriate passphrase for the connection.
	// Its format is `#!::` optionally followed by the parameters:
	// * `r=` - stream name
	// * `m=` - mode expected for the connection: `publish` (if the caller wants to send the stream data) or `request` (if the caller wants to receive the stream).
	// * `password=` - a password for the authorization in a publish session (not recommended, better use `passphrase` option instead)
	// During SRT sessions the following parameters are automaticly added to streamid:
	// * `s=` - the identifier of a session
	// * `a=` - Flussonic version
	// NOTE: you can specify a string in the format you need; to disable this extension, you need specify empty string.
	// Example: #!::r=my-stream,m=publish
	SetStreamid(string) SrtConfigBase
	// Required SRT version.
	// Pattern: ^[0-9]+\.[0-9]+\.[0-9]+$
	// Example: 1.3.0
	Version() *string
	// Required SRT version.
	// Pattern: ^[0-9]+\.[0-9]+\.[0-9]+$
	// Example: 1.3.0
	SetVersion(string) SrtConfigBase
}

type StreamConfig interface {
	// Whether to add an audio-only version of an HLS stream.
	// Used to create App Store compliant HLS streams to deliver the content to Apple iOS devices.
	// Example: true
	AddAudioOnly() *bool
	// Whether to add an audio-only version of an HLS stream.
	// Used to create App Store compliant HLS streams to deliver the content to Apple iOS devices.
	// Example: true
	SetAddAudioOnly(bool) StreamConfig
	// If a connected source does not send audio data within this timeout period (in seconds),
	// the source connection is considered to be lost.
	// This is a default configuration for a stream, can be modified for any input.
	// Format: seconds (seconds)
	// Example: 20
	AudioTimeout() *Seconds
	// If a connected source does not send audio data within this timeout period (in seconds),
	// the source connection is considered to be lost.
	// This is a default configuration for a stream, can be modified for any input.
	// Format: seconds (seconds)
	// Example: 20
	SetAudioTimeout(Seconds) StreamConfig
	// When all inputs are down, this can be used to show at least something to users.
	// It is important to understand that backup video behaves differently, not as inputs.
	// It is not a _last input_ in the list. After any input stops sending frames, timer starts.
	// After `source_timeout` seconds backup starts working, while all other inputs are still trying to
	// connect and start working.
	// So backup and all inputs are working in parallel.
	Backup() BackupConfig
	// When all inputs are down, this can be used to show at least something to users.
	// It is important to understand that backup video behaves differently, not as inputs.
	// It is not a _last input_ in the list. After any input stops sending frames, timer starts.
	// After `source_timeout` seconds backup starts working, while all other inputs are still trying to
	// connect and start working.
	// So backup and all inputs are working in parallel.
	SetBackup(BackupConfig) StreamConfig
	// Chunk duration in LL-HLS manifest to be used for tunning latency.
	// Format: milliseconds (milliseconds)
	// Example: 200
	ChunkDuration() *Milliseconds
	// Chunk duration in LL-HLS manifest to be used for tunning latency.
	// Format: milliseconds (milliseconds)
	// Example: 200
	SetChunkDuration(Milliseconds) StreamConfig
	// Stream's lifetime after the last client was disconnected (can be expressed in *seconds* or set to `False`).
	// Applicable to on-demand streams **only**.
	// Example: 485
	ClientsTimeout() any
	// Stream's lifetime after the last client was disconnected (can be expressed in *seconds* or set to `False`).
	// Applicable to on-demand streams **only**.
	// Example: 485
	SetClientsTimeout(any) StreamConfig
	// Human-readable description of the stream.
	// Example: This is a test stream
	Comment() *string
	// Human-readable description of the stream.
	// Example: This is a test stream
	SetComment(string) StreamConfig
	// Part of the effective config from the configuration file.
	ConfigOnDisk() StreamConfigStripped
	// Part of the effective config from the configuration file.
	SetConfigOnDisk(StreamConfigStripped) StreamConfig
	// Whether a stream is disabled. Disabled streams are inactive and do not run.
	// Displayed only with the API calls.
	// Example: false
	Disabled() *bool
	// Whether a stream is disabled. Disabled streams are inactive and do not run.
	// Displayed only with the API calls.
	// Example: false
	SetDisabled(bool) StreamConfig
	// Configuraton of Digital Rights Management system (DRM).
	Drm() DrmSpec
	// Configuraton of Digital Rights Management system (DRM).
	SetDrm(DrmSpec) StreamConfig
	// This parameter allows to manage subtitles in an output stream.
	// Example: replace
	Dvbocr() *StreamConfigInputDvbocr
	// This parameter allows to manage subtitles in an output stream.
	// Example: replace
	SetDvbocr(StreamConfigInputDvbocr) StreamConfig
	// DVR configuraton.
	Dvr() StreamDvrSpec
	// DVR configuraton.
	SetDvr(StreamDvrSpec) StreamConfig
	// Whether to extract EPG from the input.
	// Example: true
	EpgEnabled() *bool
	// Whether to extract EPG from the input.
	// Example: true
	SetEpgEnabled(bool) StreamConfig
	// Whether to enable SCTE-35 ad insertion markers signaling in HLS manifest.
	// Ad markers can be included in SCTE-35 (`scte35`), AWS (`aws`), EXT-X-DATERANGE (`rfc8216`) formats or not included (`false`).
	// Example: scte35
	HlsScte35() *StreamConfigMediaHlsScte35
	// Whether to enable SCTE-35 ad insertion markers signaling in HLS manifest.
	// Ad markers can be included in SCTE-35 (`scte35`), AWS (`aws`), EXT-X-DATERANGE (`rfc8216`) formats or not included (`false`).
	// Example: scte35
	SetHlsScte35(StreamConfigMediaHlsScte35) StreamConfig
	// Use this option for fine-grained control over each input track.
	// You can select, rename, change name and title for each video, audio track.
	InputMediaInfo() InputMediaInfo
	// Use this option for fine-grained control over each input track.
	// You can select, rename, change name and title for each video, audio track.
	SetInputMediaInfo(InputMediaInfo) StreamConfig
	// List of stream inputs.
	// ***Important:*** A stream without any inputs can receive video frames **only** if backup file is specified.
	Inputs() []StreamInput
	// List of stream inputs.
	// ***Important:*** A stream without any inputs can receive video frames **only** if backup file is specified.
	SetInputs([]StreamInput) StreamConfig
	// A key to sign jpeg_snapshot requests
	JpegSnapshotSignKey() *string
	// A key to sign jpeg_snapshot requests
	SetJpegSnapshotSignKey(string) StreamConfig
	// Stream labels in key value format.
	// Key is a string in unix_name format (alphanumeric characters, underscores, hyphens and periods).
	// See [Layouter schema](https://flussonic.com/doc/api/layouter/#tag/stream/operation/streams_list/response%7Cstreams%7Clabels)
	// for more details.
	Labels() map[string]UnixName
	// Stream labels in key value format.
	// Key is a string in unix_name format (alphanumeric characters, underscores, hyphens and periods).
	// See [Layouter schema](https://flussonic.com/doc/api/layouter/#tag/stream/operation/streams_list/response%7Cstreams%7Clabels)
	// for more details.
	SetLabels(map[string]UnixName) StreamConfig
	// The maximum time that Media Server will set for attempts to reconnect to sources when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	MaxRetryTimeout() *Seconds
	// The maximum time that Media Server will set for attempts to reconnect to sources when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	SetMaxRetryTimeout(Seconds) StreamConfig
	// Deprecated field. Will be deleted at 23.12
	// The param is deprecated and now used only for onvif_url and onvif_profile options.
	Meta() map[string]string
	// Deprecated field. Will be deleted at 23.12
	// The param is deprecated and now used only for onvif_url and onvif_profile options.
	SetMeta(map[string]string) StreamConfig
	// It allows to specify pack information about ac3 for outgoing MPEGTS-TS streams. The default value is `system_b`.
	MpegtsAc3() *OutputMpegtsAc3
	// It allows to specify pack information about ac3 for outgoing MPEGTS-TS streams. The default value is `system_b`.
	SetMpegtsAc3(OutputMpegtsAc3) StreamConfig
	// This parameter sets PIDs values for outgoing MPEG-TS streams. PID contains information about the TS package content and can be decoded according to special service tables.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks. Tracks are numbered starting from one.
	// The code `a1=123` sets a PID value for the first audio track. It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, `t0=100` sets PID=101 for the first track, 102 for the second, and so on. Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	MpegtsPids() OutputMpegtsPids
	// This parameter sets PIDs values for outgoing MPEG-TS streams. PID contains information about the TS package content and can be decoded according to special service tables.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks. Tracks are numbered starting from one.
	// The code `a1=123` sets a PID value for the first audio track. It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, `t0=100` sets PID=101 for the first track, 102 for the second, and so on. Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	SetMpegtsPids(OutputMpegtsPids) StreamConfig
	// Globally unique stream name.
	// Note that the name could not be changed after the stream is created.
	// Format: media_name (media_name)
	// Examples: Decklink-Stream, Dektec-Stream, hockey1, mylive/bunny, test_stream
	Name() MediaName
	// Globally unique stream name.
	// Note that the name could not be changed after the stream is created.
	// Format: media_name (media_name)
	// Examples: Decklink-Stream, Dektec-Stream, hockey1, mylive/bunny, test_stream
	SetName(MediaName) StreamConfig
	// Where the stream is initialized: config, user play/publication, or remote
	// cluster server.
	// Example: config
	NamedBy() *NamedBy
	// Where the stream is initialized: config, user play/publication, or remote
	// cluster server.
	// Example: config
	SetNamedBy(NamedBy) StreamConfig
	// Configuration of authorization backend for play sessions.
	OnPlay() AuthSpec
	// Configuration of authorization backend for play sessions.
	SetOnPlay(AuthSpec) StreamConfig
	// Configuration of authorization backend for publish sessions.
	OnPublish() AuthSpec
	// Configuration of authorization backend for publish sessions.
	SetOnPublish(AuthSpec) StreamConfig
	// This parameter sets playback HTTP headers for streams.
	PlaybackHeaders() []PlaybackHeaders
	// This parameter sets playback HTTP headers for streams.
	SetPlaybackHeaders([]PlaybackHeaders) StreamConfig
	// Position of the stream in order of streams in the config file, if declared.
	// Format: sort_index (sort_index)
	// Example: 2
	Position() *SortIndex
	// Position of the stream in order of streams in the config file, if declared.
	// Format: sort_index (sort_index)
	// Example: 2
	SetPosition(SortIndex) StreamConfig
	// The time (in seconds) that Media Server reserves for preloading the data, i. e. *buffering*.
	// Prepush is always defined through GoP, but this option provides you with a more flexible way
	// to configure the buffer size, e. g. a 1-3 or 7-10 seconds time interval.
	// The bigger the buffer size, the better the user experience is for the users
	// with a bad internet connection. However, the latency also increases.
	// If set to `False` to remove the latency, the stream's start time
	// increases. To decrease it, reduce the GoP size and make the bitrate higher
	// or the video quality lower.
	// Example: false
	Prepush() any
	// The time (in seconds) that Media Server reserves for preloading the data, i. e. *buffering*.
	// Prepush is always defined through GoP, but this option provides you with a more flexible way
	// to configure the buffer size, e. g. a 1-3 or 7-10 seconds time interval.
	// The bigger the buffer size, the better the user experience is for the users
	// with a bad internet connection. However, the latency also increases.
	// If set to `False` to remove the latency, the stream's start time
	// increases. To decrease it, reduce the GoP size and make the bitrate higher
	// or the video quality lower.
	// Example: false
	SetPrepush(any) StreamConfig
	// Configuration to allow/forbid playing the stream via various protocols.
	// - If the `whitelist` option is set to 'true', the server allows a playback only for listed protocols;
	// - If the `whitelist` option is set to 'false', the server forbids a playback for listed protocols;
	// - Server allows a playback for all the protocols by default.
	Protocols() PlayProtocolsSpec
	// Configuration to allow/forbid playing the stream via various protocols.
	// - If the `whitelist` option is set to 'true', the server allows a playback only for listed protocols;
	// - If the `whitelist` option is set to 'false', the server forbids a playback for listed protocols;
	// - Server allows a playback for all the protocols by default.
	SetProtocols(PlayProtocolsSpec) StreamConfig
	// Deprecated field. Will be deleted at 25.03
	// Human-readable name of the content provider. Used, for example, for MPEG-TS.
	// Deprecated, use `input_media_info.provider` instead
	// Example: SportsTV
	Provider() *string
	// Deprecated field. Will be deleted at 25.03
	// Human-readable name of the content provider. Used, for example, for MPEG-TS.
	// Deprecated, use `input_media_info.provider` instead
	// Example: SportsTV
	SetProvider(string) StreamConfig
	// A list of pushes. When a server initiates the connection and sends a stream
	// to other server(s), it is called a `push`.
	Pushes() []StreamPush
	// A list of pushes. When a server initiates the connection and sends a stream
	// to other server(s), it is called a `push`.
	SetPushes([]StreamPush) StreamConfig
	// How often to re-check secondary inputs. If this option is not set than check is never performed.
	// Format: seconds (seconds)
	// Example: 120
	RecheckSecondaryInputsInterval() *Seconds
	// How often to re-check secondary inputs. If this option is not set than check is never performed.
	// Format: seconds (seconds)
	// Example: 120
	SetRecheckSecondaryInputsInterval(Seconds) StreamConfig
	// Number of attempts for the server to reconnect to a data source.
	// Applicable to on-demand streams **only**. If not defined, server will constantly try to reconnect (unlimited number of retries).
	// If the input does not become active after specified amount of attempts, stream shuts down till the next user request.
	RetryLimit() *int
	// Number of attempts for the server to reconnect to a data source.
	// Applicable to on-demand streams **only**. If not defined, server will constantly try to reconnect (unlimited number of retries).
	// If the input does not become active after specified amount of attempts, stream shuts down till the next user request.
	SetRetryLimit(int) StreamConfig
	// Number of segments stored in memory for the segment-based protocols, such as HLS and DASH.
	// Added to HLS live manifest. Do not forget that one more segment is stored for stale clients
	// that come too late, but the latest segment is not shown in the manifest.
	// Example: 4
	SegmentCount() *int
	// Number of segments stored in memory for the segment-based protocols, such as HLS and DASH.
	// Added to HLS live manifest. Do not forget that one more segment is stored for stale clients
	// that come too late, but the latest segment is not shown in the manifest.
	// Example: 4
	SetSegmentCount(int) StreamConfig
	// The time of the segment duration. Used for the protocols like HLS or DASH.
	// The disk config offers this value in seconds.
	// Example: 5000
	SegmentDuration() *Milliseconds
	// The time of the segment duration. Used for the protocols like HLS or DASH.
	// The disk config offers this value in seconds.
	// Example: 5000
	SetSegmentDuration(Milliseconds) StreamConfig
	// If a connected source does not send any data within this timeout period (in seconds),
	// the source connection is considered to be lost.
	// This is a default configuration for a stream, can be modified for any input.
	// Example: 10
	SourceTimeout() any
	// If a connected source does not send any data within this timeout period (in seconds),
	// the source connection is considered to be lost.
	// This is a default configuration for a stream, can be modified for any input.
	// Example: 10
	SetSourceTimeout(any) StreamConfig
	// SRT2 publishing configuration for a stream.
	Srt2Publish() SrtConfig
	// SRT2 publishing configuration for a stream.
	SetSrt2Publish(SrtConfig) StreamConfig
	// Deprecated field. Will be deleted at 24.06
	// Stream name was resolved via `srt_port_resolve` call.
	// See [endpoint](https://flussonic.com/doc/api/config-external/#tag/srt/operation/srt_port_resolve)
	// and [listener](https://flussonic.com/doc/api/reference/#tag/config/operation/config_save%7Cbody%7Clisteners%7Csrt)
	// for feature description.
	// This parameter now lives in `stats` object.
	// Example: false
	SrtPortResolve() *bool
	// Deprecated field. Will be deleted at 24.06
	// Stream name was resolved via `srt_port_resolve` call.
	// See [endpoint](https://flussonic.com/doc/api/config-external/#tag/srt/operation/srt_port_resolve)
	// and [listener](https://flussonic.com/doc/api/reference/#tag/config/operation/config_save%7Cbody%7Clisteners%7Csrt)
	// for feature description.
	// This parameter now lives in `stats` object.
	// Example: false
	SetSrtPortResolve(bool) StreamConfig
	// SRT publishing configuration for a stream.
	SrtPublish() SrtConfig
	// SRT publishing configuration for a stream.
	SetSrtPublish(SrtConfig) StreamConfig
	// Whether a stream is `static` or not.
	// If set to `True` the server will try to keep this stream running even if
	// there are no viewers or errors encountered.
	// Streamer restarts *all* `static` streams even if any internal errors occur
	// and the `static` streams crash.
	// Example: true
	Static() *bool
	// Whether a stream is `static` or not.
	// If set to `True` the server will try to keep this stream running even if
	// there are no viewers or errors encountered.
	// Streamer restarts *all* `static` streams even if any internal errors occur
	// and the `static` streams crash.
	// Example: true
	SetStatic(bool) StreamConfig
	// Stream's metrics and other statistical information.
	Stats() StreamStats
	// Stream's metrics and other statistical information.
	SetStats(StreamStats) StreamConfig
	// Template of the stream.
	// Format: media_name (media_name)
	// Example: sports-hd
	Template() *MediaName
	// Template of the stream.
	// Format: media_name (media_name)
	// Example: sports-hd
	SetTemplate(MediaName) StreamConfig
	// Configuration of thumbnails generator.
	Thumbnails() ThumbnailsSpec
	// Configuration of thumbnails generator.
	SetThumbnails(ThumbnailsSpec) StreamConfig
	// Human-readable title of the stream. Provided for SDT MPEG-TS table or
	// SDP RTSP title parameter.
	// Example: Hockey channel
	Title() *string
	// Human-readable title of the stream. Provided for SDT MPEG-TS table or
	// SDP RTSP title parameter.
	// Example: Hockey channel
	SetTitle(string) StreamConfig
	// Configuration of the transcoder settings.
	// Examples: map[]
	Transcoder() TranscoderOpts
	// Configuration of the transcoder settings.
	// Examples: map[]
	SetTranscoder(TranscoderOpts) StreamConfig
	// Transport protocol for WebRTC.
	Transport() *WebrtcTransport
	// Transport protocol for WebRTC.
	SetTransport(WebrtcTransport) StreamConfig
	// A string starting the addresses of separate segments within a *segment-based* playlists (HLS or DASH).
	// Each sub-playlist is stored on Media Server.
	// If set to `false`, the configured value in a template will be disabled.
	URLPrefix() *URLPrefix
	// A string starting the addresses of separate segments within a *segment-based* playlists (HLS or DASH).
	// Each sub-playlist is stored on Media Server.
	// If set to `false`, the configured value in a template will be disabled.
	SetURLPrefix(*URLPrefix) StreamConfig
	// If a connected source does not send video data within this timeout period (in seconds),
	// the source connection is considered to be lost.
	// This is a default configuration for a stream, can be modified for any input.
	// Format: seconds (seconds)
	// Example: 20
	VideoTimeout() *Seconds
	// If a connected source does not send video data within this timeout period (in seconds),
	// the source connection is considered to be lost.
	// This is a default configuration for a stream, can be modified for any input.
	// Format: seconds (seconds)
	// Example: 20
	SetVideoTimeout(Seconds) StreamConfig
	// Video analytics parameters.
	Vision() VisionSpec
	// Video analytics parameters.
	SetVision(VisionSpec) StreamConfig
	// WebRTC play configuration for a stream.
	WebrtcAbr() WebrtcAbrOpts
	// WebRTC play configuration for a stream.
	SetWebrtcAbr(WebrtcAbrOpts) StreamConfig
}

type StreamConfigAdditional interface {
	// Part of the effective config from the configuration file.
	ConfigOnDisk() StreamConfigStripped
	// Part of the effective config from the configuration file.
	SetConfigOnDisk(StreamConfigStripped) StreamConfigAdditional
	// Stream's metrics and other statistical information.
	Stats() StreamStats
	// Stream's metrics and other statistical information.
	SetStats(StreamStats) StreamConfigAdditional
}

type StreamConfigBase interface {
	// Whether a stream is disabled. Disabled streams are inactive and do not run.
	// Displayed only with the API calls.
	// Example: false
	Disabled() *bool
	// Whether a stream is disabled. Disabled streams are inactive and do not run.
	// Displayed only with the API calls.
	// Example: false
	SetDisabled(bool) StreamConfigBase
	// Whether a stream is `static` or not.
	// If set to `True` the server will try to keep this stream running even if
	// there are no viewers or errors encountered.
	// Streamer restarts *all* `static` streams even if any internal errors occur
	// and the `static` streams crash.
	// Example: true
	Static() *bool
	// Whether a stream is `static` or not.
	// If set to `True` the server will try to keep this stream running even if
	// there are no viewers or errors encountered.
	// Streamer restarts *all* `static` streams even if any internal errors occur
	// and the `static` streams crash.
	// Example: true
	SetStatic(bool) StreamConfigBase
}

type StreamConfigDeprecated interface {
	// Transport protocol for WebRTC.
	Transport() *WebrtcTransport
	// Transport protocol for WebRTC.
	SetTransport(WebrtcTransport) StreamConfigDeprecated
}

type StreamConfigInput interface {
	// If a connected source does not send audio data within this timeout period (in seconds),
	// the source connection is considered to be lost.
	// This is a default configuration for a stream, can be modified for any input.
	// Format: seconds (seconds)
	// Example: 20
	AudioTimeout() *Seconds
	// If a connected source does not send audio data within this timeout period (in seconds),
	// the source connection is considered to be lost.
	// This is a default configuration for a stream, can be modified for any input.
	// Format: seconds (seconds)
	// Example: 20
	SetAudioTimeout(Seconds) StreamConfigInput
	// When all inputs are down, this can be used to show at least something to users.
	// It is important to understand that backup video behaves differently, not as inputs.
	// It is not a _last input_ in the list. After any input stops sending frames, timer starts.
	// After `source_timeout` seconds backup starts working, while all other inputs are still trying to
	// connect and start working.
	// So backup and all inputs are working in parallel.
	Backup() BackupConfig
	// When all inputs are down, this can be used to show at least something to users.
	// It is important to understand that backup video behaves differently, not as inputs.
	// It is not a _last input_ in the list. After any input stops sending frames, timer starts.
	// After `source_timeout` seconds backup starts working, while all other inputs are still trying to
	// connect and start working.
	// So backup and all inputs are working in parallel.
	SetBackup(BackupConfig) StreamConfigInput
	// This parameter allows to manage subtitles in an output stream.
	// Example: replace
	Dvbocr() *StreamConfigInputDvbocr
	// This parameter allows to manage subtitles in an output stream.
	// Example: replace
	SetDvbocr(StreamConfigInputDvbocr) StreamConfigInput
	// Whether to extract EPG from the input.
	// Example: true
	EpgEnabled() *bool
	// Whether to extract EPG from the input.
	// Example: true
	SetEpgEnabled(bool) StreamConfigInput
	// Use this option for fine-grained control over each input track.
	// You can select, rename, change name and title for each video, audio track.
	InputMediaInfo() InputMediaInfo
	// Use this option for fine-grained control over each input track.
	// You can select, rename, change name and title for each video, audio track.
	SetInputMediaInfo(InputMediaInfo) StreamConfigInput
	// List of stream inputs.
	// ***Important:*** A stream without any inputs can receive video frames **only** if backup file is specified.
	Inputs() []StreamInput
	// List of stream inputs.
	// ***Important:*** A stream without any inputs can receive video frames **only** if backup file is specified.
	SetInputs([]StreamInput) StreamConfigInput
	// The maximum time that Media Server will set for attempts to reconnect to sources when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	MaxRetryTimeout() *Seconds
	// The maximum time that Media Server will set for attempts to reconnect to sources when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	SetMaxRetryTimeout(Seconds) StreamConfigInput
	// It allows to specify pack information about ac3 for outgoing MPEGTS-TS streams. The default value is `system_b`.
	MpegtsAc3() *OutputMpegtsAc3
	// It allows to specify pack information about ac3 for outgoing MPEGTS-TS streams. The default value is `system_b`.
	SetMpegtsAc3(OutputMpegtsAc3) StreamConfigInput
	// Deprecated field. Will be deleted at 25.03
	// Human-readable name of the content provider. Used, for example, for MPEG-TS.
	// Deprecated, use `input_media_info.provider` instead
	// Example: SportsTV
	Provider() *string
	// Deprecated field. Will be deleted at 25.03
	// Human-readable name of the content provider. Used, for example, for MPEG-TS.
	// Deprecated, use `input_media_info.provider` instead
	// Example: SportsTV
	SetProvider(string) StreamConfigInput
	// If a connected source does not send any data within this timeout period (in seconds),
	// the source connection is considered to be lost.
	// This is a default configuration for a stream, can be modified for any input.
	// Example: 10
	SourceTimeout() any
	// If a connected source does not send any data within this timeout period (in seconds),
	// the source connection is considered to be lost.
	// This is a default configuration for a stream, can be modified for any input.
	// Example: 10
	SetSourceTimeout(any) StreamConfigInput
	// If a connected source does not send video data within this timeout period (in seconds),
	// the source connection is considered to be lost.
	// This is a default configuration for a stream, can be modified for any input.
	// Format: seconds (seconds)
	// Example: 20
	VideoTimeout() *Seconds
	// If a connected source does not send video data within this timeout period (in seconds),
	// the source connection is considered to be lost.
	// This is a default configuration for a stream, can be modified for any input.
	// Format: seconds (seconds)
	// Example: 20
	SetVideoTimeout(Seconds) StreamConfigInput
}

type StreamConfigMedia interface {
	// Whether to add an audio-only version of an HLS stream.
	// Used to create App Store compliant HLS streams to deliver the content to Apple iOS devices.
	// Example: true
	AddAudioOnly() *bool
	// Whether to add an audio-only version of an HLS stream.
	// Used to create App Store compliant HLS streams to deliver the content to Apple iOS devices.
	// Example: true
	SetAddAudioOnly(bool) StreamConfigMedia
	// Chunk duration in LL-HLS manifest to be used for tunning latency.
	// Format: milliseconds (milliseconds)
	// Example: 200
	ChunkDuration() *Milliseconds
	// Chunk duration in LL-HLS manifest to be used for tunning latency.
	// Format: milliseconds (milliseconds)
	// Example: 200
	SetChunkDuration(Milliseconds) StreamConfigMedia
	// Stream's lifetime after the last client was disconnected (can be expressed in *seconds* or set to `False`).
	// Applicable to on-demand streams **only**.
	// Example: 485
	ClientsTimeout() any
	// Stream's lifetime after the last client was disconnected (can be expressed in *seconds* or set to `False`).
	// Applicable to on-demand streams **only**.
	// Example: 485
	SetClientsTimeout(any) StreamConfigMedia
	// Configuraton of Digital Rights Management system (DRM).
	Drm() DrmSpec
	// Configuraton of Digital Rights Management system (DRM).
	SetDrm(DrmSpec) StreamConfigMedia
	// DVR configuraton.
	Dvr() StreamDvrSpec
	// DVR configuraton.
	SetDvr(StreamDvrSpec) StreamConfigMedia
	// Whether to enable SCTE-35 ad insertion markers signaling in HLS manifest.
	// Ad markers can be included in SCTE-35 (`scte35`), AWS (`aws`), EXT-X-DATERANGE (`rfc8216`) formats or not included (`false`).
	// Example: scte35
	HlsScte35() *StreamConfigMediaHlsScte35
	// Whether to enable SCTE-35 ad insertion markers signaling in HLS manifest.
	// Ad markers can be included in SCTE-35 (`scte35`), AWS (`aws`), EXT-X-DATERANGE (`rfc8216`) formats or not included (`false`).
	// Example: scte35
	SetHlsScte35(StreamConfigMediaHlsScte35) StreamConfigMedia
	// A key to sign jpeg_snapshot requests
	JpegSnapshotSignKey() *string
	// A key to sign jpeg_snapshot requests
	SetJpegSnapshotSignKey(string) StreamConfigMedia
	// Stream labels in key value format.
	// Key is a string in unix_name format (alphanumeric characters, underscores, hyphens and periods).
	// See [Layouter schema](https://flussonic.com/doc/api/layouter/#tag/stream/operation/streams_list/response%7Cstreams%7Clabels)
	// for more details.
	Labels() map[string]UnixName
	// Stream labels in key value format.
	// Key is a string in unix_name format (alphanumeric characters, underscores, hyphens and periods).
	// See [Layouter schema](https://flussonic.com/doc/api/layouter/#tag/stream/operation/streams_list/response%7Cstreams%7Clabels)
	// for more details.
	SetLabels(map[string]UnixName) StreamConfigMedia
	// This parameter sets PIDs values for outgoing MPEG-TS streams. PID contains information about the TS package content and can be decoded according to special service tables.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks. Tracks are numbered starting from one.
	// The code `a1=123` sets a PID value for the first audio track. It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, `t0=100` sets PID=101 for the first track, 102 for the second, and so on. Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	MpegtsPids() OutputMpegtsPids
	// This parameter sets PIDs values for outgoing MPEG-TS streams. PID contains information about the TS package content and can be decoded according to special service tables.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks. Tracks are numbered starting from one.
	// The code `a1=123` sets a PID value for the first audio track. It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, `t0=100` sets PID=101 for the first track, 102 for the second, and so on. Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	SetMpegtsPids(OutputMpegtsPids) StreamConfigMedia
	// Configuration of authorization backend for play sessions.
	OnPlay() AuthSpec
	// Configuration of authorization backend for play sessions.
	SetOnPlay(AuthSpec) StreamConfigMedia
	// Configuration of authorization backend for publish sessions.
	OnPublish() AuthSpec
	// Configuration of authorization backend for publish sessions.
	SetOnPublish(AuthSpec) StreamConfigMedia
	// This parameter sets playback HTTP headers for streams.
	PlaybackHeaders() []PlaybackHeaders
	// This parameter sets playback HTTP headers for streams.
	SetPlaybackHeaders([]PlaybackHeaders) StreamConfigMedia
	// The time (in seconds) that Media Server reserves for preloading the data, i. e. *buffering*.
	// Prepush is always defined through GoP, but this option provides you with a more flexible way
	// to configure the buffer size, e. g. a 1-3 or 7-10 seconds time interval.
	// The bigger the buffer size, the better the user experience is for the users
	// with a bad internet connection. However, the latency also increases.
	// If set to `False` to remove the latency, the stream's start time
	// increases. To decrease it, reduce the GoP size and make the bitrate higher
	// or the video quality lower.
	// Example: false
	Prepush() any
	// The time (in seconds) that Media Server reserves for preloading the data, i. e. *buffering*.
	// Prepush is always defined through GoP, but this option provides you with a more flexible way
	// to configure the buffer size, e. g. a 1-3 or 7-10 seconds time interval.
	// The bigger the buffer size, the better the user experience is for the users
	// with a bad internet connection. However, the latency also increases.
	// If set to `False` to remove the latency, the stream's start time
	// increases. To decrease it, reduce the GoP size and make the bitrate higher
	// or the video quality lower.
	// Example: false
	SetPrepush(any) StreamConfigMedia
	// Configuration to allow/forbid playing the stream via various protocols.
	// - If the `whitelist` option is set to 'true', the server allows a playback only for listed protocols;
	// - If the `whitelist` option is set to 'false', the server forbids a playback for listed protocols;
	// - Server allows a playback for all the protocols by default.
	Protocols() PlayProtocolsSpec
	// Configuration to allow/forbid playing the stream via various protocols.
	// - If the `whitelist` option is set to 'true', the server allows a playback only for listed protocols;
	// - If the `whitelist` option is set to 'false', the server forbids a playback for listed protocols;
	// - Server allows a playback for all the protocols by default.
	SetProtocols(PlayProtocolsSpec) StreamConfigMedia
	// A list of pushes. When a server initiates the connection and sends a stream
	// to other server(s), it is called a `push`.
	Pushes() []StreamPush
	// A list of pushes. When a server initiates the connection and sends a stream
	// to other server(s), it is called a `push`.
	SetPushes([]StreamPush) StreamConfigMedia
	// Number of attempts for the server to reconnect to a data source.
	// Applicable to on-demand streams **only**. If not defined, server will constantly try to reconnect (unlimited number of retries).
	// If the input does not become active after specified amount of attempts, stream shuts down till the next user request.
	RetryLimit() *int
	// Number of attempts for the server to reconnect to a data source.
	// Applicable to on-demand streams **only**. If not defined, server will constantly try to reconnect (unlimited number of retries).
	// If the input does not become active after specified amount of attempts, stream shuts down till the next user request.
	SetRetryLimit(int) StreamConfigMedia
	// Number of segments stored in memory for the segment-based protocols, such as HLS and DASH.
	// Added to HLS live manifest. Do not forget that one more segment is stored for stale clients
	// that come too late, but the latest segment is not shown in the manifest.
	// Example: 4
	SegmentCount() *int
	// Number of segments stored in memory for the segment-based protocols, such as HLS and DASH.
	// Added to HLS live manifest. Do not forget that one more segment is stored for stale clients
	// that come too late, but the latest segment is not shown in the manifest.
	// Example: 4
	SetSegmentCount(int) StreamConfigMedia
	// The time of the segment duration. Used for the protocols like HLS or DASH.
	// The disk config offers this value in seconds.
	// Example: 5000
	SegmentDuration() *Milliseconds
	// The time of the segment duration. Used for the protocols like HLS or DASH.
	// The disk config offers this value in seconds.
	// Example: 5000
	SetSegmentDuration(Milliseconds) StreamConfigMedia
	// Configuration of thumbnails generator.
	Thumbnails() ThumbnailsSpec
	// Configuration of thumbnails generator.
	SetThumbnails(ThumbnailsSpec) StreamConfigMedia
	// Configuration of the transcoder settings.
	// Examples: map[]
	Transcoder() TranscoderOpts
	// Configuration of the transcoder settings.
	// Examples: map[]
	SetTranscoder(TranscoderOpts) StreamConfigMedia
	// A string starting the addresses of separate segments within a *segment-based* playlists (HLS or DASH).
	// Each sub-playlist is stored on Media Server.
	// If set to `false`, the configured value in a template will be disabled.
	URLPrefix() *URLPrefix
	// A string starting the addresses of separate segments within a *segment-based* playlists (HLS or DASH).
	// Each sub-playlist is stored on Media Server.
	// If set to `false`, the configured value in a template will be disabled.
	SetURLPrefix(*URLPrefix) StreamConfigMedia
	// WebRTC play configuration for a stream.
	WebrtcAbr() WebrtcAbrOpts
	// WebRTC play configuration for a stream.
	SetWebrtcAbr(WebrtcAbrOpts) StreamConfigMedia
}

type StreamConfigOnpremises interface {
	// Deprecated field. Will be deleted at 23.12
	// The param is deprecated and now used only for onvif_url and onvif_profile options.
	Meta() map[string]string
	// Deprecated field. Will be deleted at 23.12
	// The param is deprecated and now used only for onvif_url and onvif_profile options.
	SetMeta(map[string]string) StreamConfigOnpremises
	// Video analytics parameters.
	Vision() VisionSpec
	// Video analytics parameters.
	SetVision(VisionSpec) StreamConfigOnpremises
}

type StreamConfigSingleMedia interface {
	// SRT2 publishing configuration for a stream.
	Srt2Publish() SrtConfig
	// SRT2 publishing configuration for a stream.
	SetSrt2Publish(SrtConfig) StreamConfigSingleMedia
	// SRT publishing configuration for a stream.
	SrtPublish() SrtConfig
	// SRT publishing configuration for a stream.
	SetSrtPublish(SrtConfig) StreamConfigSingleMedia
}

// Required: name
type StreamConfigSpecific interface {
	// Human-readable description of the stream.
	// Example: This is a test stream
	Comment() *string
	// Human-readable description of the stream.
	// Example: This is a test stream
	SetComment(string) StreamConfigSpecific
	// Globally unique stream name.
	// Note that the name could not be changed after the stream is created.
	// Format: media_name (media_name)
	// Examples: Decklink-Stream, Dektec-Stream, hockey1, mylive/bunny, test_stream
	Name() MediaName
	// Globally unique stream name.
	// Note that the name could not be changed after the stream is created.
	// Format: media_name (media_name)
	// Examples: Decklink-Stream, Dektec-Stream, hockey1, mylive/bunny, test_stream
	SetName(MediaName) StreamConfigSpecific
	// Where the stream is initialized: config, user play/publication, or remote
	// cluster server.
	// Example: config
	NamedBy() *NamedBy
	// Where the stream is initialized: config, user play/publication, or remote
	// cluster server.
	// Example: config
	SetNamedBy(NamedBy) StreamConfigSpecific
	// Position of the stream in order of streams in the config file, if declared.
	// Format: sort_index (sort_index)
	// Example: 2
	Position() *SortIndex
	// Position of the stream in order of streams in the config file, if declared.
	// Format: sort_index (sort_index)
	// Example: 2
	SetPosition(SortIndex) StreamConfigSpecific
	// How often to re-check secondary inputs. If this option is not set than check is never performed.
	// Format: seconds (seconds)
	// Example: 120
	RecheckSecondaryInputsInterval() *Seconds
	// How often to re-check secondary inputs. If this option is not set than check is never performed.
	// Format: seconds (seconds)
	// Example: 120
	SetRecheckSecondaryInputsInterval(Seconds) StreamConfigSpecific
	// Deprecated field. Will be deleted at 24.06
	// Stream name was resolved via `srt_port_resolve` call.
	// See [endpoint](https://flussonic.com/doc/api/config-external/#tag/srt/operation/srt_port_resolve)
	// and [listener](https://flussonic.com/doc/api/reference/#tag/config/operation/config_save%7Cbody%7Clisteners%7Csrt)
	// for feature description.
	// This parameter now lives in `stats` object.
	// Example: false
	SrtPortResolve() *bool
	// Deprecated field. Will be deleted at 24.06
	// Stream name was resolved via `srt_port_resolve` call.
	// See [endpoint](https://flussonic.com/doc/api/config-external/#tag/srt/operation/srt_port_resolve)
	// and [listener](https://flussonic.com/doc/api/reference/#tag/config/operation/config_save%7Cbody%7Clisteners%7Csrt)
	// for feature description.
	// This parameter now lives in `stats` object.
	// Example: false
	SetSrtPortResolve(bool) StreamConfigSpecific
	// Template of the stream.
	// Format: media_name (media_name)
	// Example: sports-hd
	Template() *MediaName
	// Template of the stream.
	// Format: media_name (media_name)
	// Example: sports-hd
	SetTemplate(MediaName) StreamConfigSpecific
	// Human-readable title of the stream. Provided for SDT MPEG-TS table or
	// SDP RTSP title parameter.
	// Example: Hockey channel
	Title() *string
	// Human-readable title of the stream. Provided for SDT MPEG-TS table or
	// SDP RTSP title parameter.
	// Example: Hockey channel
	SetTitle(string) StreamConfigSpecific
}

// This is a reduced configuration of stream that contains only actual used config.
// Can compare it with stream_config that includes some runtime information and
// interpretation of stream config information, like config_on_disk
type StreamConfigStripped interface {
	// Whether to add an audio-only version of an HLS stream.
	// Used to create App Store compliant HLS streams to deliver the content to Apple iOS devices.
	// Example: true
	AddAudioOnly() *bool
	// Whether to add an audio-only version of an HLS stream.
	// Used to create App Store compliant HLS streams to deliver the content to Apple iOS devices.
	// Example: true
	SetAddAudioOnly(bool) StreamConfigStripped
	// If a connected source does not send audio data within this timeout period (in seconds),
	// the source connection is considered to be lost.
	// This is a default configuration for a stream, can be modified for any input.
	// Format: seconds (seconds)
	// Example: 20
	AudioTimeout() *Seconds
	// If a connected source does not send audio data within this timeout period (in seconds),
	// the source connection is considered to be lost.
	// This is a default configuration for a stream, can be modified for any input.
	// Format: seconds (seconds)
	// Example: 20
	SetAudioTimeout(Seconds) StreamConfigStripped
	// When all inputs are down, this can be used to show at least something to users.
	// It is important to understand that backup video behaves differently, not as inputs.
	// It is not a _last input_ in the list. After any input stops sending frames, timer starts.
	// After `source_timeout` seconds backup starts working, while all other inputs are still trying to
	// connect and start working.
	// So backup and all inputs are working in parallel.
	Backup() BackupConfig
	// When all inputs are down, this can be used to show at least something to users.
	// It is important to understand that backup video behaves differently, not as inputs.
	// It is not a _last input_ in the list. After any input stops sending frames, timer starts.
	// After `source_timeout` seconds backup starts working, while all other inputs are still trying to
	// connect and start working.
	// So backup and all inputs are working in parallel.
	SetBackup(BackupConfig) StreamConfigStripped
	// Chunk duration in LL-HLS manifest to be used for tunning latency.
	// Format: milliseconds (milliseconds)
	// Example: 200
	ChunkDuration() *Milliseconds
	// Chunk duration in LL-HLS manifest to be used for tunning latency.
	// Format: milliseconds (milliseconds)
	// Example: 200
	SetChunkDuration(Milliseconds) StreamConfigStripped
	// Stream's lifetime after the last client was disconnected (can be expressed in *seconds* or set to `False`).
	// Applicable to on-demand streams **only**.
	// Example: 485
	ClientsTimeout() any
	// Stream's lifetime after the last client was disconnected (can be expressed in *seconds* or set to `False`).
	// Applicable to on-demand streams **only**.
	// Example: 485
	SetClientsTimeout(any) StreamConfigStripped
	// Human-readable description of the stream.
	// Example: This is a test stream
	Comment() *string
	// Human-readable description of the stream.
	// Example: This is a test stream
	SetComment(string) StreamConfigStripped
	// Whether a stream is disabled. Disabled streams are inactive and do not run.
	// Displayed only with the API calls.
	// Example: false
	Disabled() *bool
	// Whether a stream is disabled. Disabled streams are inactive and do not run.
	// Displayed only with the API calls.
	// Example: false
	SetDisabled(bool) StreamConfigStripped
	// Configuraton of Digital Rights Management system (DRM).
	Drm() DrmSpec
	// Configuraton of Digital Rights Management system (DRM).
	SetDrm(DrmSpec) StreamConfigStripped
	// This parameter allows to manage subtitles in an output stream.
	// Example: replace
	Dvbocr() *StreamConfigInputDvbocr
	// This parameter allows to manage subtitles in an output stream.
	// Example: replace
	SetDvbocr(StreamConfigInputDvbocr) StreamConfigStripped
	// DVR configuraton.
	Dvr() StreamDvrSpec
	// DVR configuraton.
	SetDvr(StreamDvrSpec) StreamConfigStripped
	// Whether to extract EPG from the input.
	// Example: true
	EpgEnabled() *bool
	// Whether to extract EPG from the input.
	// Example: true
	SetEpgEnabled(bool) StreamConfigStripped
	// Whether to enable SCTE-35 ad insertion markers signaling in HLS manifest.
	// Ad markers can be included in SCTE-35 (`scte35`), AWS (`aws`), EXT-X-DATERANGE (`rfc8216`) formats or not included (`false`).
	// Example: scte35
	HlsScte35() *StreamConfigMediaHlsScte35
	// Whether to enable SCTE-35 ad insertion markers signaling in HLS manifest.
	// Ad markers can be included in SCTE-35 (`scte35`), AWS (`aws`), EXT-X-DATERANGE (`rfc8216`) formats or not included (`false`).
	// Example: scte35
	SetHlsScte35(StreamConfigMediaHlsScte35) StreamConfigStripped
	// Use this option for fine-grained control over each input track.
	// You can select, rename, change name and title for each video, audio track.
	InputMediaInfo() InputMediaInfo
	// Use this option for fine-grained control over each input track.
	// You can select, rename, change name and title for each video, audio track.
	SetInputMediaInfo(InputMediaInfo) StreamConfigStripped
	// List of stream inputs.
	// ***Important:*** A stream without any inputs can receive video frames **only** if backup file is specified.
	Inputs() []StreamInput
	// List of stream inputs.
	// ***Important:*** A stream without any inputs can receive video frames **only** if backup file is specified.
	SetInputs([]StreamInput) StreamConfigStripped
	// A key to sign jpeg_snapshot requests
	JpegSnapshotSignKey() *string
	// A key to sign jpeg_snapshot requests
	SetJpegSnapshotSignKey(string) StreamConfigStripped
	// Stream labels in key value format.
	// Key is a string in unix_name format (alphanumeric characters, underscores, hyphens and periods).
	// See [Layouter schema](https://flussonic.com/doc/api/layouter/#tag/stream/operation/streams_list/response%7Cstreams%7Clabels)
	// for more details.
	Labels() map[string]UnixName
	// Stream labels in key value format.
	// Key is a string in unix_name format (alphanumeric characters, underscores, hyphens and periods).
	// See [Layouter schema](https://flussonic.com/doc/api/layouter/#tag/stream/operation/streams_list/response%7Cstreams%7Clabels)
	// for more details.
	SetLabels(map[string]UnixName) StreamConfigStripped
	// The maximum time that Media Server will set for attempts to reconnect to sources when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	MaxRetryTimeout() *Seconds
	// The maximum time that Media Server will set for attempts to reconnect to sources when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	SetMaxRetryTimeout(Seconds) StreamConfigStripped
	// Deprecated field. Will be deleted at 23.12
	// The param is deprecated and now used only for onvif_url and onvif_profile options.
	Meta() map[string]string
	// Deprecated field. Will be deleted at 23.12
	// The param is deprecated and now used only for onvif_url and onvif_profile options.
	SetMeta(map[string]string) StreamConfigStripped
	// It allows to specify pack information about ac3 for outgoing MPEGTS-TS streams. The default value is `system_b`.
	MpegtsAc3() *OutputMpegtsAc3
	// It allows to specify pack information about ac3 for outgoing MPEGTS-TS streams. The default value is `system_b`.
	SetMpegtsAc3(OutputMpegtsAc3) StreamConfigStripped
	// This parameter sets PIDs values for outgoing MPEG-TS streams. PID contains information about the TS package content and can be decoded according to special service tables.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks. Tracks are numbered starting from one.
	// The code `a1=123` sets a PID value for the first audio track. It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, `t0=100` sets PID=101 for the first track, 102 for the second, and so on. Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	MpegtsPids() OutputMpegtsPids
	// This parameter sets PIDs values for outgoing MPEG-TS streams. PID contains information about the TS package content and can be decoded according to special service tables.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks. Tracks are numbered starting from one.
	// The code `a1=123` sets a PID value for the first audio track. It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, `t0=100` sets PID=101 for the first track, 102 for the second, and so on. Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	SetMpegtsPids(OutputMpegtsPids) StreamConfigStripped
	// Globally unique stream name.
	// Note that the name could not be changed after the stream is created.
	// Format: media_name (media_name)
	// Examples: Decklink-Stream, Dektec-Stream, hockey1, mylive/bunny, test_stream
	Name() MediaName
	// Globally unique stream name.
	// Note that the name could not be changed after the stream is created.
	// Format: media_name (media_name)
	// Examples: Decklink-Stream, Dektec-Stream, hockey1, mylive/bunny, test_stream
	SetName(MediaName) StreamConfigStripped
	// Where the stream is initialized: config, user play/publication, or remote
	// cluster server.
	// Example: config
	NamedBy() *NamedBy
	// Where the stream is initialized: config, user play/publication, or remote
	// cluster server.
	// Example: config
	SetNamedBy(NamedBy) StreamConfigStripped
	// Configuration of authorization backend for play sessions.
	OnPlay() AuthSpec
	// Configuration of authorization backend for play sessions.
	SetOnPlay(AuthSpec) StreamConfigStripped
	// Configuration of authorization backend for publish sessions.
	OnPublish() AuthSpec
	// Configuration of authorization backend for publish sessions.
	SetOnPublish(AuthSpec) StreamConfigStripped
	// This parameter sets playback HTTP headers for streams.
	PlaybackHeaders() []PlaybackHeaders
	// This parameter sets playback HTTP headers for streams.
	SetPlaybackHeaders([]PlaybackHeaders) StreamConfigStripped
	// Position of the stream in order of streams in the config file, if declared.
	// Format: sort_index (sort_index)
	// Example: 2
	Position() *SortIndex
	// Position of the stream in order of streams in the config file, if declared.
	// Format: sort_index (sort_index)
	// Example: 2
	SetPosition(SortIndex) StreamConfigStripped
	// The time (in seconds) that Media Server reserves for preloading the data, i. e. *buffering*.
	// Prepush is always defined through GoP, but this option provides you with a more flexible way
	// to configure the buffer size, e. g. a 1-3 or 7-10 seconds time interval.
	// The bigger the buffer size, the better the user experience is for the users
	// with a bad internet connection. However, the latency also increases.
	// If set to `False` to remove the latency, the stream's start time
	// increases. To decrease it, reduce the GoP size and make the bitrate higher
	// or the video quality lower.
	// Example: false
	Prepush() any
	// The time (in seconds) that Media Server reserves for preloading the data, i. e. *buffering*.
	// Prepush is always defined through GoP, but this option provides you with a more flexible way
	// to configure the buffer size, e. g. a 1-3 or 7-10 seconds time interval.
	// The bigger the buffer size, the better the user experience is for the users
	// with a bad internet connection. However, the latency also increases.
	// If set to `False` to remove the latency, the stream's start time
	// increases. To decrease it, reduce the GoP size and make the bitrate higher
	// or the video quality lower.
	// Example: false
	SetPrepush(any) StreamConfigStripped
	// Configuration to allow/forbid playing the stream via various protocols.
	// - If the `whitelist` option is set to 'true', the server allows a playback only for listed protocols;
	// - If the `whitelist` option is set to 'false', the server forbids a playback for listed protocols;
	// - Server allows a playback for all the protocols by default.
	Protocols() PlayProtocolsSpec
	// Configuration to allow/forbid playing the stream via various protocols.
	// - If the `whitelist` option is set to 'true', the server allows a playback only for listed protocols;
	// - If the `whitelist` option is set to 'false', the server forbids a playback for listed protocols;
	// - Server allows a playback for all the protocols by default.
	SetProtocols(PlayProtocolsSpec) StreamConfigStripped
	// Deprecated field. Will be deleted at 25.03
	// Human-readable name of the content provider. Used, for example, for MPEG-TS.
	// Deprecated, use `input_media_info.provider` instead
	// Example: SportsTV
	Provider() *string
	// Deprecated field. Will be deleted at 25.03
	// Human-readable name of the content provider. Used, for example, for MPEG-TS.
	// Deprecated, use `input_media_info.provider` instead
	// Example: SportsTV
	SetProvider(string) StreamConfigStripped
	// A list of pushes. When a server initiates the connection and sends a stream
	// to other server(s), it is called a `push`.
	Pushes() []StreamPush
	// A list of pushes. When a server initiates the connection and sends a stream
	// to other server(s), it is called a `push`.
	SetPushes([]StreamPush) StreamConfigStripped
	// How often to re-check secondary inputs. If this option is not set than check is never performed.
	// Format: seconds (seconds)
	// Example: 120
	RecheckSecondaryInputsInterval() *Seconds
	// How often to re-check secondary inputs. If this option is not set than check is never performed.
	// Format: seconds (seconds)
	// Example: 120
	SetRecheckSecondaryInputsInterval(Seconds) StreamConfigStripped
	// Number of attempts for the server to reconnect to a data source.
	// Applicable to on-demand streams **only**. If not defined, server will constantly try to reconnect (unlimited number of retries).
	// If the input does not become active after specified amount of attempts, stream shuts down till the next user request.
	RetryLimit() *int
	// Number of attempts for the server to reconnect to a data source.
	// Applicable to on-demand streams **only**. If not defined, server will constantly try to reconnect (unlimited number of retries).
	// If the input does not become active after specified amount of attempts, stream shuts down till the next user request.
	SetRetryLimit(int) StreamConfigStripped
	// Number of segments stored in memory for the segment-based protocols, such as HLS and DASH.
	// Added to HLS live manifest. Do not forget that one more segment is stored for stale clients
	// that come too late, but the latest segment is not shown in the manifest.
	// Example: 4
	SegmentCount() *int
	// Number of segments stored in memory for the segment-based protocols, such as HLS and DASH.
	// Added to HLS live manifest. Do not forget that one more segment is stored for stale clients
	// that come too late, but the latest segment is not shown in the manifest.
	// Example: 4
	SetSegmentCount(int) StreamConfigStripped
	// The time of the segment duration. Used for the protocols like HLS or DASH.
	// The disk config offers this value in seconds.
	// Example: 5000
	SegmentDuration() *Milliseconds
	// The time of the segment duration. Used for the protocols like HLS or DASH.
	// The disk config offers this value in seconds.
	// Example: 5000
	SetSegmentDuration(Milliseconds) StreamConfigStripped
	// If a connected source does not send any data within this timeout period (in seconds),
	// the source connection is considered to be lost.
	// This is a default configuration for a stream, can be modified for any input.
	// Example: 10
	SourceTimeout() any
	// If a connected source does not send any data within this timeout period (in seconds),
	// the source connection is considered to be lost.
	// This is a default configuration for a stream, can be modified for any input.
	// Example: 10
	SetSourceTimeout(any) StreamConfigStripped
	// SRT2 publishing configuration for a stream.
	Srt2Publish() SrtConfig
	// SRT2 publishing configuration for a stream.
	SetSrt2Publish(SrtConfig) StreamConfigStripped
	// Deprecated field. Will be deleted at 24.06
	// Stream name was resolved via `srt_port_resolve` call.
	// See [endpoint](https://flussonic.com/doc/api/config-external/#tag/srt/operation/srt_port_resolve)
	// and [listener](https://flussonic.com/doc/api/reference/#tag/config/operation/config_save%7Cbody%7Clisteners%7Csrt)
	// for feature description.
	// This parameter now lives in `stats` object.
	// Example: false
	SrtPortResolve() *bool
	// Deprecated field. Will be deleted at 24.06
	// Stream name was resolved via `srt_port_resolve` call.
	// See [endpoint](https://flussonic.com/doc/api/config-external/#tag/srt/operation/srt_port_resolve)
	// and [listener](https://flussonic.com/doc/api/reference/#tag/config/operation/config_save%7Cbody%7Clisteners%7Csrt)
	// for feature description.
	// This parameter now lives in `stats` object.
	// Example: false
	SetSrtPortResolve(bool) StreamConfigStripped
	// SRT publishing configuration for a stream.
	SrtPublish() SrtConfig
	// SRT publishing configuration for a stream.
	SetSrtPublish(SrtConfig) StreamConfigStripped
	// Whether a stream is `static` or not.
	// If set to `True` the server will try to keep this stream running even if
	// there are no viewers or errors encountered.
	// Streamer restarts *all* `static` streams even if any internal errors occur
	// and the `static` streams crash.
	// Example: true
	Static() *bool
	// Whether a stream is `static` or not.
	// If set to `True` the server will try to keep this stream running even if
	// there are no viewers or errors encountered.
	// Streamer restarts *all* `static` streams even if any internal errors occur
	// and the `static` streams crash.
	// Example: true
	SetStatic(bool) StreamConfigStripped
	// Template of the stream.
	// Format: media_name (media_name)
	// Example: sports-hd
	Template() *MediaName
	// Template of the stream.
	// Format: media_name (media_name)
	// Example: sports-hd
	SetTemplate(MediaName) StreamConfigStripped
	// Configuration of thumbnails generator.
	Thumbnails() ThumbnailsSpec
	// Configuration of thumbnails generator.
	SetThumbnails(ThumbnailsSpec) StreamConfigStripped
	// Human-readable title of the stream. Provided for SDT MPEG-TS table or
	// SDP RTSP title parameter.
	// Example: Hockey channel
	Title() *string
	// Human-readable title of the stream. Provided for SDT MPEG-TS table or
	// SDP RTSP title parameter.
	// Example: Hockey channel
	SetTitle(string) StreamConfigStripped
	// Configuration of the transcoder settings.
	// Examples: map[]
	Transcoder() TranscoderOpts
	// Configuration of the transcoder settings.
	// Examples: map[]
	SetTranscoder(TranscoderOpts) StreamConfigStripped
	// Transport protocol for WebRTC.
	Transport() *WebrtcTransport
	// Transport protocol for WebRTC.
	SetTransport(WebrtcTransport) StreamConfigStripped
	// A string starting the addresses of separate segments within a *segment-based* playlists (HLS or DASH).
	// Each sub-playlist is stored on Media Server.
	// If set to `false`, the configured value in a template will be disabled.
	URLPrefix() *URLPrefix
	// A string starting the addresses of separate segments within a *segment-based* playlists (HLS or DASH).
	// Each sub-playlist is stored on Media Server.
	// If set to `false`, the configured value in a template will be disabled.
	SetURLPrefix(*URLPrefix) StreamConfigStripped
	// If a connected source does not send video data within this timeout period (in seconds),
	// the source connection is considered to be lost.
	// This is a default configuration for a stream, can be modified for any input.
	// Format: seconds (seconds)
	// Example: 20
	VideoTimeout() *Seconds
	// If a connected source does not send video data within this timeout period (in seconds),
	// the source connection is considered to be lost.
	// This is a default configuration for a stream, can be modified for any input.
	// Format: seconds (seconds)
	// Example: 20
	SetVideoTimeout(Seconds) StreamConfigStripped
	// Video analytics parameters.
	Vision() VisionSpec
	// Video analytics parameters.
	SetVision(VisionSpec) StreamConfigStripped
	// WebRTC play configuration for a stream.
	WebrtcAbr() WebrtcAbrOpts
	// WebRTC play configuration for a stream.
	SetWebrtcAbr(WebrtcAbrOpts) StreamConfigStripped
}

type StreamDvrSpec interface {
	// Maximum disk consumption in percents. When this limit is reached,
	// the oldest segment of the recording will be overridden by later data.
	// It important to understand that this is not a "per-stream" option, this option means
	// that cleaning of this stream will be triggered if overall disk usage reaches this number.
	// If you have all streams with configuration 98% and one stream with 95%, it will be permanently
	// empty.
	// Format: percent (percent)
	// Example: 98
	DiskUsageLimit() *Percent
	// Maximum disk consumption in percents. When this limit is reached,
	// the oldest segment of the recording will be overridden by later data.
	// It important to understand that this is not a "per-stream" option, this option means
	// that cleaning of this stream will be triggered if overall disk usage reaches this number.
	// If you have all streams with configuration 98% and one stream with 95%, it will be permanently
	// empty.
	// Format: percent (percent)
	// Example: 98
	SetDiskUsageLimit(Percent) StreamDvrSpec
	// Additional archive depth in seconds for episodes. If set, episodes and their corresponding DVR record
	// will be saved for `expiration + episodes_expiration` seconds.
	// The archive clean-up within `[expiration, expiration+episodes_expiration]` seconds of the
	// recording performed depending on [external_episodes_list](https://flussonic.com/doc/api/config-external/#tag/dvr/operation/external_episodes_list)
	// response of `episodes_url`.
	// Anything older than `expiration+episodes_expiration` seconds will
	// be cleaned even if `episodes_url` does not respond.
	// Format: seconds (seconds)
	// Examples: 6.048e+06
	EpisodesExpiration() *Seconds
	// Additional archive depth in seconds for episodes. If set, episodes and their corresponding DVR record
	// will be saved for `expiration + episodes_expiration` seconds.
	// The archive clean-up within `[expiration, expiration+episodes_expiration]` seconds of the
	// recording performed depending on [external_episodes_list](https://flussonic.com/doc/api/config-external/#tag/dvr/operation/external_episodes_list)
	// response of `episodes_url`.
	// Anything older than `expiration+episodes_expiration` seconds will
	// be cleaned even if `episodes_url` does not respond.
	// Format: seconds (seconds)
	// Examples: 6.048e+06
	SetEpisodesExpiration(Seconds) StreamDvrSpec
	// External URL that will be triggered for fetching episodes list.
	// Take a look at config_external API for method `external_episodes_list`.
	// If the `episodes_url` not set or responds with any HTTP code other than `200` or `501` or does not respond within a timeout,
	// the archive clean-up is only performed by `episodes_expiration` time while `expiration` and `storage_limit` are ignored until the `episodes_url` restores.
	// If `episodes_url` is a blank string, then current config_external API endpoint will be used to request episodes.
	// It is most common usage of this field.
	// Examples: , http://central-host.local/config-external/episodes
	EpisodesURL() *string
	// External URL that will be triggered for fetching episodes list.
	// Take a look at config_external API for method `external_episodes_list`.
	// If the `episodes_url` not set or responds with any HTTP code other than `200` or `501` or does not respond within a timeout,
	// the archive clean-up is only performed by `episodes_expiration` time while `expiration` and `storage_limit` are ignored until the `episodes_url` restores.
	// If `episodes_url` is a blank string, then current config_external API endpoint will be used to request episodes.
	// It is most common usage of this field.
	// Examples: , http://central-host.local/config-external/episodes
	SetEpisodesURL(string) StreamDvrSpec
	// Archive depth - a period (in seconds) back from the current moment during which the
	// contigious part of archive is stored.
	// As time goes, the parts of the recording which are older than the archive depth are deleted.
	// If you have option `episodes_expiration` enabled, then some parts of DVR that are
	// locked by episode signalling mechanism may be kept more than this `expiration` depth.
	// If `episodes_url` does not respond, the archive clean-up by `expiration` is not performed;
	// only the archive with expired episodes (`episodes_expiration`) is cleaned up until the `episodes_url` restores.
	// Format: seconds (seconds)
	// Examples: 604800
	Expiration() *Seconds
	// Archive depth - a period (in seconds) back from the current moment during which the
	// contigious part of archive is stored.
	// As time goes, the parts of the recording which are older than the archive depth are deleted.
	// If you have option `episodes_expiration` enabled, then some parts of DVR that are
	// locked by episode signalling mechanism may be kept more than this `expiration` depth.
	// If `episodes_url` does not respond, the archive clean-up by `expiration` is not performed;
	// only the archive with expired episodes (`episodes_expiration`) is cleaned up until the `episodes_url` restores.
	// Format: seconds (seconds)
	// Examples: 604800
	SetExpiration(Seconds) StreamDvrSpec
	// How many servers will contain a copy of the DVR archive.
	// You can find more information [here](https://flussonic.com/doc/api/layouter/#tag/stream/operation/streams_list/response%7Cstreams%7Cdvr%7Credundancy_factor)
	// Example: 1
	RedundancyFactor() *int
	// How many servers will contain a copy of the DVR archive.
	// You can find more information [here](https://flussonic.com/doc/api/layouter/#tag/stream/operation/streams_list/response%7Cstreams%7Cdvr%7Credundancy_factor)
	// Example: 1
	SetRedundancyFactor(int) StreamDvrSpec
	// Stream can refer to the globally declared DVR. This option referres to a single DVR entry.
	// Format: dvr_name (dvr_name)
	// Example: localdvr0
	Reference() *DvrName
	// Stream can refer to the globally declared DVR. This option referres to a single DVR entry.
	// Format: dvr_name (dvr_name)
	// Example: localdvr0
	SetReference(DvrName) StreamDvrSpec
	// The address of the source from which Media server will read the archive. This address will not be used for capturing live video, it is strictly for data exchange on the availability of the archive and the transmission of segments.
	Remotes() []DvrURL
	// The address of the source from which Media server will read the archive. This address will not be used for capturing live video, it is strictly for data exchange on the availability of the archive and the transmission of segments.
	SetRemotes([]DvrURL) StreamDvrSpec
	// One or several time intervals for recording by schedule.
	// The beginning and the end of each interval are set in "hhmm" format (without leading zeros ) according to UTC standard.
	// For example, `2330` is for 23:30, `800` - for 08:00. The interval can go over midnight, e.g. 22:00-1:30. In this case it is set as follows: `[2200,130]`.
	// Scheduled recording can be useful for the channels with part-time broadcasting.
	// It allows to save disk space significantly.
	// Example: [[800 1600] [2200 130]]
	Schedule() [][]int
	// One or several time intervals for recording by schedule.
	// The beginning and the end of each interval are set in "hhmm" format (without leading zeros ) according to UTC standard.
	// For example, `2330` is for 23:30, `800` - for 08:00. The interval can go over midnight, e.g. 22:00-1:30. In this case it is set as follows: `[2200,130]`.
	// Scheduled recording can be useful for the channels with part-time broadcasting.
	// It allows to save disk space significantly.
	// Example: [[800 1600] [2200 130]]
	SetSchedule([][]int) StreamDvrSpec
	// Maximum disk consumption in bytes. When this limit is reached,
	// the oldest segment of the recording will be overridden by later data.
	// This option affects both continuous recording and locked episodes (see `episodes_url`).
	// If `episodes_url` does not respond, the archive clean-up by `storage_limit` is not performed
	// to avoid deleting the recordings that should not be deleted.
	// Format: bytes (bytes)
	// Example: 4e+11
	StorageLimit() *Bytes
	// Maximum disk consumption in bytes. When this limit is reached,
	// the oldest segment of the recording will be overridden by later data.
	// This option affects both continuous recording and locked episodes (see `episodes_url`).
	// If `episodes_url` does not respond, the archive clean-up by `storage_limit` is not performed
	// to avoid deleting the recordings that should not be deleted.
	// Format: bytes (bytes)
	// Example: 4e+11
	SetStorageLimit(Bytes) StreamDvrSpec
}

type StreamDvrSpecificSpec interface {
	// How many servers will contain a copy of the DVR archive.
	// You can find more information [here](https://flussonic.com/doc/api/layouter/#tag/stream/operation/streams_list/response%7Cstreams%7Cdvr%7Credundancy_factor)
	// Example: 1
	RedundancyFactor() *int
	// How many servers will contain a copy of the DVR archive.
	// You can find more information [here](https://flussonic.com/doc/api/layouter/#tag/stream/operation/streams_list/response%7Cstreams%7Cdvr%7Credundancy_factor)
	// Example: 1
	SetRedundancyFactor(int) StreamDvrSpecificSpec
	// Stream can refer to the globally declared DVR. This option referres to a single DVR entry.
	// Format: dvr_name (dvr_name)
	// Example: localdvr0
	Reference() *DvrName
	// Stream can refer to the globally declared DVR. This option referres to a single DVR entry.
	// Format: dvr_name (dvr_name)
	// Example: localdvr0
	SetReference(DvrName) StreamDvrSpecificSpec
	// The address of the source from which Media server will read the archive. This address will not be used for capturing live video, it is strictly for data exchange on the availability of the archive and the transmission of segments.
	Remotes() []DvrURL
	// The address of the source from which Media server will read the archive. This address will not be used for capturing live video, it is strictly for data exchange on the availability of the archive and the transmission of segments.
	SetRemotes([]DvrURL) StreamDvrSpecificSpec
}

type StreamInput interface {
	// Audio interface for capturing from the Decklink card.
	// Usually, it is autodetected, but for some Decklink models you should specify it manually.
	// Example: microphone
	Ainput() any
	// Audio interface for capturing from the Decklink card.
	// Usually, it is autodetected, but for some Decklink models you should specify it manually.
	// Example: microphone
	SetAinput(any) StreamInput
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	AllowIf() *string
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	SetAllowIf(string) StreamInput
	// Synchronization mode for audio captured from the Decklink card.
	Apts() *StreamInputDecklinkApts
	// Synchronization mode for audio captured from the Decklink card.
	SetApts(*StreamInputDecklinkApts) StreamInput
	// Deprecated field. Will be deleted at 23.09
	// Moves audio timestamp forwards or backwards on a specified number of milliseconds.
	// Format: milliseconds (milliseconds)
	AudioAdd() *Milliseconds
	// Deprecated field. Will be deleted at 23.09
	// Moves audio timestamp forwards or backwards on a specified number of milliseconds.
	// Format: milliseconds (milliseconds)
	SetAudioAdd(Milliseconds) StreamInput
	// H323 audio bitrate.
	// Format: speed (speed)
	AudioBitrate() *Speed
	// H323 audio bitrate.
	// Format: speed (speed)
	SetAudioBitrate(Speed) StreamInput
	// The audio device to capture audio from Stream Labs SDI cards.
	// This parameter is specified for ALSA devices in the following format `interface:card,device`.
	// Example: plughw:1,0
	AudioDevice() *string
	// The audio device to capture audio from Stream Labs SDI cards.
	// This parameter is specified for ALSA devices in the following format `interface:card,device`.
	// Example: plughw:1,0
	SetAudioDevice(string) StreamInput
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	AudioTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetAudioTimeout(Seconds) StreamInput
	// Optional bind core
	BindToCore() *int
	// Optional bind core
	SetBindToCore(int) StreamInput
	// Bitrate of the audio.
	// Format: speed (speed)
	Bitrate() *Speed
	// Bitrate of the audio.
	// Format: speed (speed)
	SetBitrate(Speed) StreamInput
	// The rules for handling the closed captions.
	ClosedCaptions() map[string]string
	// The rules for handling the closed captions.
	SetClosedCaptions(map[string]string) StreamInput
	// Human-readable description of the input.
	// Example: This is a test input
	Comment() *string
	// Human-readable description of the input.
	// Example: This is a test input
	SetComment(string) StreamInput
	// H323 connections.
	Connections() *int
	// H323 connections.
	SetConnections(int) StreamInput
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	DenyIf() *string
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	SetDenyIf(string) StreamInput
	// Whether both connection parties must have the same password set (including empty, in other words, with no encryption).
	// If the passwords do not match or only one side is unencrypted, the connection is rejected.
	// The default value is `true`.
	// Example: true
	Enforcedencryption() *bool
	// Whether both connection parties must have the same password set (including empty, in other words, with no encryption).
	// If the passwords do not match or only one side is unencrypted, the connection is rejected.
	// The default value is `true`.
	// Example: true
	SetEnforcedencryption(bool) StreamInput
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	FramesTimeout() *int
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	SetFramesTimeout(int) StreamInput
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	Headers() map[string]string
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	SetHeaders(map[string]string) StreamInput
	// Must specify received pixel height
	Height() *int
	// Must specify received pixel height
	SetHeight(int) StreamInput
	// H323 input ID.
	ID() *string
	// H323 input ID.
	SetID(string) StreamInput
	// An array of MPEG-TS language descriptors in format `[{key: track, value: language}]`
	Languages() map[string]string
	// An array of MPEG-TS language descriptors in format `[{key: track, value: language}]`
	SetLanguages(map[string]string) StreamInput
	// The latency value for both directions of the socket.
	// By default initial value latency is 0 when transmitting and 120ms when receiving video.
	// Actual value established after connection handshake.
	// Increased value helps tolerate network losses and delays.
	// Format: milliseconds (milliseconds)
	// Example: 150
	Latency() *Milliseconds
	// The latency value for both directions of the socket.
	// By default initial value latency is 0 when transmitting and 120ms when receiving video.
	// Actual value established after connection handshake.
	// Increased value helps tolerate network losses and delays.
	// Format: milliseconds (milliseconds)
	// Example: 150
	SetLatency(Milliseconds) StreamInput
	// The time, in seconds, that the socket waits for the unsent data before closing.
	// The default value is 180.
	// Format: seconds (seconds)
	// Example: 15
	Linger() *Seconds
	// The time, in seconds, that the socket waits for the unsent data before closing.
	// The default value is 180.
	// Format: seconds (seconds)
	// Example: 15
	SetLinger(Seconds) StreamInput
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	MaxRetryTimeout() *Seconds
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	SetMaxRetryTimeout(Seconds) StreamInput
	// The minimum SRT version that is required from the peer for SRT publication.
	// Pattern: ^[0-9]+\.[0-9]+\.[0-9]+$
	// Example: 1.1.0
	Minversion() *string
	// The minimum SRT version that is required from the peer for SRT publication.
	// Pattern: ^[0-9]+\.[0-9]+\.[0-9]+$
	// Example: 1.1.0
	SetMinversion(string) StreamInput
	// The mixing mode for the `mixer://` input type.
	MixerStrategy() *StreamInputMixerMixerStrategy
	// The mixing mode for the `mixer://` input type.
	SetMixerStrategy(StreamInputMixerMixerStrategy) StreamInput
	// Mode of the input stream captured from the Decklink card. It is composed of the size and FPS of the captured video.
	// Usually, it is autodetected, but for some Decklink models you'll need to specify it manually.
	// Example: 4d30
	Mode() *string
	// Mode of the input stream captured from the Decklink card. It is composed of the size and FPS of the captured video.
	// Usually, it is autodetected, but for some Decklink models you'll need to specify it manually.
	// Example: 4d30
	SetMode(string) StreamInput
	// Skip input start if the stream has no clients.
	NoClientsReconnectDelay() *int
	// Skip input start if the stream has no clients.
	SetNoClientsReconnectDelay(int) StreamInput
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	OutputAudio() *OutputAudio
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	SetOutputAudio(OutputAudio) StreamInput
	// URL of the web page from where the SWF file was loaded.
	// This is an RTMP header (Referer) used for establishing connection.
	// Format: url (url)
	// Example: http://somehost/sample.html
	Pageurl() *URL
	// URL of the web page from where the SWF file was loaded.
	// This is an RTMP header (Referer) used for establishing connection.
	// Format: url (url)
	// Example: http://somehost/sample.html
	SetPageurl(URL) StreamInput
	// The password for the encrypted transmission.
	// Its length should be not less than 10 and not more than 79 characters.
	// Unlike [password](https://flussonic.com/doc/api/reference/#tag/stream/operation/stream_save%7Cbody%7Cpassword),
	// the passphrase is not transmitted openly but is used to encrypt the key that is transmitted by the Caller
	// and decoded by Listener.
	// Example: 9876543210
	Passphrase() *string
	// The password for the encrypted transmission.
	// Its length should be not less than 10 and not more than 79 characters.
	// Unlike [password](https://flussonic.com/doc/api/reference/#tag/stream/operation/stream_save%7Cbody%7Cpassword),
	// the passphrase is not transmitted openly but is used to encrypt the key that is transmitted by the Caller
	// and decoded by Listener.
	// Example: 9876543210
	SetPassphrase(string) StreamInput
	// Choose a specific PID to ingest from an MPEG-TS stream.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Example: [211]
	Pids() []int
	// Choose a specific PID to ingest from an MPEG-TS stream.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Example: [211]
	SetPids([]int) StreamInput
	// Preferred pixel format for captured video.
	Pixel() any
	// Preferred pixel format for captured video.
	SetPixel(any) StreamInput
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	Priority() *int
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	SetPriority(int) StreamInput
	// Choose a program to ingest from an MPEG-TS stream.
	// Example: [1]
	Programs() []int
	// Choose a program to ingest from an MPEG-TS stream.
	// Example: [1]
	SetPrograms([]int) StreamInput
	// Source for PTS for input stream.
	PtsSource() *StreamInputDektecPtsSource
	// Source for PTS for input stream.
	SetPtsSource(StreamInputDektecPtsSource) StreamInput
	// The ratio of the width of the display representation to the width of the pixel representation of video.
	// This parameter is used for creating non-anamorphic video from anamorphic video.
	// Example: 16:9
	Sar() *string
	// The ratio of the width of the display representation to the width of the pixel representation of video.
	// This parameter is used for creating non-anamorphic video from anamorphic video.
	// Example: 16:9
	SetSar(string) StreamInput
	// This option disables processing of SCTE-35 markers from an MPEG-TS input stream.
	// Deprecated since 22.12.
	// Available ways to disable processing of SCTE-35 markers:
	// 1. pids option to select tracks without SCTE-35 markers
	// 2. hls_scte35 option from stream_config_media for hls output
	// 3. performing appropriate tuning pids in the transponder
	// /This option disables processing of SCTE-35 markers from SRT input stream.
	Scte35() *bool
	// This option disables processing of SCTE-35 markers from an MPEG-TS input stream.
	// Deprecated since 22.12.
	// Available ways to disable processing of SCTE-35 markers:
	// 1. pids option to select tracks without SCTE-35 markers
	// 2. hls_scte35 option from stream_config_media for hls output
	// 3. performing appropriate tuning pids in the transponder
	// /This option disables processing of SCTE-35 markers from SRT input stream.
	SetScte35(bool) StreamInput
	// Size of shared memory buffer. Omit to make it auto
	// Example: 1.024e+06
	ShmemSize() *int
	// Size of shared memory buffer. Omit to make it auto
	// Example: 1.024e+06
	SetShmemSize(int) StreamInput
	// By default Flussonic will wait for at least 2-3 new segments before making stream available.
	// This parameter allows to disable this protection. Use it at your own risk - with it enabled, old content might be repeated over and over.
	SkipStalledCheck() *bool
	// By default Flussonic will wait for at least 2-3 new segments before making stream available.
	// This parameter allows to disable this protection. Use it at your own risk - with it enabled, old content might be repeated over and over.
	SetSkipStalledCheck(bool) StreamInput
	// Directory for shmem files
	// Example: tmp
	SocketDir() *string
	// Directory for shmem files
	// Example: tmp
	SetSocketDir(string) StreamInput
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SourceTimeout() any
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SetSourceTimeout(any) StreamInput
	// Detailed runtime information about the input.
	Stats() InputStats
	// Detailed runtime information about the input.
	SetStats(InputStats) StreamInput
	// A string of maximum 512 characters set on the socket before the connection.
	// This string is a part of a callback that is sent by the caller and regisered by the listener.
	// Based on this information the listener can accept or reject the connection, select the desired data stream, or set an appropriate passphrase for the connection.
	// Its format is `#!::` optionally followed by the parameters:
	// * `r=` - stream name
	// * `m=` - mode expected for the connection: `publish` (if the caller wants to send the stream data) or `request` (if the caller wants to receive the stream).
	// * `password=` - a password for the authorization in a publish session (not recommended, better use `passphrase` option instead)
	// During SRT sessions the following parameters are automaticly added to streamid:
	// * `s=` - the identifier of a session
	// * `a=` - Flussonic version
	// NOTE: you can specify a string in the format you need; to disable this extension, you need specify empty string.
	// Example: #!::r=my-stream,m=publish
	Streamid() *string
	// A string of maximum 512 characters set on the socket before the connection.
	// This string is a part of a callback that is sent by the caller and regisered by the listener.
	// Based on this information the listener can accept or reject the connection, select the desired data stream, or set an appropriate passphrase for the connection.
	// Its format is `#!::` optionally followed by the parameters:
	// * `r=` - stream name
	// * `m=` - mode expected for the connection: `publish` (if the caller wants to send the stream data) or `request` (if the caller wants to receive the stream).
	// * `password=` - a password for the authorization in a publish session (not recommended, better use `passphrase` option instead)
	// During SRT sessions the following parameters are automaticly added to streamid:
	// * `s=` - the identifier of a session
	// * `a=` - Flussonic version
	// NOTE: you can specify a string in the format you need; to disable this extension, you need specify empty string.
	// Example: #!::r=my-stream,m=publish
	SetStreamid(string) StreamInput
	// Deprecated field. Will be deleted at 25.03
	// This configuration is deprecated. Use `dvbocr` configuration field in stream.
	// This parameter allows to manage subtitles in an output stream.
	// Example: drop
	Subtitles() any
	// Deprecated field. Will be deleted at 25.03
	// This configuration is deprecated. Use `dvbocr` configuration field in stream.
	// This parameter allows to manage subtitles in an output stream.
	// Example: drop
	SetSubtitles(any) StreamInput
	// URL of the source SWF file making the connection by RTMP.
	// Example: file://C:/FlvPlayer.swf
	Swfurl() *string
	// URL of the source SWF file making the connection by RTMP.
	// Example: file://C:/FlvPlayer.swf
	SetSwfurl(string) StreamInput
	// This parameter is used for a mixer stream that uses other streams as its video and audio sources.
	// If the parameter is set to `realtime`, audio frames will be played in sync with video frames:
	// if the difference between timestamps of an audio frame and a corresponding video frame is more than 2 seconds,
	// the audio frame will be played at the timestamp of the video frame.
	// If this parameter is set to `dts`, no synchronization is performed.
	// Example: dts
	Sync() *string
	// This parameter is used for a mixer stream that uses other streams as its video and audio sources.
	// If the parameter is set to `realtime`, audio frames will be played in sync with video frames:
	// if the difference between timestamps of an audio frame and a corresponding video frame is more than 2 seconds,
	// the audio frame will be played at the timestamp of the video frame.
	// If this parameter is set to `dts`, no synchronization is performed.
	// Example: dts
	SetSync(string) StreamInput
	// URL of the remote Server for entering credentials.
	// It has the following format: `protocol://servername:port/appName/appInstance`.
	// Format: url (url)
	// Example: rtmp://localhost:1935/testapp/instance1
	Tcurl() *URL
	// URL of the remote Server for entering credentials.
	// It has the following format: `protocol://servername:port/appName/appInstance`.
	// Format: url (url)
	// Example: rtmp://localhost:1935/testapp/instance1
	SetTcurl(URL) StreamInput
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	Timeout() *int
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	SetTimeout(int) StreamInput
	// This information is necessary for adding into the PMT table to identify streams which carry teletext data in the resulting MPEG-TS stream.
	TtxtDescriptors() []TtxtDescriptors
	// This information is necessary for adding into the PMT table to identify streams which carry teletext data in the resulting MPEG-TS stream.
	SetTtxtDescriptors([]TtxtDescriptors) StreamInput
	// URL to connect to the H323 source and get the stream.
	// /URL to get a stream from HLS source.
	// /URL to connect to the RTMP source and get the stream.
	// RTMP uses a special URL consisting of at least two segments. *Flussonic* parses the URL and splits it into parts,
	// using the first segment as an RTMP application name.
	// /Artificial URL to connect to the SRT source and get the stream.
	// SRT requires IP and port, so we create an artificial URL to specify the options to manage the data interchange.
	// /URL for ingest and pass a stream "as is" without repackaging.
	// /URL to make a mixer stream from other streams.
	// /Special URL to make a mosaic stream.
	// /URL to get a stream from m4f source.
	// /URL to get a stream from m4s source.
	// /URL to connect to RTP source and get the stream.
	// /URL to connect to the SHOUTcast source and get the stream.
	// /Special URL to play the archive record of a stream with a fixed delay.
	// /URL to get a stream from playlist.
	// /URL to connect to the source and get a copy of the original stream.
	// /URL to connect to the SPTS source and get the stream.
	// /URL to get a stream from MPTS source.
	// /URL to connect to the Video4Linux source and get the stream.
	// /URL to connect to the Decklink SDI source and get the stream.
	// /URL to connect to the DekTec SDI source and get the stream.
	// /URL to get a stream from NDI source. Usually NDI software display sources like `My PC (Camera1)`, convert it into `ndi://My PC/Camera1`.
	// /SMPTE 2110 UDP multicast group
	// /FRIP input. Can be a cmd if started from `-` or an existing socket.
	URL() InputURL
	// URL to connect to the H323 source and get the stream.
	// /URL to get a stream from HLS source.
	// /URL to connect to the RTMP source and get the stream.
	// RTMP uses a special URL consisting of at least two segments. *Flussonic* parses the URL and splits it into parts,
	// using the first segment as an RTMP application name.
	// /Artificial URL to connect to the SRT source and get the stream.
	// SRT requires IP and port, so we create an artificial URL to specify the options to manage the data interchange.
	// /URL for ingest and pass a stream "as is" without repackaging.
	// /URL to make a mixer stream from other streams.
	// /Special URL to make a mosaic stream.
	// /URL to get a stream from m4f source.
	// /URL to get a stream from m4s source.
	// /URL to connect to RTP source and get the stream.
	// /URL to connect to the SHOUTcast source and get the stream.
	// /Special URL to play the archive record of a stream with a fixed delay.
	// /URL to get a stream from playlist.
	// /URL to connect to the source and get a copy of the original stream.
	// /URL to connect to the SPTS source and get the stream.
	// /URL to get a stream from MPTS source.
	// /URL to connect to the Video4Linux source and get the stream.
	// /URL to connect to the Decklink SDI source and get the stream.
	// /URL to connect to the DekTec SDI source and get the stream.
	// /URL to get a stream from NDI source. Usually NDI software display sources like `My PC (Camera1)`, convert it into `ndi://My PC/Camera1`.
	// /SMPTE 2110 UDP multicast group
	// /FRIP input. Can be a cmd if started from `-` or an existing socket.
	SetURL(InputURL) StreamInput
	// User agent. Can be modified if a protocol allows it.
	UserAgent() *string
	// User agent. Can be modified if a protocol allows it.
	SetUserAgent(string) StreamInput
	// This parameter allows logging the decoded data when reading teletext from VBI.
	VbiDebug() *bool
	// This parameter allows logging the decoded data when reading teletext from VBI.
	SetVbiDebug(bool) StreamInput
	// The VBI device to capture raw VBI data from Stream Labs SDI cards. VBI data can contain information about teletext or closed captions.
	// It is actually a path to a VBI device file created on the disk by Video4Linux.
	// Example: /dev/vbi
	VbiDevice() *string
	// The VBI device to capture raw VBI data from Stream Labs SDI cards. VBI data can contain information about teletext or closed captions.
	// It is actually a path to a VBI device file created on the disk by Video4Linux.
	// Example: /dev/vbi
	SetVbiDevice(string) StreamInput
	// This parameter is used for debugging when reading teletext from VBI.
	// This is a threshold, in seconds, for turning on the decoder.
	VbiThreshold() *int
	// This parameter is used for debugging when reading teletext from VBI.
	// This is a threshold, in seconds, for turning on the decoder.
	SetVbiThreshold(int) StreamInput
	// Required SRT version.
	// Pattern: ^[0-9]+\.[0-9]+\.[0-9]+$
	// Example: 1.3.0
	Version() *string
	// Required SRT version.
	// Pattern: ^[0-9]+\.[0-9]+\.[0-9]+$
	// Example: 1.3.0
	SetVersion(string) StreamInput
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	Via() *AgentURL
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	SetVia(AgentURL) StreamInput
	// H323 input bitrate.
	// Format: speed (speed)
	VideoBitrate() *Speed
	// H323 input bitrate.
	// Format: speed (speed)
	SetVideoBitrate(Speed) StreamInput
	// The video device to capture video from Stream Labs SDI cards.
	// It is actually a path to a device file created on the disk by Video4Linux.
	// Example: /dev/video0
	VideoDevice() *string
	// The video device to capture video from Stream Labs SDI cards.
	// It is actually a path to a device file created on the disk by Video4Linux.
	// Example: /dev/video0
	SetVideoDevice(string) StreamInput
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	VideoTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetVideoTimeout(Seconds) StreamInput
	// Video interface for capturing from the Decklink card.
	// Usually, it is autodetected, but for some Decklink models you should specify it manually.
	// Example: hdmi
	Vinput() any
	// Video interface for capturing from the Decklink card.
	// Usually, it is autodetected, but for some Decklink models you should specify it manually.
	// Example: hdmi
	SetVinput(any) StreamInput
	// Synchronization mode for video captured from the Decklink card.
	Vpts() *StreamInputDecklinkVpts
	// Synchronization mode for video captured from the Decklink card.
	SetVpts(*StreamInputDecklinkVpts) StreamInput
	// Must specify received pixel width
	Width() *int
	// Must specify received pixel width
	SetWidth(int) StreamInput
}

type StreamInputBase interface {
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	AllowIf() *string
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	SetAllowIf(string) StreamInputBase
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	AudioTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetAudioTimeout(Seconds) StreamInputBase
	// Human-readable description of the input.
	// Example: This is a test input
	Comment() *string
	// Human-readable description of the input.
	// Example: This is a test input
	SetComment(string) StreamInputBase
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	DenyIf() *string
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	SetDenyIf(string) StreamInputBase
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	FramesTimeout() *int
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	SetFramesTimeout(int) StreamInputBase
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	Headers() map[string]string
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	SetHeaders(map[string]string) StreamInputBase
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	MaxRetryTimeout() *Seconds
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	SetMaxRetryTimeout(Seconds) StreamInputBase
	// Skip input start if the stream has no clients.
	NoClientsReconnectDelay() *int
	// Skip input start if the stream has no clients.
	SetNoClientsReconnectDelay(int) StreamInputBase
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	OutputAudio() *OutputAudio
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	SetOutputAudio(OutputAudio) StreamInputBase
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	Priority() *int
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	SetPriority(int) StreamInputBase
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SourceTimeout() any
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SetSourceTimeout(any) StreamInputBase
	// Detailed runtime information about the input.
	Stats() InputStats
	// Detailed runtime information about the input.
	SetStats(InputStats) StreamInputBase
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	Timeout() *int
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	SetTimeout(int) StreamInputBase
	// User agent. Can be modified if a protocol allows it.
	UserAgent() *string
	// User agent. Can be modified if a protocol allows it.
	SetUserAgent(string) StreamInputBase
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	Via() *AgentURL
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	SetVia(AgentURL) StreamInputBase
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	VideoTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetVideoTimeout(Seconds) StreamInputBase
}

type StreamInputCopy interface {
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	AllowIf() *string
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	SetAllowIf(string) StreamInputCopy
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	AudioTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetAudioTimeout(Seconds) StreamInputCopy
	// The rules for handling the closed captions.
	ClosedCaptions() map[string]string
	// The rules for handling the closed captions.
	SetClosedCaptions(map[string]string) StreamInputCopy
	// Human-readable description of the input.
	// Example: This is a test input
	Comment() *string
	// Human-readable description of the input.
	// Example: This is a test input
	SetComment(string) StreamInputCopy
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	DenyIf() *string
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	SetDenyIf(string) StreamInputCopy
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	FramesTimeout() *int
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	SetFramesTimeout(int) StreamInputCopy
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	Headers() map[string]string
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	SetHeaders(map[string]string) StreamInputCopy
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	MaxRetryTimeout() *Seconds
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	SetMaxRetryTimeout(Seconds) StreamInputCopy
	// Skip input start if the stream has no clients.
	NoClientsReconnectDelay() *int
	// Skip input start if the stream has no clients.
	SetNoClientsReconnectDelay(int) StreamInputCopy
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	OutputAudio() *OutputAudio
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	SetOutputAudio(OutputAudio) StreamInputCopy
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	Priority() *int
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	SetPriority(int) StreamInputCopy
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SourceTimeout() any
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SetSourceTimeout(any) StreamInputCopy
	// Detailed runtime information about the input.
	Stats() InputStats
	// Detailed runtime information about the input.
	SetStats(InputStats) StreamInputCopy
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	Timeout() *int
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	SetTimeout(int) StreamInputCopy
	// URL to connect to the source and get a copy of the original stream.
	// Format: input_url (input_url)
	// Pattern: ^copy://.*$
	// Example: copy://stream1
	URL() InputURL
	// URL to connect to the source and get a copy of the original stream.
	// Format: input_url (input_url)
	// Pattern: ^copy://.*$
	// Example: copy://stream1
	SetURL(InputURL) StreamInputCopy
	// User agent. Can be modified if a protocol allows it.
	UserAgent() *string
	// User agent. Can be modified if a protocol allows it.
	SetUserAgent(string) StreamInputCopy
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	Via() *AgentURL
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	SetVia(AgentURL) StreamInputCopy
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	VideoTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetVideoTimeout(Seconds) StreamInputCopy
}

type StreamInputDecklink interface {
	// Audio interface for capturing from the Decklink card.
	// Usually, it is autodetected, but for some Decklink models you should specify it manually.
	// Example: microphone
	Ainput() any
	// Audio interface for capturing from the Decklink card.
	// Usually, it is autodetected, but for some Decklink models you should specify it manually.
	// Example: microphone
	SetAinput(any) StreamInputDecklink
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	AllowIf() *string
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	SetAllowIf(string) StreamInputDecklink
	// Synchronization mode for audio captured from the Decklink card.
	Apts() *StreamInputDecklinkApts
	// Synchronization mode for audio captured from the Decklink card.
	SetApts(*StreamInputDecklinkApts) StreamInputDecklink
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	AudioTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetAudioTimeout(Seconds) StreamInputDecklink
	// Human-readable description of the input.
	// Example: This is a test input
	Comment() *string
	// Human-readable description of the input.
	// Example: This is a test input
	SetComment(string) StreamInputDecklink
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	DenyIf() *string
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	SetDenyIf(string) StreamInputDecklink
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	FramesTimeout() *int
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	SetFramesTimeout(int) StreamInputDecklink
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	Headers() map[string]string
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	SetHeaders(map[string]string) StreamInputDecklink
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	MaxRetryTimeout() *Seconds
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	SetMaxRetryTimeout(Seconds) StreamInputDecklink
	// Mode of the input stream captured from the Decklink card. It is composed of the size and FPS of the captured video.
	// Usually, it is autodetected, but for some Decklink models you'll need to specify it manually.
	// Example: 4d30
	Mode() *string
	// Mode of the input stream captured from the Decklink card. It is composed of the size and FPS of the captured video.
	// Usually, it is autodetected, but for some Decklink models you'll need to specify it manually.
	// Example: 4d30
	SetMode(string) StreamInputDecklink
	// Skip input start if the stream has no clients.
	NoClientsReconnectDelay() *int
	// Skip input start if the stream has no clients.
	SetNoClientsReconnectDelay(int) StreamInputDecklink
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	OutputAudio() *OutputAudio
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	SetOutputAudio(OutputAudio) StreamInputDecklink
	// Preferred pixel format for captured video.
	Pixel() *StreamInputDecklinkPixel
	// Preferred pixel format for captured video.
	SetPixel(StreamInputDecklinkPixel) StreamInputDecklink
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	Priority() *int
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	SetPriority(int) StreamInputDecklink
	// The ratio of the width of the display representation to the width of the pixel representation of video.
	// This parameter is used for creating non-anamorphic video from anamorphic video.
	// Example: 16:9
	Sar() *string
	// The ratio of the width of the display representation to the width of the pixel representation of video.
	// This parameter is used for creating non-anamorphic video from anamorphic video.
	// Example: 16:9
	SetSar(string) StreamInputDecklink
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SourceTimeout() any
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SetSourceTimeout(any) StreamInputDecklink
	// Detailed runtime information about the input.
	Stats() InputStats
	// Detailed runtime information about the input.
	SetStats(InputStats) StreamInputDecklink
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	Timeout() *int
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	SetTimeout(int) StreamInputDecklink
	// This information is necessary for adding into the PMT table to identify streams which carry teletext data in the resulting MPEG-TS stream.
	TtxtDescriptors() []TtxtDescriptors
	// This information is necessary for adding into the PMT table to identify streams which carry teletext data in the resulting MPEG-TS stream.
	SetTtxtDescriptors([]TtxtDescriptors) StreamInputDecklink
	// URL to connect to the Decklink SDI source and get the stream.
	// Format: input_url (input_url)
	// Pattern: ^decklink://.*$
	// Example: decklink://0
	URL() InputURL
	// URL to connect to the Decklink SDI source and get the stream.
	// Format: input_url (input_url)
	// Pattern: ^decklink://.*$
	// Example: decklink://0
	SetURL(InputURL) StreamInputDecklink
	// User agent. Can be modified if a protocol allows it.
	UserAgent() *string
	// User agent. Can be modified if a protocol allows it.
	SetUserAgent(string) StreamInputDecklink
	// This parameter allows logging the decoded data when reading teletext from VBI.
	VbiDebug() *bool
	// This parameter allows logging the decoded data when reading teletext from VBI.
	SetVbiDebug(bool) StreamInputDecklink
	// This parameter is used for debugging when reading teletext from VBI.
	// This is a threshold, in seconds, for turning on the decoder.
	VbiThreshold() *int
	// This parameter is used for debugging when reading teletext from VBI.
	// This is a threshold, in seconds, for turning on the decoder.
	SetVbiThreshold(int) StreamInputDecklink
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	Via() *AgentURL
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	SetVia(AgentURL) StreamInputDecklink
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	VideoTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetVideoTimeout(Seconds) StreamInputDecklink
	// Video interface for capturing from the Decklink card.
	// Usually, it is autodetected, but for some Decklink models you should specify it manually.
	// Example: hdmi
	Vinput() any
	// Video interface for capturing from the Decklink card.
	// Usually, it is autodetected, but for some Decklink models you should specify it manually.
	// Example: hdmi
	SetVinput(any) StreamInputDecklink
	// Synchronization mode for video captured from the Decklink card.
	Vpts() *StreamInputDecklinkVpts
	// Synchronization mode for video captured from the Decklink card.
	SetVpts(*StreamInputDecklinkVpts) StreamInputDecklink
}

type StreamInputDektec interface {
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	AllowIf() *string
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	SetAllowIf(string) StreamInputDektec
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	AudioTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetAudioTimeout(Seconds) StreamInputDektec
	// Human-readable description of the input.
	// Example: This is a test input
	Comment() *string
	// Human-readable description of the input.
	// Example: This is a test input
	SetComment(string) StreamInputDektec
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	DenyIf() *string
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	SetDenyIf(string) StreamInputDektec
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	FramesTimeout() *int
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	SetFramesTimeout(int) StreamInputDektec
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	Headers() map[string]string
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	SetHeaders(map[string]string) StreamInputDektec
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	MaxRetryTimeout() *Seconds
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	SetMaxRetryTimeout(Seconds) StreamInputDektec
	// Skip input start if the stream has no clients.
	NoClientsReconnectDelay() *int
	// Skip input start if the stream has no clients.
	SetNoClientsReconnectDelay(int) StreamInputDektec
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	OutputAudio() *OutputAudio
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	SetOutputAudio(OutputAudio) StreamInputDektec
	// Preferred pixel format for captured video.
	Pixel() *StreamInputDektecPixel
	// Preferred pixel format for captured video.
	SetPixel(StreamInputDektecPixel) StreamInputDektec
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	Priority() *int
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	SetPriority(int) StreamInputDektec
	// Source for PTS for input stream.
	PtsSource() *StreamInputDektecPtsSource
	// Source for PTS for input stream.
	SetPtsSource(StreamInputDektecPtsSource) StreamInputDektec
	// The ratio of the width of the display representation to the width of the pixel representation of video.
	// This parameter is used for creating non-anamorphic video from anamorphic video.
	// Example: 16:9
	Sar() *string
	// The ratio of the width of the display representation to the width of the pixel representation of video.
	// This parameter is used for creating non-anamorphic video from anamorphic video.
	// Example: 16:9
	SetSar(string) StreamInputDektec
	// Deprecated field. Will be deleted at 23.09
	// This option disables processing of SCTE-35 markers from an MPEG-TS input stream.
	// Deprecated since 22.12.
	// Available ways to disable processing of SCTE-35 markers:
	// 1. pids option to select tracks without SCTE-35 markers
	// 2. hls_scte35 option from stream_config_media for hls output
	// 3. performing appropriate tuning pids in the transponder
	// Example: true
	Scte35() *bool
	// Deprecated field. Will be deleted at 23.09
	// This option disables processing of SCTE-35 markers from an MPEG-TS input stream.
	// Deprecated since 22.12.
	// Available ways to disable processing of SCTE-35 markers:
	// 1. pids option to select tracks without SCTE-35 markers
	// 2. hls_scte35 option from stream_config_media for hls output
	// 3. performing appropriate tuning pids in the transponder
	// Example: true
	SetScte35(bool) StreamInputDektec
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SourceTimeout() any
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SetSourceTimeout(any) StreamInputDektec
	// Detailed runtime information about the input.
	Stats() InputStats
	// Detailed runtime information about the input.
	SetStats(InputStats) StreamInputDektec
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	Timeout() *int
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	SetTimeout(int) StreamInputDektec
	// This information is necessary for adding into the PMT table to identify streams which carry teletext data in the resulting MPEG-TS stream.
	TtxtDescriptors() []TtxtDescriptors
	// This information is necessary for adding into the PMT table to identify streams which carry teletext data in the resulting MPEG-TS stream.
	SetTtxtDescriptors([]TtxtDescriptors) StreamInputDektec
	// URL to connect to the DekTec SDI source and get the stream.
	// Format: input_url (input_url)
	// Pattern: ^dektec://.*$
	// Example: dektec://2174220025:2
	URL() InputURL
	// URL to connect to the DekTec SDI source and get the stream.
	// Format: input_url (input_url)
	// Pattern: ^dektec://.*$
	// Example: dektec://2174220025:2
	SetURL(InputURL) StreamInputDektec
	// User agent. Can be modified if a protocol allows it.
	UserAgent() *string
	// User agent. Can be modified if a protocol allows it.
	SetUserAgent(string) StreamInputDektec
	// This parameter allows logging the decoded data when reading teletext from VBI.
	VbiDebug() *bool
	// This parameter allows logging the decoded data when reading teletext from VBI.
	SetVbiDebug(bool) StreamInputDektec
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	Via() *AgentURL
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	SetVia(AgentURL) StreamInputDektec
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	VideoTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetVideoTimeout(Seconds) StreamInputDektec
}

type StreamInputFake interface {
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	AllowIf() *string
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	SetAllowIf(string) StreamInputFake
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	AudioTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetAudioTimeout(Seconds) StreamInputFake
	// Bitrate of an artificially created test video stream.
	// Applicable to the `fake://fake` URL.
	// Format: speed (speed)
	Bitrate() *Speed
	// Bitrate of an artificially created test video stream.
	// Applicable to the `fake://fake` URL.
	// Format: speed (speed)
	SetBitrate(Speed) StreamInputFake
	// Human-readable description of the input.
	// Example: This is a test input
	Comment() *string
	// Human-readable description of the input.
	// Example: This is a test input
	SetComment(string) StreamInputFake
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	DenyIf() *string
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	SetDenyIf(string) StreamInputFake
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	FramesTimeout() *int
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	SetFramesTimeout(int) StreamInputFake
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	Headers() map[string]string
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	SetHeaders(map[string]string) StreamInputFake
	// Height of an artificially created test video stream.
	// Applicable to the `fake://fake` URL.
	Height() *int
	// Height of an artificially created test video stream.
	// Applicable to the `fake://fake` URL.
	SetHeight(int) StreamInputFake
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	MaxRetryTimeout() *Seconds
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	SetMaxRetryTimeout(Seconds) StreamInputFake
	// Skip input start if the stream has no clients.
	NoClientsReconnectDelay() *int
	// Skip input start if the stream has no clients.
	SetNoClientsReconnectDelay(int) StreamInputFake
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	OutputAudio() *OutputAudio
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	SetOutputAudio(OutputAudio) StreamInputFake
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	Priority() *int
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	SetPriority(int) StreamInputFake
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SourceTimeout() any
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SetSourceTimeout(any) StreamInputFake
	// Detailed runtime information about the input.
	Stats() InputStats
	// Detailed runtime information about the input.
	SetStats(InputStats) StreamInputFake
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	Timeout() *int
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	SetTimeout(int) StreamInputFake
	// URL to get a demo stream.
	// Format: input_url (input_url)
	// Pattern: ^fake://.*$
	// Example: fake://fake
	URL() InputURL
	// URL to get a demo stream.
	// Format: input_url (input_url)
	// Pattern: ^fake://.*$
	// Example: fake://fake
	SetURL(InputURL) StreamInputFake
	// User agent. Can be modified if a protocol allows it.
	UserAgent() *string
	// User agent. Can be modified if a protocol allows it.
	SetUserAgent(string) StreamInputFake
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	Via() *AgentURL
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	SetVia(AgentURL) StreamInputFake
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	VideoTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetVideoTimeout(Seconds) StreamInputFake
	// Width of an artificially created test video stream.
	// Applicable to the `fake://fake` URL.
	Width() *int
	// Width of an artificially created test video stream.
	// Applicable to the `fake://fake` URL.
	SetWidth(int) StreamInputFake
}

type StreamInputFile interface {
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	AllowIf() *string
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	SetAllowIf(string) StreamInputFile
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	AudioTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetAudioTimeout(Seconds) StreamInputFile
	// The rules for handling the closed captions.
	ClosedCaptions() map[string]string
	// The rules for handling the closed captions.
	SetClosedCaptions(map[string]string) StreamInputFile
	// Human-readable description of the input.
	// Example: This is a test input
	Comment() *string
	// Human-readable description of the input.
	// Example: This is a test input
	SetComment(string) StreamInputFile
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	DenyIf() *string
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	SetDenyIf(string) StreamInputFile
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	FramesTimeout() *int
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	SetFramesTimeout(int) StreamInputFile
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	Headers() map[string]string
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	SetHeaders(map[string]string) StreamInputFile
	// An array of MPEG-TS language descriptors in format `[{key: track, value: language}]`
	Languages() map[string]string
	// An array of MPEG-TS language descriptors in format `[{key: track, value: language}]`
	SetLanguages(map[string]string) StreamInputFile
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	MaxRetryTimeout() *Seconds
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	SetMaxRetryTimeout(Seconds) StreamInputFile
	// Skip input start if the stream has no clients.
	NoClientsReconnectDelay() *int
	// Skip input start if the stream has no clients.
	SetNoClientsReconnectDelay(int) StreamInputFile
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	OutputAudio() *OutputAudio
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	SetOutputAudio(OutputAudio) StreamInputFile
	// Choose a specific PID to ingest from an MPEG-TS stream.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Example: [211]
	Pids() []int
	// Choose a specific PID to ingest from an MPEG-TS stream.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Example: [211]
	SetPids([]int) StreamInputFile
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	Priority() *int
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	SetPriority(int) StreamInputFile
	// Choose a program to ingest from an MPEG-TS stream.
	// Example: [1]
	Programs() []int
	// Choose a program to ingest from an MPEG-TS stream.
	// Example: [1]
	SetPrograms([]int) StreamInputFile
	// Deprecated field. Will be deleted at 23.09
	// This option disables processing of SCTE-35 markers from an MPEG-TS input stream.
	// Deprecated since 22.12.
	// Available ways to disable processing of SCTE-35 markers:
	// 1. pids option to select tracks without SCTE-35 markers
	// 2. hls_scte35 option from stream_config_media for hls output
	// 3. performing appropriate tuning pids in the transponder
	// Example: true
	Scte35() *bool
	// Deprecated field. Will be deleted at 23.09
	// This option disables processing of SCTE-35 markers from an MPEG-TS input stream.
	// Deprecated since 22.12.
	// Available ways to disable processing of SCTE-35 markers:
	// 1. pids option to select tracks without SCTE-35 markers
	// 2. hls_scte35 option from stream_config_media for hls output
	// 3. performing appropriate tuning pids in the transponder
	// Example: true
	SetScte35(bool) StreamInputFile
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SourceTimeout() any
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SetSourceTimeout(any) StreamInputFile
	// Detailed runtime information about the input.
	Stats() InputStats
	// Detailed runtime information about the input.
	SetStats(InputStats) StreamInputFile
	// Deprecated field. Will be deleted at 25.03
	// This configuration is deprecated. Use `dvbocr` configuration field in stream.
	// This parameter allows to manage subtitles in an output stream.
	// Example: drop
	Subtitles() *StreamInputMpegtsSpecificSubtitles
	// Deprecated field. Will be deleted at 25.03
	// This configuration is deprecated. Use `dvbocr` configuration field in stream.
	// This parameter allows to manage subtitles in an output stream.
	// Example: drop
	SetSubtitles(StreamInputMpegtsSpecificSubtitles) StreamInputFile
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	Timeout() *int
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	SetTimeout(int) StreamInputFile
	// URL to get a stream from file.
	// Format: input_url (input_url)
	// Pattern: ^file://.*$
	// Example: file://vod/bunny.mp4
	URL() InputURL
	// URL to get a stream from file.
	// Format: input_url (input_url)
	// Pattern: ^file://.*$
	// Example: file://vod/bunny.mp4
	SetURL(InputURL) StreamInputFile
	// User agent. Can be modified if a protocol allows it.
	UserAgent() *string
	// User agent. Can be modified if a protocol allows it.
	SetUserAgent(string) StreamInputFile
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	Via() *AgentURL
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	SetVia(AgentURL) StreamInputFile
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	VideoTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetVideoTimeout(Seconds) StreamInputFile
}

type StreamInputFrip interface {
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	AllowIf() *string
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	SetAllowIf(string) StreamInputFrip
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	AudioTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetAudioTimeout(Seconds) StreamInputFrip
	// Human-readable description of the input.
	// Example: This is a test input
	Comment() *string
	// Human-readable description of the input.
	// Example: This is a test input
	SetComment(string) StreamInputFrip
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	DenyIf() *string
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	SetDenyIf(string) StreamInputFrip
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	FramesTimeout() *int
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	SetFramesTimeout(int) StreamInputFrip
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	Headers() map[string]string
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	SetHeaders(map[string]string) StreamInputFrip
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	MaxRetryTimeout() *Seconds
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	SetMaxRetryTimeout(Seconds) StreamInputFrip
	// Skip input start if the stream has no clients.
	NoClientsReconnectDelay() *int
	// Skip input start if the stream has no clients.
	SetNoClientsReconnectDelay(int) StreamInputFrip
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	OutputAudio() *OutputAudio
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	SetOutputAudio(OutputAudio) StreamInputFrip
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	Priority() *int
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	SetPriority(int) StreamInputFrip
	// Size of shared memory buffer. Omit to make it auto
	// Example: 1.024e+06
	ShmemSize() *int
	// Size of shared memory buffer. Omit to make it auto
	// Example: 1.024e+06
	SetShmemSize(int) StreamInputFrip
	// Directory for shmem files
	// Example: tmp
	SocketDir() *string
	// Directory for shmem files
	// Example: tmp
	SetSocketDir(string) StreamInputFrip
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SourceTimeout() any
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SetSourceTimeout(any) StreamInputFrip
	// Detailed runtime information about the input.
	Stats() InputStats
	// Detailed runtime information about the input.
	SetStats(InputStats) StreamInputFrip
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	Timeout() *int
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	SetTimeout(int) StreamInputFrip
	// FRIP input. Can be a cmd if started from `-` or an existing socket.
	// Format: input_url (input_url)
	// Pattern: ^frip://.*$
	// Examples: frip://-contrib/devel/simulator.erl, frip://hostname/Source1
	URL() InputURL
	// FRIP input. Can be a cmd if started from `-` or an existing socket.
	// Format: input_url (input_url)
	// Pattern: ^frip://.*$
	// Examples: frip://-contrib/devel/simulator.erl, frip://hostname/Source1
	SetURL(InputURL) StreamInputFrip
	// User agent. Can be modified if a protocol allows it.
	UserAgent() *string
	// User agent. Can be modified if a protocol allows it.
	SetUserAgent(string) StreamInputFrip
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	Via() *AgentURL
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	SetVia(AgentURL) StreamInputFrip
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	VideoTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetVideoTimeout(Seconds) StreamInputFrip
}

type StreamInputH323 interface {
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	AllowIf() *string
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	SetAllowIf(string) StreamInputH323
	// H323 audio bitrate.
	// Format: speed (speed)
	AudioBitrate() *Speed
	// H323 audio bitrate.
	// Format: speed (speed)
	SetAudioBitrate(Speed) StreamInputH323
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	AudioTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetAudioTimeout(Seconds) StreamInputH323
	// Human-readable description of the input.
	// Example: This is a test input
	Comment() *string
	// Human-readable description of the input.
	// Example: This is a test input
	SetComment(string) StreamInputH323
	// H323 connections.
	Connections() *int
	// H323 connections.
	SetConnections(int) StreamInputH323
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	DenyIf() *string
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	SetDenyIf(string) StreamInputH323
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	FramesTimeout() *int
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	SetFramesTimeout(int) StreamInputH323
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	Headers() map[string]string
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	SetHeaders(map[string]string) StreamInputH323
	// H323 input ID.
	ID() *string
	// H323 input ID.
	SetID(string) StreamInputH323
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	MaxRetryTimeout() *Seconds
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	SetMaxRetryTimeout(Seconds) StreamInputH323
	// Skip input start if the stream has no clients.
	NoClientsReconnectDelay() *int
	// Skip input start if the stream has no clients.
	SetNoClientsReconnectDelay(int) StreamInputH323
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	OutputAudio() *OutputAudio
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	SetOutputAudio(OutputAudio) StreamInputH323
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	Priority() *int
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	SetPriority(int) StreamInputH323
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SourceTimeout() any
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SetSourceTimeout(any) StreamInputH323
	// Detailed runtime information about the input.
	Stats() InputStats
	// Detailed runtime information about the input.
	SetStats(InputStats) StreamInputH323
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	Timeout() *int
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	SetTimeout(int) StreamInputH323
	// URL to connect to the H323 source and get the stream.
	// Format: input_url (input_url)
	// Pattern: ^h323://.*$
	// Example: h323://192.168.100.150
	URL() InputURL
	// URL to connect to the H323 source and get the stream.
	// Format: input_url (input_url)
	// Pattern: ^h323://.*$
	// Example: h323://192.168.100.150
	SetURL(InputURL) StreamInputH323
	// User agent. Can be modified if a protocol allows it.
	UserAgent() *string
	// User agent. Can be modified if a protocol allows it.
	SetUserAgent(string) StreamInputH323
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	Via() *AgentURL
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	SetVia(AgentURL) StreamInputH323
	// H323 input bitrate.
	// Format: speed (speed)
	VideoBitrate() *Speed
	// H323 input bitrate.
	// Format: speed (speed)
	SetVideoBitrate(Speed) StreamInputH323
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	VideoTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetVideoTimeout(Seconds) StreamInputH323
}

type StreamInputHls interface {
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	AllowIf() *string
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	SetAllowIf(string) StreamInputHls
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	AudioTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetAudioTimeout(Seconds) StreamInputHls
	// The rules for handling the closed captions.
	ClosedCaptions() map[string]string
	// The rules for handling the closed captions.
	SetClosedCaptions(map[string]string) StreamInputHls
	// Human-readable description of the input.
	// Example: This is a test input
	Comment() *string
	// Human-readable description of the input.
	// Example: This is a test input
	SetComment(string) StreamInputHls
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	DenyIf() *string
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	SetDenyIf(string) StreamInputHls
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	FramesTimeout() *int
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	SetFramesTimeout(int) StreamInputHls
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	Headers() map[string]string
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	SetHeaders(map[string]string) StreamInputHls
	// An array of MPEG-TS language descriptors in format `[{key: track, value: language}]`
	Languages() map[string]string
	// An array of MPEG-TS language descriptors in format `[{key: track, value: language}]`
	SetLanguages(map[string]string) StreamInputHls
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	MaxRetryTimeout() *Seconds
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	SetMaxRetryTimeout(Seconds) StreamInputHls
	// Skip input start if the stream has no clients.
	NoClientsReconnectDelay() *int
	// Skip input start if the stream has no clients.
	SetNoClientsReconnectDelay(int) StreamInputHls
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	OutputAudio() *OutputAudio
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	SetOutputAudio(OutputAudio) StreamInputHls
	// Choose a specific PID to ingest from an MPEG-TS stream.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Example: [211]
	Pids() []int
	// Choose a specific PID to ingest from an MPEG-TS stream.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Example: [211]
	SetPids([]int) StreamInputHls
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	Priority() *int
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	SetPriority(int) StreamInputHls
	// Choose a program to ingest from an MPEG-TS stream.
	// Example: [1]
	Programs() []int
	// Choose a program to ingest from an MPEG-TS stream.
	// Example: [1]
	SetPrograms([]int) StreamInputHls
	// Deprecated field. Will be deleted at 23.09
	// This option disables processing of SCTE-35 markers from an MPEG-TS input stream.
	// Deprecated since 22.12.
	// Available ways to disable processing of SCTE-35 markers:
	// 1. pids option to select tracks without SCTE-35 markers
	// 2. hls_scte35 option from stream_config_media for hls output
	// 3. performing appropriate tuning pids in the transponder
	// Example: true
	Scte35() *bool
	// Deprecated field. Will be deleted at 23.09
	// This option disables processing of SCTE-35 markers from an MPEG-TS input stream.
	// Deprecated since 22.12.
	// Available ways to disable processing of SCTE-35 markers:
	// 1. pids option to select tracks without SCTE-35 markers
	// 2. hls_scte35 option from stream_config_media for hls output
	// 3. performing appropriate tuning pids in the transponder
	// Example: true
	SetScte35(bool) StreamInputHls
	// By default Flussonic will wait for at least 2-3 new segments before making stream available.
	// This parameter allows to disable this protection. Use it at your own risk - with it enabled, old content might be repeated over and over.
	SkipStalledCheck() *bool
	// By default Flussonic will wait for at least 2-3 new segments before making stream available.
	// This parameter allows to disable this protection. Use it at your own risk - with it enabled, old content might be repeated over and over.
	SetSkipStalledCheck(bool) StreamInputHls
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SourceTimeout() any
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SetSourceTimeout(any) StreamInputHls
	// Detailed runtime information about the input.
	Stats() InputStats
	// Detailed runtime information about the input.
	SetStats(InputStats) StreamInputHls
	// Deprecated field. Will be deleted at 25.03
	// This configuration is deprecated. Use `dvbocr` configuration field in stream.
	// This parameter allows to manage subtitles in an output stream.
	// Example: drop
	Subtitles() *StreamInputMpegtsSpecificSubtitles
	// Deprecated field. Will be deleted at 25.03
	// This configuration is deprecated. Use `dvbocr` configuration field in stream.
	// This parameter allows to manage subtitles in an output stream.
	// Example: drop
	SetSubtitles(StreamInputMpegtsSpecificSubtitles) StreamInputHls
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	Timeout() *int
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	SetTimeout(int) StreamInputHls
	// URL to get a stream from HLS source.
	// Format: input_url (input_url)
	// Pattern: ^(hls|hlss|hls2|hlss2)://.*$|^(http|https)://.*\.m3u8((#|\?).*)?$
	// Examples: hls2://remote.host.com/example/video.m3u8, hls://remote.host.com/example/index.m3u8, hls://remote.host.com/example/video.m3u8, hlss2://remote.host.com/example/video.m3u8, hlss://remote.host.com/example/video.m3u8, http://remote.host.com/index.m3u8, https://remote.host.com/index.m3u8
	URL() InputURL
	// URL to get a stream from HLS source.
	// Format: input_url (input_url)
	// Pattern: ^(hls|hlss|hls2|hlss2)://.*$|^(http|https)://.*\.m3u8((#|\?).*)?$
	// Examples: hls2://remote.host.com/example/video.m3u8, hls://remote.host.com/example/index.m3u8, hls://remote.host.com/example/video.m3u8, hlss2://remote.host.com/example/video.m3u8, hlss://remote.host.com/example/video.m3u8, http://remote.host.com/index.m3u8, https://remote.host.com/index.m3u8
	SetURL(InputURL) StreamInputHls
	// User agent. Can be modified if a protocol allows it.
	UserAgent() *string
	// User agent. Can be modified if a protocol allows it.
	SetUserAgent(string) StreamInputHls
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	Via() *AgentURL
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	SetVia(AgentURL) StreamInputHls
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	VideoTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetVideoTimeout(Seconds) StreamInputHls
}

type StreamInputM4f interface {
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	AllowIf() *string
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	SetAllowIf(string) StreamInputM4f
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	AudioTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetAudioTimeout(Seconds) StreamInputM4f
	// The rules for handling the closed captions.
	ClosedCaptions() map[string]string
	// The rules for handling the closed captions.
	SetClosedCaptions(map[string]string) StreamInputM4f
	// Human-readable description of the input.
	// Example: This is a test input
	Comment() *string
	// Human-readable description of the input.
	// Example: This is a test input
	SetComment(string) StreamInputM4f
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	DenyIf() *string
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	SetDenyIf(string) StreamInputM4f
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	FramesTimeout() *int
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	SetFramesTimeout(int) StreamInputM4f
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	Headers() map[string]string
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	SetHeaders(map[string]string) StreamInputM4f
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	MaxRetryTimeout() *Seconds
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	SetMaxRetryTimeout(Seconds) StreamInputM4f
	// Skip input start if the stream has no clients.
	NoClientsReconnectDelay() *int
	// Skip input start if the stream has no clients.
	SetNoClientsReconnectDelay(int) StreamInputM4f
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	OutputAudio() *OutputAudio
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	SetOutputAudio(OutputAudio) StreamInputM4f
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	Priority() *int
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	SetPriority(int) StreamInputM4f
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SourceTimeout() any
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SetSourceTimeout(any) StreamInputM4f
	// Detailed runtime information about the input.
	Stats() InputStats
	// Detailed runtime information about the input.
	SetStats(InputStats) StreamInputM4f
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	Timeout() *int
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	SetTimeout(int) StreamInputM4f
	// URL to get a stream from m4f source.
	// Format: input_url (input_url)
	// Pattern: ^(m4f|m4fs)://.*$
	// Examples: m4f://remote.host.com/example, m4fs://remote.host.com/example
	URL() InputURL
	// URL to get a stream from m4f source.
	// Format: input_url (input_url)
	// Pattern: ^(m4f|m4fs)://.*$
	// Examples: m4f://remote.host.com/example, m4fs://remote.host.com/example
	SetURL(InputURL) StreamInputM4f
	// User agent. Can be modified if a protocol allows it.
	UserAgent() *string
	// User agent. Can be modified if a protocol allows it.
	SetUserAgent(string) StreamInputM4f
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	Via() *AgentURL
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	SetVia(AgentURL) StreamInputM4f
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	VideoTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetVideoTimeout(Seconds) StreamInputM4f
}

type StreamInputM4s interface {
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	AllowIf() *string
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	SetAllowIf(string) StreamInputM4s
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	AudioTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetAudioTimeout(Seconds) StreamInputM4s
	// The rules for handling the closed captions.
	ClosedCaptions() map[string]string
	// The rules for handling the closed captions.
	SetClosedCaptions(map[string]string) StreamInputM4s
	// Human-readable description of the input.
	// Example: This is a test input
	Comment() *string
	// Human-readable description of the input.
	// Example: This is a test input
	SetComment(string) StreamInputM4s
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	DenyIf() *string
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	SetDenyIf(string) StreamInputM4s
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	FramesTimeout() *int
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	SetFramesTimeout(int) StreamInputM4s
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	Headers() map[string]string
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	SetHeaders(map[string]string) StreamInputM4s
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	MaxRetryTimeout() *Seconds
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	SetMaxRetryTimeout(Seconds) StreamInputM4s
	// Skip input start if the stream has no clients.
	NoClientsReconnectDelay() *int
	// Skip input start if the stream has no clients.
	SetNoClientsReconnectDelay(int) StreamInputM4s
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	OutputAudio() *OutputAudio
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	SetOutputAudio(OutputAudio) StreamInputM4s
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	Priority() *int
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	SetPriority(int) StreamInputM4s
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SourceTimeout() any
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SetSourceTimeout(any) StreamInputM4s
	// Detailed runtime information about the input.
	Stats() InputStats
	// Detailed runtime information about the input.
	SetStats(InputStats) StreamInputM4s
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	Timeout() *int
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	SetTimeout(int) StreamInputM4s
	// URL to get a stream from m4s source.
	// Format: input_url (input_url)
	// Pattern: ^(m4s|m4ss)://.*$
	// Examples: m4s://remote.host.com/example, m4ss://remote.host.com/example
	URL() InputURL
	// URL to get a stream from m4s source.
	// Format: input_url (input_url)
	// Pattern: ^(m4s|m4ss)://.*$
	// Examples: m4s://remote.host.com/example, m4ss://remote.host.com/example
	SetURL(InputURL) StreamInputM4s
	// User agent. Can be modified if a protocol allows it.
	UserAgent() *string
	// User agent. Can be modified if a protocol allows it.
	SetUserAgent(string) StreamInputM4s
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	Via() *AgentURL
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	SetVia(AgentURL) StreamInputM4s
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	VideoTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetVideoTimeout(Seconds) StreamInputM4s
}

type StreamInputMixer interface {
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	AllowIf() *string
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	SetAllowIf(string) StreamInputMixer
	// Deprecated field. Will be deleted at 23.09
	// Moves audio timestamp forwards or backwards on a specified number of milliseconds.
	// Format: milliseconds (milliseconds)
	AudioAdd() *Milliseconds
	// Deprecated field. Will be deleted at 23.09
	// Moves audio timestamp forwards or backwards on a specified number of milliseconds.
	// Format: milliseconds (milliseconds)
	SetAudioAdd(Milliseconds) StreamInputMixer
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	AudioTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetAudioTimeout(Seconds) StreamInputMixer
	// Human-readable description of the input.
	// Example: This is a test input
	Comment() *string
	// Human-readable description of the input.
	// Example: This is a test input
	SetComment(string) StreamInputMixer
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	DenyIf() *string
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	SetDenyIf(string) StreamInputMixer
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	FramesTimeout() *int
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	SetFramesTimeout(int) StreamInputMixer
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	Headers() map[string]string
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	SetHeaders(map[string]string) StreamInputMixer
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	MaxRetryTimeout() *Seconds
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	SetMaxRetryTimeout(Seconds) StreamInputMixer
	// The mixing mode for the `mixer://` input type.
	MixerStrategy() *StreamInputMixerMixerStrategy
	// The mixing mode for the `mixer://` input type.
	SetMixerStrategy(StreamInputMixerMixerStrategy) StreamInputMixer
	// Skip input start if the stream has no clients.
	NoClientsReconnectDelay() *int
	// Skip input start if the stream has no clients.
	SetNoClientsReconnectDelay(int) StreamInputMixer
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	OutputAudio() *OutputAudio
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	SetOutputAudio(OutputAudio) StreamInputMixer
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	Priority() *int
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	SetPriority(int) StreamInputMixer
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SourceTimeout() any
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SetSourceTimeout(any) StreamInputMixer
	// Detailed runtime information about the input.
	Stats() InputStats
	// Detailed runtime information about the input.
	SetStats(InputStats) StreamInputMixer
	// This parameter is used for a mixer stream that uses other streams as its video and audio sources.
	// If the parameter is set to `realtime`, audio frames will be played in sync with video frames:
	// if the difference between timestamps of an audio frame and a corresponding video frame is more than 2 seconds,
	// the audio frame will be played at the timestamp of the video frame.
	// If this parameter is set to `dts`, no synchronization is performed.
	// Example: dts
	Sync() *string
	// This parameter is used for a mixer stream that uses other streams as its video and audio sources.
	// If the parameter is set to `realtime`, audio frames will be played in sync with video frames:
	// if the difference between timestamps of an audio frame and a corresponding video frame is more than 2 seconds,
	// the audio frame will be played at the timestamp of the video frame.
	// If this parameter is set to `dts`, no synchronization is performed.
	// Example: dts
	SetSync(string) StreamInputMixer
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	Timeout() *int
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	SetTimeout(int) StreamInputMixer
	// URL to make a mixer stream from other streams.
	// Format: input_url (input_url)
	// Pattern: ^mixer://.*$
	// Example: mixer://stream1,stream2
	URL() InputURL
	// URL to make a mixer stream from other streams.
	// Format: input_url (input_url)
	// Pattern: ^mixer://.*$
	// Example: mixer://stream1,stream2
	SetURL(InputURL) StreamInputMixer
	// User agent. Can be modified if a protocol allows it.
	UserAgent() *string
	// User agent. Can be modified if a protocol allows it.
	SetUserAgent(string) StreamInputMixer
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	Via() *AgentURL
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	SetVia(AgentURL) StreamInputMixer
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	VideoTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetVideoTimeout(Seconds) StreamInputMixer
}

type StreamInputMosaic interface {
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	AllowIf() *string
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	SetAllowIf(string) StreamInputMosaic
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	AudioTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetAudioTimeout(Seconds) StreamInputMosaic
	// Bitrate of the audio.
	// Format: speed (speed)
	Bitrate() *Speed
	// Bitrate of the audio.
	// Format: speed (speed)
	SetBitrate(Speed) StreamInputMosaic
	// Human-readable description of the input.
	// Example: This is a test input
	Comment() *string
	// Human-readable description of the input.
	// Example: This is a test input
	SetComment(string) StreamInputMosaic
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	DenyIf() *string
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	SetDenyIf(string) StreamInputMosaic
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	FramesTimeout() *int
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	SetFramesTimeout(int) StreamInputMosaic
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	Headers() map[string]string
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	SetHeaders(map[string]string) StreamInputMosaic
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	MaxRetryTimeout() *Seconds
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	SetMaxRetryTimeout(Seconds) StreamInputMosaic
	// Skip input start if the stream has no clients.
	NoClientsReconnectDelay() *int
	// Skip input start if the stream has no clients.
	SetNoClientsReconnectDelay(int) StreamInputMosaic
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	OutputAudio() *OutputAudio
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	SetOutputAudio(OutputAudio) StreamInputMosaic
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	Priority() *int
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	SetPriority(int) StreamInputMosaic
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SourceTimeout() any
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SetSourceTimeout(any) StreamInputMosaic
	// Detailed runtime information about the input.
	Stats() InputStats
	// Detailed runtime information about the input.
	SetStats(InputStats) StreamInputMosaic
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	Timeout() *int
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	SetTimeout(int) StreamInputMosaic
	// Special URL to make a mosaic stream.
	// Format: input_url (input_url)
	// Pattern: ^(mosaic|mosaic2)://.*$
	// Examples: mosaic2://, mosaic://cam1,cam2,cam3,cam4?fps=20&preset=ultrafast&bitrate=1024k&size=340x240&mosaic_size=16
	URL() InputURL
	// Special URL to make a mosaic stream.
	// Format: input_url (input_url)
	// Pattern: ^(mosaic|mosaic2)://.*$
	// Examples: mosaic2://, mosaic://cam1,cam2,cam3,cam4?fps=20&preset=ultrafast&bitrate=1024k&size=340x240&mosaic_size=16
	SetURL(InputURL) StreamInputMosaic
	// User agent. Can be modified if a protocol allows it.
	UserAgent() *string
	// User agent. Can be modified if a protocol allows it.
	SetUserAgent(string) StreamInputMosaic
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	Via() *AgentURL
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	SetVia(AgentURL) StreamInputMosaic
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	VideoTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetVideoTimeout(Seconds) StreamInputMosaic
}

type StreamInputMpegtsSpecific interface {
	// The rules for handling the closed captions.
	ClosedCaptions() map[string]string
	// The rules for handling the closed captions.
	SetClosedCaptions(map[string]string) StreamInputMpegtsSpecific
	// An array of MPEG-TS language descriptors in format `[{key: track, value: language}]`
	Languages() map[string]string
	// An array of MPEG-TS language descriptors in format `[{key: track, value: language}]`
	SetLanguages(map[string]string) StreamInputMpegtsSpecific
	// Choose a specific PID to ingest from an MPEG-TS stream.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Example: [211]
	Pids() []int
	// Choose a specific PID to ingest from an MPEG-TS stream.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Example: [211]
	SetPids([]int) StreamInputMpegtsSpecific
	// Choose a program to ingest from an MPEG-TS stream.
	// Example: [1]
	Programs() []int
	// Choose a program to ingest from an MPEG-TS stream.
	// Example: [1]
	SetPrograms([]int) StreamInputMpegtsSpecific
	// Deprecated field. Will be deleted at 23.09
	// This option disables processing of SCTE-35 markers from an MPEG-TS input stream.
	// Deprecated since 22.12.
	// Available ways to disable processing of SCTE-35 markers:
	// 1. pids option to select tracks without SCTE-35 markers
	// 2. hls_scte35 option from stream_config_media for hls output
	// 3. performing appropriate tuning pids in the transponder
	// Example: true
	Scte35() *bool
	// Deprecated field. Will be deleted at 23.09
	// This option disables processing of SCTE-35 markers from an MPEG-TS input stream.
	// Deprecated since 22.12.
	// Available ways to disable processing of SCTE-35 markers:
	// 1. pids option to select tracks without SCTE-35 markers
	// 2. hls_scte35 option from stream_config_media for hls output
	// 3. performing appropriate tuning pids in the transponder
	// Example: true
	SetScte35(bool) StreamInputMpegtsSpecific
	// Deprecated field. Will be deleted at 25.03
	// This configuration is deprecated. Use `dvbocr` configuration field in stream.
	// This parameter allows to manage subtitles in an output stream.
	// Example: drop
	Subtitles() *StreamInputMpegtsSpecificSubtitles
	// Deprecated field. Will be deleted at 25.03
	// This configuration is deprecated. Use `dvbocr` configuration field in stream.
	// This parameter allows to manage subtitles in an output stream.
	// Example: drop
	SetSubtitles(StreamInputMpegtsSpecificSubtitles) StreamInputMpegtsSpecific
}

type StreamInputMpts interface {
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	AllowIf() *string
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	SetAllowIf(string) StreamInputMpts
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	AudioTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetAudioTimeout(Seconds) StreamInputMpts
	// The rules for handling the closed captions.
	ClosedCaptions() map[string]string
	// The rules for handling the closed captions.
	SetClosedCaptions(map[string]string) StreamInputMpts
	// Human-readable description of the input.
	// Example: This is a test input
	Comment() *string
	// Human-readable description of the input.
	// Example: This is a test input
	SetComment(string) StreamInputMpts
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	DenyIf() *string
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	SetDenyIf(string) StreamInputMpts
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	FramesTimeout() *int
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	SetFramesTimeout(int) StreamInputMpts
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	Headers() map[string]string
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	SetHeaders(map[string]string) StreamInputMpts
	// An array of MPEG-TS language descriptors in format `[{key: track, value: language}]`
	Languages() map[string]string
	// An array of MPEG-TS language descriptors in format `[{key: track, value: language}]`
	SetLanguages(map[string]string) StreamInputMpts
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	MaxRetryTimeout() *Seconds
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	SetMaxRetryTimeout(Seconds) StreamInputMpts
	// Skip input start if the stream has no clients.
	NoClientsReconnectDelay() *int
	// Skip input start if the stream has no clients.
	SetNoClientsReconnectDelay(int) StreamInputMpts
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	OutputAudio() *OutputAudio
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	SetOutputAudio(OutputAudio) StreamInputMpts
	// Choose a specific PID to ingest from an MPEG-TS stream.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Example: [211]
	Pids() []int
	// Choose a specific PID to ingest from an MPEG-TS stream.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Example: [211]
	SetPids([]int) StreamInputMpts
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	Priority() *int
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	SetPriority(int) StreamInputMpts
	// Choose a program to ingest from an MPEG-TS stream.
	// Example: [1]
	Programs() []int
	// Choose a program to ingest from an MPEG-TS stream.
	// Example: [1]
	SetPrograms([]int) StreamInputMpts
	// Deprecated field. Will be deleted at 23.09
	// This option disables processing of SCTE-35 markers from an MPEG-TS input stream.
	// Deprecated since 22.12.
	// Available ways to disable processing of SCTE-35 markers:
	// 1. pids option to select tracks without SCTE-35 markers
	// 2. hls_scte35 option from stream_config_media for hls output
	// 3. performing appropriate tuning pids in the transponder
	// Example: true
	Scte35() *bool
	// Deprecated field. Will be deleted at 23.09
	// This option disables processing of SCTE-35 markers from an MPEG-TS input stream.
	// Deprecated since 22.12.
	// Available ways to disable processing of SCTE-35 markers:
	// 1. pids option to select tracks without SCTE-35 markers
	// 2. hls_scte35 option from stream_config_media for hls output
	// 3. performing appropriate tuning pids in the transponder
	// Example: true
	SetScte35(bool) StreamInputMpts
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SourceTimeout() any
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SetSourceTimeout(any) StreamInputMpts
	// Detailed runtime information about the input.
	Stats() InputStats
	// Detailed runtime information about the input.
	SetStats(InputStats) StreamInputMpts
	// Deprecated field. Will be deleted at 25.03
	// This configuration is deprecated. Use `dvbocr` configuration field in stream.
	// This parameter allows to manage subtitles in an output stream.
	// Example: drop
	Subtitles() *StreamInputMpegtsSpecificSubtitles
	// Deprecated field. Will be deleted at 25.03
	// This configuration is deprecated. Use `dvbocr` configuration field in stream.
	// This parameter allows to manage subtitles in an output stream.
	// Example: drop
	SetSubtitles(StreamInputMpegtsSpecificSubtitles) StreamInputMpts
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	Timeout() *int
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	SetTimeout(int) StreamInputMpts
	// URL to get a stream from MPTS source.
	// Format: input_url (input_url)
	// Pattern: ^(mpts-udp|mpts-http|mpts-https|mpts-dvb|dvb)://.*$
	// Examples: dvb://asi_10?program=15, mpts-dvb://asi_10?program=15, mpts-http://239.0.0.1:1234, mpts-https://239.0.0.1:1234, mpts-udp://239.0.0.1:1234
	URL() InputURL
	// URL to get a stream from MPTS source.
	// Format: input_url (input_url)
	// Pattern: ^(mpts-udp|mpts-http|mpts-https|mpts-dvb|dvb)://.*$
	// Examples: dvb://asi_10?program=15, mpts-dvb://asi_10?program=15, mpts-http://239.0.0.1:1234, mpts-https://239.0.0.1:1234, mpts-udp://239.0.0.1:1234
	SetURL(InputURL) StreamInputMpts
	// User agent. Can be modified if a protocol allows it.
	UserAgent() *string
	// User agent. Can be modified if a protocol allows it.
	SetUserAgent(string) StreamInputMpts
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	Via() *AgentURL
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	SetVia(AgentURL) StreamInputMpts
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	VideoTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetVideoTimeout(Seconds) StreamInputMpts
}

type StreamInputNdi interface {
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	AllowIf() *string
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	SetAllowIf(string) StreamInputNdi
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	AudioTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetAudioTimeout(Seconds) StreamInputNdi
	// Human-readable description of the input.
	// Example: This is a test input
	Comment() *string
	// Human-readable description of the input.
	// Example: This is a test input
	SetComment(string) StreamInputNdi
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	DenyIf() *string
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	SetDenyIf(string) StreamInputNdi
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	FramesTimeout() *int
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	SetFramesTimeout(int) StreamInputNdi
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	Headers() map[string]string
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	SetHeaders(map[string]string) StreamInputNdi
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	MaxRetryTimeout() *Seconds
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	SetMaxRetryTimeout(Seconds) StreamInputNdi
	// Skip input start if the stream has no clients.
	NoClientsReconnectDelay() *int
	// Skip input start if the stream has no clients.
	SetNoClientsReconnectDelay(int) StreamInputNdi
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	OutputAudio() *OutputAudio
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	SetOutputAudio(OutputAudio) StreamInputNdi
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	Priority() *int
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	SetPriority(int) StreamInputNdi
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SourceTimeout() any
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SetSourceTimeout(any) StreamInputNdi
	// Detailed runtime information about the input.
	Stats() InputStats
	// Detailed runtime information about the input.
	SetStats(InputStats) StreamInputNdi
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	Timeout() *int
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	SetTimeout(int) StreamInputNdi
	// URL to get a stream from NDI source. Usually NDI software display sources like `My PC (Camera1)`, convert it into `ndi://My PC/Camera1`.
	// Format: input_url (input_url)
	// Pattern: ^ndi://.*$
	// Example: ndi://hostname/Source1
	URL() InputURL
	// URL to get a stream from NDI source. Usually NDI software display sources like `My PC (Camera1)`, convert it into `ndi://My PC/Camera1`.
	// Format: input_url (input_url)
	// Pattern: ^ndi://.*$
	// Example: ndi://hostname/Source1
	SetURL(InputURL) StreamInputNdi
	// User agent. Can be modified if a protocol allows it.
	UserAgent() *string
	// User agent. Can be modified if a protocol allows it.
	SetUserAgent(string) StreamInputNdi
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	Via() *AgentURL
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	SetVia(AgentURL) StreamInputNdi
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	VideoTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetVideoTimeout(Seconds) StreamInputNdi
}

type StreamInputPlaylist interface {
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	AllowIf() *string
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	SetAllowIf(string) StreamInputPlaylist
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	AudioTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetAudioTimeout(Seconds) StreamInputPlaylist
	// Human-readable description of the input.
	// Example: This is a test input
	Comment() *string
	// Human-readable description of the input.
	// Example: This is a test input
	SetComment(string) StreamInputPlaylist
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	DenyIf() *string
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	SetDenyIf(string) StreamInputPlaylist
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	FramesTimeout() *int
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	SetFramesTimeout(int) StreamInputPlaylist
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	Headers() map[string]string
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	SetHeaders(map[string]string) StreamInputPlaylist
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	MaxRetryTimeout() *Seconds
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	SetMaxRetryTimeout(Seconds) StreamInputPlaylist
	// Skip input start if the stream has no clients.
	NoClientsReconnectDelay() *int
	// Skip input start if the stream has no clients.
	SetNoClientsReconnectDelay(int) StreamInputPlaylist
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	OutputAudio() *OutputAudio
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	SetOutputAudio(OutputAudio) StreamInputPlaylist
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	Priority() *int
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	SetPriority(int) StreamInputPlaylist
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SourceTimeout() any
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SetSourceTimeout(any) StreamInputPlaylist
	// Detailed runtime information about the input.
	Stats() InputStats
	// Detailed runtime information about the input.
	SetStats(InputStats) StreamInputPlaylist
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	Timeout() *int
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	SetTimeout(int) StreamInputPlaylist
	// URL to get a stream from playlist.
	// Format: input_url (input_url)
	// Pattern: ^playlist://.*$
	// Example: playlist://remote.host.com/example.m3u8
	URL() InputURL
	// URL to get a stream from playlist.
	// Format: input_url (input_url)
	// Pattern: ^playlist://.*$
	// Example: playlist://remote.host.com/example.m3u8
	SetURL(InputURL) StreamInputPlaylist
	// User agent. Can be modified if a protocol allows it.
	UserAgent() *string
	// User agent. Can be modified if a protocol allows it.
	SetUserAgent(string) StreamInputPlaylist
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	Via() *AgentURL
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	SetVia(AgentURL) StreamInputPlaylist
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	VideoTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetVideoTimeout(Seconds) StreamInputPlaylist
}

type StreamInputPublish interface {
	// The correction between the target bitrate (Receiver Estimated Maximum Bitrate, calculated in Flussonic) and browser bitrate, in kbit/s.
	// Flussonic sends the target bitrate to the browser from which the publication is carried out so that the browser adjusts the bitrate of the publication by this value.
	// The default value is 300 kbit/s.
	// Example: 200
	AbrCorrection() *int
	// The correction between the target bitrate (Receiver Estimated Maximum Bitrate, calculated in Flussonic) and browser bitrate, in kbit/s.
	// Flussonic sends the target bitrate to the browser from which the publication is carried out so that the browser adjusts the bitrate of the publication by this value.
	// The default value is 300 kbit/s.
	// Example: 200
	SetAbrCorrection(int) StreamInputPublish
	// The number of cycles of bitrate auto-adjustment.
	// After the specified number of auto-adjustment cycles passes, Flussonic considers the bitrate to be optimal, and it is no longer analyzed.
	// By default, `abr_cycles`=5.
	// If `abr_cycles`=0, the adjustment process takes place all the time while the publication lasts.
	// Example: 3
	AbrCycles() *int
	// The number of cycles of bitrate auto-adjustment.
	// After the specified number of auto-adjustment cycles passes, Flussonic considers the bitrate to be optimal, and it is no longer analyzed.
	// By default, `abr_cycles`=5.
	// If `abr_cycles`=0, the adjustment process takes place all the time while the publication lasts.
	// Example: 3
	SetAbrCycles(int) StreamInputPublish
	// Whether adaptive bitrate process is logged.
	// Example: 1
	AbrDebug() *int
	// Whether adaptive bitrate process is logged.
	// Example: 1
	SetAbrDebug(int) StreamInputPublish
	// The lower limit of packet loss. When it is reached, Flussonic raises the bitrate.
	// That is, if packet loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup` percent.
	// Example: 2
	AbrLossLower() *float64
	// The lower limit of packet loss. When it is reached, Flussonic raises the bitrate.
	// That is, if packet loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup` percent.
	// Example: 2
	SetAbrLossLower(float64) StreamInputPublish
	// The upper limit of packet loss. When it is reached, Flussonic reduces the bitrate.
	// That is, if packet loss is greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.
	// Example: 10
	AbrLossUpper() *float64
	// The upper limit of packet loss. When it is reached, Flussonic reduces the bitrate.
	// That is, if packet loss is greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.
	// Example: 10
	SetAbrLossUpper(float64) StreamInputPublish
	// Maximum bitrate for adjustment process, in kbit/s.
	// Flussonic will keep the publication bitrate equal or below of the specified value.
	// Example: 1000
	AbrMaxBitrate() *int
	// Maximum bitrate for adjustment process, in kbit/s.
	// Flussonic will keep the publication bitrate equal or below of the specified value.
	// Example: 1000
	SetAbrMaxBitrate(int) StreamInputPublish
	// The algorithm for determining the need to change the bitrate of the published stream and for calculating the target bitrate.
	// Two options are possible:
	// * `abr_mode=0` - This mode takes into account the packet losses, target bitrate, browser bitrate and the number of auto-adjustment cycles.
	// * `abr_mode=1` - This mode considers only packet losses and target bitrate.
	// Example: 1
	AbrMode() *int
	// The algorithm for determining the need to change the bitrate of the published stream and for calculating the target bitrate.
	// Two options are possible:
	// * `abr_mode=0` - This mode takes into account the packet losses, target bitrate, browser bitrate and the number of auto-adjustment cycles.
	// * `abr_mode=1` - This mode considers only packet losses and target bitrate.
	// Example: 1
	SetAbrMode(int) StreamInputPublish
	// A step of reducing the bitrate to the minimum.
	// If packet losses are greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.
	AbrStepdown() *float64
	// A step of reducing the bitrate to the minimum.
	// If packet losses are greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.
	SetAbrStepdown(float64) StreamInputPublish
	// Increment step for raising the bitrate to the maximum, in percent. The default step is 30%.
	// If the loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup percent`.
	AbrStepup() *int
	// Increment step for raising the bitrate to the maximum, in percent. The default step is 30%.
	// If the loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup percent`.
	SetAbrStepup(int) StreamInputPublish
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	AllowIf() *string
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	SetAllowIf(string) StreamInputPublish
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	AudioTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetAudioTimeout(Seconds) StreamInputPublish
	// Human-readable description of the input.
	// Example: This is a test input
	Comment() *string
	// Human-readable description of the input.
	// Example: This is a test input
	SetComment(string) StreamInputPublish
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	DenyIf() *string
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	SetDenyIf(string) StreamInputPublish
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	FramesTimeout() *int
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	SetFramesTimeout(int) StreamInputPublish
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	Headers() map[string]string
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	SetHeaders(map[string]string) StreamInputPublish
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	MaxRetryTimeout() *Seconds
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	SetMaxRetryTimeout(Seconds) StreamInputPublish
	// The minimum bitrate threshold, in kbit/s. The default value is 100 kbit/s.
	// Example: 150
	MinBitrate() *int
	// The minimum bitrate threshold, in kbit/s. The default value is 100 kbit/s.
	// Example: 150
	SetMinBitrate(int) StreamInputPublish
	// Skip input start if the stream has no clients.
	NoClientsReconnectDelay() *int
	// Skip input start if the stream has no clients.
	SetNoClientsReconnectDelay(int) StreamInputPublish
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	OutputAudio() *OutputAudio
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	SetOutputAudio(OutputAudio) StreamInputPublish
	// Deprecated field. Will be deleted at 24.11
	// Choose one of the listed video codecs at the start of the publication via WebRTC.
	// Example: av1
	PreferCodec() *WebrtcPreferVideoCodec
	// Deprecated field. Will be deleted at 24.11
	// Choose one of the listed video codecs at the start of the publication via WebRTC.
	// Example: av1
	SetPreferCodec(WebrtcPreferVideoCodec) StreamInputPublish
	// Prefer one of the listed video codecs at the start of the publication via WebRTC.
	// Example: av1
	PreferVideoCodec() *WebrtcPreferVideoCodec
	// Prefer one of the listed video codecs at the start of the publication via WebRTC.
	// Example: av1
	SetPreferVideoCodec(WebrtcPreferVideoCodec) StreamInputPublish
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	Priority() *int
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	SetPriority(int) StreamInputPublish
	// This option disables processing of SCTE-35 markers from SRT input stream.
	// Example: true
	Scte35() *bool
	// This option disables processing of SCTE-35 markers from SRT input stream.
	// Example: true
	SetScte35(bool) StreamInputPublish
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SourceTimeout() any
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SetSourceTimeout(any) StreamInputPublish
	// Detailed runtime information about the input.
	Stats() InputStats
	// Detailed runtime information about the input.
	SetStats(InputStats) StreamInputPublish
	// Deprecated field. Will be deleted at 25.03
	// This configuration is deprecated. Use `dvbocr` configuration field in stream.
	// This parameter allows to manage subtitles in an output stream.
	// Example: drop
	Subtitles() *StreamInputSrtPublishSpecificSubtitles
	// Deprecated field. Will be deleted at 25.03
	// This configuration is deprecated. Use `dvbocr` configuration field in stream.
	// This parameter allows to manage subtitles in an output stream.
	// Example: drop
	SetSubtitles(StreamInputSrtPublishSpecificSubtitles) StreamInputPublish
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	Timeout() *int
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	SetTimeout(int) StreamInputPublish
	// Choose the prefered transport of the publication via WebRTC: UDP or TCP.
	// Example: udp
	Transport() *WebrtcTransport
	// Choose the prefered transport of the publication via WebRTC: UDP or TCP.
	// Example: udp
	SetTransport(WebrtcTransport) StreamInputPublish
	// The publish:// URL used to indicate where this stream started in publish mode.
	// You can publish videos to Flussonic using the following URLs:
	// __RTSP__: rtsp://FLUSSONIC-IP/stream_name
	// __HTTP MPEG-TS__: http://FLUSSONIC-IP/stream_name/mpegts
	// __RTMP__: rtmp://flussonic-ip/published or rtmp://flussonic-ip/static/published
	// __WebRTC__: http://FLUSSONIC-IP/stream_name/whip
	// __SRT__: srt://FLUSSONIC-IP:SRT_PORT?streamid=#!::r=STREAM_NAME,m=publish
	// Format: input_url (input_url)
	// Pattern: ^publish://.*$
	// Example: publish://
	URL() InputURL
	// The publish:// URL used to indicate where this stream started in publish mode.
	// You can publish videos to Flussonic using the following URLs:
	// __RTSP__: rtsp://FLUSSONIC-IP/stream_name
	// __HTTP MPEG-TS__: http://FLUSSONIC-IP/stream_name/mpegts
	// __RTMP__: rtmp://flussonic-ip/published or rtmp://flussonic-ip/static/published
	// __WebRTC__: http://FLUSSONIC-IP/stream_name/whip
	// __SRT__: srt://FLUSSONIC-IP:SRT_PORT?streamid=#!::r=STREAM_NAME,m=publish
	// Format: input_url (input_url)
	// Pattern: ^publish://.*$
	// Example: publish://
	SetURL(InputURL) StreamInputPublish
	// User agent. Can be modified if a protocol allows it.
	UserAgent() *string
	// User agent. Can be modified if a protocol allows it.
	SetUserAgent(string) StreamInputPublish
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	Via() *AgentURL
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	SetVia(AgentURL) StreamInputPublish
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	VideoTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetVideoTimeout(Seconds) StreamInputPublish
	// Whether the adaptive bitrate mechanism is used for WebRTC publications.
	// Example: true
	WebrtcAbr() *bool
	// Whether the adaptive bitrate mechanism is used for WebRTC publications.
	// Example: true
	SetWebrtcAbr(bool) StreamInputPublish
}

type StreamInputRTP interface {
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	AllowIf() *string
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	SetAllowIf(string) StreamInputRTP
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	AudioTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetAudioTimeout(Seconds) StreamInputRTP
	// Human-readable description of the input.
	// Example: This is a test input
	Comment() *string
	// Human-readable description of the input.
	// Example: This is a test input
	SetComment(string) StreamInputRTP
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	DenyIf() *string
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	SetDenyIf(string) StreamInputRTP
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	FramesTimeout() *int
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	SetFramesTimeout(int) StreamInputRTP
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	Headers() map[string]string
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	SetHeaders(map[string]string) StreamInputRTP
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	MaxRetryTimeout() *Seconds
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	SetMaxRetryTimeout(Seconds) StreamInputRTP
	// Skip input start if the stream has no clients.
	NoClientsReconnectDelay() *int
	// Skip input start if the stream has no clients.
	SetNoClientsReconnectDelay(int) StreamInputRTP
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	OutputAudio() *OutputAudio
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	SetOutputAudio(OutputAudio) StreamInputRTP
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	Priority() *int
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	SetPriority(int) StreamInputRTP
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SourceTimeout() any
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SetSourceTimeout(any) StreamInputRTP
	// Detailed runtime information about the input.
	Stats() InputStats
	// Detailed runtime information about the input.
	SetStats(InputStats) StreamInputRTP
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	Timeout() *int
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	SetTimeout(int) StreamInputRTP
	// URL to connect to RTP source and get the stream.
	// Format: input_url (input_url)
	// Pattern: ^rtp://.*$
	// Example: rtp://remote.host.com
	URL() InputURL
	// URL to connect to RTP source and get the stream.
	// Format: input_url (input_url)
	// Pattern: ^rtp://.*$
	// Example: rtp://remote.host.com
	SetURL(InputURL) StreamInputRTP
	// User agent. Can be modified if a protocol allows it.
	UserAgent() *string
	// User agent. Can be modified if a protocol allows it.
	SetUserAgent(string) StreamInputRTP
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	Via() *AgentURL
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	SetVia(AgentURL) StreamInputRTP
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	VideoTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetVideoTimeout(Seconds) StreamInputRTP
}

type StreamInputRtmp interface {
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	AllowIf() *string
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	SetAllowIf(string) StreamInputRtmp
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	AudioTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetAudioTimeout(Seconds) StreamInputRtmp
	// Human-readable description of the input.
	// Example: This is a test input
	Comment() *string
	// Human-readable description of the input.
	// Example: This is a test input
	SetComment(string) StreamInputRtmp
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	DenyIf() *string
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	SetDenyIf(string) StreamInputRtmp
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	FramesTimeout() *int
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	SetFramesTimeout(int) StreamInputRtmp
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	Headers() map[string]string
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	SetHeaders(map[string]string) StreamInputRtmp
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	MaxRetryTimeout() *Seconds
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	SetMaxRetryTimeout(Seconds) StreamInputRtmp
	// Skip input start if the stream has no clients.
	NoClientsReconnectDelay() *int
	// Skip input start if the stream has no clients.
	SetNoClientsReconnectDelay(int) StreamInputRtmp
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	OutputAudio() *OutputAudio
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	SetOutputAudio(OutputAudio) StreamInputRtmp
	// URL of the web page from where the SWF file was loaded.
	// This is an RTMP header (Referer) used for establishing connection.
	// Format: url (url)
	// Example: http://somehost/sample.html
	Pageurl() *URL
	// URL of the web page from where the SWF file was loaded.
	// This is an RTMP header (Referer) used for establishing connection.
	// Format: url (url)
	// Example: http://somehost/sample.html
	SetPageurl(URL) StreamInputRtmp
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	Priority() *int
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	SetPriority(int) StreamInputRtmp
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SourceTimeout() any
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SetSourceTimeout(any) StreamInputRtmp
	// Detailed runtime information about the input.
	Stats() InputStats
	// Detailed runtime information about the input.
	SetStats(InputStats) StreamInputRtmp
	// URL of the source SWF file making the connection by RTMP.
	// Example: file://C:/FlvPlayer.swf
	Swfurl() *string
	// URL of the source SWF file making the connection by RTMP.
	// Example: file://C:/FlvPlayer.swf
	SetSwfurl(string) StreamInputRtmp
	// URL of the remote Server for entering credentials.
	// It has the following format: `protocol://servername:port/appName/appInstance`.
	// Format: url (url)
	// Example: rtmp://localhost:1935/testapp/instance1
	Tcurl() *URL
	// URL of the remote Server for entering credentials.
	// It has the following format: `protocol://servername:port/appName/appInstance`.
	// Format: url (url)
	// Example: rtmp://localhost:1935/testapp/instance1
	SetTcurl(URL) StreamInputRtmp
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	Timeout() *int
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	SetTimeout(int) StreamInputRtmp
	// URL to connect to the RTMP source and get the stream.
	// RTMP uses a special URL consisting of at least two segments. *Flussonic* parses the URL and splits it into parts,
	// using the first segment as an RTMP application name.
	// Format: input_url (input_url)
	// Pattern: ^(rtmp|rtmps)://.*$
	// Examples: rtmp://remote.host.com/static/example, rtmps://remote.host.com/static/example
	URL() InputURL
	// URL to connect to the RTMP source and get the stream.
	// RTMP uses a special URL consisting of at least two segments. *Flussonic* parses the URL and splits it into parts,
	// using the first segment as an RTMP application name.
	// Format: input_url (input_url)
	// Pattern: ^(rtmp|rtmps)://.*$
	// Examples: rtmp://remote.host.com/static/example, rtmps://remote.host.com/static/example
	SetURL(InputURL) StreamInputRtmp
	// User agent. Can be modified if a protocol allows it.
	UserAgent() *string
	// User agent. Can be modified if a protocol allows it.
	SetUserAgent(string) StreamInputRtmp
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	Via() *AgentURL
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	SetVia(AgentURL) StreamInputRtmp
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	VideoTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetVideoTimeout(Seconds) StreamInputRtmp
}

type StreamInputRtsp interface {
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	AllowIf() *string
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	SetAllowIf(string) StreamInputRtsp
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	AudioTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetAudioTimeout(Seconds) StreamInputRtsp
	// Human-readable description of the input.
	// Example: This is a test input
	Comment() *string
	// Human-readable description of the input.
	// Example: This is a test input
	SetComment(string) StreamInputRtsp
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	DenyIf() *string
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	SetDenyIf(string) StreamInputRtsp
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	FramesTimeout() *int
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	SetFramesTimeout(int) StreamInputRtsp
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	Headers() map[string]string
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	SetHeaders(map[string]string) StreamInputRtsp
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	MaxRetryTimeout() *Seconds
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	SetMaxRetryTimeout(Seconds) StreamInputRtsp
	// Skip input start if the stream has no clients.
	NoClientsReconnectDelay() *int
	// Skip input start if the stream has no clients.
	SetNoClientsReconnectDelay(int) StreamInputRtsp
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	OutputAudio() *OutputAudio
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	SetOutputAudio(OutputAudio) StreamInputRtsp
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	Priority() *int
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	SetPriority(int) StreamInputRtsp
	// Whether to force UDP to capture a video from RTSP cameras.
	RTP() *string
	// Whether to force UDP to capture a video from RTSP cameras.
	SetRTP(string) StreamInputRtsp
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SourceTimeout() any
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SetSourceTimeout(any) StreamInputRtsp
	// Detailed runtime information about the input.
	Stats() InputStats
	// Detailed runtime information about the input.
	SetStats(InputStats) StreamInputRtsp
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	Timeout() *int
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	SetTimeout(int) StreamInputRtsp
	// URL to connect to the RTSP source and get the stream.
	// Format: input_url (input_url)
	// Pattern: ^(rtsp|rtsps|rtsp-udp|rtsp2)://.*$
	// Examples: rtsp-udp://remote.host.com/example, rtsp2://remote.host.com/example, rtsp://remote.host.com/example, rtsps://remote.host.com/example
	URL() InputURL
	// URL to connect to the RTSP source and get the stream.
	// Format: input_url (input_url)
	// Pattern: ^(rtsp|rtsps|rtsp-udp|rtsp2)://.*$
	// Examples: rtsp-udp://remote.host.com/example, rtsp2://remote.host.com/example, rtsp://remote.host.com/example, rtsps://remote.host.com/example
	SetURL(InputURL) StreamInputRtsp
	// User agent. Can be modified if a protocol allows it.
	UserAgent() *string
	// User agent. Can be modified if a protocol allows it.
	SetUserAgent(string) StreamInputRtsp
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	Via() *AgentURL
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	SetVia(AgentURL) StreamInputRtsp
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	VideoTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetVideoTimeout(Seconds) StreamInputRtsp
	// Whether to wait for the full RTP time synchronization before the processing of frames from the RTSP camera.
	WaitRtcp() *bool
	// Whether to wait for the full RTP time synchronization before the processing of frames from the RTSP camera.
	SetWaitRtcp(bool) StreamInputRtsp
}

type StreamInputShoutcast interface {
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	AllowIf() *string
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	SetAllowIf(string) StreamInputShoutcast
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	AudioTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetAudioTimeout(Seconds) StreamInputShoutcast
	// Human-readable description of the input.
	// Example: This is a test input
	Comment() *string
	// Human-readable description of the input.
	// Example: This is a test input
	SetComment(string) StreamInputShoutcast
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	DenyIf() *string
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	SetDenyIf(string) StreamInputShoutcast
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	FramesTimeout() *int
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	SetFramesTimeout(int) StreamInputShoutcast
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	Headers() map[string]string
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	SetHeaders(map[string]string) StreamInputShoutcast
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	MaxRetryTimeout() *Seconds
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	SetMaxRetryTimeout(Seconds) StreamInputShoutcast
	// Skip input start if the stream has no clients.
	NoClientsReconnectDelay() *int
	// Skip input start if the stream has no clients.
	SetNoClientsReconnectDelay(int) StreamInputShoutcast
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	OutputAudio() *OutputAudio
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	SetOutputAudio(OutputAudio) StreamInputShoutcast
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	Priority() *int
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	SetPriority(int) StreamInputShoutcast
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SourceTimeout() any
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SetSourceTimeout(any) StreamInputShoutcast
	// Detailed runtime information about the input.
	Stats() InputStats
	// Detailed runtime information about the input.
	SetStats(InputStats) StreamInputShoutcast
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	Timeout() *int
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	SetTimeout(int) StreamInputShoutcast
	// URL to connect to the SHOUTcast source and get the stream.
	// Format: input_url (input_url)
	// Pattern: ^(shoutcast|shoutcasts)://.*$
	// Examples: shoutcast://remote.host.com/example/shoutcast, shoutcasts://remote.host.com/example/shoutcast
	URL() InputURL
	// URL to connect to the SHOUTcast source and get the stream.
	// Format: input_url (input_url)
	// Pattern: ^(shoutcast|shoutcasts)://.*$
	// Examples: shoutcast://remote.host.com/example/shoutcast, shoutcasts://remote.host.com/example/shoutcast
	SetURL(InputURL) StreamInputShoutcast
	// User agent. Can be modified if a protocol allows it.
	UserAgent() *string
	// User agent. Can be modified if a protocol allows it.
	SetUserAgent(string) StreamInputShoutcast
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	Via() *AgentURL
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	SetVia(AgentURL) StreamInputShoutcast
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	VideoTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetVideoTimeout(Seconds) StreamInputShoutcast
}

type StreamInputSpts interface {
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	AllowIf() *string
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	SetAllowIf(string) StreamInputSpts
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	AudioTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetAudioTimeout(Seconds) StreamInputSpts
	// The rules for handling the closed captions.
	ClosedCaptions() map[string]string
	// The rules for handling the closed captions.
	SetClosedCaptions(map[string]string) StreamInputSpts
	// Human-readable description of the input.
	// Example: This is a test input
	Comment() *string
	// Human-readable description of the input.
	// Example: This is a test input
	SetComment(string) StreamInputSpts
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	DenyIf() *string
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	SetDenyIf(string) StreamInputSpts
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	FramesTimeout() *int
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	SetFramesTimeout(int) StreamInputSpts
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	Headers() map[string]string
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	SetHeaders(map[string]string) StreamInputSpts
	// An array of MPEG-TS language descriptors in format `[{key: track, value: language}]`
	Languages() map[string]string
	// An array of MPEG-TS language descriptors in format `[{key: track, value: language}]`
	SetLanguages(map[string]string) StreamInputSpts
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	MaxRetryTimeout() *Seconds
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	SetMaxRetryTimeout(Seconds) StreamInputSpts
	// Skip input start if the stream has no clients.
	NoClientsReconnectDelay() *int
	// Skip input start if the stream has no clients.
	SetNoClientsReconnectDelay(int) StreamInputSpts
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	OutputAudio() *OutputAudio
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	SetOutputAudio(OutputAudio) StreamInputSpts
	// Choose a specific PID to ingest from an MPEG-TS stream.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Example: [211]
	Pids() []int
	// Choose a specific PID to ingest from an MPEG-TS stream.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Example: [211]
	SetPids([]int) StreamInputSpts
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	Priority() *int
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	SetPriority(int) StreamInputSpts
	// Choose a program to ingest from an MPEG-TS stream.
	// Example: [1]
	Programs() []int
	// Choose a program to ingest from an MPEG-TS stream.
	// Example: [1]
	SetPrograms([]int) StreamInputSpts
	// Deprecated field. Will be deleted at 23.09
	// This option disables processing of SCTE-35 markers from an MPEG-TS input stream.
	// Deprecated since 22.12.
	// Available ways to disable processing of SCTE-35 markers:
	// 1. pids option to select tracks without SCTE-35 markers
	// 2. hls_scte35 option from stream_config_media for hls output
	// 3. performing appropriate tuning pids in the transponder
	// Example: true
	Scte35() *bool
	// Deprecated field. Will be deleted at 23.09
	// This option disables processing of SCTE-35 markers from an MPEG-TS input stream.
	// Deprecated since 22.12.
	// Available ways to disable processing of SCTE-35 markers:
	// 1. pids option to select tracks without SCTE-35 markers
	// 2. hls_scte35 option from stream_config_media for hls output
	// 3. performing appropriate tuning pids in the transponder
	// Example: true
	SetScte35(bool) StreamInputSpts
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SourceTimeout() any
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SetSourceTimeout(any) StreamInputSpts
	// Detailed runtime information about the input.
	Stats() InputStats
	// Detailed runtime information about the input.
	SetStats(InputStats) StreamInputSpts
	// Deprecated field. Will be deleted at 25.03
	// This configuration is deprecated. Use `dvbocr` configuration field in stream.
	// This parameter allows to manage subtitles in an output stream.
	// Example: drop
	Subtitles() *StreamInputMpegtsSpecificSubtitles
	// Deprecated field. Will be deleted at 25.03
	// This configuration is deprecated. Use `dvbocr` configuration field in stream.
	// This parameter allows to manage subtitles in an output stream.
	// Example: drop
	SetSubtitles(StreamInputMpegtsSpecificSubtitles) StreamInputSpts
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	Timeout() *int
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	SetTimeout(int) StreamInputSpts
	// URL to connect to the SPTS source and get the stream.
	// Format: input_url (input_url)
	// Pattern: ^(udp|udp1|udp2|udp3)://.*$
	// Examples: udp1://239.0.0.1:1234, udp2://239.0.0.1:1234, udp3://239.0.0.1:1234, udp://239.0.0.1:1234
	URL() InputURL
	// URL to connect to the SPTS source and get the stream.
	// Format: input_url (input_url)
	// Pattern: ^(udp|udp1|udp2|udp3)://.*$
	// Examples: udp1://239.0.0.1:1234, udp2://239.0.0.1:1234, udp3://239.0.0.1:1234, udp://239.0.0.1:1234
	SetURL(InputURL) StreamInputSpts
	// User agent. Can be modified if a protocol allows it.
	UserAgent() *string
	// User agent. Can be modified if a protocol allows it.
	SetUserAgent(string) StreamInputSpts
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	Via() *AgentURL
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	SetVia(AgentURL) StreamInputSpts
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	VideoTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetVideoTimeout(Seconds) StreamInputSpts
}

type StreamInputSrt interface {
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	AllowIf() *string
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	SetAllowIf(string) StreamInputSrt
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	AudioTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetAudioTimeout(Seconds) StreamInputSrt
	// The rules for handling the closed captions.
	ClosedCaptions() map[string]string
	// The rules for handling the closed captions.
	SetClosedCaptions(map[string]string) StreamInputSrt
	// Human-readable description of the input.
	// Example: This is a test input
	Comment() *string
	// Human-readable description of the input.
	// Example: This is a test input
	SetComment(string) StreamInputSrt
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	DenyIf() *string
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	SetDenyIf(string) StreamInputSrt
	// Whether both connection parties must have the same password set (including empty, in other words, with no encryption).
	// If the passwords do not match or only one side is unencrypted, the connection is rejected.
	// The default value is `true`.
	// Example: true
	Enforcedencryption() *bool
	// Whether both connection parties must have the same password set (including empty, in other words, with no encryption).
	// If the passwords do not match or only one side is unencrypted, the connection is rejected.
	// The default value is `true`.
	// Example: true
	SetEnforcedencryption(bool) StreamInputSrt
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	FramesTimeout() *int
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	SetFramesTimeout(int) StreamInputSrt
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	Headers() map[string]string
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	SetHeaders(map[string]string) StreamInputSrt
	// The latency value for both directions of the socket.
	// By default initial value latency is 0 when transmitting and 120ms when receiving video.
	// Actual value established after connection handshake.
	// Increased value helps tolerate network losses and delays.
	// Format: milliseconds (milliseconds)
	// Example: 150
	Latency() *Milliseconds
	// The latency value for both directions of the socket.
	// By default initial value latency is 0 when transmitting and 120ms when receiving video.
	// Actual value established after connection handshake.
	// Increased value helps tolerate network losses and delays.
	// Format: milliseconds (milliseconds)
	// Example: 150
	SetLatency(Milliseconds) StreamInputSrt
	// The time, in seconds, that the socket waits for the unsent data before closing.
	// The default value is 180.
	// Format: seconds (seconds)
	// Example: 15
	Linger() *Seconds
	// The time, in seconds, that the socket waits for the unsent data before closing.
	// The default value is 180.
	// Format: seconds (seconds)
	// Example: 15
	SetLinger(Seconds) StreamInputSrt
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	MaxRetryTimeout() *Seconds
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	SetMaxRetryTimeout(Seconds) StreamInputSrt
	// The minimum SRT version that is required from the peer for SRT publication.
	// Pattern: ^[0-9]+\.[0-9]+\.[0-9]+$
	// Example: 1.1.0
	Minversion() *string
	// The minimum SRT version that is required from the peer for SRT publication.
	// Pattern: ^[0-9]+\.[0-9]+\.[0-9]+$
	// Example: 1.1.0
	SetMinversion(string) StreamInputSrt
	// Skip input start if the stream has no clients.
	NoClientsReconnectDelay() *int
	// Skip input start if the stream has no clients.
	SetNoClientsReconnectDelay(int) StreamInputSrt
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	OutputAudio() *OutputAudio
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	SetOutputAudio(OutputAudio) StreamInputSrt
	// The password for the encrypted transmission.
	// Its length should be not less than 10 and not more than 79 characters.
	// Unlike [password](https://flussonic.com/doc/api/reference/#tag/stream/operation/stream_save%7Cbody%7Cpassword),
	// the passphrase is not transmitted openly but is used to encrypt the key that is transmitted by the Caller
	// and decoded by Listener.
	// Example: 9876543210
	Passphrase() *string
	// The password for the encrypted transmission.
	// Its length should be not less than 10 and not more than 79 characters.
	// Unlike [password](https://flussonic.com/doc/api/reference/#tag/stream/operation/stream_save%7Cbody%7Cpassword),
	// the passphrase is not transmitted openly but is used to encrypt the key that is transmitted by the Caller
	// and decoded by Listener.
	// Example: 9876543210
	SetPassphrase(string) StreamInputSrt
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	Priority() *int
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	SetPriority(int) StreamInputSrt
	// This option disables processing of SCTE-35 markers from SRT input stream.
	// Example: true
	Scte35() *bool
	// This option disables processing of SCTE-35 markers from SRT input stream.
	// Example: true
	SetScte35(bool) StreamInputSrt
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SourceTimeout() any
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SetSourceTimeout(any) StreamInputSrt
	// Detailed runtime information about the input.
	Stats() InputStats
	// Detailed runtime information about the input.
	SetStats(InputStats) StreamInputSrt
	// A string of maximum 512 characters set on the socket before the connection.
	// This string is a part of a callback that is sent by the caller and regisered by the listener.
	// Based on this information the listener can accept or reject the connection, select the desired data stream, or set an appropriate passphrase for the connection.
	// Its format is `#!::` optionally followed by the parameters:
	// * `r=` - stream name
	// * `m=` - mode expected for the connection: `publish` (if the caller wants to send the stream data) or `request` (if the caller wants to receive the stream).
	// * `password=` - a password for the authorization in a publish session (not recommended, better use `passphrase` option instead)
	// During SRT sessions the following parameters are automaticly added to streamid:
	// * `s=` - the identifier of a session
	// * `a=` - Flussonic version
	// NOTE: you can specify a string in the format you need; to disable this extension, you need specify empty string.
	// Example: #!::r=my-stream,m=publish
	Streamid() *string
	// A string of maximum 512 characters set on the socket before the connection.
	// This string is a part of a callback that is sent by the caller and regisered by the listener.
	// Based on this information the listener can accept or reject the connection, select the desired data stream, or set an appropriate passphrase for the connection.
	// Its format is `#!::` optionally followed by the parameters:
	// * `r=` - stream name
	// * `m=` - mode expected for the connection: `publish` (if the caller wants to send the stream data) or `request` (if the caller wants to receive the stream).
	// * `password=` - a password for the authorization in a publish session (not recommended, better use `passphrase` option instead)
	// During SRT sessions the following parameters are automaticly added to streamid:
	// * `s=` - the identifier of a session
	// * `a=` - Flussonic version
	// NOTE: you can specify a string in the format you need; to disable this extension, you need specify empty string.
	// Example: #!::r=my-stream,m=publish
	SetStreamid(string) StreamInputSrt
	// Deprecated field. Will be deleted at 25.03
	// This configuration is deprecated. Use `dvbocr` configuration field in stream.
	// This parameter allows to manage subtitles in an output stream.
	// Example: drop
	Subtitles() *StreamInputSrtPublishSpecificSubtitles
	// Deprecated field. Will be deleted at 25.03
	// This configuration is deprecated. Use `dvbocr` configuration field in stream.
	// This parameter allows to manage subtitles in an output stream.
	// Example: drop
	SetSubtitles(StreamInputSrtPublishSpecificSubtitles) StreamInputSrt
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	Timeout() *int
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	SetTimeout(int) StreamInputSrt
	// Artificial URL to connect to the SRT source and get the stream.
	// SRT requires IP and port, so we create an artificial URL to specify the options to manage the data interchange.
	// Format: input_url (input_url)
	// Pattern: ^(srt|srt1|srt2)://.*$
	// Examples: srt1://remote.host.com:1234?bind_ip=10.77.0.100, srt2://remote.host.com:1234?bind_ip=10.77.0.100, srt://remote.host.com:1234?bind_ip=10.77.0.100
	URL() InputURL
	// Artificial URL to connect to the SRT source and get the stream.
	// SRT requires IP and port, so we create an artificial URL to specify the options to manage the data interchange.
	// Format: input_url (input_url)
	// Pattern: ^(srt|srt1|srt2)://.*$
	// Examples: srt1://remote.host.com:1234?bind_ip=10.77.0.100, srt2://remote.host.com:1234?bind_ip=10.77.0.100, srt://remote.host.com:1234?bind_ip=10.77.0.100
	SetURL(InputURL) StreamInputSrt
	// User agent. Can be modified if a protocol allows it.
	UserAgent() *string
	// User agent. Can be modified if a protocol allows it.
	SetUserAgent(string) StreamInputSrt
	// Required SRT version.
	// Pattern: ^[0-9]+\.[0-9]+\.[0-9]+$
	// Example: 1.3.0
	Version() *string
	// Required SRT version.
	// Pattern: ^[0-9]+\.[0-9]+\.[0-9]+$
	// Example: 1.3.0
	SetVersion(string) StreamInputSrt
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	Via() *AgentURL
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	SetVia(AgentURL) StreamInputSrt
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	VideoTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetVideoTimeout(Seconds) StreamInputSrt
}

type StreamInputSrtPublishSpecific interface {
	// This option disables processing of SCTE-35 markers from SRT input stream.
	// Example: true
	Scte35() *bool
	// This option disables processing of SCTE-35 markers from SRT input stream.
	// Example: true
	SetScte35(bool) StreamInputSrtPublishSpecific
	// Deprecated field. Will be deleted at 25.03
	// This configuration is deprecated. Use `dvbocr` configuration field in stream.
	// This parameter allows to manage subtitles in an output stream.
	// Example: drop
	Subtitles() *StreamInputSrtPublishSpecificSubtitles
	// Deprecated field. Will be deleted at 25.03
	// This configuration is deprecated. Use `dvbocr` configuration field in stream.
	// This parameter allows to manage subtitles in an output stream.
	// Example: drop
	SetSubtitles(StreamInputSrtPublishSpecificSubtitles) StreamInputSrtPublishSpecific
}

type StreamInputSt2110 interface {
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	AllowIf() *string
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	SetAllowIf(string) StreamInputSt2110
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	AudioTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetAudioTimeout(Seconds) StreamInputSt2110
	// Optional bind core
	BindToCore() *int
	// Optional bind core
	SetBindToCore(int) StreamInputSt2110
	// Human-readable description of the input.
	// Example: This is a test input
	Comment() *string
	// Human-readable description of the input.
	// Example: This is a test input
	SetComment(string) StreamInputSt2110
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	DenyIf() *string
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	SetDenyIf(string) StreamInputSt2110
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	FramesTimeout() *int
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	SetFramesTimeout(int) StreamInputSt2110
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	Headers() map[string]string
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	SetHeaders(map[string]string) StreamInputSt2110
	// Must specify received pixel height
	Height() *int
	// Must specify received pixel height
	SetHeight(int) StreamInputSt2110
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	MaxRetryTimeout() *Seconds
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	SetMaxRetryTimeout(Seconds) StreamInputSt2110
	// Skip input start if the stream has no clients.
	NoClientsReconnectDelay() *int
	// Skip input start if the stream has no clients.
	SetNoClientsReconnectDelay(int) StreamInputSt2110
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	OutputAudio() *OutputAudio
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	SetOutputAudio(OutputAudio) StreamInputSt2110
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	Priority() *int
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	SetPriority(int) StreamInputSt2110
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SourceTimeout() any
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SetSourceTimeout(any) StreamInputSt2110
	// Detailed runtime information about the input.
	Stats() InputStats
	// Detailed runtime information about the input.
	SetStats(InputStats) StreamInputSt2110
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	Timeout() *int
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	SetTimeout(int) StreamInputSt2110
	// SMPTE 2110 UDP multicast group
	// Format: input_url (input_url)
	// Pattern: ^st2110://.*$
	// Examples: st2110://239.0.0.1:1234, st2110://239.0.0.1:1234/192.168.20.24, st2110://eth0@239.0.0.1:1234
	URL() InputURL
	// SMPTE 2110 UDP multicast group
	// Format: input_url (input_url)
	// Pattern: ^st2110://.*$
	// Examples: st2110://239.0.0.1:1234, st2110://239.0.0.1:1234/192.168.20.24, st2110://eth0@239.0.0.1:1234
	SetURL(InputURL) StreamInputSt2110
	// User agent. Can be modified if a protocol allows it.
	UserAgent() *string
	// User agent. Can be modified if a protocol allows it.
	SetUserAgent(string) StreamInputSt2110
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	Via() *AgentURL
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	SetVia(AgentURL) StreamInputSt2110
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	VideoTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetVideoTimeout(Seconds) StreamInputSt2110
	// Must specify received pixel width
	Width() *int
	// Must specify received pixel width
	SetWidth(int) StreamInputSt2110
}

type StreamInputTimeshift interface {
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	AllowIf() *string
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	SetAllowIf(string) StreamInputTimeshift
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	AudioTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetAudioTimeout(Seconds) StreamInputTimeshift
	// Human-readable description of the input.
	// Example: This is a test input
	Comment() *string
	// Human-readable description of the input.
	// Example: This is a test input
	SetComment(string) StreamInputTimeshift
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	DenyIf() *string
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	SetDenyIf(string) StreamInputTimeshift
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	FramesTimeout() *int
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	SetFramesTimeout(int) StreamInputTimeshift
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	Headers() map[string]string
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	SetHeaders(map[string]string) StreamInputTimeshift
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	MaxRetryTimeout() *Seconds
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	SetMaxRetryTimeout(Seconds) StreamInputTimeshift
	// Skip input start if the stream has no clients.
	NoClientsReconnectDelay() *int
	// Skip input start if the stream has no clients.
	SetNoClientsReconnectDelay(int) StreamInputTimeshift
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	OutputAudio() *OutputAudio
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	SetOutputAudio(OutputAudio) StreamInputTimeshift
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	Priority() *int
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	SetPriority(int) StreamInputTimeshift
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SourceTimeout() any
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SetSourceTimeout(any) StreamInputTimeshift
	// Detailed runtime information about the input.
	Stats() InputStats
	// Detailed runtime information about the input.
	SetStats(InputStats) StreamInputTimeshift
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	Timeout() *int
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	SetTimeout(int) StreamInputTimeshift
	// Special URL to play the archive record of a stream with a fixed delay.
	// Format: input_url (input_url)
	// Pattern: ^timeshift://.*$
	// Examples: timeshift://channel/7200
	URL() InputURL
	// Special URL to play the archive record of a stream with a fixed delay.
	// Format: input_url (input_url)
	// Pattern: ^timeshift://.*$
	// Examples: timeshift://channel/7200
	SetURL(InputURL) StreamInputTimeshift
	// User agent. Can be modified if a protocol allows it.
	UserAgent() *string
	// User agent. Can be modified if a protocol allows it.
	SetUserAgent(string) StreamInputTimeshift
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	Via() *AgentURL
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	SetVia(AgentURL) StreamInputTimeshift
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	VideoTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetVideoTimeout(Seconds) StreamInputTimeshift
}

type StreamInputTshttp interface {
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	AllowIf() *string
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	SetAllowIf(string) StreamInputTshttp
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	AudioTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetAudioTimeout(Seconds) StreamInputTshttp
	// The rules for handling the closed captions.
	ClosedCaptions() map[string]string
	// The rules for handling the closed captions.
	SetClosedCaptions(map[string]string) StreamInputTshttp
	// Human-readable description of the input.
	// Example: This is a test input
	Comment() *string
	// Human-readable description of the input.
	// Example: This is a test input
	SetComment(string) StreamInputTshttp
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	DenyIf() *string
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	SetDenyIf(string) StreamInputTshttp
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	FramesTimeout() *int
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	SetFramesTimeout(int) StreamInputTshttp
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	Headers() map[string]string
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	SetHeaders(map[string]string) StreamInputTshttp
	// An array of MPEG-TS language descriptors in format `[{key: track, value: language}]`
	Languages() map[string]string
	// An array of MPEG-TS language descriptors in format `[{key: track, value: language}]`
	SetLanguages(map[string]string) StreamInputTshttp
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	MaxRetryTimeout() *Seconds
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	SetMaxRetryTimeout(Seconds) StreamInputTshttp
	// Skip input start if the stream has no clients.
	NoClientsReconnectDelay() *int
	// Skip input start if the stream has no clients.
	SetNoClientsReconnectDelay(int) StreamInputTshttp
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	OutputAudio() *OutputAudio
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	SetOutputAudio(OutputAudio) StreamInputTshttp
	// Choose a specific PID to ingest from an MPEG-TS stream.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Example: [211]
	Pids() []int
	// Choose a specific PID to ingest from an MPEG-TS stream.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Example: [211]
	SetPids([]int) StreamInputTshttp
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	Priority() *int
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	SetPriority(int) StreamInputTshttp
	// Choose a program to ingest from an MPEG-TS stream.
	// Example: [1]
	Programs() []int
	// Choose a program to ingest from an MPEG-TS stream.
	// Example: [1]
	SetPrograms([]int) StreamInputTshttp
	// Deprecated field. Will be deleted at 23.09
	// This option disables processing of SCTE-35 markers from an MPEG-TS input stream.
	// Deprecated since 22.12.
	// Available ways to disable processing of SCTE-35 markers:
	// 1. pids option to select tracks without SCTE-35 markers
	// 2. hls_scte35 option from stream_config_media for hls output
	// 3. performing appropriate tuning pids in the transponder
	// Example: true
	Scte35() *bool
	// Deprecated field. Will be deleted at 23.09
	// This option disables processing of SCTE-35 markers from an MPEG-TS input stream.
	// Deprecated since 22.12.
	// Available ways to disable processing of SCTE-35 markers:
	// 1. pids option to select tracks without SCTE-35 markers
	// 2. hls_scte35 option from stream_config_media for hls output
	// 3. performing appropriate tuning pids in the transponder
	// Example: true
	SetScte35(bool) StreamInputTshttp
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SourceTimeout() any
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SetSourceTimeout(any) StreamInputTshttp
	// Detailed runtime information about the input.
	Stats() InputStats
	// Detailed runtime information about the input.
	SetStats(InputStats) StreamInputTshttp
	// Deprecated field. Will be deleted at 25.03
	// This configuration is deprecated. Use `dvbocr` configuration field in stream.
	// This parameter allows to manage subtitles in an output stream.
	// Example: drop
	Subtitles() *StreamInputMpegtsSpecificSubtitles
	// Deprecated field. Will be deleted at 25.03
	// This configuration is deprecated. Use `dvbocr` configuration field in stream.
	// This parameter allows to manage subtitles in an output stream.
	// Example: drop
	SetSubtitles(StreamInputMpegtsSpecificSubtitles) StreamInputTshttp
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	Timeout() *int
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	SetTimeout(int) StreamInputTshttp
	// URL for ingest and pass a stream "as is" without repackaging.
	// Format: input_url (input_url)
	// Pattern: ^(tshttp|tshttps)://.*$|^(http|https)://.*(\.ts|/mpegts)$
	// Examples: http://remote.host.com/example.ts, http://remote.host.com/mpegts, https://remote.host.com/example.ts, https://remote.host.com/mpegts, tshttp://ADMIN:PASSWORD@FLUSSONIC_IP/flussonic/api/dvbts/a0, tshttps://127.0.0.1:8080
	URL() InputURL
	// URL for ingest and pass a stream "as is" without repackaging.
	// Format: input_url (input_url)
	// Pattern: ^(tshttp|tshttps)://.*$|^(http|https)://.*(\.ts|/mpegts)$
	// Examples: http://remote.host.com/example.ts, http://remote.host.com/mpegts, https://remote.host.com/example.ts, https://remote.host.com/mpegts, tshttp://ADMIN:PASSWORD@FLUSSONIC_IP/flussonic/api/dvbts/a0, tshttps://127.0.0.1:8080
	SetURL(InputURL) StreamInputTshttp
	// User agent. Can be modified if a protocol allows it.
	UserAgent() *string
	// User agent. Can be modified if a protocol allows it.
	SetUserAgent(string) StreamInputTshttp
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	Via() *AgentURL
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	SetVia(AgentURL) StreamInputTshttp
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	VideoTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetVideoTimeout(Seconds) StreamInputTshttp
}

type StreamInputV4l interface {
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	AllowIf() *string
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	SetAllowIf(string) StreamInputV4l
	// The audio device to capture audio from Stream Labs SDI cards.
	// This parameter is specified for ALSA devices in the following format `interface:card,device`.
	// Example: plughw:1,0
	AudioDevice() *string
	// The audio device to capture audio from Stream Labs SDI cards.
	// This parameter is specified for ALSA devices in the following format `interface:card,device`.
	// Example: plughw:1,0
	SetAudioDevice(string) StreamInputV4l
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	AudioTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetAudioTimeout(Seconds) StreamInputV4l
	// Human-readable description of the input.
	// Example: This is a test input
	Comment() *string
	// Human-readable description of the input.
	// Example: This is a test input
	SetComment(string) StreamInputV4l
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	DenyIf() *string
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	SetDenyIf(string) StreamInputV4l
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	FramesTimeout() *int
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	SetFramesTimeout(int) StreamInputV4l
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	Headers() map[string]string
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	SetHeaders(map[string]string) StreamInputV4l
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	MaxRetryTimeout() *Seconds
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	SetMaxRetryTimeout(Seconds) StreamInputV4l
	// Skip input start if the stream has no clients.
	NoClientsReconnectDelay() *int
	// Skip input start if the stream has no clients.
	SetNoClientsReconnectDelay(int) StreamInputV4l
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	OutputAudio() *OutputAudio
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	SetOutputAudio(OutputAudio) StreamInputV4l
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	Priority() *int
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	SetPriority(int) StreamInputV4l
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SourceTimeout() any
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SetSourceTimeout(any) StreamInputV4l
	// Detailed runtime information about the input.
	Stats() InputStats
	// Detailed runtime information about the input.
	SetStats(InputStats) StreamInputV4l
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	Timeout() *int
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	SetTimeout(int) StreamInputV4l
	// This information is necessary for adding into the PMT table to identify streams which carry teletext data in the resulting MPEG-TS stream.
	TtxtDescriptors() []TtxtDescriptors
	// This information is necessary for adding into the PMT table to identify streams which carry teletext data in the resulting MPEG-TS stream.
	SetTtxtDescriptors([]TtxtDescriptors) StreamInputV4l
	// URL to connect to the Video4Linux source and get the stream.
	// Format: input_url (input_url)
	// Pattern: ^(v4l|v4l2)://.*$
	// Examples: v4l2://, v4l://
	URL() InputURL
	// URL to connect to the Video4Linux source and get the stream.
	// Format: input_url (input_url)
	// Pattern: ^(v4l|v4l2)://.*$
	// Examples: v4l2://, v4l://
	SetURL(InputURL) StreamInputV4l
	// User agent. Can be modified if a protocol allows it.
	UserAgent() *string
	// User agent. Can be modified if a protocol allows it.
	SetUserAgent(string) StreamInputV4l
	// This parameter allows logging the decoded data when reading teletext from VBI.
	VbiDebug() *bool
	// This parameter allows logging the decoded data when reading teletext from VBI.
	SetVbiDebug(bool) StreamInputV4l
	// The VBI device to capture raw VBI data from Stream Labs SDI cards. VBI data can contain information about teletext or closed captions.
	// It is actually a path to a VBI device file created on the disk by Video4Linux.
	// Example: /dev/vbi
	VbiDevice() *string
	// The VBI device to capture raw VBI data from Stream Labs SDI cards. VBI data can contain information about teletext or closed captions.
	// It is actually a path to a VBI device file created on the disk by Video4Linux.
	// Example: /dev/vbi
	SetVbiDevice(string) StreamInputV4l
	// This parameter is used for debugging when reading teletext from VBI.
	// This is a threshold, in seconds, for turning on the decoder.
	VbiThreshold() *int
	// This parameter is used for debugging when reading teletext from VBI.
	// This is a threshold, in seconds, for turning on the decoder.
	SetVbiThreshold(int) StreamInputV4l
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	Via() *AgentURL
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	SetVia(AgentURL) StreamInputV4l
	// The video device to capture video from Stream Labs SDI cards.
	// It is actually a path to a device file created on the disk by Video4Linux.
	// Example: /dev/video0
	VideoDevice() *string
	// The video device to capture video from Stream Labs SDI cards.
	// It is actually a path to a device file created on the disk by Video4Linux.
	// Example: /dev/video0
	SetVideoDevice(string) StreamInputV4l
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	VideoTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetVideoTimeout(Seconds) StreamInputV4l
}

// Title: WebRTC
type StreamInputWebrtcPublishSpecific interface {
	// The correction between the target bitrate (Receiver Estimated Maximum Bitrate, calculated in Flussonic) and browser bitrate, in kbit/s.
	// Flussonic sends the target bitrate to the browser from which the publication is carried out so that the browser adjusts the bitrate of the publication by this value.
	// The default value is 300 kbit/s.
	// Example: 200
	AbrCorrection() *int
	// The correction between the target bitrate (Receiver Estimated Maximum Bitrate, calculated in Flussonic) and browser bitrate, in kbit/s.
	// Flussonic sends the target bitrate to the browser from which the publication is carried out so that the browser adjusts the bitrate of the publication by this value.
	// The default value is 300 kbit/s.
	// Example: 200
	SetAbrCorrection(int) StreamInputWebrtcPublishSpecific
	// The number of cycles of bitrate auto-adjustment.
	// After the specified number of auto-adjustment cycles passes, Flussonic considers the bitrate to be optimal, and it is no longer analyzed.
	// By default, `abr_cycles`=5.
	// If `abr_cycles`=0, the adjustment process takes place all the time while the publication lasts.
	// Example: 3
	AbrCycles() *int
	// The number of cycles of bitrate auto-adjustment.
	// After the specified number of auto-adjustment cycles passes, Flussonic considers the bitrate to be optimal, and it is no longer analyzed.
	// By default, `abr_cycles`=5.
	// If `abr_cycles`=0, the adjustment process takes place all the time while the publication lasts.
	// Example: 3
	SetAbrCycles(int) StreamInputWebrtcPublishSpecific
	// Whether adaptive bitrate process is logged.
	// Example: 1
	AbrDebug() *int
	// Whether adaptive bitrate process is logged.
	// Example: 1
	SetAbrDebug(int) StreamInputWebrtcPublishSpecific
	// The lower limit of packet loss. When it is reached, Flussonic raises the bitrate.
	// That is, if packet loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup` percent.
	// Example: 2
	AbrLossLower() *float64
	// The lower limit of packet loss. When it is reached, Flussonic raises the bitrate.
	// That is, if packet loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup` percent.
	// Example: 2
	SetAbrLossLower(float64) StreamInputWebrtcPublishSpecific
	// The upper limit of packet loss. When it is reached, Flussonic reduces the bitrate.
	// That is, if packet loss is greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.
	// Example: 10
	AbrLossUpper() *float64
	// The upper limit of packet loss. When it is reached, Flussonic reduces the bitrate.
	// That is, if packet loss is greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.
	// Example: 10
	SetAbrLossUpper(float64) StreamInputWebrtcPublishSpecific
	// Maximum bitrate for adjustment process, in kbit/s.
	// Flussonic will keep the publication bitrate equal or below of the specified value.
	// Example: 1000
	AbrMaxBitrate() *int
	// Maximum bitrate for adjustment process, in kbit/s.
	// Flussonic will keep the publication bitrate equal or below of the specified value.
	// Example: 1000
	SetAbrMaxBitrate(int) StreamInputWebrtcPublishSpecific
	// The algorithm for determining the need to change the bitrate of the published stream and for calculating the target bitrate.
	// Two options are possible:
	// * `abr_mode=0` - This mode takes into account the packet losses, target bitrate, browser bitrate and the number of auto-adjustment cycles.
	// * `abr_mode=1` - This mode considers only packet losses and target bitrate.
	// Example: 1
	AbrMode() *int
	// The algorithm for determining the need to change the bitrate of the published stream and for calculating the target bitrate.
	// Two options are possible:
	// * `abr_mode=0` - This mode takes into account the packet losses, target bitrate, browser bitrate and the number of auto-adjustment cycles.
	// * `abr_mode=1` - This mode considers only packet losses and target bitrate.
	// Example: 1
	SetAbrMode(int) StreamInputWebrtcPublishSpecific
	// A step of reducing the bitrate to the minimum.
	// If packet losses are greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.
	AbrStepdown() *float64
	// A step of reducing the bitrate to the minimum.
	// If packet losses are greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.
	SetAbrStepdown(float64) StreamInputWebrtcPublishSpecific
	// Increment step for raising the bitrate to the maximum, in percent. The default step is 30%.
	// If the loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup percent`.
	AbrStepup() *int
	// Increment step for raising the bitrate to the maximum, in percent. The default step is 30%.
	// If the loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup percent`.
	SetAbrStepup(int) StreamInputWebrtcPublishSpecific
	// The minimum bitrate threshold, in kbit/s. The default value is 100 kbit/s.
	// Example: 150
	MinBitrate() *int
	// The minimum bitrate threshold, in kbit/s. The default value is 100 kbit/s.
	// Example: 150
	SetMinBitrate(int) StreamInputWebrtcPublishSpecific
	// Deprecated field. Will be deleted at 24.11
	// Choose one of the listed video codecs at the start of the publication via WebRTC.
	// Example: av1
	PreferCodec() *WebrtcPreferVideoCodec
	// Deprecated field. Will be deleted at 24.11
	// Choose one of the listed video codecs at the start of the publication via WebRTC.
	// Example: av1
	SetPreferCodec(WebrtcPreferVideoCodec) StreamInputWebrtcPublishSpecific
	// Prefer one of the listed video codecs at the start of the publication via WebRTC.
	// Example: av1
	PreferVideoCodec() *WebrtcPreferVideoCodec
	// Prefer one of the listed video codecs at the start of the publication via WebRTC.
	// Example: av1
	SetPreferVideoCodec(WebrtcPreferVideoCodec) StreamInputWebrtcPublishSpecific
	// Choose the prefered transport of the publication via WebRTC: UDP or TCP.
	// Example: udp
	Transport() *WebrtcTransport
	// Choose the prefered transport of the publication via WebRTC: UDP or TCP.
	// Example: udp
	SetTransport(WebrtcTransport) StreamInputWebrtcPublishSpecific
	// Whether the adaptive bitrate mechanism is used for WebRTC publications.
	// Example: true
	WebrtcAbr() *bool
	// Whether the adaptive bitrate mechanism is used for WebRTC publications.
	// Example: true
	SetWebrtcAbr(bool) StreamInputWebrtcPublishSpecific
}

type StreamPush interface {
	// The bitrate of the whole stream.
	// Format: speed (speed)
	// Example: 3200
	Bitrate() *Speed
	// The bitrate of the whole stream.
	// Format: speed (speed)
	// Example: 3200
	SetBitrate(Speed) StreamPush
	// Human-readable description of the pusher.
	// Example: This is a test push
	Comment() *string
	// Human-readable description of the pusher.
	// Example: This is a test push
	SetComment(string) StreamPush
	// Connection timeout, in seconds. Equals to 0 by default.
	// Format: seconds (seconds)
	// Example: 2
	ConnectTimeout() *Seconds
	// Connection timeout, in seconds. Equals to 0 by default.
	// Format: seconds (seconds)
	// Example: 2
	SetConnectTimeout(Seconds) StreamPush
	// Activate deinterlacing, i.e., converting an interlaced image to a progressive image.
	// It is necessary for comfortable viewing of legacy TV video on PC/mobile devices.
	Deinterlace() *bool
	// Activate deinterlacing, i.e., converting an interlaced image to a progressive image.
	// It is necessary for comfortable viewing of legacy TV video on PC/mobile devices.
	SetDeinterlace(bool) StreamPush
	// Disable pushing the stream.
	// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
	// In this way, the URL and other settings of a disabled stream remain in Flussonic.
	Disabled() *bool
	// Disable pushing the stream.
	// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
	// In this way, the URL and other settings of a disabled stream remain in Flussonic.
	SetDisabled(bool) StreamPush
	// Defines a number of threads in a decoder.
	// One thread uses one core.
	// The default value equals 4, but you can set it equal to the number of cores of your CPU.
	Dthreads() *int
	// Defines a number of threads in a decoder.
	// One thread uses one core.
	// The default value equals 4, but you can set it equal to the number of cores of your CPU.
	SetDthreads(int) StreamPush
	// Whether both connection parties must have the same password set (including empty, in other words, with no encryption).
	// If the passwords do not match or only one side is unencrypted, the connection is rejected.
	// The default value is `true`.
	// Example: true
	Enforcedencryption() *bool
	// Whether both connection parties must have the same password set (including empty, in other words, with no encryption).
	// If the passwords do not match or only one side is unencrypted, the connection is rejected.
	// The default value is `true`.
	// Example: true
	SetEnforcedencryption(bool) StreamPush
	// Enable clock-lock feature (if supported). See also genlock_status property in pusher stats.
	Genlock() *bool
	// Enable clock-lock feature (if supported). See also genlock_status property in pusher stats.
	SetGenlock(bool) StreamPush
	// The latency value for both directions of the socket.
	// By default initial value latency is 0 when transmitting and 120ms when receiving video.
	// Actual value established after connection handshake.
	// Increased value helps tolerate network losses and delays.
	// Format: milliseconds (milliseconds)
	// Example: 150
	Latency() *Milliseconds
	// The latency value for both directions of the socket.
	// By default initial value latency is 0 when transmitting and 120ms when receiving video.
	// Actual value established after connection handshake.
	// Increased value helps tolerate network losses and delays.
	// Format: milliseconds (milliseconds)
	// Example: 150
	SetLatency(Milliseconds) StreamPush
	// The time, in seconds, that the socket waits for the unsent data before closing.
	// The default value is 180.
	// Format: seconds (seconds)
	// Example: 15
	Linger() *Seconds
	// The time, in seconds, that the socket waits for the unsent data before closing.
	// The default value is 180.
	// Format: seconds (seconds)
	// Example: 15
	SetLinger(Seconds) StreamPush
	// The minimum SRT version that is required from the peer for SRT publication.
	// Pattern: ^[0-9]+\.[0-9]+\.[0-9]+$
	// Example: 1.1.0
	Minversion() *string
	// The minimum SRT version that is required from the peer for SRT publication.
	// Pattern: ^[0-9]+\.[0-9]+\.[0-9]+$
	// Example: 1.1.0
	SetMinversion(string) StreamPush
	// It allows to specify pack information about ac3 for outgoing MPEGTS-TS streams. The default value is `system_b`.
	MpegtsAc3() *OutputMpegtsAc3
	// It allows to specify pack information about ac3 for outgoing MPEGTS-TS streams. The default value is `system_b`.
	SetMpegtsAc3(OutputMpegtsAc3) StreamPush
	// Whether to capture multicast back to the *Flussonic* host.
	// This option allows you to ingest the sent stream on the sending host by *Flussonic* or other application.
	// Set to `True` for a UDP MPEG-TS push.
	// Example: true
	MulticastLoop() *bool
	// Whether to capture multicast back to the *Flussonic* host.
	// This option allows you to ingest the sent stream on the sending host by *Flussonic* or other application.
	// Set to `True` for a UDP MPEG-TS push.
	// Example: true
	SetMulticastLoop(bool) StreamPush
	// The password for the encrypted transmission.
	// Its length should be not less than 10 and not more than 79 characters.
	// Unlike [password](https://flussonic.com/doc/api/reference/#tag/stream/operation/stream_save%7Cbody%7Cpassword),
	// the passphrase is not transmitted openly but is used to encrypt the key that is transmitted by the Caller
	// and decoded by Listener.
	// Example: 9876543210
	Passphrase() *string
	// The password for the encrypted transmission.
	// Its length should be not less than 10 and not more than 79 characters.
	// Unlike [password](https://flussonic.com/doc/api/reference/#tag/stream/operation/stream_save%7Cbody%7Cpassword),
	// the passphrase is not transmitted openly but is used to encrypt the key that is transmitted by the Caller
	// and decoded by Listener.
	// Example: 9876543210
	SetPassphrase(string) StreamPush
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// It is possible to set PID values for PMT, STD and video and audio tracks.
	Pids() OutputMpegtsPids
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// It is possible to set PID values for PMT, STD and video and audio tracks.
	SetPids(OutputMpegtsPids) StreamPush
	// Adjusting genlock timing pixel offset.
	PixelOffset() *int
	// Adjusting genlock timing pixel offset.
	SetPixelOffset(int) StreamPush
	// Program number in the outgoing MPEG-TS stream. A program may represent a television channel.
	Pnr() *int
	// Program number in the outgoing MPEG-TS stream. A program may represent a television channel.
	SetPnr(int) StreamPush
	// Provider name. Used to fill in the field service provider within SDT MPEG-TS table.
	// Example: My provider name
	Provider() *string
	// Provider name. Used to fill in the field service provider within SDT MPEG-TS table.
	// Example: My provider name
	SetProvider(string) StreamPush
	// The maximum number of times *Flussonic* retries to push the stream.
	RetryLimit() *int
	// The maximum number of times *Flussonic* retries to push the stream.
	SetRetryLimit(int) StreamPush
	// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
	// It is an interval in seconds, 5 seconds by default.
	// You can increase this value to reduce server load.
	// Format: seconds (seconds)
	// Example: 7
	RetryTimeout() *Seconds
	// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
	// It is an interval in seconds, 5 seconds by default.
	// You can increase this value to reduce server load.
	// Format: seconds (seconds)
	// Example: 7
	SetRetryTimeout(Seconds) StreamPush
	// Defines a scaling algorithm.
	// You can choose only one algorithm at a time.
	// If a pushing stream has the same video resolution as an ingest stream, the `fast_bilinear` algorithm is used by default.
	// If a video resolution of a pushing stream does not equal the video resolution of an ingest stream, the bicubic algorithm is used by default.
	// If the algorithm is specified explicitly, it applies to all the formats.
	Scale() *ScaleAlgorithm
	// Defines a scaling algorithm.
	// You can choose only one algorithm at a time.
	// If a pushing stream has the same video resolution as an ingest stream, the `fast_bilinear` algorithm is used by default.
	// If a video resolution of a pushing stream does not equal the video resolution of an ingest stream, the bicubic algorithm is used by default.
	// If the algorithm is specified explicitly, it applies to all the formats.
	SetScale(ScaleAlgorithm) StreamPush
	// Service name. Used to fill in the field service name within SDT MPEG-TS table.
	// Example: My service name
	Service() *string
	// Service name. Used to fill in the field service name within SDT MPEG-TS table.
	// Example: My service name
	SetService(string) StreamPush
	// Monitoring multicast group and stop pushing if another publisher presented
	Standby() *bool
	// Monitoring multicast group and stop pushing if another publisher presented
	SetStandby(bool) StreamPush
	// Detailed runtime information about the push.
	Stats() PushCounters
	// Detailed runtime information about the push.
	SetStats(PushCounters) StreamPush
	// A string of maximum 512 characters set on the socket before the connection.
	// This string is a part of a callback that is sent by the caller and regisered by the listener.
	// Based on this information the listener can accept or reject the connection, select the desired data stream, or set an appropriate passphrase for the connection.
	// Its format is `#!::` optionally followed by the parameters:
	// * `r=` - stream name
	// * `m=` - mode expected for the connection: `publish` (if the caller wants to send the stream data) or `request` (if the caller wants to receive the stream).
	// * `password=` - a password for the authorization in a publish session (not recommended, better use `passphrase` option instead)
	// During SRT sessions the following parameters are automaticly added to streamid:
	// * `s=` - the identifier of a session
	// * `a=` - Flussonic version
	// NOTE: you can specify a string in the format you need; to disable this extension, you need specify empty string.
	// Example: #!::r=my-stream,m=publish
	Streamid() *string
	// A string of maximum 512 characters set on the socket before the connection.
	// This string is a part of a callback that is sent by the caller and regisered by the listener.
	// Based on this information the listener can accept or reject the connection, select the desired data stream, or set an appropriate passphrase for the connection.
	// Its format is `#!::` optionally followed by the parameters:
	// * `r=` - stream name
	// * `m=` - mode expected for the connection: `publish` (if the caller wants to send the stream data) or `request` (if the caller wants to receive the stream).
	// * `password=` - a password for the authorization in a publish session (not recommended, better use `passphrase` option instead)
	// During SRT sessions the following parameters are automaticly added to streamid:
	// * `s=` - the identifier of a session
	// * `a=` - Flussonic version
	// NOTE: you can specify a string in the format you need; to disable this extension, you need specify empty string.
	// Example: #!::r=my-stream,m=publish
	SetStreamid(string) StreamPush
	// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
	// Format: seconds (seconds)
	// Example: 10
	Timeout() *Seconds
	// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
	// Format: seconds (seconds)
	// Example: 10
	SetTimeout(Seconds) StreamPush
	// UDP URL of multicast group
	// /Another Flussonic URL where to push video to.
	// /Flussonic stream URL where to push to.
	// /Specify Blackmagic Decklink SDI card as a destination for this stream.
	// You need to specify exact number of output, refer to decklink manual to find
	// enumeration rules.
	// /Select which Dektec SDI card to use as a sink for this stream.
	// Dektec url is combined of card serial # and number of output port on this card.
	// Output ports on a card are numbered starting from 1.
	// Serial numbers are uniq for each produced card. Take a look at admin UI or use
	// native dektec tools to find the serial number.
	// /Select which Dektec ASI card to use as a sink for this stream.
	// Dektec url is combined of card serial # and number of output port on this card.
	// Output ports on a card are numbered starting from 1.
	// Serial numbers are uniq for each produced card. Take a look at admin UI or use
	// native dektec tools to find the serial number.
	// Mention that ASI is a MPEG-TS transport
	// /Content will be similar to multicast MPEG-TS, but endless HTTP POST will be used to upload content.
	// /It is possible to publish HLS to a CDN. Segments will be uploaded together with manifests.
	// /SRT URL where to push video.
	// /The URL allows you to set the name of the NDI source being created.
	URL() InputURL
	// UDP URL of multicast group
	// /Another Flussonic URL where to push video to.
	// /Flussonic stream URL where to push to.
	// /Specify Blackmagic Decklink SDI card as a destination for this stream.
	// You need to specify exact number of output, refer to decklink manual to find
	// enumeration rules.
	// /Select which Dektec SDI card to use as a sink for this stream.
	// Dektec url is combined of card serial # and number of output port on this card.
	// Output ports on a card are numbered starting from 1.
	// Serial numbers are uniq for each produced card. Take a look at admin UI or use
	// native dektec tools to find the serial number.
	// /Select which Dektec ASI card to use as a sink for this stream.
	// Dektec url is combined of card serial # and number of output port on this card.
	// Output ports on a card are numbered starting from 1.
	// Serial numbers are uniq for each produced card. Take a look at admin UI or use
	// native dektec tools to find the serial number.
	// Mention that ASI is a MPEG-TS transport
	// /Content will be similar to multicast MPEG-TS, but endless HTTP POST will be used to upload content.
	// /It is possible to publish HLS to a CDN. Segments will be uploaded together with manifests.
	// /SRT URL where to push video.
	// /The URL allows you to set the name of the NDI source being created.
	SetURL(InputURL) StreamPush
	// Average bitrate per second that you can send of a video track, including all the headers and encapsulation in the transport stream.
	// So, for example, the value of vb=2720 approximately corresponds to the bitrate 2600 specified in the transcoder settings.
	// Format: speed (speed)
	// Example: 2720
	Vb() *Speed
	// Average bitrate per second that you can send of a video track, including all the headers and encapsulation in the transport stream.
	// So, for example, the value of vb=2720 approximately corresponds to the bitrate 2600 specified in the transcoder settings.
	// Format: speed (speed)
	// Example: 2720
	SetVb(Speed) StreamPush
	// Lines of VBI (vertical blanking interval) of an output analog stream that will contain teletext.
	// It is used for passing teletext from MPEG-TS to analog streams.
	VbiLines() []VbiLines
	// Lines of VBI (vertical blanking interval) of an output analog stream that will contain teletext.
	// It is used for passing teletext from MPEG-TS to analog streams.
	SetVbiLines([]VbiLines) StreamPush
	// Required SRT version.
	// Pattern: ^[0-9]+\.[0-9]+\.[0-9]+$
	// Example: 1.3.0
	Version() *string
	// Required SRT version.
	// Pattern: ^[0-9]+\.[0-9]+\.[0-9]+$
	// Example: 1.3.0
	SetVersion(string) StreamPush
	// Specify SDI/HDMI output format
	VideoFormat() *string
	// Specify SDI/HDMI output format
	SetVideoFormat(string) StreamPush
	// Audio volume coefficient.
	// The output audio volume is given by the relation: `output_volume = volume * input_volume`.
	// The maximum volume value is 1.0 (default value).
	// Example: 0.5
	Volume() *float64
	// Audio volume coefficient.
	// The output audio volume is given by the relation: `output_volume = volume * input_volume`.
	// The maximum volume value is 1.0 (default value).
	// Example: 0.5
	SetVolume(float64) StreamPush
}

type StreamPushBase interface {
	// Human-readable description of the pusher.
	// Example: This is a test push
	Comment() *string
	// Human-readable description of the pusher.
	// Example: This is a test push
	SetComment(string) StreamPushBase
	// Connection timeout, in seconds. Equals to 0 by default.
	// Format: seconds (seconds)
	// Example: 2
	ConnectTimeout() *Seconds
	// Connection timeout, in seconds. Equals to 0 by default.
	// Format: seconds (seconds)
	// Example: 2
	SetConnectTimeout(Seconds) StreamPushBase
	// Disable pushing the stream.
	// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
	// In this way, the URL and other settings of a disabled stream remain in Flussonic.
	Disabled() *bool
	// Disable pushing the stream.
	// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
	// In this way, the URL and other settings of a disabled stream remain in Flussonic.
	SetDisabled(bool) StreamPushBase
	// The maximum number of times *Flussonic* retries to push the stream.
	RetryLimit() *int
	// The maximum number of times *Flussonic* retries to push the stream.
	SetRetryLimit(int) StreamPushBase
	// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
	// It is an interval in seconds, 5 seconds by default.
	// You can increase this value to reduce server load.
	// Format: seconds (seconds)
	// Example: 7
	RetryTimeout() *Seconds
	// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
	// It is an interval in seconds, 5 seconds by default.
	// You can increase this value to reduce server load.
	// Format: seconds (seconds)
	// Example: 7
	SetRetryTimeout(Seconds) StreamPushBase
	// Detailed runtime information about the push.
	Stats() PushCounters
	// Detailed runtime information about the push.
	SetStats(PushCounters) StreamPushBase
	// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
	// Format: seconds (seconds)
	// Example: 10
	Timeout() *Seconds
	// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
	// Format: seconds (seconds)
	// Example: 10
	SetTimeout(Seconds) StreamPushBase
}

type StreamPushDecklink interface {
	// Human-readable description of the pusher.
	// Example: This is a test push
	Comment() *string
	// Human-readable description of the pusher.
	// Example: This is a test push
	SetComment(string) StreamPushDecklink
	// Connection timeout, in seconds. Equals to 0 by default.
	// Format: seconds (seconds)
	// Example: 2
	ConnectTimeout() *Seconds
	// Connection timeout, in seconds. Equals to 0 by default.
	// Format: seconds (seconds)
	// Example: 2
	SetConnectTimeout(Seconds) StreamPushDecklink
	// Activate deinterlacing, i.e., converting an interlaced image to a progressive image.
	// It is necessary for comfortable viewing of legacy TV video on PC/mobile devices.
	Deinterlace() *bool
	// Activate deinterlacing, i.e., converting an interlaced image to a progressive image.
	// It is necessary for comfortable viewing of legacy TV video on PC/mobile devices.
	SetDeinterlace(bool) StreamPushDecklink
	// Disable pushing the stream.
	// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
	// In this way, the URL and other settings of a disabled stream remain in Flussonic.
	Disabled() *bool
	// Disable pushing the stream.
	// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
	// In this way, the URL and other settings of a disabled stream remain in Flussonic.
	SetDisabled(bool) StreamPushDecklink
	// Defines a number of threads in a decoder.
	// One thread uses one core.
	// The default value equals 4, but you can set it equal to the number of cores of your CPU.
	Dthreads() *int
	// Defines a number of threads in a decoder.
	// One thread uses one core.
	// The default value equals 4, but you can set it equal to the number of cores of your CPU.
	SetDthreads(int) StreamPushDecklink
	// The maximum number of times *Flussonic* retries to push the stream.
	RetryLimit() *int
	// The maximum number of times *Flussonic* retries to push the stream.
	SetRetryLimit(int) StreamPushDecklink
	// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
	// It is an interval in seconds, 5 seconds by default.
	// You can increase this value to reduce server load.
	// Format: seconds (seconds)
	// Example: 7
	RetryTimeout() *Seconds
	// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
	// It is an interval in seconds, 5 seconds by default.
	// You can increase this value to reduce server load.
	// Format: seconds (seconds)
	// Example: 7
	SetRetryTimeout(Seconds) StreamPushDecklink
	// Defines a scaling algorithm.
	// You can choose only one algorithm at a time.
	// If a pushing stream has the same video resolution as an ingest stream, the `fast_bilinear` algorithm is used by default.
	// If a video resolution of a pushing stream does not equal the video resolution of an ingest stream, the bicubic algorithm is used by default.
	// If the algorithm is specified explicitly, it applies to all the formats.
	Scale() *ScaleAlgorithm
	// Defines a scaling algorithm.
	// You can choose only one algorithm at a time.
	// If a pushing stream has the same video resolution as an ingest stream, the `fast_bilinear` algorithm is used by default.
	// If a video resolution of a pushing stream does not equal the video resolution of an ingest stream, the bicubic algorithm is used by default.
	// If the algorithm is specified explicitly, it applies to all the formats.
	SetScale(ScaleAlgorithm) StreamPushDecklink
	// Detailed runtime information about the push.
	Stats() PushCounters
	// Detailed runtime information about the push.
	SetStats(PushCounters) StreamPushDecklink
	// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
	// Format: seconds (seconds)
	// Example: 10
	Timeout() *Seconds
	// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
	// Format: seconds (seconds)
	// Example: 10
	SetTimeout(Seconds) StreamPushDecklink
	// Specify Blackmagic Decklink SDI card as a destination for this stream.
	// You need to specify exact number of output, refer to decklink manual to find
	// enumeration rules.
	// Format: input_url (input_url)
	// Pattern: ^decklink://[0-9]+$
	// Examples: decklink://0
	URL() InputURL
	// Specify Blackmagic Decklink SDI card as a destination for this stream.
	// You need to specify exact number of output, refer to decklink manual to find
	// enumeration rules.
	// Format: input_url (input_url)
	// Pattern: ^decklink://[0-9]+$
	// Examples: decklink://0
	SetURL(InputURL) StreamPushDecklink
	// Lines of VBI (vertical blanking interval) of an output analog stream that will contain teletext.
	// It is used for passing teletext from MPEG-TS to analog streams.
	VbiLines() []VbiLines
	// Lines of VBI (vertical blanking interval) of an output analog stream that will contain teletext.
	// It is used for passing teletext from MPEG-TS to analog streams.
	SetVbiLines([]VbiLines) StreamPushDecklink
	// Specify SDI/HDMI output format
	VideoFormat() *string
	// Specify SDI/HDMI output format
	SetVideoFormat(string) StreamPushDecklink
	// Audio volume coefficient.
	// The output audio volume is given by the relation: `output_volume = volume * input_volume`.
	// The maximum volume value is 1.0 (default value).
	// Example: 0.5
	Volume() *float64
	// Audio volume coefficient.
	// The output audio volume is given by the relation: `output_volume = volume * input_volume`.
	// The maximum volume value is 1.0 (default value).
	// Example: 0.5
	SetVolume(float64) StreamPushDecklink
}

type StreamPushDektec interface {
	// Human-readable description of the pusher.
	// Example: This is a test push
	Comment() *string
	// Human-readable description of the pusher.
	// Example: This is a test push
	SetComment(string) StreamPushDektec
	// Connection timeout, in seconds. Equals to 0 by default.
	// Format: seconds (seconds)
	// Example: 2
	ConnectTimeout() *Seconds
	// Connection timeout, in seconds. Equals to 0 by default.
	// Format: seconds (seconds)
	// Example: 2
	SetConnectTimeout(Seconds) StreamPushDektec
	// Activate deinterlacing, i.e., converting an interlaced image to a progressive image.
	// It is necessary for comfortable viewing of legacy TV video on PC/mobile devices.
	Deinterlace() *bool
	// Activate deinterlacing, i.e., converting an interlaced image to a progressive image.
	// It is necessary for comfortable viewing of legacy TV video on PC/mobile devices.
	SetDeinterlace(bool) StreamPushDektec
	// Disable pushing the stream.
	// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
	// In this way, the URL and other settings of a disabled stream remain in Flussonic.
	Disabled() *bool
	// Disable pushing the stream.
	// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
	// In this way, the URL and other settings of a disabled stream remain in Flussonic.
	SetDisabled(bool) StreamPushDektec
	// Defines a number of threads in a decoder.
	// One thread uses one core.
	// The default value equals 4, but you can set it equal to the number of cores of your CPU.
	Dthreads() *int
	// Defines a number of threads in a decoder.
	// One thread uses one core.
	// The default value equals 4, but you can set it equal to the number of cores of your CPU.
	SetDthreads(int) StreamPushDektec
	// Enable clock-lock feature (if supported). See also genlock_status property in pusher stats.
	Genlock() *bool
	// Enable clock-lock feature (if supported). See also genlock_status property in pusher stats.
	SetGenlock(bool) StreamPushDektec
	// Adjusting genlock timing pixel offset.
	PixelOffset() *int
	// Adjusting genlock timing pixel offset.
	SetPixelOffset(int) StreamPushDektec
	// The maximum number of times *Flussonic* retries to push the stream.
	RetryLimit() *int
	// The maximum number of times *Flussonic* retries to push the stream.
	SetRetryLimit(int) StreamPushDektec
	// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
	// It is an interval in seconds, 5 seconds by default.
	// You can increase this value to reduce server load.
	// Format: seconds (seconds)
	// Example: 7
	RetryTimeout() *Seconds
	// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
	// It is an interval in seconds, 5 seconds by default.
	// You can increase this value to reduce server load.
	// Format: seconds (seconds)
	// Example: 7
	SetRetryTimeout(Seconds) StreamPushDektec
	// Defines a scaling algorithm.
	// You can choose only one algorithm at a time.
	// If a pushing stream has the same video resolution as an ingest stream, the `fast_bilinear` algorithm is used by default.
	// If a video resolution of a pushing stream does not equal the video resolution of an ingest stream, the bicubic algorithm is used by default.
	// If the algorithm is specified explicitly, it applies to all the formats.
	Scale() *ScaleAlgorithm
	// Defines a scaling algorithm.
	// You can choose only one algorithm at a time.
	// If a pushing stream has the same video resolution as an ingest stream, the `fast_bilinear` algorithm is used by default.
	// If a video resolution of a pushing stream does not equal the video resolution of an ingest stream, the bicubic algorithm is used by default.
	// If the algorithm is specified explicitly, it applies to all the formats.
	SetScale(ScaleAlgorithm) StreamPushDektec
	// Detailed runtime information about the push.
	Stats() PushCounters
	// Detailed runtime information about the push.
	SetStats(PushCounters) StreamPushDektec
	// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
	// Format: seconds (seconds)
	// Example: 10
	Timeout() *Seconds
	// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
	// Format: seconds (seconds)
	// Example: 10
	SetTimeout(Seconds) StreamPushDektec
	// Select which Dektec SDI card to use as a sink for this stream.
	// Dektec url is combined of card serial # and number of output port on this card.
	// Output ports on a card are numbered starting from 1.
	// Serial numbers are uniq for each produced card. Take a look at admin UI or use
	// native dektec tools to find the serial number.
	// Format: input_url (input_url)
	// Pattern: ^dektec://[0-9]+:[0-9]+$
	// Examples: dektec://2174223350:1
	URL() InputURL
	// Select which Dektec SDI card to use as a sink for this stream.
	// Dektec url is combined of card serial # and number of output port on this card.
	// Output ports on a card are numbered starting from 1.
	// Serial numbers are uniq for each produced card. Take a look at admin UI or use
	// native dektec tools to find the serial number.
	// Format: input_url (input_url)
	// Pattern: ^dektec://[0-9]+:[0-9]+$
	// Examples: dektec://2174223350:1
	SetURL(InputURL) StreamPushDektec
	// Lines of VBI (vertical blanking interval) of an output analog stream that will contain teletext.
	// It is used for passing teletext from MPEG-TS to analog streams.
	VbiLines() []VbiLines
	// Lines of VBI (vertical blanking interval) of an output analog stream that will contain teletext.
	// It is used for passing teletext from MPEG-TS to analog streams.
	SetVbiLines([]VbiLines) StreamPushDektec
	// Specify SDI/HDMI output format
	VideoFormat() *string
	// Specify SDI/HDMI output format
	SetVideoFormat(string) StreamPushDektec
	// Audio volume coefficient.
	// The output audio volume is given by the relation: `output_volume = volume * input_volume`.
	// The maximum volume value is 1.0 (default value).
	// Example: 0.5
	Volume() *float64
	// Audio volume coefficient.
	// The output audio volume is given by the relation: `output_volume = volume * input_volume`.
	// The maximum volume value is 1.0 (default value).
	// Example: 0.5
	SetVolume(float64) StreamPushDektec
}

type StreamPushDektecAsi interface {
	// The bitrate of the whole stream.
	// Format: speed (speed)
	// Example: 3200
	Bitrate() *Speed
	// The bitrate of the whole stream.
	// Format: speed (speed)
	// Example: 3200
	SetBitrate(Speed) StreamPushDektecAsi
	// Human-readable description of the pusher.
	// Example: This is a test push
	Comment() *string
	// Human-readable description of the pusher.
	// Example: This is a test push
	SetComment(string) StreamPushDektecAsi
	// Connection timeout, in seconds. Equals to 0 by default.
	// Format: seconds (seconds)
	// Example: 2
	ConnectTimeout() *Seconds
	// Connection timeout, in seconds. Equals to 0 by default.
	// Format: seconds (seconds)
	// Example: 2
	SetConnectTimeout(Seconds) StreamPushDektecAsi
	// Disable pushing the stream.
	// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
	// In this way, the URL and other settings of a disabled stream remain in Flussonic.
	Disabled() *bool
	// Disable pushing the stream.
	// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
	// In this way, the URL and other settings of a disabled stream remain in Flussonic.
	SetDisabled(bool) StreamPushDektecAsi
	// It allows to specify pack information about ac3 for outgoing MPEGTS-TS streams. The default value is `system_b`.
	MpegtsAc3() *OutputMpegtsAc3
	// It allows to specify pack information about ac3 for outgoing MPEGTS-TS streams. The default value is `system_b`.
	SetMpegtsAc3(OutputMpegtsAc3) StreamPushDektecAsi
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// It is possible to set PID values for PMT, STD and video and audio tracks.
	Pids() OutputMpegtsPids
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// It is possible to set PID values for PMT, STD and video and audio tracks.
	SetPids(OutputMpegtsPids) StreamPushDektecAsi
	// Program number in the outgoing MPEG-TS stream. A program may represent a television channel.
	Pnr() *int
	// Program number in the outgoing MPEG-TS stream. A program may represent a television channel.
	SetPnr(int) StreamPushDektecAsi
	// Provider name. Used to fill in the field service provider within SDT MPEG-TS table.
	// Example: My provider name
	Provider() *string
	// Provider name. Used to fill in the field service provider within SDT MPEG-TS table.
	// Example: My provider name
	SetProvider(string) StreamPushDektecAsi
	// The maximum number of times *Flussonic* retries to push the stream.
	RetryLimit() *int
	// The maximum number of times *Flussonic* retries to push the stream.
	SetRetryLimit(int) StreamPushDektecAsi
	// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
	// It is an interval in seconds, 5 seconds by default.
	// You can increase this value to reduce server load.
	// Format: seconds (seconds)
	// Example: 7
	RetryTimeout() *Seconds
	// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
	// It is an interval in seconds, 5 seconds by default.
	// You can increase this value to reduce server load.
	// Format: seconds (seconds)
	// Example: 7
	SetRetryTimeout(Seconds) StreamPushDektecAsi
	// Service name. Used to fill in the field service name within SDT MPEG-TS table.
	// Example: My service name
	Service() *string
	// Service name. Used to fill in the field service name within SDT MPEG-TS table.
	// Example: My service name
	SetService(string) StreamPushDektecAsi
	// Detailed runtime information about the push.
	Stats() PushCounters
	// Detailed runtime information about the push.
	SetStats(PushCounters) StreamPushDektecAsi
	// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
	// Format: seconds (seconds)
	// Example: 10
	Timeout() *Seconds
	// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
	// Format: seconds (seconds)
	// Example: 10
	SetTimeout(Seconds) StreamPushDektecAsi
	// Select which Dektec ASI card to use as a sink for this stream.
	// Dektec url is combined of card serial # and number of output port on this card.
	// Output ports on a card are numbered starting from 1.
	// Serial numbers are uniq for each produced card. Take a look at admin UI or use
	// native dektec tools to find the serial number.
	// Mention that ASI is a MPEG-TS transport
	// Format: input_url (input_url)
	// Pattern: ^dektec-asi://.*$
	// Examples: dektec-asi://
	URL() InputURL
	// Select which Dektec ASI card to use as a sink for this stream.
	// Dektec url is combined of card serial # and number of output port on this card.
	// Output ports on a card are numbered starting from 1.
	// Serial numbers are uniq for each produced card. Take a look at admin UI or use
	// native dektec tools to find the serial number.
	// Mention that ASI is a MPEG-TS transport
	// Format: input_url (input_url)
	// Pattern: ^dektec-asi://.*$
	// Examples: dektec-asi://
	SetURL(InputURL) StreamPushDektecAsi
	// Average bitrate per second that you can send of a video track, including all the headers and encapsulation in the transport stream.
	// So, for example, the value of vb=2720 approximately corresponds to the bitrate 2600 specified in the transcoder settings.
	// Format: speed (speed)
	// Example: 2720
	Vb() *Speed
	// Average bitrate per second that you can send of a video track, including all the headers and encapsulation in the transport stream.
	// So, for example, the value of vb=2720 approximately corresponds to the bitrate 2600 specified in the transcoder settings.
	// Format: speed (speed)
	// Example: 2720
	SetVb(Speed) StreamPushDektecAsi
}

type StreamPushHls interface {
	// Human-readable description of the pusher.
	// Example: This is a test push
	Comment() *string
	// Human-readable description of the pusher.
	// Example: This is a test push
	SetComment(string) StreamPushHls
	// Connection timeout, in seconds. Equals to 0 by default.
	// Format: seconds (seconds)
	// Example: 2
	ConnectTimeout() *Seconds
	// Connection timeout, in seconds. Equals to 0 by default.
	// Format: seconds (seconds)
	// Example: 2
	SetConnectTimeout(Seconds) StreamPushHls
	// Disable pushing the stream.
	// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
	// In this way, the URL and other settings of a disabled stream remain in Flussonic.
	Disabled() *bool
	// Disable pushing the stream.
	// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
	// In this way, the URL and other settings of a disabled stream remain in Flussonic.
	SetDisabled(bool) StreamPushHls
	// The maximum number of times *Flussonic* retries to push the stream.
	RetryLimit() *int
	// The maximum number of times *Flussonic* retries to push the stream.
	SetRetryLimit(int) StreamPushHls
	// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
	// It is an interval in seconds, 5 seconds by default.
	// You can increase this value to reduce server load.
	// Format: seconds (seconds)
	// Example: 7
	RetryTimeout() *Seconds
	// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
	// It is an interval in seconds, 5 seconds by default.
	// You can increase this value to reduce server load.
	// Format: seconds (seconds)
	// Example: 7
	SetRetryTimeout(Seconds) StreamPushHls
	// Detailed runtime information about the push.
	Stats() PushCounters
	// Detailed runtime information about the push.
	SetStats(PushCounters) StreamPushHls
	// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
	// Format: seconds (seconds)
	// Example: 10
	Timeout() *Seconds
	// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
	// Format: seconds (seconds)
	// Example: 10
	SetTimeout(Seconds) StreamPushHls
	// It is possible to publish HLS to a CDN. Segments will be uploaded together with manifests.
	// Format: input_url (input_url)
	// Pattern: ^hlss?://.*$
	// Examples: hls://your-server.com/app/stream1
	URL() InputURL
	// It is possible to publish HLS to a CDN. Segments will be uploaded together with manifests.
	// Format: input_url (input_url)
	// Pattern: ^hlss?://.*$
	// Examples: hls://your-server.com/app/stream1
	SetURL(InputURL) StreamPushHls
}

type StreamPushM4f interface {
	// Human-readable description of the pusher.
	// Example: This is a test push
	Comment() *string
	// Human-readable description of the pusher.
	// Example: This is a test push
	SetComment(string) StreamPushM4f
	// Connection timeout, in seconds. Equals to 0 by default.
	// Format: seconds (seconds)
	// Example: 2
	ConnectTimeout() *Seconds
	// Connection timeout, in seconds. Equals to 0 by default.
	// Format: seconds (seconds)
	// Example: 2
	SetConnectTimeout(Seconds) StreamPushM4f
	// Disable pushing the stream.
	// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
	// In this way, the URL and other settings of a disabled stream remain in Flussonic.
	Disabled() *bool
	// Disable pushing the stream.
	// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
	// In this way, the URL and other settings of a disabled stream remain in Flussonic.
	SetDisabled(bool) StreamPushM4f
	// The maximum number of times *Flussonic* retries to push the stream.
	RetryLimit() *int
	// The maximum number of times *Flussonic* retries to push the stream.
	SetRetryLimit(int) StreamPushM4f
	// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
	// It is an interval in seconds, 5 seconds by default.
	// You can increase this value to reduce server load.
	// Format: seconds (seconds)
	// Example: 7
	RetryTimeout() *Seconds
	// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
	// It is an interval in seconds, 5 seconds by default.
	// You can increase this value to reduce server load.
	// Format: seconds (seconds)
	// Example: 7
	SetRetryTimeout(Seconds) StreamPushM4f
	// Detailed runtime information about the push.
	Stats() PushCounters
	// Detailed runtime information about the push.
	SetStats(PushCounters) StreamPushM4f
	// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
	// Format: seconds (seconds)
	// Example: 10
	Timeout() *Seconds
	// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
	// Format: seconds (seconds)
	// Example: 10
	SetTimeout(Seconds) StreamPushM4f
	// Another Flussonic URL where to push video to.
	// Format: input_url (input_url)
	// Pattern: ^m4fs?://.*$
	// Examples: m4f://your-server.com/app/stream1
	URL() InputURL
	// Another Flussonic URL where to push video to.
	// Format: input_url (input_url)
	// Pattern: ^m4fs?://.*$
	// Examples: m4f://your-server.com/app/stream1
	SetURL(InputURL) StreamPushM4f
}

type StreamPushM4s interface {
	// Human-readable description of the pusher.
	// Example: This is a test push
	Comment() *string
	// Human-readable description of the pusher.
	// Example: This is a test push
	SetComment(string) StreamPushM4s
	// Connection timeout, in seconds. Equals to 0 by default.
	// Format: seconds (seconds)
	// Example: 2
	ConnectTimeout() *Seconds
	// Connection timeout, in seconds. Equals to 0 by default.
	// Format: seconds (seconds)
	// Example: 2
	SetConnectTimeout(Seconds) StreamPushM4s
	// Disable pushing the stream.
	// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
	// In this way, the URL and other settings of a disabled stream remain in Flussonic.
	Disabled() *bool
	// Disable pushing the stream.
	// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
	// In this way, the URL and other settings of a disabled stream remain in Flussonic.
	SetDisabled(bool) StreamPushM4s
	// The maximum number of times *Flussonic* retries to push the stream.
	RetryLimit() *int
	// The maximum number of times *Flussonic* retries to push the stream.
	SetRetryLimit(int) StreamPushM4s
	// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
	// It is an interval in seconds, 5 seconds by default.
	// You can increase this value to reduce server load.
	// Format: seconds (seconds)
	// Example: 7
	RetryTimeout() *Seconds
	// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
	// It is an interval in seconds, 5 seconds by default.
	// You can increase this value to reduce server load.
	// Format: seconds (seconds)
	// Example: 7
	SetRetryTimeout(Seconds) StreamPushM4s
	// Detailed runtime information about the push.
	Stats() PushCounters
	// Detailed runtime information about the push.
	SetStats(PushCounters) StreamPushM4s
	// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
	// Format: seconds (seconds)
	// Example: 10
	Timeout() *Seconds
	// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
	// Format: seconds (seconds)
	// Example: 10
	SetTimeout(Seconds) StreamPushM4s
	// Flussonic stream URL where to push to.
	// Format: input_url (input_url)
	// Pattern: ^m4ss?://.*$
	// Examples: m4s://your-server.com/app/stream1
	URL() InputURL
	// Flussonic stream URL where to push to.
	// Format: input_url (input_url)
	// Pattern: ^m4ss?://.*$
	// Examples: m4s://your-server.com/app/stream1
	SetURL(InputURL) StreamPushM4s
}

type StreamPushMpegtsBase interface {
	// The bitrate of the whole stream.
	// Format: speed (speed)
	// Example: 3200
	Bitrate() *Speed
	// The bitrate of the whole stream.
	// Format: speed (speed)
	// Example: 3200
	SetBitrate(Speed) StreamPushMpegtsBase
	// It allows to specify pack information about ac3 for outgoing MPEGTS-TS streams. The default value is `system_b`.
	MpegtsAc3() *OutputMpegtsAc3
	// It allows to specify pack information about ac3 for outgoing MPEGTS-TS streams. The default value is `system_b`.
	SetMpegtsAc3(OutputMpegtsAc3) StreamPushMpegtsBase
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// It is possible to set PID values for PMT, STD and video and audio tracks.
	Pids() OutputMpegtsPids
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// It is possible to set PID values for PMT, STD and video and audio tracks.
	SetPids(OutputMpegtsPids) StreamPushMpegtsBase
	// Program number in the outgoing MPEG-TS stream. A program may represent a television channel.
	Pnr() *int
	// Program number in the outgoing MPEG-TS stream. A program may represent a television channel.
	SetPnr(int) StreamPushMpegtsBase
	// Provider name. Used to fill in the field service provider within SDT MPEG-TS table.
	// Example: My provider name
	Provider() *string
	// Provider name. Used to fill in the field service provider within SDT MPEG-TS table.
	// Example: My provider name
	SetProvider(string) StreamPushMpegtsBase
	// Service name. Used to fill in the field service name within SDT MPEG-TS table.
	// Example: My service name
	Service() *string
	// Service name. Used to fill in the field service name within SDT MPEG-TS table.
	// Example: My service name
	SetService(string) StreamPushMpegtsBase
	// Average bitrate per second that you can send of a video track, including all the headers and encapsulation in the transport stream.
	// So, for example, the value of vb=2720 approximately corresponds to the bitrate 2600 specified in the transcoder settings.
	// Format: speed (speed)
	// Example: 2720
	Vb() *Speed
	// Average bitrate per second that you can send of a video track, including all the headers and encapsulation in the transport stream.
	// So, for example, the value of vb=2720 approximately corresponds to the bitrate 2600 specified in the transcoder settings.
	// Format: speed (speed)
	// Example: 2720
	SetVb(Speed) StreamPushMpegtsBase
}

type StreamPushNdi interface {
	// Human-readable description of the pusher.
	// Example: This is a test push
	Comment() *string
	// Human-readable description of the pusher.
	// Example: This is a test push
	SetComment(string) StreamPushNdi
	// Connection timeout, in seconds. Equals to 0 by default.
	// Format: seconds (seconds)
	// Example: 2
	ConnectTimeout() *Seconds
	// Connection timeout, in seconds. Equals to 0 by default.
	// Format: seconds (seconds)
	// Example: 2
	SetConnectTimeout(Seconds) StreamPushNdi
	// Disable pushing the stream.
	// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
	// In this way, the URL and other settings of a disabled stream remain in Flussonic.
	Disabled() *bool
	// Disable pushing the stream.
	// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
	// In this way, the URL and other settings of a disabled stream remain in Flussonic.
	SetDisabled(bool) StreamPushNdi
	// The maximum number of times *Flussonic* retries to push the stream.
	RetryLimit() *int
	// The maximum number of times *Flussonic* retries to push the stream.
	SetRetryLimit(int) StreamPushNdi
	// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
	// It is an interval in seconds, 5 seconds by default.
	// You can increase this value to reduce server load.
	// Format: seconds (seconds)
	// Example: 7
	RetryTimeout() *Seconds
	// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
	// It is an interval in seconds, 5 seconds by default.
	// You can increase this value to reduce server load.
	// Format: seconds (seconds)
	// Example: 7
	SetRetryTimeout(Seconds) StreamPushNdi
	// Detailed runtime information about the push.
	Stats() PushCounters
	// Detailed runtime information about the push.
	SetStats(PushCounters) StreamPushNdi
	// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
	// Format: seconds (seconds)
	// Example: 10
	Timeout() *Seconds
	// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
	// Format: seconds (seconds)
	// Example: 10
	SetTimeout(Seconds) StreamPushNdi
	// The URL allows you to set the name of the NDI source being created.
	// Format: input_url (input_url)
	// Pattern: ^ndi://.*$
	// Examples: ndi://source_name
	URL() InputURL
	// The URL allows you to set the name of the NDI source being created.
	// Format: input_url (input_url)
	// Pattern: ^ndi://.*$
	// Examples: ndi://source_name
	SetURL(InputURL) StreamPushNdi
}

type StreamPushRtmp interface {
	// Human-readable description of the pusher.
	// Example: This is a test push
	Comment() *string
	// Human-readable description of the pusher.
	// Example: This is a test push
	SetComment(string) StreamPushRtmp
	// Connection timeout, in seconds. Equals to 0 by default.
	// Format: seconds (seconds)
	// Example: 2
	ConnectTimeout() *Seconds
	// Connection timeout, in seconds. Equals to 0 by default.
	// Format: seconds (seconds)
	// Example: 2
	SetConnectTimeout(Seconds) StreamPushRtmp
	// Disable pushing the stream.
	// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
	// In this way, the URL and other settings of a disabled stream remain in Flussonic.
	Disabled() *bool
	// Disable pushing the stream.
	// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
	// In this way, the URL and other settings of a disabled stream remain in Flussonic.
	SetDisabled(bool) StreamPushRtmp
	// Service public domain name.
	// The value will be sent within notify message with command name 'onMetaData'
	// Metadata also will contain the name `Streamer`, streamer version, the type and version of the operating system.
	// Metadata will be sent as map with associated map key `yt_project`.
	// String template is `Streamer #{streamer_version} #{encoder} #{os_type} #{os_version} #{domain}`.
	// Example of the resulting string is `{"yt_project" : "Streamer 25.01 Lavf56.40.101 unix-linux 6.1.0 officialdomain.com"}`.
	// Example: officialdomain.com
	Domain() *string
	// Service public domain name.
	// The value will be sent within notify message with command name 'onMetaData'
	// Metadata also will contain the name `Streamer`, streamer version, the type and version of the operating system.
	// Metadata will be sent as map with associated map key `yt_project`.
	// String template is `Streamer #{streamer_version} #{encoder} #{os_type} #{os_version} #{domain}`.
	// Example of the resulting string is `{"yt_project" : "Streamer 25.01 Lavf56.40.101 unix-linux 6.1.0 officialdomain.com"}`.
	// Example: officialdomain.com
	SetDomain(string) StreamPushRtmp
	// The name of the encoder used by the pusher. Can also be used as a device name.
	// The value will be sent within notify message with command name 'onMetaData' and within FlashVer string (see above).
	// Example: Lavf57
	Encoder() *string
	// The name of the encoder used by the pusher. Can also be used as a device name.
	// The value will be sent within notify message with command name 'onMetaData' and within FlashVer string (see above).
	// Example: Lavf57
	SetEncoder(string) StreamPushRtmp
	// The maximum number of times *Flussonic* retries to push the stream.
	RetryLimit() *int
	// The maximum number of times *Flussonic* retries to push the stream.
	SetRetryLimit(int) StreamPushRtmp
	// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
	// It is an interval in seconds, 5 seconds by default.
	// You can increase this value to reduce server load.
	// Format: seconds (seconds)
	// Example: 7
	RetryTimeout() *Seconds
	// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
	// It is an interval in seconds, 5 seconds by default.
	// You can increase this value to reduce server load.
	// Format: seconds (seconds)
	// Example: 7
	SetRetryTimeout(Seconds) StreamPushRtmp
	// The name of the service.
	// The value will be sent within FlashVer string when establishing a connection.
	// String template is `FMLE/3.0 (compatible; #{encoder}; Streamer #{streamer_version}; #{service}`.
	// Example of the resulting FlashVer string is `FMLE/3.0 (compatible; Lavf56.40.101; Streamer 25.01; My service)`.
	// Example: My service
	Service() *string
	// The name of the service.
	// The value will be sent within FlashVer string when establishing a connection.
	// String template is `FMLE/3.0 (compatible; #{encoder}; Streamer #{streamer_version}; #{service}`.
	// Example of the resulting FlashVer string is `FMLE/3.0 (compatible; Lavf56.40.101; Streamer 25.01; My service)`.
	// Example: My service
	SetService(string) StreamPushRtmp
	// Detailed runtime information about the push.
	Stats() PushCounters
	// Detailed runtime information about the push.
	SetStats(PushCounters) StreamPushRtmp
	// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
	// Format: seconds (seconds)
	// Example: 10
	Timeout() *Seconds
	// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
	// Format: seconds (seconds)
	// Example: 10
	SetTimeout(Seconds) StreamPushRtmp
	// RTMP URL where to push.
	// You can publish to RTMP servers. Usually it is a social network streaming.
	// Format: input_url (input_url)
	// Pattern: ^rtmps?://.*$
	// Examples: rtmp://your-server.com/app/stream1
	URL() InputURL
	// RTMP URL where to push.
	// You can publish to RTMP servers. Usually it is a social network streaming.
	// Format: input_url (input_url)
	// Pattern: ^rtmps?://.*$
	// Examples: rtmp://your-server.com/app/stream1
	SetURL(InputURL) StreamPushRtmp
}

type StreamPushSdiBase interface {
	// Activate deinterlacing, i.e., converting an interlaced image to a progressive image.
	// It is necessary for comfortable viewing of legacy TV video on PC/mobile devices.
	Deinterlace() *bool
	// Activate deinterlacing, i.e., converting an interlaced image to a progressive image.
	// It is necessary for comfortable viewing of legacy TV video on PC/mobile devices.
	SetDeinterlace(bool) StreamPushSdiBase
	// Defines a number of threads in a decoder.
	// One thread uses one core.
	// The default value equals 4, but you can set it equal to the number of cores of your CPU.
	Dthreads() *int
	// Defines a number of threads in a decoder.
	// One thread uses one core.
	// The default value equals 4, but you can set it equal to the number of cores of your CPU.
	SetDthreads(int) StreamPushSdiBase
	// Defines a scaling algorithm.
	// You can choose only one algorithm at a time.
	// If a pushing stream has the same video resolution as an ingest stream, the `fast_bilinear` algorithm is used by default.
	// If a video resolution of a pushing stream does not equal the video resolution of an ingest stream, the bicubic algorithm is used by default.
	// If the algorithm is specified explicitly, it applies to all the formats.
	Scale() *ScaleAlgorithm
	// Defines a scaling algorithm.
	// You can choose only one algorithm at a time.
	// If a pushing stream has the same video resolution as an ingest stream, the `fast_bilinear` algorithm is used by default.
	// If a video resolution of a pushing stream does not equal the video resolution of an ingest stream, the bicubic algorithm is used by default.
	// If the algorithm is specified explicitly, it applies to all the formats.
	SetScale(ScaleAlgorithm) StreamPushSdiBase
	// Lines of VBI (vertical blanking interval) of an output analog stream that will contain teletext.
	// It is used for passing teletext from MPEG-TS to analog streams.
	VbiLines() []VbiLines
	// Lines of VBI (vertical blanking interval) of an output analog stream that will contain teletext.
	// It is used for passing teletext from MPEG-TS to analog streams.
	SetVbiLines([]VbiLines) StreamPushSdiBase
	// Specify SDI/HDMI output format
	VideoFormat() *string
	// Specify SDI/HDMI output format
	SetVideoFormat(string) StreamPushSdiBase
	// Audio volume coefficient.
	// The output audio volume is given by the relation: `output_volume = volume * input_volume`.
	// The maximum volume value is 1.0 (default value).
	// Example: 0.5
	Volume() *float64
	// Audio volume coefficient.
	// The output audio volume is given by the relation: `output_volume = volume * input_volume`.
	// The maximum volume value is 1.0 (default value).
	// Example: 0.5
	SetVolume(float64) StreamPushSdiBase
}

type StreamPushSrt interface {
	// The bitrate of the whole stream.
	// Format: speed (speed)
	// Example: 3200
	Bitrate() *Speed
	// The bitrate of the whole stream.
	// Format: speed (speed)
	// Example: 3200
	SetBitrate(Speed) StreamPushSrt
	// Human-readable description of the pusher.
	// Example: This is a test push
	Comment() *string
	// Human-readable description of the pusher.
	// Example: This is a test push
	SetComment(string) StreamPushSrt
	// Connection timeout, in seconds. Equals to 0 by default.
	// Format: seconds (seconds)
	// Example: 2
	ConnectTimeout() *Seconds
	// Connection timeout, in seconds. Equals to 0 by default.
	// Format: seconds (seconds)
	// Example: 2
	SetConnectTimeout(Seconds) StreamPushSrt
	// Disable pushing the stream.
	// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
	// In this way, the URL and other settings of a disabled stream remain in Flussonic.
	Disabled() *bool
	// Disable pushing the stream.
	// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
	// In this way, the URL and other settings of a disabled stream remain in Flussonic.
	SetDisabled(bool) StreamPushSrt
	// Whether both connection parties must have the same password set (including empty, in other words, with no encryption).
	// If the passwords do not match or only one side is unencrypted, the connection is rejected.
	// The default value is `true`.
	// Example: true
	Enforcedencryption() *bool
	// Whether both connection parties must have the same password set (including empty, in other words, with no encryption).
	// If the passwords do not match or only one side is unencrypted, the connection is rejected.
	// The default value is `true`.
	// Example: true
	SetEnforcedencryption(bool) StreamPushSrt
	// The latency value for both directions of the socket.
	// By default initial value latency is 0 when transmitting and 120ms when receiving video.
	// Actual value established after connection handshake.
	// Increased value helps tolerate network losses and delays.
	// Format: milliseconds (milliseconds)
	// Example: 150
	Latency() *Milliseconds
	// The latency value for both directions of the socket.
	// By default initial value latency is 0 when transmitting and 120ms when receiving video.
	// Actual value established after connection handshake.
	// Increased value helps tolerate network losses and delays.
	// Format: milliseconds (milliseconds)
	// Example: 150
	SetLatency(Milliseconds) StreamPushSrt
	// The time, in seconds, that the socket waits for the unsent data before closing.
	// The default value is 180.
	// Format: seconds (seconds)
	// Example: 15
	Linger() *Seconds
	// The time, in seconds, that the socket waits for the unsent data before closing.
	// The default value is 180.
	// Format: seconds (seconds)
	// Example: 15
	SetLinger(Seconds) StreamPushSrt
	// The minimum SRT version that is required from the peer for SRT publication.
	// Pattern: ^[0-9]+\.[0-9]+\.[0-9]+$
	// Example: 1.1.0
	Minversion() *string
	// The minimum SRT version that is required from the peer for SRT publication.
	// Pattern: ^[0-9]+\.[0-9]+\.[0-9]+$
	// Example: 1.1.0
	SetMinversion(string) StreamPushSrt
	// It allows to specify pack information about ac3 for outgoing MPEGTS-TS streams. The default value is `system_b`.
	MpegtsAc3() *OutputMpegtsAc3
	// It allows to specify pack information about ac3 for outgoing MPEGTS-TS streams. The default value is `system_b`.
	SetMpegtsAc3(OutputMpegtsAc3) StreamPushSrt
	// Whether to capture multicast back to the *Flussonic* host.
	// This option allows you to ingest the sent stream on the sending host by *Flussonic* or other application.
	// Set to `True` for a UDP MPEG-TS push.
	// Example: true
	MulticastLoop() *bool
	// Whether to capture multicast back to the *Flussonic* host.
	// This option allows you to ingest the sent stream on the sending host by *Flussonic* or other application.
	// Set to `True` for a UDP MPEG-TS push.
	// Example: true
	SetMulticastLoop(bool) StreamPushSrt
	// The password for the encrypted transmission.
	// Its length should be not less than 10 and not more than 79 characters.
	// Unlike [password](https://flussonic.com/doc/api/reference/#tag/stream/operation/stream_save%7Cbody%7Cpassword),
	// the passphrase is not transmitted openly but is used to encrypt the key that is transmitted by the Caller
	// and decoded by Listener.
	// Example: 9876543210
	Passphrase() *string
	// The password for the encrypted transmission.
	// Its length should be not less than 10 and not more than 79 characters.
	// Unlike [password](https://flussonic.com/doc/api/reference/#tag/stream/operation/stream_save%7Cbody%7Cpassword),
	// the passphrase is not transmitted openly but is used to encrypt the key that is transmitted by the Caller
	// and decoded by Listener.
	// Example: 9876543210
	SetPassphrase(string) StreamPushSrt
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// It is possible to set PID values for PMT, STD and video and audio tracks.
	Pids() OutputMpegtsPids
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// It is possible to set PID values for PMT, STD and video and audio tracks.
	SetPids(OutputMpegtsPids) StreamPushSrt
	// Program number in the outgoing MPEG-TS stream. A program may represent a television channel.
	Pnr() *int
	// Program number in the outgoing MPEG-TS stream. A program may represent a television channel.
	SetPnr(int) StreamPushSrt
	// Provider name. Used to fill in the field service provider within SDT MPEG-TS table.
	// Example: My provider name
	Provider() *string
	// Provider name. Used to fill in the field service provider within SDT MPEG-TS table.
	// Example: My provider name
	SetProvider(string) StreamPushSrt
	// The maximum number of times *Flussonic* retries to push the stream.
	RetryLimit() *int
	// The maximum number of times *Flussonic* retries to push the stream.
	SetRetryLimit(int) StreamPushSrt
	// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
	// It is an interval in seconds, 5 seconds by default.
	// You can increase this value to reduce server load.
	// Format: seconds (seconds)
	// Example: 7
	RetryTimeout() *Seconds
	// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
	// It is an interval in seconds, 5 seconds by default.
	// You can increase this value to reduce server load.
	// Format: seconds (seconds)
	// Example: 7
	SetRetryTimeout(Seconds) StreamPushSrt
	// Service name. Used to fill in the field service name within SDT MPEG-TS table.
	// Example: My service name
	Service() *string
	// Service name. Used to fill in the field service name within SDT MPEG-TS table.
	// Example: My service name
	SetService(string) StreamPushSrt
	// Monitoring multicast group and stop pushing if another publisher presented
	Standby() *bool
	// Monitoring multicast group and stop pushing if another publisher presented
	SetStandby(bool) StreamPushSrt
	// Detailed runtime information about the push.
	Stats() PushCounters
	// Detailed runtime information about the push.
	SetStats(PushCounters) StreamPushSrt
	// A string of maximum 512 characters set on the socket before the connection.
	// This string is a part of a callback that is sent by the caller and regisered by the listener.
	// Based on this information the listener can accept or reject the connection, select the desired data stream, or set an appropriate passphrase for the connection.
	// Its format is `#!::` optionally followed by the parameters:
	// * `r=` - stream name
	// * `m=` - mode expected for the connection: `publish` (if the caller wants to send the stream data) or `request` (if the caller wants to receive the stream).
	// * `password=` - a password for the authorization in a publish session (not recommended, better use `passphrase` option instead)
	// During SRT sessions the following parameters are automaticly added to streamid:
	// * `s=` - the identifier of a session
	// * `a=` - Flussonic version
	// NOTE: you can specify a string in the format you need; to disable this extension, you need specify empty string.
	// Example: #!::r=my-stream,m=publish
	Streamid() *string
	// A string of maximum 512 characters set on the socket before the connection.
	// This string is a part of a callback that is sent by the caller and regisered by the listener.
	// Based on this information the listener can accept or reject the connection, select the desired data stream, or set an appropriate passphrase for the connection.
	// Its format is `#!::` optionally followed by the parameters:
	// * `r=` - stream name
	// * `m=` - mode expected for the connection: `publish` (if the caller wants to send the stream data) or `request` (if the caller wants to receive the stream).
	// * `password=` - a password for the authorization in a publish session (not recommended, better use `passphrase` option instead)
	// During SRT sessions the following parameters are automaticly added to streamid:
	// * `s=` - the identifier of a session
	// * `a=` - Flussonic version
	// NOTE: you can specify a string in the format you need; to disable this extension, you need specify empty string.
	// Example: #!::r=my-stream,m=publish
	SetStreamid(string) StreamPushSrt
	// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
	// Format: seconds (seconds)
	// Example: 10
	Timeout() *Seconds
	// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
	// Format: seconds (seconds)
	// Example: 10
	SetTimeout(Seconds) StreamPushSrt
	// SRT URL where to push video.
	// Format: input_url (input_url)
	// Pattern: ^srt[12]?://[^:]+:[0-9]+.*$
	// Examples: srt://my-server.com:8994
	URL() InputURL
	// SRT URL where to push video.
	// Format: input_url (input_url)
	// Pattern: ^srt[12]?://[^:]+:[0-9]+.*$
	// Examples: srt://my-server.com:8994
	SetURL(InputURL) StreamPushSrt
	// Average bitrate per second that you can send of a video track, including all the headers and encapsulation in the transport stream.
	// So, for example, the value of vb=2720 approximately corresponds to the bitrate 2600 specified in the transcoder settings.
	// Format: speed (speed)
	// Example: 2720
	Vb() *Speed
	// Average bitrate per second that you can send of a video track, including all the headers and encapsulation in the transport stream.
	// So, for example, the value of vb=2720 approximately corresponds to the bitrate 2600 specified in the transcoder settings.
	// Format: speed (speed)
	// Example: 2720
	SetVb(Speed) StreamPushSrt
	// Required SRT version.
	// Pattern: ^[0-9]+\.[0-9]+\.[0-9]+$
	// Example: 1.3.0
	Version() *string
	// Required SRT version.
	// Pattern: ^[0-9]+\.[0-9]+\.[0-9]+$
	// Example: 1.3.0
	SetVersion(string) StreamPushSrt
}

type StreamPushSt2110 interface {
	// Human-readable description of the pusher.
	// Example: This is a test push
	Comment() *string
	// Human-readable description of the pusher.
	// Example: This is a test push
	SetComment(string) StreamPushSt2110
	// Connection timeout, in seconds. Equals to 0 by default.
	// Format: seconds (seconds)
	// Example: 2
	ConnectTimeout() *Seconds
	// Connection timeout, in seconds. Equals to 0 by default.
	// Format: seconds (seconds)
	// Example: 2
	SetConnectTimeout(Seconds) StreamPushSt2110
	// Disable pushing the stream.
	// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
	// In this way, the URL and other settings of a disabled stream remain in Flussonic.
	Disabled() *bool
	// Disable pushing the stream.
	// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
	// In this way, the URL and other settings of a disabled stream remain in Flussonic.
	SetDisabled(bool) StreamPushSt2110
	// The maximum number of times *Flussonic* retries to push the stream.
	RetryLimit() *int
	// The maximum number of times *Flussonic* retries to push the stream.
	SetRetryLimit(int) StreamPushSt2110
	// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
	// It is an interval in seconds, 5 seconds by default.
	// You can increase this value to reduce server load.
	// Format: seconds (seconds)
	// Example: 7
	RetryTimeout() *Seconds
	// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
	// It is an interval in seconds, 5 seconds by default.
	// You can increase this value to reduce server load.
	// Format: seconds (seconds)
	// Example: 7
	SetRetryTimeout(Seconds) StreamPushSt2110
	// Detailed runtime information about the push.
	Stats() PushCounters
	// Detailed runtime information about the push.
	SetStats(PushCounters) StreamPushSt2110
	// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
	// Format: seconds (seconds)
	// Example: 10
	Timeout() *Seconds
	// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
	// Format: seconds (seconds)
	// Example: 10
	SetTimeout(Seconds) StreamPushSt2110
	// UDP URL of multicast group
	// Format: input_url (input_url)
	// Pattern: ^st2110?://([^@]+\@)?[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+:[0-9]+.*$
	// Examples: st2110://239.0.0.1:1234, st2110://239.0.0.1:1234/192.168.20.24, st2110://eth0@239.0.0.1:1234
	URL() InputURL
	// UDP URL of multicast group
	// Format: input_url (input_url)
	// Pattern: ^st2110?://([^@]+\@)?[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+:[0-9]+.*$
	// Examples: st2110://239.0.0.1:1234, st2110://239.0.0.1:1234/192.168.20.24, st2110://eth0@239.0.0.1:1234
	SetURL(InputURL) StreamPushSt2110
}

type StreamPushTshttp interface {
	// The bitrate of the whole stream.
	// Format: speed (speed)
	// Example: 3200
	Bitrate() *Speed
	// The bitrate of the whole stream.
	// Format: speed (speed)
	// Example: 3200
	SetBitrate(Speed) StreamPushTshttp
	// Human-readable description of the pusher.
	// Example: This is a test push
	Comment() *string
	// Human-readable description of the pusher.
	// Example: This is a test push
	SetComment(string) StreamPushTshttp
	// Connection timeout, in seconds. Equals to 0 by default.
	// Format: seconds (seconds)
	// Example: 2
	ConnectTimeout() *Seconds
	// Connection timeout, in seconds. Equals to 0 by default.
	// Format: seconds (seconds)
	// Example: 2
	SetConnectTimeout(Seconds) StreamPushTshttp
	// Disable pushing the stream.
	// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
	// In this way, the URL and other settings of a disabled stream remain in Flussonic.
	Disabled() *bool
	// Disable pushing the stream.
	// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
	// In this way, the URL and other settings of a disabled stream remain in Flussonic.
	SetDisabled(bool) StreamPushTshttp
	// It allows to specify pack information about ac3 for outgoing MPEGTS-TS streams. The default value is `system_b`.
	MpegtsAc3() *OutputMpegtsAc3
	// It allows to specify pack information about ac3 for outgoing MPEGTS-TS streams. The default value is `system_b`.
	SetMpegtsAc3(OutputMpegtsAc3) StreamPushTshttp
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// It is possible to set PID values for PMT, STD and video and audio tracks.
	Pids() OutputMpegtsPids
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// It is possible to set PID values for PMT, STD and video and audio tracks.
	SetPids(OutputMpegtsPids) StreamPushTshttp
	// Program number in the outgoing MPEG-TS stream. A program may represent a television channel.
	Pnr() *int
	// Program number in the outgoing MPEG-TS stream. A program may represent a television channel.
	SetPnr(int) StreamPushTshttp
	// Provider name. Used to fill in the field service provider within SDT MPEG-TS table.
	// Example: My provider name
	Provider() *string
	// Provider name. Used to fill in the field service provider within SDT MPEG-TS table.
	// Example: My provider name
	SetProvider(string) StreamPushTshttp
	// The maximum number of times *Flussonic* retries to push the stream.
	RetryLimit() *int
	// The maximum number of times *Flussonic* retries to push the stream.
	SetRetryLimit(int) StreamPushTshttp
	// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
	// It is an interval in seconds, 5 seconds by default.
	// You can increase this value to reduce server load.
	// Format: seconds (seconds)
	// Example: 7
	RetryTimeout() *Seconds
	// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
	// It is an interval in seconds, 5 seconds by default.
	// You can increase this value to reduce server load.
	// Format: seconds (seconds)
	// Example: 7
	SetRetryTimeout(Seconds) StreamPushTshttp
	// Service name. Used to fill in the field service name within SDT MPEG-TS table.
	// Example: My service name
	Service() *string
	// Service name. Used to fill in the field service name within SDT MPEG-TS table.
	// Example: My service name
	SetService(string) StreamPushTshttp
	// Detailed runtime information about the push.
	Stats() PushCounters
	// Detailed runtime information about the push.
	SetStats(PushCounters) StreamPushTshttp
	// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
	// Format: seconds (seconds)
	// Example: 10
	Timeout() *Seconds
	// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
	// Format: seconds (seconds)
	// Example: 10
	SetTimeout(Seconds) StreamPushTshttp
	// Content will be similar to multicast MPEG-TS, but endless HTTP POST will be used to upload content.
	// Format: input_url (input_url)
	// Pattern: ^tshttps?://.*$
	// Examples: tshttp://your-server.com/app/stream1, tshttps://your-server.com/app/stream1
	URL() InputURL
	// Content will be similar to multicast MPEG-TS, but endless HTTP POST will be used to upload content.
	// Format: input_url (input_url)
	// Pattern: ^tshttps?://.*$
	// Examples: tshttp://your-server.com/app/stream1, tshttps://your-server.com/app/stream1
	SetURL(InputURL) StreamPushTshttp
	// Average bitrate per second that you can send of a video track, including all the headers and encapsulation in the transport stream.
	// So, for example, the value of vb=2720 approximately corresponds to the bitrate 2600 specified in the transcoder settings.
	// Format: speed (speed)
	// Example: 2720
	Vb() *Speed
	// Average bitrate per second that you can send of a video track, including all the headers and encapsulation in the transport stream.
	// So, for example, the value of vb=2720 approximately corresponds to the bitrate 2600 specified in the transcoder settings.
	// Format: speed (speed)
	// Example: 2720
	SetVb(Speed) StreamPushTshttp
}

type StreamPushUDP interface {
	// The bitrate of the whole stream.
	// Format: speed (speed)
	// Example: 3200
	Bitrate() *Speed
	// The bitrate of the whole stream.
	// Format: speed (speed)
	// Example: 3200
	SetBitrate(Speed) StreamPushUDP
	// Human-readable description of the pusher.
	// Example: This is a test push
	Comment() *string
	// Human-readable description of the pusher.
	// Example: This is a test push
	SetComment(string) StreamPushUDP
	// Connection timeout, in seconds. Equals to 0 by default.
	// Format: seconds (seconds)
	// Example: 2
	ConnectTimeout() *Seconds
	// Connection timeout, in seconds. Equals to 0 by default.
	// Format: seconds (seconds)
	// Example: 2
	SetConnectTimeout(Seconds) StreamPushUDP
	// Disable pushing the stream.
	// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
	// In this way, the URL and other settings of a disabled stream remain in Flussonic.
	Disabled() *bool
	// Disable pushing the stream.
	// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
	// In this way, the URL and other settings of a disabled stream remain in Flussonic.
	SetDisabled(bool) StreamPushUDP
	// It allows to specify pack information about ac3 for outgoing MPEGTS-TS streams. The default value is `system_b`.
	MpegtsAc3() *OutputMpegtsAc3
	// It allows to specify pack information about ac3 for outgoing MPEGTS-TS streams. The default value is `system_b`.
	SetMpegtsAc3(OutputMpegtsAc3) StreamPushUDP
	// Whether to capture multicast back to the *Flussonic* host.
	// This option allows you to ingest the sent stream on the sending host by *Flussonic* or other application.
	// Set to `True` for a UDP MPEG-TS push.
	// Example: true
	MulticastLoop() *bool
	// Whether to capture multicast back to the *Flussonic* host.
	// This option allows you to ingest the sent stream on the sending host by *Flussonic* or other application.
	// Set to `True` for a UDP MPEG-TS push.
	// Example: true
	SetMulticastLoop(bool) StreamPushUDP
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// It is possible to set PID values for PMT, STD and video and audio tracks.
	Pids() OutputMpegtsPids
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// It is possible to set PID values for PMT, STD and video and audio tracks.
	SetPids(OutputMpegtsPids) StreamPushUDP
	// Program number in the outgoing MPEG-TS stream. A program may represent a television channel.
	Pnr() *int
	// Program number in the outgoing MPEG-TS stream. A program may represent a television channel.
	SetPnr(int) StreamPushUDP
	// Provider name. Used to fill in the field service provider within SDT MPEG-TS table.
	// Example: My provider name
	Provider() *string
	// Provider name. Used to fill in the field service provider within SDT MPEG-TS table.
	// Example: My provider name
	SetProvider(string) StreamPushUDP
	// The maximum number of times *Flussonic* retries to push the stream.
	RetryLimit() *int
	// The maximum number of times *Flussonic* retries to push the stream.
	SetRetryLimit(int) StreamPushUDP
	// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
	// It is an interval in seconds, 5 seconds by default.
	// You can increase this value to reduce server load.
	// Format: seconds (seconds)
	// Example: 7
	RetryTimeout() *Seconds
	// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
	// It is an interval in seconds, 5 seconds by default.
	// You can increase this value to reduce server load.
	// Format: seconds (seconds)
	// Example: 7
	SetRetryTimeout(Seconds) StreamPushUDP
	// Service name. Used to fill in the field service name within SDT MPEG-TS table.
	// Example: My service name
	Service() *string
	// Service name. Used to fill in the field service name within SDT MPEG-TS table.
	// Example: My service name
	SetService(string) StreamPushUDP
	// Monitoring multicast group and stop pushing if another publisher presented
	Standby() *bool
	// Monitoring multicast group and stop pushing if another publisher presented
	SetStandby(bool) StreamPushUDP
	// Detailed runtime information about the push.
	Stats() PushCounters
	// Detailed runtime information about the push.
	SetStats(PushCounters) StreamPushUDP
	// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
	// Format: seconds (seconds)
	// Example: 10
	Timeout() *Seconds
	// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
	// Format: seconds (seconds)
	// Example: 10
	SetTimeout(Seconds) StreamPushUDP
	// UDP URL of multicast group
	// Format: input_url (input_url)
	// Pattern: ^udp[12]?://([^@]+\@)?[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+:[0-9]+.*$
	// Examples: udp://239.0.0.1:1234, udp://239.0.0.1:1234/192.168.20.24, udp://eth0@239.0.0.1:1234
	URL() InputURL
	// UDP URL of multicast group
	// Format: input_url (input_url)
	// Pattern: ^udp[12]?://([^@]+\@)?[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+:[0-9]+.*$
	// Examples: udp://239.0.0.1:1234, udp://239.0.0.1:1234/192.168.20.24, udp://eth0@239.0.0.1:1234
	SetURL(InputURL) StreamPushUDP
	// Average bitrate per second that you can send of a video track, including all the headers and encapsulation in the transport stream.
	// So, for example, the value of vb=2720 approximately corresponds to the bitrate 2600 specified in the transcoder settings.
	// Format: speed (speed)
	// Example: 2720
	Vb() *Speed
	// Average bitrate per second that you can send of a video track, including all the headers and encapsulation in the transport stream.
	// So, for example, the value of vb=2720 approximately corresponds to the bitrate 2600 specified in the transcoder settings.
	// Format: speed (speed)
	// Example: 2720
	SetVb(Speed) StreamPushUDP
}

type StreamPushUDPBase interface {
	// Whether to capture multicast back to the *Flussonic* host.
	// This option allows you to ingest the sent stream on the sending host by *Flussonic* or other application.
	// Set to `True` for a UDP MPEG-TS push.
	// Example: true
	MulticastLoop() *bool
	// Whether to capture multicast back to the *Flussonic* host.
	// This option allows you to ingest the sent stream on the sending host by *Flussonic* or other application.
	// Set to `True` for a UDP MPEG-TS push.
	// Example: true
	SetMulticastLoop(bool) StreamPushUDPBase
	// Monitoring multicast group and stop pushing if another publisher presented
	Standby() *bool
	// Monitoring multicast group and stop pushing if another publisher presented
	SetStandby(bool) StreamPushUDPBase
}

type StreamStats interface {
	// The status of the Agent serving the stream.
	AgentStatus() *string
	// The status of the Agent serving the stream.
	SetAgentStatus(string) StreamStats
	// Becomes `false` when `ts_delay` > 12000 (= 12 seconds)
	// Example: true
	Alive() *bool
	// Becomes `false` when `ts_delay` > 12000 (= 12 seconds)
	// Example: true
	SetAlive(bool) StreamStats
	// Stream bitrate.
	// Format: speed (speed)
	// Example: 186
	Bitrate() *Speed
	// Stream bitrate.
	// Format: speed (speed)
	// Example: 186
	SetBitrate(Speed) StreamStats
	// The amount of stream data sent to the clients.
	// Format: bytes (bytes)
	// Example: 0
	BytesOut() *Bytes
	// The amount of stream data sent to the clients.
	// Format: bytes (bytes)
	// Example: 0
	SetBytesOut(Bytes) StreamStats
	// The identifier of the Agent that is currently serving the stream.
	// Format: agent_id (agent_id)
	CurrentAgentID() *AgentID
	// The identifier of the Agent that is currently serving the stream.
	// Format: agent_id (agent_id)
	SetCurrentAgentID(AgentID) StreamStats
	// The information about the recorded DVR archive.
	DvrInfo() DvrInfo
	// The information about the recorded DVR archive.
	SetDvrInfo(DvrInfo) StreamStats
	// The ratio of the total duration of episodes to the total observation time.
	// A value between 0 and 1 indicating the proportion of time occupied by episodes.
	// For example, 0.75 means that 75% of the time (or 2700 seconds out of 3600) is covered by episodes.
	// Format: float (float)
	// Example: 0.001
	EpisodesDensity() *Float
	// The ratio of the total duration of episodes to the total observation time.
	// A value between 0 and 1 indicating the proportion of time occupied by episodes.
	// For example, 0.75 means that 75% of the time (or 2700 seconds out of 3600) is covered by episodes.
	// Format: float (float)
	// Example: 0.001
	SetEpisodesDensity(Float) StreamStats
	// The time when the last time frame was sent to the stream output (in UTC).
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.636383841974e+12
	LastDtsAt() *UtcMs
	// The time when the last time frame was sent to the stream output (in UTC).
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.636383841974e+12
	SetLastDtsAt(UtcMs) StreamStats
	// The last time when the stream was running.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.737975543123e+12
	LastRunningAt() *UtcMs
	// The last time when the stream was running.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.737975543123e+12
	SetLastRunningAt(UtcMs) StreamStats
	// The time period in seconds during which the stream is being captured.
	// Can be calculated from `opened_at`
	// Format: milliseconds (milliseconds)
	// Example: 71977
	Lifetime() *Milliseconds
	// The time period in seconds during which the stream is being captured.
	// Can be calculated from `opened_at`
	// Format: milliseconds (milliseconds)
	// Example: 71977
	SetLifetime(Milliseconds) StreamStats
	// Technical information about the output media content.
	MediaInfo() MediaInfo
	// Technical information about the output media content.
	SetMediaInfo(MediaInfo) StreamStats
	// Deprecated field. Will be deleted at 25.04
	// The number of clients receiving the stream.
	// Use play.play_opened_sessions instead
	// Format: client_count (client_count)
	// Example: 3
	OnlineClients() *ClientCount
	// Deprecated field. Will be deleted at 25.04
	// The number of clients receiving the stream.
	// Use play.play_opened_sessions instead
	// Format: client_count (client_count)
	// Example: 3
	SetOnlineClients(ClientCount) StreamStats
	// List of servers hostnames where the stream is running on.
	// Example: [streamer1.example.com]
	RunningOn() []ServerName
	// List of servers hostnames where the stream is running on.
	// Example: [streamer1.example.com]
	SetRunningOn([]ServerName) StreamStats
	// Indicates the status of the stream.
	Status() *StreamStatus
	// Indicates the status of the stream.
	SetStatus(StreamStatus) StreamStats
	// HTTP(s) URL that can be used for streaming API of this stream
	StreamingEndpoint() *string
	// HTTP(s) URL that can be used for streaming API of this stream
	SetStreamingEndpoint(string) StreamStats
	// The time period during which no frames were received from the stream's input.
	// Format: ticks (ticks)
	// Example: 1284
	TSDelay() *Ticks
	// The time period during which no frames were received from the stream's input.
	// Format: ticks (ticks)
	// Example: 1284
	SetTSDelay(Ticks) StreamStats
}

type StreamerConfig interface {
	// The URL for provisioning of configuration from the managing server to the streamer.
	// This URL does not have to be public but must be accessible from the managing server.
	// The API URL can also be used as Public and/or Private payload URL if they are not set.
	// When used as Public payload URL, the API URL shall be public to allow playback from this streamer.
	// Format: url (url)
	// Example: http://streamer.local:8080
	APIURL() *URL
	// The URL for provisioning of configuration from the managing server to the streamer.
	// This URL does not have to be public but must be accessible from the managing server.
	// The API URL can also be used as Public and/or Private payload URL if they are not set.
	// When used as Public payload URL, the API URL shall be public to allow playback from this streamer.
	// Format: url (url)
	// Example: http://streamer.local:8080
	SetAPIURL(URL) StreamerConfig
	// Maximal number of streams.
	// Example: 5
	ChannelLimit() *int
	// Maximal number of streams.
	// Example: 5
	SetChannelLimit(int) StreamerConfig
	// The key for authorization for inter-Flussonic connections.
	// All cluster peers should have the same cluster key.
	// Example: xS6i6Q3DCc5nEvnu
	ClusterKey() *string
	// The key for authorization for inter-Flussonic connections.
	// All cluster peers should have the same cluster key.
	// Example: xS6i6Q3DCc5nEvnu
	SetClusterKey(string) StreamerConfig
	// Flussonic Media Server configuration which will be provided to Streamer
	Config() CentralStreamerNodeConfig
	// Flussonic Media Server configuration which will be provided to Streamer
	SetConfig(CentralStreamerNodeConfig) StreamerConfig
	// CPU limit in percents.
	// Format: percent (percent)
	// Example: 10
	CpuLimit() *Percent
	// CPU limit in percents.
	// Format: percent (percent)
	// Example: 10
	SetCpuLimit(Percent) StreamerConfig
	// The configuration of the DVRs
	Dvrs() []DvrConfig
	// The configuration of the DVRs
	SetDvrs([]DvrConfig) StreamerConfig
	// How often the peer will try to get the data from the remote server via internal API.
	// Format: milliseconds (milliseconds)
	// Example: 1000
	FetchTimeout() *Milliseconds
	// How often the peer will try to get the data from the remote server via internal API.
	// Format: milliseconds (milliseconds)
	// Example: 1000
	SetFetchTimeout(Milliseconds) StreamerConfig
	// Streamer's identifier in the cluster.
	// The managing server may try using this hostname to access the streamer
	// if API URL is not specified.
	// Format: server_name (server_name)
	// Example: peer.example.com
	Hostname() *ServerName
	// Streamer's identifier in the cluster.
	// The managing server may try using this hostname to access the streamer
	// if API URL is not specified.
	// Format: server_name (server_name)
	// Example: peer.example.com
	SetHostname(ServerName) StreamerConfig
	// Flag indicating the Streamer's ability to act as a restreamer.
	// See [dynamic_streams_list](https://flussonic.com/doc/api/config-external/#tag/stream/operation/dynamic_streams_list)
	// operation for more info
	IsRestreamer() *bool
	// Flag indicating the Streamer's ability to act as a restreamer.
	// See [dynamic_streams_list](https://flussonic.com/doc/api/config-external/#tag/stream/operation/dynamic_streams_list)
	// operation for more info
	SetIsRestreamer(bool) StreamerConfig
	Labels() map[string]UnixName
	SetLabels(map[string]UnixName) StreamerConfig
	// Deprecated field. Will be deleted at 23.09
	// Maximal output bitrate of the peer.
	// Format: speed (speed)
	MaxBitrate() *Speed
	// Deprecated field. Will be deleted at 23.09
	// Maximal output bitrate of the peer.
	// Format: speed (speed)
	SetMaxBitrate(Speed) StreamerConfig
	// Streamer's logical namespace, used for interacting with streams of the same namespace. By default, a streamer has no assigned namespace. In this default state, it can interact with streams that also have no assigned namespace. If a namespace is explicitly set, the streamer will only interact with streams possessing that specific namespace.
	// For example, the layouter will distribute streams only to streamers with the same namespace. The `dynamic_streams_list` endpoint will operate exclusively within a single namespace.
	// ***Use case:***
	// Namespaces provide strict, system-wide resource isolation, fundamentally separating streams and streamers into independent segments. This ensures no interaction, archive access, inference processing, or layout operations occur between different namespaces.
	// Unlike labels, which offer flexible, attribute-based layout control within a namespace, namespaces define an absolute boundary: resources from one namespace cannot interact with resources from another.
	// ***Important:***
	// A namespace can only be assigned when the streamer is created and cannot be changed afterwards.
	// Format: unix_name (Contains only alphanumeric characters (a-z, A-Z, 0-9), underscores (_), hyphens (-) and periods (.).)
	// Pattern: ^[a-zA-Z0-9_.-]+$
	// Example: example
	Namespace() *UnixName
	// Streamer's logical namespace, used for interacting with streams of the same namespace. By default, a streamer has no assigned namespace. In this default state, it can interact with streams that also have no assigned namespace. If a namespace is explicitly set, the streamer will only interact with streams possessing that specific namespace.
	// For example, the layouter will distribute streams only to streamers with the same namespace. The `dynamic_streams_list` endpoint will operate exclusively within a single namespace.
	// ***Use case:***
	// Namespaces provide strict, system-wide resource isolation, fundamentally separating streams and streamers into independent segments. This ensures no interaction, archive access, inference processing, or layout operations occur between different namespaces.
	// Unlike labels, which offer flexible, attribute-based layout control within a namespace, namespaces define an absolute boundary: resources from one namespace cannot interact with resources from another.
	// ***Important:***
	// A namespace can only be assigned when the streamer is created and cannot be changed afterwards.
	// Format: unix_name (Contains only alphanumeric characters (a-z, A-Z, 0-9), underscores (_), hyphens (-) and periods (.).)
	// Pattern: ^[a-zA-Z0-9_.-]+$
	// Example: example
	SetNamespace(UnixName) StreamerConfig
	// The internal address for communication in a local network (by default, it is equal to API URL).
	// Format: url (url)
	// Example: http://streamer.local
	PrivatePayloadURL() *URL
	// The internal address for communication in a local network (by default, it is equal to API URL).
	// Format: url (url)
	// Example: http://streamer.local
	SetPrivatePayloadURL(URL) StreamerConfig
	// The public address that is exposed to clients. It can also contain a port number.
	// The client will be redirected to this URL and port when requesting for the stream captured on the peer
	// even if other `http` port is set in the peer's own config.
	// Format: url (url)
	// Example: http://public.example.com
	PublicPayloadURL() *URL
	// The public address that is exposed to clients. It can also contain a port number.
	// The client will be redirected to this URL and port when requesting for the stream captured on the peer
	// even if other `http` port is set in the peer's own config.
	// Format: url (url)
	// Example: http://public.example.com
	SetPublicPayloadURL(URL) StreamerConfig
	// Role of node
	Role() *CentralNodeRoleRole
	// Role of node
	SetRole(CentralNodeRoleRole) StreamerConfig
	// The time after which deleted streams on this server are considered to be inactive
	// and cannot be used in the `cluster_ingest` mechanism.
	// Format: milliseconds (milliseconds)
	// Example: 1000
	StaleTimeout() *Milliseconds
	// The time after which deleted streams on this server are considered to be inactive
	// and cannot be used in the `cluster_ingest` mechanism.
	// Format: milliseconds (milliseconds)
	// Example: 1000
	SetStaleTimeout(Milliseconds) StreamerConfig
	// Statistics on peers in the cluster.
	Stats() PeerStats
	// Statistics on peers in the cluster.
	SetStats(PeerStats) StreamerConfig
	// Server network bandwidth limit in kbit.
	// This value is used to calculate the current network load status.
	// Format: speed (speed)
	// Example: 1024
	TotalBandwidth() *Speed
	// Server network bandwidth limit in kbit.
	// This value is used to calculate the current network load status.
	// Format: speed (speed)
	// Example: 1024
	SetTotalBandwidth(Speed) StreamerConfig
}

type StreamersList interface {
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	EstimatedCount() *int
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	SetEstimatedCount(int) StreamersList
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	Next() *string
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	SetNext(string) StreamersList
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	Prev() *string
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	SetPrev(string) StreamersList
	// The list of streamers fetched according to the query parameters.
	Streamers() []StreamerConfig
	// The list of streamers fetched according to the query parameters.
	SetStreamers([]StreamerConfig) StreamersList
	// An object with a list of different timings measured during this API call.
	Timing() any
	// An object with a list of different timings measured during this API call.
	SetTiming(any) StreamersList
	// Collection returns the collection items
	Collection() []StreamerConfig
}

type StreamsList interface {
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	EstimatedCount() *int
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	SetEstimatedCount(int) StreamsList
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	Next() *string
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	SetNext(string) StreamsList
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	Prev() *string
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	SetPrev(string) StreamsList
	// List of fetched streams according to the query parameters.
	Streams() []StreamConfig
	// List of fetched streams according to the query parameters.
	SetStreams([]StreamConfig) StreamsList
	// An object with a list of different timings measured during this API call.
	Timing() any
	// An object with a list of different timings measured during this API call.
	SetTiming(any) StreamsList
	// Time of last configuration updated in ms.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.727274724e+12
	UpdatedAt() *UtcMs
	// Time of last configuration updated in ms.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.727274724e+12
	SetUpdatedAt(UtcMs) StreamsList
	// Collection returns the collection items
	Collection() []StreamConfig
}

type TcAudioAac interface {
	// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
	// If it is just an integer or a float, the output audio volume is calculated by this formula:
	// `output_volume = avol * input_volume`
	// If specified in decibels (dB), the output audio volume is calculated as follows:
	// `output_volume = input_volume +/- avol`
	// depending whether it is a positive (+9dB) or a negative value (-6dB).
	// By default it equals to 1 (the input audio volume).
	// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
	// Example: -6dB
	Avol() *string
	// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
	// If it is just an integer or a float, the output audio volume is calculated by this formula:
	// `output_volume = avol * input_volume`
	// If specified in decibels (dB), the output audio volume is calculated as follows:
	// `output_volume = input_volume +/- avol`
	// depending whether it is a positive (+9dB) or a negative value (-6dB).
	// By default it equals to 1 (the input audio volume).
	// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
	// Example: -6dB
	SetAvol(string) TcAudioAac
	// Audio bitrate. The allowed values are:
	// * `copy` - the bitrate or the original stream is copied to the outgoing stream.
	// * a full number of bits (e.g., 64000) or a short form of the number with `k` (e.g., 64k).
	// Example: 64000
	Bitrate() *TcBitrate
	// Audio bitrate. The allowed values are:
	// * `copy` - the bitrate or the original stream is copied to the outgoing stream.
	// * a full number of bits (e.g., 64000) or a short form of the number with `k` (e.g., 64k).
	// Example: 64000
	SetBitrate(*TcBitrate) TcAudioAac
	// The number of audio channels in an output stream.
	// Example: 2
	Channels() *TiAudioAacSpecChannels
	// The number of audio channels in an output stream.
	// Example: 2
	SetChannels(TiAudioAacSpecChannels) TcAudioAac
	// Audio codec (the AAC codec is used by default).
	// Example: opus
	Codec() *string
	// Audio codec (the AAC codec is used by default).
	// Example: opus
	SetCodec(string) TcAudioAac
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// The allowed values are:
	// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
	// Example: 48000
	SampleRate() *TiAudioAacSpecSampleRate
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// The allowed values are:
	// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
	// Example: 48000
	SetSampleRate(TiAudioAacSpecSampleRate) TcAudioAac
	// This option allows to split each audio track with multiple channels into several mono tracks.
	SplitChannels() *bool
	// This option allows to split each audio track with multiple channels into several mono tracks.
	SetSplitChannels(bool) TcAudioAac
}

type TcAudioAc3 interface {
	// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
	// If it is just an integer or a float, the output audio volume is calculated by this formula:
	// `output_volume = avol * input_volume`
	// If specified in decibels (dB), the output audio volume is calculated as follows:
	// `output_volume = input_volume +/- avol`
	// depending whether it is a positive (+9dB) or a negative value (-6dB).
	// By default it equals to 1 (the input audio volume).
	// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
	// Example: -6dB
	Avol() *string
	// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
	// If it is just an integer or a float, the output audio volume is calculated by this formula:
	// `output_volume = avol * input_volume`
	// If specified in decibels (dB), the output audio volume is calculated as follows:
	// `output_volume = input_volume +/- avol`
	// depending whether it is a positive (+9dB) or a negative value (-6dB).
	// By default it equals to 1 (the input audio volume).
	// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
	// Example: -6dB
	SetAvol(string) TcAudioAc3
	// Audio bitrate. The allowed values are:
	// * `copy` - the bitrate or the original stream is copied to the outgoing stream.
	// * a full number of bits (e.g., 64000) or a short form of the number with `k` (e.g., 64k).
	// Example: 64000
	Bitrate() *TcBitrate
	// Audio bitrate. The allowed values are:
	// * `copy` - the bitrate or the original stream is copied to the outgoing stream.
	// * a full number of bits (e.g., 64000) or a short form of the number with `k` (e.g., 64k).
	// Example: 64000
	SetBitrate(*TcBitrate) TcAudioAc3
	// The number of audio channels in an output stream.
	// Example: 2
	Channels() *TiAudioAc3SpecChannels
	// The number of audio channels in an output stream.
	// Example: 2
	SetChannels(TiAudioAc3SpecChannels) TcAudioAc3
	// Audio codec (the AAC codec is used by default).
	// Example: opus
	Codec() *string
	// Audio codec (the AAC codec is used by default).
	// Example: opus
	SetCodec(string) TcAudioAc3
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// The allowed values are:
	// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
	// Example: 48000
	SampleRate() *TiAudioAc3SpecSampleRate
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// The allowed values are:
	// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
	// Example: 48000
	SetSampleRate(TiAudioAc3SpecSampleRate) TcAudioAc3
	// This option allows to split each audio track with multiple channels into several mono tracks.
	SplitChannels() *bool
	// This option allows to split each audio track with multiple channels into several mono tracks.
	SetSplitChannels(bool) TcAudioAc3
}

type TcAudioBase interface {
	// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
	// If it is just an integer or a float, the output audio volume is calculated by this formula:
	// `output_volume = avol * input_volume`
	// If specified in decibels (dB), the output audio volume is calculated as follows:
	// `output_volume = input_volume +/- avol`
	// depending whether it is a positive (+9dB) or a negative value (-6dB).
	// By default it equals to 1 (the input audio volume).
	// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
	// Example: -6dB
	Avol() *string
	// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
	// If it is just an integer or a float, the output audio volume is calculated by this formula:
	// `output_volume = avol * input_volume`
	// If specified in decibels (dB), the output audio volume is calculated as follows:
	// `output_volume = input_volume +/- avol`
	// depending whether it is a positive (+9dB) or a negative value (-6dB).
	// By default it equals to 1 (the input audio volume).
	// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
	// Example: -6dB
	SetAvol(string) TcAudioBase
	// Audio bitrate. The allowed values are:
	// * `copy` - the bitrate or the original stream is copied to the outgoing stream.
	// * a full number of bits (e.g., 64000) or a short form of the number with `k` (e.g., 64k).
	// Example: 64000
	Bitrate() *TcBitrate
	// Audio bitrate. The allowed values are:
	// * `copy` - the bitrate or the original stream is copied to the outgoing stream.
	// * a full number of bits (e.g., 64000) or a short form of the number with `k` (e.g., 64k).
	// Example: 64000
	SetBitrate(*TcBitrate) TcAudioBase
	// Audio codec (the AAC codec is used by default).
	// Example: opus
	Codec() *string
	// Audio codec (the AAC codec is used by default).
	// Example: opus
	SetCodec(string) TcAudioBase
	// This option allows to split each audio track with multiple channels into several mono tracks.
	SplitChannels() *bool
	// This option allows to split each audio track with multiple channels into several mono tracks.
	SetSplitChannels(bool) TcAudioBase
}

type TcAudioMp2a interface {
	// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
	// If it is just an integer or a float, the output audio volume is calculated by this formula:
	// `output_volume = avol * input_volume`
	// If specified in decibels (dB), the output audio volume is calculated as follows:
	// `output_volume = input_volume +/- avol`
	// depending whether it is a positive (+9dB) or a negative value (-6dB).
	// By default it equals to 1 (the input audio volume).
	// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
	// Example: -6dB
	Avol() *string
	// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
	// If it is just an integer or a float, the output audio volume is calculated by this formula:
	// `output_volume = avol * input_volume`
	// If specified in decibels (dB), the output audio volume is calculated as follows:
	// `output_volume = input_volume +/- avol`
	// depending whether it is a positive (+9dB) or a negative value (-6dB).
	// By default it equals to 1 (the input audio volume).
	// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
	// Example: -6dB
	SetAvol(string) TcAudioMp2a
	// Audio bitrate. The allowed values are:
	// * `copy` - the bitrate or the original stream is copied to the outgoing stream.
	// * a full number of bits (e.g., 64000) or a short form of the number with `k` (e.g., 64k).
	// Example: 64000
	Bitrate() *TcBitrate
	// Audio bitrate. The allowed values are:
	// * `copy` - the bitrate or the original stream is copied to the outgoing stream.
	// * a full number of bits (e.g., 64000) or a short form of the number with `k` (e.g., 64k).
	// Example: 64000
	SetBitrate(*TcBitrate) TcAudioMp2a
	// The number of audio channels in an output stream.
	// Example: 2
	Channels() *TiAudioMp2aSpecChannels
	// The number of audio channels in an output stream.
	// Example: 2
	SetChannels(TiAudioMp2aSpecChannels) TcAudioMp2a
	// Audio codec (the AAC codec is used by default).
	// Example: opus
	Codec() *string
	// Audio codec (the AAC codec is used by default).
	// Example: opus
	SetCodec(string) TcAudioMp2a
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// The allowed values are:
	// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
	// Example: 48000
	SampleRate() *TiAudioMp2aSpecSampleRate
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// The allowed values are:
	// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
	// Example: 48000
	SetSampleRate(TiAudioMp2aSpecSampleRate) TcAudioMp2a
	// This option allows to split each audio track with multiple channels into several mono tracks.
	SplitChannels() *bool
	// This option allows to split each audio track with multiple channels into several mono tracks.
	SetSplitChannels(bool) TcAudioMp2a
}

type TcAudioMp3 interface {
	// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
	// If it is just an integer or a float, the output audio volume is calculated by this formula:
	// `output_volume = avol * input_volume`
	// If specified in decibels (dB), the output audio volume is calculated as follows:
	// `output_volume = input_volume +/- avol`
	// depending whether it is a positive (+9dB) or a negative value (-6dB).
	// By default it equals to 1 (the input audio volume).
	// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
	// Example: -6dB
	Avol() *string
	// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
	// If it is just an integer or a float, the output audio volume is calculated by this formula:
	// `output_volume = avol * input_volume`
	// If specified in decibels (dB), the output audio volume is calculated as follows:
	// `output_volume = input_volume +/- avol`
	// depending whether it is a positive (+9dB) or a negative value (-6dB).
	// By default it equals to 1 (the input audio volume).
	// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
	// Example: -6dB
	SetAvol(string) TcAudioMp3
	// Audio bitrate. The allowed values are:
	// * `copy` - the bitrate or the original stream is copied to the outgoing stream.
	// * a full number of bits (e.g., 64000) or a short form of the number with `k` (e.g., 64k).
	// Example: 64000
	Bitrate() *TcBitrate
	// Audio bitrate. The allowed values are:
	// * `copy` - the bitrate or the original stream is copied to the outgoing stream.
	// * a full number of bits (e.g., 64000) or a short form of the number with `k` (e.g., 64k).
	// Example: 64000
	SetBitrate(*TcBitrate) TcAudioMp3
	// The number of audio channels in an output stream.
	// Example: 2
	Channels() *TiAudioMp3SpecChannels
	// The number of audio channels in an output stream.
	// Example: 2
	SetChannels(TiAudioMp3SpecChannels) TcAudioMp3
	// Audio codec (the AAC codec is used by default).
	// Example: opus
	Codec() *string
	// Audio codec (the AAC codec is used by default).
	// Example: opus
	SetCodec(string) TcAudioMp3
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// The allowed values are:
	// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
	// Example: 8000
	SampleRate() *TiAudioMp3SpecSampleRate
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// The allowed values are:
	// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
	// Example: 8000
	SetSampleRate(TiAudioMp3SpecSampleRate) TcAudioMp3
	// This option allows to split each audio track with multiple channels into several mono tracks.
	SplitChannels() *bool
	// This option allows to split each audio track with multiple channels into several mono tracks.
	SetSplitChannels(bool) TcAudioMp3
}

type TcAudioOpts interface {
	// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
	// If it is just an integer or a float, the output audio volume is calculated by this formula:
	// `output_volume = avol * input_volume`
	// If specified in decibels (dB), the output audio volume is calculated as follows:
	// `output_volume = input_volume +/- avol`
	// depending whether it is a positive (+9dB) or a negative value (-6dB).
	// By default it equals to 1 (the input audio volume).
	// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
	// Example: -6dB
	Avol() *string
	// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
	// If it is just an integer or a float, the output audio volume is calculated by this formula:
	// `output_volume = avol * input_volume`
	// If specified in decibels (dB), the output audio volume is calculated as follows:
	// `output_volume = input_volume +/- avol`
	// depending whether it is a positive (+9dB) or a negative value (-6dB).
	// By default it equals to 1 (the input audio volume).
	// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
	// Example: -6dB
	SetAvol(string) TcAudioOpts
	// Audio bitrate. The allowed values are:
	// * `copy` - the bitrate or the original stream is copied to the outgoing stream.
	// * a full number of bits (e.g., 64000) or a short form of the number with `k` (e.g., 64k).
	// Example: 64000
	Bitrate() *TcBitrate
	// Audio bitrate. The allowed values are:
	// * `copy` - the bitrate or the original stream is copied to the outgoing stream.
	// * a full number of bits (e.g., 64000) or a short form of the number with `k` (e.g., 64k).
	// Example: 64000
	SetBitrate(*TcBitrate) TcAudioOpts
	// The number of audio channels in an output stream.
	// Example: 2
	Channels() any
	// The number of audio channels in an output stream.
	// Example: 2
	SetChannels(any) TcAudioOpts
	// Audio codec (the AAC codec is used by default).
	// Example: opus
	Codec() *string
	// Audio codec (the AAC codec is used by default).
	// Example: opus
	SetCodec(string) TcAudioOpts
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// The allowed values are:
	// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
	// /Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	SampleRate() any
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// The allowed values are:
	// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
	// /Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	SetSampleRate(any) TcAudioOpts
	// This option allows to split each audio track with multiple channels into several mono tracks.
	SplitChannels() *bool
	// This option allows to split each audio track with multiple channels into several mono tracks.
	SetSplitChannels(bool) TcAudioOpts
}

type TcAudioOpus interface {
	// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
	// If it is just an integer or a float, the output audio volume is calculated by this formula:
	// `output_volume = avol * input_volume`
	// If specified in decibels (dB), the output audio volume is calculated as follows:
	// `output_volume = input_volume +/- avol`
	// depending whether it is a positive (+9dB) or a negative value (-6dB).
	// By default it equals to 1 (the input audio volume).
	// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
	// Example: -6dB
	Avol() *string
	// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
	// If it is just an integer or a float, the output audio volume is calculated by this formula:
	// `output_volume = avol * input_volume`
	// If specified in decibels (dB), the output audio volume is calculated as follows:
	// `output_volume = input_volume +/- avol`
	// depending whether it is a positive (+9dB) or a negative value (-6dB).
	// By default it equals to 1 (the input audio volume).
	// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
	// Example: -6dB
	SetAvol(string) TcAudioOpus
	// Audio bitrate. The allowed values are:
	// * `copy` - the bitrate or the original stream is copied to the outgoing stream.
	// * a full number of bits (e.g., 64000) or a short form of the number with `k` (e.g., 64k).
	// Example: 64000
	Bitrate() *TcBitrate
	// Audio bitrate. The allowed values are:
	// * `copy` - the bitrate or the original stream is copied to the outgoing stream.
	// * a full number of bits (e.g., 64000) or a short form of the number with `k` (e.g., 64k).
	// Example: 64000
	SetBitrate(*TcBitrate) TcAudioOpus
	// The number of audio channels in an output stream.
	// Example: 2
	Channels() *TiAudioOpusSpecChannels
	// The number of audio channels in an output stream.
	// Example: 2
	SetChannels(TiAudioOpusSpecChannels) TcAudioOpus
	// Audio codec (the AAC codec is used by default).
	// Example: opus
	Codec() *string
	// Audio codec (the AAC codec is used by default).
	// Example: opus
	SetCodec(string) TcAudioOpus
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// The allowed values are:
	// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
	// Example: 48000
	SampleRate() *TiAudioOpusSpecSampleRate
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// The allowed values are:
	// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
	// Example: 48000
	SetSampleRate(TiAudioOpusSpecSampleRate) TcAudioOpus
	// This option allows to split each audio track with multiple channels into several mono tracks.
	SplitChannels() *bool
	// This option allows to split each audio track with multiple channels into several mono tracks.
	SetSplitChannels(bool) TcAudioOpus
}

type TcAudioPcm interface {
	// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
	// If it is just an integer or a float, the output audio volume is calculated by this formula:
	// `output_volume = avol * input_volume`
	// If specified in decibels (dB), the output audio volume is calculated as follows:
	// `output_volume = input_volume +/- avol`
	// depending whether it is a positive (+9dB) or a negative value (-6dB).
	// By default it equals to 1 (the input audio volume).
	// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
	// Example: -6dB
	Avol() *string
	// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
	// If it is just an integer or a float, the output audio volume is calculated by this formula:
	// `output_volume = avol * input_volume`
	// If specified in decibels (dB), the output audio volume is calculated as follows:
	// `output_volume = input_volume +/- avol`
	// depending whether it is a positive (+9dB) or a negative value (-6dB).
	// By default it equals to 1 (the input audio volume).
	// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
	// Example: -6dB
	SetAvol(string) TcAudioPcm
	// Audio bitrate. The allowed values are:
	// * `copy` - the bitrate or the original stream is copied to the outgoing stream.
	// * a full number of bits (e.g., 64000) or a short form of the number with `k` (e.g., 64k).
	// Example: 64000
	Bitrate() *TcBitrate
	// Audio bitrate. The allowed values are:
	// * `copy` - the bitrate or the original stream is copied to the outgoing stream.
	// * a full number of bits (e.g., 64000) or a short form of the number with `k` (e.g., 64k).
	// Example: 64000
	SetBitrate(*TcBitrate) TcAudioPcm
	// The number of audio channels in an output stream.
	// Example: 1
	Channels() *int
	// The number of audio channels in an output stream.
	// Example: 1
	SetChannels(int) TcAudioPcm
	// Audio codec (the AAC codec is used by default).
	// Example: opus
	Codec() *string
	// Audio codec (the AAC codec is used by default).
	// Example: opus
	SetCodec(string) TcAudioPcm
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// Example: 8000
	SampleRate() *int
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// Example: 8000
	SetSampleRate(int) TcAudioPcm
	// This option allows to split each audio track with multiple channels into several mono tracks.
	SplitChannels() *bool
	// This option allows to split each audio track with multiple channels into several mono tracks.
	SetSplitChannels(bool) TcAudioPcm
}

type TcAudioPcma interface {
	// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
	// If it is just an integer or a float, the output audio volume is calculated by this formula:
	// `output_volume = avol * input_volume`
	// If specified in decibels (dB), the output audio volume is calculated as follows:
	// `output_volume = input_volume +/- avol`
	// depending whether it is a positive (+9dB) or a negative value (-6dB).
	// By default it equals to 1 (the input audio volume).
	// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
	// Example: -6dB
	Avol() *string
	// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
	// If it is just an integer or a float, the output audio volume is calculated by this formula:
	// `output_volume = avol * input_volume`
	// If specified in decibels (dB), the output audio volume is calculated as follows:
	// `output_volume = input_volume +/- avol`
	// depending whether it is a positive (+9dB) or a negative value (-6dB).
	// By default it equals to 1 (the input audio volume).
	// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
	// Example: -6dB
	SetAvol(string) TcAudioPcma
	// Audio bitrate. The allowed values are:
	// * `copy` - the bitrate or the original stream is copied to the outgoing stream.
	// * a full number of bits (e.g., 64000) or a short form of the number with `k` (e.g., 64k).
	// Example: 64000
	Bitrate() *TcBitrate
	// Audio bitrate. The allowed values are:
	// * `copy` - the bitrate or the original stream is copied to the outgoing stream.
	// * a full number of bits (e.g., 64000) or a short form of the number with `k` (e.g., 64k).
	// Example: 64000
	SetBitrate(*TcBitrate) TcAudioPcma
	// The number of audio channels in an output stream.
	// Example: 1
	Channels() *TiAudioPcmaSpecChannels
	// The number of audio channels in an output stream.
	// Example: 1
	SetChannels(TiAudioPcmaSpecChannels) TcAudioPcma
	// Audio codec (the AAC codec is used by default).
	// Example: opus
	Codec() *string
	// Audio codec (the AAC codec is used by default).
	// Example: opus
	SetCodec(string) TcAudioPcma
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// The allowed values are:
	// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
	// Example: 8000
	SampleRate() *TiAudioPcmaSpecSampleRate
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// The allowed values are:
	// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
	// Example: 8000
	SetSampleRate(TiAudioPcmaSpecSampleRate) TcAudioPcma
	// This option allows to split each audio track with multiple channels into several mono tracks.
	SplitChannels() *bool
	// This option allows to split each audio track with multiple channels into several mono tracks.
	SetSplitChannels(bool) TcAudioPcma
}

type TcBurn interface {
	// Configuration of burn-in text to video frames.
	Text() TcLabel
	// Configuration of burn-in text to video frames.
	SetText(TcLabel) TcBurn
	// Configuration of burn-in timestamp to video frames.
	Time() TcLabel
	// Configuration of burn-in timestamp to video frames.
	SetTime(TcLabel) TcBurn
}

// Required: left, top, width, height
type TcCrop interface {
	// The height of the output video.
	Height() int
	// The height of the output video.
	SetHeight(int) TcCrop
	// The `x` coordinate of the upper-left corner of the output video withing the input video.
	Left() int
	// The `x` coordinate of the upper-left corner of the output video withing the input video.
	SetLeft(int) TcCrop
	// The `y` coordinate of the upper-left corner of the output video withing the input video.
	Top() int
	// The `y` coordinate of the upper-left corner of the output video withing the input video.
	SetTop(int) TcCrop
	// The width of the output video.
	Width() int
	// The width of the output video.
	SetWidth(int) TcCrop
}

type TcDecoder interface {
	// Video cropping options.
	Crop() TcCrop
	// Video cropping options.
	SetCrop(TcCrop) TcDecoder
	// Activate deinterlacing, i.e., converting an interlaced image to a progressive image.
	// It is necessary for comfortable viewing of legacy TV video on PC/mobile devices.
	// Example: true
	Deinterlace() *DeinterlaceSettings
	// Activate deinterlacing, i.e., converting an interlaced image to a progressive image.
	// It is necessary for comfortable viewing of legacy TV video on PC/mobile devices.
	// Example: true
	SetDeinterlace(*DeinterlaceSettings) TcDecoder
	// This parameter is used when encoding with Nvidia NVENC.
	// You can remove duplicate frames that were produced after deinterlacing, preventing increased bitrate, by one of two methods.
	// Example: frame
	DeinterlaceRate() *TcDecoderDeinterlaceRate
	// This parameter is used when encoding with Nvidia NVENC.
	// You can remove duplicate frames that were produced after deinterlacing, preventing increased bitrate, by one of two methods.
	// Example: frame
	SetDeinterlaceRate(TcDecoderDeinterlaceRate) TcDecoder
	// This parameter is applicable for NVIDIA Jetson transcoder only.
	// This is the number of frames after wich the decoder skips a frame and, thus, allows to save the resources. For example:
	// * 1 - sip each frame
	// * 2 - skip each second frame
	// * 3 - skip each third frame, etc.
	// This option can be useful for streams with high FPS (e.g., 60) as it allows to increase the bandwidth.
	// Example: 3
	DropFrameInterval() *int
	// This parameter is applicable for NVIDIA Jetson transcoder only.
	// This is the number of frames after wich the decoder skips a frame and, thus, allows to save the resources. For example:
	// * 1 - sip each frame
	// * 2 - skip each second frame
	// * 3 - skip each third frame, etc.
	// This option can be useful for streams with high FPS (e.g., 60) as it allows to increase the bandwidth.
	// Example: 3
	SetDropFrameInterval(int) TcDecoder
	// Switch off the decoded picture buffer. Works for the streams with 1 reference frame.
	// The default value is `false`.
	// Example: false
	NoDpb() *bool
	// Switch off the decoded picture buffer. Works for the streams with 1 reference frame.
	// The default value is `false`.
	// Example: false
	SetNoDpb(bool) TcDecoder
	// The required pixel format according to a color model.
	PixFmt() *FrameVideoPixFmt
	// The required pixel format according to a color model.
	SetPixFmt(FrameVideoPixFmt) TcDecoder
	// Allow receiving incomplete frames from the input buffer.
	// If it is set to `true`, the decoder can start decoding before the complete frame is received.
	// Example: false
	StreamingFrame() *bool
	// Allow receiving incomplete frames from the input buffer.
	// If it is set to `true`, the decoder can start decoding before the complete frame is received.
	// Example: false
	SetStreamingFrame(bool) TcDecoder
}

type TcGlobal interface {
	// Configuration of text, timestamp or subtitles burn-in to video frames.
	Burn() TcBurn
	// Configuration of text, timestamp or subtitles burn-in to video frames.
	SetBurn(TcBurn) TcGlobal
	// Identifier of hardware device to be used for transcoding a stream.
	Deviceid() *TcDeviceid
	// Identifier of hardware device to be used for transcoding a stream.
	SetDeviceid(*TcDeviceid) TcGlobal
	// If this parameter is se to `true` (by default), the transcoder runs in a separate process from Flussonic.
	// If it is set to `false`, the transcoder will run in the same process as Flussonic.
	// This mode speeds up encoding, especially when encoding audio or when using an Nvidia device.
	// However, a transcoder error may cause Flussonic to crash.
	External() *bool
	// If this parameter is se to `true` (by default), the transcoder runs in a separate process from Flussonic.
	// If it is set to `false`, the transcoder will run in the same process as Flussonic.
	// This mode speeds up encoding, especially when encoding audio or when using an Nvidia device.
	// However, a transcoder error may cause Flussonic to crash.
	SetExternal(bool) TcGlobal
	// GOP (group of pictures) size (in frames) to be applied for any video track in the stream.
	// The encoder will create all GOPs of an exactly identical size - as specified in this option.
	// May be overridden for a track.
	// Example: 150
	Gop() *int
	// GOP (group of pictures) size (in frames) to be applied for any video track in the stream.
	// The encoder will create all GOPs of an exactly identical size - as specified in this option.
	// May be overridden for a track.
	// Example: 150
	SetGop(int) TcGlobal
	// Transcoder hardware device type to be used for transcoding a stream.
	Hw() *TranscoderDevice
	// Transcoder hardware device type to be used for transcoding a stream.
	SetHw(TranscoderDevice) TcGlobal
	// What use is the stream intended for.
	// Specifying this option applies useful defaults in conformance with standards
	Target() *TranscoderTarget
	// What use is the stream intended for.
	// Specifying this option applies useful defaults in conformance with standards
	SetTarget(TranscoderTarget) TcGlobal
}

type TcLabel interface {
	// Parameters of the box around the text, timestamp, or subtitles.
	Box() TcLabelBox
	// Parameters of the box around the text, timestamp, or subtitles.
	SetBox(TcLabelBox) TcLabel
	// Font to be used for text, timestamp, or subtitles burn-in to video frames.
	Font() TcLabelFont
	// Font to be used for text, timestamp, or subtitles burn-in to video frames.
	SetFont(TcLabelFont) TcLabel
	// Position to burn text.
	Position() *TcLabelPosition
	// Position to burn text.
	SetPosition(TcLabelPosition) TcLabel
	// Text, time, or subtitles to burn-in to video frames.
	// * For text - it is the text
	// * For subtitles - it is the subtitles track, e.g., `t1`.
	// * For time - it is the time in one of the formats:
	// ** `%T` - the time in 24-hour notation (`%H:%M:%S`).
	// ** `%F` - equivalent to `%Y-%m-%d` (the ISO 8601 date format).
	Text() *string
	// Text, time, or subtitles to burn-in to video frames.
	// * For text - it is the text
	// * For subtitles - it is the subtitles track, e.g., `t1`.
	// * For time - it is the time in one of the formats:
	// ** `%T` - the time in 24-hour notation (`%H:%M:%S`).
	// ** `%F` - equivalent to `%Y-%m-%d` (the ISO 8601 date format).
	SetText(string) TcLabel
	// The offset of the text, timestamp, or subtitles position, in pixel, to the right or left to the center of the screen.
	X() *int
	// The offset of the text, timestamp, or subtitles position, in pixel, to the right or left to the center of the screen.
	SetX(int) TcLabel
	// The offset of the text, timestamp, or subtitles position, in pixel, up or down to the center of the screen.
	Y() *int
	// The offset of the text, timestamp, or subtitles position, in pixel, up or down to the center of the screen.
	SetY(int) TcLabel
}

type TcLabelBox interface {
	// Box opacity (use values from 0.1 to 1.0, 0.0 - completely transparent, 1.0 - completely opaque).
	// Example: 0
	Alpha() *float64
	// Box opacity (use values from 0.1 to 1.0, 0.0 - completely transparent, 1.0 - completely opaque).
	// Example: 0
	SetAlpha(float64) TcLabelBox
	// The width, in pixel, of the border to be drawn around the text, timestamp, or subtitles.
	// Example: 10
	Borderw() *int
	// The width, in pixel, of the border to be drawn around the text, timestamp, or subtitles.
	// Example: 10
	SetBorderw(int) TcLabelBox
	// Box color.
	Color() *string
	// Box color.
	SetColor(string) TcLabelBox
}

type TcLabelFont interface {
	// Font opacity (use values from 0.1 to 1.0, 0.0 - completely transparent, 1.0 - completely opaque).
	// Example: 1
	Alpha() *float64
	// Font opacity (use values from 0.1 to 1.0, 0.0 - completely transparent, 1.0 - completely opaque).
	// Example: 1
	SetAlpha(float64) TcLabelFont
	// Font color.
	Color() *string
	// Font color.
	SetColor(string) TcLabelFont
	// The subpath to the `.ttf` font file in the `font` subdirectory of the `/etc/flussonic/` directory.
	// This means you can place the font file like `/etc/flussonic/font/SomeFont.ttf`.
	// If the font file specified is missing in `/etc/flussonic/font/`, the default `FiraCode-Regular.ttf` font will be used, which is included in Flussonic.
	// You can also specify the full path to a font file. Make sure you put the font file in the directory you specified.
	// Example: /usr/share/fonts/truetype/freefont/FONT_NAME.ttf
	File() *string
	// The subpath to the `.ttf` font file in the `font` subdirectory of the `/etc/flussonic/` directory.
	// This means you can place the font file like `/etc/flussonic/font/SomeFont.ttf`.
	// If the font file specified is missing in `/etc/flussonic/font/`, the default `FiraCode-Regular.ttf` font will be used, which is included in Flussonic.
	// You can also specify the full path to a font file. Make sure you put the font file in the directory you specified.
	// Example: /usr/share/fonts/truetype/freefont/FONT_NAME.ttf
	SetFile(string) TcLabelFont
	// The font size in pixel.
	// Example: 24
	Size() *int
	// The font size in pixel.
	// Example: 24
	SetSize(int) TcLabelFont
}

type TcLogo interface {
	// Path to the logo image.
	// Pattern: ^.+\.png$
	// Example: @chan.png
	Path() *string
	// Path to the logo image.
	// Pattern: ^.+\.png$
	// Example: @chan.png
	SetPath(string) TcLogo
	// Position to place the logo.
	// Example: tl
	Position() *TcLogoPosition
	// Position to place the logo.
	// Example: tl
	SetPosition(TcLogoPosition) TcLogo
	// The offset of the logo position, in pixel, to the right or left to the center of the screen.
	// Example: 10
	X() *int
	// The offset of the logo position, in pixel, to the right or left to the center of the screen.
	// Example: 10
	SetX(int) TcLogo
	// The offset of the logo position, in pixel, up or down to the center of the screen.
	// Example: 10
	Y() *int
	// The offset of the logo position, in pixel, up or down to the center of the screen.
	// Example: 10
	SetY(int) TcLogo
}

type TcQpRange interface {
	// Maximal quantization parameter for B-frames.
	Qpmaxb() *int
	// Maximal quantization parameter for B-frames.
	SetQpmaxb(int) TcQpRange
	// Maximal quantization parameter for I-frames.
	Qpmaxi() *int
	// Maximal quantization parameter for I-frames.
	SetQpmaxi(int) TcQpRange
	// Maximal quantization parameter for P-frames.
	Qpmaxp() *int
	// Maximal quantization parameter for P-frames.
	SetQpmaxp(int) TcQpRange
	// Minimal quantization parameter for B-frames.
	Qpminb() *int
	// Minimal quantization parameter for B-frames.
	SetQpminb(int) TcQpRange
	// Minimal quantization parameter for I-frames.
	Qpmini() *int
	// Minimal quantization parameter for I-frames.
	SetQpmini(int) TcQpRange
	// Minimal quantization parameter for P-frames.
	Qpminp() *int
	// Minimal quantization parameter for P-frames.
	SetQpminp(int) TcQpRange
}

type TcSar interface {
	// The first number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
	X() *int
	// The first number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
	SetX(int) TcSar
	// The second number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
	Y() *int
	// The second number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
	SetY(int) TcSar
}

type TcSize interface {
	// The color of the area in the player that is not occupied by the video after resizing.
	// It is used only with the 'fit' strategy.
	Background() *string
	// The color of the area in the player that is not occupied by the video after resizing.
	// It is used only with the 'fit' strategy.
	SetBackground(string) TcSize
	// The picture height in pixels on the display where it will be played by a player.
	// If you need to insert a web-player into a web page, use this value for choosing the player size.
	// A value of -1 means that the width will be used to calculate the actual height with maintaining the aspect ratio.
	// Only one of width or height may have value -1.
	// Zero value (0) is not allowed.
	Height() *int
	// The picture height in pixels on the display where it will be played by a player.
	// If you need to insert a web-player into a web page, use this value for choosing the player size.
	// A value of -1 means that the width will be used to calculate the actual height with maintaining the aspect ratio.
	// Only one of width or height may have value -1.
	// Zero value (0) is not allowed.
	SetHeight(int) TcSize
	// The algorithm of the picture resizing: crop, scale, or fit.
	// Example: crop
	Strategy() *TcSizeStrategy
	// The algorithm of the picture resizing: crop, scale, or fit.
	// Example: crop
	SetStrategy(TcSizeStrategy) TcSize
	// The picture width in pixels on the display where it will be played by a player.
	// If you need to insert a web-player into a web page, use this value for choosing the player size.
	// A value of -1 means that the heigth will be used to calculate the actual width with maintaining the aspect ratio.
	// Only one of width or height may have value -1.
	// Zero value (0) is not allowed.
	Width() *int
	// The picture width in pixels on the display where it will be played by a player.
	// If you need to insert a web-player into a web page, use this value for choosing the player size.
	// A value of -1 means that the heigth will be used to calculate the actual width with maintaining the aspect ratio.
	// Only one of width or height may have value -1.
	// Zero value (0) is not allowed.
	SetWidth(int) TcSize
}

// Required: track
type TcVideoOpts interface {
	// The configuration of a logo added to the video track after the video was resized as specified in the `size` option.
	// This prevents the logo picture from stretching that might occur when the `logo` option is used.
	// You will need to prepare and specify a separate file with a logo for each size of the resulting video track.
	Alogo() TcLogo
	// The configuration of a logo added to the video track after the video was resized as specified in the `size` option.
	// This prevents the logo picture from stretching that might occur when the `logo` option is used.
	// You will need to prepare and specify a separate file with a logo for each size of the resulting video track.
	SetAlogo(TcLogo) TcVideoOpts
	// Number of B-frames in a GOP. B-frames contain links to keyframes and P-frames before and after themselves.
	// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
	// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
	// When set to 0, this option disables b-frames. This may be necessary, for example, when broadcasting to RTSP.
	// Example: 3
	Bframes() *int
	// Number of B-frames in a GOP. B-frames contain links to keyframes and P-frames before and after themselves.
	// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
	// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
	// When set to 0, this option disables b-frames. This may be necessary, for example, when broadcasting to RTSP.
	// Example: 3
	SetBframes(int) TcVideoOpts
	// The bitrate of a video track.
	// Example: 1e+06
	Bitrate() *TcBitrate
	// The bitrate of a video track.
	// Example: 1e+06
	SetBitrate(*TcBitrate) TcVideoOpts
	// Configuration of burn-in text, timestamp, or subtitles to video frames.
	Burn() TcBurn
	// Configuration of burn-in text, timestamp, or subtitles to video frames.
	SetBurn(TcBurn) TcVideoOpts
	// The video codec.
	Codec() *TcVideoOptsCodec
	// The video codec.
	SetCodec(TcVideoOptsCodec) TcVideoOpts
	// Some additional options.
	Extra() map[string]string
	// Some additional options.
	SetExtra(map[string]string) TcVideoOpts
	// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
	// Higher frame rates capture more images per second, which makes for smoother video.
	// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
	// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
	// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
	// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
	// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
	FPS() *TcFPS
	// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
	// Higher frame rates capture more images per second, which makes for smoother video.
	// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
	// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
	// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
	// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
	// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
	SetFPS(*TcFPS) TcVideoOpts
	// Sets the number of frames in a GOP.
	// The encoder will create all GOPs of an exactly identical size - as specified in this option.
	// Example: 150
	Gop() *int
	// Sets the number of frames in a GOP.
	// The encoder will create all GOPs of an exactly identical size - as specified in this option.
	// Example: 150
	SetGop(int) TcVideoOpts
	// This parameter is used to get an interlaced stream from a progressive one.
	// The allowed values are `true` (interlaced video), `false` (progressive video), or one of the methods for producing interlaced video supported for the selected type of transcoder.
	Interlace() *InterlaceSettings
	// This parameter is used to get an interlaced stream from a progressive one.
	// The allowed values are `true` (interlaced video), `false` (progressive video), or one of the methods for producing interlaced video supported for the selected type of transcoder.
	SetInterlace(*InterlaceSettings) TcVideoOpts
	// A set of constraints that indicate a degree of required decoder performance.
	// This parameter is used for compatibility with old devices.
	Level() any
	// A set of constraints that indicate a degree of required decoder performance.
	// This parameter is used for compatibility with old devices.
	SetLevel(any) TcVideoOpts
	// The configuration of a logo "burned" into the video track.
	// The transcoder adds the logo before the video is resized as specified in the `size` option.
	// This means that the logo can be visibly stretched if the size was changed significantly.
	Logo() TcLogo
	// The configuration of a logo "burned" into the video track.
	// The transcoder adds the logo before the video is resized as specified in the `size` option.
	// This means that the logo can be visibly stretched if the size was changed significantly.
	SetLogo(TcLogo) TcVideoOpts
	// Whether open GOP is used. Open GOP contains P-frames that refer to the frames before the keyframe.
	// It allows to decrease bitrate to 5-7%, but can result in breaking the picture.
	OpenGop() *bool
	// Whether open GOP is used. Open GOP contains P-frames that refer to the frames before the keyframe.
	// It allows to decrease bitrate to 5-7%, but can result in breaking the picture.
	SetOpenGop(bool) TcVideoOpts
	// A set of values that determine a certain encoding speed, which influences a compression ratio.
	// A slower preset will provide better compression (compression is quality per file size).
	// Example: medium
	Preset() *TcPreset
	// A set of values that determine a certain encoding speed, which influences a compression ratio.
	// A slower preset will provide better compression (compression is quality per file size).
	// Example: medium
	SetPreset(TcPreset) TcVideoOpts
	// Limits the output to a specific H.264 profile.
	Profile() *TcProfile
	// Limits the output to a specific H.264 profile.
	SetProfile(TcProfile) TcVideoOpts
	// The ranges of the quantization parameter for different types of frames in a GOP.
	// Quantization is an algorithm used for video compression. It is based on fragmentation of video frames.
	// Increasing this parameter allows to improve the compression but may lower the picture quality.
	// Usually, these ranges are defined automatically by the transcoder, but for some types of transcoders it makes sense to set them manually.
	QpRange() TcQpRange
	// The ranges of the quantization parameter for different types of frames in a GOP.
	// Quantization is an algorithm used for video compression. It is based on fragmentation of video frames.
	// Increasing this parameter allows to improve the compression but may lower the picture quality.
	// Usually, these ranges are defined automatically by the transcoder, but for some types of transcoders it makes sense to set them manually.
	SetQpRange(TcQpRange) TcVideoOpts
	// A method for creating output video with constant bitrate suitable for broadcasting to television networks.
	RcMethod() *RcMethod
	// A method for creating output video with constant bitrate suitable for broadcasting to television networks.
	SetRcMethod(RcMethod) TcVideoOpts
	// The number of reference frames in a GOP.
	// Reference frames are frames of a compressed video that are used to define other frames (P-frames and B-frames).
	Refs() *int
	// The number of reference frames in a GOP.
	// Reference frames are frames of a compressed video that are used to define other frames (P-frames and B-frames).
	SetRefs(int) TcVideoOpts
	// The mode to be used for resizing video tracks. It is one of the computing platforms for Flussonic Coder:
	// * vic -  Video Image Converter, specific for Jetson Nvidia
	// * cuda - CUDA (or Compute Unified Device Architecture)
	ResizeMode() *TranscoderResizeMode
	// The mode to be used for resizing video tracks. It is one of the computing platforms for Flussonic Coder:
	// * vic -  Video Image Converter, specific for Jetson Nvidia
	// * cuda - CUDA (or Compute Unified Device Architecture)
	SetResizeMode(TranscoderResizeMode) TcVideoOpts
	// Target aspect ratio.
	Sar() TcSar
	// Target aspect ratio.
	SetSar(TcSar) TcVideoOpts
	// Target size of the image and the strategy to achieve it.
	Size() TcSize
	// Target size of the image and the strategy to achieve it.
	SetSize(TcSize) TcVideoOpts
	// Drop some frames in dynamic scenes when the transcoder does not have time to code all frames.
	// The allowed values are:
	// * `15` - drop 1 from 5
	// * `13` - drop 1 from 3
	// * `12` - drop 1 from 2
	// * `23` - drop 2 from 3
	// * `0` - do not drop frames
	TemporalTradeoff() *int
	// Drop some frames in dynamic scenes when the transcoder does not have time to code all frames.
	// The allowed values are:
	// * `15` - drop 1 from 5
	// * `13` - drop 1 from 3
	// * `12` - drop 1 from 2
	// * `23` - drop 2 from 3
	// * `0` - do not drop frames
	SetTemporalTradeoff(int) TcVideoOpts
	// Number of threads used by the encoder when transcoding with CPU (it is not used for other types of transcoder).
	// This parameter allows to increase performance by adding new threads. By default, it is autodetected.
	Threads() *int
	// Number of threads used by the encoder when transcoding with CPU (it is not used for other types of transcoder).
	// This parameter allows to increase performance by adding new threads. By default, it is autodetected.
	SetThreads(int) TcVideoOpts
	// Number of a video track.
	// Example: 1
	Track() int
	// Number of a video track.
	// Example: 1
	SetTrack(int) TcVideoOpts
	// Virtual buffer size, it bits. The default value is `gop / fps * bitrate`.
	VbvBufsize() *int
	// Virtual buffer size, it bits. The default value is `gop / fps * bitrate`.
	SetVbvBufsize(int) TcVideoOpts
}

type ThumbnailsSizeSpec interface {
	// The thumbnail height.
	Height() *int
	// The thumbnail height.
	SetHeight(int) ThumbnailsSizeSpec
	// The thumbnail width.
	Width() *int
	// The thumbnail width.
	SetWidth(int) ThumbnailsSizeSpec
}

type ThumbnailsSpec interface {
	// Whether to generate thumbnails from the video stream.
	Enabled() any
	// Whether to generate thumbnails from the video stream.
	SetEnabled(any) ThumbnailsSpec
	// What sizes will be used for thumbnails generation.
	Sizes() []ThumbnailsSizeSpec
	// What sizes will be used for thumbnails generation.
	SetSizes([]ThumbnailsSizeSpec) ThumbnailsSpec
	// *Flussonic* takes a thumbnail from the specified URL on each keyframe.
	// May reduce CPU usage on IP cameras.
	// Example: http://10.115.23.45/isapi/thumbnail.jpg
	URL() *string
	// *Flussonic* takes a thumbnail from the specified URL on each keyframe.
	// May reduce CPU usage on IP cameras.
	// Example: http://10.115.23.45/isapi/thumbnail.jpg
	SetURL(string) ThumbnailsSpec
}

type TiAudioAac interface {
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	Bitrate() *Speed
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	SetBitrate(Speed) TiAudioAac
	// The number of audio channels in an output stream.
	// Example: 2
	Channels() *TiAudioAacSpecChannels
	// The number of audio channels in an output stream.
	// Example: 2
	SetChannels(TiAudioAacSpecChannels) TiAudioAac
	// Audio codec (the AAC codec is used by default).
	// Example: opus
	Codec() *string
	// Audio codec (the AAC codec is used by default).
	// Example: opus
	SetCodec(string) TiAudioAac
	// Content of the track (audio, video, or text).
	Content() FrameContent
	// Content of the track (audio, video, or text).
	SetContent(FrameContent) TiAudioAac
	// Input audio track to be transcoded.
	// Example: 1
	InputTrack() *int
	// Input audio track to be transcoded.
	// Example: 1
	SetInputTrack(int) TiAudioAac
	// Language value of the track, if applicable.
	// Example: eng
	Language() *string
	// Language value of the track, if applicable.
	// Example: eng
	SetLanguage(string) TiAudioAac
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	Pid() *int
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	SetPid(int) TiAudioAac
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// The allowed values are:
	// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
	// Example: 48000
	SampleRate() *TiAudioAacSpecSampleRate
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// The allowed values are:
	// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
	// Example: 48000
	SetSampleRate(TiAudioAacSpecSampleRate) TiAudioAac
	// This option allows to split each audio track with multiple channels into several mono tracks.
	SplitChannels() *bool
	// This option allows to split each audio track with multiple channels into several mono tracks.
	SetSplitChannels(bool) TiAudioAac
	// Human-readable localized title of the track.
	// Example: Video1
	Title() *string
	// Human-readable localized title of the track.
	// Example: Video1
	SetTitle(string) TiAudioAac
	// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
	// If it is just an integer or a float, the output audio volume is calculated by this formula:
	// `output_volume = volume * input_volume`
	// If specified in decibels (dB), the output audio volume is calculated as follows:
	// `output_volume = input_volume +/- volume`
	// depending whether it is a positive (+9dB) or a negative value (-6dB).
	// By default it equals to 1 (the input audio volume).
	// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
	// Example: -6dB
	Volume() *string
	// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
	// If it is just an integer or a float, the output audio volume is calculated by this formula:
	// `output_volume = volume * input_volume`
	// If specified in decibels (dB), the output audio volume is calculated as follows:
	// `output_volume = input_volume +/- volume`
	// depending whether it is a positive (+9dB) or a negative value (-6dB).
	// By default it equals to 1 (the input audio volume).
	// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
	// Example: -6dB
	SetVolume(string) TiAudioAac
}

// Title: AAC codec
type TiAudioAacSpec interface {
	// The number of audio channels in an output stream.
	// Example: 2
	Channels() *TiAudioAacSpecChannels
	// The number of audio channels in an output stream.
	// Example: 2
	SetChannels(TiAudioAacSpecChannels) TiAudioAacSpec
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// The allowed values are:
	// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
	// Example: 48000
	SampleRate() *TiAudioAacSpecSampleRate
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// The allowed values are:
	// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
	// Example: 48000
	SetSampleRate(TiAudioAacSpecSampleRate) TiAudioAacSpec
}

type TiAudioAc3 interface {
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	Bitrate() *Speed
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	SetBitrate(Speed) TiAudioAc3
	// The number of audio channels in an output stream.
	// Example: 2
	Channels() *TiAudioAc3SpecChannels
	// The number of audio channels in an output stream.
	// Example: 2
	SetChannels(TiAudioAc3SpecChannels) TiAudioAc3
	// Audio codec (the AAC codec is used by default).
	// Example: opus
	Codec() *string
	// Audio codec (the AAC codec is used by default).
	// Example: opus
	SetCodec(string) TiAudioAc3
	// Content of the track (audio, video, or text).
	Content() FrameContent
	// Content of the track (audio, video, or text).
	SetContent(FrameContent) TiAudioAc3
	// Input audio track to be transcoded.
	// Example: 1
	InputTrack() *int
	// Input audio track to be transcoded.
	// Example: 1
	SetInputTrack(int) TiAudioAc3
	// Language value of the track, if applicable.
	// Example: eng
	Language() *string
	// Language value of the track, if applicable.
	// Example: eng
	SetLanguage(string) TiAudioAc3
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	Pid() *int
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	SetPid(int) TiAudioAc3
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// The allowed values are:
	// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
	// Example: 48000
	SampleRate() *TiAudioAc3SpecSampleRate
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// The allowed values are:
	// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
	// Example: 48000
	SetSampleRate(TiAudioAc3SpecSampleRate) TiAudioAc3
	// This option allows to split each audio track with multiple channels into several mono tracks.
	SplitChannels() *bool
	// This option allows to split each audio track with multiple channels into several mono tracks.
	SetSplitChannels(bool) TiAudioAc3
	// Human-readable localized title of the track.
	// Example: Video1
	Title() *string
	// Human-readable localized title of the track.
	// Example: Video1
	SetTitle(string) TiAudioAc3
	// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
	// If it is just an integer or a float, the output audio volume is calculated by this formula:
	// `output_volume = volume * input_volume`
	// If specified in decibels (dB), the output audio volume is calculated as follows:
	// `output_volume = input_volume +/- volume`
	// depending whether it is a positive (+9dB) or a negative value (-6dB).
	// By default it equals to 1 (the input audio volume).
	// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
	// Example: -6dB
	Volume() *string
	// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
	// If it is just an integer or a float, the output audio volume is calculated by this formula:
	// `output_volume = volume * input_volume`
	// If specified in decibels (dB), the output audio volume is calculated as follows:
	// `output_volume = input_volume +/- volume`
	// depending whether it is a positive (+9dB) or a negative value (-6dB).
	// By default it equals to 1 (the input audio volume).
	// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
	// Example: -6dB
	SetVolume(string) TiAudioAc3
}

// Title: AC3/EAC3 codec
type TiAudioAc3Spec interface {
	// The number of audio channels in an output stream.
	// Example: 2
	Channels() *TiAudioAc3SpecChannels
	// The number of audio channels in an output stream.
	// Example: 2
	SetChannels(TiAudioAc3SpecChannels) TiAudioAc3Spec
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// The allowed values are:
	// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
	// Example: 48000
	SampleRate() *TiAudioAc3SpecSampleRate
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// The allowed values are:
	// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
	// Example: 48000
	SetSampleRate(TiAudioAc3SpecSampleRate) TiAudioAc3Spec
}

type TiAudioMp2a interface {
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	Bitrate() *Speed
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	SetBitrate(Speed) TiAudioMp2a
	// The number of audio channels in an output stream.
	// Example: 2
	Channels() *TiAudioMp2aSpecChannels
	// The number of audio channels in an output stream.
	// Example: 2
	SetChannels(TiAudioMp2aSpecChannels) TiAudioMp2a
	// Audio codec (the AAC codec is used by default).
	// Example: opus
	Codec() *string
	// Audio codec (the AAC codec is used by default).
	// Example: opus
	SetCodec(string) TiAudioMp2a
	// Content of the track (audio, video, or text).
	Content() FrameContent
	// Content of the track (audio, video, or text).
	SetContent(FrameContent) TiAudioMp2a
	// Input audio track to be transcoded.
	// Example: 1
	InputTrack() *int
	// Input audio track to be transcoded.
	// Example: 1
	SetInputTrack(int) TiAudioMp2a
	// Language value of the track, if applicable.
	// Example: eng
	Language() *string
	// Language value of the track, if applicable.
	// Example: eng
	SetLanguage(string) TiAudioMp2a
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	Pid() *int
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	SetPid(int) TiAudioMp2a
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// The allowed values are:
	// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
	// Example: 48000
	SampleRate() *TiAudioMp2aSpecSampleRate
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// The allowed values are:
	// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
	// Example: 48000
	SetSampleRate(TiAudioMp2aSpecSampleRate) TiAudioMp2a
	// This option allows to split each audio track with multiple channels into several mono tracks.
	SplitChannels() *bool
	// This option allows to split each audio track with multiple channels into several mono tracks.
	SetSplitChannels(bool) TiAudioMp2a
	// Human-readable localized title of the track.
	// Example: Video1
	Title() *string
	// Human-readable localized title of the track.
	// Example: Video1
	SetTitle(string) TiAudioMp2a
	// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
	// If it is just an integer or a float, the output audio volume is calculated by this formula:
	// `output_volume = volume * input_volume`
	// If specified in decibels (dB), the output audio volume is calculated as follows:
	// `output_volume = input_volume +/- volume`
	// depending whether it is a positive (+9dB) or a negative value (-6dB).
	// By default it equals to 1 (the input audio volume).
	// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
	// Example: -6dB
	Volume() *string
	// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
	// If it is just an integer or a float, the output audio volume is calculated by this formula:
	// `output_volume = volume * input_volume`
	// If specified in decibels (dB), the output audio volume is calculated as follows:
	// `output_volume = input_volume +/- volume`
	// depending whether it is a positive (+9dB) or a negative value (-6dB).
	// By default it equals to 1 (the input audio volume).
	// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
	// Example: -6dB
	SetVolume(string) TiAudioMp2a
}

// Title: MP2 audio codec
type TiAudioMp2aSpec interface {
	// The number of audio channels in an output stream.
	// Example: 2
	Channels() *TiAudioMp2aSpecChannels
	// The number of audio channels in an output stream.
	// Example: 2
	SetChannels(TiAudioMp2aSpecChannels) TiAudioMp2aSpec
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// The allowed values are:
	// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
	// Example: 48000
	SampleRate() *TiAudioMp2aSpecSampleRate
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// The allowed values are:
	// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
	// Example: 48000
	SetSampleRate(TiAudioMp2aSpecSampleRate) TiAudioMp2aSpec
}

type TiAudioMp3 interface {
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	Bitrate() *Speed
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	SetBitrate(Speed) TiAudioMp3
	// The number of audio channels in an output stream.
	// Example: 2
	Channels() *TiAudioMp3SpecChannels
	// The number of audio channels in an output stream.
	// Example: 2
	SetChannels(TiAudioMp3SpecChannels) TiAudioMp3
	// Audio codec (the AAC codec is used by default).
	// Example: opus
	Codec() *string
	// Audio codec (the AAC codec is used by default).
	// Example: opus
	SetCodec(string) TiAudioMp3
	// Content of the track (audio, video, or text).
	Content() FrameContent
	// Content of the track (audio, video, or text).
	SetContent(FrameContent) TiAudioMp3
	// Input audio track to be transcoded.
	// Example: 1
	InputTrack() *int
	// Input audio track to be transcoded.
	// Example: 1
	SetInputTrack(int) TiAudioMp3
	// Language value of the track, if applicable.
	// Example: eng
	Language() *string
	// Language value of the track, if applicable.
	// Example: eng
	SetLanguage(string) TiAudioMp3
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	Pid() *int
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	SetPid(int) TiAudioMp3
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// The allowed values are:
	// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
	// Example: 8000
	SampleRate() *TiAudioMp3SpecSampleRate
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// The allowed values are:
	// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
	// Example: 8000
	SetSampleRate(TiAudioMp3SpecSampleRate) TiAudioMp3
	// This option allows to split each audio track with multiple channels into several mono tracks.
	SplitChannels() *bool
	// This option allows to split each audio track with multiple channels into several mono tracks.
	SetSplitChannels(bool) TiAudioMp3
	// Human-readable localized title of the track.
	// Example: Video1
	Title() *string
	// Human-readable localized title of the track.
	// Example: Video1
	SetTitle(string) TiAudioMp3
	// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
	// If it is just an integer or a float, the output audio volume is calculated by this formula:
	// `output_volume = volume * input_volume`
	// If specified in decibels (dB), the output audio volume is calculated as follows:
	// `output_volume = input_volume +/- volume`
	// depending whether it is a positive (+9dB) or a negative value (-6dB).
	// By default it equals to 1 (the input audio volume).
	// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
	// Example: -6dB
	Volume() *string
	// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
	// If it is just an integer or a float, the output audio volume is calculated by this formula:
	// `output_volume = volume * input_volume`
	// If specified in decibels (dB), the output audio volume is calculated as follows:
	// `output_volume = input_volume +/- volume`
	// depending whether it is a positive (+9dB) or a negative value (-6dB).
	// By default it equals to 1 (the input audio volume).
	// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
	// Example: -6dB
	SetVolume(string) TiAudioMp3
}

// Title: MP3 codec
type TiAudioMp3Spec interface {
	// The number of audio channels in an output stream.
	// Example: 2
	Channels() *TiAudioMp3SpecChannels
	// The number of audio channels in an output stream.
	// Example: 2
	SetChannels(TiAudioMp3SpecChannels) TiAudioMp3Spec
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// The allowed values are:
	// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
	// Example: 8000
	SampleRate() *TiAudioMp3SpecSampleRate
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// The allowed values are:
	// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
	// Example: 8000
	SetSampleRate(TiAudioMp3SpecSampleRate) TiAudioMp3Spec
}

type TiAudioOpus interface {
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	Bitrate() *Speed
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	SetBitrate(Speed) TiAudioOpus
	// The number of audio channels in an output stream.
	// Example: 2
	Channels() *TiAudioOpusSpecChannels
	// The number of audio channels in an output stream.
	// Example: 2
	SetChannels(TiAudioOpusSpecChannels) TiAudioOpus
	// Audio codec (the AAC codec is used by default).
	// Example: opus
	Codec() *string
	// Audio codec (the AAC codec is used by default).
	// Example: opus
	SetCodec(string) TiAudioOpus
	// Content of the track (audio, video, or text).
	Content() FrameContent
	// Content of the track (audio, video, or text).
	SetContent(FrameContent) TiAudioOpus
	// Input audio track to be transcoded.
	// Example: 1
	InputTrack() *int
	// Input audio track to be transcoded.
	// Example: 1
	SetInputTrack(int) TiAudioOpus
	// Language value of the track, if applicable.
	// Example: eng
	Language() *string
	// Language value of the track, if applicable.
	// Example: eng
	SetLanguage(string) TiAudioOpus
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	Pid() *int
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	SetPid(int) TiAudioOpus
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// The allowed values are:
	// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
	// Example: 48000
	SampleRate() *TiAudioOpusSpecSampleRate
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// The allowed values are:
	// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
	// Example: 48000
	SetSampleRate(TiAudioOpusSpecSampleRate) TiAudioOpus
	// This option allows to split each audio track with multiple channels into several mono tracks.
	SplitChannels() *bool
	// This option allows to split each audio track with multiple channels into several mono tracks.
	SetSplitChannels(bool) TiAudioOpus
	// Human-readable localized title of the track.
	// Example: Video1
	Title() *string
	// Human-readable localized title of the track.
	// Example: Video1
	SetTitle(string) TiAudioOpus
	// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
	// If it is just an integer or a float, the output audio volume is calculated by this formula:
	// `output_volume = volume * input_volume`
	// If specified in decibels (dB), the output audio volume is calculated as follows:
	// `output_volume = input_volume +/- volume`
	// depending whether it is a positive (+9dB) or a negative value (-6dB).
	// By default it equals to 1 (the input audio volume).
	// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
	// Example: -6dB
	Volume() *string
	// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
	// If it is just an integer or a float, the output audio volume is calculated by this formula:
	// `output_volume = volume * input_volume`
	// If specified in decibels (dB), the output audio volume is calculated as follows:
	// `output_volume = input_volume +/- volume`
	// depending whether it is a positive (+9dB) or a negative value (-6dB).
	// By default it equals to 1 (the input audio volume).
	// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
	// Example: -6dB
	SetVolume(string) TiAudioOpus
}

// Title: OPUS codec
type TiAudioOpusSpec interface {
	// The number of audio channels in an output stream.
	// Example: 2
	Channels() *TiAudioOpusSpecChannels
	// The number of audio channels in an output stream.
	// Example: 2
	SetChannels(TiAudioOpusSpecChannels) TiAudioOpusSpec
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// The allowed values are:
	// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
	// Example: 48000
	SampleRate() *TiAudioOpusSpecSampleRate
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// The allowed values are:
	// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
	// Example: 48000
	SetSampleRate(TiAudioOpusSpecSampleRate) TiAudioOpusSpec
}

type TiAudioPcm interface {
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	Bitrate() *Speed
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	SetBitrate(Speed) TiAudioPcm
	// The number of audio channels in an output stream.
	// Example: 1
	Channels() *int
	// The number of audio channels in an output stream.
	// Example: 1
	SetChannels(int) TiAudioPcm
	// Audio codec (the AAC codec is used by default).
	// Example: opus
	Codec() *string
	// Audio codec (the AAC codec is used by default).
	// Example: opus
	SetCodec(string) TiAudioPcm
	// Content of the track (audio, video, or text).
	Content() FrameContent
	// Content of the track (audio, video, or text).
	SetContent(FrameContent) TiAudioPcm
	// Input audio track to be transcoded.
	// Example: 1
	InputTrack() *int
	// Input audio track to be transcoded.
	// Example: 1
	SetInputTrack(int) TiAudioPcm
	// Language value of the track, if applicable.
	// Example: eng
	Language() *string
	// Language value of the track, if applicable.
	// Example: eng
	SetLanguage(string) TiAudioPcm
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	Pid() *int
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	SetPid(int) TiAudioPcm
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// Example: 8000
	SampleRate() *int
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// Example: 8000
	SetSampleRate(int) TiAudioPcm
	// This option allows to split each audio track with multiple channels into several mono tracks.
	SplitChannels() *bool
	// This option allows to split each audio track with multiple channels into several mono tracks.
	SetSplitChannels(bool) TiAudioPcm
	// Human-readable localized title of the track.
	// Example: Video1
	Title() *string
	// Human-readable localized title of the track.
	// Example: Video1
	SetTitle(string) TiAudioPcm
	// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
	// If it is just an integer or a float, the output audio volume is calculated by this formula:
	// `output_volume = volume * input_volume`
	// If specified in decibels (dB), the output audio volume is calculated as follows:
	// `output_volume = input_volume +/- volume`
	// depending whether it is a positive (+9dB) or a negative value (-6dB).
	// By default it equals to 1 (the input audio volume).
	// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
	// Example: -6dB
	Volume() *string
	// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
	// If it is just an integer or a float, the output audio volume is calculated by this formula:
	// `output_volume = volume * input_volume`
	// If specified in decibels (dB), the output audio volume is calculated as follows:
	// `output_volume = input_volume +/- volume`
	// depending whether it is a positive (+9dB) or a negative value (-6dB).
	// By default it equals to 1 (the input audio volume).
	// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
	// Example: -6dB
	SetVolume(string) TiAudioPcm
}

// Title: RAW PCM
type TiAudioPcmSpec interface {
	// The number of audio channels in an output stream.
	// Example: 1
	Channels() *int
	// The number of audio channels in an output stream.
	// Example: 1
	SetChannels(int) TiAudioPcmSpec
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// Example: 8000
	SampleRate() *int
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// Example: 8000
	SetSampleRate(int) TiAudioPcmSpec
}

type TiAudioPcma interface {
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	Bitrate() *Speed
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	SetBitrate(Speed) TiAudioPcma
	// The number of audio channels in an output stream.
	// Example: 1
	Channels() *TiAudioPcmaSpecChannels
	// The number of audio channels in an output stream.
	// Example: 1
	SetChannels(TiAudioPcmaSpecChannels) TiAudioPcma
	// Audio codec (the AAC codec is used by default).
	// Example: opus
	Codec() *string
	// Audio codec (the AAC codec is used by default).
	// Example: opus
	SetCodec(string) TiAudioPcma
	// Content of the track (audio, video, or text).
	Content() FrameContent
	// Content of the track (audio, video, or text).
	SetContent(FrameContent) TiAudioPcma
	// Input audio track to be transcoded.
	// Example: 1
	InputTrack() *int
	// Input audio track to be transcoded.
	// Example: 1
	SetInputTrack(int) TiAudioPcma
	// Language value of the track, if applicable.
	// Example: eng
	Language() *string
	// Language value of the track, if applicable.
	// Example: eng
	SetLanguage(string) TiAudioPcma
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	Pid() *int
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	SetPid(int) TiAudioPcma
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// The allowed values are:
	// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
	// Example: 8000
	SampleRate() *TiAudioPcmaSpecSampleRate
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// The allowed values are:
	// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
	// Example: 8000
	SetSampleRate(TiAudioPcmaSpecSampleRate) TiAudioPcma
	// This option allows to split each audio track with multiple channels into several mono tracks.
	SplitChannels() *bool
	// This option allows to split each audio track with multiple channels into several mono tracks.
	SetSplitChannels(bool) TiAudioPcma
	// Human-readable localized title of the track.
	// Example: Video1
	Title() *string
	// Human-readable localized title of the track.
	// Example: Video1
	SetTitle(string) TiAudioPcma
	// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
	// If it is just an integer or a float, the output audio volume is calculated by this formula:
	// `output_volume = volume * input_volume`
	// If specified in decibels (dB), the output audio volume is calculated as follows:
	// `output_volume = input_volume +/- volume`
	// depending whether it is a positive (+9dB) or a negative value (-6dB).
	// By default it equals to 1 (the input audio volume).
	// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
	// Example: -6dB
	Volume() *string
	// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
	// If it is just an integer or a float, the output audio volume is calculated by this formula:
	// `output_volume = volume * input_volume`
	// If specified in decibels (dB), the output audio volume is calculated as follows:
	// `output_volume = input_volume +/- volume`
	// depending whether it is a positive (+9dB) or a negative value (-6dB).
	// By default it equals to 1 (the input audio volume).
	// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
	// Example: -6dB
	SetVolume(string) TiAudioPcma
}

// Title: PCM A-law/PCM mu-law codec
type TiAudioPcmaSpec interface {
	// The number of audio channels in an output stream.
	// Example: 1
	Channels() *TiAudioPcmaSpecChannels
	// The number of audio channels in an output stream.
	// Example: 1
	SetChannels(TiAudioPcmaSpecChannels) TiAudioPcmaSpec
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// The allowed values are:
	// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
	// Example: 8000
	SampleRate() *TiAudioPcmaSpecSampleRate
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// The allowed values are:
	// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
	// Example: 8000
	SetSampleRate(TiAudioPcmaSpecSampleRate) TiAudioPcmaSpec
}

type TrackInfo interface {
	// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
	// The higher FPS is, the smoother the video playback is.
	// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
	AvgFPS() *float64
	// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
	// The higher FPS is, the smoother the video playback is.
	// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
	SetAvgFPS(float64) TrackInfo
	// Average GOP size (expressed in number of frames) of the last 1000-2000 frames.
	// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
	// If this value is floating, this means that your transcoder is working in flexible GOP size mode and some players may have problems.
	// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
	// Example: 25
	AvgGop() *int
	// Average GOP size (expressed in number of frames) of the last 1000-2000 frames.
	// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
	// If this value is floating, this means that your transcoder is working in flexible GOP size mode and some players may have problems.
	// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
	// Example: 25
	SetAvgGop(int) TrackInfo
	// Bandwidth necessary to transfer this track.
	// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
	// Format: speed (speed)
	// Example: 2600
	Bandwidth() *Speed
	// Bandwidth necessary to transfer this track.
	// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
	// Format: speed (speed)
	// Example: 2600
	SetBandwidth(Speed) TrackInfo
	// Average number of B-frames in a GOP. B-frames contain links to keyframes and P-frames before and after themselves.
	// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
	// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
	// Example: 3
	Bframes() *int
	// Average number of B-frames in a GOP. B-frames contain links to keyframes and P-frames before and after themselves.
	// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
	// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
	// Example: 3
	SetBframes(int) TrackInfo
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	Bitrate() *Speed
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	SetBitrate(Speed) TrackInfo
	// The number of audio channels.
	// Example: 2
	Channels() *int
	// The number of audio channels.
	// Example: 2
	SetChannels(int) TrackInfo
	// Parameters of closed captions.
	ClosedCaptions() []ClosedCaptions
	// Parameters of closed captions.
	SetClosedCaptions([]ClosedCaptions) TrackInfo
	// Codec of the track. Different codecs do **not** get the same track.
	// Example: h264
	Codec() *FrameCodec
	// Codec of the track. Different codecs do **not** get the same track.
	// Example: h264
	SetCodec(FrameCodec) TrackInfo
	// Content of the track (audio, video, or text).
	Content() FrameContent
	// Content of the track (audio, video, or text).
	SetContent(FrameContent) TrackInfo
	// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
	// Higher frame rates capture more images per second, which makes for smoother video.
	// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
	// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
	// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
	// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
	// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
	FPS() *float64
	// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
	// Higher frame rates capture more images per second, which makes for smoother video.
	// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
	// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
	// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
	// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
	// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
	SetFPS(float64) TrackInfo
	// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
	// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
	// However, sometimes (when the connection is broken) video breakups are possible.
	// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
	// This situation is considered as a frame gap and is handled differently across different protocols.
	// Format: ticks (ticks)
	FrameDuration() *Ticks
	// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
	// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
	// However, sometimes (when the connection is broken) video breakups are possible.
	// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
	// This situation is considered as a frame gap and is handled differently across different protocols.
	// Format: ticks (ticks)
	SetFrameDuration(Ticks) TrackInfo
	// The number of frames in a group of pictures (GOP).
	// The encoder will create all GOPs of an exactly identical size - as specified in this option.
	// A bigger GOP can be good for video compression but it can result in big zap-time (the duration of time between changing a channel and displaying a new channel.)
	GopSize() *int
	// The number of frames in a group of pictures (GOP).
	// The encoder will create all GOPs of an exactly identical size - as specified in this option.
	// A bigger GOP can be good for video compression but it can result in big zap-time (the duration of time between changing a channel and displaying a new channel.)
	SetGopSize(int) TrackInfo
	// The picture height in pixels on the display where it will be played by a player.
	// If you need to insert a web-player into a web page, use this value for choosing the player size.
	// Format: pixels (pixels)
	Height() *Pixels
	// The picture height in pixels on the display where it will be played by a player.
	// If you need to insert a web-player into a web page, use this value for choosing the player size.
	// Format: pixels (pixels)
	SetHeight(Pixels) TrackInfo
	// Indicates if progressive scanning method is used for all frames of the track
	IsProgressive() *bool
	// Indicates if progressive scanning method is used for all frames of the track
	SetIsProgressive(bool) TrackInfo
	// Language value of the track, if applicable.
	// Example: eng
	Language() *string
	// Language value of the track, if applicable.
	// Example: eng
	SetLanguage(string) TrackInfo
	// Last GOP size (expressed in number of frames).
	// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
	// If this value is floating, this means that your transcoder is working in a flexible GOP size mode and some players may have problems.
	// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
	// Example: 28
	LastGop() *int
	// Last GOP size (expressed in number of frames).
	// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
	// If this value is floating, this means that your transcoder is working in a flexible GOP size mode and some players may have problems.
	// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
	// Example: 28
	SetLastGop(int) TrackInfo
	// The size of the length field for H264 bitstream without start codes.
	LengthSize() *int
	// The size of the length field for H264 bitstream without start codes.
	SetLengthSize(int) TrackInfo
	// A set of constraints that indicate a degree of required decoder performance.
	// This parameter is used for compatibility with old devices.
	Level() *string
	// A set of constraints that indicate a degree of required decoder performance.
	// This parameter is used for compatibility with old devices.
	SetLevel(string) TrackInfo
	// The number of I-frames to be used for encoding.
	NumRefsFrames() *int
	// The number of I-frames to be used for encoding.
	SetNumRefsFrames(int) TrackInfo
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	Pid() *int
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	SetPid(int) TrackInfo
	// The color model of the video.
	PixFmt() *FrameVideoPixFmt
	// The color model of the video.
	SetPixFmt(FrameVideoPixFmt) TrackInfo
	// The picture width in pixels of the original video before transcoding.
	// Format: pixels (pixels)
	PixelHeight() *Pixels
	// The picture width in pixels of the original video before transcoding.
	// Format: pixels (pixels)
	SetPixelHeight(Pixels) TrackInfo
	// The picture width in pixels of the original video before transcoding.
	// Format: pixels (pixels)
	PixelWidth() *Pixels
	// The picture width in pixels of the original video before transcoding.
	// Format: pixels (pixels)
	SetPixelWidth(Pixels) TrackInfo
	// A specific codec-dependent profile of the output video.
	// The profile allows to assume if the track can be played on a particular device.
	Profile() *string
	// A specific codec-dependent profile of the output video.
	// The profile allows to assume if the track can be played on a particular device.
	SetProfile(string) TrackInfo
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// Example: 8000
	SampleRate() *int
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// Example: 8000
	SetSampleRate(int) TrackInfo
	// The second number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
	// SAR is used for creating non-anamorphic video from anamorphic video.
	SarHeight() *int
	// The second number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
	// SAR is used for creating non-anamorphic video from anamorphic video.
	SetSarHeight(int) TrackInfo
	// The first number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
	// SAR is used for creating non-anamorphic video from anamorphic video.
	SarWidth() *int
	// The first number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
	// SAR is used for creating non-anamorphic video from anamorphic video.
	SetSarWidth(int) TrackInfo
	// Human-readable localized title of the track.
	// Example: Video1
	Title() *string
	// Human-readable localized title of the track.
	// Example: Video1
	SetTitle(string) TrackInfo
	// Track identifier assigned by Flussonic.
	// Example: v1
	TrackID() any
	// Track identifier assigned by Flussonic.
	// Example: v1
	SetTrackID(any) TrackInfo
	// The picture width in pixels on the display where it will be played by a player.
	// If you need to insert a web-player into a web page, use this value for choosing the player size.
	// Format: pixels (pixels)
	Width() *Pixels
	// The picture width in pixels on the display where it will be played by a player.
	// If you need to insert a web-player into a web page, use this value for choosing the player size.
	// Format: pixels (pixels)
	SetWidth(Pixels) TrackInfo
}

type TrackInfoApplication interface {
	// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
	// The higher FPS is, the smoother the video playback is.
	// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
	AvgFPS() *float64
	// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
	// The higher FPS is, the smoother the video playback is.
	// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
	SetAvgFPS(float64) TrackInfoApplication
	// Bandwidth necessary to transfer this track.
	// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
	// Format: speed (speed)
	// Example: 2600
	Bandwidth() *Speed
	// Bandwidth necessary to transfer this track.
	// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
	// Format: speed (speed)
	// Example: 2600
	SetBandwidth(Speed) TrackInfoApplication
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	Bitrate() *Speed
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	SetBitrate(Speed) TrackInfoApplication
	// Codec of the track. Different codecs do **not** get the same track.
	// Example: h264
	Codec() *FrameCodec
	// Codec of the track. Different codecs do **not** get the same track.
	// Example: h264
	SetCodec(FrameCodec) TrackInfoApplication
	// Content of the track (audio, video, or text).
	Content() FrameContent
	// Content of the track (audio, video, or text).
	SetContent(FrameContent) TrackInfoApplication
	// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
	// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
	// However, sometimes (when the connection is broken) video breakups are possible.
	// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
	// This situation is considered as a frame gap and is handled differently across different protocols.
	// Format: ticks (ticks)
	FrameDuration() *Ticks
	// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
	// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
	// However, sometimes (when the connection is broken) video breakups are possible.
	// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
	// This situation is considered as a frame gap and is handled differently across different protocols.
	// Format: ticks (ticks)
	SetFrameDuration(Ticks) TrackInfoApplication
	// Language value of the track, if applicable.
	// Example: eng
	Language() *string
	// Language value of the track, if applicable.
	// Example: eng
	SetLanguage(string) TrackInfoApplication
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	Pid() *int
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	SetPid(int) TrackInfoApplication
	// Human-readable localized title of the track.
	// Example: Video1
	Title() *string
	// Human-readable localized title of the track.
	// Example: Video1
	SetTitle(string) TrackInfoApplication
	// Track identifier assigned by Flussonic.
	// Example: v1
	TrackID() any
	// Track identifier assigned by Flussonic.
	// Example: v1
	SetTrackID(any) TrackInfoApplication
}

type TrackInfoApplicationSpecific interface {
	// Language value of the track, if applicable.
	// Example: eng
	Language() *string
	// Language value of the track, if applicable.
	// Example: eng
	SetLanguage(string) TrackInfoApplicationSpecific
}

type TrackInfoAudio interface {
	// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
	// The higher FPS is, the smoother the video playback is.
	// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
	AvgFPS() *float64
	// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
	// The higher FPS is, the smoother the video playback is.
	// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
	SetAvgFPS(float64) TrackInfoAudio
	// Bandwidth necessary to transfer this track.
	// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
	// Format: speed (speed)
	// Example: 2600
	Bandwidth() *Speed
	// Bandwidth necessary to transfer this track.
	// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
	// Format: speed (speed)
	// Example: 2600
	SetBandwidth(Speed) TrackInfoAudio
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	Bitrate() *Speed
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	SetBitrate(Speed) TrackInfoAudio
	// The number of audio channels.
	// Example: 2
	Channels() *int
	// The number of audio channels.
	// Example: 2
	SetChannels(int) TrackInfoAudio
	// Codec of the track. Different codecs do **not** get the same track.
	// Example: h264
	Codec() *FrameCodec
	// Codec of the track. Different codecs do **not** get the same track.
	// Example: h264
	SetCodec(FrameCodec) TrackInfoAudio
	// Content of the track (audio, video, or text).
	Content() FrameContent
	// Content of the track (audio, video, or text).
	SetContent(FrameContent) TrackInfoAudio
	// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
	// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
	// However, sometimes (when the connection is broken) video breakups are possible.
	// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
	// This situation is considered as a frame gap and is handled differently across different protocols.
	// Format: ticks (ticks)
	FrameDuration() *Ticks
	// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
	// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
	// However, sometimes (when the connection is broken) video breakups are possible.
	// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
	// This situation is considered as a frame gap and is handled differently across different protocols.
	// Format: ticks (ticks)
	SetFrameDuration(Ticks) TrackInfoAudio
	// Language value of the track, if applicable.
	// Example: eng
	Language() *string
	// Language value of the track, if applicable.
	// Example: eng
	SetLanguage(string) TrackInfoAudio
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	Pid() *int
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	SetPid(int) TrackInfoAudio
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// Example: 8000
	SampleRate() *int
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// Example: 8000
	SetSampleRate(int) TrackInfoAudio
	// Human-readable localized title of the track.
	// Example: Video1
	Title() *string
	// Human-readable localized title of the track.
	// Example: Video1
	SetTitle(string) TrackInfoAudio
	// Track identifier assigned by Flussonic.
	// Example: v1
	TrackID() any
	// Track identifier assigned by Flussonic.
	// Example: v1
	SetTrackID(any) TrackInfoAudio
}

type TrackInfoAudioSpecific interface {
	// The number of audio channels.
	// Example: 2
	Channels() *int
	// The number of audio channels.
	// Example: 2
	SetChannels(int) TrackInfoAudioSpecific
	// Language value of the track, if applicable.
	// Example: eng
	Language() *string
	// Language value of the track, if applicable.
	// Example: eng
	SetLanguage(string) TrackInfoAudioSpecific
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// Example: 8000
	SampleRate() *int
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// Example: 8000
	SetSampleRate(int) TrackInfoAudioSpecific
}

type TrackInfoBase interface {
	// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
	// The higher FPS is, the smoother the video playback is.
	// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
	AvgFPS() *float64
	// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
	// The higher FPS is, the smoother the video playback is.
	// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
	SetAvgFPS(float64) TrackInfoBase
	// Bandwidth necessary to transfer this track.
	// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
	// Format: speed (speed)
	// Example: 2600
	Bandwidth() *Speed
	// Bandwidth necessary to transfer this track.
	// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
	// Format: speed (speed)
	// Example: 2600
	SetBandwidth(Speed) TrackInfoBase
	// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
	// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
	// However, sometimes (when the connection is broken) video breakups are possible.
	// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
	// This situation is considered as a frame gap and is handled differently across different protocols.
	// Format: ticks (ticks)
	FrameDuration() *Ticks
	// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
	// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
	// However, sometimes (when the connection is broken) video breakups are possible.
	// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
	// This situation is considered as a frame gap and is handled differently across different protocols.
	// Format: ticks (ticks)
	SetFrameDuration(Ticks) TrackInfoBase
	// Track identifier assigned by Flussonic.
	// Example: v1
	TrackID() any
	// Track identifier assigned by Flussonic.
	// Example: v1
	SetTrackID(any) TrackInfoBase
}

// Required: content
type TrackInfoBaseConfigurable interface {
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	Bitrate() *Speed
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	SetBitrate(Speed) TrackInfoBaseConfigurable
	// Content of the track (audio, video, or text).
	Content() FrameContent
	// Content of the track (audio, video, or text).
	SetContent(FrameContent) TrackInfoBaseConfigurable
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	Pid() *int
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	SetPid(int) TrackInfoBaseConfigurable
	// Human-readable localized title of the track.
	// Example: Video1
	Title() *string
	// Human-readable localized title of the track.
	// Example: Video1
	SetTitle(string) TrackInfoBaseConfigurable
}

type TrackInfoFull interface {
	// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
	// The higher FPS is, the smoother the video playback is.
	// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
	AvgFPS() *float64
	// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
	// The higher FPS is, the smoother the video playback is.
	// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
	SetAvgFPS(float64) TrackInfoFull
	// Average GOP size (expressed in number of frames) of the last 1000-2000 frames.
	// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
	// If this value is floating, this means that your transcoder is working in flexible GOP size mode and some players may have problems.
	// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
	// Example: 25
	AvgGop() *int
	// Average GOP size (expressed in number of frames) of the last 1000-2000 frames.
	// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
	// If this value is floating, this means that your transcoder is working in flexible GOP size mode and some players may have problems.
	// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
	// Example: 25
	SetAvgGop(int) TrackInfoFull
	// Bandwidth necessary to transfer this track.
	// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
	// Format: speed (speed)
	// Example: 2600
	Bandwidth() *Speed
	// Bandwidth necessary to transfer this track.
	// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
	// Format: speed (speed)
	// Example: 2600
	SetBandwidth(Speed) TrackInfoFull
	// Average number of B-frames in a GOP. B-frames contain links to keyframes and P-frames before and after themselves.
	// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
	// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
	// Example: 3
	Bframes() *int
	// Average number of B-frames in a GOP. B-frames contain links to keyframes and P-frames before and after themselves.
	// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
	// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
	// Example: 3
	SetBframes(int) TrackInfoFull
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	Bitrate() *Speed
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	SetBitrate(Speed) TrackInfoFull
	// The number of audio channels.
	// Example: 2
	Channels() *int
	// The number of audio channels.
	// Example: 2
	SetChannels(int) TrackInfoFull
	// Parameters of closed captions.
	ClosedCaptions() []ClosedCaptions
	// Parameters of closed captions.
	SetClosedCaptions([]ClosedCaptions) TrackInfoFull
	// Codec of the track. Different codecs do **not** get the same track.
	// Example: h264
	Codec() *FrameCodec
	// Codec of the track. Different codecs do **not** get the same track.
	// Example: h264
	SetCodec(FrameCodec) TrackInfoFull
	// Content of the track (audio, video, or text).
	Content() FrameContent
	// Content of the track (audio, video, or text).
	SetContent(FrameContent) TrackInfoFull
	// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
	// Higher frame rates capture more images per second, which makes for smoother video.
	// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
	// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
	// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
	// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
	// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
	FPS() *float64
	// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
	// Higher frame rates capture more images per second, which makes for smoother video.
	// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
	// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
	// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
	// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
	// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
	SetFPS(float64) TrackInfoFull
	// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
	// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
	// However, sometimes (when the connection is broken) video breakups are possible.
	// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
	// This situation is considered as a frame gap and is handled differently across different protocols.
	// Format: ticks (ticks)
	FrameDuration() *Ticks
	// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
	// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
	// However, sometimes (when the connection is broken) video breakups are possible.
	// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
	// This situation is considered as a frame gap and is handled differently across different protocols.
	// Format: ticks (ticks)
	SetFrameDuration(Ticks) TrackInfoFull
	// The number of frames in a group of pictures (GOP).
	// The encoder will create all GOPs of an exactly identical size - as specified in this option.
	// A bigger GOP can be good for video compression but it can result in big zap-time (the duration of time between changing a channel and displaying a new channel.)
	GopSize() *int
	// The number of frames in a group of pictures (GOP).
	// The encoder will create all GOPs of an exactly identical size - as specified in this option.
	// A bigger GOP can be good for video compression but it can result in big zap-time (the duration of time between changing a channel and displaying a new channel.)
	SetGopSize(int) TrackInfoFull
	// The picture height in pixels on the display where it will be played by a player.
	// If you need to insert a web-player into a web page, use this value for choosing the player size.
	// Format: pixels (pixels)
	Height() *Pixels
	// The picture height in pixels on the display where it will be played by a player.
	// If you need to insert a web-player into a web page, use this value for choosing the player size.
	// Format: pixels (pixels)
	SetHeight(Pixels) TrackInfoFull
	// Indicates if progressive scanning method is used for all frames of the track
	IsProgressive() *bool
	// Indicates if progressive scanning method is used for all frames of the track
	SetIsProgressive(bool) TrackInfoFull
	// Language value of the track, if applicable.
	// Example: eng
	Language() *string
	// Language value of the track, if applicable.
	// Example: eng
	SetLanguage(string) TrackInfoFull
	// Last GOP size (expressed in number of frames).
	// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
	// If this value is floating, this means that your transcoder is working in a flexible GOP size mode and some players may have problems.
	// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
	// Example: 28
	LastGop() *int
	// Last GOP size (expressed in number of frames).
	// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
	// If this value is floating, this means that your transcoder is working in a flexible GOP size mode and some players may have problems.
	// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
	// Example: 28
	SetLastGop(int) TrackInfoFull
	// The size of the length field for H264 bitstream without start codes.
	LengthSize() *int
	// The size of the length field for H264 bitstream without start codes.
	SetLengthSize(int) TrackInfoFull
	// A set of constraints that indicate a degree of required decoder performance.
	// This parameter is used for compatibility with old devices.
	Level() *string
	// A set of constraints that indicate a degree of required decoder performance.
	// This parameter is used for compatibility with old devices.
	SetLevel(string) TrackInfoFull
	// The number of I-frames to be used for encoding.
	NumRefsFrames() *int
	// The number of I-frames to be used for encoding.
	SetNumRefsFrames(int) TrackInfoFull
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	Pid() *int
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	SetPid(int) TrackInfoFull
	// The color model of the video.
	PixFmt() *FrameVideoPixFmt
	// The color model of the video.
	SetPixFmt(FrameVideoPixFmt) TrackInfoFull
	// The picture width in pixels of the original video before transcoding.
	// Format: pixels (pixels)
	PixelHeight() *Pixels
	// The picture width in pixels of the original video before transcoding.
	// Format: pixels (pixels)
	SetPixelHeight(Pixels) TrackInfoFull
	// The picture width in pixels of the original video before transcoding.
	// Format: pixels (pixels)
	PixelWidth() *Pixels
	// The picture width in pixels of the original video before transcoding.
	// Format: pixels (pixels)
	SetPixelWidth(Pixels) TrackInfoFull
	// A specific codec-dependent profile of the output video.
	// The profile allows to assume if the track can be played on a particular device.
	Profile() *string
	// A specific codec-dependent profile of the output video.
	// The profile allows to assume if the track can be played on a particular device.
	SetProfile(string) TrackInfoFull
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// Example: 8000
	SampleRate() *int
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// Example: 8000
	SetSampleRate(int) TrackInfoFull
	// The second number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
	// SAR is used for creating non-anamorphic video from anamorphic video.
	SarHeight() *int
	// The second number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
	// SAR is used for creating non-anamorphic video from anamorphic video.
	SetSarHeight(int) TrackInfoFull
	// The first number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
	// SAR is used for creating non-anamorphic video from anamorphic video.
	SarWidth() *int
	// The first number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
	// SAR is used for creating non-anamorphic video from anamorphic video.
	SetSarWidth(int) TrackInfoFull
	// Human-readable localized title of the track.
	// Example: Video1
	Title() *string
	// Human-readable localized title of the track.
	// Example: Video1
	SetTitle(string) TrackInfoFull
	// Track identifier assigned by Flussonic.
	// Example: v1
	TrackID() any
	// Track identifier assigned by Flussonic.
	// Example: v1
	SetTrackID(any) TrackInfoFull
	// The picture width in pixels on the display where it will be played by a player.
	// If you need to insert a web-player into a web page, use this value for choosing the player size.
	// Format: pixels (pixels)
	Width() *Pixels
	// The picture width in pixels on the display where it will be played by a player.
	// If you need to insert a web-player into a web page, use this value for choosing the player size.
	// Format: pixels (pixels)
	SetWidth(Pixels) TrackInfoFull
}

type TrackInfoMetadata interface {
	// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
	// The higher FPS is, the smoother the video playback is.
	// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
	AvgFPS() *float64
	// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
	// The higher FPS is, the smoother the video playback is.
	// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
	SetAvgFPS(float64) TrackInfoMetadata
	// Bandwidth necessary to transfer this track.
	// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
	// Format: speed (speed)
	// Example: 2600
	Bandwidth() *Speed
	// Bandwidth necessary to transfer this track.
	// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
	// Format: speed (speed)
	// Example: 2600
	SetBandwidth(Speed) TrackInfoMetadata
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	Bitrate() *Speed
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	SetBitrate(Speed) TrackInfoMetadata
	// Codec of the track. Different codecs do **not** get the same track.
	// Example: h264
	Codec() *FrameCodec
	// Codec of the track. Different codecs do **not** get the same track.
	// Example: h264
	SetCodec(FrameCodec) TrackInfoMetadata
	// Content of the track (audio, video, or text).
	Content() FrameContent
	// Content of the track (audio, video, or text).
	SetContent(FrameContent) TrackInfoMetadata
	// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
	// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
	// However, sometimes (when the connection is broken) video breakups are possible.
	// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
	// This situation is considered as a frame gap and is handled differently across different protocols.
	// Format: ticks (ticks)
	FrameDuration() *Ticks
	// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
	// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
	// However, sometimes (when the connection is broken) video breakups are possible.
	// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
	// This situation is considered as a frame gap and is handled differently across different protocols.
	// Format: ticks (ticks)
	SetFrameDuration(Ticks) TrackInfoMetadata
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	Pid() *int
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	SetPid(int) TrackInfoMetadata
	// Human-readable localized title of the track.
	// Example: Video1
	Title() *string
	// Human-readable localized title of the track.
	// Example: Video1
	SetTitle(string) TrackInfoMetadata
	// Track identifier assigned by Flussonic.
	// Example: v1
	TrackID() any
	// Track identifier assigned by Flussonic.
	// Example: v1
	SetTrackID(any) TrackInfoMetadata
}

type TrackInfoText interface {
	// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
	// The higher FPS is, the smoother the video playback is.
	// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
	AvgFPS() *float64
	// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
	// The higher FPS is, the smoother the video playback is.
	// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
	SetAvgFPS(float64) TrackInfoText
	// Bandwidth necessary to transfer this track.
	// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
	// Format: speed (speed)
	// Example: 2600
	Bandwidth() *Speed
	// Bandwidth necessary to transfer this track.
	// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
	// Format: speed (speed)
	// Example: 2600
	SetBandwidth(Speed) TrackInfoText
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	Bitrate() *Speed
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	SetBitrate(Speed) TrackInfoText
	// Codec of the track. Different codecs do **not** get the same track.
	// Example: h264
	Codec() *FrameCodec
	// Codec of the track. Different codecs do **not** get the same track.
	// Example: h264
	SetCodec(FrameCodec) TrackInfoText
	// Content of the track (audio, video, or text).
	Content() FrameContent
	// Content of the track (audio, video, or text).
	SetContent(FrameContent) TrackInfoText
	// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
	// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
	// However, sometimes (when the connection is broken) video breakups are possible.
	// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
	// This situation is considered as a frame gap and is handled differently across different protocols.
	// Format: ticks (ticks)
	FrameDuration() *Ticks
	// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
	// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
	// However, sometimes (when the connection is broken) video breakups are possible.
	// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
	// This situation is considered as a frame gap and is handled differently across different protocols.
	// Format: ticks (ticks)
	SetFrameDuration(Ticks) TrackInfoText
	// Language value of the track, if applicable.
	// Example: eng
	Language() *string
	// Language value of the track, if applicable.
	// Example: eng
	SetLanguage(string) TrackInfoText
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	Pid() *int
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	SetPid(int) TrackInfoText
	// Human-readable localized title of the track.
	// Example: Video1
	Title() *string
	// Human-readable localized title of the track.
	// Example: Video1
	SetTitle(string) TrackInfoText
	// Track identifier assigned by Flussonic.
	// Example: v1
	TrackID() any
	// Track identifier assigned by Flussonic.
	// Example: v1
	SetTrackID(any) TrackInfoText
}

type TrackInfoTextSpecific interface {
	// Language value of the track, if applicable.
	// Example: eng
	Language() *string
	// Language value of the track, if applicable.
	// Example: eng
	SetLanguage(string) TrackInfoTextSpecific
}

type TrackInfoVideo interface {
	// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
	// The higher FPS is, the smoother the video playback is.
	// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
	AvgFPS() *float64
	// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
	// The higher FPS is, the smoother the video playback is.
	// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
	SetAvgFPS(float64) TrackInfoVideo
	// Average GOP size (expressed in number of frames) of the last 1000-2000 frames.
	// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
	// If this value is floating, this means that your transcoder is working in flexible GOP size mode and some players may have problems.
	// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
	// Example: 25
	AvgGop() *int
	// Average GOP size (expressed in number of frames) of the last 1000-2000 frames.
	// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
	// If this value is floating, this means that your transcoder is working in flexible GOP size mode and some players may have problems.
	// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
	// Example: 25
	SetAvgGop(int) TrackInfoVideo
	// Bandwidth necessary to transfer this track.
	// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
	// Format: speed (speed)
	// Example: 2600
	Bandwidth() *Speed
	// Bandwidth necessary to transfer this track.
	// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
	// Format: speed (speed)
	// Example: 2600
	SetBandwidth(Speed) TrackInfoVideo
	// Average number of B-frames in a GOP. B-frames contain links to keyframes and P-frames before and after themselves.
	// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
	// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
	// Example: 3
	Bframes() *int
	// Average number of B-frames in a GOP. B-frames contain links to keyframes and P-frames before and after themselves.
	// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
	// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
	// Example: 3
	SetBframes(int) TrackInfoVideo
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	Bitrate() *Speed
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	SetBitrate(Speed) TrackInfoVideo
	// Parameters of closed captions.
	ClosedCaptions() []ClosedCaptions
	// Parameters of closed captions.
	SetClosedCaptions([]ClosedCaptions) TrackInfoVideo
	// Codec of the track. Different codecs do **not** get the same track.
	// Example: h264
	Codec() *FrameCodec
	// Codec of the track. Different codecs do **not** get the same track.
	// Example: h264
	SetCodec(FrameCodec) TrackInfoVideo
	// Content of the track (audio, video, or text).
	Content() FrameContent
	// Content of the track (audio, video, or text).
	SetContent(FrameContent) TrackInfoVideo
	// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
	// Higher frame rates capture more images per second, which makes for smoother video.
	// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
	// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
	// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
	// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
	// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
	FPS() *float64
	// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
	// Higher frame rates capture more images per second, which makes for smoother video.
	// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
	// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
	// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
	// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
	// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
	SetFPS(float64) TrackInfoVideo
	// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
	// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
	// However, sometimes (when the connection is broken) video breakups are possible.
	// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
	// This situation is considered as a frame gap and is handled differently across different protocols.
	// Format: ticks (ticks)
	FrameDuration() *Ticks
	// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
	// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
	// However, sometimes (when the connection is broken) video breakups are possible.
	// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
	// This situation is considered as a frame gap and is handled differently across different protocols.
	// Format: ticks (ticks)
	SetFrameDuration(Ticks) TrackInfoVideo
	// The number of frames in a group of pictures (GOP).
	// The encoder will create all GOPs of an exactly identical size - as specified in this option.
	// A bigger GOP can be good for video compression but it can result in big zap-time (the duration of time between changing a channel and displaying a new channel.)
	GopSize() *int
	// The number of frames in a group of pictures (GOP).
	// The encoder will create all GOPs of an exactly identical size - as specified in this option.
	// A bigger GOP can be good for video compression but it can result in big zap-time (the duration of time between changing a channel and displaying a new channel.)
	SetGopSize(int) TrackInfoVideo
	// The picture height in pixels on the display where it will be played by a player.
	// If you need to insert a web-player into a web page, use this value for choosing the player size.
	// Format: pixels (pixels)
	Height() *Pixels
	// The picture height in pixels on the display where it will be played by a player.
	// If you need to insert a web-player into a web page, use this value for choosing the player size.
	// Format: pixels (pixels)
	SetHeight(Pixels) TrackInfoVideo
	// Indicates if progressive scanning method is used for all frames of the track
	IsProgressive() *bool
	// Indicates if progressive scanning method is used for all frames of the track
	SetIsProgressive(bool) TrackInfoVideo
	// Last GOP size (expressed in number of frames).
	// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
	// If this value is floating, this means that your transcoder is working in a flexible GOP size mode and some players may have problems.
	// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
	// Example: 28
	LastGop() *int
	// Last GOP size (expressed in number of frames).
	// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
	// If this value is floating, this means that your transcoder is working in a flexible GOP size mode and some players may have problems.
	// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
	// Example: 28
	SetLastGop(int) TrackInfoVideo
	// The size of the length field for H264 bitstream without start codes.
	LengthSize() *int
	// The size of the length field for H264 bitstream without start codes.
	SetLengthSize(int) TrackInfoVideo
	// A set of constraints that indicate a degree of required decoder performance.
	// This parameter is used for compatibility with old devices.
	Level() *string
	// A set of constraints that indicate a degree of required decoder performance.
	// This parameter is used for compatibility with old devices.
	SetLevel(string) TrackInfoVideo
	// The number of I-frames to be used for encoding.
	NumRefsFrames() *int
	// The number of I-frames to be used for encoding.
	SetNumRefsFrames(int) TrackInfoVideo
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	Pid() *int
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	SetPid(int) TrackInfoVideo
	// The color model of the video.
	PixFmt() *FrameVideoPixFmt
	// The color model of the video.
	SetPixFmt(FrameVideoPixFmt) TrackInfoVideo
	// The picture width in pixels of the original video before transcoding.
	// Format: pixels (pixels)
	PixelHeight() *Pixels
	// The picture width in pixels of the original video before transcoding.
	// Format: pixels (pixels)
	SetPixelHeight(Pixels) TrackInfoVideo
	// The picture width in pixels of the original video before transcoding.
	// Format: pixels (pixels)
	PixelWidth() *Pixels
	// The picture width in pixels of the original video before transcoding.
	// Format: pixels (pixels)
	SetPixelWidth(Pixels) TrackInfoVideo
	// A specific codec-dependent profile of the output video.
	// The profile allows to assume if the track can be played on a particular device.
	Profile() *string
	// A specific codec-dependent profile of the output video.
	// The profile allows to assume if the track can be played on a particular device.
	SetProfile(string) TrackInfoVideo
	// The second number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
	// SAR is used for creating non-anamorphic video from anamorphic video.
	SarHeight() *int
	// The second number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
	// SAR is used for creating non-anamorphic video from anamorphic video.
	SetSarHeight(int) TrackInfoVideo
	// The first number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
	// SAR is used for creating non-anamorphic video from anamorphic video.
	SarWidth() *int
	// The first number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
	// SAR is used for creating non-anamorphic video from anamorphic video.
	SetSarWidth(int) TrackInfoVideo
	// Human-readable localized title of the track.
	// Example: Video1
	Title() *string
	// Human-readable localized title of the track.
	// Example: Video1
	SetTitle(string) TrackInfoVideo
	// Track identifier assigned by Flussonic.
	// Example: v1
	TrackID() any
	// Track identifier assigned by Flussonic.
	// Example: v1
	SetTrackID(any) TrackInfoVideo
	// The picture width in pixels on the display where it will be played by a player.
	// If you need to insert a web-player into a web page, use this value for choosing the player size.
	// Format: pixels (pixels)
	Width() *Pixels
	// The picture width in pixels on the display where it will be played by a player.
	// If you need to insert a web-player into a web page, use this value for choosing the player size.
	// Format: pixels (pixels)
	SetWidth(Pixels) TrackInfoVideo
}

type TrackInfoVideoConfigurable interface {
	// Average number of B-frames in a GOP. B-frames contain links to keyframes and P-frames before and after themselves.
	// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
	// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
	// Example: 3
	Bframes() *int
	// Average number of B-frames in a GOP. B-frames contain links to keyframes and P-frames before and after themselves.
	// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
	// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
	// Example: 3
	SetBframes(int) TrackInfoVideoConfigurable
	// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
	// Higher frame rates capture more images per second, which makes for smoother video.
	// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
	// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
	// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
	// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
	// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
	FPS() *float64
	// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
	// Higher frame rates capture more images per second, which makes for smoother video.
	// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
	// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
	// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
	// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
	// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
	SetFPS(float64) TrackInfoVideoConfigurable
	// The number of frames in a group of pictures (GOP).
	// The encoder will create all GOPs of an exactly identical size - as specified in this option.
	// A bigger GOP can be good for video compression but it can result in big zap-time (the duration of time between changing a channel and displaying a new channel.)
	GopSize() *int
	// The number of frames in a group of pictures (GOP).
	// The encoder will create all GOPs of an exactly identical size - as specified in this option.
	// A bigger GOP can be good for video compression but it can result in big zap-time (the duration of time between changing a channel and displaying a new channel.)
	SetGopSize(int) TrackInfoVideoConfigurable
	// The picture height in pixels on the display where it will be played by a player.
	// If you need to insert a web-player into a web page, use this value for choosing the player size.
	// Format: pixels (pixels)
	Height() *Pixels
	// The picture height in pixels on the display where it will be played by a player.
	// If you need to insert a web-player into a web page, use this value for choosing the player size.
	// Format: pixels (pixels)
	SetHeight(Pixels) TrackInfoVideoConfigurable
	// A set of constraints that indicate a degree of required decoder performance.
	// This parameter is used for compatibility with old devices.
	Level() *string
	// A set of constraints that indicate a degree of required decoder performance.
	// This parameter is used for compatibility with old devices.
	SetLevel(string) TrackInfoVideoConfigurable
	// The number of I-frames to be used for encoding.
	NumRefsFrames() *int
	// The number of I-frames to be used for encoding.
	SetNumRefsFrames(int) TrackInfoVideoConfigurable
	// The color model of the video.
	PixFmt() *FrameVideoPixFmt
	// The color model of the video.
	SetPixFmt(FrameVideoPixFmt) TrackInfoVideoConfigurable
	// The picture width in pixels of the original video before transcoding.
	// Format: pixels (pixels)
	PixelHeight() *Pixels
	// The picture width in pixels of the original video before transcoding.
	// Format: pixels (pixels)
	SetPixelHeight(Pixels) TrackInfoVideoConfigurable
	// The picture width in pixels of the original video before transcoding.
	// Format: pixels (pixels)
	PixelWidth() *Pixels
	// The picture width in pixels of the original video before transcoding.
	// Format: pixels (pixels)
	SetPixelWidth(Pixels) TrackInfoVideoConfigurable
	// A specific codec-dependent profile of the output video.
	// The profile allows to assume if the track can be played on a particular device.
	Profile() *string
	// A specific codec-dependent profile of the output video.
	// The profile allows to assume if the track can be played on a particular device.
	SetProfile(string) TrackInfoVideoConfigurable
	// The second number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
	// SAR is used for creating non-anamorphic video from anamorphic video.
	SarHeight() *int
	// The second number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
	// SAR is used for creating non-anamorphic video from anamorphic video.
	SetSarHeight(int) TrackInfoVideoConfigurable
	// The first number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
	// SAR is used for creating non-anamorphic video from anamorphic video.
	SarWidth() *int
	// The first number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
	// SAR is used for creating non-anamorphic video from anamorphic video.
	SetSarWidth(int) TrackInfoVideoConfigurable
	// The picture width in pixels on the display where it will be played by a player.
	// If you need to insert a web-player into a web page, use this value for choosing the player size.
	// Format: pixels (pixels)
	Width() *Pixels
	// The picture width in pixels on the display where it will be played by a player.
	// If you need to insert a web-player into a web page, use this value for choosing the player size.
	// Format: pixels (pixels)
	SetWidth(Pixels) TrackInfoVideoConfigurable
}

type TrackInfoVideoSpecific interface {
	// Average GOP size (expressed in number of frames) of the last 1000-2000 frames.
	// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
	// If this value is floating, this means that your transcoder is working in flexible GOP size mode and some players may have problems.
	// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
	// Example: 25
	AvgGop() *int
	// Average GOP size (expressed in number of frames) of the last 1000-2000 frames.
	// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
	// If this value is floating, this means that your transcoder is working in flexible GOP size mode and some players may have problems.
	// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
	// Example: 25
	SetAvgGop(int) TrackInfoVideoSpecific
	// Parameters of closed captions.
	ClosedCaptions() []ClosedCaptions
	// Parameters of closed captions.
	SetClosedCaptions([]ClosedCaptions) TrackInfoVideoSpecific
	// Indicates if progressive scanning method is used for all frames of the track
	IsProgressive() *bool
	// Indicates if progressive scanning method is used for all frames of the track
	SetIsProgressive(bool) TrackInfoVideoSpecific
	// Last GOP size (expressed in number of frames).
	// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
	// If this value is floating, this means that your transcoder is working in a flexible GOP size mode and some players may have problems.
	// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
	// Example: 28
	LastGop() *int
	// Last GOP size (expressed in number of frames).
	// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
	// If this value is floating, this means that your transcoder is working in a flexible GOP size mode and some players may have problems.
	// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
	// Example: 28
	SetLastGop(int) TrackInfoVideoSpecific
	// The size of the length field for H264 bitstream without start codes.
	LengthSize() *int
	// The size of the length field for H264 bitstream without start codes.
	SetLengthSize(int) TrackInfoVideoSpecific
}

type TranscoderDeviceStats interface {
	// Shows if the device can make an interlaced stream from a progressive one.
	CanInterlace() *bool
	// Shows if the device can make an interlaced stream from a progressive one.
	SetCanInterlace(bool) TranscoderDeviceStats
	// Shows if the transcoder with this device can run in the same process as Flussonic Media Server.
	CanInternal() *bool
	// Shows if the transcoder with this device can run in the same process as Flussonic Media Server.
	SetCanInternal(bool) TranscoderDeviceStats
	// Shows if the device can put a logo on the image.
	CanLogo() *bool
	// Shows if the device can put a logo on the image.
	SetCanLogo(bool) TranscoderDeviceStats
	// GPU decoder load percentage.
	GpuDec() *int
	// GPU decoder load percentage.
	SetGpuDec(int) TranscoderDeviceStats
	// GPU encoder load percentage.
	GpuEnc() *int
	// GPU encoder load percentage.
	SetGpuEnc(int) TranscoderDeviceStats
	// GPU shared memory amount.
	GpuSm() *int
	// GPU shared memory amount.
	SetGpuSm(int) TranscoderDeviceStats
	// GPU temperature, C.
	GpuTemp() *int
	// GPU temperature, C.
	SetGpuTemp(int) TranscoderDeviceStats
	// The ID of the device used for transcoding.
	// In PUT requests, you can use `auto` for Flussonic to set the ID itself.
	// In the response to GET requests, the `id` will always be a number.
	ID() *TcDeviceid
	// The ID of the device used for transcoding.
	// In PUT requests, you can use `auto` for Flussonic to set the ID itself.
	// In the response to GET requests, the `id` will always be a number.
	SetID(*TcDeviceid) TranscoderDeviceStats
	// Free RAM.
	Memfree() *int
	// Free RAM.
	SetMemfree(int) TranscoderDeviceStats
	// Total RAM on the device.
	Memtotal() *int
	// Total RAM on the device.
	SetMemtotal(int) TranscoderDeviceStats
	// Utilized RAM.
	Memused() *int
	// Utilized RAM.
	SetMemused(int) TranscoderDeviceStats
	// The name of the transcoder device.
	Name() *string
	// The name of the transcoder device.
	SetName(string) TranscoderDeviceStats
	// The ability of the device to be reconfigured online, i.e. without complete restart of the transcoder.
	// `full` means that both decoder and encoder can be reconfigured online.
	// `encoder` means that only encoder can be reconfigured online.
	// `decoder` means that only decoder can be reconfigured online.
	// `false` means that online reconfiguration is not supported.
	ReconfigSupport() *TcReconfigSupport
	// The ability of the device to be reconfigured online, i.e. without complete restart of the transcoder.
	// `full` means that both decoder and encoder can be reconfigured online.
	// `encoder` means that only encoder can be reconfigured online.
	// `decoder` means that only decoder can be reconfigured online.
	// `false` means that online reconfiguration is not supported.
	SetReconfigSupport(*TcReconfigSupport) TranscoderDeviceStats
	// The type of the device used for transcoding.
	// Example: cpu
	Type() *TranscoderDevice
	// The type of the device used for transcoding.
	// Example: cpu
	SetType(TranscoderDevice) TranscoderDeviceStats
}

type TranscoderOpts interface {
	// Deprecated field. Will be deleted at 23.09
	// List of audio tracks the stream audio track will be transcoded into.
	Audio() TcAudioOpts
	// Deprecated field. Will be deleted at 23.09
	// List of audio tracks the stream audio track will be transcoded into.
	SetAudio(TcAudioOpts) TranscoderOpts
	// Decoder settings to be used for transcoding.
	Decoder() TcDecoder
	// Decoder settings to be used for transcoding.
	SetDecoder(TcDecoder) TranscoderOpts
	// Transcoder settings to be used for transcoding.
	Global() TcGlobal
	// Transcoder settings to be used for transcoding.
	SetGlobal(TcGlobal) TranscoderOpts
	// Info on the tracks. In the case of iris-hal, the first video track must be
	// high-resolution track, second one (if present) must be lower-resolution
	Tracks() []TranscoderTrackInfo
	// Info on the tracks. In the case of iris-hal, the first video track must be
	// high-resolution track, second one (if present) must be lower-resolution
	SetTracks([]TranscoderTrackInfo) TranscoderOpts
	// Deprecated field. Will be deleted at 24.08
	// List of video tracks the stream video track will be transcoded into.
	Video() []TcVideoOpts
	// Deprecated field. Will be deleted at 24.08
	// List of video tracks the stream video track will be transcoded into.
	SetVideo([]TcVideoOpts) TranscoderOpts
}

type TranscoderTrackInfo interface {
	// The configuration of a logo added to the video track after the video was resized as specified in the `size` option.
	// This prevents the logo picture from stretching that might occur when the `logo` option is used.
	// You will need to prepare and specify a separate file with a logo for each size of the resulting video track.
	Alogo() TcLogo
	// The configuration of a logo added to the video track after the video was resized as specified in the `size` option.
	// This prevents the logo picture from stretching that might occur when the `logo` option is used.
	// You will need to prepare and specify a separate file with a logo for each size of the resulting video track.
	SetAlogo(TcLogo) TranscoderTrackInfo
	// Number of B-frames between I and P-frames. B-frames contain links to keyframes and P-frames before and after themselves.
	// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
	// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
	// When set to 0, this option disables b-frames. This may be necessary, for example, when broadcasting to RTSP.
	// Example: 3
	Bframes() *int
	// Number of B-frames between I and P-frames. B-frames contain links to keyframes and P-frames before and after themselves.
	// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
	// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
	// When set to 0, this option disables b-frames. This may be necessary, for example, when broadcasting to RTSP.
	// Example: 3
	SetBframes(int) TranscoderTrackInfo
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	Bitrate() *Speed
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	SetBitrate(Speed) TranscoderTrackInfo
	// Configuration of burn-in text, timestamp, or subtitles to video frames.
	Burn() TcBurn
	// Configuration of burn-in text, timestamp, or subtitles to video frames.
	SetBurn(TcBurn) TranscoderTrackInfo
	// Codec of the track. Different codecs do **not** get the same track.
	// Example: h264
	Codec() *FrameCodec
	// Codec of the track. Different codecs do **not** get the same track.
	// Example: h264
	SetCodec(FrameCodec) TranscoderTrackInfo
	// Content of the track (audio, video, or text).
	Content() FrameContent
	// Content of the track (audio, video, or text).
	SetContent(FrameContent) TranscoderTrackInfo
	// Some additional options.
	Extra() map[string]string
	// Some additional options.
	SetExtra(map[string]string) TranscoderTrackInfo
	// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
	// Higher frame rates capture more images per second, which makes for smoother video.
	// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
	// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
	// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
	// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
	// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
	FPS() *TcFPS
	// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
	// Higher frame rates capture more images per second, which makes for smoother video.
	// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
	// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
	// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
	// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
	// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
	SetFPS(*TcFPS) TranscoderTrackInfo
	// Sets the number of frames in a GOP.
	// The encoder will create all GOPs of an exactly identical size - as specified in this option.
	// Example: 150
	Gop() *int
	// Sets the number of frames in a GOP.
	// The encoder will create all GOPs of an exactly identical size - as specified in this option.
	// Example: 150
	SetGop(int) TranscoderTrackInfo
	// This parameter is used to get an interlaced stream from a progressive one.
	// The allowed values are `true` (interlaced video), `false` (progressive video), or one of the methods for producing interlaced video supported for the selected type of transcoder.
	Interlace() *InterlaceSettings
	// This parameter is used to get an interlaced stream from a progressive one.
	// The allowed values are `true` (interlaced video), `false` (progressive video), or one of the methods for producing interlaced video supported for the selected type of transcoder.
	SetInterlace(*InterlaceSettings) TranscoderTrackInfo
	// A set of constraints that indicate a degree of required decoder performance.
	// This parameter is used for compatibility with old devices.
	Level() any
	// A set of constraints that indicate a degree of required decoder performance.
	// This parameter is used for compatibility with old devices.
	SetLevel(any) TranscoderTrackInfo
	// The configuration of a logo "burned" into the video track.
	// The transcoder adds the logo before the video is resized as specified in the `size` option.
	// This means that the logo can be visibly stretched if the size was changed significantly.
	Logo() TcLogo
	// The configuration of a logo "burned" into the video track.
	// The transcoder adds the logo before the video is resized as specified in the `size` option.
	// This means that the logo can be visibly stretched if the size was changed significantly.
	SetLogo(TcLogo) TranscoderTrackInfo
	// Whether open GOP is used. Open GOP contains P-frames that refer to the frames before the keyframe.
	// It allows to decrease bitrate to 5-7%, but can result in breaking the picture.
	// Do not enable this option if the track will be played over segment-based protocols (HLS, DASH, etc.) because
	// absence of keyframes or IDR frames in the same segment with P-frames may prevent playback.
	// [Read more about tracks, GOP and segments](https://flussonic.com/doc/live-stream-internals/).
	OpenGop() *bool
	// Whether open GOP is used. Open GOP contains P-frames that refer to the frames before the keyframe.
	// It allows to decrease bitrate to 5-7%, but can result in breaking the picture.
	// Do not enable this option if the track will be played over segment-based protocols (HLS, DASH, etc.) because
	// absence of keyframes or IDR frames in the same segment with P-frames may prevent playback.
	// [Read more about tracks, GOP and segments](https://flussonic.com/doc/live-stream-internals/).
	SetOpenGop(bool) TranscoderTrackInfo
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	Pid() *int
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	SetPid(int) TranscoderTrackInfo
	// A set of values that determine a certain encoding speed, which influences a compression ratio.
	// A slower preset will provide better compression (compression is quality per file size).
	// Example: medium
	Preset() *TcPreset
	// A set of values that determine a certain encoding speed, which influences a compression ratio.
	// A slower preset will provide better compression (compression is quality per file size).
	// Example: medium
	SetPreset(TcPreset) TranscoderTrackInfo
	// Limits the output to a specific H.264 profile.
	Profile() *TcProfile
	// Limits the output to a specific H.264 profile.
	SetProfile(TcProfile) TranscoderTrackInfo
	// The ranges of the quantization parameter for different types of frames in a GOP.
	// Quantization is an algorithm used for video compression. It is based on fragmentation of video frames.
	// Increasing this parameter allows to improve the compression but may lower the picture quality.
	// Usually, these ranges are defined automatically by the transcoder, but for some types of transcoders it makes sense to set them manually.
	QpRange() TcQpRange
	// The ranges of the quantization parameter for different types of frames in a GOP.
	// Quantization is an algorithm used for video compression. It is based on fragmentation of video frames.
	// Increasing this parameter allows to improve the compression but may lower the picture quality.
	// Usually, these ranges are defined automatically by the transcoder, but for some types of transcoders it makes sense to set them manually.
	SetQpRange(TcQpRange) TranscoderTrackInfo
	// A method for creating output video with constant bitrate suitable for broadcasting to television networks.
	RcMethod() *RcMethod
	// A method for creating output video with constant bitrate suitable for broadcasting to television networks.
	SetRcMethod(RcMethod) TranscoderTrackInfo
	// The number of reference frames in a GOP.
	// Reference frames are frames of a compressed video that are used to define other frames (P-frames and B-frames).
	Refs() *int
	// The number of reference frames in a GOP.
	// Reference frames are frames of a compressed video that are used to define other frames (P-frames and B-frames).
	SetRefs(int) TranscoderTrackInfo
	// The mode to be used for resizing video tracks. It is one of the computing platforms for Flussonic Coder:
	// * vic -  Video Image Converter, specific for Jetson Nvidia
	// * cuda - CUDA (or Compute Unified Device Architecture)
	ResizeMode() *TranscoderResizeMode
	// The mode to be used for resizing video tracks. It is one of the computing platforms for Flussonic Coder:
	// * vic -  Video Image Converter, specific for Jetson Nvidia
	// * cuda - CUDA (or Compute Unified Device Architecture)
	SetResizeMode(TranscoderResizeMode) TranscoderTrackInfo
	// Target aspect ratio.
	Sar() TcSar
	// Target aspect ratio.
	SetSar(TcSar) TranscoderTrackInfo
	// Target size of the image and the strategy to achieve it.
	Size() TcSize
	// Target size of the image and the strategy to achieve it.
	SetSize(TcSize) TranscoderTrackInfo
	// Drop some frames in dynamic scenes when the transcoder does not have time to code all frames.
	// The allowed values are:
	// * `15` - drop 1 from 5
	// * `13` - drop 1 from 3
	// * `12` - drop 1 from 2
	// * `23` - drop 2 from 3
	// * `0` - do not drop frames
	TemporalTradeoff() *int
	// Drop some frames in dynamic scenes when the transcoder does not have time to code all frames.
	// The allowed values are:
	// * `15` - drop 1 from 5
	// * `13` - drop 1 from 3
	// * `12` - drop 1 from 2
	// * `23` - drop 2 from 3
	// * `0` - do not drop frames
	SetTemporalTradeoff(int) TranscoderTrackInfo
	// Number of threads used by the encoder when transcoding with CPU (it is not used for other types of transcoder).
	// This parameter allows to increase performance by adding new threads. By default, it is autodetected.
	Threads() *int
	// Number of threads used by the encoder when transcoding with CPU (it is not used for other types of transcoder).
	// This parameter allows to increase performance by adding new threads. By default, it is autodetected.
	SetThreads(int) TranscoderTrackInfo
	// Human-readable localized title of the track.
	// Example: Video1
	Title() *string
	// Human-readable localized title of the track.
	// Example: Video1
	SetTitle(string) TranscoderTrackInfo
	// Virtual buffer size, it bits. The default value is `gop / fps * bitrate`.
	VbvBufsize() *int
	// Virtual buffer size, it bits. The default value is `gop / fps * bitrate`.
	SetVbvBufsize(int) TranscoderTrackInfo
}

type TranscoderTrackInfoAudio interface {
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	Bitrate() *Speed
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	SetBitrate(Speed) TranscoderTrackInfoAudio
	// The number of audio channels in an output stream.
	// Example: 2
	Channels() any
	// The number of audio channels in an output stream.
	// Example: 2
	SetChannels(any) TranscoderTrackInfoAudio
	// Audio codec (the AAC codec is used by default).
	// Example: opus
	Codec() *string
	// Audio codec (the AAC codec is used by default).
	// Example: opus
	SetCodec(string) TranscoderTrackInfoAudio
	// Content of the track (audio, video, or text).
	Content() FrameContent
	// Content of the track (audio, video, or text).
	SetContent(FrameContent) TranscoderTrackInfoAudio
	// Input audio track to be transcoded.
	// Example: 1
	InputTrack() *int
	// Input audio track to be transcoded.
	// Example: 1
	SetInputTrack(int) TranscoderTrackInfoAudio
	// Language value of the track, if applicable.
	// Example: eng
	Language() *string
	// Language value of the track, if applicable.
	// Example: eng
	SetLanguage(string) TranscoderTrackInfoAudio
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	Pid() *int
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	SetPid(int) TranscoderTrackInfoAudio
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// The allowed values are:
	// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
	// /Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	SampleRate() any
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// The allowed values are:
	// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
	// /Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	SetSampleRate(any) TranscoderTrackInfoAudio
	// This option allows to split each audio track with multiple channels into several mono tracks.
	SplitChannels() *bool
	// This option allows to split each audio track with multiple channels into several mono tracks.
	SetSplitChannels(bool) TranscoderTrackInfoAudio
	// Human-readable localized title of the track.
	// Example: Video1
	Title() *string
	// Human-readable localized title of the track.
	// Example: Video1
	SetTitle(string) TranscoderTrackInfoAudio
	// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
	// If it is just an integer or a float, the output audio volume is calculated by this formula:
	// `output_volume = volume * input_volume`
	// If specified in decibels (dB), the output audio volume is calculated as follows:
	// `output_volume = input_volume +/- volume`
	// depending whether it is a positive (+9dB) or a negative value (-6dB).
	// By default it equals to 1 (the input audio volume).
	// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
	// Example: -6dB
	Volume() *string
	// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
	// If it is just an integer or a float, the output audio volume is calculated by this formula:
	// `output_volume = volume * input_volume`
	// If specified in decibels (dB), the output audio volume is calculated as follows:
	// `output_volume = input_volume +/- volume`
	// depending whether it is a positive (+9dB) or a negative value (-6dB).
	// By default it equals to 1 (the input audio volume).
	// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
	// Example: -6dB
	SetVolume(string) TranscoderTrackInfoAudio
}

type TranscoderTrackInfoAudioSpec interface {
	// Audio codec (the AAC codec is used by default).
	// Example: opus
	Codec() *string
	// Audio codec (the AAC codec is used by default).
	// Example: opus
	SetCodec(string) TranscoderTrackInfoAudioSpec
	// Input audio track to be transcoded.
	// Example: 1
	InputTrack() *int
	// Input audio track to be transcoded.
	// Example: 1
	SetInputTrack(int) TranscoderTrackInfoAudioSpec
	// Language value of the track, if applicable.
	// Example: eng
	Language() *string
	// Language value of the track, if applicable.
	// Example: eng
	SetLanguage(string) TranscoderTrackInfoAudioSpec
	// This option allows to split each audio track with multiple channels into several mono tracks.
	SplitChannels() *bool
	// This option allows to split each audio track with multiple channels into several mono tracks.
	SetSplitChannels(bool) TranscoderTrackInfoAudioSpec
	// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
	// If it is just an integer or a float, the output audio volume is calculated by this formula:
	// `output_volume = volume * input_volume`
	// If specified in decibels (dB), the output audio volume is calculated as follows:
	// `output_volume = input_volume +/- volume`
	// depending whether it is a positive (+9dB) or a negative value (-6dB).
	// By default it equals to 1 (the input audio volume).
	// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
	// Example: -6dB
	Volume() *string
	// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
	// If it is just an integer or a float, the output audio volume is calculated by this formula:
	// `output_volume = volume * input_volume`
	// If specified in decibels (dB), the output audio volume is calculated as follows:
	// `output_volume = input_volume +/- volume`
	// depending whether it is a positive (+9dB) or a negative value (-6dB).
	// By default it equals to 1 (the input audio volume).
	// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
	// Example: -6dB
	SetVolume(string) TranscoderTrackInfoAudioSpec
}

type TranscoderTrackInfoVideo interface {
	// The configuration of a logo added to the video track after the video was resized as specified in the `size` option.
	// This prevents the logo picture from stretching that might occur when the `logo` option is used.
	// You will need to prepare and specify a separate file with a logo for each size of the resulting video track.
	Alogo() TcLogo
	// The configuration of a logo added to the video track after the video was resized as specified in the `size` option.
	// This prevents the logo picture from stretching that might occur when the `logo` option is used.
	// You will need to prepare and specify a separate file with a logo for each size of the resulting video track.
	SetAlogo(TcLogo) TranscoderTrackInfoVideo
	// Number of B-frames between I and P-frames. B-frames contain links to keyframes and P-frames before and after themselves.
	// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
	// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
	// When set to 0, this option disables b-frames. This may be necessary, for example, when broadcasting to RTSP.
	// Example: 3
	Bframes() *int
	// Number of B-frames between I and P-frames. B-frames contain links to keyframes and P-frames before and after themselves.
	// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
	// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
	// When set to 0, this option disables b-frames. This may be necessary, for example, when broadcasting to RTSP.
	// Example: 3
	SetBframes(int) TranscoderTrackInfoVideo
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	Bitrate() *Speed
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	SetBitrate(Speed) TranscoderTrackInfoVideo
	// Configuration of burn-in text, timestamp, or subtitles to video frames.
	Burn() TcBurn
	// Configuration of burn-in text, timestamp, or subtitles to video frames.
	SetBurn(TcBurn) TranscoderTrackInfoVideo
	// Codec of the track. Different codecs do **not** get the same track.
	// Example: h264
	Codec() *FrameCodec
	// Codec of the track. Different codecs do **not** get the same track.
	// Example: h264
	SetCodec(FrameCodec) TranscoderTrackInfoVideo
	// Content of the track (audio, video, or text).
	Content() FrameContent
	// Content of the track (audio, video, or text).
	SetContent(FrameContent) TranscoderTrackInfoVideo
	// Some additional options.
	Extra() map[string]string
	// Some additional options.
	SetExtra(map[string]string) TranscoderTrackInfoVideo
	// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
	// Higher frame rates capture more images per second, which makes for smoother video.
	// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
	// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
	// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
	// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
	// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
	FPS() *TcFPS
	// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
	// Higher frame rates capture more images per second, which makes for smoother video.
	// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
	// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
	// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
	// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
	// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
	SetFPS(*TcFPS) TranscoderTrackInfoVideo
	// Sets the number of frames in a GOP.
	// The encoder will create all GOPs of an exactly identical size - as specified in this option.
	// Example: 150
	Gop() *int
	// Sets the number of frames in a GOP.
	// The encoder will create all GOPs of an exactly identical size - as specified in this option.
	// Example: 150
	SetGop(int) TranscoderTrackInfoVideo
	// This parameter is used to get an interlaced stream from a progressive one.
	// The allowed values are `true` (interlaced video), `false` (progressive video), or one of the methods for producing interlaced video supported for the selected type of transcoder.
	Interlace() *InterlaceSettings
	// This parameter is used to get an interlaced stream from a progressive one.
	// The allowed values are `true` (interlaced video), `false` (progressive video), or one of the methods for producing interlaced video supported for the selected type of transcoder.
	SetInterlace(*InterlaceSettings) TranscoderTrackInfoVideo
	// A set of constraints that indicate a degree of required decoder performance.
	// This parameter is used for compatibility with old devices.
	Level() any
	// A set of constraints that indicate a degree of required decoder performance.
	// This parameter is used for compatibility with old devices.
	SetLevel(any) TranscoderTrackInfoVideo
	// The configuration of a logo "burned" into the video track.
	// The transcoder adds the logo before the video is resized as specified in the `size` option.
	// This means that the logo can be visibly stretched if the size was changed significantly.
	Logo() TcLogo
	// The configuration of a logo "burned" into the video track.
	// The transcoder adds the logo before the video is resized as specified in the `size` option.
	// This means that the logo can be visibly stretched if the size was changed significantly.
	SetLogo(TcLogo) TranscoderTrackInfoVideo
	// Whether open GOP is used. Open GOP contains P-frames that refer to the frames before the keyframe.
	// It allows to decrease bitrate to 5-7%, but can result in breaking the picture.
	// Do not enable this option if the track will be played over segment-based protocols (HLS, DASH, etc.) because
	// absence of keyframes or IDR frames in the same segment with P-frames may prevent playback.
	// [Read more about tracks, GOP and segments](https://flussonic.com/doc/live-stream-internals/).
	OpenGop() *bool
	// Whether open GOP is used. Open GOP contains P-frames that refer to the frames before the keyframe.
	// It allows to decrease bitrate to 5-7%, but can result in breaking the picture.
	// Do not enable this option if the track will be played over segment-based protocols (HLS, DASH, etc.) because
	// absence of keyframes or IDR frames in the same segment with P-frames may prevent playback.
	// [Read more about tracks, GOP and segments](https://flussonic.com/doc/live-stream-internals/).
	SetOpenGop(bool) TranscoderTrackInfoVideo
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	Pid() *int
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	SetPid(int) TranscoderTrackInfoVideo
	// A set of values that determine a certain encoding speed, which influences a compression ratio.
	// A slower preset will provide better compression (compression is quality per file size).
	// Example: medium
	Preset() *TcPreset
	// A set of values that determine a certain encoding speed, which influences a compression ratio.
	// A slower preset will provide better compression (compression is quality per file size).
	// Example: medium
	SetPreset(TcPreset) TranscoderTrackInfoVideo
	// Limits the output to a specific H.264 profile.
	Profile() *TcProfile
	// Limits the output to a specific H.264 profile.
	SetProfile(TcProfile) TranscoderTrackInfoVideo
	// The ranges of the quantization parameter for different types of frames in a GOP.
	// Quantization is an algorithm used for video compression. It is based on fragmentation of video frames.
	// Increasing this parameter allows to improve the compression but may lower the picture quality.
	// Usually, these ranges are defined automatically by the transcoder, but for some types of transcoders it makes sense to set them manually.
	QpRange() TcQpRange
	// The ranges of the quantization parameter for different types of frames in a GOP.
	// Quantization is an algorithm used for video compression. It is based on fragmentation of video frames.
	// Increasing this parameter allows to improve the compression but may lower the picture quality.
	// Usually, these ranges are defined automatically by the transcoder, but for some types of transcoders it makes sense to set them manually.
	SetQpRange(TcQpRange) TranscoderTrackInfoVideo
	// A method for creating output video with constant bitrate suitable for broadcasting to television networks.
	RcMethod() *RcMethod
	// A method for creating output video with constant bitrate suitable for broadcasting to television networks.
	SetRcMethod(RcMethod) TranscoderTrackInfoVideo
	// The number of reference frames in a GOP.
	// Reference frames are frames of a compressed video that are used to define other frames (P-frames and B-frames).
	Refs() *int
	// The number of reference frames in a GOP.
	// Reference frames are frames of a compressed video that are used to define other frames (P-frames and B-frames).
	SetRefs(int) TranscoderTrackInfoVideo
	// The mode to be used for resizing video tracks. It is one of the computing platforms for Flussonic Coder:
	// * vic -  Video Image Converter, specific for Jetson Nvidia
	// * cuda - CUDA (or Compute Unified Device Architecture)
	ResizeMode() *TranscoderResizeMode
	// The mode to be used for resizing video tracks. It is one of the computing platforms for Flussonic Coder:
	// * vic -  Video Image Converter, specific for Jetson Nvidia
	// * cuda - CUDA (or Compute Unified Device Architecture)
	SetResizeMode(TranscoderResizeMode) TranscoderTrackInfoVideo
	// Target aspect ratio.
	Sar() TcSar
	// Target aspect ratio.
	SetSar(TcSar) TranscoderTrackInfoVideo
	// Target size of the image and the strategy to achieve it.
	Size() TcSize
	// Target size of the image and the strategy to achieve it.
	SetSize(TcSize) TranscoderTrackInfoVideo
	// Drop some frames in dynamic scenes when the transcoder does not have time to code all frames.
	// The allowed values are:
	// * `15` - drop 1 from 5
	// * `13` - drop 1 from 3
	// * `12` - drop 1 from 2
	// * `23` - drop 2 from 3
	// * `0` - do not drop frames
	TemporalTradeoff() *int
	// Drop some frames in dynamic scenes when the transcoder does not have time to code all frames.
	// The allowed values are:
	// * `15` - drop 1 from 5
	// * `13` - drop 1 from 3
	// * `12` - drop 1 from 2
	// * `23` - drop 2 from 3
	// * `0` - do not drop frames
	SetTemporalTradeoff(int) TranscoderTrackInfoVideo
	// Number of threads used by the encoder when transcoding with CPU (it is not used for other types of transcoder).
	// This parameter allows to increase performance by adding new threads. By default, it is autodetected.
	Threads() *int
	// Number of threads used by the encoder when transcoding with CPU (it is not used for other types of transcoder).
	// This parameter allows to increase performance by adding new threads. By default, it is autodetected.
	SetThreads(int) TranscoderTrackInfoVideo
	// Human-readable localized title of the track.
	// Example: Video1
	Title() *string
	// Human-readable localized title of the track.
	// Example: Video1
	SetTitle(string) TranscoderTrackInfoVideo
	// Virtual buffer size, it bits. The default value is `gop / fps * bitrate`.
	VbvBufsize() *int
	// Virtual buffer size, it bits. The default value is `gop / fps * bitrate`.
	SetVbvBufsize(int) TranscoderTrackInfoVideo
}

// Required: pid, content, track
type TransponderPid interface {
	// Bitrate of the track.
	// Format: speed (speed)
	// Example: 2543
	Bitrate() *Speed
	// Bitrate of the track.
	// Format: speed (speed)
	// Example: 2543
	SetBitrate(Speed) TransponderPid
	// Codec for this pid. Use this if just content+track is not enough.
	// Example: scte35
	Codec() *FrameCodec
	// Codec for this pid. Use this if just content+track is not enough.
	// Example: scte35
	SetCodec(FrameCodec) TransponderPid
	// Content of the track.
	// Example: audio
	Content() string
	// Content of the track.
	// Example: audio
	SetContent(string) TransponderPid
	// Raw elementary stream descriptors to describe proprietary stream in PMT program info
	// Plese refer to ISO/IEC 13818-1 section 2.6 for syntax
	// This is an optional parameter for advanced users. By default, the media Server
	// is automatically sets the stream_type according to the track codec.
	// Format: hexbinary (hexbinary)
	// Example: 52010D
	EsInfo() *Hexbinary
	// Raw elementary stream descriptors to describe proprietary stream in PMT program info
	// Plese refer to ISO/IEC 13818-1 section 2.6 for syntax
	// This is an optional parameter for advanced users. By default, the media Server
	// is automatically sets the stream_type according to the track codec.
	// Format: hexbinary (hexbinary)
	// Example: 52010D
	SetEsInfo(Hexbinary) TransponderPid
	// A PID to assign to a matched track or system table.
	// PID identifies the payload (media or service) in the resulting MPTS stream.
	// Multiplexer will include only the tracks with specified PIDs.
	// It is possible to set PID values for video, audio and other media tracks, as well as for PMT and SDT.
	Pid() int
	// A PID to assign to a matched track or system table.
	// PID identifies the payload (media or service) in the resulting MPTS stream.
	// Multiplexer will include only the tracks with specified PIDs.
	// It is possible to set PID values for video, audio and other media tracks, as well as for PMT and SDT.
	SetPid(int) TransponderPid
	// Detailed runtime information about the multiplexer pid.
	Stats() PushPidCounters
	// Detailed runtime information about the multiplexer pid.
	SetStats(PushPidCounters) TransponderPid
	// Custom program element type in PMT
	// Combined with bypass (content=metadata, track=0) this option makes
	// proprietary PSI streams appear in PMT program info with given stream_type field
	// This is an optional parameter for advanced users. By default, the media Server
	// is automatically sets the stream_type according to the track codec.
	// Example: 12
	StreamType() *int
	// Custom program element type in PMT
	// Combined with bypass (content=metadata, track=0) this option makes
	// proprietary PSI streams appear in PMT program info with given stream_type field
	// This is an optional parameter for advanced users. By default, the media Server
	// is automatically sets the stream_type according to the track codec.
	// Example: 12
	SetStreamType(int) TransponderPid
	// Index of a track with specified content and maybe codec.
	// E.g. when you specify content=audio and track=2 the second audio track will be selected.
	// If you specify content=audio, codec=aac and track=1, the first AAC track will be selected
	// even if it is a third audio track and fifth track in stream media_info
	// Example: 1
	Track() int
	// Index of a track with specified content and maybe codec.
	// E.g. when you specify content=audio and track=2 the second audio track will be selected.
	// If you specify content=audio, codec=aac and track=1, the first AAC track will be selected
	// even if it is a third audio track and fifth track in stream media_info
	// Example: 1
	SetTrack(int) TransponderPid
}

// Required: page, lang, type
type TtxtDescriptors interface {
	// The language code of the teletext.
	Lang() string
	// The language code of the teletext.
	SetLang(string) TtxtDescriptors
	// Page number of the teletext received from an SDI card.
	// It is defined according to ETS 300 706 teletext specification.
	// The information about the pages is received from the stream provider.
	// Example: 100
	Page() int
	// Page number of the teletext received from an SDI card.
	// It is defined according to ETS 300 706 teletext specification.
	// The information about the pages is received from the stream provider.
	// Example: 100
	SetPage(int) TtxtDescriptors
	// Teletext page type defined according to the Specification for Service Information (SI) in DVB systems, 6.2.32 Teletext descriptor in EN 300 468 Digital Video Broadcasting (DVB).
	// Example: initial
	Type() string
	// Teletext page type defined according to the Specification for Service Information (SI) in DVB systems, 6.2.32 Teletext descriptor in EN 300 468 Digital Video Broadcasting (DVB).
	// Example: initial
	SetType(string) TtxtDescriptors
}

type VbiLines interface {
	// Numbers of VBI lines that will carry a teletext track.
	Lines() []VbiLine
	// Numbers of VBI lines that will carry a teletext track.
	SetLines([]VbiLine) VbiLines
	// The service information passed to VBI of the output analog stream.
	// The allowed value is `ttxt` - teletext.
	Service() *VbiService
	// The service information passed to VBI of the output analog stream.
	// The allowed value is `ttxt` - teletext.
	SetService(VbiService) VbiLines
}

type VisionAlerts interface {
	// The time when an episode could not be created due to low detection quality (on blurry or noisy frames).
	// It may be caused by uncertainty when the picture is not clear enough.
	// Try adjusting the shutter speed parameters on your camera.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	LowQualityAt() *UtcMs
	// The time when an episode could not be created due to low detection quality (on blurry or noisy frames).
	// It may be caused by uncertainty when the picture is not clear enough.
	// Try adjusting the shutter speed parameters on your camera.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	SetLowQualityAt(UtcMs) VisionAlerts
	// The time when an episode could not be created due to insufficient detections.
	// The issue occurs when the selected detector is unable to find the target object enough times.
	// It is possible that the target object appears shortly or is obscured by something.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	NotEnoughDetectionsAt() *UtcMs
	// The time when an episode could not be created due to insufficient detections.
	// The issue occurs when the selected detector is unable to find the target object enough times.
	// It is possible that the target object appears shortly or is obscured by something.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	SetNotEnoughDetectionsAt(UtcMs) VisionAlerts
	// The time when an episode could not be created due to the small size of detections relative to the detector internal settings.
	// The camera placement may need to be adjusted closer to the target objects.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	SmallSizeAt() *UtcMs
	// The time when an episode could not be created due to the small size of detections relative to the detector internal settings.
	// The camera placement may need to be adjusted closer to the target objects.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	SetSmallSizeAt(UtcMs) VisionAlerts
}

type VisionAppearance interface {
	// Position of the objects at the frame
	Box() VisionBox
	// Position of the objects at the frame
	SetBox(VisionBox) VisionAppearance
}

// Rectangle
// Required: top, left, bottom, right
type VisionBox interface {
	// Bottom border of the bounding box. Fraction of full frame height
	Bottom() float64
	// Bottom border of the bounding box. Fraction of full frame height
	SetBottom(float64) VisionBox
	// Left border of the bounding box. Fraction of full frame width
	Left() float64
	// Left border of the bounding box. Fraction of full frame width
	SetLeft(float64) VisionBox
	// Right border of the bounding box. Fraction of full frame width
	Right() float64
	// Right border of the bounding box. Fraction of full frame width
	SetRight(float64) VisionBox
	// Top border of the bounding box. Fraction of full frame height
	Top() float64
	// Top border of the bounding box. Fraction of full frame height
	SetTop(float64) VisionBox
}

type VisionDetectedFace interface {
	// Appearance attributes of the detected object
	Appearance() VisionAppearance
	// Appearance attributes of the detected object
	SetAppearance(VisionAppearance) VisionDetectedFace
	// Confidence level of object detection
	Confidence() *float64
	// Confidence level of object detection
	SetConfidence(float64) VisionDetectedFace
	// Timestamp when the object was detected
	// Format: utc_ms (Unix timestamp in milliseconds)
	DetectedAt() UtcMs
	// Timestamp when the object was detected
	// Format: utc_ms (Unix timestamp in milliseconds)
	SetDetectedAt(UtcMs) VisionDetectedFace
	// The fingerprint of the detected face
	Fingerprint() VisionFaceFingerprint
	// The fingerprint of the detected face
	SetFingerprint(VisionFaceFingerprint) VisionDetectedFace
	// Class of the detected object
	ObjectClass() VisionObjectClass
	// Class of the detected object
	SetObjectClass(VisionObjectClass) VisionDetectedFace
	// Preview of the detected object
	Thumbnail() VisionImageAttributes
	// Preview of the detected object
	SetThumbnail(VisionImageAttributes) VisionDetectedFace
	// Quality of the thumbnail
	ThumbnailQuality() *float64
	// Quality of the thumbnail
	SetThumbnailQuality(float64) VisionDetectedFace
}

type VisionDetectedLicensePlate interface {
	// Appearance attributes of the detected object
	Appearance() VisionAppearance
	// Appearance attributes of the detected object
	SetAppearance(VisionAppearance) VisionDetectedLicensePlate
	// Confidence level of object detection
	Confidence() *float64
	// Confidence level of object detection
	SetConfidence(float64) VisionDetectedLicensePlate
	// Timestamp when the object was detected
	// Format: utc_ms (Unix timestamp in milliseconds)
	DetectedAt() UtcMs
	// Timestamp when the object was detected
	// Format: utc_ms (Unix timestamp in milliseconds)
	SetDetectedAt(UtcMs) VisionDetectedLicensePlate
	// Shows from which side the vehicle was detected.
	FacingSide() *VisionVehicleFacingSide
	// Shows from which side the vehicle was detected.
	SetFacingSide(VisionVehicleFacingSide) VisionDetectedLicensePlate
	// Class of the detected object
	ObjectClass() VisionObjectClass
	// Class of the detected object
	SetObjectClass(VisionObjectClass) VisionDetectedLicensePlate
	// Recognized vehicle's license plate number
	PlateText() *string
	// Recognized vehicle's license plate number
	SetPlateText(string) VisionDetectedLicensePlate
	// Preview of the detected object
	Thumbnail() VisionImageAttributes
	// Preview of the detected object
	SetThumbnail(VisionImageAttributes) VisionDetectedLicensePlate
	// Quality of the thumbnail
	ThumbnailQuality() *float64
	// Quality of the thumbnail
	SetThumbnailQuality(float64) VisionDetectedLicensePlate
}

// Required: detected_at, object_class
type VisionDetectedObjectBase interface {
	// Appearance attributes of the detected object
	Appearance() VisionAppearance
	// Appearance attributes of the detected object
	SetAppearance(VisionAppearance) VisionDetectedObjectBase
	// Confidence level of object detection
	Confidence() *float64
	// Confidence level of object detection
	SetConfidence(float64) VisionDetectedObjectBase
	// Timestamp when the object was detected
	// Format: utc_ms (Unix timestamp in milliseconds)
	DetectedAt() UtcMs
	// Timestamp when the object was detected
	// Format: utc_ms (Unix timestamp in milliseconds)
	SetDetectedAt(UtcMs) VisionDetectedObjectBase
	// Class of the detected object
	ObjectClass() VisionObjectClass
	// Class of the detected object
	SetObjectClass(VisionObjectClass) VisionDetectedObjectBase
	// Preview of the detected object
	Thumbnail() VisionImageAttributes
	// Preview of the detected object
	SetThumbnail(VisionImageAttributes) VisionDetectedObjectBase
	// Quality of the thumbnail
	ThumbnailQuality() *float64
	// Quality of the thumbnail
	SetThumbnailQuality(float64) VisionDetectedObjectBase
}

type VisionDetectedVehicle interface {
	// Appearance attributes of the detected object
	Appearance() VisionAppearance
	// Appearance attributes of the detected object
	SetAppearance(VisionAppearance) VisionDetectedVehicle
	// Confidence level of object detection
	Confidence() *float64
	// Confidence level of object detection
	SetConfidence(float64) VisionDetectedVehicle
	// Timestamp when the object was detected
	// Format: utc_ms (Unix timestamp in milliseconds)
	DetectedAt() UtcMs
	// Timestamp when the object was detected
	// Format: utc_ms (Unix timestamp in milliseconds)
	SetDetectedAt(UtcMs) VisionDetectedVehicle
	// Indicates if no license plate is detected on this vehicle
	LicensePlateMissing() *bool
	// Indicates if no license plate is detected on this vehicle
	SetLicensePlateMissing(bool) VisionDetectedVehicle
	// Class of the detected object
	ObjectClass() VisionObjectClass
	// Class of the detected object
	SetObjectClass(VisionObjectClass) VisionDetectedVehicle
	// The purpose of the vehicle, e.g. emergency or regular.
	Purpose() *VisionVehiclePurpose
	// The purpose of the vehicle, e.g. emergency or regular.
	SetPurpose(VisionVehiclePurpose) VisionDetectedVehicle
	// Preview of the detected object
	Thumbnail() VisionImageAttributes
	// Preview of the detected object
	SetThumbnail(VisionImageAttributes) VisionDetectedVehicle
	// Quality of the thumbnail
	ThumbnailQuality() *float64
	// Quality of the thumbnail
	SetThumbnailQuality(float64) VisionDetectedVehicle
}

// Required: detector_type, region_id
type VisionDetectorConfig interface {
	DetectorType() VisionDetectorConfigDetectorType
	SetDetectorType(VisionDetectorConfigDetectorType) VisionDetectorConfig
	RegionCoordinates() VisionDetectorConfigRegionCoordinates
	SetRegionCoordinates(VisionDetectorConfigRegionCoordinates) VisionDetectorConfig
	// Identifier of the detection area.
	// It is used to distinguish episodes from various regions of interest within the frame.
	// For instance, it can be used with a single camera facing two entrances to count visitors independently at each entrance.
	RegionID() string
	// Identifier of the detection area.
	// It is used to distinguish episodes from various regions of interest within the frame.
	// For instance, it can be used with a single camera facing two entrances to count visitors independently at each entrance.
	SetRegionID(string) VisionDetectorConfig
	// Runtime information about the vision process.
	Stats() VisionDetectorStats
	// Runtime information about the vision process.
	SetStats(VisionDetectorStats) VisionDetectorConfig
}

type VisionDetectorConfigDetectorType interface {
}

type VisionDetectorConfigRegionCoordinates interface {
}

type VisionDetectorStats interface {
	// Identifies analytics issues related to frames in a stream that impact episode creation
	Alerts() VisionAlerts
	// Identifies analytics issues related to frames in a stream that impact episode creation
	SetAlerts(VisionAlerts) VisionDetectorStats
	// The time when there was the last detection. Constant updates mean that analytics can detect objects on frames.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	LastDetectionAt() *UtcMs
	// The time when there was the last detection. Constant updates mean that analytics can detect objects on frames.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	SetLastDetectionAt(UtcMs) VisionDetectorStats
	// Indicates the analytics status of the stream on inference node.
	Status() *StreamStatus
	// Indicates the analytics status of the stream on inference node.
	SetStatus(StreamStatus) VisionDetectorStats
}

type VisionEpisodeContextSearch interface {
	// The reason for closing the episode.
	CloseReason() *EpisodeCloseReason
	// The reason for closing the episode.
	SetCloseReason(EpisodeCloseReason) VisionEpisodeContextSearch
	// Episode emitter can decide that episode considered closed and will not grow further.
	// `closed_at` MUST NOT change, it must be emitted only once.
	// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
	// of the episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	ClosedAt() *UtcMs
	// Episode emitter can decide that episode considered closed and will not grow further.
	// `closed_at` MUST NOT change, it must be emitted only once.
	// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
	// of the episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetClosedAt(UtcMs) VisionEpisodeContextSearch
	// The time when the episode appeared in the service relative to the server time.
	EpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps
	// The time when the episode appeared in the service relative to the server time.
	SetEpisodeAppearanceTimestamps(EpisodeAppearanceTimestamps) VisionEpisodeContextSearch
	// Unique identifier of the episode. Must be created by the system that first creates this episode.
	// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
	// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
	// handle very long integers.
	// Format: snowflake_id (snowflake_id)
	// Examples: 1.722279170848854e+18
	EpisodeID() SnowflakeID
	// Unique identifier of the episode. Must be created by the system that first creates this episode.
	// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
	// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
	// handle very long integers.
	// Format: snowflake_id (snowflake_id)
	// Examples: 1.722279170848854e+18
	SetEpisodeID(SnowflakeID) VisionEpisodeContextSearch
	// Episode matches context search text query
	EpisodeType() *string
	// Episode matches context search text query
	SetEpisodeType(string) VisionEpisodeContextSearch
	// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
	// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
	// Format: base64 (base64)
	FramePreview() *Base64
	// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
	// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
	// Format: base64 (base64)
	SetFramePreview(Base64) VisionEpisodeContextSearch
	// Maximum matching score between the text query and episode.
	// Examples: 0.2345
	MatchScore() *float64
	// Maximum matching score between the text query and episode.
	// Examples: 0.2345
	SetMatchScore(float64) VisionEpisodeContextSearch
	// Stream name on which this episode exists.
	// Format: media_name (media_name)
	Media() MediaName
	// Stream name on which this episode exists.
	// Format: media_name (media_name)
	SetMedia(MediaName) VisionEpisodeContextSearch
	// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
	// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
	// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
	// sort as by `opened_at`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	OpenedAt() UtcMs
	// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
	// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
	// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
	// sort as by `opened_at`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetOpenedAt(UtcMs) VisionEpisodeContextSearch
	// This describes the way this episode was updated, whether via an inference node or an API.
	// In the case of an inference node, its hostname will be provided.
	Originator() EpisodeOriginator
	// This describes the way this episode was updated, whether via an inference node or an API.
	// In the case of an inference node, its hostname will be provided.
	SetOriginator(EpisodeOriginator) VisionEpisodeContextSearch
	// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Format: base64 (base64)
	Preview() *Base64
	// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Format: base64 (base64)
	SetPreview(Base64) VisionEpisodeContextSearch
	// The time when the preview of this episode is available.
	// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
	// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
	// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
	// for details.
	// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	PreviewTimestamp() *UtcMs
	// The time when the preview of this episode is available.
	// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
	// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
	// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
	// for details.
	// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetPreviewTimestamp(UtcMs) VisionEpisodeContextSearch
	// DVR recording status: fully recorded, not recorded, or partially recorded
	RecordingStatus() *string
	// DVR recording status: fully recorded, not recorded, or partially recorded
	SetRecordingStatus(string) VisionEpisodeContextSearch
	// This field can be used as indication of the fact that some system have checked and ensured that
	// this episode has really started at some time, that may differ from `opened_at`.
	// For example video analytics will use this field for the time when this episode was confirmed as confident.
	// May be not relevant for television systems.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	StartedAt() *UtcMs
	// This field can be used as indication of the fact that some system have checked and ensured that
	// this episode has really started at some time, that may differ from `opened_at`.
	// For example video analytics will use this field for the time when this episode was confirmed as confident.
	// May be not relevant for television systems.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetStartedAt(UtcMs) VisionEpisodeContextSearch
	// The time of last change of the episode.
	// System that processes episodes and can send them to other systems, MUST update this field
	// on any changes in this episode.
	// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
	// this `updated_at` can be used as a sort key for fetching fresh updates.
	// Consumer of the episodes can use `updated_at` in the following scenario:
	// * fetch all exisiting episodes from the source
	// * take biggest `updated_at` from this dataset, it will be T
	// * ask source for all episodes with `updated_at > T`
	// This algorithm can be used for fetching update stream from the source.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637098611e+12
	UpdatedAt() UtcMs
	// The time of last change of the episode.
	// System that processes episodes and can send them to other systems, MUST update this field
	// on any changes in this episode.
	// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
	// this `updated_at` can be used as a sort key for fetching fresh updates.
	// Consumer of the episodes can use `updated_at` in the following scenario:
	// * fetch all exisiting episodes from the source
	// * take biggest `updated_at` from this dataset, it will be T
	// * ask source for all episodes with `updated_at > T`
	// This algorithm can be used for fetching update stream from the source.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637098611e+12
	SetUpdatedAt(UtcMs) VisionEpisodeContextSearch
}

type VisionEpisodeFace interface {
	// The reason for closing the episode.
	CloseReason() *EpisodeCloseReason
	// The reason for closing the episode.
	SetCloseReason(EpisodeCloseReason) VisionEpisodeFace
	// Episode emitter can decide that episode considered closed and will not grow further.
	// `closed_at` MUST NOT change, it must be emitted only once.
	// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
	// of the episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	ClosedAt() *UtcMs
	// Episode emitter can decide that episode considered closed and will not grow further.
	// `closed_at` MUST NOT change, it must be emitted only once.
	// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
	// of the episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetClosedAt(UtcMs) VisionEpisodeFace
	// Detections associated with this episode
	Detections() []VisionDetectedFace
	// Detections associated with this episode
	SetDetections([]VisionDetectedFace) VisionEpisodeFace
	// The time when the episode appeared in the service relative to the server time.
	EpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps
	// The time when the episode appeared in the service relative to the server time.
	SetEpisodeAppearanceTimestamps(EpisodeAppearanceTimestamps) VisionEpisodeFace
	// Unique identifier of the episode. Must be created by the system that first creates this episode.
	// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
	// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
	// handle very long integers.
	// Format: snowflake_id (snowflake_id)
	// Examples: 1.722279170848854e+18
	EpisodeID() SnowflakeID
	// Unique identifier of the episode. Must be created by the system that first creates this episode.
	// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
	// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
	// handle very long integers.
	// Format: snowflake_id (snowflake_id)
	// Examples: 1.722279170848854e+18
	SetEpisodeID(SnowflakeID) VisionEpisodeFace
	// Face is detected
	EpisodeType() *string
	// Face is detected
	SetEpisodeType(string) VisionEpisodeFace
	// The fingerprint of the detected face
	Fingerprint() VisionFaceFingerprint
	// The fingerprint of the detected face
	SetFingerprint(VisionFaceFingerprint) VisionEpisodeFace
	// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
	// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
	// Format: base64 (base64)
	FramePreview() *Base64
	// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
	// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
	// Format: base64 (base64)
	SetFramePreview(Base64) VisionEpisodeFace
	// List of matched persons with similarity metric.
	// Videoanalytics identification service enriches episode's data and fills this field
	// with the list of persons that are similar to the face detected in this episode.
	MatchedPersons() []VisionPersonMatch
	// List of matched persons with similarity metric.
	// Videoanalytics identification service enriches episode's data and fills this field
	// with the list of persons that are similar to the face detected in this episode.
	SetMatchedPersons([]VisionPersonMatch) VisionEpisodeFace
	// Stream name on which this episode exists.
	// Format: media_name (media_name)
	Media() MediaName
	// Stream name on which this episode exists.
	// Format: media_name (media_name)
	SetMedia(MediaName) VisionEpisodeFace
	// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
	// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
	// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
	// sort as by `opened_at`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	OpenedAt() UtcMs
	// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
	// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
	// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
	// sort as by `opened_at`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetOpenedAt(UtcMs) VisionEpisodeFace
	// This describes the way this episode was updated, whether via an inference node or an API.
	// In the case of an inference node, its hostname will be provided.
	Originator() EpisodeOriginator
	// This describes the way this episode was updated, whether via an inference node or an API.
	// In the case of an inference node, its hostname will be provided.
	SetOriginator(EpisodeOriginator) VisionEpisodeFace
	// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Preview contains an image of person's face and has a resolution about 200 x 200 pixels with maximum size about 10 kilobytes.
	// Format: base64 (base64)
	Preview() Base64
	// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Preview contains an image of person's face and has a resolution about 200 x 200 pixels with maximum size about 10 kilobytes.
	// Format: base64 (base64)
	SetPreview(Base64) VisionEpisodeFace
	// The time when the preview of this episode is available.
	// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
	// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
	// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
	// for details.
	// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	PreviewTimestamp() *UtcMs
	// The time when the preview of this episode is available.
	// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
	// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
	// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
	// for details.
	// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetPreviewTimestamp(UtcMs) VisionEpisodeFace
	// DVR recording status: fully recorded, not recorded, or partially recorded
	RecordingStatus() *string
	// DVR recording status: fully recorded, not recorded, or partially recorded
	SetRecordingStatus(string) VisionEpisodeFace
	// This field can be used as indication of the fact that some system have checked and ensured that
	// this episode has really started at some time, that may differ from `opened_at`.
	// For example video analytics will use this field for the time when this episode was confirmed as confident.
	// May be not relevant for television systems.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	StartedAt() *UtcMs
	// This field can be used as indication of the fact that some system have checked and ensured that
	// this episode has really started at some time, that may differ from `opened_at`.
	// For example video analytics will use this field for the time when this episode was confirmed as confident.
	// May be not relevant for television systems.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetStartedAt(UtcMs) VisionEpisodeFace
	// The time of last change of the episode.
	// System that processes episodes and can send them to other systems, MUST update this field
	// on any changes in this episode.
	// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
	// this `updated_at` can be used as a sort key for fetching fresh updates.
	// Consumer of the episodes can use `updated_at` in the following scenario:
	// * fetch all exisiting episodes from the source
	// * take biggest `updated_at` from this dataset, it will be T
	// * ask source for all episodes with `updated_at > T`
	// This algorithm can be used for fetching update stream from the source.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637098611e+12
	UpdatedAt() UtcMs
	// The time of last change of the episode.
	// System that processes episodes and can send them to other systems, MUST update this field
	// on any changes in this episode.
	// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
	// this `updated_at` can be used as a sort key for fetching fresh updates.
	// Consumer of the episodes can use `updated_at` in the following scenario:
	// * fetch all exisiting episodes from the source
	// * take biggest `updated_at` from this dataset, it will be T
	// * ask source for all episodes with `updated_at > T`
	// This algorithm can be used for fetching update stream from the source.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637098611e+12
	SetUpdatedAt(UtcMs) VisionEpisodeFace
}

type VisionEpisodeHuman interface {
	// The reason for closing the episode.
	CloseReason() *EpisodeCloseReason
	// The reason for closing the episode.
	SetCloseReason(EpisodeCloseReason) VisionEpisodeHuman
	// Episode emitter can decide that episode considered closed and will not grow further.
	// `closed_at` MUST NOT change, it must be emitted only once.
	// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
	// of the episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	ClosedAt() *UtcMs
	// Episode emitter can decide that episode considered closed and will not grow further.
	// `closed_at` MUST NOT change, it must be emitted only once.
	// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
	// of the episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetClosedAt(UtcMs) VisionEpisodeHuman
	// Detections associated with this episode
	Detections() []VisionDetectedObjectBase
	// Detections associated with this episode
	SetDetections([]VisionDetectedObjectBase) VisionEpisodeHuman
	// The time when the episode appeared in the service relative to the server time.
	EpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps
	// The time when the episode appeared in the service relative to the server time.
	SetEpisodeAppearanceTimestamps(EpisodeAppearanceTimestamps) VisionEpisodeHuman
	// Unique identifier of the episode. Must be created by the system that first creates this episode.
	// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
	// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
	// handle very long integers.
	// Format: snowflake_id (snowflake_id)
	// Examples: 1.722279170848854e+18
	EpisodeID() SnowflakeID
	// Unique identifier of the episode. Must be created by the system that first creates this episode.
	// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
	// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
	// handle very long integers.
	// Format: snowflake_id (snowflake_id)
	// Examples: 1.722279170848854e+18
	SetEpisodeID(SnowflakeID) VisionEpisodeHuman
	// Human is detected
	EpisodeType() *string
	// Human is detected
	SetEpisodeType(string) VisionEpisodeHuman
	// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
	// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
	// Format: base64 (base64)
	FramePreview() *Base64
	// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
	// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
	// Format: base64 (base64)
	SetFramePreview(Base64) VisionEpisodeHuman
	// Stream name on which this episode exists.
	// Format: media_name (media_name)
	Media() MediaName
	// Stream name on which this episode exists.
	// Format: media_name (media_name)
	SetMedia(MediaName) VisionEpisodeHuman
	// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
	// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
	// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
	// sort as by `opened_at`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	OpenedAt() UtcMs
	// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
	// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
	// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
	// sort as by `opened_at`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetOpenedAt(UtcMs) VisionEpisodeHuman
	// This describes the way this episode was updated, whether via an inference node or an API.
	// In the case of an inference node, its hostname will be provided.
	Originator() EpisodeOriginator
	// This describes the way this episode was updated, whether via an inference node or an API.
	// In the case of an inference node, its hostname will be provided.
	SetOriginator(EpisodeOriginator) VisionEpisodeHuman
	// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Format: base64 (base64)
	Preview() *Base64
	// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Format: base64 (base64)
	SetPreview(Base64) VisionEpisodeHuman
	// The time when the preview of this episode is available.
	// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
	// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
	// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
	// for details.
	// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	PreviewTimestamp() *UtcMs
	// The time when the preview of this episode is available.
	// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
	// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
	// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
	// for details.
	// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetPreviewTimestamp(UtcMs) VisionEpisodeHuman
	// DVR recording status: fully recorded, not recorded, or partially recorded
	RecordingStatus() *string
	// DVR recording status: fully recorded, not recorded, or partially recorded
	SetRecordingStatus(string) VisionEpisodeHuman
	// This field can be used as indication of the fact that some system have checked and ensured that
	// this episode has really started at some time, that may differ from `opened_at`.
	// For example video analytics will use this field for the time when this episode was confirmed as confident.
	// May be not relevant for television systems.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	StartedAt() *UtcMs
	// This field can be used as indication of the fact that some system have checked and ensured that
	// this episode has really started at some time, that may differ from `opened_at`.
	// For example video analytics will use this field for the time when this episode was confirmed as confident.
	// May be not relevant for television systems.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetStartedAt(UtcMs) VisionEpisodeHuman
	// The time of last change of the episode.
	// System that processes episodes and can send them to other systems, MUST update this field
	// on any changes in this episode.
	// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
	// this `updated_at` can be used as a sort key for fetching fresh updates.
	// Consumer of the episodes can use `updated_at` in the following scenario:
	// * fetch all exisiting episodes from the source
	// * take biggest `updated_at` from this dataset, it will be T
	// * ask source for all episodes with `updated_at > T`
	// This algorithm can be used for fetching update stream from the source.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637098611e+12
	UpdatedAt() UtcMs
	// The time of last change of the episode.
	// System that processes episodes and can send them to other systems, MUST update this field
	// on any changes in this episode.
	// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
	// this `updated_at` can be used as a sort key for fetching fresh updates.
	// Consumer of the episodes can use `updated_at` in the following scenario:
	// * fetch all exisiting episodes from the source
	// * take biggest `updated_at` from this dataset, it will be T
	// * ask source for all episodes with `updated_at > T`
	// This algorithm can be used for fetching update stream from the source.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637098611e+12
	SetUpdatedAt(UtcMs) VisionEpisodeHuman
}

type VisionEpisodeQrCode interface {
	// The reason for closing the episode.
	CloseReason() *EpisodeCloseReason
	// The reason for closing the episode.
	SetCloseReason(EpisodeCloseReason) VisionEpisodeQrCode
	// Episode emitter can decide that episode considered closed and will not grow further.
	// `closed_at` MUST NOT change, it must be emitted only once.
	// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
	// of the episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	ClosedAt() *UtcMs
	// Episode emitter can decide that episode considered closed and will not grow further.
	// `closed_at` MUST NOT change, it must be emitted only once.
	// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
	// of the episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetClosedAt(UtcMs) VisionEpisodeQrCode
	// The time when the episode appeared in the service relative to the server time.
	EpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps
	// The time when the episode appeared in the service relative to the server time.
	SetEpisodeAppearanceTimestamps(EpisodeAppearanceTimestamps) VisionEpisodeQrCode
	// Unique identifier of the episode. Must be created by the system that first creates this episode.
	// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
	// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
	// handle very long integers.
	// Format: snowflake_id (snowflake_id)
	// Examples: 1.722279170848854e+18
	EpisodeID() SnowflakeID
	// Unique identifier of the episode. Must be created by the system that first creates this episode.
	// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
	// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
	// handle very long integers.
	// Format: snowflake_id (snowflake_id)
	// Examples: 1.722279170848854e+18
	SetEpisodeID(SnowflakeID) VisionEpisodeQrCode
	// QR-code is detected
	EpisodeType() *string
	// QR-code is detected
	SetEpisodeType(string) VisionEpisodeQrCode
	// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
	// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
	// Format: base64 (base64)
	FramePreview() *Base64
	// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
	// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
	// Format: base64 (base64)
	SetFramePreview(Base64) VisionEpisodeQrCode
	// Stream name on which this episode exists.
	// Format: media_name (media_name)
	Media() MediaName
	// Stream name on which this episode exists.
	// Format: media_name (media_name)
	SetMedia(MediaName) VisionEpisodeQrCode
	// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
	// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
	// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
	// sort as by `opened_at`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	OpenedAt() UtcMs
	// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
	// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
	// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
	// sort as by `opened_at`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetOpenedAt(UtcMs) VisionEpisodeQrCode
	// This describes the way this episode was updated, whether via an inference node or an API.
	// In the case of an inference node, its hostname will be provided.
	Originator() EpisodeOriginator
	// This describes the way this episode was updated, whether via an inference node or an API.
	// In the case of an inference node, its hostname will be provided.
	SetOriginator(EpisodeOriginator) VisionEpisodeQrCode
	// Raw data extracted from QR-code
	// Example: WIFI:T:WPA;S:MyOfficeWiFi;P:Mypassword;H:;
	Payload() *string
	// Raw data extracted from QR-code
	// Example: WIFI:T:WPA;S:MyOfficeWiFi;P:Mypassword;H:;
	SetPayload(string) VisionEpisodeQrCode
	// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Format: base64 (base64)
	Preview() *Base64
	// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Format: base64 (base64)
	SetPreview(Base64) VisionEpisodeQrCode
	// The time when the preview of this episode is available.
	// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
	// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
	// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
	// for details.
	// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	PreviewTimestamp() *UtcMs
	// The time when the preview of this episode is available.
	// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
	// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
	// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
	// for details.
	// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetPreviewTimestamp(UtcMs) VisionEpisodeQrCode
	// DVR recording status: fully recorded, not recorded, or partially recorded
	RecordingStatus() *string
	// DVR recording status: fully recorded, not recorded, or partially recorded
	SetRecordingStatus(string) VisionEpisodeQrCode
	// This field can be used as indication of the fact that some system have checked and ensured that
	// this episode has really started at some time, that may differ from `opened_at`.
	// For example video analytics will use this field for the time when this episode was confirmed as confident.
	// May be not relevant for television systems.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	StartedAt() *UtcMs
	// This field can be used as indication of the fact that some system have checked and ensured that
	// this episode has really started at some time, that may differ from `opened_at`.
	// For example video analytics will use this field for the time when this episode was confirmed as confident.
	// May be not relevant for television systems.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetStartedAt(UtcMs) VisionEpisodeQrCode
	// The time of last change of the episode.
	// System that processes episodes and can send them to other systems, MUST update this field
	// on any changes in this episode.
	// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
	// this `updated_at` can be used as a sort key for fetching fresh updates.
	// Consumer of the episodes can use `updated_at` in the following scenario:
	// * fetch all exisiting episodes from the source
	// * take biggest `updated_at` from this dataset, it will be T
	// * ask source for all episodes with `updated_at > T`
	// This algorithm can be used for fetching update stream from the source.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637098611e+12
	UpdatedAt() UtcMs
	// The time of last change of the episode.
	// System that processes episodes and can send them to other systems, MUST update this field
	// on any changes in this episode.
	// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
	// this `updated_at` can be used as a sort key for fetching fresh updates.
	// Consumer of the episodes can use `updated_at` in the following scenario:
	// * fetch all exisiting episodes from the source
	// * take biggest `updated_at` from this dataset, it will be T
	// * ask source for all episodes with `updated_at > T`
	// This algorithm can be used for fetching update stream from the source.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637098611e+12
	SetUpdatedAt(UtcMs) VisionEpisodeQrCode
}

type VisionEpisodeVehicle interface {
	// The reason for closing the episode.
	CloseReason() *EpisodeCloseReason
	// The reason for closing the episode.
	SetCloseReason(EpisodeCloseReason) VisionEpisodeVehicle
	// Episode emitter can decide that episode considered closed and will not grow further.
	// `closed_at` MUST NOT change, it must be emitted only once.
	// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
	// of the episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	ClosedAt() *UtcMs
	// Episode emitter can decide that episode considered closed and will not grow further.
	// `closed_at` MUST NOT change, it must be emitted only once.
	// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
	// of the episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetClosedAt(UtcMs) VisionEpisodeVehicle
	// Detections associated with this episode
	Detections() []any
	// Detections associated with this episode
	SetDetections([]any) VisionEpisodeVehicle
	// The time when the episode appeared in the service relative to the server time.
	EpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps
	// The time when the episode appeared in the service relative to the server time.
	SetEpisodeAppearanceTimestamps(EpisodeAppearanceTimestamps) VisionEpisodeVehicle
	// Unique identifier of the episode. Must be created by the system that first creates this episode.
	// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
	// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
	// handle very long integers.
	// Format: snowflake_id (snowflake_id)
	// Examples: 1.722279170848854e+18
	EpisodeID() SnowflakeID
	// Unique identifier of the episode. Must be created by the system that first creates this episode.
	// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
	// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
	// handle very long integers.
	// Format: snowflake_id (snowflake_id)
	// Examples: 1.722279170848854e+18
	SetEpisodeID(SnowflakeID) VisionEpisodeVehicle
	// Vehicle is detected
	EpisodeType() *string
	// Vehicle is detected
	SetEpisodeType(string) VisionEpisodeVehicle
	// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
	// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
	// Format: base64 (base64)
	FramePreview() *Base64
	// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
	// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
	// Format: base64 (base64)
	SetFramePreview(Base64) VisionEpisodeVehicle
	// Indicates if no license plate is detected on this vehicle
	LicensePlateMissing() *bool
	// Indicates if no license plate is detected on this vehicle
	SetLicensePlateMissing(bool) VisionEpisodeVehicle
	// Recognized vehicle's license plate number
	LicensePlateText() *string
	// Recognized vehicle's license plate number
	SetLicensePlateText(string) VisionEpisodeVehicle
	// Stream name on which this episode exists.
	// Format: media_name (media_name)
	Media() MediaName
	// Stream name on which this episode exists.
	// Format: media_name (media_name)
	SetMedia(MediaName) VisionEpisodeVehicle
	// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
	// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
	// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
	// sort as by `opened_at`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	OpenedAt() UtcMs
	// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
	// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
	// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
	// sort as by `opened_at`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetOpenedAt(UtcMs) VisionEpisodeVehicle
	// This describes the way this episode was updated, whether via an inference node or an API.
	// In the case of an inference node, its hostname will be provided.
	Originator() EpisodeOriginator
	// This describes the way this episode was updated, whether via an inference node or an API.
	// In the case of an inference node, its hostname will be provided.
	SetOriginator(EpisodeOriginator) VisionEpisodeVehicle
	// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Preview contains an image of vehicle's license plate and has a resolution about 160 x 64 pixels with maximum size about 10 kilobytes.
	// Format: base64 (base64)
	Preview() Base64
	// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Preview contains an image of vehicle's license plate and has a resolution about 160 x 64 pixels with maximum size about 10 kilobytes.
	// Format: base64 (base64)
	SetPreview(Base64) VisionEpisodeVehicle
	// The time when the preview of this episode is available.
	// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
	// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
	// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
	// for details.
	// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	PreviewTimestamp() *UtcMs
	// The time when the preview of this episode is available.
	// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
	// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
	// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
	// for details.
	// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetPreviewTimestamp(UtcMs) VisionEpisodeVehicle
	// DVR recording status: fully recorded, not recorded, or partially recorded
	RecordingStatus() *string
	// DVR recording status: fully recorded, not recorded, or partially recorded
	SetRecordingStatus(string) VisionEpisodeVehicle
	// This field can be used as indication of the fact that some system have checked and ensured that
	// this episode has really started at some time, that may differ from `opened_at`.
	// For example video analytics will use this field for the time when this episode was confirmed as confident.
	// May be not relevant for television systems.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	StartedAt() *UtcMs
	// This field can be used as indication of the fact that some system have checked and ensured that
	// this episode has really started at some time, that may differ from `opened_at`.
	// For example video analytics will use this field for the time when this episode was confirmed as confident.
	// May be not relevant for television systems.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetStartedAt(UtcMs) VisionEpisodeVehicle
	// The time of last change of the episode.
	// System that processes episodes and can send them to other systems, MUST update this field
	// on any changes in this episode.
	// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
	// this `updated_at` can be used as a sort key for fetching fresh updates.
	// Consumer of the episodes can use `updated_at` in the following scenario:
	// * fetch all exisiting episodes from the source
	// * take biggest `updated_at` from this dataset, it will be T
	// * ask source for all episodes with `updated_at > T`
	// This algorithm can be used for fetching update stream from the source.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637098611e+12
	UpdatedAt() UtcMs
	// The time of last change of the episode.
	// System that processes episodes and can send them to other systems, MUST update this field
	// on any changes in this episode.
	// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
	// this `updated_at` can be used as a sort key for fetching fresh updates.
	// Consumer of the episodes can use `updated_at` in the following scenario:
	// * fetch all exisiting episodes from the source
	// * take biggest `updated_at` from this dataset, it will be T
	// * ask source for all episodes with `updated_at > T`
	// This algorithm can be used for fetching update stream from the source.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637098611e+12
	SetUpdatedAt(UtcMs) VisionEpisodeVehicle
	// Emergency type of the vehicle.
	VehicleEmergencySubtype() *VisionVehicleEmergencySubtype
	// Emergency type of the vehicle.
	SetVehicleEmergencySubtype(VisionVehicleEmergencySubtype) VisionEpisodeVehicle
	// Shows from which side the vehicle was detected.
	VehicleFacingSide() *VisionVehicleFacingSide
	// Shows from which side the vehicle was detected.
	SetVehicleFacingSide(VisionVehicleFacingSide) VisionEpisodeVehicle
	// The purpose of the vehicle, e.g. emergency or regular.
	VehiclePurpose() *VisionVehiclePurpose
	// The purpose of the vehicle, e.g. emergency or regular.
	SetVehiclePurpose(VisionVehiclePurpose) VisionEpisodeVehicle
}

type VisionFaceAttributes interface {
	// The fingerprint of the detected face
	Fingerprint() VisionFaceFingerprint
	// The fingerprint of the detected face
	SetFingerprint(VisionFaceFingerprint) VisionFaceAttributes
}

// Digital fingerprint of the face
// Required: data, version
type VisionFaceFingerprint interface {
	// Base64 encoded representation of the fingerprint
	// Format: base64 (base64)
	Data() Base64
	// Base64 encoded representation of the fingerprint
	// Format: base64 (base64)
	SetData(Base64) VisionFaceFingerprint
	// Version identifier of the fingerprint's data. The version is assigned automatically.
	// Fingerprints of different versions cannot be compared to each other.
	// Examples: aabbccdd, c6ba4246
	Version() string
	// Version identifier of the fingerprint's data. The version is assigned automatically.
	// Fingerprints of different versions cannot be compared to each other.
	// Examples: aabbccdd, c6ba4246
	SetVersion(string) VisionFaceFingerprint
}

// Required: data
type VisionImageAttributes interface {
	// Base64-encoded image data
	// Format: base64 (base64)
	Data() Base64
	// Base64-encoded image data
	// Format: base64 (base64)
	SetData(Base64) VisionImageAttributes
	// MIME type of the image
	MimeType() *VisionImageMimetype
	// MIME type of the image
	SetMimeType(VisionImageMimetype) VisionImageAttributes
	// Checksum of this image
	// Format: hexbinary (hexbinary)
	Sha256() *Hexbinary
	// Checksum of this image
	// Format: hexbinary (hexbinary)
	SetSha256(Hexbinary) VisionImageAttributes
}

// Attributes of the detected vehicle
type VisionLicensePlateAttributes interface {
	// Shows from which side the vehicle was detected.
	FacingSide() *VisionVehicleFacingSide
	// Shows from which side the vehicle was detected.
	SetFacingSide(VisionVehicleFacingSide) VisionLicensePlateAttributes
	// Recognized vehicle's license plate number
	PlateText() *string
	// Recognized vehicle's license plate number
	SetPlateText(string) VisionLicensePlateAttributes
}

// Person
// Required: person_id, updated_at, originator
type VisionPerson interface {
	// When this person was marked as deleted
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637095014573e+12
	DeletedAt() *UtcMs
	// When this person was marked as deleted
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637095014573e+12
	SetDeletedAt(UtcMs) VisionPerson
	// Identifier of the person in the external system.
	// Use it when supplying the recognition results further into the external system
	// (e.g. for access level check) if the person identifiers in the external system
	// are different from the ones in Flussonic Identification database.
	// This field may contain `null` when video analytics detects a new person
	// which explicitly has no association in the external system (i.e. if `originator=identification_service`).
	// Examples: dedcc8e8
	ExternalID() *string
	// Identifier of the person in the external system.
	// Use it when supplying the recognition results further into the external system
	// (e.g. for access level check) if the person identifiers in the external system
	// are different from the ones in Flussonic Identification database.
	// This field may contain `null` when video analytics detects a new person
	// which explicitly has no association in the external system (i.e. if `originator=identification_service`).
	// Examples: dedcc8e8
	SetExternalID(string) VisionPerson
	// Digital fingerprints of the person.
	// Videoanalytics makes digital fingerprint of the person
	// using uploaded photos or videostreams being processed
	Fingerprints() []VisionFaceFingerprint
	// Digital fingerprints of the person.
	// Videoanalytics makes digital fingerprint of the person
	// using uploaded photos or videostreams being processed
	SetFingerprints([]VisionFaceFingerprint) VisionPerson
	// Indicates the way this person was created:
	// manually via an api or automatically in the identification service.
	Originator() VisionPersonOriginator
	// Indicates the way this person was created:
	// manually via an api or automatically in the identification service.
	SetOriginator(VisionPersonOriginator) VisionPerson
	// Identifier of the person
	// Format: snowflake_id (snowflake_id)
	// Examples: 7.036001172460667e+18
	PersonID() SnowflakeID
	// Identifier of the person
	// Format: snowflake_id (snowflake_id)
	// Examples: 7.036001172460667e+18
	SetPersonID(SnowflakeID) VisionPerson
	// Person's photos. External system uploads images
	// which are being processed by videoanalytics
	// to get digital fingerprint of the person
	Photos() []VisionImageAttributes
	// Person's photos. External system uploads images
	// which are being processed by videoanalytics
	// to get digital fingerprint of the person
	SetPhotos([]VisionImageAttributes) VisionPerson
	// When this person was last updated
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637034282845e+12
	UpdatedAt() UtcMs
	// When this person was last updated
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637034282845e+12
	SetUpdatedAt(UtcMs) VisionPerson
}

// Person matching information
// Required: person, match_score
type VisionPersonMatch interface {
	// Score of the match with person. 1.0 means absolute match
	MatchScore() float64
	// Score of the match with person. 1.0 means absolute match
	SetMatchScore(float64) VisionPersonMatch
	// Matched person
	Person() VisionPerson
	// Matched person
	SetPerson(VisionPerson) VisionPersonMatch
}

type VisionPersonsList interface {
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	EstimatedCount() *int
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	SetEstimatedCount(int) VisionPersonsList
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	Next() *string
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	SetNext(string) VisionPersonsList
	// List of fetched persons according to the query parameters.
	Persons() []VisionPerson
	// List of fetched persons according to the query parameters.
	SetPersons([]VisionPerson) VisionPersonsList
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	Prev() *string
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	SetPrev(string) VisionPersonsList
	// An object with a list of different timings measured during this API call.
	Timing() any
	// An object with a list of different timings measured during this API call.
	SetTiming(any) VisionPersonsList
	// Collection returns the collection items
	Collection() []VisionPerson
}

// 2D point
// Required: x, y
type VisionPoint interface {
	// X coordinate. Fraction of full frame width
	// Examples: 0.54, 0.78
	X() float64
	// X coordinate. Fraction of full frame width
	// Examples: 0.54, 0.78
	SetX(float64) VisionPoint
	// Y coordinate. Fraction of full frame height
	// Examples: 0.12, 0.38
	Y() float64
	// Y coordinate. Fraction of full frame height
	// Examples: 0.12, 0.38
	SetY(float64) VisionPoint
}

type VisionSpec interface {
	// The algorithm used for video analytics.
	// Example: faces
	Alg() *VisionSpecAlg
	// The algorithm used for video analytics.
	// Example: faces
	SetAlg(VisionSpecAlg) VisionSpec
	// This parameter allows you to select specific polygonal area(s) for detection.
	// By default, it is empty, and the recognition system searches over the entire camera field of view.
	// Each area is specified as a sequence of comma-separated coordinates of vertices of the polygon: `x0,y0,x1,y1,x2,y2,...`.
	// The vertices are specified in a counter-clockwise direction. Multiple areas are separated by `:`.
	Areas() *string
	// This parameter allows you to select specific polygonal area(s) for detection.
	// By default, it is empty, and the recognition system searches over the entire camera field of view.
	// Each area is specified as a sequence of comma-separated coordinates of vertices of the polygon: `x0,y0,x1,y1,x2,y2,...`.
	// The vertices are specified in a counter-clockwise direction. Multiple areas are separated by `:`.
	SetAreas(string) VisionSpec
	// Configuration of videoanalytics modules.
	// This configuration supersedes `alg` and `areas` parameters.
	// If this field is specified, values of `alg` and `areas` fields are being ignored.
	Detectors() []VisionDetectorConfig
	// Configuration of videoanalytics modules.
	// This configuration supersedes `alg` and `areas` parameters.
	// If this field is specified, values of `alg` and `areas` fields are being ignored.
	SetDetectors([]VisionDetectorConfig) VisionSpec
}

type VisionVehicleAttributes interface {
	// Indicates if no license plate is detected on this vehicle
	LicensePlateMissing() *bool
	// Indicates if no license plate is detected on this vehicle
	SetLicensePlateMissing(bool) VisionVehicleAttributes
	// The purpose of the vehicle, e.g. emergency or regular.
	Purpose() *VisionVehiclePurpose
	// The purpose of the vehicle, e.g. emergency or regular.
	SetPurpose(VisionVehiclePurpose) VisionVehicleAttributes
}

type WatcherAgentConfig interface {
	// Agent identifier
	// Example: 1234567
	ID() *string
	// Agent identifier
	// Example: 1234567
	SetID(string) WatcherAgentConfig
	// Agent authentication key.
	Key() *string
	// Agent authentication key.
	SetKey(string) WatcherAgentConfig
	// Agents's metrics and other statistical information.
	Stats() WatcherAgentStats
	// Agents's metrics and other statistical information.
	SetStats(WatcherAgentStats) WatcherAgentConfig
}

type WatcherAgentControlConnection interface {
	// A flag showing if Agent is connected at the moment of the request.
	Alive() *bool
	// A flag showing if Agent is connected at the moment of the request.
	SetAlive(bool) WatcherAgentControlConnection
	// A number of bytes received from the server by Agent since `opened_at`.
	// Format: bytes (bytes)
	// Example: 40000
	BytesFromServer() *Bytes
	// A number of bytes received from the server by Agent since `opened_at`.
	// Format: bytes (bytes)
	// Example: 40000
	SetBytesFromServer(Bytes) WatcherAgentControlConnection
	// A number of bytes sent to the server by Agent since `opened_at`.
	// Format: bytes (bytes)
	// Example: 4e+11
	BytesToServer() *Bytes
	// A number of bytes sent to the server by Agent since `opened_at`.
	// Format: bytes (bytes)
	// Example: 4e+11
	SetBytesToServer(Bytes) WatcherAgentControlConnection
	// Hostname of the server
	// Example: agents-001.vsaas.io
	Hostname() *string
	// Hostname of the server
	// Example: agents-001.vsaas.io
	SetHostname(string) WatcherAgentControlConnection
	// Timestamp of the current Agent control connection opening.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	OpenedAt() *UtcMs
	// Timestamp of the current Agent control connection opening.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	SetOpenedAt(UtcMs) WatcherAgentControlConnection
	// UTC timestamp of the last Agent status change to offline or online.
	// Same as `opened_at` if Agent is now connected.
	// Format: utc (Unix timestamp in seconds)
	// Example: 1.634560921e+09
	StatusChangedAt() *Utc
	// UTC timestamp of the last Agent status change to offline or online.
	// Same as `opened_at` if Agent is now connected.
	// Format: utc (Unix timestamp in seconds)
	// Example: 1.634560921e+09
	SetStatusChangedAt(Utc) WatcherAgentControlConnection
}

type WatcherAgentDataConnections interface {
	// A number of times the streamer tried to open a data connection via this Agent.
	// Example: 400
	ConnectionsAttempted() *int
	// A number of times the streamer tried to open a data connection via this Agent.
	// Example: 400
	SetConnectionsAttempted(int) WatcherAgentDataConnections
	// A number of currently active data connections opened via this Agent.
	// Example: 2
	ConnectionsCurrent() *int
	// A number of currently active data connections opened via this Agent.
	// Example: 2
	SetConnectionsCurrent(int) WatcherAgentDataConnections
	// A number of successfully opened data connections via this Agent.
	// Example: 300
	ConnectionsOpened() *int
	// A number of successfully opened data connections via this Agent.
	// Example: 300
	SetConnectionsOpened(int) WatcherAgentDataConnections
}

type WatcherAgentLogs interface {
	// Encoded log data for security purposes. Only the support team can decrypt it.
	// Example: VDEVSvaNZZWeNOXqi7tA5Hm+KAqBjfHQKMzMl5aqRdYxHZkSnJ
	A() *string
	// Encoded log data for security purposes. Only the support team can decrypt it.
	// Example: VDEVSvaNZZWeNOXqi7tA5Hm+KAqBjfHQKMzMl5aqRdYxHZkSnJ
	SetA(string) WatcherAgentLogs
	// Agent id
	// Example: 1234567
	AgentID() *string
	// Agent id
	// Example: 1234567
	SetAgentID(string) WatcherAgentLogs
	// Encoded log data for security purposes. Only the support team can decrypt it.
	// Example: xglytWCTztsbTAUVBIhQymqik7nvzXi5VbJWEQNBHFCxw/NdvY6hdknh87/3gslKpER0hIaymR67Qo8zGKICFN==
	B() *string
	// Encoded log data for security purposes. Only the support team can decrypt it.
	// Example: xglytWCTztsbTAUVBIhQymqik7nvzXi5VbJWEQNBHFCxw/NdvY6hdknh87/3gslKpER0hIaymR67Qo8zGKICFN==
	SetB(string) WatcherAgentLogs
	// Shows agent's buffer limit.
	// Example: 0
	BufferLimit() *int
	// Shows agent's buffer limit.
	// Example: 0
	SetBufferLimit(int) WatcherAgentLogs
	// Shows agent's buffer size.
	// Example: 0
	BufferSize() *int
	// Shows agent's buffer size.
	// Example: 0
	SetBufferSize(int) WatcherAgentLogs
	// Agent client ID.
	// Example: 42195
	Cid() *string
	// Agent client ID.
	// Example: 42195
	SetCid(string) WatcherAgentLogs
	// Main endpoint URL (Watcher host)
	// Example: http://example.com
	MainURL() *string
	// Main endpoint URL (Watcher host)
	// Example: http://example.com
	SetMainURL(string) WatcherAgentLogs
	// Physical memory size available on the device.
	// Example: 806400
	Meminfo() *string
	// Physical memory size available on the device.
	// Example: 806400
	SetMeminfo(string) WatcherAgentLogs
	// Agent model ID.
	// Example: 3059
	Mid() *string
	// Agent model ID.
	// Example: 3059
	SetMid(string) WatcherAgentLogs
	// Agent serial
	// Example: a3dccd69f53deb79723a2a7a5f2037e1
	Serial() *string
	// Agent serial
	// Example: a3dccd69f53deb79723a2a7a5f2037e1
	SetSerial(string) WatcherAgentLogs
	// Agent status
	// Example: ok
	Status() *string
	// Agent status
	// Example: ok
	SetStatus(string) WatcherAgentLogs
	// Agent version
	// Example: version
	Version() *string
	// Agent version
	// Example: version
	SetVersion(string) WatcherAgentLogs
}

type WatcherAgentStats interface {
	// The type of Agent installed on the device:
	// * `single` means "one Agent = one camera", i.e. Agent is installed on a camera itself.
	// * `router` means "one Agent = multiple cameras", i.e. Agent is installed on a router
	// to provision the cameras from LAN to Watcher.
	AgentType() *string
	// The type of Agent installed on the device:
	// * `single` means "one Agent = one camera", i.e. Agent is installed on a camera itself.
	// * `router` means "one Agent = multiple cameras", i.e. Agent is installed on a router
	// to provision the cameras from LAN to Watcher.
	SetAgentType(string) WatcherAgentStats
	// The number of successfully established connections.
	ConnectionsEstablished() *int
	// The number of successfully established connections.
	SetConnectionsEstablished(int) WatcherAgentStats
	// The number of connections requested by Agent.
	ConnectionsRequested() *int
	// The number of connections requested by Agent.
	SetConnectionsRequested(int) WatcherAgentStats
	// Parameters of the connection between Agent and its endpoint.
	EndpointConnection() WatcherAgentControlConnection
	// Parameters of the connection between Agent and its endpoint.
	SetEndpointConnection(WatcherAgentControlConnection) WatcherAgentStats
	// IP address of the device (camera or router) in the local network.
	// Format: ipv4 (ipv4)
	// Example: 10.10.17.88
	LocalIP() *Ipv4
	// IP address of the device (camera or router) in the local network.
	// Format: ipv4 (ipv4)
	// Example: 10.10.17.88
	SetLocalIP(Ipv4) WatcherAgentStats
	// MAC-address of the device.
	// Example: F0-23-B9-59-20-F1
	MacAddress() *string
	// MAC-address of the device.
	// Example: F0-23-B9-59-20-F1
	SetMacAddress(string) WatcherAgentStats
	// Public IP address of the device (camera or router) on which the Agent is running.
	// Format: ipv4 (ipv4)
	// Example: 185.134.232.183
	PeerIP() *Ipv4
	// Public IP address of the device (camera or router) on which the Agent is running.
	// Format: ipv4 (ipv4)
	// Example: 185.134.232.183
	SetPeerIP(Ipv4) WatcherAgentStats
	// Parameters of the connection between Agent and its streampoint.
	StreampointConnection() WatcherAgentStatsStreampointConnection
	// Parameters of the connection between Agent and its streampoint.
	SetStreampointConnection(WatcherAgentStatsStreampointConnection) WatcherAgentStats
	// Agent version.
	// Example: v21.02-8-g535c85d
	Version() *string
	// Agent version.
	// Example: v21.02-8-g535c85d
	SetVersion(string) WatcherAgentStats
}

// Parameters of the connection between Agent and its streampoint.
type WatcherAgentStatsStreampointConnection interface {
	// A flag showing if Agent is connected at the moment of the request.
	Alive() *bool
	// A flag showing if Agent is connected at the moment of the request.
	SetAlive(bool) WatcherAgentStatsStreampointConnection
	// A number of bytes received from the server by Agent since `opened_at`.
	// Format: bytes (bytes)
	// Example: 40000
	BytesFromServer() *Bytes
	// A number of bytes received from the server by Agent since `opened_at`.
	// Format: bytes (bytes)
	// Example: 40000
	SetBytesFromServer(Bytes) WatcherAgentStatsStreampointConnection
	// A number of bytes sent to the server by Agent since `opened_at`.
	// Format: bytes (bytes)
	// Example: 4e+11
	BytesToServer() *Bytes
	// A number of bytes sent to the server by Agent since `opened_at`.
	// Format: bytes (bytes)
	// Example: 4e+11
	SetBytesToServer(Bytes) WatcherAgentStatsStreampointConnection
	// A number of times the streamer tried to open a data connection via this Agent.
	// Example: 400
	ConnectionsAttempted() *int
	// A number of times the streamer tried to open a data connection via this Agent.
	// Example: 400
	SetConnectionsAttempted(int) WatcherAgentStatsStreampointConnection
	// A number of currently active data connections opened via this Agent.
	// Example: 2
	ConnectionsCurrent() *int
	// A number of currently active data connections opened via this Agent.
	// Example: 2
	SetConnectionsCurrent(int) WatcherAgentStatsStreampointConnection
	// A number of successfully opened data connections via this Agent.
	// Example: 300
	ConnectionsOpened() *int
	// A number of successfully opened data connections via this Agent.
	// Example: 300
	SetConnectionsOpened(int) WatcherAgentStatsStreampointConnection
	// Hostname of the server
	// Example: agents-001.vsaas.io
	Hostname() *string
	// Hostname of the server
	// Example: agents-001.vsaas.io
	SetHostname(string) WatcherAgentStatsStreampointConnection
	// Timestamp of the current Agent control connection opening.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	OpenedAt() *UtcMs
	// Timestamp of the current Agent control connection opening.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	SetOpenedAt(UtcMs) WatcherAgentStatsStreampointConnection
	// UTC timestamp of the last Agent status change to offline or online.
	// Same as `opened_at` if Agent is now connected.
	// Format: utc (Unix timestamp in seconds)
	// Example: 1.634560921e+09
	StatusChangedAt() *Utc
	// UTC timestamp of the last Agent status change to offline or online.
	// Same as `opened_at` if Agent is now connected.
	// Format: utc (Unix timestamp in seconds)
	// Example: 1.634560921e+09
	SetStatusChangedAt(Utc) WatcherAgentStatsStreampointConnection
}

type WebrtcAbrOpts interface {
	// Video track number from which playback starts. Possible values: `v1`, `v2`, `v3` and so on.
	// If not specified, or an audio track specified (`start_track=a3`), or a video track number does not exist,
	// playback starts with the track number in the middle of the list (e.g. `v2` if you have tracks `v1`, `v2`, and `v3`)
	// and then adjusts to the bandwidth availability.
	// If some tracks are excluded by the query parameter `?filter=tracks:...`, Flussonic searches for an available track with a lower number up to v0.
	// If no track with a lower number was found, Flussonic searches for a closest track with a higher number.
	// Example: v2
	StartTrack() *string
	// Video track number from which playback starts. Possible values: `v1`, `v2`, `v3` and so on.
	// If not specified, or an audio track specified (`start_track=a3`), or a video track number does not exist,
	// playback starts with the track number in the middle of the list (e.g. `v2` if you have tracks `v1`, `v2`, and `v3`)
	// and then adjusts to the bandwidth availability.
	// If some tracks are excluded by the query parameter `?filter=tracks:...`, Flussonic searches for an available track with a lower number up to v0.
	// If no track with a lower number was found, Flussonic searches for a closest track with a higher number.
	// Example: v2
	SetStartTrack(string) WebrtcAbrOpts
}

type APICallImpl struct {
	CreatedAtValue   *DateTime     `json:"created_at,omitempty" validate:"omitempty"`
	DurationValue    *Microseconds `json:"duration,omitempty" validate:"omitempty"`
	IPValue          *IP           `json:"ip,omitempty" validate:"omitempty"`
	OperationIDValue *string       `json:"operation_id,omitempty" validate:"omitempty"`
	OriginatorValue  *string       `json:"originator,omitempty" validate:"omitempty"`
	PayloadValue     *string       `json:"payload,omitempty" validate:"omitempty"`
	RequestIDValue   *string       `json:"request_id,omitempty" validate:"omitempty"`
	StatusValue      *int          `json:"status,omitempty" validate:"omitempty"`
	UserAgentValue   *string       `json:"user_agent,omitempty" validate:"omitempty"`
}

type APICallEventImpl struct {
	RequestIDValue   *string                `json:"request_id,omitempty" validate:"omitempty"`
	PayloadValue     *string                `json:"payload,omitempty" validate:"omitempty"`
	EntityIDValue    *string                `json:"entity_id,omitempty" validate:"omitempty"`
	EntityTypeValue  *EntityEventEntityType `json:"entity_type,omitempty" validate:"omitempty,oneof=agent stream streamer"`
	UtcMsValue       *UtcMs                 `json:"utc_ms,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	EventIDValue     *int                   `json:"event_id,omitempty" validate:"omitempty"`
	IPValue          *IP                    `json:"ip,omitempty" validate:"omitempty"`
	OperationIDValue *string                `json:"operation_id,omitempty" validate:"omitempty"`
	DurationValue    *Microseconds          `json:"duration,omitempty" validate:"omitempty"`
	OriginatorValue  *string                `json:"originator,omitempty" validate:"omitempty"`
	PathValue        *string                `json:"path,omitempty" validate:"omitempty"`
	QsValue          *string                `json:"qs,omitempty" validate:"omitempty"`
	CreatedAtValue   *DateTime              `json:"created_at,omitempty" validate:"omitempty"`
	ServerValue      *string                `json:"server,omitempty" validate:"omitempty"`
	StatusValue      *int                   `json:"status,omitempty" validate:"omitempty"`
	TraceIDValue     *UUID                  `json:"trace_id,omitempty" validate:"omitempty"`
	UserAgentValue   *string                `json:"user_agent,omitempty" validate:"omitempty"`
	EventValue       string                 `json:"event" validate:"required"`
}

// This object describes one API token with its unique text, permissions, etc.
// Required: key, name
type APITokenImpl struct {
	AuthScopesValue  []string                  `json:"auth_scopes,omitempty" validate:"omitempty"`
	KeyValue         string                    `json:"key" validate:"required"`
	NameValue        string                    `json:"name" validate:"required"`
	PermissionsValue []*APITokenPermissionImpl `json:"permissions,omitempty" validate:"omitempty"`
}

// Required: scopes
type APITokenPermissionImpl struct {
	ExecuteValue *bool    `json:"execute,omitempty" validate:"omitempty"`
	ListValue    *bool    `json:"list,omitempty" validate:"omitempty"`
	ReadValue    *bool    `json:"read,omitempty" validate:"omitempty"`
	WriteValue   *bool    `json:"write,omitempty" validate:"omitempty"`
	ScopesValue  []string `json:"scopes" validate:"required"`
}

type APITokensListImpl struct {
	TimingValue         any             `json:"timing,omitempty" validate:"omitempty"`
	EstimatedCountValue *int            `json:"estimated_count,omitempty" validate:"omitempty"`
	NextValue           *string         `json:"next,omitempty" validate:"omitempty"`
	PrevValue           *string         `json:"prev,omitempty" validate:"omitempty"`
	APITokensValue      []*APITokenImpl `json:"api_tokens,omitempty" validate:"omitempty"`
}

// Required: login, password
type AdminCredentialsImpl struct {
	LoginValue    string   `json:"login" validate:"required"`
	PasswordValue Password `json:"password" validate:"required"`
}

type AgentCommandHandlingImpl struct {
	CommandValue    *AgentCommandHandlingCommand `json:"command,omitempty" validate:"omitempty,oneof=hello description streampoint_connect streampoint_connected streampoint_connect_failure streampoint_disconnect streampoint_disconnected reset reboot disconnect"`
	EntityIDValue   *string                      `json:"entity_id,omitempty" validate:"omitempty"`
	EntityTypeValue *EntityEventEntityType       `json:"entity_type,omitempty" validate:"omitempty,oneof=agent stream streamer"`
	ErrorValue      *AgentCommandHandlingError   `json:"error,omitempty" validate:"omitempty,oneof=timeout connection_closed"`
	EventIDValue    *int                         `json:"event_id,omitempty" validate:"omitempty"`
	InitiatorValue  *AgentInitiator              `json:"initiator,omitempty" validate:"omitempty"`
	PayloadValue    *string                      `json:"payload,omitempty" validate:"omitempty"`
	ServerValue     *string                      `json:"server,omitempty" validate:"omitempty"`
	TraceIDValue    *UUID                        `json:"trace_id,omitempty" validate:"omitempty"`
	UtcMsValue      *UtcMs                       `json:"utc_ms,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	EventValue      string                       `json:"event" validate:"required"`
}

type AgentConfigBaseImpl struct {
	IDValue    *string                `json:"id,omitempty" validate:"omitempty"`
	KeyValue   *string                `json:"key,omitempty" validate:"omitempty"`
	StatsValue *WatcherAgentStatsImpl `json:"stats,omitempty" validate:"omitempty"`
}

type AgentConnectFailedImpl struct {
	EntityIDValue   *string                   `json:"entity_id,omitempty" validate:"omitempty"`
	EntityTypeValue *EntityEventEntityType    `json:"entity_type,omitempty" validate:"omitempty,oneof=agent stream streamer"`
	EventIDValue    *int                      `json:"event_id,omitempty" validate:"omitempty"`
	MessageValue    *string                   `json:"message,omitempty" validate:"omitempty"`
	ReasonValue     *AgentConnectFailedReason `json:"reason,omitempty" validate:"omitempty,oneof=internal_server_error authentication_failed"`
	ServerValue     *string                   `json:"server,omitempty" validate:"omitempty"`
	TraceIDValue    *UUID                     `json:"trace_id,omitempty" validate:"omitempty"`
	UtcMsValue      *UtcMs                    `json:"utc_ms,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	EventValue      string                    `json:"event" validate:"required"`
}

type AgentConnectedImpl struct {
	EntityIDValue   *string                `json:"entity_id,omitempty" validate:"omitempty"`
	EntityTypeValue *EntityEventEntityType `json:"entity_type,omitempty" validate:"omitempty,oneof=agent stream streamer"`
	EventIDValue    *int                   `json:"event_id,omitempty" validate:"omitempty"`
	ServerValue     *string                `json:"server,omitempty" validate:"omitempty"`
	TraceIDValue    *UUID                  `json:"trace_id,omitempty" validate:"omitempty"`
	UtcMsValue      *UtcMs                 `json:"utc_ms,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	EventValue      string                 `json:"event" validate:"required"`
}

type AgentDisconnectedImpl struct {
	EntityIDValue   *string                  `json:"entity_id,omitempty" validate:"omitempty"`
	EntityTypeValue *EntityEventEntityType   `json:"entity_type,omitempty" validate:"omitempty,oneof=agent stream streamer"`
	EventIDValue    *int                     `json:"event_id,omitempty" validate:"omitempty"`
	InitiatorValue  *AgentInitiator          `json:"initiator,omitempty" validate:"omitempty"`
	ReasonValue     *AgentDisconnectedReason `json:"reason,omitempty" validate:"omitempty,oneof=ping_timeout set_write_deadline_fail set_read_deadline_fail agent_closed_connection"`
	ServerValue     *string                  `json:"server,omitempty" validate:"omitempty"`
	TraceIDValue    *UUID                    `json:"trace_id,omitempty" validate:"omitempty"`
	UtcMsValue      *UtcMs                   `json:"utc_ms,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	EventValue      string                   `json:"event" validate:"required"`
}

type AgentMakeStreampointLocationErrorImpl struct {
	EntityIDValue    *string                                  `json:"entity_id,omitempty" validate:"omitempty"`
	EntityTypeValue  *EntityEventEntityType                   `json:"entity_type,omitempty" validate:"omitempty,oneof=agent stream streamer"`
	EventValue       *string                                  `json:"event,omitempty" validate:"omitempty"`
	EventIDValue     *int                                     `json:"event_id,omitempty" validate:"omitempty"`
	MessageValue     *string                                  `json:"message,omitempty" validate:"omitempty"`
	ReasonValue      *AgentMakeStreampointLocationErrorReason `json:"reason,omitempty" validate:"omitempty,oneof=streamer_misses_streampoint_key"`
	ServerValue      *string                                  `json:"server,omitempty" validate:"omitempty"`
	StreampointValue *string                                  `json:"streampoint,omitempty" validate:"omitempty"`
	TraceIDValue     *UUID                                    `json:"trace_id,omitempty" validate:"omitempty"`
	UtcMsValue       *UtcMs                                   `json:"utc_ms,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
}

// Required: name
type AuthBackendConfigImpl struct {
	AllowDefaultValue   *bool                 `json:"allow_default,omitempty" validate:"omitempty"`
	NameValue           AuthBackendName       `json:"name" validate:"required"`
	AllowCountriesValue []string              `json:"allow_countries,omitempty" validate:"omitempty"`
	AllowIpsValue       []string              `json:"allow_ips,omitempty" validate:"omitempty"`
	AllowTokensValue    []string              `json:"allow_tokens,omitempty" validate:"omitempty"`
	AllowUasValue       []string              `json:"allow_uas,omitempty" validate:"omitempty"`
	BackendsValue       []*AuthBackendURLImpl `json:"backends,omitempty" validate:"omitempty"`
	DenyCountriesValue  []string              `json:"deny_countries,omitempty" validate:"omitempty"`
	DenyIpsValue        []string              `json:"deny_ips,omitempty" validate:"omitempty"`
	DenyTokensValue     []string              `json:"deny_tokens,omitempty" validate:"omitempty"`
	DenyUasValue        []string              `json:"deny_uas,omitempty" validate:"omitempty"`
}

// Required: url
type AuthBackendURLImpl struct {
	URLValue string `json:"url" validate:"required"`
}

type AuthBackendsListImpl struct {
	TimingValue         any                      `json:"timing,omitempty" validate:"omitempty"`
	EstimatedCountValue *int                     `json:"estimated_count,omitempty" validate:"omitempty"`
	NextValue           *string                  `json:"next,omitempty" validate:"omitempty"`
	PrevValue           *string                  `json:"prev,omitempty" validate:"omitempty"`
	AuthBackendsValue   []*AuthBackendConfigImpl `json:"auth_backends,omitempty" validate:"omitempty"`
}

type AuthResponseV1Impl struct {
	AdInjectValue         *AuthResponseV1AdInjectImpl               `json:"ad_inject,omitempty" validate:"omitempty"`
	AllowedDvrRangesValue []*AuthResponseV1AllowedDvrRangesItemImpl `json:"allowed_dvr_ranges,omitempty" validate:"omitempty"`
}

// Configuration of injecting advertising video clips into played stream.
type AuthResponseV1AdInjectImpl struct {
	MidrollInsertByValue  *AuthResponseV1AdInjectMidrollInsertBy `json:"midroll_insert_by,omitempty" validate:"omitempty,oneof=interval splicing"`
	MidrollIntervalValue  *int                                   `json:"midroll_interval,omitempty" validate:"omitempty"`
	MidrollProgramIDValue *int                                   `json:"midroll_program_id,omitempty" validate:"omitempty"`
	VValue                *int                                   `json:"v,omitempty" validate:"omitempty"`
	MidrollValue          []string                               `json:"midroll,omitempty" validate:"omitempty"`
	PrerollValue          []string                               `json:"preroll,omitempty" validate:"omitempty"`
}

// 'opened_at' or 'closed_at' can be omitted (not both), which means open interval.
type AuthResponseV1AllowedDvrRangesItemImpl struct {
	ClosedAtValue *Utc `json:"closed_at,omitempty" validate:"omitempty,min=1e+09,max=1e+10"`
	OpenedAtValue *Utc `json:"opened_at,omitempty" validate:"omitempty,min=1e+09,max=1e+10"`
}

type AuthSpecImpl struct {
	ExtraValue               map[string]string `json:"extra,omitempty" validate:"omitempty"`
	MaxSessionsValue         *int              `json:"max_sessions,omitempty" validate:"omitempty"`
	SoftLimitationValue      *bool             `json:"soft_limitation,omitempty" validate:"omitempty"`
	URLValue                 *AuthURL          `json:"url,omitempty" validate:"omitempty"`
	AllowedCountriesValue    []Iso3166         `json:"allowed_countries,omitempty" validate:"omitempty"`
	DisallowedCountriesValue []Iso3166         `json:"disallowed_countries,omitempty" validate:"omitempty"`
	DomainsValue             []string          `json:"domains,omitempty" validate:"omitempty"`
	SessionKeysValue         []SessionKey      `json:"session_keys,omitempty" validate:"omitempty"`
}

type BackupConfigImpl struct {
	AudioTimeoutValue *int    `json:"audio_timeout,omitempty" validate:"omitempty"`
	DvrValue          *bool   `json:"dvr,omitempty" validate:"omitempty"`
	FileValue         *string `json:"file,omitempty" validate:"omitempty"`
	TimeoutValue      *int    `json:"timeout,omitempty" validate:"omitempty"`
	TranscodeValue    *bool   `json:"transcode,omitempty" validate:"omitempty"`
	VideoTimeoutValue *int    `json:"video_timeout,omitempty" validate:"omitempty"`
}

type BalancerConfigImpl struct {
	ModeValue    *BalancerConfigMode         `json:"mode,omitempty" validate:"omitempty,oneof=usage clients bitrate streams"`
	NameValue    *MediaName                  `json:"name,omitempty" validate:"omitempty"`
	ServersValue []*BalancerServerConfigImpl `json:"servers,omitempty" validate:"omitempty"`
}

type BalancerServerConfigImpl struct {
	CountriesDefaultValue *bool       `json:"countries_default,omitempty" validate:"omitempty"`
	MaxBitrateValue       *Speed      `json:"max_bitrate,omitempty" validate:"omitempty"`
	NameValue             *ServerName `json:"name,omitempty" validate:"omitempty"`
	CountriesValue        []Iso3166   `json:"countries,omitempty" validate:"omitempty"`
}

type BalancersListImpl struct {
	TimingValue         any                   `json:"timing,omitempty" validate:"omitempty"`
	EstimatedCountValue *int                  `json:"estimated_count,omitempty" validate:"omitempty"`
	NextValue           *string               `json:"next,omitempty" validate:"omitempty"`
	PrevValue           *string               `json:"prev,omitempty" validate:"omitempty"`
	BalancersValue      []*BalancerConfigImpl `json:"balancers,omitempty" validate:"omitempty"`
}

type CentralAgentConfigImpl struct {
	IDValue     *string                      `json:"id,omitempty" validate:"omitempty"`
	KeyValue    *string                      `json:"key,omitempty" validate:"omitempty"`
	LayoutValue *CentralStreamLayoutBaseImpl `json:"layout,omitempty" validate:"omitempty"`
	StatsValue  *WatcherAgentStatsImpl       `json:"stats,omitempty" validate:"omitempty"`
}

type CentralAgentLayoutListImpl struct {
	LayoutsValue []*CentralAgentLayoutListItemImpl `json:"layouts,omitempty" validate:"omitempty"`
}

type CentralAgentLayoutListItemImpl struct {
	CreatedAtValue  *UtcMs                         `json:"created_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	IDValue         *string                        `json:"id,omitempty" validate:"omitempty"`
	IngestValue     *ServerName                    `json:"ingest,omitempty" validate:"omitempty"`
	OriginatorValue *CentralStreamLayoutOriginator `json:"originator,omitempty" validate:"omitempty"`
}

type CentralAgentsListImpl struct {
	TimingValue         any                       `json:"timing,omitempty" validate:"omitempty"`
	EstimatedCountValue *int                      `json:"estimated_count,omitempty" validate:"omitempty"`
	NextValue           *string                   `json:"next,omitempty" validate:"omitempty"`
	PrevValue           *string                   `json:"prev,omitempty" validate:"omitempty"`
	AgentsValue         []*CentralAgentConfigImpl `json:"agents,omitempty" validate:"omitempty"`
}

// Required: database, api_key
type CentralConfigImpl struct {
	LayouterEnabledValue                      *string                    `json:"layouter_enabled,omitempty" validate:"omitempty"`
	ListenersValue                            *ListenersImpl             `json:"listeners,omitempty" validate:"omitempty"`
	ClusterValue                              *CentralConfigClusterImpl  `json:"cluster,omitempty" validate:"omitempty"`
	ConfigExternalReconciliationIntervalValue *float64                   `json:"config_external_reconciliation_interval,omitempty" validate:"omitempty"`
	DatabaseValue                             *CentralConfigDatabaseImpl `json:"database" validate:"required"`
	EditAuthValue                             *AdminCredentialsImpl      `json:"edit_auth,omitempty" validate:"omitempty"`
	EpisodesBufferDelayValue                  *Milliseconds              `json:"episodes_buffer_delay,omitempty" validate:"omitempty"`
	EpisodesBufferLimitValue                  *float64                   `json:"episodes_buffer_limit,omitempty" validate:"omitempty"`
	APIURLValue                               *URL                       `json:"api_url,omitempty" validate:"omitempty"`
	StreamerHealthcheckFailsThresholdValue    *float64                   `json:"streamer_healthcheck_fails_threshold,omitempty" validate:"omitempty"`
	LayouterSleepingIntervalValue             *Milliseconds              `json:"layouter_sleeping_interval,omitempty" validate:"omitempty"`
	LogRequestsValue                          *string                    `json:"log_requests,omitempty" validate:"omitempty"`
	LoglevelValue                             *Loglevel                  `json:"loglevel,omitempty" validate:"omitempty"`
	OpentelemetryURLValue                     *URL                       `json:"opentelemetry_url,omitempty" validate:"omitempty"`
	RedisValue                                *CentralConfigRedisImpl    `json:"redis,omitempty" validate:"omitempty"`
	ServerIDValue                             *UUID                      `json:"server_id,omitempty" validate:"omitempty" openmetrics_label:"server_id"`
	StatsValue                                *CentralStatsImpl          `json:"stats,omitempty" validate:"omitempty"`
	APIKeyValue                               string                     `json:"api_key" validate:"required"`
}

type CentralConfigClusterImpl struct {
	NodeConfigProvisionEnabledValue *bool `json:"node_config_provision_enabled,omitempty" validate:"omitempty"`
	StreamerConnectorRetriesValue   *int  `json:"streamer_connector_retries,omitempty" validate:"omitempty"`
}

// Required: url
type CentralConfigDatabaseImpl struct {
	ConnectMaxRetriesValue   *int    `json:"connect_max_retries,omitempty" validate:"omitempty"`
	ConnectRetryTimeoutValue *string `json:"connect_retry_timeout,omitempty" validate:"omitempty"`
	MaxConnectionsValue      *int    `json:"max_connections,omitempty" validate:"omitempty"`
	URLValue                 string  `json:"url" validate:"required"`
}

type CentralConfigRedisImpl struct {
	ConnectMaxRetriesValue   *int    `json:"connect_max_retries,omitempty" validate:"omitempty"`
	ConnectRetryTimeoutValue *string `json:"connect_retry_timeout,omitempty" validate:"omitempty"`
	MaxConnectionsValue      *int    `json:"max_connections,omitempty" validate:"omitempty"`
	URLValue                 *string `json:"url,omitempty" validate:"omitempty"`
}

// Predictions for disk usage.
type CentralDiskPredictionsImpl struct {
	EstimatedDiskUsageValue *Percent `json:"estimated_disk_usage,omitempty" validate:"omitempty,min=0,max=100"`
}

type CentralDvrConfigImpl struct {
	NameValue *DvrName `json:"name,omitempty" validate:"omitempty"`
}

type CentralDvrsListImpl struct {
	TimingValue         any                     `json:"timing,omitempty" validate:"omitempty"`
	EstimatedCountValue *int                    `json:"estimated_count,omitempty" validate:"omitempty"`
	NextValue           *string                 `json:"next,omitempty" validate:"omitempty"`
	PrevValue           *string                 `json:"prev,omitempty" validate:"omitempty"`
	DvrsValue           []*CentralDvrConfigImpl `json:"dvrs,omitempty" validate:"omitempty"`
}

type CentralEventImpl struct {
	EntityBodyValue     any                                `json:"entity_body,omitempty" validate:"omitempty"`
	ReasonValue         any                                `json:"reason,omitempty" validate:"omitempty,oneof=internal_server_error authentication_failed"`
	ErrorValue          any                                `json:"error,omitempty" validate:"omitempty,oneof=timeout connection_closed"`
	RequestIDValue      *string                            `json:"request_id,omitempty" validate:"omitempty"`
	PreviousStateValue  *PreviousServerState               `json:"previous_state,omitempty" validate:"omitempty"`
	EntityIDValue       *string                            `json:"entity_id,omitempty" validate:"omitempty"`
	EntityTypeValue     *EntityEventEntityType             `json:"entity_type,omitempty" validate:"omitempty,oneof=agent stream streamer"`
	CreatedAtValue      *DateTime                          `json:"created_at,omitempty" validate:"omitempty"`
	VersionValue        *string                            `json:"version,omitempty" validate:"omitempty"`
	EventIDValue        *int                               `json:"event_id,omitempty" validate:"omitempty"`
	FullVersionValue    *string                            `json:"full_version,omitempty" validate:"omitempty"`
	InitiatorValue      *AgentInitiator                    `json:"initiator,omitempty" validate:"omitempty"`
	InstanceIDValue     *string                            `json:"instance_id,omitempty" validate:"omitempty"`
	IPValue             *IP                                `json:"ip,omitempty" validate:"omitempty"`
	MessageValue        *string                            `json:"message,omitempty" validate:"omitempty"`
	OperationIDValue    *string                            `json:"operation_id,omitempty" validate:"omitempty"`
	OriginatorValue     *string                            `json:"originator,omitempty" validate:"omitempty"`
	DurationValue       *Microseconds                      `json:"duration,omitempty" validate:"omitempty"`
	UtcMsValue          *UtcMs                             `json:"utc_ms,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	ServerValue         *string                            `json:"server,omitempty" validate:"omitempty"`
	QsValue             *string                            `json:"qs,omitempty" validate:"omitempty"`
	QueryValue          *string                            `json:"query,omitempty" validate:"omitempty"`
	CommandValue        *AgentCommandHandlingCommand       `json:"command,omitempty" validate:"omitempty,oneof=hello description streampoint_connect streampoint_connected streampoint_connect_failure streampoint_disconnect streampoint_disconnected reset reboot disconnect"`
	PayloadValue        *string                            `json:"payload,omitempty" validate:"omitempty"`
	AgentsUpdatedValue  *int                               `json:"agents_updated,omitempty" validate:"omitempty"`
	PathValue           *string                            `json:"path,omitempty" validate:"omitempty"`
	StatusValue         *int                               `json:"status,omitempty" validate:"omitempty"`
	StreampointValue    *string                            `json:"streampoint,omitempty" validate:"omitempty"`
	StreamsUpdatedValue *int                               `json:"streams_updated,omitempty" validate:"omitempty"`
	TraceIDValue        *UUID                              `json:"trace_id,omitempty" validate:"omitempty"`
	UserAgentValue      *string                            `json:"user_agent,omitempty" validate:"omitempty"`
	EventValue          string                             `json:"event" validate:"required"`
	RelayoutsValue      []*CentralStreamLayoutListItemImpl `json:"relayouts,omitempty" validate:"omitempty"`
}

type CentralEventsListImpl struct {
	TimingValue         any                 `json:"timing,omitempty" validate:"omitempty"`
	EstimatedCountValue *int                `json:"estimated_count,omitempty" validate:"omitempty"`
	NextValue           *string             `json:"next,omitempty" validate:"omitempty"`
	PrevValue           *string             `json:"prev,omitempty" validate:"omitempty"`
	EventsValue         []*CentralEventImpl `json:"events,omitempty" validate:"omitempty"`
}

// Status of Central healthcheck.
type CentralHealthcheckStatusImpl struct {
	ChecksValue          *CentralHealthcheckStatusChecksImpl `json:"checks,omitempty" validate:"omitempty"`
	StatusValue          *CentralHealthcheckStatusStatus     `json:"status,omitempty" validate:"omitempty,oneof=ok error"`
	StatusChangedAtValue *UtcMs                              `json:"status_changed_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
}

// List of healthcheck checks with their results.
type CentralHealthcheckStatusChecksImpl struct {
	ConfigExternalOkValue *bool                                                  `json:"config_external_ok,omitempty" validate:"omitempty"`
	ConfigOkValue         *bool                                                  `json:"config_ok,omitempty" validate:"omitempty"`
	ReachableValue        *bool                                                  `json:"reachable,omitempty" validate:"omitempty"`
	RproxyOkValue         *bool                                                  `json:"rproxy_ok,omitempty" validate:"omitempty"`
	RunningValue          *bool                                                  `json:"running,omitempty" validate:"omitempty"`
	TimeSynchronizedValue *bool                                                  `json:"time_synchronized,omitempty" validate:"omitempty"`
	ValidClusterKeyValue  *bool                                                  `json:"valid_cluster_key,omitempty" validate:"omitempty"`
	ErrorsDetailsValue    []*CentralHealthcheckStatusChecksErrorsDetailsItemImpl `json:"errors_details,omitempty" validate:"omitempty"`
}

// Error details
type CentralHealthcheckStatusChecksErrorsDetailsItemImpl struct {
	ErrorValue *string `json:"error,omitempty" validate:"omitempty"`
	RuleValue  *string `json:"rule,omitempty" validate:"omitempty"`
}

type CentralIdentificationNodeImpl struct {
	APIURLValue       *URL                 `json:"api_url,omitempty" validate:"omitempty"`
	ChannelLimitValue *int                 `json:"channel_limit,omitempty" validate:"omitempty"`
	ClusterKeyValue   *string              `json:"cluster_key,omitempty" validate:"omitempty"`
	CpuLimitValue     *Percent             `json:"cpu_limit,omitempty" validate:"omitempty,min=0,max=100"`
	FetchTimeoutValue *Milliseconds        `json:"fetch_timeout,omitempty" validate:"omitempty"`
	HostnameValue     *ServerName          `json:"hostname,omitempty" validate:"omitempty"`
	MaxBitrateValue   *Speed               `json:"max_bitrate,omitempty" validate:"omitempty"`
	NamespaceValue    *UnixName            `json:"namespace,omitempty" validate:"omitempty"`
	RoleValue         *CentralNodeRoleRole `json:"role,omitempty" validate:"omitempty,oneof=streamer inference identification"`
	StaleTimeoutValue *Milliseconds        `json:"stale_timeout,omitempty" validate:"omitempty"`
	StatsValue        *PeerStatsImpl       `json:"stats,omitempty" validate:"omitempty"`
}

type CentralInferenceNodeImpl struct {
	APIURLValue       *URL                 `json:"api_url,omitempty" validate:"omitempty"`
	ChannelLimitValue *int                 `json:"channel_limit,omitempty" validate:"omitempty"`
	ClusterKeyValue   *string              `json:"cluster_key,omitempty" validate:"omitempty"`
	CpuLimitValue     *Percent             `json:"cpu_limit,omitempty" validate:"omitempty,min=0,max=100"`
	FetchTimeoutValue *Milliseconds        `json:"fetch_timeout,omitempty" validate:"omitempty"`
	HostnameValue     *ServerName          `json:"hostname,omitempty" validate:"omitempty"`
	LabelsValue       map[string]UnixName  `json:"labels,omitempty" validate:"omitempty"`
	MaxBitrateValue   *Speed               `json:"max_bitrate,omitempty" validate:"omitempty"`
	NamespaceValue    *UnixName            `json:"namespace,omitempty" validate:"omitempty"`
	RoleValue         *CentralNodeRoleRole `json:"role,omitempty" validate:"omitempty,oneof=streamer inference identification"`
	StaleTimeoutValue *Milliseconds        `json:"stale_timeout,omitempty" validate:"omitempty"`
	StatsValue        *PeerStatsImpl       `json:"stats,omitempty" validate:"omitempty"`
}

type CentralNodeLayoutDecisionImpl struct {
	HostnameValue     *ServerName                       `json:"hostname,omitempty" validate:"omitempty"`
	NodeDecisionValue *bool                             `json:"node_decision,omitempty" validate:"omitempty"`
	RoleValue         *CentralNodeRoleRole              `json:"role,omitempty" validate:"omitempty,oneof=streamer inference identification"`
	ReasonsValue      []CentralNodeLayoutDecisionReason `json:"reasons,omitempty" validate:"omitempty"`
}

type CentralNodeRoleImpl struct {
	RoleValue *CentralNodeRoleRole `json:"role,omitempty" validate:"omitempty,oneof=streamer inference identification"`
}

// Cluster stats
type CentralStatsImpl struct {
	IDValue            *UUID          `json:"id,omitempty" validate:"omitempty"`
	ServerVersionValue *ServerVersion `json:"server_version,omitempty" validate:"omitempty" openmetrics_label:"version"`
	StartedAtValue     *Utc           `json:"started_at,omitempty" validate:"omitempty,min=1e+09,max=1e+10"`
	UptimeValue        *Seconds       `json:"uptime,omitempty" validate:"omitempty"`
}

type CentralStreamConfigImpl struct {
	ClientsTimeoutValue                    any                                  `json:"clients_timeout,omitempty" validate:"omitempty"`
	SourceTimeoutValue                     any                                  `json:"source_timeout,omitempty" validate:"omitempty"`
	PrepushValue                           any                                  `json:"prepush,omitempty" validate:"omitempty"`
	NamespaceValue                         *UnixName                            `json:"namespace,omitempty" validate:"omitempty"`
	Srt2PublishValue                       *SrtConfigImpl                       `json:"srt2_publish,omitempty" validate:"omitempty"`
	ClaimsValue                            *CentralStreamLayoutConfigClaimsImpl `json:"claims,omitempty" validate:"omitempty"`
	BackupValue                            *BackupConfigImpl                    `json:"backup,omitempty" validate:"omitempty"`
	CommentValue                           *string                              `json:"comment,omitempty" validate:"omitempty"`
	ConfigOnDiskValue                      *StreamConfigStrippedImpl            `json:"config_on_disk,omitempty" validate:"omitempty"`
	DisabledValue                          *bool                                `json:"disabled,omitempty" validate:"omitempty"`
	DrmValue                               *DrmSpecImpl                         `json:"drm,omitempty" validate:"omitempty"`
	DvbocrValue                            *StreamConfigInputDvbocr             `json:"dvbocr,omitempty" validate:"omitempty,oneof=replace add"`
	DvrValue                               *StreamDvrSpecImpl                   `json:"dvr,omitempty" validate:"omitempty"`
	EpgEnabledValue                        *bool                                `json:"epg_enabled,omitempty" validate:"omitempty"`
	HlsScte35Value                         *StreamConfigMediaHlsScte35          `json:"hls_scte35,omitempty" validate:"omitempty,oneof=aws scte35 rfc8216"`
	WebrtcAbrValue                         *WebrtcAbrOptsImpl                   `json:"webrtc_abr,omitempty" validate:"omitempty"`
	VisionValue                            *VisionSpecImpl                      `json:"vision,omitempty" validate:"omitempty"`
	JpegSnapshotSignKeyValue               *string                              `json:"jpeg_snapshot_sign_key,omitempty" validate:"omitempty"`
	LabelsValue                            map[string]UnixName                  `json:"labels,omitempty" validate:"omitempty,dive,min=1,max=40"`
	LayoutValue                            *CentralStreamLayoutImpl             `json:"layout,omitempty" validate:"omitempty"`
	MaxRetryTimeoutValue                   *Seconds                             `json:"max_retry_timeout,omitempty" validate:"omitempty,min=1"`
	MetaValue                              map[string]string                    `json:"meta,omitempty" validate:"omitempty"`
	MpegtsAc3Value                         *OutputMpegtsAc3                     `json:"mpegts_ac3,omitempty" validate:"omitempty"`
	MpegtsPidsValue                        *OutputMpegtsPidsImpl                `json:"mpegts_pids,omitempty" validate:"omitempty"`
	VideoTimeoutValue                      *Seconds                             `json:"video_timeout,omitempty" validate:"omitempty"`
	NamedByValue                           *NamedBy                             `json:"named_by,omitempty" validate:"omitempty"`
	AddAudioOnlyValue                      *bool                                `json:"add_audio_only,omitempty" validate:"omitempty"`
	ChunkDurationValue                     *Milliseconds                        `json:"chunk_duration,omitempty" validate:"omitempty"`
	ThumbnailsValue                        *ThumbnailsSpecImpl                  `json:"thumbnails,omitempty" validate:"omitempty"`
	InputMediaInfoValue                    *InputMediaInfoImpl                  `json:"input_media_info,omitempty" validate:"omitempty"`
	PositionValue                          *SortIndex                           `json:"position,omitempty" validate:"omitempty"`
	AutogeneratedEpisodesCloseTimeoutValue *Seconds                             `json:"autogenerated_episodes_close_timeout,omitempty" validate:"omitempty,min=0"`
	ProtocolsValue                         *PlayProtocolsSpecImpl               `json:"protocols,omitempty" validate:"omitempty"`
	ProviderValue                          *string                              `json:"provider,omitempty" validate:"omitempty"`
	URLPrefixValue                         *URLPrefix                           `json:"url_prefix,omitempty" validate:"omitempty"`
	RecheckSecondaryInputsIntervalValue    *Seconds                             `json:"recheck_secondary_inputs_interval,omitempty" validate:"omitempty"`
	RetryLimitValue                        *int                                 `json:"retry_limit,omitempty" validate:"omitempty"`
	SegmentCountValue                      *int                                 `json:"segment_count,omitempty" validate:"omitempty"`
	SegmentDurationValue                   *Milliseconds                        `json:"segment_duration,omitempty" validate:"omitempty"`
	AudioTimeoutValue                      *Seconds                             `json:"audio_timeout,omitempty" validate:"omitempty"`
	OnPlayValue                            *AuthSpecImpl                        `json:"on_play,omitempty" validate:"omitempty"`
	SrtPortResolveValue                    *bool                                `json:"srt_port_resolve,omitempty" validate:"omitempty"`
	SrtPublishValue                        *SrtConfigImpl                       `json:"srt_publish,omitempty" validate:"omitempty"`
	StaticValue                            *bool                                `json:"static,omitempty" validate:"omitempty"`
	StatsValue                             *StreamStatsImpl                     `json:"stats,omitempty" validate:"omitempty"`
	TemplateValue                          *MediaName                           `json:"template,omitempty" validate:"omitempty"`
	OnPublishValue                         *AuthSpecImpl                        `json:"on_publish,omitempty" validate:"omitempty"`
	TitleValue                             *string                              `json:"title,omitempty" validate:"omitempty"`
	TranscoderValue                        *TranscoderOptsImpl                  `json:"transcoder,omitempty" validate:"omitempty"`
	TransportValue                         *WebrtcTransport                     `json:"transport,omitempty" validate:"omitempty"`
	NameValue                              MediaName                            `json:"name" validate:"required" openmetrics_label:"name"`
	PushesValue                            []*StreamPushImpl                    `json:"pushes,omitempty" validate:"omitempty"`
	InputsValue                            []*StreamInputImpl                   `json:"inputs,omitempty" validate:"omitempty"`
	PlaybackHeadersValue                   []*PlaybackHeadersImpl               `json:"playback_headers,omitempty" validate:"omitempty"`
	UpdatedAtValue                         UtcMs                                `json:"updated_at" validate:"required,min=1e+12,max=1e+13"`
}

// Required: updated_at
type CentralStreamConfigAdditionalImpl struct {
	AutogeneratedEpisodesCloseTimeoutValue *Seconds  `json:"autogenerated_episodes_close_timeout,omitempty" validate:"omitempty,min=0"`
	NamespaceValue                         *UnixName `json:"namespace,omitempty" validate:"omitempty"`
	UpdatedAtValue                         UtcMs     `json:"updated_at" validate:"required,min=1e+12,max=1e+13"`
}

type CentralStreamLayoutImpl struct {
	ChangeReasonValue        *CentralStreamLayoutChangeReason `json:"change_reason,omitempty" validate:"omitempty,oneof=stream_misses_node_required_labels node_misses_stream_required_labels node_become_offline stream_disabled node_deleted node_channel_limit_exceeded multistream_agent_ingest_conflict streamer_dvr_size_exceeded streamer_total_bandwidth_exceeded preferred_labels_better_match not_distributed dvr_redundancy_adjust node_cpu_pressure relayout_by_api namespace_mismatch"`
	CreatedAtValue           *UtcMs                           `json:"created_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	FailoverFromValue        *ServerName                      `json:"failover_from,omitempty" validate:"omitempty"`
	InferenceValue           *ServerName                      `json:"inference,omitempty" validate:"omitempty"`
	IngestValue              *ServerName                      `json:"ingest,omitempty" validate:"omitempty"`
	OriginatorValue          *CentralStreamLayoutOriginator   `json:"originator,omitempty" validate:"omitempty"`
	DvrBackupsValue          []ServerName                     `json:"dvr_backups,omitempty" validate:"omitempty"`
	IngestHistoryValue       []*CentralStreamLayoutBaseImpl   `json:"ingest_history,omitempty" validate:"omitempty"`
	NodeLayoutDecisionsValue []*CentralNodeLayoutDecisionImpl `json:"node_layout_decisions,omitempty" validate:"omitempty"`
}

type CentralStreamLayoutBaseImpl struct {
	CreatedAtValue  *UtcMs                         `json:"created_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	IngestValue     *ServerName                    `json:"ingest,omitempty" validate:"omitempty"`
	OriginatorValue *CentralStreamLayoutOriginator `json:"originator,omitempty" validate:"omitempty"`
}

type CentralStreamLayoutConfigImpl struct {
	ClaimsValue *CentralStreamLayoutConfigClaimsImpl `json:"claims,omitempty" validate:"omitempty"`
	LayoutValue *CentralStreamLayoutImpl             `json:"layout,omitempty" validate:"omitempty"`
}

// User-defined claims about the stream parameters.
// Set this field so that [layouter](https://flussonic.com/doc/api/layouter/) can rely on this data when distributing streams.
type CentralStreamLayoutConfigClaimsImpl struct {
	BitrateValue *Speed `json:"bitrate,omitempty" validate:"omitempty"`
}

type CentralStreamLayoutListImpl struct {
	LayoutsValue []*CentralStreamLayoutListItemImpl `json:"layouts,omitempty" validate:"omitempty"`
}

type CentralStreamLayoutListItemImpl struct {
	ChangeReasonValue        *CentralStreamLayoutChangeReason `json:"change_reason,omitempty" validate:"omitempty,oneof=stream_misses_node_required_labels node_misses_stream_required_labels node_become_offline stream_disabled node_deleted node_channel_limit_exceeded multistream_agent_ingest_conflict streamer_dvr_size_exceeded streamer_total_bandwidth_exceeded preferred_labels_better_match not_distributed dvr_redundancy_adjust node_cpu_pressure relayout_by_api namespace_mismatch"`
	CreatedAtValue           *UtcMs                           `json:"created_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	FailoverFromValue        *ServerName                      `json:"failover_from,omitempty" validate:"omitempty"`
	InferenceValue           *ServerName                      `json:"inference,omitempty" validate:"omitempty"`
	IngestValue              *ServerName                      `json:"ingest,omitempty" validate:"omitempty"`
	NameValue                *string                          `json:"name,omitempty" validate:"omitempty"`
	OriginatorValue          *CentralStreamLayoutOriginator   `json:"originator,omitempty" validate:"omitempty"`
	DvrBackupsValue          []ServerName                     `json:"dvr_backups,omitempty" validate:"omitempty"`
	IngestHistoryValue       []*CentralStreamLayoutBaseImpl   `json:"ingest_history,omitempty" validate:"omitempty"`
	NodeLayoutDecisionsValue []*CentralNodeLayoutDecisionImpl `json:"node_layout_decisions,omitempty" validate:"omitempty"`
}

type CentralStreamLayoutPredictionImpl struct {
	TimingValue         any                                `json:"timing,omitempty" validate:"omitempty"`
	EstimatedCountValue *int                               `json:"estimated_count,omitempty" validate:"omitempty"`
	NextValue           *string                            `json:"next,omitempty" validate:"omitempty"`
	PrevValue           *string                            `json:"prev,omitempty" validate:"omitempty"`
	ChangesValue        []*CentralStreamLayoutListItemImpl `json:"changes,omitempty" validate:"omitempty"`
}

type CentralStreamLayoutsImpl struct {
	TimingValue         any                        `json:"timing,omitempty" validate:"omitempty"`
	EstimatedCountValue *int                       `json:"estimated_count,omitempty" validate:"omitempty"`
	NextValue           *string                    `json:"next,omitempty" validate:"omitempty"`
	PrevValue           *string                    `json:"prev,omitempty" validate:"omitempty"`
	LayoutsValue        []*CentralStreamLayoutImpl `json:"layouts,omitempty" validate:"omitempty"`
}

type CentralStreamerLayoutPredictionImpl struct {
	TimingValue         any                                        `json:"timing,omitempty" validate:"omitempty"`
	EstimatedCountValue *int                                       `json:"estimated_count,omitempty" validate:"omitempty"`
	NextValue           *string                                    `json:"next,omitempty" validate:"omitempty"`
	PrevValue           *string                                    `json:"prev,omitempty" validate:"omitempty"`
	ChangesValue        []*CentralStreamerLayoutPredictionItemImpl `json:"changes,omitempty" validate:"omitempty"`
}

type CentralStreamerLayoutPredictionItemImpl struct {
	AfterValue    *int                                     `json:"after,omitempty" validate:"omitempty"`
	BeforeValue   *int                                     `json:"before,omitempty" validate:"omitempty"`
	DeltaValue    *int                                     `json:"delta,omitempty" validate:"omitempty"`
	HostnameValue *ServerName                              `json:"hostname,omitempty" validate:"omitempty"`
	RoleValue     *CentralStreamerLayoutPredictionItemRole `json:"role,omitempty" validate:"omitempty,oneof=ingest inference dvr_backup"`
}

type CentralStreamerNodeImpl struct {
	IsRestreamerValue      *bool                          `json:"is_restreamer,omitempty" validate:"omitempty"`
	PublicPayloadURLValue  *URL                           `json:"public_payload_url,omitempty" validate:"omitempty"`
	ClusterKeyValue        *string                        `json:"cluster_key,omitempty" validate:"omitempty"`
	ConfigValue            *CentralStreamerNodeConfigImpl `json:"config,omitempty" validate:"omitempty"`
	CpuLimitValue          *Percent                       `json:"cpu_limit,omitempty" validate:"omitempty,min=0,max=100"`
	TotalBandwidthValue    *Speed                         `json:"total_bandwidth,omitempty" validate:"omitempty"`
	FetchTimeoutValue      *Milliseconds                  `json:"fetch_timeout,omitempty" validate:"omitempty"`
	HostnameValue          *ServerName                    `json:"hostname,omitempty" validate:"omitempty"`
	ChannelLimitValue      *int                           `json:"channel_limit,omitempty" validate:"omitempty"`
	MaxBitrateValue        *Speed                         `json:"max_bitrate,omitempty" validate:"omitempty"`
	LabelsValue            map[string]UnixName            `json:"labels,omitempty" validate:"omitempty"`
	NamespaceValue         *UnixName                      `json:"namespace,omitempty" validate:"omitempty"`
	PrivatePayloadURLValue *URL                           `json:"private_payload_url,omitempty" validate:"omitempty"`
	APIURLValue            *URL                           `json:"api_url,omitempty" validate:"omitempty"`
	RoleValue              *CentralNodeRoleRole           `json:"role,omitempty" validate:"omitempty,oneof=streamer inference identification"`
	StaleTimeoutValue      *Milliseconds                  `json:"stale_timeout,omitempty" validate:"omitempty"`
	StatsValue             *PeerStatsImpl                 `json:"stats,omitempty" validate:"omitempty"`
	DvrsValue              []*DvrConfigImpl               `json:"dvrs,omitempty" validate:"omitempty"`
}

// Flussonic Media Server configuration which will be provided to Streamer
type CentralStreamerNodeConfigImpl struct {
	ClusterKeyValue  *string                 `json:"cluster_key,omitempty" validate:"omitempty"`
	EventSinksValue  []*EventSinkConfigImpl  `json:"event_sinks,omitempty" validate:"omitempty"`
	HTTPProxiesValue []*HTTPProxyConfigImpl  `json:"http_proxies,omitempty" validate:"omitempty"`
	RproxyValue      *RproxyConfigImpl       `json:"rproxy,omitempty" validate:"omitempty"`
	ServerNamesValue []*ServerNameConfigImpl `json:"server_names,omitempty" validate:"omitempty"`
}

type CentralStreamsListImpl struct {
	TimingValue         any                        `json:"timing,omitempty" validate:"omitempty"`
	EstimatedCountValue *int                       `json:"estimated_count,omitempty" validate:"omitempty"`
	NextValue           *string                    `json:"next,omitempty" validate:"omitempty"`
	PrevValue           *string                    `json:"prev,omitempty" validate:"omitempty"`
	StreamsValue        []*CentralStreamConfigImpl `json:"streams,omitempty" validate:"omitempty"`
}

type ClosedCaptionsImpl struct {
	LanguageValue *string `json:"language,omitempty" validate:"omitempty"`
	NameValue     *string `json:"name,omitempty" validate:"omitempty"`
}

// Number of entities, grouped by status
type ClusterHealthMetricsTotalImpl struct {
	DegradatedValue    *int `json:"degradated,omitempty" validate:"omitempty" openmetrics_metric:"degradated_count"`
	DisabledValue      *int `json:"disabled,omitempty" validate:"omitempty" openmetrics_metric:"disabled_count"`
	OperationalValue   *int `json:"operational,omitempty" validate:"omitempty" openmetrics_metric:"operational_count"`
	OutageValue        *int `json:"outage,omitempty" validate:"omitempty" openmetrics_metric:"outage_count"`
	PartialOutageValue *int `json:"partial_outage,omitempty" validate:"omitempty" openmetrics_metric:"partial_outage_count"`
	TotalValue         *int `json:"total,omitempty" validate:"omitempty" openmetrics_metric:"total_count"`
}

type ClusterHealthStatsImpl struct {
	AgentMetricsTotalValue           *ClusterHealthMetricsTotalImpl                     `json:"agent_metrics_total,omitempty" validate:"omitempty" openmetrics_metric_segment:"agent"`
	CollectedAtValue                 *UtcMs                                             `json:"collected_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	ServerIDValue                    *UUID                                              `json:"server_id,omitempty" validate:"omitempty" openmetrics_label:"server_id"`
	StreamMetricsTotalValue          *ClusterHealthMetricsTotalImpl                     `json:"stream_metrics_total,omitempty" validate:"omitempty" openmetrics_metric_segment:"stream"`
	StreamerBitrateMetricsTotalValue *ClusterHealthStatsStreamerBitrateMetricsTotalImpl `json:"streamer_bitrate_metrics_total,omitempty" validate:"omitempty"`
	StreamerMetricsTotalValue        *ClusterHealthMetricsTotalImpl                     `json:"streamer_metrics_total,omitempty" validate:"omitempty" openmetrics_metric_segment:"streamer"`
	VersionValue                     *int                                               `json:"version,omitempty" validate:"omitempty" openmetrics_metric:"version"`
	StreamerMetricsValue             []*ClusterHealthStreamerStatsImpl                  `json:"streamer_metrics,omitempty" validate:"omitempty"`
}

// Cluster total bitrate metrics
type ClusterHealthStatsStreamerBitrateMetricsTotalImpl struct {
	InputKbitValue  *Speed `json:"input_kbit,omitempty" validate:"omitempty" openmetrics_metric:"streamer_inbound_kbit_total"`
	OutputKbitValue *Speed `json:"output_kbit,omitempty" validate:"omitempty" openmetrics_metric:"streamer_outbound_kbit_total"`
}

// Streamer stats
// Required: hostname
type ClusterHealthStreamerStatsImpl struct {
	AgentMetricsValue  *ClusterHealthStreamerStatsAgentMetricsImpl  `json:"agent_metrics,omitempty" validate:"omitempty"`
	ConfigValue        *ClusterHealthStreamerStatsConfigImpl        `json:"config,omitempty" validate:"omitempty"`
	CpuValue           *ClusterHealthStreamerStatsCpuImpl           `json:"cpu,omitempty" validate:"omitempty"`
	MemoryValue        *ClusterHealthStreamerStatsMemoryImpl        `json:"memory,omitempty" validate:"omitempty"`
	NetworkValue       *ClusterHealthStreamerStatsNetworkImpl       `json:"network,omitempty" validate:"omitempty"`
	StatusValue        *ClusterHealthStatus                         `json:"status,omitempty" validate:"omitempty"`
	StorageValue       *ClusterHealthStreamerStatsStorageImpl       `json:"storage,omitempty" validate:"omitempty"`
	StreamMetricsValue *ClusterHealthStreamerStatsStreamMetricsImpl `json:"stream_metrics,omitempty" validate:"omitempty"`
	UptimeValue        *Seconds                                     `json:"uptime,omitempty" validate:"omitempty"`
	HostnameValue      ServerName                                   `json:"hostname" validate:"required" openmetrics_label:"hostname"`
}

// Streamer agents info.
type ClusterHealthStreamerStatsAgentMetricsImpl struct {
	DegradatedValue    *int                 `json:"degradated,omitempty" validate:"omitempty" openmetrics_metric:"degradated_count"`
	DisabledValue      *int                 `json:"disabled,omitempty" validate:"omitempty" openmetrics_metric:"disabled_count"`
	OperationalValue   *int                 `json:"operational,omitempty" validate:"omitempty" openmetrics_metric:"operational_count"`
	OutageValue        *int                 `json:"outage,omitempty" validate:"omitempty" openmetrics_metric:"outage_count"`
	PartialOutageValue *int                 `json:"partial_outage,omitempty" validate:"omitempty" openmetrics_metric:"partial_outage_count"`
	StatusValue        *ClusterHealthStatus `json:"status,omitempty" validate:"omitempty"`
	TotalValue         *int                 `json:"total,omitempty" validate:"omitempty" openmetrics_metric:"total_count"`
}

// Streamer config info.
type ClusterHealthStreamerStatsConfigImpl struct {
	StatusValue *ClusterHealthStatus `json:"status,omitempty" validate:"omitempty"`
}

// CPU usage info.
type ClusterHealthStreamerStatsCpuImpl struct {
	StatusValue *ClusterHealthStatus `json:"status,omitempty" validate:"omitempty"`
	UsageValue  *Percent             `json:"usage,omitempty" validate:"omitempty,min=0,max=100" openmetrics_metric:"cpu_usage"`
}

// Memory usage info.
type ClusterHealthStreamerStatsMemoryImpl struct {
	StatusValue *ClusterHealthStatus `json:"status,omitempty" validate:"omitempty"`
	UsageValue  *Percent             `json:"usage,omitempty" validate:"omitempty,min=0,max=100" openmetrics_metric:"memory_usage"`
}

// Network IO info.
type ClusterHealthStreamerStatsNetworkImpl struct {
	InKbitValue  *ClusterHealthStreamerStatsNetworkInKbitImpl  `json:"in_kbit,omitempty" validate:"omitempty"`
	OutKbitValue *ClusterHealthStreamerStatsNetworkOutKbitImpl `json:"out_kbit,omitempty" validate:"omitempty"`
}

// Inbound network info on the server.
type ClusterHealthStreamerStatsNetworkInKbitImpl struct {
	StatusValue *ClusterHealthStatus `json:"status,omitempty" validate:"omitempty"`
	UsageValue  *Speed               `json:"usage,omitempty" validate:"omitempty" openmetrics_metric:"network_usage_in"`
}

// Outbound network info on the server.
type ClusterHealthStreamerStatsNetworkOutKbitImpl struct {
	StatusValue *ClusterHealthStatus `json:"status,omitempty" validate:"omitempty"`
	UsageValue  *Speed               `json:"usage,omitempty" validate:"omitempty" openmetrics_metric:"network_usage_out"`
}

// Total disk usage info.
type ClusterHealthStreamerStatsStorageImpl struct {
	StatusValue *ClusterHealthStatus `json:"status,omitempty" validate:"omitempty"`
	UsageValue  *Percent             `json:"usage,omitempty" validate:"omitempty,min=0,max=100" openmetrics_metric:"storage_usage"`
}

// Streamer streams info.
type ClusterHealthStreamerStatsStreamMetricsImpl struct {
	DegradatedValue    *int                 `json:"degradated,omitempty" validate:"omitempty" openmetrics_metric:"degradated_count"`
	DisabledValue      *int                 `json:"disabled,omitempty" validate:"omitempty" openmetrics_metric:"disabled_count"`
	OperationalValue   *int                 `json:"operational,omitempty" validate:"omitempty" openmetrics_metric:"operational_count"`
	OutageValue        *int                 `json:"outage,omitempty" validate:"omitempty" openmetrics_metric:"outage_count"`
	PartialOutageValue *int                 `json:"partial_outage,omitempty" validate:"omitempty" openmetrics_metric:"partial_outage_count"`
	StatusValue        *ClusterHealthStatus `json:"status,omitempty" validate:"omitempty"`
	TotalValue         *int                 `json:"total,omitempty" validate:"omitempty" openmetrics_metric:"total_count"`
}

type CollectionResponseImpl struct {
	EstimatedCountValue *int    `json:"estimated_count,omitempty" validate:"omitempty"`
	NextValue           *string `json:"next,omitempty" validate:"omitempty"`
	PrevValue           *string `json:"prev,omitempty" validate:"omitempty"`
	TimingValue         any     `json:"timing,omitempty" validate:"omitempty"`
}

type ConfigErrorStatusImpl struct {
	ColValue            *int                `json:"col,omitempty" validate:"omitempty"`
	ConfigValue         any                 `json:"config,omitempty" validate:"omitempty"`
	DetailValue         any                 `json:"detail,omitempty" validate:"omitempty"`
	ErrorValue          *string             `json:"error,omitempty" validate:"omitempty"`
	FirstErrorColValue  *int                `json:"first_error_col,omitempty" validate:"omitempty"`
	FirstErrorLineValue *int                `json:"first_error_line,omitempty" validate:"omitempty"`
	LineValue           *int                `json:"line,omitempty" validate:"omitempty"`
	PathValue           []ConfigPathSegment `json:"path,omitempty" validate:"omitempty"`
}

type ConfigExternalErrorStatusImpl struct {
	CodeValue   *int                             `json:"code,omitempty" validate:"omitempty"`
	DetailValue *string                          `json:"detail,omitempty" validate:"omitempty"`
	ErrorValue  *string                          `json:"error,omitempty" validate:"omitempty"`
	ReasonValue *RequestErrorReason              `json:"reason,omitempty" validate:"omitempty"`
	StatusValue *ConfigExternalErrorStatusStatus `json:"status,omitempty" validate:"omitempty,oneof=loaded error"`
	WhileValue  *ConfigExternalErrorStatusWhile  `json:"while,omitempty" validate:"omitempty,oneof=refresh request srt_port_resolve"`
	PathValue   []ConfigPathSegment              `json:"path,omitempty" validate:"omitempty"`
}

type DatabaseErrorImpl struct {
	EventIDValue *int    `json:"event_id,omitempty" validate:"omitempty"`
	MessageValue *string `json:"message,omitempty" validate:"omitempty"`
	QueryValue   *string `json:"query,omitempty" validate:"omitempty"`
	ServerValue  *string `json:"server,omitempty" validate:"omitempty"`
	TraceIDValue *UUID   `json:"trace_id,omitempty" validate:"omitempty"`
	UtcMsValue   *UtcMs  `json:"utc_ms,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	EventValue   string  `json:"event" validate:"required"`
}

type DrmBaseImpl struct {
	EncryptionValue *string        `json:"encryption,omitempty" validate:"omitempty"`
	ExpiresValue    *int           `json:"expires,omitempty" validate:"omitempty"`
	KeyserverValue  *string        `json:"keyserver,omitempty" validate:"omitempty"`
	ResourceIDValue *DrmResourceID `json:"resource_id,omitempty" validate:"omitempty"`
}

type DrmCpixBaseImpl struct {
	EncryptionValue *string        `json:"encryption,omitempty" validate:"omitempty"`
	ExpiresValue    *int           `json:"expires,omitempty" validate:"omitempty"`
	IvValue         *string        `json:"iv,omitempty" validate:"omitempty"`
	KeyserverValue  *string        `json:"keyserver,omitempty" validate:"omitempty"`
	ResourceIDValue *DrmResourceID `json:"resource_id,omitempty" validate:"omitempty"`
	SystemsValue    []DrmSystem    `json:"systems,omitempty" validate:"omitempty"`
}

type DrmEncKeyImpl struct {
	KeyValue *string `json:"key,omitempty" validate:"omitempty"`
}

type DrmEncKeyURLImpl struct {
	URLValue *string `json:"url,omitempty" validate:"omitempty"`
}

type DrmIvImpl struct {
	IvValue *string `json:"iv,omitempty" validate:"omitempty"`
}

type DrmKeyosBaseImpl struct {
	ContentIDValue         *string `json:"content_id,omitempty" validate:"omitempty"`
	EndUserCertValue       *string `json:"end_user_cert,omitempty" validate:"omitempty"`
	EndUserPrivateKeyValue *string `json:"end_user_private_key,omitempty" validate:"omitempty"`
	UserkeyValue           *string `json:"userkey,omitempty" validate:"omitempty"`
}

type DrmSpecImpl struct {
	KeyserverValue         *string        `json:"keyserver,omitempty" validate:"omitempty"`
	LaURLValue             *URL           `json:"la_url,omitempty" validate:"omitempty"`
	AuthServerValue        *string        `json:"auth_server,omitempty" validate:"omitempty"`
	ContentIDValue         *string        `json:"content_id,omitempty" validate:"omitempty"`
	CpixConfigIDValue      *string        `json:"cpix_config_id,omitempty" validate:"omitempty"`
	EncTokenValue          *string        `json:"enc_token,omitempty" validate:"omitempty"`
	EncryptionValue        *string        `json:"encryption,omitempty" validate:"omitempty"`
	EndUserCertValue       *string        `json:"end_user_cert,omitempty" validate:"omitempty"`
	EndUserPrivateKeyValue *string        `json:"end_user_private_key,omitempty" validate:"omitempty"`
	ExpiresValue           *int           `json:"expires,omitempty" validate:"omitempty"`
	FpValue                *string        `json:"fp,omitempty" validate:"omitempty"`
	HlsExtXKeyIvValue      *bool          `json:"hls_ext_x_key_iv,omitempty" validate:"omitempty"`
	IcHostValue            *string        `json:"ic_host,omitempty" validate:"omitempty"`
	IvValue                *string        `json:"iv,omitempty" validate:"omitempty"`
	KeyValue               *string        `json:"key,omitempty" validate:"omitempty"`
	KeyseedValue           *string        `json:"keyseed,omitempty" validate:"omitempty"`
	AesKeyValue            *string        `json:"aes_key,omitempty" validate:"omitempty"`
	AccountIDValue         *string        `json:"account_id,omitempty" validate:"omitempty"`
	ManagementKeyValue     *string        `json:"management_key,omitempty" validate:"omitempty"`
	MerchantIDValue        *string        `json:"merchant_id,omitempty" validate:"omitempty"`
	PasswordValue          *string        `json:"password,omitempty" validate:"omitempty"`
	ResourceIDValue        *DrmResourceID `json:"resource_id,omitempty" validate:"omitempty"`
	SecretValue            *string        `json:"secret,omitempty" validate:"omitempty"`
	SignerValue            *string        `json:"signer,omitempty" validate:"omitempty"`
	SiteValue              *string        `json:"site,omitempty" validate:"omitempty"`
	UsernameValue          *string        `json:"username,omitempty" validate:"omitempty"`
	TenantIDValue          *string        `json:"tenant_id,omitempty" validate:"omitempty"`
	URLValue               *string        `json:"url,omitempty" validate:"omitempty"`
	UserValue              *string        `json:"user,omitempty" validate:"omitempty"`
	UserKeyserverValue     *string        `json:"user_keyserver,omitempty" validate:"omitempty"`
	UserNameValue          *string        `json:"user_name,omitempty" validate:"omitempty"`
	UserPathValue          *string        `json:"user_path,omitempty" validate:"omitempty"`
	UserkeyValue           *string        `json:"userkey,omitempty" validate:"omitempty"`
	VendorValue            string         `json:"vendor" validate:"required"`
	SystemsValue           []DrmSystem    `json:"systems,omitempty" validate:"omitempty"`
}

type DrmSystemsImpl struct {
	SystemsValue []DrmSystem `json:"systems,omitempty" validate:"omitempty"`
}

type DrmVendorAes128Impl struct {
	EncryptionValue   *string        `json:"encryption,omitempty" validate:"omitempty"`
	ExpiresValue      *int           `json:"expires,omitempty" validate:"omitempty"`
	HlsExtXKeyIvValue *bool          `json:"hls_ext_x_key_iv,omitempty" validate:"omitempty"`
	KeyserverValue    *string        `json:"keyserver,omitempty" validate:"omitempty"`
	ResourceIDValue   *DrmResourceID `json:"resource_id,omitempty" validate:"omitempty"`
	VendorValue       string         `json:"vendor" validate:"required"`
}

type DrmVendorAxinomImpl struct {
	EncryptionValue    *string        `json:"encryption,omitempty" validate:"omitempty"`
	ExpiresValue       *int           `json:"expires,omitempty" validate:"omitempty"`
	IvValue            *string        `json:"iv,omitempty" validate:"omitempty"`
	KeyserverValue     *string        `json:"keyserver,omitempty" validate:"omitempty"`
	ManagementKeyValue *string        `json:"management_key,omitempty" validate:"omitempty"`
	ResourceIDValue    *DrmResourceID `json:"resource_id,omitempty" validate:"omitempty"`
	TenantIDValue      *string        `json:"tenant_id,omitempty" validate:"omitempty"`
	VendorValue        string         `json:"vendor" validate:"required"`
	SystemsValue       []DrmSystem    `json:"systems,omitempty" validate:"omitempty"`
}

type DrmVendorBuydrmImpl struct {
	ContentIDValue         *string        `json:"content_id,omitempty" validate:"omitempty"`
	EncryptionValue        *string        `json:"encryption,omitempty" validate:"omitempty"`
	EndUserCertValue       *string        `json:"end_user_cert,omitempty" validate:"omitempty"`
	EndUserPrivateKeyValue *string        `json:"end_user_private_key,omitempty" validate:"omitempty"`
	ExpiresValue           *int           `json:"expires,omitempty" validate:"omitempty"`
	KeyserverValue         *string        `json:"keyserver,omitempty" validate:"omitempty"`
	ResourceIDValue        *DrmResourceID `json:"resource_id,omitempty" validate:"omitempty"`
	UserkeyValue           *string        `json:"userkey,omitempty" validate:"omitempty"`
	VendorValue            string         `json:"vendor" validate:"required"`
}

type DrmVendorClearkeyImpl struct {
	EncryptionValue *string        `json:"encryption,omitempty" validate:"omitempty"`
	ExpiresValue    *int           `json:"expires,omitempty" validate:"omitempty"`
	KeyValue        *string        `json:"key,omitempty" validate:"omitempty"`
	KeyserverValue  *string        `json:"keyserver,omitempty" validate:"omitempty"`
	ResourceIDValue *DrmResourceID `json:"resource_id,omitempty" validate:"omitempty"`
	VendorValue     string         `json:"vendor" validate:"required"`
}

type DrmVendorConaxImpl struct {
	EncryptionValue *string        `json:"encryption,omitempty" validate:"omitempty"`
	ExpiresValue    *int           `json:"expires,omitempty" validate:"omitempty"`
	KeyserverValue  *string        `json:"keyserver,omitempty" validate:"omitempty"`
	ResourceIDValue *DrmResourceID `json:"resource_id,omitempty" validate:"omitempty"`
	UserPathValue   *string        `json:"user_path,omitempty" validate:"omitempty"`
	VendorValue     string         `json:"vendor" validate:"required"`
	SystemsValue    []DrmSystem    `json:"systems,omitempty" validate:"omitempty"`
}

type DrmVendorCpixImpl struct {
	EncryptionValue *string        `json:"encryption,omitempty" validate:"omitempty"`
	ExpiresValue    *int           `json:"expires,omitempty" validate:"omitempty"`
	IvValue         *string        `json:"iv,omitempty" validate:"omitempty"`
	KeyserverValue  *string        `json:"keyserver,omitempty" validate:"omitempty"`
	ResourceIDValue *DrmResourceID `json:"resource_id,omitempty" validate:"omitempty"`
	VendorValue     string         `json:"vendor" validate:"required"`
	SystemsValue    []DrmSystem    `json:"systems,omitempty" validate:"omitempty"`
}

type DrmVendorDrmtodayImpl struct {
	AuthServerValue   *string        `json:"auth_server,omitempty" validate:"omitempty"`
	CpixConfigIDValue *string        `json:"cpix_config_id,omitempty" validate:"omitempty"`
	EncryptionValue   *string        `json:"encryption,omitempty" validate:"omitempty"`
	ExpiresValue      *int           `json:"expires,omitempty" validate:"omitempty"`
	IvValue           *string        `json:"iv,omitempty" validate:"omitempty"`
	KeyserverValue    *string        `json:"keyserver,omitempty" validate:"omitempty"`
	MerchantIDValue   *string        `json:"merchant_id,omitempty" validate:"omitempty"`
	PasswordValue     *string        `json:"password,omitempty" validate:"omitempty"`
	ResourceIDValue   *DrmResourceID `json:"resource_id,omitempty" validate:"omitempty"`
	UsernameValue     *string        `json:"username,omitempty" validate:"omitempty"`
	VendorValue       string         `json:"vendor" validate:"required"`
	SystemsValue      []DrmSystem    `json:"systems,omitempty" validate:"omitempty"`
}

type DrmVendorEzdrmImpl struct {
	EncryptionValue *string        `json:"encryption,omitempty" validate:"omitempty"`
	ExpiresValue    *int           `json:"expires,omitempty" validate:"omitempty"`
	KeyserverValue  *string        `json:"keyserver,omitempty" validate:"omitempty"`
	PasswordValue   *string        `json:"password,omitempty" validate:"omitempty"`
	ResourceIDValue *DrmResourceID `json:"resource_id,omitempty" validate:"omitempty"`
	UserValue       *string        `json:"user,omitempty" validate:"omitempty"`
	VendorValue     string         `json:"vendor" validate:"required"`
}

type DrmVendorEzdrmClassicImpl struct {
	EncryptionValue *string        `json:"encryption,omitempty" validate:"omitempty"`
	ExpiresValue    *int           `json:"expires,omitempty" validate:"omitempty"`
	KeyserverValue  *string        `json:"keyserver,omitempty" validate:"omitempty"`
	PasswordValue   *string        `json:"password,omitempty" validate:"omitempty"`
	ResourceIDValue *DrmResourceID `json:"resource_id,omitempty" validate:"omitempty"`
	UserValue       *string        `json:"user,omitempty" validate:"omitempty"`
	VendorValue     string         `json:"vendor" validate:"required"`
}

type DrmVendorGsdrmImpl struct {
	EncryptionValue *string        `json:"encryption,omitempty" validate:"omitempty"`
	ExpiresValue    *int           `json:"expires,omitempty" validate:"omitempty"`
	KeyserverValue  *string        `json:"keyserver,omitempty" validate:"omitempty"`
	ResourceIDValue *DrmResourceID `json:"resource_id,omitempty" validate:"omitempty"`
	VendorValue     string         `json:"vendor" validate:"required"`
}

type DrmVendorIrdetoImpl struct {
	AccountIDValue  *string        `json:"account_id,omitempty" validate:"omitempty"`
	EncryptionValue *string        `json:"encryption,omitempty" validate:"omitempty"`
	ExpiresValue    *int           `json:"expires,omitempty" validate:"omitempty"`
	IcHostValue     *string        `json:"ic_host,omitempty" validate:"omitempty"`
	IvValue         *string        `json:"iv,omitempty" validate:"omitempty"`
	KeyserverValue  *string        `json:"keyserver,omitempty" validate:"omitempty"`
	PasswordValue   *string        `json:"password,omitempty" validate:"omitempty"`
	ResourceIDValue *DrmResourceID `json:"resource_id,omitempty" validate:"omitempty"`
	UserNameValue   *string        `json:"user_name,omitempty" validate:"omitempty"`
	VendorValue     string         `json:"vendor" validate:"required"`
	SystemsValue    []DrmSystem    `json:"systems,omitempty" validate:"omitempty"`
}

type DrmVendorKeyosImpl struct {
	ContentIDValue         *string        `json:"content_id,omitempty" validate:"omitempty"`
	EncryptionValue        *string        `json:"encryption,omitempty" validate:"omitempty"`
	EndUserCertValue       *string        `json:"end_user_cert,omitempty" validate:"omitempty"`
	EndUserPrivateKeyValue *string        `json:"end_user_private_key,omitempty" validate:"omitempty"`
	ExpiresValue           *int           `json:"expires,omitempty" validate:"omitempty"`
	KeyserverValue         *string        `json:"keyserver,omitempty" validate:"omitempty"`
	ResourceIDValue        *DrmResourceID `json:"resource_id,omitempty" validate:"omitempty"`
	UserkeyValue           *string        `json:"userkey,omitempty" validate:"omitempty"`
	VendorValue            string         `json:"vendor" validate:"required"`
}

type DrmVendorPallyconImpl struct {
	EncTokenValue   *string        `json:"enc_token,omitempty" validate:"omitempty"`
	EncryptionValue *string        `json:"encryption,omitempty" validate:"omitempty"`
	ExpiresValue    *int           `json:"expires,omitempty" validate:"omitempty"`
	IvValue         *string        `json:"iv,omitempty" validate:"omitempty"`
	KeyserverValue  *string        `json:"keyserver,omitempty" validate:"omitempty"`
	ResourceIDValue *DrmResourceID `json:"resource_id,omitempty" validate:"omitempty"`
	VendorValue     string         `json:"vendor" validate:"required"`
	SystemsValue    []DrmSystem    `json:"systems,omitempty" validate:"omitempty"`
}

type DrmVendorPlayreadyImpl struct {
	EncryptionValue *string        `json:"encryption,omitempty" validate:"omitempty"`
	ExpiresValue    *int           `json:"expires,omitempty" validate:"omitempty"`
	KeyseedValue    *string        `json:"keyseed,omitempty" validate:"omitempty"`
	KeyserverValue  *string        `json:"keyserver,omitempty" validate:"omitempty"`
	LaURLValue      *URL           `json:"la_url,omitempty" validate:"omitempty"`
	ResourceIDValue *DrmResourceID `json:"resource_id,omitempty" validate:"omitempty"`
	VendorValue     string         `json:"vendor" validate:"required"`
}

type DrmVendorSampleAesImpl struct {
	EncryptionValue *string        `json:"encryption,omitempty" validate:"omitempty"`
	ExpiresValue    *int           `json:"expires,omitempty" validate:"omitempty"`
	KeyserverValue  *string        `json:"keyserver,omitempty" validate:"omitempty"`
	ResourceIDValue *DrmResourceID `json:"resource_id,omitempty" validate:"omitempty"`
	VendorValue     string         `json:"vendor" validate:"required"`
}

type DrmVendorSampleAesIdentityImpl struct {
	IvValue     *string `json:"iv,omitempty" validate:"omitempty"`
	KeyValue    *string `json:"key,omitempty" validate:"omitempty"`
	URLValue    *string `json:"url,omitempty" validate:"omitempty"`
	VendorValue string  `json:"vendor" validate:"required"`
}

type DrmVendorSolocooImpl struct {
	EncryptionValue *string        `json:"encryption,omitempty" validate:"omitempty"`
	ExpiresValue    *int           `json:"expires,omitempty" validate:"omitempty"`
	FpValue         *string        `json:"fp,omitempty" validate:"omitempty"`
	KeyserverValue  *string        `json:"keyserver,omitempty" validate:"omitempty"`
	ResourceIDValue *DrmResourceID `json:"resource_id,omitempty" validate:"omitempty"`
	SecretValue     *string        `json:"secret,omitempty" validate:"omitempty"`
	SiteValue       *string        `json:"site,omitempty" validate:"omitempty"`
	VendorValue     string         `json:"vendor" validate:"required"`
}

type DrmVendorVerimatrixImpl struct {
	EncryptionValue    *string        `json:"encryption,omitempty" validate:"omitempty"`
	ExpiresValue       *int           `json:"expires,omitempty" validate:"omitempty"`
	KeyserverValue     *string        `json:"keyserver,omitempty" validate:"omitempty"`
	ResourceIDValue    *DrmResourceID `json:"resource_id,omitempty" validate:"omitempty"`
	UserKeyserverValue *string        `json:"user_keyserver,omitempty" validate:"omitempty"`
	VendorValue        string         `json:"vendor" validate:"required"`
}

type DrmVendorWidevineImpl struct {
	AesKeyValue     *string        `json:"aes_key,omitempty" validate:"omitempty"`
	EncryptionValue *string        `json:"encryption,omitempty" validate:"omitempty"`
	ExpiresValue    *int           `json:"expires,omitempty" validate:"omitempty"`
	IvValue         *string        `json:"iv,omitempty" validate:"omitempty"`
	KeyserverValue  *string        `json:"keyserver,omitempty" validate:"omitempty"`
	ResourceIDValue *DrmResourceID `json:"resource_id,omitempty" validate:"omitempty"`
	SignerValue     *string        `json:"signer,omitempty" validate:"omitempty"`
	VendorValue     string         `json:"vendor" validate:"required"`
}

type DvrBaseConfigImpl struct {
	DiskUsageLimitValue     *Percent `json:"disk_usage_limit,omitempty" validate:"omitempty,min=0,max=100"`
	EpisodesExpirationValue *Seconds `json:"episodes_expiration,omitempty" validate:"omitempty"`
	EpisodesURLValue        *string  `json:"episodes_url,omitempty" validate:"omitempty"`
	ExpirationValue         *Seconds `json:"expiration,omitempty" validate:"omitempty"`
	StorageLimitValue       *Bytes   `json:"storage_limit,omitempty" validate:"omitempty"`
	ScheduleValue           [][]int  `json:"schedule,omitempty" validate:"omitempty"`
}

// This list of stats can be used to monitor health of invidiual disk in storage.
// There are several layers of indexes in internal database, here you can validate
// integrity of data.
type DvrCapacityStatsImpl struct {
	BlobsCountValue   *int     `json:"blobs_count,omitempty" validate:"omitempty" openmetrics_metric:"storage_blobs_count"`
	BlobsCountDbValue *int     `json:"blobs_count_db,omitempty" validate:"omitempty" openmetrics_metric:"storage_blobs_count_db"`
	SizeValue         *Bytes   `json:"size,omitempty" validate:"omitempty" openmetrics_metric:"storage_size"`
	UsageValue        *Percent `json:"usage,omitempty" validate:"omitempty,min=0,max=100" openmetrics_metric:"storage_usage"`
	UsedValue         *Bytes   `json:"used,omitempty" validate:"omitempty" openmetrics_metric:"storage_used"`
	UsedIndexValue    *Bytes   `json:"used_index,omitempty" validate:"omitempty" openmetrics_metric:"storage_used_index"`
}

type DvrConfigImpl struct {
	RaidValue               *DvrRaidLevel              `json:"raid,omitempty" validate:"omitempty"`
	StatsValue              *DvrStorageConfigStatsImpl `json:"stats,omitempty" validate:"omitempty"`
	DiskUsageLimitValue     *Percent                   `json:"disk_usage_limit,omitempty" validate:"omitempty,min=0,max=100"`
	StorageLimitValue       *Bytes                     `json:"storage_limit,omitempty" validate:"omitempty"`
	EpisodesExpirationValue *Seconds                   `json:"episodes_expiration,omitempty" validate:"omitempty"`
	EpisodesURLValue        *string                    `json:"episodes_url,omitempty" validate:"omitempty"`
	IndexValue              *DiskPath                  `json:"index,omitempty" validate:"omitempty"`
	ExpirationValue         *Seconds                   `json:"expiration,omitempty" validate:"omitempty"`
	CheckMountValue         *bool                      `json:"check_mount,omitempty" validate:"omitempty"`
	ActiveValue             *int                       `json:"active,omitempty" validate:"omitempty"`
	RootValue               DvrURL                     `json:"root" validate:"required"`
	NameValue               DvrName                    `json:"name" validate:"required" openmetrics_label:"dvr_name"`
	ScheduleValue           [][]int                    `json:"schedule,omitempty" validate:"omitempty"`
	DisksValue              []*RaidDiskConfigImpl      `json:"disks,omitempty" validate:"omitempty"`
}

// Required: from, depth, ranges
type DvrInfoImpl struct {
	BytesValue    *Bytes          `json:"bytes,omitempty" validate:"omitempty"`
	DiskSizeValue *Bytes          `json:"disk_size,omitempty" validate:"omitempty"`
	DurationValue *Seconds        `json:"duration,omitempty" validate:"omitempty"`
	RangesValue   []*DvrRangeImpl `json:"ranges" validate:"required"`
	DepthValue    Seconds         `json:"depth" validate:"required"`
	FromValue     Utc             `json:"from" validate:"required,min=1e+09,max=1e+10"`
}

type DvrRangeImpl struct {
	ClosedAtValue *UtcMs   `json:"closed_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	DurationValue *Seconds `json:"duration,omitempty" validate:"omitempty"`
	FromValue     *Utc     `json:"from,omitempty" validate:"omitempty,min=1e+09,max=1e+10"`
	OpenedAtValue *UtcMs   `json:"opened_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
}

// Required: name, root
type DvrStorageConfigImpl struct {
	ActiveValue     *int                       `json:"active,omitempty" validate:"omitempty"`
	CheckMountValue *bool                      `json:"check_mount,omitempty" validate:"omitempty"`
	IndexValue      *DiskPath                  `json:"index,omitempty" validate:"omitempty"`
	RaidValue       *DvrRaidLevel              `json:"raid,omitempty" validate:"omitempty"`
	StatsValue      *DvrStorageConfigStatsImpl `json:"stats,omitempty" validate:"omitempty"`
	NameValue       DvrName                    `json:"name" validate:"required" openmetrics_label:"dvr_name"`
	RootValue       DvrURL                     `json:"root" validate:"required"`
	DisksValue      []*RaidDiskConfigImpl      `json:"disks,omitempty" validate:"omitempty"`
}

// The runtime statistics about DVR.
type DvrStorageConfigStatsImpl struct {
	BlobsCountValue   *int                  `json:"blobs_count,omitempty" validate:"omitempty" openmetrics_metric:"storage_blobs_count"`
	BlobsCountDbValue *int                  `json:"blobs_count_db,omitempty" validate:"omitempty" openmetrics_metric:"storage_blobs_count_db"`
	ErrorsValue       *DvrStorageErrorsImpl `json:"errors,omitempty" validate:"omitempty"`
	SizeValue         *Bytes                `json:"size,omitempty" validate:"omitempty" openmetrics_metric:"storage_size"`
	UsageValue        *Percent              `json:"usage,omitempty" validate:"omitempty,min=0,max=100" openmetrics_metric:"storage_usage"`
	UsedValue         *Bytes                `json:"used,omitempty" validate:"omitempty" openmetrics_metric:"storage_used"`
	UsedIndexValue    *Bytes                `json:"used_index,omitempty" validate:"omitempty" openmetrics_metric:"storage_used_index"`
}

type DvrStorageErrorsImpl struct {
	CollapsedWriteCountValue *int `json:"collapsed_write_count,omitempty" validate:"omitempty"`
	DeleteErrorsValue        *int `json:"delete_errors,omitempty" validate:"omitempty"`
	DropWriteCountValue      *int `json:"drop_write_count,omitempty" validate:"omitempty"`
	ReadErrorsValue          *int `json:"read_errors,omitempty" validate:"omitempty"`
	WriteErrorsValue         *int `json:"write_errors,omitempty" validate:"omitempty"`
}

type DvrStorageStatsImpl struct {
	ErrorsValue *DvrStorageErrorsImpl `json:"errors,omitempty" validate:"omitempty"`
}

type EntityEventImpl struct {
	EntityIDValue   *string                `json:"entity_id,omitempty" validate:"omitempty"`
	EntityTypeValue *EntityEventEntityType `json:"entity_type,omitempty" validate:"omitempty,oneof=agent stream streamer"`
	EventIDValue    *int                   `json:"event_id,omitempty" validate:"omitempty"`
	ServerValue     *string                `json:"server,omitempty" validate:"omitempty"`
	TraceIDValue    *UUID                  `json:"trace_id,omitempty" validate:"omitempty"`
	UtcMsValue      *UtcMs                 `json:"utc_ms,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
}

type EpisodeImpl struct {
	DetectionsValue                  any                              `json:"detections,omitempty" validate:"omitempty"`
	PayloadValue                     any                              `json:"payload,omitempty" validate:"omitempty"`
	RecordingStatusValue             *string                          `json:"recording_status,omitempty" validate:"omitempty"`
	CloseReasonValue                 *EpisodeCloseReason              `json:"close_reason,omitempty" validate:"omitempty"`
	VehiclePurposeValue              *VisionVehiclePurpose            `json:"vehicle_purpose,omitempty" validate:"omitempty"`
	EpisodeTypeValue                 *string                          `json:"episode_type,omitempty" validate:"omitempty"`
	FingerprintValue                 *VisionFaceFingerprintImpl       `json:"fingerprint,omitempty" validate:"omitempty"`
	FramePreviewValue                *Base64                          `json:"frame_preview,omitempty" validate:"omitempty,base64"`
	LicensePlateMissingValue         *bool                            `json:"license_plate_missing,omitempty" validate:"omitempty"`
	LicensePlateTextValue            *string                          `json:"license_plate_text,omitempty" validate:"omitempty"`
	MatchScoreValue                  *float64                         `json:"match_score,omitempty" validate:"omitempty"`
	OriginatorValue                  *EpisodeOriginatorImpl           `json:"originator,omitempty" validate:"omitempty"`
	EpisodeAppearanceTimestampsValue *EpisodeAppearanceTimestampsImpl `json:"episode_appearance_timestamps,omitempty" validate:"omitempty"`
	VehicleFacingSideValue           *VisionVehicleFacingSide         `json:"vehicle_facing_side,omitempty" validate:"omitempty"`
	VehicleEmergencySubtypeValue     *VisionVehicleEmergencySubtype   `json:"vehicle_emergency_subtype,omitempty" validate:"omitempty"`
	ClosedAtValue                    *UtcMs                           `json:"closed_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	PreviewValue                     *Base64                          `json:"preview,omitempty" validate:"omitempty,base64"`
	PreviewTimestampValue            *UtcMs                           `json:"preview_timestamp,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	StartedAtValue                   *UtcMs                           `json:"started_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	MediaValue                       MediaName                        `json:"media" validate:"required"`
	MatchedPersonsValue              []*VisionPersonMatchImpl         `json:"matched_persons,omitempty" validate:"omitempty"`
	UpdatedAtValue                   UtcMs                            `json:"updated_at" validate:"required,min=1e+12,max=1e+13"`
	OpenedAtValue                    UtcMs                            `json:"opened_at" validate:"required,min=1e+12,max=1e+13"`
	EpisodeIDValue                   SnowflakeID                      `json:"episode_id" validate:"required"`
}

type EpisodeAppearanceTimestampsImpl struct {
	CentralTimestampValue   *UtcMs `json:"central_timestamp,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	InferenceTimestampValue *UtcMs `json:"inference_timestamp,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
}

// # Definition
// Episode is a record about continious part of one video stream.
// It is used in video analytics, television systems, etc. for describing one continious and logically
// consolidated part of video stream.
// For example, episode can describe one TV show or a part of video when the car with specific license plate
// passed the camera view.
// Different systems in our ecosystem can emit and consume episodes of different `episode_type`.
// # Alternatives
// What episodes are not:
// * they cannot combine multiple streams. If you have multicamera view on the scene, you will have to create many episodes and join then in another system
// * they cannot be multipart. Only one continious uninterrupted episode. However, it is ok for them to overlap.
// # Updates
// Episodes are supposed to be streamable and updatable.
// If you consume episodes, you must be ready to see old `episode_id`
// with new updated data. You MUST overwrite previous data.
// If you emit episodes and you change any fields, you MUST accumulate previous data of episode and send full copy of
// updated episode.
// # Borders
// Episode have two mandatory fields: `opened_at` and `updated_at`, they are default borders of the episode:
// beginning and the end.
// Sometimes you need to look at another fields: `started_at` and `closed_at`.
// `started_at` appears when episode emitter decides that beginning of the episode should be different from `opened_at`,
// for example if video analytics has analysed previous frames and decided that this object appeared earlier.
// `closed_at` can appear if episode source have decided that episode will not continue anymore, for example
// car have run out of camera view. However, `updated_at` can be still changed, if any other system will add
// more data there, for example detected licence plates of some other auxiliary information.
// Required: episode_id, media, opened_at, updated_at
type EpisodeBaseImpl struct {
	RecordingStatusValue             *string                          `json:"recording_status,omitempty" validate:"omitempty"`
	ClosedAtValue                    *UtcMs                           `json:"closed_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	EpisodeAppearanceTimestampsValue *EpisodeAppearanceTimestampsImpl `json:"episode_appearance_timestamps,omitempty" validate:"omitempty"`
	CloseReasonValue                 *EpisodeCloseReason              `json:"close_reason,omitempty" validate:"omitempty"`
	FramePreviewValue                *Base64                          `json:"frame_preview,omitempty" validate:"omitempty,base64"`
	StartedAtValue                   *UtcMs                           `json:"started_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	OriginatorValue                  *EpisodeOriginatorImpl           `json:"originator,omitempty" validate:"omitempty"`
	PreviewValue                     *Base64                          `json:"preview,omitempty" validate:"omitempty,base64"`
	PreviewTimestampValue            *UtcMs                           `json:"preview_timestamp,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	MediaValue                       MediaName                        `json:"media" validate:"required"`
	EpisodeIDValue                   SnowflakeID                      `json:"episode_id" validate:"required"`
	OpenedAtValue                    UtcMs                            `json:"opened_at" validate:"required,min=1e+12,max=1e+13"`
	UpdatedAtValue                   UtcMs                            `json:"updated_at" validate:"required,min=1e+12,max=1e+13"`
}

type EpisodeCustomImpl struct {
	PayloadValue                     any                              `json:"payload,omitempty" validate:"omitempty"`
	PreviewTimestampValue            *UtcMs                           `json:"preview_timestamp,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	ClosedAtValue                    *UtcMs                           `json:"closed_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	EpisodeAppearanceTimestampsValue *EpisodeAppearanceTimestampsImpl `json:"episode_appearance_timestamps,omitempty" validate:"omitempty"`
	StartedAtValue                   *UtcMs                           `json:"started_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	EpisodeTypeValue                 *string                          `json:"episode_type,omitempty" validate:"omitempty,min=1,max=20"`
	FramePreviewValue                *Base64                          `json:"frame_preview,omitempty" validate:"omitempty,base64"`
	CloseReasonValue                 *EpisodeCloseReason              `json:"close_reason,omitempty" validate:"omitempty"`
	RecordingStatusValue             *string                          `json:"recording_status,omitempty" validate:"omitempty"`
	OriginatorValue                  *EpisodeOriginatorImpl           `json:"originator,omitempty" validate:"omitempty"`
	PreviewValue                     *Base64                          `json:"preview,omitempty" validate:"omitempty,base64"`
	MediaValue                       MediaName                        `json:"media" validate:"required"`
	OpenedAtValue                    UtcMs                            `json:"opened_at" validate:"required,min=1e+12,max=1e+13"`
	EpisodeIDValue                   SnowflakeID                      `json:"episode_id" validate:"required"`
	UpdatedAtValue                   UtcMs                            `json:"updated_at" validate:"required,min=1e+12,max=1e+13"`
}

type EpisodeGenericImpl struct {
	PreviewTimestampValue            *UtcMs                           `json:"preview_timestamp,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	ClosedAtValue                    *UtcMs                           `json:"closed_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	EpisodeAppearanceTimestampsValue *EpisodeAppearanceTimestampsImpl `json:"episode_appearance_timestamps,omitempty" validate:"omitempty"`
	StartedAtValue                   *UtcMs                           `json:"started_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	EpisodeTypeValue                 *string                          `json:"episode_type,omitempty" validate:"omitempty"`
	FramePreviewValue                *Base64                          `json:"frame_preview,omitempty" validate:"omitempty,base64"`
	CloseReasonValue                 *EpisodeCloseReason              `json:"close_reason,omitempty" validate:"omitempty"`
	RecordingStatusValue             *string                          `json:"recording_status,omitempty" validate:"omitempty"`
	OriginatorValue                  *EpisodeOriginatorImpl           `json:"originator,omitempty" validate:"omitempty"`
	PreviewValue                     *Base64                          `json:"preview,omitempty" validate:"omitempty,base64"`
	MediaValue                       MediaName                        `json:"media" validate:"required"`
	OpenedAtValue                    UtcMs                            `json:"opened_at" validate:"required,min=1e+12,max=1e+13"`
	EpisodeIDValue                   SnowflakeID                      `json:"episode_id" validate:"required"`
	UpdatedAtValue                   UtcMs                            `json:"updated_at" validate:"required,min=1e+12,max=1e+13"`
}

// Required: source
type EpisodeOriginatorImpl struct {
	HostnameValue *string                 `json:"hostname,omitempty" validate:"omitempty"`
	SourceValue   EpisodeOriginatorSource `json:"source" validate:"required,oneof=api inference motion_detector"`
}

type EpisodesListImpl struct {
	TimingValue         any            `json:"timing,omitempty" validate:"omitempty"`
	EstimatedCountValue *int           `json:"estimated_count,omitempty" validate:"omitempty"`
	NextValue           *string        `json:"next,omitempty" validate:"omitempty"`
	PrevValue           *string        `json:"prev,omitempty" validate:"omitempty"`
	EpisodesValue       []*EpisodeImpl `json:"episodes,omitempty" validate:"omitempty"`
}

type ErrorImpl struct {
	CodeValue   *string           `json:"code,omitempty" validate:"omitempty"`
	IDValue     *string           `json:"id,omitempty" validate:"omitempty"`
	MetaValue   map[string]string `json:"meta,omitempty" validate:"omitempty"`
	SourceValue *ErrorSourceImpl  `json:"source,omitempty" validate:"omitempty"`
	StatusValue *string           `json:"status,omitempty" validate:"omitempty"`
	TitleValue  *string           `json:"title,omitempty" validate:"omitempty"`
}

type ErrorResponseImpl struct {
	ErrorsValue []*ErrorImpl `json:"errors,omitempty" validate:"omitempty"`
}

// an object containing references to the source of the error
type ErrorSourceImpl struct {
	ParameterValue *string `json:"parameter,omitempty" validate:"omitempty"`
	PointerValue   *string `json:"pointer,omitempty" validate:"omitempty"`
}

type EventDefaultImpl struct {
	EventIDValue *int    `json:"event_id,omitempty" validate:"omitempty"`
	ServerValue  *string `json:"server,omitempty" validate:"omitempty"`
	TraceIDValue *UUID   `json:"trace_id,omitempty" validate:"omitempty"`
	UtcMsValue   *UtcMs  `json:"utc_ms,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
}

// Required: name, url
type EventSinkConfigImpl struct {
	ExtraValue         map[string]string     `json:"extra,omitempty" validate:"omitempty"`
	LevelValue         *Loglevel             `json:"level,omitempty" validate:"omitempty"`
	MaxDepthValue      *int                  `json:"max_depth,omitempty" validate:"omitempty"`
	MaxSizeValue       *Bytes                `json:"max_size,omitempty" validate:"omitempty"`
	ResendLimitValue   *int                  `json:"resend_limit,omitempty" validate:"omitempty"`
	ResendTimeoutValue *int                  `json:"resend_timeout,omitempty" validate:"omitempty"`
	ThrottleDelayValue *Seconds              `json:"throttle_delay,omitempty" validate:"omitempty"`
	NameValue          EventSinkName         `json:"name" validate:"required"`
	URLValue           string                `json:"url" validate:"required"`
	ExceptValue        []map[string][]string `json:"except,omitempty" validate:"omitempty"`
	OnlyValue          []map[string][]string `json:"only,omitempty" validate:"omitempty"`
}

// Required: opened_at, updated_at
type ExternalEpisodeImpl struct {
	ClosedAtValue  *UtcMs `json:"closed_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	OpenedAtValue  UtcMs  `json:"opened_at" validate:"required,min=1e+12,max=1e+13"`
	UpdatedAtValue UtcMs  `json:"updated_at" validate:"required,min=1e+12,max=1e+13"`
}

type ExternalEpisodesListImpl struct {
	TimingValue         any                    `json:"timing,omitempty" validate:"omitempty"`
	EstimatedCountValue *int                   `json:"estimated_count,omitempty" validate:"omitempty"`
	NextValue           *string                `json:"next,omitempty" validate:"omitempty"`
	PrevValue           *string                `json:"prev,omitempty" validate:"omitempty"`
	EpisodesValue       []*ExternalEpisodeImpl `json:"episodes,omitempty" validate:"omitempty"`
}

type ForwardPortsConfigImpl struct {
	HandlerValue *string `json:"handler,omitempty" validate:"omitempty"`
	OptionsValue any     `json:"options,omitempty" validate:"omitempty"`
}

type GenrefStatusImpl struct {
	ExternalValue     *bool   `json:"external,omitempty" validate:"omitempty"`
	PortValue         *int    `json:"port,omitempty" validate:"omitempty"`
	VstdValue         *string `json:"vstd,omitempty" validate:"omitempty,oneof=pal 625i50 ntsc 525i29.97 525i29 720p23.98 720p23 720p24 720p25 720p29.97 720p29 720p30 720p50 720p59.94 720p59 720p60 1080p23.98 1080p23 1080p24 1080p25 1080p29.97 1080p29 1080p30 1080psf23.98 1080psf23 1080psf24 1080psf25 1080psf29.97 1080psf29 1080psf30 1080i50 1080i59.94 1080i60 1080p50 1080p50b 1080p59.94 1080p59 1080p59.94b 1080p59b 1080p60 1080p60b 2160p50 2160p50b 2160p59.94 2160p59 2160p59.94b 2160p59b 2160p60 2160p60b 2160p23 2160p24 2160p25 2160p29 2160p30"`
	VstdDetectedValue *string `json:"vstd_detected,omitempty" validate:"omitempty,oneof=pal 625i50 ntsc 525i29.97 525i29 720p23.98 720p23 720p24 720p25 720p29.97 720p29 720p30 720p50 720p59.94 720p59 720p60 1080p23.98 1080p23 1080p24 1080p25 1080p29.97 1080p29 1080p30 1080psf23.98 1080psf23 1080psf24 1080psf25 1080psf29.97 1080psf29 1080psf30 1080i50 1080i59.94 1080i60 1080p50 1080p50b 1080p59.94 1080p59 1080p59.94b 1080p59b 1080p60 1080p60b 2160p50 2160p50b 2160p59.94 2160p59 2160p59.94b 2160p59b 2160p60 2160p60b 2160p23 2160p24 2160p25 2160p29 2160p30"`
}

// Here are counters for h264/h265 decoder.
type H26xDecoderCountersImpl struct {
	DiscardedBrokenNalCountValue        *int `json:"discarded_broken_nal_count,omitempty" validate:"omitempty"`
	DiscardedFuCountValue               *int `json:"discarded_fu_count,omitempty" validate:"omitempty"`
	DiscardedNalCountValue              *int `json:"discarded_nal_count,omitempty" validate:"omitempty"`
	DiscardedNotAllowedNalCountValue    *int `json:"discarded_not_allowed_nal_count,omitempty" validate:"omitempty"`
	DiscardedSeiCountValue              *int `json:"discarded_sei_count,omitempty" validate:"omitempty"`
	FuEndThenMiddleWorkaroundCountValue *int `json:"fu_end_then_middle_workaround_count,omitempty" validate:"omitempty"`
	FuHasBothStartEndBitsCountValue     *int `json:"fu_has_both_start_end_bits_count,omitempty" validate:"omitempty"`
	FuPatternIsBrokenCountValue         *int `json:"fu_pattern_is_broken_count,omitempty" validate:"omitempty"`
	IncompleteNalCountValue             *int `json:"incomplete_nal_count,omitempty" validate:"omitempty"`
	InvalidSeiPayloadCountValue         *int `json:"invalid_sei_payload_count,omitempty" validate:"omitempty"`
	InvalidSeiSizeCountValue            *int `json:"invalid_sei_size_count,omitempty" validate:"omitempty"`
	InvalidSeiTypeCountValue            *int `json:"invalid_sei_type_count,omitempty" validate:"omitempty"`
	NalAggregationCountValue            *int `json:"nal_aggregation_count,omitempty" validate:"omitempty"`
	NalAudCountValue                    *int `json:"nal_aud_count,omitempty" validate:"omitempty"`
	NalCountValue                       *int `json:"nal_count,omitempty" validate:"omitempty"`
	NalFillerCountValue                 *int `json:"nal_filler_count,omitempty" validate:"omitempty"`
	NalFuCountValue                     *int `json:"nal_fu_count,omitempty" validate:"omitempty"`
	NalIdrCountValue                    *int `json:"nal_idr_count,omitempty" validate:"omitempty"`
	NalOtherCountValue                  *int `json:"nal_other_count,omitempty" validate:"omitempty"`
	NalPpsCountValue                    *int `json:"nal_pps_count,omitempty" validate:"omitempty"`
	NalSeiCountValue                    *int `json:"nal_sei_count,omitempty" validate:"omitempty"`
	NalSingleCountValue                 *int `json:"nal_single_count,omitempty" validate:"omitempty"`
	NalSliceCountValue                  *int `json:"nal_slice_count,omitempty" validate:"omitempty"`
	NalSpsCountValue                    *int `json:"nal_sps_count,omitempty" validate:"omitempty"`
	NalStapACountValue                  *int `json:"nal_stap_a_count,omitempty" validate:"omitempty"`
	NalVpsCountValue                    *int `json:"nal_vps_count,omitempty" validate:"omitempty"`
}

// Required: prefix, url
type HTTPProxyConfigImpl struct {
	MainpageValue *bool               `json:"mainpage,omitempty" validate:"omitempty"`
	PrefixValue   MediaName           `json:"prefix" validate:"required"`
	StatsValue    *HTTPProxyStatsImpl `json:"stats,omitempty" validate:"omitempty"`
	URLValue      URL                 `json:"url" validate:"required"`
}

type HTTPProxyStatsImpl struct {
	HTTP100Value              *int `json:"http_100,omitempty" validate:"omitempty" openmetrics_metric:"http_proxy_100"`
	HTTP200Value              *int `json:"http_200,omitempty" validate:"omitempty" openmetrics_metric:"http_proxy_200"`
	HTTP300Value              *int `json:"http_300,omitempty" validate:"omitempty" openmetrics_metric:"http_proxy_300"`
	HTTP400Value              *int `json:"http_400,omitempty" validate:"omitempty" openmetrics_metric:"http_proxy_400"`
	HTTP500Value              *int `json:"http_500,omitempty" validate:"omitempty" openmetrics_metric:"http_proxy_500"`
	ProtocolUpgradesValue     *int `json:"protocol_upgrades,omitempty" validate:"omitempty" openmetrics_metric:"http_proxy_protocol_upgrades"`
	ProxyErrorValue           *int `json:"proxy_error,omitempty" validate:"omitempty" openmetrics_metric:"http_proxy_error"`
	ProxyErrorConnectionValue *int `json:"proxy_error_connection,omitempty" validate:"omitempty" openmetrics_metric:"http_proxy_error_connection"`
	RequestsValue             *int `json:"requests,omitempty" validate:"omitempty" openmetrics_metric:"http_proxy_requests"`
	Time1000MsValue           *int `json:"time_1000ms,omitempty" validate:"omitempty" openmetrics_metric:"http_proxy_time_1000ms"`
	Time100MsValue            *int `json:"time_100ms,omitempty" validate:"omitempty" openmetrics_metric:"http_proxy_time_100ms"`
	Time5000MsValue           *int `json:"time_5000ms,omitempty" validate:"omitempty" openmetrics_metric:"http_proxy_time_5000ms"`
	Time500MsValue            *int `json:"time_500ms,omitempty" validate:"omitempty" openmetrics_metric:"http_proxy_time_500ms"`
	TimeLongmsValue           *int `json:"time_longms,omitempty" validate:"omitempty" openmetrics_metric:"http_proxy_time_longms"`
}

// Agent counters
type InputAgentCountersImpl struct {
	ErrorsBufferOverrunValue  *int `json:"errors_buffer_overrun,omitempty" validate:"omitempty"`
	ErrorsConnFailedValue     *int `json:"errors_conn_failed,omitempty" validate:"omitempty"`
	ErrorsInvalidRequestValue *int `json:"errors_invalid_request,omitempty" validate:"omitempty"`
	ErrorsOutOfMemoryValue    *int `json:"errors_out_of_memory,omitempty" validate:"omitempty"`
	ErrorsUnknownValue        *int `json:"errors_unknown,omitempty" validate:"omitempty"`
}

// Here are grouped different counters for sessions: generic and errors
type InputCountersImpl struct {
	ErrorsTSStuckRestartsValue  *int                             `json:"errors_ts_stuck_restarts,omitempty" validate:"omitempty"`
	FramesValue                 *int                             `json:"frames,omitempty" validate:"omitempty"`
	AgentValue                  *InputAgentCountersImpl          `json:"agent,omitempty" validate:"omitempty"`
	BytesValue                  *Bytes                           `json:"bytes,omitempty" validate:"omitempty" openmetrics_metric:"stream_input_bytes"`
	BytesDvrValue               *Bytes                           `json:"bytes_dvr,omitempty" validate:"omitempty"`
	InputSwitchesValue          *int                             `json:"input_switches,omitempty" validate:"omitempty"`
	ErrorsValue                 *int                             `json:"errors,omitempty" validate:"omitempty"`
	Errors403Value              *int                             `json:"errors_403,omitempty" validate:"omitempty"`
	Errors404Value              *int                             `json:"errors_404,omitempty" validate:"omitempty"`
	Errors500Value              *int                             `json:"errors_500,omitempty" validate:"omitempty"`
	ErrorsBrokenPayloadValue    *int                             `json:"errors_broken_payload,omitempty" validate:"omitempty"`
	ErrorsCrashedValue          *int                             `json:"errors_crashed,omitempty" validate:"omitempty"`
	ErrorsDecoderResetValue     *int                             `json:"errors_decoder_reset,omitempty" validate:"omitempty"`
	ErrorsDesyncValue           *int                             `json:"errors_desync,omitempty" validate:"omitempty"`
	ErrorsDroppedFramesValue    *int                             `json:"errors_dropped_frames,omitempty" validate:"omitempty"`
	ErrorsLostPacketsValue      *int                             `json:"errors_lost_packets,omitempty" validate:"omitempty"`
	ErrorsTSPatValue            *int                             `json:"errors_ts_pat,omitempty" validate:"omitempty"`
	ErrorsTSServiceLostValue    *int                             `json:"errors_ts_service_lost,omitempty" validate:"omitempty"`
	AdSplicesInsertedValue      *int                             `json:"ad_splices_inserted,omitempty" validate:"omitempty"`
	AdSplicesIngestedValue      *int                             `json:"ad_splices_ingested,omitempty" validate:"omitempty"`
	ErrorRateValue              *int                             `json:"error_rate,omitempty" validate:"omitempty"`
	InvalidSecondaryInputsValue *int                             `json:"invalid_secondary_inputs,omitempty" validate:"omitempty"`
	MediaInfoChangesValue       *int                             `json:"media_info_changes,omitempty" validate:"omitempty"`
	MotionDetectorValue         *InputMotionDetectorCountersImpl `json:"motion_detector,omitempty" validate:"omitempty"`
	NumSecNoDataValue           *Seconds                         `json:"num_sec_no_data,omitempty" validate:"omitempty"`
	NumSecOnPrimaryInputValue   *Seconds                         `json:"num_sec_on_primary_input,omitempty" validate:"omitempty"`
	NumSecOnSecondaryInputValue *Seconds                         `json:"num_sec_on_secondary_input,omitempty" validate:"omitempty"`
	ValidSecondaryInputsValue   *int                             `json:"valid_secondary_inputs,omitempty" validate:"omitempty"`
	ReorderCountValue           *int                             `json:"reorder_count,omitempty" validate:"omitempty"`
	ResyncCountDriftValue       *int                             `json:"resync_count_drift,omitempty" validate:"omitempty"`
	ResyncCountJumpValue        *int                             `json:"resync_count_jump,omitempty" validate:"omitempty"`
	ResyncCountNormalValue      *int                             `json:"resync_count_normal,omitempty" validate:"omitempty"`
	RetriesValue                *int                             `json:"retries,omitempty" validate:"omitempty"`
	SrtValue                    *InputSrtCountersImpl            `json:"srt,omitempty" validate:"omitempty"`
	SdiValue                    *InputSdiCountersImpl            `json:"sdi,omitempty" validate:"omitempty"`
	RTPChannelsValue            []*InputRTPCountersImpl          `json:"rtp_channels,omitempty" validate:"omitempty"`
	PidsValue                   []*InputPidCountersImpl          `json:"pids,omitempty" validate:"omitempty"`
}

type InputMediaInfoImpl struct {
	ProgramIDValue *int                  `json:"program_id,omitempty" validate:"omitempty"`
	ProviderValue  *string               `json:"provider,omitempty" validate:"omitempty"`
	StreamIDValue  *int                  `json:"stream_id,omitempty" validate:"omitempty"`
	TitleValue     *string               `json:"title,omitempty" validate:"omitempty"`
	TracksValue    []*InputTrackInfoImpl `json:"tracks,omitempty" validate:"omitempty"`
}

// Specific counters to get insights on current state of getting events from cameras.
// Designed to be used by analyzers, monitoring and alerting tools
type InputMotionDetectorCountersImpl struct {
	EpisodesCountValue                  *int `json:"episodes_count,omitempty" validate:"omitempty"`
	ErrorsBrokenPayloadValue            *int `json:"errors_broken_payload,omitempty" validate:"omitempty"`
	ErrorsIncorrectTimeValuesCountValue *int `json:"errors_incorrect_time_values_count,omitempty" validate:"omitempty"`
	ErrorsNoAgentConnectedValue         *int `json:"errors_no_agent_connected,omitempty" validate:"omitempty"`
	ErrorsNoServiceCountValue           *int `json:"errors_no_service_count,omitempty" validate:"omitempty"`
	ErrorsNotAuthorizedCountValue       *int `json:"errors_not_authorized_count,omitempty" validate:"omitempty"`
	ErrorsURLUnreachableCountValue      *int `json:"errors_url_unreachable_count,omitempty" validate:"omitempty"`
	MotionDetectedCountValue            *int `json:"motion_detected_count,omitempty" validate:"omitempty"`
}

// Required: pid
type InputPidCountersImpl struct {
	ErrorsTSScrambledValue      *int `json:"errors_ts_scrambled,omitempty" validate:"omitempty"`
	PacketsValue                *int `json:"packets,omitempty" validate:"omitempty"`
	CorrectedBackwardPtsValue   *int `json:"corrected_backward_pts,omitempty" validate:"omitempty"`
	CrashedValue                *int `json:"crashed,omitempty" validate:"omitempty"`
	BrokenPesCountValue         *int `json:"broken_pes_count,omitempty" validate:"omitempty"`
	DiscardedBufferSumValue     *int `json:"discarded_buffer_sum,omitempty" validate:"omitempty"`
	DtsGoesBackwardsValue       *int `json:"dts_goes_backwards,omitempty" validate:"omitempty"`
	DtsJumpForwardValue         *int `json:"dts_jump_forward,omitempty" validate:"omitempty"`
	EmptyPacketsValue           *int `json:"empty_packets,omitempty" validate:"omitempty"`
	ErrorsAdaptationBrokenValue *int `json:"errors_adaptation_broken,omitempty" validate:"omitempty"`
	ErrorsPidLostValue          *int `json:"errors_pid_lost,omitempty" validate:"omitempty"`
	ErrorsTSCcValue             *int `json:"errors_ts_cc,omitempty" validate:"omitempty"`
	BrokenPesSumValue           *int `json:"broken_pes_sum,omitempty" validate:"omitempty"`
	TooLargeDtsJumpValue        *int `json:"too_large_dts_jump,omitempty" validate:"omitempty"`
	DiscardedBufferCountValue   *int `json:"discarded_buffer_count,omitempty" validate:"omitempty"`
	ErrorsTSTeiValue            *int `json:"errors_ts_tei,omitempty" validate:"omitempty"`
	FillersCountValue           *int `json:"fillers_count,omitempty" validate:"omitempty"`
	FillersSumValue             *int `json:"fillers_sum,omitempty" validate:"omitempty"`
	FramesValue                 *int `json:"frames,omitempty" validate:"omitempty"`
	ErrorsTSPmtValue            *int `json:"errors_ts_pmt,omitempty" validate:"omitempty"`
	PaddingPesCountValue        *int `json:"padding_pes_count,omitempty" validate:"omitempty"`
	PaddingPesSumValue          *int `json:"padding_pes_sum,omitempty" validate:"omitempty"`
	PcrResyncValue              *int `json:"pcr_resync,omitempty" validate:"omitempty"`
	ErrorsTSPsiChecksumValue    *int `json:"errors_ts_psi_checksum,omitempty" validate:"omitempty"`
	PnrValue                    *int `json:"pnr,omitempty" validate:"omitempty"`
	RepeatedFramesValue         *int `json:"repeated_frames,omitempty" validate:"omitempty"`
	TimeCorrectionsValue        *int `json:"time_corrections,omitempty" validate:"omitempty"`
	PidValue                    int  `json:"pid" validate:"required"`
}

type InputRTPCountersImpl struct {
	NalAudCountValue                    *int    `json:"nal_aud_count,omitempty" validate:"omitempty"`
	IncompleteNalCountValue             *int    `json:"incomplete_nal_count,omitempty" validate:"omitempty"`
	ContentValue                        *string `json:"content,omitempty" validate:"omitempty"`
	DiscardedBrokenNalCountValue        *int    `json:"discarded_broken_nal_count,omitempty" validate:"omitempty"`
	DiscardedFuCountValue               *int    `json:"discarded_fu_count,omitempty" validate:"omitempty"`
	DiscardedNalCountValue              *int    `json:"discarded_nal_count,omitempty" validate:"omitempty"`
	DiscardedNotAllowedNalCountValue    *int    `json:"discarded_not_allowed_nal_count,omitempty" validate:"omitempty"`
	DiscardedSeiCountValue              *int    `json:"discarded_sei_count,omitempty" validate:"omitempty"`
	ErrorsBrokenPayloadValue            *int    `json:"errors_broken_payload,omitempty" validate:"omitempty"`
	ErrorsDtsStuckValue                 *int    `json:"errors_dts_stuck,omitempty" validate:"omitempty"`
	ErrorsLostPacketsValue              *int    `json:"errors_lost_packets,omitempty" validate:"omitempty"`
	FramesValue                         *int    `json:"frames,omitempty" validate:"omitempty"`
	FuEndThenMiddleWorkaroundCountValue *int    `json:"fu_end_then_middle_workaround_count,omitempty" validate:"omitempty"`
	NalFillerCountValue                 *int    `json:"nal_filler_count,omitempty" validate:"omitempty"`
	FuPatternIsBrokenCountValue         *int    `json:"fu_pattern_is_broken_count,omitempty" validate:"omitempty"`
	NalCountValue                       *int    `json:"nal_count,omitempty" validate:"omitempty"`
	InvalidSeiPayloadCountValue         *int    `json:"invalid_sei_payload_count,omitempty" validate:"omitempty"`
	InvalidSeiSizeCountValue            *int    `json:"invalid_sei_size_count,omitempty" validate:"omitempty"`
	InvalidSeiTypeCountValue            *int    `json:"invalid_sei_type_count,omitempty" validate:"omitempty"`
	MarkerPacketsCountValue             *int    `json:"marker_packets_count,omitempty" validate:"omitempty"`
	NackCountValue                      *int    `json:"nack_count,omitempty" validate:"omitempty"`
	NalAggregationCountValue            *int    `json:"nal_aggregation_count,omitempty" validate:"omitempty"`
	TSStuckValue                        *int    `json:"ts_stuck,omitempty" validate:"omitempty"`
	BytesValue                          *int    `json:"bytes,omitempty" validate:"omitempty"`
	FuHasBothStartEndBitsCountValue     *int    `json:"fu_has_both_start_end_bits_count,omitempty" validate:"omitempty"`
	NalFuCountValue                     *int    `json:"nal_fu_count,omitempty" validate:"omitempty"`
	NalIdrCountValue                    *int    `json:"nal_idr_count,omitempty" validate:"omitempty"`
	NalOtherCountValue                  *int    `json:"nal_other_count,omitempty" validate:"omitempty"`
	NalPpsCountValue                    *int    `json:"nal_pps_count,omitempty" validate:"omitempty"`
	NalSeiCountValue                    *int    `json:"nal_sei_count,omitempty" validate:"omitempty"`
	NalSingleCountValue                 *int    `json:"nal_single_count,omitempty" validate:"omitempty"`
	NalSliceCountValue                  *int    `json:"nal_slice_count,omitempty" validate:"omitempty"`
	NalSpsCountValue                    *int    `json:"nal_sps_count,omitempty" validate:"omitempty"`
	NalStapACountValue                  *int    `json:"nal_stap_a_count,omitempty" validate:"omitempty"`
	NalVpsCountValue                    *int    `json:"nal_vps_count,omitempty" validate:"omitempty"`
	NoMarkerModeFlagValue               *bool   `json:"no_marker_mode_flag,omitempty" validate:"omitempty"`
	PtRejectCountValue                  *int    `json:"pt_reject_count,omitempty" validate:"omitempty"`
	PtRejectSumValue                    *int    `json:"pt_reject_sum,omitempty" validate:"omitempty"`
	RtcpPacketsValue                    *int    `json:"rtcp_packets,omitempty" validate:"omitempty"`
	RTPPacketsValue                     *int    `json:"rtp_packets,omitempty" validate:"omitempty"`
	SenderClockDeviationValue           *int    `json:"sender_clock_deviation,omitempty" validate:"omitempty"`
	SrTSStuckValue                      *int    `json:"sr_ts_stuck,omitempty" validate:"omitempty"`
	TSGoesBackwardsValue                *int    `json:"ts_goes_backwards,omitempty" validate:"omitempty"`
	TSJumpForwardValue                  *int    `json:"ts_jump_forward,omitempty" validate:"omitempty"`
	ChannelIDValue                      int     `json:"channel_id" validate:"required"`
}

// SDI,HDMI and other raw input counters
type InputSdiCountersImpl struct {
	AvgRecvDurationValue       *int `json:"avg_recv_duration,omitempty" validate:"omitempty"`
	CompensatedFramesValue     *int `json:"compensated_frames,omitempty" validate:"omitempty"`
	ErrorLostAudioValue        *int `json:"error_lost_audio,omitempty" validate:"omitempty"`
	ErrorsCpuStallValue        *int `json:"errors_cpu_stall,omitempty" validate:"omitempty"`
	ErrorsDuplicateValue       *int `json:"errors_duplicate,omitempty" validate:"omitempty"`
	ErrorsNoSignalValue        *int `json:"errors_no_signal,omitempty" validate:"omitempty"`
	ErrorsTSDuplicateValue     *int `json:"errors_ts_duplicate,omitempty" validate:"omitempty"`
	PeakDurationDeviationValue *int `json:"peak_duration_deviation,omitempty" validate:"omitempty"`
}

// SRT specific counters
type InputSrtCountersImpl struct {
	ErrorDroppedPacketsValue  *int `json:"error_dropped_packets,omitempty" validate:"omitempty"`
	ErrorLostPacketsValue     *int `json:"error_lost_packets,omitempty" validate:"omitempty"`
	LatencyValue              *int `json:"latency,omitempty" validate:"omitempty"`
	PacketsValue              *int `json:"packets,omitempty" validate:"omitempty"`
	RetransmittedPacketsValue *int `json:"retransmitted_packets,omitempty" validate:"omitempty"`
	RttValue                  *int `json:"rtt,omitempty" validate:"omitempty"`
}

type InputStatsImpl struct {
	InvalidSecondaryInputsValue *int                             `json:"invalid_secondary_inputs,omitempty" validate:"omitempty"`
	Errors403Value              *int                             `json:"errors_403,omitempty" validate:"omitempty"`
	AdSplicesInsertedValue      *int                             `json:"ad_splices_inserted,omitempty" validate:"omitempty"`
	AgentValue                  *InputAgentCountersImpl          `json:"agent,omitempty" validate:"omitempty"`
	BytesValue                  *Bytes                           `json:"bytes,omitempty" validate:"omitempty" openmetrics_metric:"stream_input_bytes"`
	BytesDvrValue               *Bytes                           `json:"bytes_dvr,omitempty" validate:"omitempty"`
	DivergentInputsValue        *bool                            `json:"divergent_inputs,omitempty" validate:"omitempty"`
	DvrInfoValue                *DvrInfoImpl                     `json:"dvr_info,omitempty" validate:"omitempty"`
	ErrorRateValue              *int                             `json:"error_rate,omitempty" validate:"omitempty"`
	ActiveValue                 *bool                            `json:"active,omitempty" validate:"omitempty"`
	InputSwitchesValue          *int                             `json:"input_switches,omitempty" validate:"omitempty"`
	Errors404Value              *int                             `json:"errors_404,omitempty" validate:"omitempty"`
	Errors500Value              *int                             `json:"errors_500,omitempty" validate:"omitempty"`
	ErrorsBrokenPayloadValue    *int                             `json:"errors_broken_payload,omitempty" validate:"omitempty"`
	ErrorsCrashedValue          *int                             `json:"errors_crashed,omitempty" validate:"omitempty"`
	ErrorsDecoderResetValue     *int                             `json:"errors_decoder_reset,omitempty" validate:"omitempty"`
	ErrorsDesyncValue           *int                             `json:"errors_desync,omitempty" validate:"omitempty"`
	ErrorsDroppedFramesValue    *int                             `json:"errors_dropped_frames,omitempty" validate:"omitempty"`
	ErrorsLostPacketsValue      *int                             `json:"errors_lost_packets,omitempty" validate:"omitempty"`
	ErrorsTSPatValue            *int                             `json:"errors_ts_pat,omitempty" validate:"omitempty"`
	ErrorsTSServiceLostValue    *int                             `json:"errors_ts_service_lost,omitempty" validate:"omitempty"`
	ErrorsTSStuckRestartsValue  *int                             `json:"errors_ts_stuck_restarts,omitempty" validate:"omitempty"`
	AdSplicesIngestedValue      *int                             `json:"ad_splices_ingested,omitempty" validate:"omitempty"`
	FramesValue                 *int                             `json:"frames,omitempty" validate:"omitempty"`
	ErrorsValue                 *int                             `json:"errors,omitempty" validate:"omitempty"`
	IPValue                     *string                          `json:"ip,omitempty" validate:"omitempty"`
	MediaInfoValue              *MediaInfoImpl                   `json:"media_info,omitempty" validate:"omitempty"`
	MediaInfoChangesValue       *int                             `json:"media_info_changes,omitempty" validate:"omitempty"`
	MotionDetectorValue         *InputMotionDetectorCountersImpl `json:"motion_detector,omitempty" validate:"omitempty"`
	NumSecNoDataValue           *Seconds                         `json:"num_sec_no_data,omitempty" validate:"omitempty"`
	NumSecOnPrimaryInputValue   *Seconds                         `json:"num_sec_on_primary_input,omitempty" validate:"omitempty"`
	NumSecOnSecondaryInputValue *Seconds                         `json:"num_sec_on_secondary_input,omitempty" validate:"omitempty"`
	OpenedAtValue               *UtcMs                           `json:"opened_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	ValidSecondaryInputsValue   *int                             `json:"valid_secondary_inputs,omitempty" validate:"omitempty"`
	ProtoValue                  *Protocol                        `json:"proto,omitempty" validate:"omitempty"`
	ReorderCountValue           *int                             `json:"reorder_count,omitempty" validate:"omitempty"`
	ResyncCountDriftValue       *int                             `json:"resync_count_drift,omitempty" validate:"omitempty"`
	ResyncCountJumpValue        *int                             `json:"resync_count_jump,omitempty" validate:"omitempty"`
	ResyncCountNormalValue      *int                             `json:"resync_count_normal,omitempty" validate:"omitempty"`
	RetriesValue                *int                             `json:"retries,omitempty" validate:"omitempty"`
	UserAgentValue              *string                          `json:"user_agent,omitempty" validate:"omitempty"`
	SdiValue                    *InputSdiCountersImpl            `json:"sdi,omitempty" validate:"omitempty"`
	SrtValue                    *InputSrtCountersImpl            `json:"srt,omitempty" validate:"omitempty"`
	TSDelayValue                *Ticks                           `json:"ts_delay,omitempty" validate:"omitempty"`
	URLValue                    *URL                             `json:"url,omitempty" validate:"omitempty"`
	TSDelayPerTracksValue       []Ticks                          `json:"ts_delay_per_tracks,omitempty" validate:"omitempty"`
	RTPChannelsValue            []*InputRTPCountersImpl          `json:"rtp_channels,omitempty" validate:"omitempty"`
	PidsValue                   []*InputPidCountersImpl          `json:"pids,omitempty" validate:"omitempty"`
}

type InputTrackInfoImpl struct {
	MatchValue *InputTrackInfoMatchImpl `json:"match,omitempty" validate:"omitempty"`
}

type InputTrackInfoMatchImpl struct {
	CodecValue    *FrameCodec `json:"codec,omitempty" validate:"omitempty"`
	IndexValue    *int        `json:"index,omitempty" validate:"omitempty"`
	LanguageValue *string     `json:"language,omitempty" validate:"omitempty"`
}

type LayouterEntityFetchedImpl struct {
	EntityBodyValue any                    `json:"entity_body,omitempty" validate:"omitempty"`
	EntityIDValue   *string                `json:"entity_id,omitempty" validate:"omitempty"`
	EntityTypeValue *EntityEventEntityType `json:"entity_type,omitempty" validate:"omitempty,oneof=agent stream streamer"`
	EventIDValue    *int                   `json:"event_id,omitempty" validate:"omitempty"`
	ServerValue     *string                `json:"server,omitempty" validate:"omitempty"`
	TraceIDValue    *UUID                  `json:"trace_id,omitempty" validate:"omitempty"`
	UtcMsValue      *UtcMs                 `json:"utc_ms,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	EventValue      string                 `json:"event" validate:"required"`
}

type LayouterFetchingStartedImpl struct {
	EventIDValue *int    `json:"event_id,omitempty" validate:"omitempty"`
	ServerValue  *string `json:"server,omitempty" validate:"omitempty"`
	TraceIDValue *UUID   `json:"trace_id,omitempty" validate:"omitempty"`
	UtcMsValue   *UtcMs  `json:"utc_ms,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	EventValue   string  `json:"event" validate:"required"`
}

type LayouterProcessAgentsErrorImpl struct {
	ErrorValue   *ErrorImpl `json:"error,omitempty" validate:"omitempty"`
	EventIDValue *int       `json:"event_id,omitempty" validate:"omitempty"`
	ServerValue  *string    `json:"server,omitempty" validate:"omitempty"`
	TraceIDValue *UUID      `json:"trace_id,omitempty" validate:"omitempty"`
	UtcMsValue   *UtcMs     `json:"utc_ms,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	EventValue   string     `json:"event" validate:"required"`
}

type LayouterProcessAgentsSuccessImpl struct {
	AgentsUpdatedValue *int    `json:"agents_updated,omitempty" validate:"omitempty"`
	EventIDValue       *int    `json:"event_id,omitempty" validate:"omitempty"`
	ServerValue        *string `json:"server,omitempty" validate:"omitempty"`
	TraceIDValue       *UUID   `json:"trace_id,omitempty" validate:"omitempty"`
	UtcMsValue         *UtcMs  `json:"utc_ms,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	EventValue         string  `json:"event" validate:"required"`
}

type LayouterProcessStreamsErrorImpl struct {
	ErrorValue   *ErrorImpl `json:"error,omitempty" validate:"omitempty"`
	EventIDValue *int       `json:"event_id,omitempty" validate:"omitempty"`
	ServerValue  *string    `json:"server,omitempty" validate:"omitempty"`
	TraceIDValue *UUID      `json:"trace_id,omitempty" validate:"omitempty"`
	UtcMsValue   *UtcMs     `json:"utc_ms,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	EventValue   string     `json:"event" validate:"required"`
}

type LayouterProcessStreamsSuccessImpl struct {
	EventIDValue        *int    `json:"event_id,omitempty" validate:"omitempty"`
	ServerValue         *string `json:"server,omitempty" validate:"omitempty"`
	StreamsUpdatedValue *int    `json:"streams_updated,omitempty" validate:"omitempty"`
	TraceIDValue        *UUID   `json:"trace_id,omitempty" validate:"omitempty"`
	UtcMsValue          *UtcMs  `json:"utc_ms,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	EventValue          string  `json:"event" validate:"required"`
}

type LayouterProcessingResultImpl struct {
	EventIDValue   *int                               `json:"event_id,omitempty" validate:"omitempty"`
	ServerValue    *string                            `json:"server,omitempty" validate:"omitempty"`
	TraceIDValue   *UUID                              `json:"trace_id,omitempty" validate:"omitempty"`
	UtcMsValue     *UtcMs                             `json:"utc_ms,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	EventValue     string                             `json:"event" validate:"required"`
	RelayoutsValue []*CentralStreamLayoutListItemImpl `json:"relayouts,omitempty" validate:"omitempty"`
}

// Required: port
type ListenConfigImpl struct {
	AddressValue *string     `json:"address,omitempty" validate:"omitempty"`
	PortValue    NetworkPort `json:"port" validate:"required"`
}

type ListenHTTPConfigImpl struct {
	AddressValue      *string     `json:"address,omitempty" validate:"omitempty"`
	APIValue          *bool       `json:"api,omitempty" validate:"omitempty"`
	ReadTimeoutValue  *int        `json:"read_timeout,omitempty" validate:"omitempty"`
	WriteTimeoutValue *int        `json:"write_timeout,omitempty" validate:"omitempty"`
	PortValue         NetworkPort `json:"port" validate:"required"`
}

type ListenHTTPConfigParamsImpl struct {
	APIValue          *bool `json:"api,omitempty" validate:"omitempty"`
	ReadTimeoutValue  *int  `json:"read_timeout,omitempty" validate:"omitempty"`
	WriteTimeoutValue *int  `json:"write_timeout,omitempty" validate:"omitempty"`
}

type ListenHTTPSConfigImpl struct {
	AddressValue        *string      `json:"address,omitempty" validate:"omitempty"`
	APIValue            *bool        `json:"api,omitempty" validate:"omitempty"`
	CertificateValue    *string      `json:"certificate,omitempty" validate:"omitempty"`
	CertificateKeyValue *string      `json:"certificate_key,omitempty" validate:"omitempty"`
	ReadTimeoutValue    *int         `json:"read_timeout,omitempty" validate:"omitempty"`
	WriteTimeoutValue   *int         `json:"write_timeout,omitempty" validate:"omitempty"`
	SslProtocolsValue   []TlsVersion `json:"ssl_protocols,omitempty" validate:"omitempty"`
	PortValue           NetworkPort  `json:"port" validate:"required"`
}

type ListenSslConfigImpl struct {
	CertificateValue    *string      `json:"certificate,omitempty" validate:"omitempty"`
	CertificateKeyValue *string      `json:"certificate_key,omitempty" validate:"omitempty"`
	SslProtocolsValue   []TlsVersion `json:"ssl_protocols,omitempty" validate:"omitempty"`
}

type ListenersImpl struct {
	HTTPValue  []*ListenHTTPConfigImpl  `json:"http,omitempty" validate:"omitempty"`
	HTTPSValue []*ListenHTTPSConfigImpl `json:"https,omitempty" validate:"omitempty"`
}

type MediaInfoImpl struct {
	DurationValue  *Ticks                     `json:"duration,omitempty" validate:"omitempty"`
	FlowTypeValue  *MediaInfoSpecificFlowType `json:"flow_type,omitempty" validate:"omitempty,oneof=file stream dvr_file dvr_stream"`
	ProgramIDValue *int                       `json:"program_id,omitempty" validate:"omitempty"`
	ProviderValue  *string                    `json:"provider,omitempty" validate:"omitempty"`
	StreamIDValue  *int                       `json:"stream_id,omitempty" validate:"omitempty"`
	TitleValue     *string                    `json:"title,omitempty" validate:"omitempty"`
	TracksValue    []*TrackInfoImpl           `json:"tracks,omitempty" validate:"omitempty"`
}

type MediaInfoCommonImpl struct {
	ProgramIDValue *int    `json:"program_id,omitempty" validate:"omitempty"`
	ProviderValue  *string `json:"provider,omitempty" validate:"omitempty"`
	StreamIDValue  *int    `json:"stream_id,omitempty" validate:"omitempty"`
	TitleValue     *string `json:"title,omitempty" validate:"omitempty"`
}

type MediaInfoSpecificImpl struct {
	DurationValue *Ticks                     `json:"duration,omitempty" validate:"omitempty"`
	FlowTypeValue *MediaInfoSpecificFlowType `json:"flow_type,omitempty" validate:"omitempty,oneof=file stream dvr_file dvr_stream"`
	TracksValue   []*TrackInfoImpl           `json:"tracks,omitempty" validate:"omitempty"`
}

type OpenmetricsLabelsImpl struct {
}

type OutputMpegtsPidsImpl struct {
	DefaultValue *string               `json:"default,omitempty" validate:"omitempty"`
	PcrValue     *int                  `json:"pcr,omitempty" validate:"omitempty"`
	PmtValue     *int                  `json:"pmt,omitempty" validate:"omitempty"`
	SdtValue     *int                  `json:"sdt,omitempty" validate:"omitempty"`
	MediaValue   []*TransponderPidImpl `json:"media,omitempty" validate:"omitempty"`
}

type PartitionStatsImpl struct {
	DeviceValue  *DiskDevice `json:"device,omitempty" validate:"omitempty" openmetrics_label:"device"`
	IoUtilValue  *Percent    `json:"io_util,omitempty" validate:"omitempty,min=0,max=100" openmetrics_metric:"device_io_util"`
	PathValue    *DiskPath   `json:"path,omitempty" validate:"omitempty" openmetrics_label:"path"`
	TotalMbValue *Megabytes  `json:"total_mb,omitempty" validate:"omitempty" openmetrics_metric:"partition_total_mb"`
	UsageValue   *Percent    `json:"usage,omitempty" validate:"omitempty,min=0,max=100" openmetrics_metric:"partition_usage"`
}

type PeerConfigImpl struct {
	APIURLValue       *URL           `json:"api_url,omitempty" validate:"omitempty"`
	ChannelLimitValue *int           `json:"channel_limit,omitempty" validate:"omitempty"`
	ClusterKeyValue   *string        `json:"cluster_key,omitempty" validate:"omitempty"`
	CpuLimitValue     *Percent       `json:"cpu_limit,omitempty" validate:"omitempty,min=0,max=100"`
	FetchTimeoutValue *Milliseconds  `json:"fetch_timeout,omitempty" validate:"omitempty"`
	HostnameValue     *ServerName    `json:"hostname,omitempty" validate:"omitempty"`
	MaxBitrateValue   *Speed         `json:"max_bitrate,omitempty" validate:"omitempty"`
	NamespaceValue    *UnixName      `json:"namespace,omitempty" validate:"omitempty"`
	StaleTimeoutValue *Milliseconds  `json:"stale_timeout,omitempty" validate:"omitempty"`
	StatsValue        *PeerStatsImpl `json:"stats,omitempty" validate:"omitempty"`
}

type PeerStatsImpl struct {
	OpenedFilesValue          *int                           `json:"opened_files,omitempty" validate:"omitempty" openmetrics_metric:"server_opened_files"`
	OutputKbitValue           *Speed                         `json:"output_kbit,omitempty" validate:"omitempty" openmetrics_metric:"server_output_bitrate"`
	ConfigErrorValue          *ConfigErrorStatusImpl         `json:"config_error,omitempty" validate:"omitempty"`
	ConfigExternalStatusValue *ConfigExternalErrorStatusImpl `json:"config_external_status,omitempty" validate:"omitempty"`
	VsaasRunningValue         *bool                          `json:"vsaas_running,omitempty" validate:"omitempty"`
	CpuUsageValue             *Percent                       `json:"cpu_usage,omitempty" validate:"omitempty,min=0,max=100" openmetrics_metric:"server_cpu_usage"`
	ErrorValue                *string                        `json:"error,omitempty" validate:"omitempty"`
	HealthcheckStatusValue    *CentralHealthcheckStatusImpl  `json:"healthcheck_status,omitempty" validate:"omitempty"`
	HostnameValue             *string                        `json:"hostname,omitempty" validate:"omitempty"`
	VsaasBrandingValue        *bool                          `json:"vsaas_branding,omitempty" validate:"omitempty"`
	InputKbitValue            *Speed                         `json:"input_kbit,omitempty" validate:"omitempty" openmetrics_metric:"server_input_bitrate"`
	IsChassisValue            *bool                          `json:"is_chassis,omitempty" validate:"omitempty"`
	LicenseTxtValue           *string                        `json:"license_txt,omitempty" validate:"omitempty"`
	LicenseTypeValue          *LicenseType                   `json:"license_type,omitempty" validate:"omitempty"`
	MemoryUsageValue          *Percent                       `json:"memory_usage,omitempty" validate:"omitempty,min=0,max=100" openmetrics_metric:"server_memory_usage"`
	NextVersionValue          *ServerVersion                 `json:"next_version,omitempty" validate:"omitempty"`
	NowValue                  *UtcMs                         `json:"now,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	OnlineStreamsValue        *int                           `json:"online_streams,omitempty" validate:"omitempty" openmetrics_metric:"server_online_streams"`
	BuildValue                *int                           `json:"build,omitempty" validate:"omitempty" openmetrics_label:"build"`
	BandwidthUsageValue       *Percent                       `json:"bandwidth_usage,omitempty" validate:"omitempty,min=0,max=100"`
	IDValue                   *UUID                          `json:"id,omitempty" validate:"omitempty"`
	PredictionsValue          *PeerStatsPredictionsImpl      `json:"predictions,omitempty" validate:"omitempty"`
	RproxyValue               *bool                          `json:"rproxy,omitempty" validate:"omitempty"`
	RproxyRunningValue        *bool                          `json:"rproxy_running,omitempty" validate:"omitempty"`
	SchedulerLoadValue        *Percent                       `json:"scheduler_load,omitempty" validate:"omitempty,min=0,max=100" openmetrics_metric:"server_scheduler_load"`
	ServerVersionValue        *ServerVersion                 `json:"server_version,omitempty" validate:"omitempty" openmetrics_label:"version"`
	StartedAtValue            *Utc                           `json:"started_at,omitempty" validate:"omitempty,min=1e+09,max=1e+10" openmetrics_metric:"server_started_at"`
	StreamerStatusValue       *ServerStatsStreamerStatus     `json:"streamer_status,omitempty" validate:"omitempty"`
	TextAlertsValue           map[string]string              `json:"text_alerts,omitempty" validate:"omitempty"`
	TotalBandwidthValue       *Speed                         `json:"total_bandwidth,omitempty" validate:"omitempty"`
	TotalClientsValue         *int                           `json:"total_clients,omitempty" validate:"omitempty" openmetrics_metric:"server_total_clients"`
	TotalStreamsValue         *int                           `json:"total_streams,omitempty" validate:"omitempty"`
	TranscoderValue           *bool                          `json:"transcoder,omitempty" validate:"omitempty"`
	VsaasValue                *bool                          `json:"vsaas,omitempty" validate:"omitempty"`
	UptimeValue               *Seconds                       `json:"uptime,omitempty" validate:"omitempty"`
	TranscoderDevicesValue    []*TranscoderDeviceStatsImpl   `json:"transcoder_devices,omitempty" validate:"omitempty"`
	PartitionsValue           []*PartitionStatsImpl          `json:"partitions,omitempty" validate:"omitempty"`
	ConfigVersionValue        []int                          `json:"config_version,omitempty" validate:"omitempty"`
}

// Predictions of future stats based on the current state of the cluster.
type PeerStatsPredictionsImpl struct {
	DiskValue *CentralDiskPredictionsImpl `json:"disk,omitempty" validate:"omitempty"`
}

type PlayProtocolsSpecImpl struct {
	APIValue       *bool `json:"api,omitempty" validate:"omitempty"`
	CmafValue      *bool `json:"cmaf,omitempty" validate:"omitempty"`
	DashValue      *bool `json:"dash,omitempty" validate:"omitempty"`
	HlsValue       *bool `json:"hls,omitempty" validate:"omitempty"`
	JpegValue      *bool `json:"jpeg,omitempty" validate:"omitempty"`
	M4fValue       *bool `json:"m4f,omitempty" validate:"omitempty"`
	M4sValue       *bool `json:"m4s,omitempty" validate:"omitempty"`
	Mp4Value       *bool `json:"mp4,omitempty" validate:"omitempty"`
	MseldValue     *bool `json:"mseld,omitempty" validate:"omitempty"`
	MssValue       *bool `json:"mss,omitempty" validate:"omitempty"`
	PlayerValue    *bool `json:"player,omitempty" validate:"omitempty"`
	RtmpValue      *bool `json:"rtmp,omitempty" validate:"omitempty"`
	RtspValue      *bool `json:"rtsp,omitempty" validate:"omitempty"`
	ShoutcastValue *bool `json:"shoutcast,omitempty" validate:"omitempty"`
	SrtValue       *bool `json:"srt,omitempty" validate:"omitempty"`
	TshttpValue    *bool `json:"tshttp,omitempty" validate:"omitempty"`
	WebrtcValue    *bool `json:"webrtc,omitempty" validate:"omitempty"`
	WhitelistValue *bool `json:"whitelist,omitempty" validate:"omitempty"`
}

type PlaybackHeadersImpl struct {
	HeadersValue        map[string]string        `json:"headers,omitempty" validate:"omitempty,dive,min=1,max=64"`
	PlaybackValue       *PlaybackHeadersPlayback `json:"playback,omitempty" validate:"omitempty,oneof=live dvr"`
	ProtocolsValue      *PlayProtocolsSpecImpl   `json:"protocols,omitempty" validate:"omitempty"`
	SegmentHeadersValue map[string]string        `json:"segment_headers,omitempty" validate:"omitempty,dive,min=1,max=64"`
}

type PushCountersImpl struct {
	ErrorsStopOverloadedValue       *int                   `json:"errors_stop_overloaded,omitempty" validate:"omitempty"`
	ErrorsTlsValue                  *int                   `json:"errors_tls,omitempty" validate:"omitempty"`
	Errors401Value                  *int                   `json:"errors_401,omitempty" validate:"omitempty"`
	Errors403Value                  *int                   `json:"errors_403,omitempty" validate:"omitempty"`
	Errors404Value                  *int                   `json:"errors_404,omitempty" validate:"omitempty"`
	Errors409Value                  *int                   `json:"errors_409,omitempty" validate:"omitempty"`
	Errors500Value                  *int                   `json:"errors_500,omitempty" validate:"omitempty"`
	ErrorsAudioFrameDecodeValue     *int                   `json:"errors_audio_frame_decode,omitempty" validate:"omitempty"`
	ErrorsConnectionLostValue       *int                   `json:"errors_connection_lost,omitempty" validate:"omitempty"`
	ErrorsDeviceBufferOverflowValue *int                   `json:"errors_device_buffer_overflow,omitempty" validate:"omitempty"`
	ErrorsVideoFrameDecodeValue     *int                   `json:"errors_video_frame_decode,omitempty" validate:"omitempty"`
	ErrorsDroppedFramesValue        *int                   `json:"errors_dropped_frames,omitempty" validate:"omitempty"`
	ErrorsDroppedSegmentsValue      *int                   `json:"errors_dropped_segments,omitempty" validate:"omitempty"`
	ErrorsNoDestinationValue        *int                   `json:"errors_no_destination,omitempty" validate:"omitempty"`
	ErrorsNotAuthorizedValue        *int                   `json:"errors_not_authorized,omitempty" validate:"omitempty"`
	ErrorsRedirectLimitValue        *int                   `json:"errors_redirect_limit,omitempty" validate:"omitempty"`
	EncodedBytesValue               *Bytes                 `json:"encoded_bytes,omitempty" validate:"omitempty"`
	BytesValue                      *Bytes                 `json:"bytes,omitempty" validate:"omitempty"`
	ErrorsDeviceNotOpenedValue      *int                   `json:"errors_device_not_opened,omitempty" validate:"omitempty"`
	FramesValue                     *int                   `json:"frames,omitempty" validate:"omitempty"`
	GenlockStatusValue              *GenlockStatus         `json:"genlock_status,omitempty" validate:"omitempty"`
	GenrefStatusValue               *GenrefStatusImpl      `json:"genref_status,omitempty" validate:"omitempty"`
	OpenedAtValue                   *UtcMs                 `json:"opened_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	URLValue                        *InputURL              `json:"url,omitempty" validate:"omitempty"`
	PusherQueueExhaustedCountValue  *int                   `json:"pusher_queue_exhausted_count,omitempty" validate:"omitempty"`
	PusherRestartsValue             *int                   `json:"pusher_restarts,omitempty" validate:"omitempty"`
	ResentPacketsValue              *int                   `json:"resent_packets,omitempty" validate:"omitempty"`
	SegmentsValue                   *int                   `json:"segments,omitempty" validate:"omitempty"`
	StandbyStatusValue              *PusherStandbyStatus   `json:"standby_status,omitempty" validate:"omitempty"`
	StatusValue                     *PusherStatus          `json:"status,omitempty" validate:"omitempty"`
	SysFillersBytesValue            *Bytes                 `json:"sys_fillers_bytes,omitempty" validate:"omitempty"`
	SysPayloadBytesValue            *Bytes                 `json:"sys_payload_bytes,omitempty" validate:"omitempty"`
	SysStuffingPacketsValue         *int                   `json:"sys_stuffing_packets,omitempty" validate:"omitempty"`
	PidsValue                       []*PushPidCountersImpl `json:"pids,omitempty" validate:"omitempty"`
}

// Required: pid
type PushPidCountersImpl struct {
	FillersBytesValue            *Bytes        `json:"fillers_bytes,omitempty" validate:"omitempty"`
	ErrorsStartLateDtsValue      *int          `json:"errors_start_late_dts,omitempty" validate:"omitempty"`
	ErrorsDtsGoesBackwardValue   *int          `json:"errors_dts_goes_backward,omitempty" validate:"omitempty"`
	ErrorsDtsJumpsForwardValue   *int          `json:"errors_dts_jumps_forward,omitempty" validate:"omitempty"`
	ErrorsPidOffValue            *int          `json:"errors_pid_off,omitempty" validate:"omitempty"`
	ErrorsStartFutureDtsValue    *int          `json:"errors_start_future_dts,omitempty" validate:"omitempty"`
	FillersValue                 *Bytes        `json:"fillers,omitempty" validate:"omitempty" openmetrics_metric:"pid_fillers"`
	ErrorsUnconfiguredQueueValue *int          `json:"errors_unconfigured_queue,omitempty" validate:"omitempty"`
	ExceededBytesValue           *Bytes        `json:"exceeded_bytes,omitempty" validate:"omitempty"`
	ExceededFramesValue          *int          `json:"exceeded_frames,omitempty" validate:"omitempty"`
	ContentValue                 *FrameContent `json:"content,omitempty" validate:"omitempty"`
	FillerPacketsValue           *int          `json:"filler_packets,omitempty" validate:"omitempty"`
	PayloadValue                 *Bytes        `json:"payload,omitempty" validate:"omitempty" openmetrics_metric:"pid_payload"`
	MaxBufferValue               *Milliseconds `json:"max_buffer,omitempty" validate:"omitempty"`
	MinBufferValue               *Milliseconds `json:"min_buffer,omitempty" validate:"omitempty"`
	PacketsValue                 *int          `json:"packets,omitempty" validate:"omitempty"`
	BitrateValue                 *Speed        `json:"bitrate,omitempty" validate:"omitempty"`
	PayloadBytesValue            *Bytes        `json:"payload_bytes,omitempty" validate:"omitempty"`
	TrimmedFramesValue           *int          `json:"trimmed_frames,omitempty" validate:"omitempty"`
	PnrValue                     *int          `json:"pnr,omitempty" validate:"omitempty"`
	StuffingValue                *int          `json:"stuffing,omitempty" validate:"omitempty" openmetrics_metric:"pid_stuffing"`
	StuffingPacketsValue         *int          `json:"stuffing_packets,omitempty" validate:"omitempty"`
	TrimmedBytesValue            *Bytes        `json:"trimmed_bytes,omitempty" validate:"omitempty"`
	PidValue                     int           `json:"pid" validate:"required"`
}

// Required: channel_id
type RTPCountersBaseImpl struct {
	NackCountValue            *int    `json:"nack_count,omitempty" validate:"omitempty"`
	PtRejectCountValue        *int    `json:"pt_reject_count,omitempty" validate:"omitempty"`
	ContentValue              *string `json:"content,omitempty" validate:"omitempty"`
	NoMarkerModeFlagValue     *bool   `json:"no_marker_mode_flag,omitempty" validate:"omitempty"`
	ErrorsDtsStuckValue       *int    `json:"errors_dts_stuck,omitempty" validate:"omitempty"`
	ErrorsLostPacketsValue    *int    `json:"errors_lost_packets,omitempty" validate:"omitempty"`
	FramesValue               *int    `json:"frames,omitempty" validate:"omitempty"`
	MarkerPacketsCountValue   *int    `json:"marker_packets_count,omitempty" validate:"omitempty"`
	TSStuckValue              *int    `json:"ts_stuck,omitempty" validate:"omitempty"`
	BytesValue                *int    `json:"bytes,omitempty" validate:"omitempty"`
	ErrorsBrokenPayloadValue  *int    `json:"errors_broken_payload,omitempty" validate:"omitempty"`
	PtRejectSumValue          *int    `json:"pt_reject_sum,omitempty" validate:"omitempty"`
	RtcpPacketsValue          *int    `json:"rtcp_packets,omitempty" validate:"omitempty"`
	RTPPacketsValue           *int    `json:"rtp_packets,omitempty" validate:"omitempty"`
	SenderClockDeviationValue *int    `json:"sender_clock_deviation,omitempty" validate:"omitempty"`
	SrTSStuckValue            *int    `json:"sr_ts_stuck,omitempty" validate:"omitempty"`
	TSGoesBackwardsValue      *int    `json:"ts_goes_backwards,omitempty" validate:"omitempty"`
	TSJumpForwardValue        *int    `json:"ts_jump_forward,omitempty" validate:"omitempty"`
	ChannelIDValue            int     `json:"channel_id" validate:"required"`
}

// Required: path
type RaidDiskConfigImpl struct {
	ModeValue  *RaidDiskMode            `json:"mode,omitempty" validate:"omitempty"`
	StatsValue *RaidDiskConfigStatsImpl `json:"stats,omitempty" validate:"omitempty"`
	PathValue  DiskPath                 `json:"path" validate:"required" openmetrics_label:"disk"`
}

// The runtime statistics about RAID. The statistics shows the state of disks.
// Learn more in [Flussonic RAID for DVR](https://flussonic.com/doc/extend-video-storage-on-fly/#dvr-flussonic-raid-stats)
type RaidDiskConfigStatsImpl struct {
	BlobsCountValue       *int                `json:"blobs_count,omitempty" validate:"omitempty" openmetrics_metric:"storage_blobs_count"`
	BlobsCountDbValue     *int                `json:"blobs_count_db,omitempty" validate:"omitempty" openmetrics_metric:"storage_blobs_count_db"`
	ErrorsValue           *RaidDiskErrorsImpl `json:"errors,omitempty" validate:"omitempty"`
	IoUsageValue          *Percent            `json:"io_usage,omitempty" validate:"omitempty,min=0,max=100" openmetrics_metric:"raid_disk_io_usage"`
	MigrationEtaValue     *Utc                `json:"migration_eta,omitempty" validate:"omitempty,min=1e+09,max=1e+10"`
	MigrationSpeedValue   *Speed              `json:"migration_speed,omitempty" validate:"omitempty"`
	MigrationUpdatedValue *Utc                `json:"migration_updated,omitempty" validate:"omitempty,min=1e+09,max=1e+10"`
	ModeValue             *RaidDiskMode       `json:"mode,omitempty" validate:"omitempty"`
	MountedValue          *bool               `json:"mounted,omitempty" validate:"omitempty"`
	SizeValue             *Bytes              `json:"size,omitempty" validate:"omitempty" openmetrics_metric:"storage_size"`
	UsageValue            *Percent            `json:"usage,omitempty" validate:"omitempty,min=0,max=100" openmetrics_metric:"storage_usage"`
	UsedValue             *Bytes              `json:"used,omitempty" validate:"omitempty" openmetrics_metric:"storage_used"`
	UsedIndexValue        *Bytes              `json:"used_index,omitempty" validate:"omitempty" openmetrics_metric:"storage_used_index"`
}

type RaidDiskErrorsImpl struct {
	ConnectionTimeoutValue *int `json:"connection_timeout,omitempty" validate:"omitempty"`
	EaccesValue            *int `json:"eacces,omitempty" validate:"omitempty"`
	EagainValue            *int `json:"eagain,omitempty" validate:"omitempty"`
	EbusyValue             *int `json:"ebusy,omitempty" validate:"omitempty"`
	EconnrefusedValue      *int `json:"econnrefused,omitempty" validate:"omitempty"`
	EdquotValue            *int `json:"edquot,omitempty" validate:"omitempty"`
	EmfileValue            *int `json:"emfile,omitempty" validate:"omitempty"`
	EnodevValue            *int `json:"enodev,omitempty" validate:"omitempty"`
	EnoentValue            *int `json:"enoent,omitempty" validate:"omitempty"`
	EnospcValue            *int `json:"enospc,omitempty" validate:"omitempty"`
	ErofsValue             *int `json:"erofs,omitempty" validate:"omitempty"`
	NxdomainValue          *int `json:"nxdomain,omitempty" validate:"omitempty"`
	OtherValue             *int `json:"other,omitempty" validate:"omitempty"`
	SslErrorValue          *int `json:"ssl_error,omitempty" validate:"omitempty"`
}

type RaidDiskStatsImpl struct {
	ErrorsValue           *RaidDiskErrorsImpl `json:"errors,omitempty" validate:"omitempty"`
	IoUsageValue          *Percent            `json:"io_usage,omitempty" validate:"omitempty,min=0,max=100" openmetrics_metric:"raid_disk_io_usage"`
	MigrationEtaValue     *Utc                `json:"migration_eta,omitempty" validate:"omitempty,min=1e+09,max=1e+10"`
	MigrationSpeedValue   *Speed              `json:"migration_speed,omitempty" validate:"omitempty"`
	MigrationUpdatedValue *Utc                `json:"migration_updated,omitempty" validate:"omitempty,min=1e+09,max=1e+10"`
	ModeValue             *RaidDiskMode       `json:"mode,omitempty" validate:"omitempty"`
	MountedValue          *bool               `json:"mounted,omitempty" validate:"omitempty"`
}

// Required: streampoint_key
type RproxyConfigImpl struct {
	EndpointAuthValue   *string                            `json:"endpoint_auth,omitempty" validate:"omitempty"`
	ForwardPortsValue   map[string]*ForwardPortsConfigImpl `json:"forward_ports,omitempty" validate:"omitempty"`
	StreampointKeyValue string                             `json:"streampoint_key" validate:"required,min=1,max=256"`
}

type ServerConfigBaseImpl struct {
	ClusterKeyValue  *string                 `json:"cluster_key,omitempty" validate:"omitempty"`
	ServerNamesValue []*ServerNameConfigImpl `json:"server_names,omitempty" validate:"omitempty"`
}

type ServerConfigFullImpl struct {
	RproxyValue      *RproxyConfigImpl      `json:"rproxy,omitempty" validate:"omitempty"`
	EventSinksValue  []*EventSinkConfigImpl `json:"event_sinks,omitempty" validate:"omitempty"`
	HTTPProxiesValue []*HTTPProxyConfigImpl `json:"http_proxies,omitempty" validate:"omitempty"`
}

// Required: domain
type ServerNameConfigImpl struct {
	DomainValue  string   `json:"domain" validate:"required"`
	AliasesValue []string `json:"aliases,omitempty" validate:"omitempty"`
}

type ServerStartedImpl struct {
	EventIDValue       *int                 `json:"event_id,omitempty" validate:"omitempty"`
	InstanceIDValue    *string              `json:"instance_id,omitempty" validate:"omitempty"`
	PreviousStateValue *PreviousServerState `json:"previous_state,omitempty" validate:"omitempty"`
	ServerValue        *string              `json:"server,omitempty" validate:"omitempty"`
	TraceIDValue       *UUID                `json:"trace_id,omitempty" validate:"omitempty"`
	UtcMsValue         *UtcMs               `json:"utc_ms,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	VersionValue       *string              `json:"version,omitempty" validate:"omitempty"`
	EventValue         string               `json:"event" validate:"required"`
}

type ServerStartingImpl struct {
	EventIDValue     *int    `json:"event_id,omitempty" validate:"omitempty"`
	FullVersionValue *string `json:"full_version,omitempty" validate:"omitempty"`
	ServerValue      *string `json:"server,omitempty" validate:"omitempty"`
	TraceIDValue     *UUID   `json:"trace_id,omitempty" validate:"omitempty"`
	UtcMsValue       *UtcMs  `json:"utc_ms,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	VersionValue     *string `json:"version,omitempty" validate:"omitempty"`
	EventValue       string  `json:"event" validate:"required"`
}

type ServerStatsNetworkImpl struct {
	InputKbitValue     *Speed `json:"input_kbit,omitempty" validate:"omitempty" openmetrics_metric:"server_input_bitrate"`
	OnlineStreamsValue *int   `json:"online_streams,omitempty" validate:"omitempty" openmetrics_metric:"server_online_streams"`
	OpenedFilesValue   *int   `json:"opened_files,omitempty" validate:"omitempty" openmetrics_metric:"server_opened_files"`
	OutputKbitValue    *Speed `json:"output_kbit,omitempty" validate:"omitempty" openmetrics_metric:"server_output_bitrate"`
	TotalClientsValue  *int   `json:"total_clients,omitempty" validate:"omitempty" openmetrics_metric:"server_total_clients"`
	TotalStreamsValue  *int   `json:"total_streams,omitempty" validate:"omitempty"`
}

type ServerStatsStreamerImpl struct {
	TotalBandwidthValue       *Speed                         `json:"total_bandwidth,omitempty" validate:"omitempty"`
	UptimeValue               *Seconds                       `json:"uptime,omitempty" validate:"omitempty"`
	ConfigExternalStatusValue *ConfigExternalErrorStatusImpl `json:"config_external_status,omitempty" validate:"omitempty"`
	VsaasRunningValue         *bool                          `json:"vsaas_running,omitempty" validate:"omitempty"`
	CpuUsageValue             *Percent                       `json:"cpu_usage,omitempty" validate:"omitempty,min=0,max=100" openmetrics_metric:"server_cpu_usage"`
	HostnameValue             *string                        `json:"hostname,omitempty" validate:"omitempty"`
	IDValue                   *UUID                          `json:"id,omitempty" validate:"omitempty"`
	IsChassisValue            *bool                          `json:"is_chassis,omitempty" validate:"omitempty"`
	LicenseTxtValue           *string                        `json:"license_txt,omitempty" validate:"omitempty"`
	LicenseTypeValue          *LicenseType                   `json:"license_type,omitempty" validate:"omitempty"`
	MemoryUsageValue          *Percent                       `json:"memory_usage,omitempty" validate:"omitempty,min=0,max=100" openmetrics_metric:"server_memory_usage"`
	NextVersionValue          *ServerVersion                 `json:"next_version,omitempty" validate:"omitempty"`
	ConfigErrorValue          *ConfigErrorStatusImpl         `json:"config_error,omitempty" validate:"omitempty"`
	RproxyRunningValue        *bool                          `json:"rproxy_running,omitempty" validate:"omitempty"`
	VsaasBrandingValue        *bool                          `json:"vsaas_branding,omitempty" validate:"omitempty"`
	SchedulerLoadValue        *Percent                       `json:"scheduler_load,omitempty" validate:"omitempty,min=0,max=100" openmetrics_metric:"server_scheduler_load"`
	StreamerStatusValue       *ServerStatsStreamerStatus     `json:"streamer_status,omitempty" validate:"omitempty"`
	TextAlertsValue           map[string]string              `json:"text_alerts,omitempty" validate:"omitempty"`
	BandwidthUsageValue       *Percent                       `json:"bandwidth_usage,omitempty" validate:"omitempty,min=0,max=100"`
	TranscoderValue           *bool                          `json:"transcoder,omitempty" validate:"omitempty"`
	VsaasValue                *bool                          `json:"vsaas,omitempty" validate:"omitempty"`
	RproxyValue               *bool                          `json:"rproxy,omitempty" validate:"omitempty"`
	TranscoderDevicesValue    []*TranscoderDeviceStatsImpl   `json:"transcoder_devices,omitempty" validate:"omitempty"`
	PartitionsValue           []*PartitionStatsImpl          `json:"partitions,omitempty" validate:"omitempty"`
	ConfigVersionValue        []int                          `json:"config_version,omitempty" validate:"omitempty"`
}

type ServerStatsWhoamiImpl struct {
	BuildValue         *int           `json:"build,omitempty" validate:"omitempty" openmetrics_label:"build"`
	NowValue           *UtcMs         `json:"now,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	ServerVersionValue *ServerVersion `json:"server_version,omitempty" validate:"omitempty" openmetrics_label:"version"`
	StartedAtValue     *Utc           `json:"started_at,omitempty" validate:"omitempty,min=1e+09,max=1e+10" openmetrics_metric:"server_started_at"`
}

type SrtConfigImpl struct {
	EnforcedencryptionValue *bool         `json:"enforcedencryption,omitempty" validate:"omitempty"`
	LatencyValue            *Milliseconds `json:"latency,omitempty" validate:"omitempty"`
	LingerValue             *Seconds      `json:"linger,omitempty" validate:"omitempty"`
	MinversionValue         *string       `json:"minversion,omitempty" validate:"omitempty"`
	PassphraseValue         *string       `json:"passphrase,omitempty" validate:"omitempty,min=10,max=79"`
	PortValue               *ListenSpec   `json:"port,omitempty" validate:"omitempty"`
	StreamidValue           *string       `json:"streamid,omitempty" validate:"omitempty,max=512"`
	TimeoutValue            any           `json:"timeout,omitempty" validate:"omitempty"`
	VersionValue            *string       `json:"version,omitempty" validate:"omitempty"`
}

type SrtConfigBaseImpl struct {
	EnforcedencryptionValue *bool         `json:"enforcedencryption,omitempty" validate:"omitempty"`
	LatencyValue            *Milliseconds `json:"latency,omitempty" validate:"omitempty"`
	LingerValue             *Seconds      `json:"linger,omitempty" validate:"omitempty"`
	MinversionValue         *string       `json:"minversion,omitempty" validate:"omitempty"`
	PassphraseValue         *string       `json:"passphrase,omitempty" validate:"omitempty,min=10,max=79"`
	StreamidValue           *string       `json:"streamid,omitempty" validate:"omitempty,max=512"`
	VersionValue            *string       `json:"version,omitempty" validate:"omitempty"`
}

type StreamConfigImpl struct {
	ClientsTimeoutValue                 any                         `json:"clients_timeout,omitempty" validate:"omitempty"`
	PrepushValue                        any                         `json:"prepush,omitempty" validate:"omitempty"`
	SourceTimeoutValue                  any                         `json:"source_timeout,omitempty" validate:"omitempty"`
	PositionValue                       *SortIndex                  `json:"position,omitempty" validate:"omitempty"`
	JpegSnapshotSignKeyValue            *string                     `json:"jpeg_snapshot_sign_key,omitempty" validate:"omitempty"`
	ChunkDurationValue                  *Milliseconds               `json:"chunk_duration,omitempty" validate:"omitempty"`
	CommentValue                        *string                     `json:"comment,omitempty" validate:"omitempty"`
	ConfigOnDiskValue                   *StreamConfigStrippedImpl   `json:"config_on_disk,omitempty" validate:"omitempty"`
	DisabledValue                       *bool                       `json:"disabled,omitempty" validate:"omitempty"`
	DrmValue                            *DrmSpecImpl                `json:"drm,omitempty" validate:"omitempty"`
	DvbocrValue                         *StreamConfigInputDvbocr    `json:"dvbocr,omitempty" validate:"omitempty,oneof=replace add"`
	DvrValue                            *StreamDvrSpecImpl          `json:"dvr,omitempty" validate:"omitempty"`
	EpgEnabledValue                     *bool                       `json:"epg_enabled,omitempty" validate:"omitempty"`
	HlsScte35Value                      *StreamConfigMediaHlsScte35 `json:"hls_scte35,omitempty" validate:"omitempty,oneof=aws scte35 rfc8216"`
	InputMediaInfoValue                 *InputMediaInfoImpl         `json:"input_media_info,omitempty" validate:"omitempty"`
	ProtocolsValue                      *PlayProtocolsSpecImpl      `json:"protocols,omitempty" validate:"omitempty"`
	LabelsValue                         map[string]UnixName         `json:"labels,omitempty" validate:"omitempty,dive,min=1,max=40"`
	MaxRetryTimeoutValue                *Seconds                    `json:"max_retry_timeout,omitempty" validate:"omitempty,min=1"`
	MetaValue                           map[string]string           `json:"meta,omitempty" validate:"omitempty"`
	MpegtsAc3Value                      *OutputMpegtsAc3            `json:"mpegts_ac3,omitempty" validate:"omitempty"`
	MpegtsPidsValue                     *OutputMpegtsPidsImpl       `json:"mpegts_pids,omitempty" validate:"omitempty"`
	NamedByValue                        *NamedBy                    `json:"named_by,omitempty" validate:"omitempty"`
	OnPlayValue                         *AuthSpecImpl               `json:"on_play,omitempty" validate:"omitempty"`
	OnPublishValue                      *AuthSpecImpl               `json:"on_publish,omitempty" validate:"omitempty"`
	AudioTimeoutValue                   *Seconds                    `json:"audio_timeout,omitempty" validate:"omitempty"`
	BackupValue                         *BackupConfigImpl           `json:"backup,omitempty" validate:"omitempty"`
	WebrtcAbrValue                      *WebrtcAbrOptsImpl          `json:"webrtc_abr,omitempty" validate:"omitempty"`
	SegmentDurationValue                *Milliseconds               `json:"segment_duration,omitempty" validate:"omitempty"`
	VisionValue                         *VisionSpecImpl             `json:"vision,omitempty" validate:"omitempty"`
	VideoTimeoutValue                   *Seconds                    `json:"video_timeout,omitempty" validate:"omitempty"`
	URLPrefixValue                      *URLPrefix                  `json:"url_prefix,omitempty" validate:"omitempty"`
	RecheckSecondaryInputsIntervalValue *Seconds                    `json:"recheck_secondary_inputs_interval,omitempty" validate:"omitempty"`
	RetryLimitValue                     *int                        `json:"retry_limit,omitempty" validate:"omitempty"`
	SegmentCountValue                   *int                        `json:"segment_count,omitempty" validate:"omitempty"`
	ProviderValue                       *string                     `json:"provider,omitempty" validate:"omitempty"`
	AddAudioOnlyValue                   *bool                       `json:"add_audio_only,omitempty" validate:"omitempty"`
	Srt2PublishValue                    *SrtConfigImpl              `json:"srt2_publish,omitempty" validate:"omitempty"`
	SrtPortResolveValue                 *bool                       `json:"srt_port_resolve,omitempty" validate:"omitempty"`
	SrtPublishValue                     *SrtConfigImpl              `json:"srt_publish,omitempty" validate:"omitempty"`
	StaticValue                         *bool                       `json:"static,omitempty" validate:"omitempty"`
	StatsValue                          *StreamStatsImpl            `json:"stats,omitempty" validate:"omitempty"`
	TemplateValue                       *MediaName                  `json:"template,omitempty" validate:"omitempty"`
	ThumbnailsValue                     *ThumbnailsSpecImpl         `json:"thumbnails,omitempty" validate:"omitempty"`
	TitleValue                          *string                     `json:"title,omitempty" validate:"omitempty"`
	TranscoderValue                     *TranscoderOptsImpl         `json:"transcoder,omitempty" validate:"omitempty"`
	TransportValue                      *WebrtcTransport            `json:"transport,omitempty" validate:"omitempty"`
	NameValue                           MediaName                   `json:"name" validate:"required" openmetrics_label:"name"`
	PushesValue                         []*StreamPushImpl           `json:"pushes,omitempty" validate:"omitempty"`
	PlaybackHeadersValue                []*PlaybackHeadersImpl      `json:"playback_headers,omitempty" validate:"omitempty"`
	InputsValue                         []*StreamInputImpl          `json:"inputs,omitempty" validate:"omitempty"`
}

type StreamConfigAdditionalImpl struct {
	ConfigOnDiskValue *StreamConfigStrippedImpl `json:"config_on_disk,omitempty" validate:"omitempty"`
	StatsValue        *StreamStatsImpl          `json:"stats,omitempty" validate:"omitempty"`
}

type StreamConfigBaseImpl struct {
	DisabledValue *bool `json:"disabled,omitempty" validate:"omitempty"`
	StaticValue   *bool `json:"static,omitempty" validate:"omitempty"`
}

type StreamConfigDeprecatedImpl struct {
	TransportValue *WebrtcTransport `json:"transport,omitempty" validate:"omitempty"`
}

type StreamConfigInputImpl struct {
	SourceTimeoutValue   any                      `json:"source_timeout,omitempty" validate:"omitempty"`
	AudioTimeoutValue    *Seconds                 `json:"audio_timeout,omitempty" validate:"omitempty"`
	BackupValue          *BackupConfigImpl        `json:"backup,omitempty" validate:"omitempty"`
	DvbocrValue          *StreamConfigInputDvbocr `json:"dvbocr,omitempty" validate:"omitempty,oneof=replace add"`
	EpgEnabledValue      *bool                    `json:"epg_enabled,omitempty" validate:"omitempty"`
	InputMediaInfoValue  *InputMediaInfoImpl      `json:"input_media_info,omitempty" validate:"omitempty"`
	MaxRetryTimeoutValue *Seconds                 `json:"max_retry_timeout,omitempty" validate:"omitempty,min=1"`
	MpegtsAc3Value       *OutputMpegtsAc3         `json:"mpegts_ac3,omitempty" validate:"omitempty"`
	ProviderValue        *string                  `json:"provider,omitempty" validate:"omitempty"`
	VideoTimeoutValue    *Seconds                 `json:"video_timeout,omitempty" validate:"omitempty"`
	InputsValue          []*StreamInputImpl       `json:"inputs,omitempty" validate:"omitempty"`
}

type StreamConfigMediaImpl struct {
	ClientsTimeoutValue      any                         `json:"clients_timeout,omitempty" validate:"omitempty"`
	PrepushValue             any                         `json:"prepush,omitempty" validate:"omitempty"`
	OnPublishValue           *AuthSpecImpl               `json:"on_publish,omitempty" validate:"omitempty"`
	RetryLimitValue          *int                        `json:"retry_limit,omitempty" validate:"omitempty"`
	DvrValue                 *StreamDvrSpecImpl          `json:"dvr,omitempty" validate:"omitempty"`
	HlsScte35Value           *StreamConfigMediaHlsScte35 `json:"hls_scte35,omitempty" validate:"omitempty,oneof=aws scte35 rfc8216"`
	JpegSnapshotSignKeyValue *string                     `json:"jpeg_snapshot_sign_key,omitempty" validate:"omitempty"`
	LabelsValue              map[string]UnixName         `json:"labels,omitempty" validate:"omitempty,dive,min=1,max=40"`
	MpegtsPidsValue          *OutputMpegtsPidsImpl       `json:"mpegts_pids,omitempty" validate:"omitempty"`
	OnPlayValue              *AuthSpecImpl               `json:"on_play,omitempty" validate:"omitempty"`
	AddAudioOnlyValue        *bool                       `json:"add_audio_only,omitempty" validate:"omitempty"`
	WebrtcAbrValue           *WebrtcAbrOptsImpl          `json:"webrtc_abr,omitempty" validate:"omitempty"`
	ChunkDurationValue       *Milliseconds               `json:"chunk_duration,omitempty" validate:"omitempty"`
	ProtocolsValue           *PlayProtocolsSpecImpl      `json:"protocols,omitempty" validate:"omitempty"`
	URLPrefixValue           *URLPrefix                  `json:"url_prefix,omitempty" validate:"omitempty"`
	DrmValue                 *DrmSpecImpl                `json:"drm,omitempty" validate:"omitempty"`
	SegmentCountValue        *int                        `json:"segment_count,omitempty" validate:"omitempty"`
	SegmentDurationValue     *Milliseconds               `json:"segment_duration,omitempty" validate:"omitempty"`
	ThumbnailsValue          *ThumbnailsSpecImpl         `json:"thumbnails,omitempty" validate:"omitempty"`
	TranscoderValue          *TranscoderOptsImpl         `json:"transcoder,omitempty" validate:"omitempty"`
	PushesValue              []*StreamPushImpl           `json:"pushes,omitempty" validate:"omitempty"`
	PlaybackHeadersValue     []*PlaybackHeadersImpl      `json:"playback_headers,omitempty" validate:"omitempty"`
}

type StreamConfigOnpremisesImpl struct {
	MetaValue   map[string]string `json:"meta,omitempty" validate:"omitempty"`
	VisionValue *VisionSpecImpl   `json:"vision,omitempty" validate:"omitempty"`
}

type StreamConfigSingleMediaImpl struct {
	Srt2PublishValue *SrtConfigImpl `json:"srt2_publish,omitempty" validate:"omitempty"`
	SrtPublishValue  *SrtConfigImpl `json:"srt_publish,omitempty" validate:"omitempty"`
}

// Required: name
type StreamConfigSpecificImpl struct {
	CommentValue                        *string    `json:"comment,omitempty" validate:"omitempty"`
	NamedByValue                        *NamedBy   `json:"named_by,omitempty" validate:"omitempty"`
	PositionValue                       *SortIndex `json:"position,omitempty" validate:"omitempty"`
	RecheckSecondaryInputsIntervalValue *Seconds   `json:"recheck_secondary_inputs_interval,omitempty" validate:"omitempty"`
	SrtPortResolveValue                 *bool      `json:"srt_port_resolve,omitempty" validate:"omitempty"`
	TemplateValue                       *MediaName `json:"template,omitempty" validate:"omitempty"`
	TitleValue                          *string    `json:"title,omitempty" validate:"omitempty"`
	NameValue                           MediaName  `json:"name" validate:"required" openmetrics_label:"name"`
}

// This is a reduced configuration of stream that contains only actual used config.
// Can compare it with stream_config that includes some runtime information and
// interpretation of stream config information, like config_on_disk
type StreamConfigStrippedImpl struct {
	ClientsTimeoutValue                 any                         `json:"clients_timeout,omitempty" validate:"omitempty"`
	SourceTimeoutValue                  any                         `json:"source_timeout,omitempty" validate:"omitempty"`
	PrepushValue                        any                         `json:"prepush,omitempty" validate:"omitempty"`
	SrtPortResolveValue                 *bool                       `json:"srt_port_resolve,omitempty" validate:"omitempty"`
	MpegtsAc3Value                      *OutputMpegtsAc3            `json:"mpegts_ac3,omitempty" validate:"omitempty"`
	CommentValue                        *string                     `json:"comment,omitempty" validate:"omitempty"`
	DisabledValue                       *bool                       `json:"disabled,omitempty" validate:"omitempty"`
	DrmValue                            *DrmSpecImpl                `json:"drm,omitempty" validate:"omitempty"`
	DvbocrValue                         *StreamConfigInputDvbocr    `json:"dvbocr,omitempty" validate:"omitempty,oneof=replace add"`
	DvrValue                            *StreamDvrSpecImpl          `json:"dvr,omitempty" validate:"omitempty"`
	EpgEnabledValue                     *bool                       `json:"epg_enabled,omitempty" validate:"omitempty"`
	HlsScte35Value                      *StreamConfigMediaHlsScte35 `json:"hls_scte35,omitempty" validate:"omitempty,oneof=aws scte35 rfc8216"`
	InputMediaInfoValue                 *InputMediaInfoImpl         `json:"input_media_info,omitempty" validate:"omitempty"`
	WebrtcAbrValue                      *WebrtcAbrOptsImpl          `json:"webrtc_abr,omitempty" validate:"omitempty"`
	JpegSnapshotSignKeyValue            *string                     `json:"jpeg_snapshot_sign_key,omitempty" validate:"omitempty"`
	LabelsValue                         map[string]UnixName         `json:"labels,omitempty" validate:"omitempty,dive,min=1,max=40"`
	ProtocolsValue                      *PlayProtocolsSpecImpl      `json:"protocols,omitempty" validate:"omitempty"`
	MetaValue                           map[string]string           `json:"meta,omitempty" validate:"omitempty"`
	BackupValue                         *BackupConfigImpl           `json:"backup,omitempty" validate:"omitempty"`
	MpegtsPidsValue                     *OutputMpegtsPidsImpl       `json:"mpegts_pids,omitempty" validate:"omitempty"`
	VisionValue                         *VisionSpecImpl             `json:"vision,omitempty" validate:"omitempty"`
	NamedByValue                        *NamedBy                    `json:"named_by,omitempty" validate:"omitempty"`
	OnPlayValue                         *AuthSpecImpl               `json:"on_play,omitempty" validate:"omitempty"`
	OnPublishValue                      *AuthSpecImpl               `json:"on_publish,omitempty" validate:"omitempty"`
	VideoTimeoutValue                   *Seconds                    `json:"video_timeout,omitempty" validate:"omitempty"`
	ChunkDurationValue                  *Milliseconds               `json:"chunk_duration,omitempty" validate:"omitempty"`
	PositionValue                       *SortIndex                  `json:"position,omitempty" validate:"omitempty"`
	MaxRetryTimeoutValue                *Seconds                    `json:"max_retry_timeout,omitempty" validate:"omitempty,min=1"`
	ProviderValue                       *string                     `json:"provider,omitempty" validate:"omitempty"`
	URLPrefixValue                      *URLPrefix                  `json:"url_prefix,omitempty" validate:"omitempty"`
	RecheckSecondaryInputsIntervalValue *Seconds                    `json:"recheck_secondary_inputs_interval,omitempty" validate:"omitempty"`
	RetryLimitValue                     *int                        `json:"retry_limit,omitempty" validate:"omitempty"`
	SegmentCountValue                   *int                        `json:"segment_count,omitempty" validate:"omitempty"`
	SegmentDurationValue                *Milliseconds               `json:"segment_duration,omitempty" validate:"omitempty"`
	AudioTimeoutValue                   *Seconds                    `json:"audio_timeout,omitempty" validate:"omitempty"`
	Srt2PublishValue                    *SrtConfigImpl              `json:"srt2_publish,omitempty" validate:"omitempty"`
	AddAudioOnlyValue                   *bool                       `json:"add_audio_only,omitempty" validate:"omitempty"`
	SrtPublishValue                     *SrtConfigImpl              `json:"srt_publish,omitempty" validate:"omitempty"`
	StaticValue                         *bool                       `json:"static,omitempty" validate:"omitempty"`
	TemplateValue                       *MediaName                  `json:"template,omitempty" validate:"omitempty"`
	ThumbnailsValue                     *ThumbnailsSpecImpl         `json:"thumbnails,omitempty" validate:"omitempty"`
	TitleValue                          *string                     `json:"title,omitempty" validate:"omitempty"`
	TranscoderValue                     *TranscoderOptsImpl         `json:"transcoder,omitempty" validate:"omitempty"`
	TransportValue                      *WebrtcTransport            `json:"transport,omitempty" validate:"omitempty"`
	NameValue                           MediaName                   `json:"name" validate:"required" openmetrics_label:"name"`
	PushesValue                         []*StreamPushImpl           `json:"pushes,omitempty" validate:"omitempty"`
	PlaybackHeadersValue                []*PlaybackHeadersImpl      `json:"playback_headers,omitempty" validate:"omitempty"`
	InputsValue                         []*StreamInputImpl          `json:"inputs,omitempty" validate:"omitempty"`
}

type StreamDvrSpecImpl struct {
	DiskUsageLimitValue     *Percent `json:"disk_usage_limit,omitempty" validate:"omitempty,min=0,max=100"`
	EpisodesExpirationValue *Seconds `json:"episodes_expiration,omitempty" validate:"omitempty"`
	EpisodesURLValue        *string  `json:"episodes_url,omitempty" validate:"omitempty"`
	ExpirationValue         *Seconds `json:"expiration,omitempty" validate:"omitempty"`
	RedundancyFactorValue   *int     `json:"redundancy_factor,omitempty" validate:"omitempty,min=0"`
	ReferenceValue          *DvrName `json:"reference,omitempty" validate:"omitempty"`
	StorageLimitValue       *Bytes   `json:"storage_limit,omitempty" validate:"omitempty"`
	RemotesValue            []DvrURL `json:"remotes,omitempty" validate:"omitempty"`
	ScheduleValue           [][]int  `json:"schedule,omitempty" validate:"omitempty"`
}

type StreamDvrSpecificSpecImpl struct {
	RedundancyFactorValue *int     `json:"redundancy_factor,omitempty" validate:"omitempty,min=0"`
	ReferenceValue        *DvrName `json:"reference,omitempty" validate:"omitempty"`
	RemotesValue          []DvrURL `json:"remotes,omitempty" validate:"omitempty"`
}

type StreamInputImpl struct {
	PixelValue                   any                            `json:"pixel,omitempty" validate:"omitempty,oneof=rgb8 rgb10 rgb12 yuv8 yuv10 8 10"`
	VinputValue                  any                            `json:"vinput,omitempty" validate:"omitempty"`
	SubtitlesValue               any                            `json:"subtitles,omitempty" validate:"omitempty,oneof=drop accept ocr_replace ocr_add"`
	SourceTimeoutValue           any                            `json:"source_timeout,omitempty" validate:"omitempty"`
	AinputValue                  any                            `json:"ainput,omitempty" validate:"omitempty"`
	PriorityValue                *int                           `json:"priority,omitempty" validate:"omitempty"`
	VbiDebugValue                *bool                          `json:"vbi_debug,omitempty" validate:"omitempty"`
	BindToCoreValue              *int                           `json:"bind_to_core,omitempty" validate:"omitempty"`
	BitrateValue                 *Speed                         `json:"bitrate,omitempty" validate:"omitempty"`
	ClosedCaptionsValue          map[string]string              `json:"closed_captions,omitempty" validate:"omitempty"`
	CommentValue                 *string                        `json:"comment,omitempty" validate:"omitempty"`
	ConnectionsValue             *int                           `json:"connections,omitempty" validate:"omitempty"`
	DenyIfValue                  *string                        `json:"deny_if,omitempty" validate:"omitempty"`
	EnforcedencryptionValue      *bool                          `json:"enforcedencryption,omitempty" validate:"omitempty"`
	FramesTimeoutValue           *int                           `json:"frames_timeout,omitempty" validate:"omitempty"`
	HeadersValue                 map[string]string              `json:"headers,omitempty" validate:"omitempty"`
	HeightValue                  *int                           `json:"height,omitempty" validate:"omitempty"`
	IDValue                      *string                        `json:"id,omitempty" validate:"omitempty"`
	LanguagesValue               map[string]string              `json:"languages,omitempty" validate:"omitempty"`
	LatencyValue                 *Milliseconds                  `json:"latency,omitempty" validate:"omitempty"`
	LingerValue                  *Seconds                       `json:"linger,omitempty" validate:"omitempty"`
	MaxRetryTimeoutValue         *Seconds                       `json:"max_retry_timeout,omitempty" validate:"omitempty,min=1"`
	MinversionValue              *string                        `json:"minversion,omitempty" validate:"omitempty"`
	MixerStrategyValue           *StreamInputMixerMixerStrategy `json:"mixer_strategy,omitempty" validate:"omitempty,oneof=all first_video_audio"`
	ModeValue                    *string                        `json:"mode,omitempty" validate:"omitempty"`
	NoClientsReconnectDelayValue *int                           `json:"no_clients_reconnect_delay,omitempty" validate:"omitempty"`
	OutputAudioValue             *OutputAudio                   `json:"output_audio,omitempty" validate:"omitempty"`
	PageurlValue                 *URL                           `json:"pageUrl,omitempty" validate:"omitempty"`
	PassphraseValue              *string                        `json:"passphrase,omitempty" validate:"omitempty,min=10,max=79"`
	WidthValue                   *int                           `json:"width,omitempty" validate:"omitempty"`
	AudioDeviceValue             *string                        `json:"audio_device,omitempty" validate:"omitempty"`
	AudioTimeoutValue            *Seconds                       `json:"audio_timeout,omitempty" validate:"omitempty"`
	AudioBitrateValue            *Speed                         `json:"audio_bitrate,omitempty" validate:"omitempty"`
	VersionValue                 *string                        `json:"version,omitempty" validate:"omitempty"`
	SarValue                     *string                        `json:"sar,omitempty" validate:"omitempty"`
	Scte35Value                  *bool                          `json:"scte35,omitempty" validate:"omitempty"`
	ShmemSizeValue               *int                           `json:"shmem_size,omitempty" validate:"omitempty"`
	SkipStalledCheckValue        *bool                          `json:"skip_stalled_check,omitempty" validate:"omitempty"`
	SocketDirValue               *string                        `json:"socket_dir,omitempty" validate:"omitempty"`
	AudioAddValue                *Milliseconds                  `json:"audio_add,omitempty" validate:"omitempty"`
	StatsValue                   *InputStatsImpl                `json:"stats,omitempty" validate:"omitempty"`
	StreamidValue                *string                        `json:"streamid,omitempty" validate:"omitempty,max=512"`
	AptsValue                    *StreamInputDecklinkApts       `json:"apts,omitempty" validate:"omitempty,oneof=video ref 1 3"`
	SwfurlValue                  *string                        `json:"swfUrl,omitempty" validate:"omitempty"`
	SyncValue                    *string                        `json:"sync,omitempty" validate:"omitempty"`
	TcurlValue                   *URL                           `json:"tcUrl,omitempty" validate:"omitempty"`
	TimeoutValue                 *int                           `json:"timeout,omitempty" validate:"omitempty"`
	VptsValue                    *StreamInputDecklinkVpts       `json:"vpts,omitempty" validate:"omitempty,oneof=audio ref 2 3"`
	AllowIfValue                 *string                        `json:"allow_if,omitempty" validate:"omitempty"`
	UserAgentValue               *string                        `json:"user_agent,omitempty" validate:"omitempty"`
	VideoTimeoutValue            *Seconds                       `json:"video_timeout,omitempty" validate:"omitempty"`
	VbiDeviceValue               *string                        `json:"vbi_device,omitempty" validate:"omitempty"`
	VbiThresholdValue            *int                           `json:"vbi_threshold,omitempty" validate:"omitempty"`
	PtsSourceValue               *StreamInputDektecPtsSource    `json:"pts_source,omitempty" validate:"omitempty,oneof=aligned sdi tod us"`
	ViaValue                     *AgentURL                      `json:"via,omitempty" validate:"omitempty"`
	VideoBitrateValue            *Speed                         `json:"video_bitrate,omitempty" validate:"omitempty"`
	VideoDeviceValue             *string                        `json:"video_device,omitempty" validate:"omitempty"`
	URLValue                     InputURL                       `json:"url" validate:"required"`
	ProgramsValue                []int                          `json:"programs,omitempty" validate:"omitempty"`
	TtxtDescriptorsValue         []*TtxtDescriptorsImpl         `json:"ttxt_descriptors,omitempty" validate:"omitempty"`
	PidsValue                    []int                          `json:"pids,omitempty" validate:"omitempty"`
}

type StreamInputBaseImpl struct {
	AllowIfValue                 *string           `json:"allow_if,omitempty" validate:"omitempty"`
	AudioTimeoutValue            *Seconds          `json:"audio_timeout,omitempty" validate:"omitempty"`
	CommentValue                 *string           `json:"comment,omitempty" validate:"omitempty"`
	DenyIfValue                  *string           `json:"deny_if,omitempty" validate:"omitempty"`
	FramesTimeoutValue           *int              `json:"frames_timeout,omitempty" validate:"omitempty"`
	HeadersValue                 map[string]string `json:"headers,omitempty" validate:"omitempty"`
	MaxRetryTimeoutValue         *Seconds          `json:"max_retry_timeout,omitempty" validate:"omitempty,min=1"`
	NoClientsReconnectDelayValue *int              `json:"no_clients_reconnect_delay,omitempty" validate:"omitempty"`
	OutputAudioValue             *OutputAudio      `json:"output_audio,omitempty" validate:"omitempty"`
	PriorityValue                *int              `json:"priority,omitempty" validate:"omitempty"`
	SourceTimeoutValue           any               `json:"source_timeout,omitempty" validate:"omitempty"`
	StatsValue                   *InputStatsImpl   `json:"stats,omitempty" validate:"omitempty"`
	TimeoutValue                 *int              `json:"timeout,omitempty" validate:"omitempty"`
	UserAgentValue               *string           `json:"user_agent,omitempty" validate:"omitempty"`
	ViaValue                     *AgentURL         `json:"via,omitempty" validate:"omitempty"`
	VideoTimeoutValue            *Seconds          `json:"video_timeout,omitempty" validate:"omitempty"`
}

type StreamInputCopyImpl struct {
	SourceTimeoutValue           any               `json:"source_timeout,omitempty" validate:"omitempty"`
	NoClientsReconnectDelayValue *int              `json:"no_clients_reconnect_delay,omitempty" validate:"omitempty"`
	PriorityValue                *int              `json:"priority,omitempty" validate:"omitempty"`
	CommentValue                 *string           `json:"comment,omitempty" validate:"omitempty"`
	DenyIfValue                  *string           `json:"deny_if,omitempty" validate:"omitempty"`
	FramesTimeoutValue           *int              `json:"frames_timeout,omitempty" validate:"omitempty"`
	HeadersValue                 map[string]string `json:"headers,omitempty" validate:"omitempty"`
	MaxRetryTimeoutValue         *Seconds          `json:"max_retry_timeout,omitempty" validate:"omitempty,min=1"`
	AllowIfValue                 *string           `json:"allow_if,omitempty" validate:"omitempty"`
	ClosedCaptionsValue          map[string]string `json:"closed_captions,omitempty" validate:"omitempty"`
	AudioTimeoutValue            *Seconds          `json:"audio_timeout,omitempty" validate:"omitempty"`
	OutputAudioValue             *OutputAudio      `json:"output_audio,omitempty" validate:"omitempty"`
	StatsValue                   *InputStatsImpl   `json:"stats,omitempty" validate:"omitempty"`
	TimeoutValue                 *int              `json:"timeout,omitempty" validate:"omitempty"`
	VideoTimeoutValue            *Seconds          `json:"video_timeout,omitempty" validate:"omitempty"`
	UserAgentValue               *string           `json:"user_agent,omitempty" validate:"omitempty"`
	ViaValue                     *AgentURL         `json:"via,omitempty" validate:"omitempty"`
	URLValue                     InputURL          `json:"url" validate:"required"`
}

type StreamInputDecklinkImpl struct {
	AinputValue                  any                       `json:"ainput,omitempty" validate:"omitempty"`
	VinputValue                  any                       `json:"vinput,omitempty" validate:"omitempty"`
	SourceTimeoutValue           any                       `json:"source_timeout,omitempty" validate:"omitempty"`
	PixelValue                   *StreamInputDecklinkPixel `json:"pixel,omitempty" validate:"omitempty,oneof=rgb8 rgb10 rgb12 yuv8 yuv10 8 10"`
	SarValue                     *string                   `json:"sar,omitempty" validate:"omitempty"`
	DenyIfValue                  *string                   `json:"deny_if,omitempty" validate:"omitempty"`
	FramesTimeoutValue           *int                      `json:"frames_timeout,omitempty" validate:"omitempty"`
	HeadersValue                 map[string]string         `json:"headers,omitempty" validate:"omitempty"`
	MaxRetryTimeoutValue         *Seconds                  `json:"max_retry_timeout,omitempty" validate:"omitempty,min=1"`
	ModeValue                    *string                   `json:"mode,omitempty" validate:"omitempty"`
	NoClientsReconnectDelayValue *int                      `json:"no_clients_reconnect_delay,omitempty" validate:"omitempty"`
	OutputAudioValue             *OutputAudio              `json:"output_audio,omitempty" validate:"omitempty"`
	AudioTimeoutValue            *Seconds                  `json:"audio_timeout,omitempty" validate:"omitempty"`
	PriorityValue                *int                      `json:"priority,omitempty" validate:"omitempty"`
	CommentValue                 *string                   `json:"comment,omitempty" validate:"omitempty"`
	AptsValue                    *StreamInputDecklinkApts  `json:"apts,omitempty" validate:"omitempty,oneof=video ref 1 3"`
	StatsValue                   *InputStatsImpl           `json:"stats,omitempty" validate:"omitempty"`
	TimeoutValue                 *int                      `json:"timeout,omitempty" validate:"omitempty"`
	VptsValue                    *StreamInputDecklinkVpts  `json:"vpts,omitempty" validate:"omitempty,oneof=audio ref 2 3"`
	AllowIfValue                 *string                   `json:"allow_if,omitempty" validate:"omitempty"`
	UserAgentValue               *string                   `json:"user_agent,omitempty" validate:"omitempty"`
	VbiDebugValue                *bool                     `json:"vbi_debug,omitempty" validate:"omitempty"`
	VbiThresholdValue            *int                      `json:"vbi_threshold,omitempty" validate:"omitempty"`
	ViaValue                     *AgentURL                 `json:"via,omitempty" validate:"omitempty"`
	VideoTimeoutValue            *Seconds                  `json:"video_timeout,omitempty" validate:"omitempty"`
	URLValue                     InputURL                  `json:"url" validate:"required"`
	TtxtDescriptorsValue         []*TtxtDescriptorsImpl    `json:"ttxt_descriptors,omitempty" validate:"omitempty"`
}

type StreamInputDektecImpl struct {
	SourceTimeoutValue           any                         `json:"source_timeout,omitempty" validate:"omitempty"`
	PriorityValue                *int                        `json:"priority,omitempty" validate:"omitempty"`
	SarValue                     *string                     `json:"sar,omitempty" validate:"omitempty"`
	DenyIfValue                  *string                     `json:"deny_if,omitempty" validate:"omitempty"`
	FramesTimeoutValue           *int                        `json:"frames_timeout,omitempty" validate:"omitempty"`
	HeadersValue                 map[string]string           `json:"headers,omitempty" validate:"omitempty"`
	MaxRetryTimeoutValue         *Seconds                    `json:"max_retry_timeout,omitempty" validate:"omitempty,min=1"`
	NoClientsReconnectDelayValue *int                        `json:"no_clients_reconnect_delay,omitempty" validate:"omitempty"`
	OutputAudioValue             *OutputAudio                `json:"output_audio,omitempty" validate:"omitempty"`
	PixelValue                   *StreamInputDektecPixel     `json:"pixel,omitempty" validate:"omitempty,oneof=rgb8 rgb10 rgb12 yuv8 yuv10 8 10"`
	Scte35Value                  *bool                       `json:"scte35,omitempty" validate:"omitempty"`
	CommentValue                 *string                     `json:"comment,omitempty" validate:"omitempty"`
	PtsSourceValue               *StreamInputDektecPtsSource `json:"pts_source,omitempty" validate:"omitempty,oneof=aligned sdi tod us"`
	AllowIfValue                 *string                     `json:"allow_if,omitempty" validate:"omitempty"`
	AudioTimeoutValue            *Seconds                    `json:"audio_timeout,omitempty" validate:"omitempty"`
	StatsValue                   *InputStatsImpl             `json:"stats,omitempty" validate:"omitempty"`
	TimeoutValue                 *int                        `json:"timeout,omitempty" validate:"omitempty"`
	VideoTimeoutValue            *Seconds                    `json:"video_timeout,omitempty" validate:"omitempty"`
	ViaValue                     *AgentURL                   `json:"via,omitempty" validate:"omitempty"`
	UserAgentValue               *string                     `json:"user_agent,omitempty" validate:"omitempty"`
	VbiDebugValue                *bool                       `json:"vbi_debug,omitempty" validate:"omitempty"`
	URLValue                     InputURL                    `json:"url" validate:"required"`
	TtxtDescriptorsValue         []*TtxtDescriptorsImpl      `json:"ttxt_descriptors,omitempty" validate:"omitempty"`
}

type StreamInputFakeImpl struct {
	SourceTimeoutValue           any               `json:"source_timeout,omitempty" validate:"omitempty"`
	OutputAudioValue             *OutputAudio      `json:"output_audio,omitempty" validate:"omitempty"`
	PriorityValue                *int              `json:"priority,omitempty" validate:"omitempty"`
	CommentValue                 *string           `json:"comment,omitempty" validate:"omitempty"`
	AllowIfValue                 *string           `json:"allow_if,omitempty" validate:"omitempty"`
	FramesTimeoutValue           *int              `json:"frames_timeout,omitempty" validate:"omitempty"`
	HeadersValue                 map[string]string `json:"headers,omitempty" validate:"omitempty"`
	HeightValue                  *int              `json:"height,omitempty" validate:"omitempty"`
	MaxRetryTimeoutValue         *Seconds          `json:"max_retry_timeout,omitempty" validate:"omitempty,min=1"`
	BitrateValue                 *Speed            `json:"bitrate,omitempty" validate:"omitempty"`
	NoClientsReconnectDelayValue *int              `json:"no_clients_reconnect_delay,omitempty" validate:"omitempty"`
	DenyIfValue                  *string           `json:"deny_if,omitempty" validate:"omitempty"`
	AudioTimeoutValue            *Seconds          `json:"audio_timeout,omitempty" validate:"omitempty"`
	StatsValue                   *InputStatsImpl   `json:"stats,omitempty" validate:"omitempty"`
	TimeoutValue                 *int              `json:"timeout,omitempty" validate:"omitempty"`
	WidthValue                   *int              `json:"width,omitempty" validate:"omitempty"`
	UserAgentValue               *string           `json:"user_agent,omitempty" validate:"omitempty"`
	ViaValue                     *AgentURL         `json:"via,omitempty" validate:"omitempty"`
	VideoTimeoutValue            *Seconds          `json:"video_timeout,omitempty" validate:"omitempty"`
	URLValue                     InputURL          `json:"url" validate:"required"`
}

type StreamInputFileImpl struct {
	SourceTimeoutValue           any                                 `json:"source_timeout,omitempty" validate:"omitempty"`
	FramesTimeoutValue           *int                                `json:"frames_timeout,omitempty" validate:"omitempty"`
	PriorityValue                *int                                `json:"priority,omitempty" validate:"omitempty"`
	CommentValue                 *string                             `json:"comment,omitempty" validate:"omitempty"`
	DenyIfValue                  *string                             `json:"deny_if,omitempty" validate:"omitempty"`
	AllowIfValue                 *string                             `json:"allow_if,omitempty" validate:"omitempty"`
	HeadersValue                 map[string]string                   `json:"headers,omitempty" validate:"omitempty"`
	LanguagesValue               map[string]string                   `json:"languages,omitempty" validate:"omitempty"`
	MaxRetryTimeoutValue         *Seconds                            `json:"max_retry_timeout,omitempty" validate:"omitempty,min=1"`
	NoClientsReconnectDelayValue *int                                `json:"no_clients_reconnect_delay,omitempty" validate:"omitempty"`
	VideoTimeoutValue            *Seconds                            `json:"video_timeout,omitempty" validate:"omitempty"`
	ClosedCaptionsValue          map[string]string                   `json:"closed_captions,omitempty" validate:"omitempty"`
	ViaValue                     *AgentURL                           `json:"via,omitempty" validate:"omitempty"`
	OutputAudioValue             *OutputAudio                        `json:"output_audio,omitempty" validate:"omitempty"`
	Scte35Value                  *bool                               `json:"scte35,omitempty" validate:"omitempty"`
	AudioTimeoutValue            *Seconds                            `json:"audio_timeout,omitempty" validate:"omitempty"`
	StatsValue                   *InputStatsImpl                     `json:"stats,omitempty" validate:"omitempty"`
	SubtitlesValue               *StreamInputMpegtsSpecificSubtitles `json:"subtitles,omitempty" validate:"omitempty,oneof=drop accept ocr_replace ocr_add"`
	TimeoutValue                 *int                                `json:"timeout,omitempty" validate:"omitempty"`
	UserAgentValue               *string                             `json:"user_agent,omitempty" validate:"omitempty"`
	URLValue                     InputURL                            `json:"url" validate:"required"`
	PidsValue                    []int                               `json:"pids,omitempty" validate:"omitempty"`
	ProgramsValue                []int                               `json:"programs,omitempty" validate:"omitempty"`
}

type StreamInputFripImpl struct {
	SourceTimeoutValue           any               `json:"source_timeout,omitempty" validate:"omitempty"`
	FramesTimeoutValue           *int              `json:"frames_timeout,omitempty" validate:"omitempty"`
	SocketDirValue               *string           `json:"socket_dir,omitempty" validate:"omitempty"`
	DenyIfValue                  *string           `json:"deny_if,omitempty" validate:"omitempty"`
	AllowIfValue                 *string           `json:"allow_if,omitempty" validate:"omitempty"`
	HeadersValue                 map[string]string `json:"headers,omitempty" validate:"omitempty"`
	MaxRetryTimeoutValue         *Seconds          `json:"max_retry_timeout,omitempty" validate:"omitempty,min=1"`
	NoClientsReconnectDelayValue *int              `json:"no_clients_reconnect_delay,omitempty" validate:"omitempty"`
	OutputAudioValue             *OutputAudio      `json:"output_audio,omitempty" validate:"omitempty"`
	CommentValue                 *string           `json:"comment,omitempty" validate:"omitempty"`
	PriorityValue                *int              `json:"priority,omitempty" validate:"omitempty"`
	ShmemSizeValue               *int              `json:"shmem_size,omitempty" validate:"omitempty"`
	AudioTimeoutValue            *Seconds          `json:"audio_timeout,omitempty" validate:"omitempty"`
	StatsValue                   *InputStatsImpl   `json:"stats,omitempty" validate:"omitempty"`
	TimeoutValue                 *int              `json:"timeout,omitempty" validate:"omitempty"`
	VideoTimeoutValue            *Seconds          `json:"video_timeout,omitempty" validate:"omitempty"`
	UserAgentValue               *string           `json:"user_agent,omitempty" validate:"omitempty"`
	ViaValue                     *AgentURL         `json:"via,omitempty" validate:"omitempty"`
	URLValue                     InputURL          `json:"url" validate:"required"`
}

type StreamInputH323Impl struct {
	SourceTimeoutValue           any               `json:"source_timeout,omitempty" validate:"omitempty"`
	NoClientsReconnectDelayValue *int              `json:"no_clients_reconnect_delay,omitempty" validate:"omitempty"`
	AudioTimeoutValue            *Seconds          `json:"audio_timeout,omitempty" validate:"omitempty"`
	CommentValue                 *string           `json:"comment,omitempty" validate:"omitempty"`
	ConnectionsValue             *int              `json:"connections,omitempty" validate:"omitempty"`
	DenyIfValue                  *string           `json:"deny_if,omitempty" validate:"omitempty"`
	FramesTimeoutValue           *int              `json:"frames_timeout,omitempty" validate:"omitempty"`
	HeadersValue                 map[string]string `json:"headers,omitempty" validate:"omitempty"`
	IDValue                      *string           `json:"id,omitempty" validate:"omitempty"`
	AllowIfValue                 *string           `json:"allow_if,omitempty" validate:"omitempty"`
	MaxRetryTimeoutValue         *Seconds          `json:"max_retry_timeout,omitempty" validate:"omitempty,min=1"`
	AudioBitrateValue            *Speed            `json:"audio_bitrate,omitempty" validate:"omitempty"`
	PriorityValue                *int              `json:"priority,omitempty" validate:"omitempty"`
	OutputAudioValue             *OutputAudio      `json:"output_audio,omitempty" validate:"omitempty"`
	StatsValue                   *InputStatsImpl   `json:"stats,omitempty" validate:"omitempty"`
	TimeoutValue                 *int              `json:"timeout,omitempty" validate:"omitempty"`
	VideoTimeoutValue            *Seconds          `json:"video_timeout,omitempty" validate:"omitempty"`
	UserAgentValue               *string           `json:"user_agent,omitempty" validate:"omitempty"`
	ViaValue                     *AgentURL         `json:"via,omitempty" validate:"omitempty"`
	VideoBitrateValue            *Speed            `json:"video_bitrate,omitempty" validate:"omitempty"`
	URLValue                     InputURL          `json:"url" validate:"required"`
}

type StreamInputHlsImpl struct {
	SourceTimeoutValue           any                                 `json:"source_timeout,omitempty" validate:"omitempty"`
	PriorityValue                *int                                `json:"priority,omitempty" validate:"omitempty"`
	NoClientsReconnectDelayValue *int                                `json:"no_clients_reconnect_delay,omitempty" validate:"omitempty"`
	CommentValue                 *string                             `json:"comment,omitempty" validate:"omitempty"`
	DenyIfValue                  *string                             `json:"deny_if,omitempty" validate:"omitempty"`
	FramesTimeoutValue           *int                                `json:"frames_timeout,omitempty" validate:"omitempty"`
	HeadersValue                 map[string]string                   `json:"headers,omitempty" validate:"omitempty"`
	LanguagesValue               map[string]string                   `json:"languages,omitempty" validate:"omitempty"`
	VideoTimeoutValue            *Seconds                            `json:"video_timeout,omitempty" validate:"omitempty"`
	AllowIfValue                 *string                             `json:"allow_if,omitempty" validate:"omitempty"`
	OutputAudioValue             *OutputAudio                        `json:"output_audio,omitempty" validate:"omitempty"`
	ClosedCaptionsValue          map[string]string                   `json:"closed_captions,omitempty" validate:"omitempty"`
	ViaValue                     *AgentURL                           `json:"via,omitempty" validate:"omitempty"`
	MaxRetryTimeoutValue         *Seconds                            `json:"max_retry_timeout,omitempty" validate:"omitempty,min=1"`
	Scte35Value                  *bool                               `json:"scte35,omitempty" validate:"omitempty"`
	SkipStalledCheckValue        *bool                               `json:"skip_stalled_check,omitempty" validate:"omitempty"`
	AudioTimeoutValue            *Seconds                            `json:"audio_timeout,omitempty" validate:"omitempty"`
	StatsValue                   *InputStatsImpl                     `json:"stats,omitempty" validate:"omitempty"`
	SubtitlesValue               *StreamInputMpegtsSpecificSubtitles `json:"subtitles,omitempty" validate:"omitempty,oneof=drop accept ocr_replace ocr_add"`
	TimeoutValue                 *int                                `json:"timeout,omitempty" validate:"omitempty"`
	UserAgentValue               *string                             `json:"user_agent,omitempty" validate:"omitempty"`
	URLValue                     InputURL                            `json:"url" validate:"required"`
	PidsValue                    []int                               `json:"pids,omitempty" validate:"omitempty"`
	ProgramsValue                []int                               `json:"programs,omitempty" validate:"omitempty"`
}

type StreamInputM4fImpl struct {
	SourceTimeoutValue           any               `json:"source_timeout,omitempty" validate:"omitempty"`
	NoClientsReconnectDelayValue *int              `json:"no_clients_reconnect_delay,omitempty" validate:"omitempty"`
	PriorityValue                *int              `json:"priority,omitempty" validate:"omitempty"`
	CommentValue                 *string           `json:"comment,omitempty" validate:"omitempty"`
	DenyIfValue                  *string           `json:"deny_if,omitempty" validate:"omitempty"`
	FramesTimeoutValue           *int              `json:"frames_timeout,omitempty" validate:"omitempty"`
	HeadersValue                 map[string]string `json:"headers,omitempty" validate:"omitempty"`
	MaxRetryTimeoutValue         *Seconds          `json:"max_retry_timeout,omitempty" validate:"omitempty,min=1"`
	AllowIfValue                 *string           `json:"allow_if,omitempty" validate:"omitempty"`
	ClosedCaptionsValue          map[string]string `json:"closed_captions,omitempty" validate:"omitempty"`
	AudioTimeoutValue            *Seconds          `json:"audio_timeout,omitempty" validate:"omitempty"`
	OutputAudioValue             *OutputAudio      `json:"output_audio,omitempty" validate:"omitempty"`
	StatsValue                   *InputStatsImpl   `json:"stats,omitempty" validate:"omitempty"`
	TimeoutValue                 *int              `json:"timeout,omitempty" validate:"omitempty"`
	VideoTimeoutValue            *Seconds          `json:"video_timeout,omitempty" validate:"omitempty"`
	UserAgentValue               *string           `json:"user_agent,omitempty" validate:"omitempty"`
	ViaValue                     *AgentURL         `json:"via,omitempty" validate:"omitempty"`
	URLValue                     InputURL          `json:"url" validate:"required"`
}

type StreamInputM4sImpl struct {
	SourceTimeoutValue           any               `json:"source_timeout,omitempty" validate:"omitempty"`
	NoClientsReconnectDelayValue *int              `json:"no_clients_reconnect_delay,omitempty" validate:"omitempty"`
	PriorityValue                *int              `json:"priority,omitempty" validate:"omitempty"`
	CommentValue                 *string           `json:"comment,omitempty" validate:"omitempty"`
	DenyIfValue                  *string           `json:"deny_if,omitempty" validate:"omitempty"`
	FramesTimeoutValue           *int              `json:"frames_timeout,omitempty" validate:"omitempty"`
	HeadersValue                 map[string]string `json:"headers,omitempty" validate:"omitempty"`
	MaxRetryTimeoutValue         *Seconds          `json:"max_retry_timeout,omitempty" validate:"omitempty,min=1"`
	AllowIfValue                 *string           `json:"allow_if,omitempty" validate:"omitempty"`
	ClosedCaptionsValue          map[string]string `json:"closed_captions,omitempty" validate:"omitempty"`
	AudioTimeoutValue            *Seconds          `json:"audio_timeout,omitempty" validate:"omitempty"`
	OutputAudioValue             *OutputAudio      `json:"output_audio,omitempty" validate:"omitempty"`
	StatsValue                   *InputStatsImpl   `json:"stats,omitempty" validate:"omitempty"`
	TimeoutValue                 *int              `json:"timeout,omitempty" validate:"omitempty"`
	VideoTimeoutValue            *Seconds          `json:"video_timeout,omitempty" validate:"omitempty"`
	UserAgentValue               *string           `json:"user_agent,omitempty" validate:"omitempty"`
	ViaValue                     *AgentURL         `json:"via,omitempty" validate:"omitempty"`
	URLValue                     InputURL          `json:"url" validate:"required"`
}

type StreamInputMixerImpl struct {
	SourceTimeoutValue           any                            `json:"source_timeout,omitempty" validate:"omitempty"`
	OutputAudioValue             *OutputAudio                   `json:"output_audio,omitempty" validate:"omitempty"`
	PriorityValue                *int                           `json:"priority,omitempty" validate:"omitempty"`
	CommentValue                 *string                        `json:"comment,omitempty" validate:"omitempty"`
	AllowIfValue                 *string                        `json:"allow_if,omitempty" validate:"omitempty"`
	FramesTimeoutValue           *int                           `json:"frames_timeout,omitempty" validate:"omitempty"`
	HeadersValue                 map[string]string              `json:"headers,omitempty" validate:"omitempty"`
	MaxRetryTimeoutValue         *Seconds                       `json:"max_retry_timeout,omitempty" validate:"omitempty,min=1"`
	MixerStrategyValue           *StreamInputMixerMixerStrategy `json:"mixer_strategy,omitempty" validate:"omitempty,oneof=all first_video_audio"`
	AudioTimeoutValue            *Seconds                       `json:"audio_timeout,omitempty" validate:"omitempty"`
	NoClientsReconnectDelayValue *int                           `json:"no_clients_reconnect_delay,omitempty" validate:"omitempty"`
	DenyIfValue                  *string                        `json:"deny_if,omitempty" validate:"omitempty"`
	AudioAddValue                *Milliseconds                  `json:"audio_add,omitempty" validate:"omitempty"`
	StatsValue                   *InputStatsImpl                `json:"stats,omitempty" validate:"omitempty"`
	SyncValue                    *string                        `json:"sync,omitempty" validate:"omitempty"`
	TimeoutValue                 *int                           `json:"timeout,omitempty" validate:"omitempty"`
	VideoTimeoutValue            *Seconds                       `json:"video_timeout,omitempty" validate:"omitempty"`
	UserAgentValue               *string                        `json:"user_agent,omitempty" validate:"omitempty"`
	ViaValue                     *AgentURL                      `json:"via,omitempty" validate:"omitempty"`
	URLValue                     InputURL                       `json:"url" validate:"required"`
}

type StreamInputMosaicImpl struct {
	SourceTimeoutValue           any               `json:"source_timeout,omitempty" validate:"omitempty"`
	NoClientsReconnectDelayValue *int              `json:"no_clients_reconnect_delay,omitempty" validate:"omitempty"`
	PriorityValue                *int              `json:"priority,omitempty" validate:"omitempty"`
	CommentValue                 *string           `json:"comment,omitempty" validate:"omitempty"`
	DenyIfValue                  *string           `json:"deny_if,omitempty" validate:"omitempty"`
	FramesTimeoutValue           *int              `json:"frames_timeout,omitempty" validate:"omitempty"`
	HeadersValue                 map[string]string `json:"headers,omitempty" validate:"omitempty"`
	MaxRetryTimeoutValue         *Seconds          `json:"max_retry_timeout,omitempty" validate:"omitempty,min=1"`
	AllowIfValue                 *string           `json:"allow_if,omitempty" validate:"omitempty"`
	BitrateValue                 *Speed            `json:"bitrate,omitempty" validate:"omitempty"`
	AudioTimeoutValue            *Seconds          `json:"audio_timeout,omitempty" validate:"omitempty"`
	OutputAudioValue             *OutputAudio      `json:"output_audio,omitempty" validate:"omitempty"`
	StatsValue                   *InputStatsImpl   `json:"stats,omitempty" validate:"omitempty"`
	TimeoutValue                 *int              `json:"timeout,omitempty" validate:"omitempty"`
	VideoTimeoutValue            *Seconds          `json:"video_timeout,omitempty" validate:"omitempty"`
	UserAgentValue               *string           `json:"user_agent,omitempty" validate:"omitempty"`
	ViaValue                     *AgentURL         `json:"via,omitempty" validate:"omitempty"`
	URLValue                     InputURL          `json:"url" validate:"required"`
}

type StreamInputMpegtsSpecificImpl struct {
	ClosedCaptionsValue map[string]string                   `json:"closed_captions,omitempty" validate:"omitempty"`
	LanguagesValue      map[string]string                   `json:"languages,omitempty" validate:"omitempty"`
	Scte35Value         *bool                               `json:"scte35,omitempty" validate:"omitempty"`
	SubtitlesValue      *StreamInputMpegtsSpecificSubtitles `json:"subtitles,omitempty" validate:"omitempty,oneof=drop accept ocr_replace ocr_add"`
	PidsValue           []int                               `json:"pids,omitempty" validate:"omitempty"`
	ProgramsValue       []int                               `json:"programs,omitempty" validate:"omitempty"`
}

type StreamInputMptsImpl struct {
	SourceTimeoutValue           any                                 `json:"source_timeout,omitempty" validate:"omitempty"`
	FramesTimeoutValue           *int                                `json:"frames_timeout,omitempty" validate:"omitempty"`
	PriorityValue                *int                                `json:"priority,omitempty" validate:"omitempty"`
	CommentValue                 *string                             `json:"comment,omitempty" validate:"omitempty"`
	DenyIfValue                  *string                             `json:"deny_if,omitempty" validate:"omitempty"`
	AllowIfValue                 *string                             `json:"allow_if,omitempty" validate:"omitempty"`
	HeadersValue                 map[string]string                   `json:"headers,omitempty" validate:"omitempty"`
	LanguagesValue               map[string]string                   `json:"languages,omitempty" validate:"omitempty"`
	MaxRetryTimeoutValue         *Seconds                            `json:"max_retry_timeout,omitempty" validate:"omitempty,min=1"`
	NoClientsReconnectDelayValue *int                                `json:"no_clients_reconnect_delay,omitempty" validate:"omitempty"`
	VideoTimeoutValue            *Seconds                            `json:"video_timeout,omitempty" validate:"omitempty"`
	ClosedCaptionsValue          map[string]string                   `json:"closed_captions,omitempty" validate:"omitempty"`
	ViaValue                     *AgentURL                           `json:"via,omitempty" validate:"omitempty"`
	OutputAudioValue             *OutputAudio                        `json:"output_audio,omitempty" validate:"omitempty"`
	Scte35Value                  *bool                               `json:"scte35,omitempty" validate:"omitempty"`
	AudioTimeoutValue            *Seconds                            `json:"audio_timeout,omitempty" validate:"omitempty"`
	StatsValue                   *InputStatsImpl                     `json:"stats,omitempty" validate:"omitempty"`
	SubtitlesValue               *StreamInputMpegtsSpecificSubtitles `json:"subtitles,omitempty" validate:"omitempty,oneof=drop accept ocr_replace ocr_add"`
	TimeoutValue                 *int                                `json:"timeout,omitempty" validate:"omitempty"`
	UserAgentValue               *string                             `json:"user_agent,omitempty" validate:"omitempty"`
	URLValue                     InputURL                            `json:"url" validate:"required"`
	PidsValue                    []int                               `json:"pids,omitempty" validate:"omitempty"`
	ProgramsValue                []int                               `json:"programs,omitempty" validate:"omitempty"`
}

type StreamInputNdiImpl struct {
	SourceTimeoutValue           any               `json:"source_timeout,omitempty" validate:"omitempty"`
	OutputAudioValue             *OutputAudio      `json:"output_audio,omitempty" validate:"omitempty"`
	AudioTimeoutValue            *Seconds          `json:"audio_timeout,omitempty" validate:"omitempty"`
	DenyIfValue                  *string           `json:"deny_if,omitempty" validate:"omitempty"`
	FramesTimeoutValue           *int              `json:"frames_timeout,omitempty" validate:"omitempty"`
	HeadersValue                 map[string]string `json:"headers,omitempty" validate:"omitempty"`
	MaxRetryTimeoutValue         *Seconds          `json:"max_retry_timeout,omitempty" validate:"omitempty,min=1"`
	CommentValue                 *string           `json:"comment,omitempty" validate:"omitempty"`
	NoClientsReconnectDelayValue *int              `json:"no_clients_reconnect_delay,omitempty" validate:"omitempty"`
	PriorityValue                *int              `json:"priority,omitempty" validate:"omitempty"`
	AllowIfValue                 *string           `json:"allow_if,omitempty" validate:"omitempty"`
	StatsValue                   *InputStatsImpl   `json:"stats,omitempty" validate:"omitempty"`
	TimeoutValue                 *int              `json:"timeout,omitempty" validate:"omitempty"`
	VideoTimeoutValue            *Seconds          `json:"video_timeout,omitempty" validate:"omitempty"`
	UserAgentValue               *string           `json:"user_agent,omitempty" validate:"omitempty"`
	ViaValue                     *AgentURL         `json:"via,omitempty" validate:"omitempty"`
	URLValue                     InputURL          `json:"url" validate:"required"`
}

type StreamInputPlaylistImpl struct {
	SourceTimeoutValue           any               `json:"source_timeout,omitempty" validate:"omitempty"`
	OutputAudioValue             *OutputAudio      `json:"output_audio,omitempty" validate:"omitempty"`
	AudioTimeoutValue            *Seconds          `json:"audio_timeout,omitempty" validate:"omitempty"`
	DenyIfValue                  *string           `json:"deny_if,omitempty" validate:"omitempty"`
	FramesTimeoutValue           *int              `json:"frames_timeout,omitempty" validate:"omitempty"`
	HeadersValue                 map[string]string `json:"headers,omitempty" validate:"omitempty"`
	MaxRetryTimeoutValue         *Seconds          `json:"max_retry_timeout,omitempty" validate:"omitempty,min=1"`
	CommentValue                 *string           `json:"comment,omitempty" validate:"omitempty"`
	NoClientsReconnectDelayValue *int              `json:"no_clients_reconnect_delay,omitempty" validate:"omitempty"`
	PriorityValue                *int              `json:"priority,omitempty" validate:"omitempty"`
	AllowIfValue                 *string           `json:"allow_if,omitempty" validate:"omitempty"`
	StatsValue                   *InputStatsImpl   `json:"stats,omitempty" validate:"omitempty"`
	TimeoutValue                 *int              `json:"timeout,omitempty" validate:"omitempty"`
	VideoTimeoutValue            *Seconds          `json:"video_timeout,omitempty" validate:"omitempty"`
	UserAgentValue               *string           `json:"user_agent,omitempty" validate:"omitempty"`
	ViaValue                     *AgentURL         `json:"via,omitempty" validate:"omitempty"`
	URLValue                     InputURL          `json:"url" validate:"required"`
}

type StreamInputPublishImpl struct {
	SourceTimeoutValue           any                                     `json:"source_timeout,omitempty" validate:"omitempty"`
	MinBitrateValue              *int                                    `json:"min_bitrate,omitempty" validate:"omitempty"`
	OutputAudioValue             *OutputAudio                            `json:"output_audio,omitempty" validate:"omitempty"`
	AbrLossLowerValue            *float64                                `json:"abr_loss_lower,omitempty" validate:"omitempty"`
	AbrLossUpperValue            *float64                                `json:"abr_loss_upper,omitempty" validate:"omitempty"`
	AbrMaxBitrateValue           *int                                    `json:"abr_max_bitrate,omitempty" validate:"omitempty"`
	AbrModeValue                 *int                                    `json:"abr_mode,omitempty" validate:"omitempty"`
	AbrStepdownValue             *float64                                `json:"abr_stepdown,omitempty" validate:"omitempty"`
	AbrStepupValue               *int                                    `json:"abr_stepup,omitempty" validate:"omitempty"`
	NoClientsReconnectDelayValue *int                                    `json:"no_clients_reconnect_delay,omitempty" validate:"omitempty"`
	AudioTimeoutValue            *Seconds                                `json:"audio_timeout,omitempty" validate:"omitempty"`
	CommentValue                 *string                                 `json:"comment,omitempty" validate:"omitempty"`
	DenyIfValue                  *string                                 `json:"deny_if,omitempty" validate:"omitempty"`
	FramesTimeoutValue           *int                                    `json:"frames_timeout,omitempty" validate:"omitempty"`
	HeadersValue                 map[string]string                       `json:"headers,omitempty" validate:"omitempty"`
	AbrDebugValue                *int                                    `json:"abr_debug,omitempty" validate:"omitempty"`
	MaxRetryTimeoutValue         *Seconds                                `json:"max_retry_timeout,omitempty" validate:"omitempty,min=1"`
	AllowIfValue                 *string                                 `json:"allow_if,omitempty" validate:"omitempty"`
	AbrCorrectionValue           *int                                    `json:"abr_correction,omitempty" validate:"omitempty"`
	PreferCodecValue             *WebrtcPreferVideoCodec                 `json:"prefer_codec,omitempty" validate:"omitempty"`
	PreferVideoCodecValue        *WebrtcPreferVideoCodec                 `json:"prefer_video_codec,omitempty" validate:"omitempty"`
	PriorityValue                *int                                    `json:"priority,omitempty" validate:"omitempty"`
	Scte35Value                  *bool                                   `json:"scte35,omitempty" validate:"omitempty"`
	AbrCyclesValue               *int                                    `json:"abr_cycles,omitempty" validate:"omitempty"`
	StatsValue                   *InputStatsImpl                         `json:"stats,omitempty" validate:"omitempty"`
	SubtitlesValue               *StreamInputSrtPublishSpecificSubtitles `json:"subtitles,omitempty" validate:"omitempty,oneof=drop accept ocr_replace ocr_add"`
	TimeoutValue                 *int                                    `json:"timeout,omitempty" validate:"omitempty"`
	TransportValue               *WebrtcTransport                        `json:"transport,omitempty" validate:"omitempty"`
	WebrtcAbrValue               *bool                                   `json:"webrtc_abr,omitempty" validate:"omitempty"`
	UserAgentValue               *string                                 `json:"user_agent,omitempty" validate:"omitempty"`
	ViaValue                     *AgentURL                               `json:"via,omitempty" validate:"omitempty"`
	VideoTimeoutValue            *Seconds                                `json:"video_timeout,omitempty" validate:"omitempty"`
	URLValue                     InputURL                                `json:"url" validate:"required"`
}

type StreamInputRTPImpl struct {
	SourceTimeoutValue           any               `json:"source_timeout,omitempty" validate:"omitempty"`
	OutputAudioValue             *OutputAudio      `json:"output_audio,omitempty" validate:"omitempty"`
	AudioTimeoutValue            *Seconds          `json:"audio_timeout,omitempty" validate:"omitempty"`
	DenyIfValue                  *string           `json:"deny_if,omitempty" validate:"omitempty"`
	FramesTimeoutValue           *int              `json:"frames_timeout,omitempty" validate:"omitempty"`
	HeadersValue                 map[string]string `json:"headers,omitempty" validate:"omitempty"`
	MaxRetryTimeoutValue         *Seconds          `json:"max_retry_timeout,omitempty" validate:"omitempty,min=1"`
	CommentValue                 *string           `json:"comment,omitempty" validate:"omitempty"`
	NoClientsReconnectDelayValue *int              `json:"no_clients_reconnect_delay,omitempty" validate:"omitempty"`
	PriorityValue                *int              `json:"priority,omitempty" validate:"omitempty"`
	AllowIfValue                 *string           `json:"allow_if,omitempty" validate:"omitempty"`
	StatsValue                   *InputStatsImpl   `json:"stats,omitempty" validate:"omitempty"`
	TimeoutValue                 *int              `json:"timeout,omitempty" validate:"omitempty"`
	VideoTimeoutValue            *Seconds          `json:"video_timeout,omitempty" validate:"omitempty"`
	UserAgentValue               *string           `json:"user_agent,omitempty" validate:"omitempty"`
	ViaValue                     *AgentURL         `json:"via,omitempty" validate:"omitempty"`
	URLValue                     InputURL          `json:"url" validate:"required"`
}

type StreamInputRtmpImpl struct {
	SourceTimeoutValue           any               `json:"source_timeout,omitempty" validate:"omitempty"`
	PriorityValue                *int              `json:"priority,omitempty" validate:"omitempty"`
	AudioTimeoutValue            *Seconds          `json:"audio_timeout,omitempty" validate:"omitempty"`
	DenyIfValue                  *string           `json:"deny_if,omitempty" validate:"omitempty"`
	AllowIfValue                 *string           `json:"allow_if,omitempty" validate:"omitempty"`
	HeadersValue                 map[string]string `json:"headers,omitempty" validate:"omitempty"`
	MaxRetryTimeoutValue         *Seconds          `json:"max_retry_timeout,omitempty" validate:"omitempty,min=1"`
	NoClientsReconnectDelayValue *int              `json:"no_clients_reconnect_delay,omitempty" validate:"omitempty"`
	OutputAudioValue             *OutputAudio      `json:"output_audio,omitempty" validate:"omitempty"`
	CommentValue                 *string           `json:"comment,omitempty" validate:"omitempty"`
	PageurlValue                 *URL              `json:"pageUrl,omitempty" validate:"omitempty"`
	FramesTimeoutValue           *int              `json:"frames_timeout,omitempty" validate:"omitempty"`
	StatsValue                   *InputStatsImpl   `json:"stats,omitempty" validate:"omitempty"`
	SwfurlValue                  *string           `json:"swfUrl,omitempty" validate:"omitempty"`
	TcurlValue                   *URL              `json:"tcUrl,omitempty" validate:"omitempty"`
	TimeoutValue                 *int              `json:"timeout,omitempty" validate:"omitempty"`
	VideoTimeoutValue            *Seconds          `json:"video_timeout,omitempty" validate:"omitempty"`
	UserAgentValue               *string           `json:"user_agent,omitempty" validate:"omitempty"`
	ViaValue                     *AgentURL         `json:"via,omitempty" validate:"omitempty"`
	URLValue                     InputURL          `json:"url" validate:"required"`
}

type StreamInputRtspImpl struct {
	SourceTimeoutValue           any               `json:"source_timeout,omitempty" validate:"omitempty"`
	OutputAudioValue             *OutputAudio      `json:"output_audio,omitempty" validate:"omitempty"`
	AudioTimeoutValue            *Seconds          `json:"audio_timeout,omitempty" validate:"omitempty"`
	DenyIfValue                  *string           `json:"deny_if,omitempty" validate:"omitempty"`
	FramesTimeoutValue           *int              `json:"frames_timeout,omitempty" validate:"omitempty"`
	HeadersValue                 map[string]string `json:"headers,omitempty" validate:"omitempty"`
	MaxRetryTimeoutValue         *Seconds          `json:"max_retry_timeout,omitempty" validate:"omitempty,min=1"`
	NoClientsReconnectDelayValue *int              `json:"no_clients_reconnect_delay,omitempty" validate:"omitempty"`
	AllowIfValue                 *string           `json:"allow_if,omitempty" validate:"omitempty"`
	CommentValue                 *string           `json:"comment,omitempty" validate:"omitempty"`
	PriorityValue                *int              `json:"priority,omitempty" validate:"omitempty"`
	RTPValue                     *string           `json:"rtp,omitempty" validate:"omitempty"`
	StatsValue                   *InputStatsImpl   `json:"stats,omitempty" validate:"omitempty"`
	TimeoutValue                 *int              `json:"timeout,omitempty" validate:"omitempty"`
	WaitRtcpValue                *bool             `json:"wait_rtcp,omitempty" validate:"omitempty"`
	UserAgentValue               *string           `json:"user_agent,omitempty" validate:"omitempty"`
	ViaValue                     *AgentURL         `json:"via,omitempty" validate:"omitempty"`
	VideoTimeoutValue            *Seconds          `json:"video_timeout,omitempty" validate:"omitempty"`
	URLValue                     InputURL          `json:"url" validate:"required"`
}

type StreamInputShoutcastImpl struct {
	SourceTimeoutValue           any               `json:"source_timeout,omitempty" validate:"omitempty"`
	OutputAudioValue             *OutputAudio      `json:"output_audio,omitempty" validate:"omitempty"`
	AudioTimeoutValue            *Seconds          `json:"audio_timeout,omitempty" validate:"omitempty"`
	DenyIfValue                  *string           `json:"deny_if,omitempty" validate:"omitempty"`
	FramesTimeoutValue           *int              `json:"frames_timeout,omitempty" validate:"omitempty"`
	HeadersValue                 map[string]string `json:"headers,omitempty" validate:"omitempty"`
	MaxRetryTimeoutValue         *Seconds          `json:"max_retry_timeout,omitempty" validate:"omitempty,min=1"`
	CommentValue                 *string           `json:"comment,omitempty" validate:"omitempty"`
	NoClientsReconnectDelayValue *int              `json:"no_clients_reconnect_delay,omitempty" validate:"omitempty"`
	PriorityValue                *int              `json:"priority,omitempty" validate:"omitempty"`
	AllowIfValue                 *string           `json:"allow_if,omitempty" validate:"omitempty"`
	StatsValue                   *InputStatsImpl   `json:"stats,omitempty" validate:"omitempty"`
	TimeoutValue                 *int              `json:"timeout,omitempty" validate:"omitempty"`
	VideoTimeoutValue            *Seconds          `json:"video_timeout,omitempty" validate:"omitempty"`
	UserAgentValue               *string           `json:"user_agent,omitempty" validate:"omitempty"`
	ViaValue                     *AgentURL         `json:"via,omitempty" validate:"omitempty"`
	URLValue                     InputURL          `json:"url" validate:"required"`
}

type StreamInputSptsImpl struct {
	SourceTimeoutValue           any                                 `json:"source_timeout,omitempty" validate:"omitempty"`
	FramesTimeoutValue           *int                                `json:"frames_timeout,omitempty" validate:"omitempty"`
	PriorityValue                *int                                `json:"priority,omitempty" validate:"omitempty"`
	CommentValue                 *string                             `json:"comment,omitempty" validate:"omitempty"`
	DenyIfValue                  *string                             `json:"deny_if,omitempty" validate:"omitempty"`
	AllowIfValue                 *string                             `json:"allow_if,omitempty" validate:"omitempty"`
	HeadersValue                 map[string]string                   `json:"headers,omitempty" validate:"omitempty"`
	LanguagesValue               map[string]string                   `json:"languages,omitempty" validate:"omitempty"`
	MaxRetryTimeoutValue         *Seconds                            `json:"max_retry_timeout,omitempty" validate:"omitempty,min=1"`
	NoClientsReconnectDelayValue *int                                `json:"no_clients_reconnect_delay,omitempty" validate:"omitempty"`
	VideoTimeoutValue            *Seconds                            `json:"video_timeout,omitempty" validate:"omitempty"`
	ClosedCaptionsValue          map[string]string                   `json:"closed_captions,omitempty" validate:"omitempty"`
	ViaValue                     *AgentURL                           `json:"via,omitempty" validate:"omitempty"`
	OutputAudioValue             *OutputAudio                        `json:"output_audio,omitempty" validate:"omitempty"`
	Scte35Value                  *bool                               `json:"scte35,omitempty" validate:"omitempty"`
	AudioTimeoutValue            *Seconds                            `json:"audio_timeout,omitempty" validate:"omitempty"`
	StatsValue                   *InputStatsImpl                     `json:"stats,omitempty" validate:"omitempty"`
	SubtitlesValue               *StreamInputMpegtsSpecificSubtitles `json:"subtitles,omitempty" validate:"omitempty,oneof=drop accept ocr_replace ocr_add"`
	TimeoutValue                 *int                                `json:"timeout,omitempty" validate:"omitempty"`
	UserAgentValue               *string                             `json:"user_agent,omitempty" validate:"omitempty"`
	URLValue                     InputURL                            `json:"url" validate:"required"`
	PidsValue                    []int                               `json:"pids,omitempty" validate:"omitempty"`
	ProgramsValue                []int                               `json:"programs,omitempty" validate:"omitempty"`
}

type StreamInputSrtImpl struct {
	SourceTimeoutValue           any                                     `json:"source_timeout,omitempty" validate:"omitempty"`
	NoClientsReconnectDelayValue *int                                    `json:"no_clients_reconnect_delay,omitempty" validate:"omitempty"`
	UserAgentValue               *string                                 `json:"user_agent,omitempty" validate:"omitempty"`
	CommentValue                 *string                                 `json:"comment,omitempty" validate:"omitempty"`
	DenyIfValue                  *string                                 `json:"deny_if,omitempty" validate:"omitempty"`
	EnforcedencryptionValue      *bool                                   `json:"enforcedencryption,omitempty" validate:"omitempty"`
	FramesTimeoutValue           *int                                    `json:"frames_timeout,omitempty" validate:"omitempty"`
	HeadersValue                 map[string]string                       `json:"headers,omitempty" validate:"omitempty"`
	LatencyValue                 *Milliseconds                           `json:"latency,omitempty" validate:"omitempty"`
	LingerValue                  *Seconds                                `json:"linger,omitempty" validate:"omitempty"`
	MaxRetryTimeoutValue         *Seconds                                `json:"max_retry_timeout,omitempty" validate:"omitempty,min=1"`
	MinversionValue              *string                                 `json:"minversion,omitempty" validate:"omitempty"`
	AllowIfValue                 *string                                 `json:"allow_if,omitempty" validate:"omitempty"`
	ClosedCaptionsValue          map[string]string                       `json:"closed_captions,omitempty" validate:"omitempty"`
	OutputAudioValue             *OutputAudio                            `json:"output_audio,omitempty" validate:"omitempty"`
	StreamidValue                *string                                 `json:"streamid,omitempty" validate:"omitempty,max=512"`
	Scte35Value                  *bool                                   `json:"scte35,omitempty" validate:"omitempty"`
	AudioTimeoutValue            *Seconds                                `json:"audio_timeout,omitempty" validate:"omitempty"`
	StatsValue                   *InputStatsImpl                         `json:"stats,omitempty" validate:"omitempty"`
	PriorityValue                *int                                    `json:"priority,omitempty" validate:"omitempty"`
	SubtitlesValue               *StreamInputSrtPublishSpecificSubtitles `json:"subtitles,omitempty" validate:"omitempty,oneof=drop accept ocr_replace ocr_add"`
	TimeoutValue                 *int                                    `json:"timeout,omitempty" validate:"omitempty"`
	VideoTimeoutValue            *Seconds                                `json:"video_timeout,omitempty" validate:"omitempty"`
	PassphraseValue              *string                                 `json:"passphrase,omitempty" validate:"omitempty,min=10,max=79"`
	VersionValue                 *string                                 `json:"version,omitempty" validate:"omitempty"`
	ViaValue                     *AgentURL                               `json:"via,omitempty" validate:"omitempty"`
	URLValue                     InputURL                                `json:"url" validate:"required"`
}

type StreamInputSrtPublishSpecificImpl struct {
	Scte35Value    *bool                                   `json:"scte35,omitempty" validate:"omitempty"`
	SubtitlesValue *StreamInputSrtPublishSpecificSubtitles `json:"subtitles,omitempty" validate:"omitempty,oneof=drop accept ocr_replace ocr_add"`
}

type StreamInputSt2110Impl struct {
	SourceTimeoutValue           any               `json:"source_timeout,omitempty" validate:"omitempty"`
	OutputAudioValue             *OutputAudio      `json:"output_audio,omitempty" validate:"omitempty"`
	PriorityValue                *int              `json:"priority,omitempty" validate:"omitempty"`
	CommentValue                 *string           `json:"comment,omitempty" validate:"omitempty"`
	AllowIfValue                 *string           `json:"allow_if,omitempty" validate:"omitempty"`
	FramesTimeoutValue           *int              `json:"frames_timeout,omitempty" validate:"omitempty"`
	HeadersValue                 map[string]string `json:"headers,omitempty" validate:"omitempty"`
	HeightValue                  *int              `json:"height,omitempty" validate:"omitempty"`
	MaxRetryTimeoutValue         *Seconds          `json:"max_retry_timeout,omitempty" validate:"omitempty,min=1"`
	BindToCoreValue              *int              `json:"bind_to_core,omitempty" validate:"omitempty"`
	NoClientsReconnectDelayValue *int              `json:"no_clients_reconnect_delay,omitempty" validate:"omitempty"`
	DenyIfValue                  *string           `json:"deny_if,omitempty" validate:"omitempty"`
	AudioTimeoutValue            *Seconds          `json:"audio_timeout,omitempty" validate:"omitempty"`
	StatsValue                   *InputStatsImpl   `json:"stats,omitempty" validate:"omitempty"`
	TimeoutValue                 *int              `json:"timeout,omitempty" validate:"omitempty"`
	WidthValue                   *int              `json:"width,omitempty" validate:"omitempty"`
	UserAgentValue               *string           `json:"user_agent,omitempty" validate:"omitempty"`
	ViaValue                     *AgentURL         `json:"via,omitempty" validate:"omitempty"`
	VideoTimeoutValue            *Seconds          `json:"video_timeout,omitempty" validate:"omitempty"`
	URLValue                     InputURL          `json:"url" validate:"required"`
}

type StreamInputTimeshiftImpl struct {
	SourceTimeoutValue           any               `json:"source_timeout,omitempty" validate:"omitempty"`
	OutputAudioValue             *OutputAudio      `json:"output_audio,omitempty" validate:"omitempty"`
	AudioTimeoutValue            *Seconds          `json:"audio_timeout,omitempty" validate:"omitempty"`
	DenyIfValue                  *string           `json:"deny_if,omitempty" validate:"omitempty"`
	FramesTimeoutValue           *int              `json:"frames_timeout,omitempty" validate:"omitempty"`
	HeadersValue                 map[string]string `json:"headers,omitempty" validate:"omitempty"`
	MaxRetryTimeoutValue         *Seconds          `json:"max_retry_timeout,omitempty" validate:"omitempty,min=1"`
	CommentValue                 *string           `json:"comment,omitempty" validate:"omitempty"`
	NoClientsReconnectDelayValue *int              `json:"no_clients_reconnect_delay,omitempty" validate:"omitempty"`
	PriorityValue                *int              `json:"priority,omitempty" validate:"omitempty"`
	AllowIfValue                 *string           `json:"allow_if,omitempty" validate:"omitempty"`
	StatsValue                   *InputStatsImpl   `json:"stats,omitempty" validate:"omitempty"`
	TimeoutValue                 *int              `json:"timeout,omitempty" validate:"omitempty"`
	VideoTimeoutValue            *Seconds          `json:"video_timeout,omitempty" validate:"omitempty"`
	UserAgentValue               *string           `json:"user_agent,omitempty" validate:"omitempty"`
	ViaValue                     *AgentURL         `json:"via,omitempty" validate:"omitempty"`
	URLValue                     InputURL          `json:"url" validate:"required"`
}

type StreamInputTshttpImpl struct {
	SourceTimeoutValue           any                                 `json:"source_timeout,omitempty" validate:"omitempty"`
	FramesTimeoutValue           *int                                `json:"frames_timeout,omitempty" validate:"omitempty"`
	PriorityValue                *int                                `json:"priority,omitempty" validate:"omitempty"`
	CommentValue                 *string                             `json:"comment,omitempty" validate:"omitempty"`
	DenyIfValue                  *string                             `json:"deny_if,omitempty" validate:"omitempty"`
	AllowIfValue                 *string                             `json:"allow_if,omitempty" validate:"omitempty"`
	HeadersValue                 map[string]string                   `json:"headers,omitempty" validate:"omitempty"`
	LanguagesValue               map[string]string                   `json:"languages,omitempty" validate:"omitempty"`
	MaxRetryTimeoutValue         *Seconds                            `json:"max_retry_timeout,omitempty" validate:"omitempty,min=1"`
	NoClientsReconnectDelayValue *int                                `json:"no_clients_reconnect_delay,omitempty" validate:"omitempty"`
	VideoTimeoutValue            *Seconds                            `json:"video_timeout,omitempty" validate:"omitempty"`
	ClosedCaptionsValue          map[string]string                   `json:"closed_captions,omitempty" validate:"omitempty"`
	ViaValue                     *AgentURL                           `json:"via,omitempty" validate:"omitempty"`
	OutputAudioValue             *OutputAudio                        `json:"output_audio,omitempty" validate:"omitempty"`
	Scte35Value                  *bool                               `json:"scte35,omitempty" validate:"omitempty"`
	AudioTimeoutValue            *Seconds                            `json:"audio_timeout,omitempty" validate:"omitempty"`
	StatsValue                   *InputStatsImpl                     `json:"stats,omitempty" validate:"omitempty"`
	SubtitlesValue               *StreamInputMpegtsSpecificSubtitles `json:"subtitles,omitempty" validate:"omitempty,oneof=drop accept ocr_replace ocr_add"`
	TimeoutValue                 *int                                `json:"timeout,omitempty" validate:"omitempty"`
	UserAgentValue               *string                             `json:"user_agent,omitempty" validate:"omitempty"`
	URLValue                     InputURL                            `json:"url" validate:"required"`
	PidsValue                    []int                               `json:"pids,omitempty" validate:"omitempty"`
	ProgramsValue                []int                               `json:"programs,omitempty" validate:"omitempty"`
}

type StreamInputV4lImpl struct {
	SourceTimeoutValue           any                    `json:"source_timeout,omitempty" validate:"omitempty"`
	PriorityValue                *int                   `json:"priority,omitempty" validate:"omitempty"`
	StatsValue                   *InputStatsImpl        `json:"stats,omitempty" validate:"omitempty"`
	CommentValue                 *string                `json:"comment,omitempty" validate:"omitempty"`
	DenyIfValue                  *string                `json:"deny_if,omitempty" validate:"omitempty"`
	FramesTimeoutValue           *int                   `json:"frames_timeout,omitempty" validate:"omitempty"`
	HeadersValue                 map[string]string      `json:"headers,omitempty" validate:"omitempty"`
	MaxRetryTimeoutValue         *Seconds               `json:"max_retry_timeout,omitempty" validate:"omitempty,min=1"`
	NoClientsReconnectDelayValue *int                   `json:"no_clients_reconnect_delay,omitempty" validate:"omitempty"`
	OutputAudioValue             *OutputAudio           `json:"output_audio,omitempty" validate:"omitempty"`
	TimeoutValue                 *int                   `json:"timeout,omitempty" validate:"omitempty"`
	AudioTimeoutValue            *Seconds               `json:"audio_timeout,omitempty" validate:"omitempty"`
	AudioDeviceValue             *string                `json:"audio_device,omitempty" validate:"omitempty"`
	AllowIfValue                 *string                `json:"allow_if,omitempty" validate:"omitempty"`
	VideoTimeoutValue            *Seconds               `json:"video_timeout,omitempty" validate:"omitempty"`
	VideoDeviceValue             *string                `json:"video_device,omitempty" validate:"omitempty"`
	UserAgentValue               *string                `json:"user_agent,omitempty" validate:"omitempty"`
	VbiDebugValue                *bool                  `json:"vbi_debug,omitempty" validate:"omitempty"`
	VbiDeviceValue               *string                `json:"vbi_device,omitempty" validate:"omitempty"`
	VbiThresholdValue            *int                   `json:"vbi_threshold,omitempty" validate:"omitempty"`
	ViaValue                     *AgentURL              `json:"via,omitempty" validate:"omitempty"`
	URLValue                     InputURL               `json:"url" validate:"required"`
	TtxtDescriptorsValue         []*TtxtDescriptorsImpl `json:"ttxt_descriptors,omitempty" validate:"omitempty"`
}

// Title: WebRTC
type StreamInputWebrtcPublishSpecificImpl struct {
	AbrCorrectionValue    *int                    `json:"abr_correction,omitempty" validate:"omitempty"`
	AbrCyclesValue        *int                    `json:"abr_cycles,omitempty" validate:"omitempty"`
	AbrDebugValue         *int                    `json:"abr_debug,omitempty" validate:"omitempty"`
	AbrLossLowerValue     *float64                `json:"abr_loss_lower,omitempty" validate:"omitempty"`
	AbrLossUpperValue     *float64                `json:"abr_loss_upper,omitempty" validate:"omitempty"`
	AbrMaxBitrateValue    *int                    `json:"abr_max_bitrate,omitempty" validate:"omitempty"`
	AbrModeValue          *int                    `json:"abr_mode,omitempty" validate:"omitempty"`
	AbrStepdownValue      *float64                `json:"abr_stepdown,omitempty" validate:"omitempty"`
	AbrStepupValue        *int                    `json:"abr_stepup,omitempty" validate:"omitempty"`
	MinBitrateValue       *int                    `json:"min_bitrate,omitempty" validate:"omitempty"`
	PreferCodecValue      *WebrtcPreferVideoCodec `json:"prefer_codec,omitempty" validate:"omitempty"`
	PreferVideoCodecValue *WebrtcPreferVideoCodec `json:"prefer_video_codec,omitempty" validate:"omitempty"`
	TransportValue        *WebrtcTransport        `json:"transport,omitempty" validate:"omitempty"`
	WebrtcAbrValue        *bool                   `json:"webrtc_abr,omitempty" validate:"omitempty"`
}

type StreamPushImpl struct {
	PnrValue                *int                  `json:"pnr,omitempty" validate:"omitempty"`
	ProviderValue           *string               `json:"provider,omitempty" validate:"omitempty"`
	ConnectTimeoutValue     *Seconds              `json:"connect_timeout,omitempty" validate:"omitempty"`
	DeinterlaceValue        *bool                 `json:"deinterlace,omitempty" validate:"omitempty"`
	DisabledValue           *bool                 `json:"disabled,omitempty" validate:"omitempty"`
	DthreadsValue           *int                  `json:"dthreads,omitempty" validate:"omitempty"`
	EnforcedencryptionValue *bool                 `json:"enforcedencryption,omitempty" validate:"omitempty"`
	GenlockValue            *bool                 `json:"genlock,omitempty" validate:"omitempty"`
	BitrateValue            *Speed                `json:"bitrate,omitempty" validate:"omitempty"`
	LingerValue             *Seconds              `json:"linger,omitempty" validate:"omitempty"`
	MinversionValue         *string               `json:"minversion,omitempty" validate:"omitempty"`
	MpegtsAc3Value          *OutputMpegtsAc3      `json:"mpegts_ac3,omitempty" validate:"omitempty"`
	MulticastLoopValue      *bool                 `json:"multicast_loop,omitempty" validate:"omitempty"`
	PassphraseValue         *string               `json:"passphrase,omitempty" validate:"omitempty,min=10,max=79"`
	CommentValue            *string               `json:"comment,omitempty" validate:"omitempty"`
	PidsValue               *OutputMpegtsPidsImpl `json:"pids,omitempty" validate:"omitempty"`
	LatencyValue            *Milliseconds         `json:"latency,omitempty" validate:"omitempty"`
	PixelOffsetValue        *int                  `json:"pixel_offset,omitempty" validate:"omitempty"`
	RetryLimitValue         *int                  `json:"retry_limit,omitempty" validate:"omitempty"`
	RetryTimeoutValue       *Seconds              `json:"retry_timeout,omitempty" validate:"omitempty"`
	ScaleValue              *ScaleAlgorithm       `json:"scale,omitempty" validate:"omitempty"`
	ServiceValue            *string               `json:"service,omitempty" validate:"omitempty"`
	StandbyValue            *bool                 `json:"standby,omitempty" validate:"omitempty"`
	StatsValue              *PushCountersImpl     `json:"stats,omitempty" validate:"omitempty"`
	StreamidValue           *string               `json:"streamid,omitempty" validate:"omitempty,max=512"`
	TimeoutValue            *Seconds              `json:"timeout,omitempty" validate:"omitempty"`
	VolumeValue             *float64              `json:"volume,omitempty" validate:"omitempty"`
	VbValue                 *Speed                `json:"vb,omitempty" validate:"omitempty"`
	VideoFormatValue        *string               `json:"video_format,omitempty" validate:"omitempty,oneof=pal 625i50 ntsc 525i29.97 525i29 720p23.98 720p23 720p24 720p25 720p29.97 720p29 720p30 720p50 720p59.94 720p59 720p60 1080p23.98 1080p23 1080p24 1080p25 1080p29.97 1080p29 1080p30 1080psf23.98 1080psf23 1080psf24 1080psf25 1080psf29.97 1080psf29 1080psf30 1080i50 1080i59.94 1080i60 1080p50 1080p50b 1080p59.94 1080p59 1080p59.94b 1080p59b 1080p60 1080p60b 2160p50 2160p50b 2160p59.94 2160p59 2160p59.94b 2160p59b 2160p60 2160p60b 2160p23 2160p24 2160p25 2160p29 2160p30"`
	VersionValue            *string               `json:"version,omitempty" validate:"omitempty"`
	URLValue                InputURL              `json:"url" validate:"required"`
	VbiLinesValue           []*VbiLinesImpl       `json:"vbi_lines,omitempty" validate:"omitempty"`
}

type StreamPushBaseImpl struct {
	CommentValue        *string           `json:"comment,omitempty" validate:"omitempty"`
	ConnectTimeoutValue *Seconds          `json:"connect_timeout,omitempty" validate:"omitempty"`
	DisabledValue       *bool             `json:"disabled,omitempty" validate:"omitempty"`
	RetryLimitValue     *int              `json:"retry_limit,omitempty" validate:"omitempty"`
	RetryTimeoutValue   *Seconds          `json:"retry_timeout,omitempty" validate:"omitempty"`
	StatsValue          *PushCountersImpl `json:"stats,omitempty" validate:"omitempty"`
	TimeoutValue        *Seconds          `json:"timeout,omitempty" validate:"omitempty"`
}

type StreamPushDecklinkImpl struct {
	RetryTimeoutValue   *Seconds          `json:"retry_timeout,omitempty" validate:"omitempty"`
	VideoFormatValue    *string           `json:"video_format,omitempty" validate:"omitempty,oneof=pal 625i50 ntsc 525i29.97 525i29 720p23.98 720p23 720p24 720p25 720p29.97 720p29 720p30 720p50 720p59.94 720p59 720p60 1080p23.98 1080p23 1080p24 1080p25 1080p29.97 1080p29 1080p30 1080psf23.98 1080psf23 1080psf24 1080psf25 1080psf29.97 1080psf29 1080psf30 1080i50 1080i59.94 1080i60 1080p50 1080p50b 1080p59.94 1080p59 1080p59.94b 1080p59b 1080p60 1080p60b 2160p50 2160p50b 2160p59.94 2160p59 2160p59.94b 2160p59b 2160p60 2160p60b 2160p23 2160p24 2160p25 2160p29 2160p30"`
	DeinterlaceValue    *bool             `json:"deinterlace,omitempty" validate:"omitempty"`
	DisabledValue       *bool             `json:"disabled,omitempty" validate:"omitempty"`
	DthreadsValue       *int              `json:"dthreads,omitempty" validate:"omitempty"`
	RetryLimitValue     *int              `json:"retry_limit,omitempty" validate:"omitempty"`
	StatsValue          *PushCountersImpl `json:"stats,omitempty" validate:"omitempty"`
	CommentValue        *string           `json:"comment,omitempty" validate:"omitempty"`
	ConnectTimeoutValue *Seconds          `json:"connect_timeout,omitempty" validate:"omitempty"`
	TimeoutValue        *Seconds          `json:"timeout,omitempty" validate:"omitempty"`
	VolumeValue         *float64          `json:"volume,omitempty" validate:"omitempty"`
	ScaleValue          *ScaleAlgorithm   `json:"scale,omitempty" validate:"omitempty"`
	URLValue            InputURL          `json:"url" validate:"required"`
	VbiLinesValue       []*VbiLinesImpl   `json:"vbi_lines,omitempty" validate:"omitempty"`
}

type StreamPushDektecImpl struct {
	RetryTimeoutValue   *Seconds          `json:"retry_timeout,omitempty" validate:"omitempty"`
	ScaleValue          *ScaleAlgorithm   `json:"scale,omitempty" validate:"omitempty"`
	DeinterlaceValue    *bool             `json:"deinterlace,omitempty" validate:"omitempty"`
	DisabledValue       *bool             `json:"disabled,omitempty" validate:"omitempty"`
	DthreadsValue       *int              `json:"dthreads,omitempty" validate:"omitempty"`
	GenlockValue        *bool             `json:"genlock,omitempty" validate:"omitempty"`
	ConnectTimeoutValue *Seconds          `json:"connect_timeout,omitempty" validate:"omitempty"`
	PixelOffsetValue    *int              `json:"pixel_offset,omitempty" validate:"omitempty"`
	CommentValue        *string           `json:"comment,omitempty" validate:"omitempty"`
	RetryLimitValue     *int              `json:"retry_limit,omitempty" validate:"omitempty"`
	StatsValue          *PushCountersImpl `json:"stats,omitempty" validate:"omitempty"`
	TimeoutValue        *Seconds          `json:"timeout,omitempty" validate:"omitempty"`
	VolumeValue         *float64          `json:"volume,omitempty" validate:"omitempty"`
	VideoFormatValue    *string           `json:"video_format,omitempty" validate:"omitempty,oneof=pal 625i50 ntsc 525i29.97 525i29 720p23.98 720p23 720p24 720p25 720p29.97 720p29 720p30 720p50 720p59.94 720p59 720p60 1080p23.98 1080p23 1080p24 1080p25 1080p29.97 1080p29 1080p30 1080psf23.98 1080psf23 1080psf24 1080psf25 1080psf29.97 1080psf29 1080psf30 1080i50 1080i59.94 1080i60 1080p50 1080p50b 1080p59.94 1080p59 1080p59.94b 1080p59b 1080p60 1080p60b 2160p50 2160p50b 2160p59.94 2160p59 2160p59.94b 2160p59b 2160p60 2160p60b 2160p23 2160p24 2160p25 2160p29 2160p30"`
	URLValue            InputURL          `json:"url" validate:"required"`
	VbiLinesValue       []*VbiLinesImpl   `json:"vbi_lines,omitempty" validate:"omitempty"`
}

type StreamPushDektecAsiImpl struct {
	PnrValue            *int                  `json:"pnr,omitempty" validate:"omitempty"`
	ServiceValue        *string               `json:"service,omitempty" validate:"omitempty"`
	ConnectTimeoutValue *Seconds              `json:"connect_timeout,omitempty" validate:"omitempty"`
	DisabledValue       *bool                 `json:"disabled,omitempty" validate:"omitempty"`
	MpegtsAc3Value      *OutputMpegtsAc3      `json:"mpegts_ac3,omitempty" validate:"omitempty"`
	PidsValue           *OutputMpegtsPidsImpl `json:"pids,omitempty" validate:"omitempty"`
	CommentValue        *string               `json:"comment,omitempty" validate:"omitempty"`
	RetryLimitValue     *int                  `json:"retry_limit,omitempty" validate:"omitempty"`
	BitrateValue        *Speed                `json:"bitrate,omitempty" validate:"omitempty"`
	RetryTimeoutValue   *Seconds              `json:"retry_timeout,omitempty" validate:"omitempty"`
	ProviderValue       *string               `json:"provider,omitempty" validate:"omitempty"`
	StatsValue          *PushCountersImpl     `json:"stats,omitempty" validate:"omitempty"`
	TimeoutValue        *Seconds              `json:"timeout,omitempty" validate:"omitempty"`
	VbValue             *Speed                `json:"vb,omitempty" validate:"omitempty"`
	URLValue            InputURL              `json:"url" validate:"required"`
}

type StreamPushHlsImpl struct {
	CommentValue        *string           `json:"comment,omitempty" validate:"omitempty"`
	ConnectTimeoutValue *Seconds          `json:"connect_timeout,omitempty" validate:"omitempty"`
	DisabledValue       *bool             `json:"disabled,omitempty" validate:"omitempty"`
	RetryLimitValue     *int              `json:"retry_limit,omitempty" validate:"omitempty"`
	RetryTimeoutValue   *Seconds          `json:"retry_timeout,omitempty" validate:"omitempty"`
	StatsValue          *PushCountersImpl `json:"stats,omitempty" validate:"omitempty"`
	TimeoutValue        *Seconds          `json:"timeout,omitempty" validate:"omitempty"`
	URLValue            InputURL          `json:"url" validate:"required"`
}

type StreamPushM4fImpl struct {
	CommentValue        *string           `json:"comment,omitempty" validate:"omitempty"`
	ConnectTimeoutValue *Seconds          `json:"connect_timeout,omitempty" validate:"omitempty"`
	DisabledValue       *bool             `json:"disabled,omitempty" validate:"omitempty"`
	RetryLimitValue     *int              `json:"retry_limit,omitempty" validate:"omitempty"`
	RetryTimeoutValue   *Seconds          `json:"retry_timeout,omitempty" validate:"omitempty"`
	StatsValue          *PushCountersImpl `json:"stats,omitempty" validate:"omitempty"`
	TimeoutValue        *Seconds          `json:"timeout,omitempty" validate:"omitempty"`
	URLValue            InputURL          `json:"url" validate:"required"`
}

type StreamPushM4sImpl struct {
	CommentValue        *string           `json:"comment,omitempty" validate:"omitempty"`
	ConnectTimeoutValue *Seconds          `json:"connect_timeout,omitempty" validate:"omitempty"`
	DisabledValue       *bool             `json:"disabled,omitempty" validate:"omitempty"`
	RetryLimitValue     *int              `json:"retry_limit,omitempty" validate:"omitempty"`
	RetryTimeoutValue   *Seconds          `json:"retry_timeout,omitempty" validate:"omitempty"`
	StatsValue          *PushCountersImpl `json:"stats,omitempty" validate:"omitempty"`
	TimeoutValue        *Seconds          `json:"timeout,omitempty" validate:"omitempty"`
	URLValue            InputURL          `json:"url" validate:"required"`
}

type StreamPushMpegtsBaseImpl struct {
	BitrateValue   *Speed                `json:"bitrate,omitempty" validate:"omitempty"`
	MpegtsAc3Value *OutputMpegtsAc3      `json:"mpegts_ac3,omitempty" validate:"omitempty"`
	PidsValue      *OutputMpegtsPidsImpl `json:"pids,omitempty" validate:"omitempty"`
	PnrValue       *int                  `json:"pnr,omitempty" validate:"omitempty"`
	ProviderValue  *string               `json:"provider,omitempty" validate:"omitempty"`
	ServiceValue   *string               `json:"service,omitempty" validate:"omitempty"`
	VbValue        *Speed                `json:"vb,omitempty" validate:"omitempty"`
}

type StreamPushNdiImpl struct {
	CommentValue        *string           `json:"comment,omitempty" validate:"omitempty"`
	ConnectTimeoutValue *Seconds          `json:"connect_timeout,omitempty" validate:"omitempty"`
	DisabledValue       *bool             `json:"disabled,omitempty" validate:"omitempty"`
	RetryLimitValue     *int              `json:"retry_limit,omitempty" validate:"omitempty"`
	RetryTimeoutValue   *Seconds          `json:"retry_timeout,omitempty" validate:"omitempty"`
	StatsValue          *PushCountersImpl `json:"stats,omitempty" validate:"omitempty"`
	TimeoutValue        *Seconds          `json:"timeout,omitempty" validate:"omitempty"`
	URLValue            InputURL          `json:"url" validate:"required"`
}

type StreamPushRtmpImpl struct {
	CommentValue        *string           `json:"comment,omitempty" validate:"omitempty"`
	ConnectTimeoutValue *Seconds          `json:"connect_timeout,omitempty" validate:"omitempty"`
	DisabledValue       *bool             `json:"disabled,omitempty" validate:"omitempty"`
	DomainValue         *string           `json:"domain,omitempty" validate:"omitempty"`
	EncoderValue        *string           `json:"encoder,omitempty" validate:"omitempty"`
	RetryLimitValue     *int              `json:"retry_limit,omitempty" validate:"omitempty"`
	RetryTimeoutValue   *Seconds          `json:"retry_timeout,omitempty" validate:"omitempty"`
	ServiceValue        *string           `json:"service,omitempty" validate:"omitempty"`
	StatsValue          *PushCountersImpl `json:"stats,omitempty" validate:"omitempty"`
	TimeoutValue        *Seconds          `json:"timeout,omitempty" validate:"omitempty"`
	URLValue            InputURL          `json:"url" validate:"required"`
}

type StreamPushSdiBaseImpl struct {
	DeinterlaceValue *bool           `json:"deinterlace,omitempty" validate:"omitempty"`
	DthreadsValue    *int            `json:"dthreads,omitempty" validate:"omitempty"`
	ScaleValue       *ScaleAlgorithm `json:"scale,omitempty" validate:"omitempty"`
	VideoFormatValue *string         `json:"video_format,omitempty" validate:"omitempty,oneof=pal 625i50 ntsc 525i29.97 525i29 720p23.98 720p23 720p24 720p25 720p29.97 720p29 720p30 720p50 720p59.94 720p59 720p60 1080p23.98 1080p23 1080p24 1080p25 1080p29.97 1080p29 1080p30 1080psf23.98 1080psf23 1080psf24 1080psf25 1080psf29.97 1080psf29 1080psf30 1080i50 1080i59.94 1080i60 1080p50 1080p50b 1080p59.94 1080p59 1080p59.94b 1080p59b 1080p60 1080p60b 2160p50 2160p50b 2160p59.94 2160p59 2160p59.94b 2160p59b 2160p60 2160p60b 2160p23 2160p24 2160p25 2160p29 2160p30"`
	VolumeValue      *float64        `json:"volume,omitempty" validate:"omitempty"`
	VbiLinesValue    []*VbiLinesImpl `json:"vbi_lines,omitempty" validate:"omitempty"`
}

type StreamPushSrtImpl struct {
	PnrValue                *int                  `json:"pnr,omitempty" validate:"omitempty"`
	LingerValue             *Seconds              `json:"linger,omitempty" validate:"omitempty"`
	ConnectTimeoutValue     *Seconds              `json:"connect_timeout,omitempty" validate:"omitempty"`
	DisabledValue           *bool                 `json:"disabled,omitempty" validate:"omitempty"`
	EnforcedencryptionValue *bool                 `json:"enforcedencryption,omitempty" validate:"omitempty"`
	LatencyValue            *Milliseconds         `json:"latency,omitempty" validate:"omitempty"`
	PidsValue               *OutputMpegtsPidsImpl `json:"pids,omitempty" validate:"omitempty"`
	MinversionValue         *string               `json:"minversion,omitempty" validate:"omitempty"`
	MpegtsAc3Value          *OutputMpegtsAc3      `json:"mpegts_ac3,omitempty" validate:"omitempty"`
	MulticastLoopValue      *bool                 `json:"multicast_loop,omitempty" validate:"omitempty"`
	CommentValue            *string               `json:"comment,omitempty" validate:"omitempty"`
	PassphraseValue         *string               `json:"passphrase,omitempty" validate:"omitempty,min=10,max=79"`
	ServiceValue            *string               `json:"service,omitempty" validate:"omitempty"`
	ProviderValue           *string               `json:"provider,omitempty" validate:"omitempty"`
	RetryLimitValue         *int                  `json:"retry_limit,omitempty" validate:"omitempty"`
	RetryTimeoutValue       *Seconds              `json:"retry_timeout,omitempty" validate:"omitempty"`
	BitrateValue            *Speed                `json:"bitrate,omitempty" validate:"omitempty"`
	StandbyValue            *bool                 `json:"standby,omitempty" validate:"omitempty"`
	StatsValue              *PushCountersImpl     `json:"stats,omitempty" validate:"omitempty"`
	StreamidValue           *string               `json:"streamid,omitempty" validate:"omitempty,max=512"`
	TimeoutValue            *Seconds              `json:"timeout,omitempty" validate:"omitempty"`
	VersionValue            *string               `json:"version,omitempty" validate:"omitempty"`
	VbValue                 *Speed                `json:"vb,omitempty" validate:"omitempty"`
	URLValue                InputURL              `json:"url" validate:"required"`
}

type StreamPushSt2110Impl struct {
	CommentValue        *string           `json:"comment,omitempty" validate:"omitempty"`
	ConnectTimeoutValue *Seconds          `json:"connect_timeout,omitempty" validate:"omitempty"`
	DisabledValue       *bool             `json:"disabled,omitempty" validate:"omitempty"`
	RetryLimitValue     *int              `json:"retry_limit,omitempty" validate:"omitempty"`
	RetryTimeoutValue   *Seconds          `json:"retry_timeout,omitempty" validate:"omitempty"`
	StatsValue          *PushCountersImpl `json:"stats,omitempty" validate:"omitempty"`
	TimeoutValue        *Seconds          `json:"timeout,omitempty" validate:"omitempty"`
	URLValue            InputURL          `json:"url" validate:"required"`
}

type StreamPushTshttpImpl struct {
	PnrValue            *int                  `json:"pnr,omitempty" validate:"omitempty"`
	ServiceValue        *string               `json:"service,omitempty" validate:"omitempty"`
	ConnectTimeoutValue *Seconds              `json:"connect_timeout,omitempty" validate:"omitempty"`
	DisabledValue       *bool                 `json:"disabled,omitempty" validate:"omitempty"`
	MpegtsAc3Value      *OutputMpegtsAc3      `json:"mpegts_ac3,omitempty" validate:"omitempty"`
	PidsValue           *OutputMpegtsPidsImpl `json:"pids,omitempty" validate:"omitempty"`
	CommentValue        *string               `json:"comment,omitempty" validate:"omitempty"`
	RetryLimitValue     *int                  `json:"retry_limit,omitempty" validate:"omitempty"`
	BitrateValue        *Speed                `json:"bitrate,omitempty" validate:"omitempty"`
	RetryTimeoutValue   *Seconds              `json:"retry_timeout,omitempty" validate:"omitempty"`
	ProviderValue       *string               `json:"provider,omitempty" validate:"omitempty"`
	StatsValue          *PushCountersImpl     `json:"stats,omitempty" validate:"omitempty"`
	TimeoutValue        *Seconds              `json:"timeout,omitempty" validate:"omitempty"`
	VbValue             *Speed                `json:"vb,omitempty" validate:"omitempty"`
	URLValue            InputURL              `json:"url" validate:"required"`
}

type StreamPushUDPImpl struct {
	ProviderValue       *string               `json:"provider,omitempty" validate:"omitempty"`
	RetryLimitValue     *int                  `json:"retry_limit,omitempty" validate:"omitempty"`
	ConnectTimeoutValue *Seconds              `json:"connect_timeout,omitempty" validate:"omitempty"`
	DisabledValue       *bool                 `json:"disabled,omitempty" validate:"omitempty"`
	MpegtsAc3Value      *OutputMpegtsAc3      `json:"mpegts_ac3,omitempty" validate:"omitempty"`
	MulticastLoopValue  *bool                 `json:"multicast_loop,omitempty" validate:"omitempty"`
	PidsValue           *OutputMpegtsPidsImpl `json:"pids,omitempty" validate:"omitempty"`
	PnrValue            *int                  `json:"pnr,omitempty" validate:"omitempty"`
	CommentValue        *string               `json:"comment,omitempty" validate:"omitempty"`
	RetryTimeoutValue   *Seconds              `json:"retry_timeout,omitempty" validate:"omitempty"`
	BitrateValue        *Speed                `json:"bitrate,omitempty" validate:"omitempty"`
	ServiceValue        *string               `json:"service,omitempty" validate:"omitempty"`
	StandbyValue        *bool                 `json:"standby,omitempty" validate:"omitempty"`
	StatsValue          *PushCountersImpl     `json:"stats,omitempty" validate:"omitempty"`
	TimeoutValue        *Seconds              `json:"timeout,omitempty" validate:"omitempty"`
	VbValue             *Speed                `json:"vb,omitempty" validate:"omitempty"`
	URLValue            InputURL              `json:"url" validate:"required"`
}

type StreamPushUDPBaseImpl struct {
	MulticastLoopValue *bool `json:"multicast_loop,omitempty" validate:"omitempty"`
	StandbyValue       *bool `json:"standby,omitempty" validate:"omitempty"`
}

type StreamStatsImpl struct {
	LastRunningAtValue     *UtcMs         `json:"last_running_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	LifetimeValue          *Milliseconds  `json:"lifetime,omitempty" validate:"omitempty"`
	BitrateValue           *Speed         `json:"bitrate,omitempty" validate:"omitempty" openmetrics_metric:"stream_bitrate"`
	BytesOutValue          *Bytes         `json:"bytes_out,omitempty" validate:"omitempty" openmetrics_metric:"stream_bytes_out"`
	CurrentAgentIDValue    *AgentID       `json:"current_agent_id,omitempty" validate:"omitempty"`
	DvrInfoValue           *DvrInfoImpl   `json:"dvr_info,omitempty" validate:"omitempty"`
	AliveValue             *bool          `json:"alive,omitempty" validate:"omitempty"`
	EpisodesDensityValue   *Float         `json:"episodes_density,omitempty" validate:"omitempty"`
	AgentStatusValue       *string        `json:"agent_status,omitempty" validate:"omitempty"`
	LastDtsAtValue         *UtcMs         `json:"last_dts_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	MediaInfoValue         *MediaInfoImpl `json:"media_info,omitempty" validate:"omitempty"`
	OnlineClientsValue     *ClientCount   `json:"online_clients,omitempty" validate:"omitempty" openmetrics_metric:"stream_online_clients"`
	TSDelayValue           *Ticks         `json:"ts_delay,omitempty" validate:"omitempty"`
	StatusValue            *StreamStatus  `json:"status,omitempty" validate:"omitempty"`
	StreamingEndpointValue *string        `json:"streaming_endpoint,omitempty" validate:"omitempty"`
	RunningOnValue         []ServerName   `json:"running_on,omitempty" validate:"omitempty"`
}

type StreamerConfigImpl struct {
	IsRestreamerValue      *bool                          `json:"is_restreamer,omitempty" validate:"omitempty"`
	PublicPayloadURLValue  *URL                           `json:"public_payload_url,omitempty" validate:"omitempty"`
	ClusterKeyValue        *string                        `json:"cluster_key,omitempty" validate:"omitempty"`
	ConfigValue            *CentralStreamerNodeConfigImpl `json:"config,omitempty" validate:"omitempty"`
	CpuLimitValue          *Percent                       `json:"cpu_limit,omitempty" validate:"omitempty,min=0,max=100"`
	TotalBandwidthValue    *Speed                         `json:"total_bandwidth,omitempty" validate:"omitempty"`
	FetchTimeoutValue      *Milliseconds                  `json:"fetch_timeout,omitempty" validate:"omitempty"`
	HostnameValue          *ServerName                    `json:"hostname,omitempty" validate:"omitempty"`
	ChannelLimitValue      *int                           `json:"channel_limit,omitempty" validate:"omitempty"`
	MaxBitrateValue        *Speed                         `json:"max_bitrate,omitempty" validate:"omitempty"`
	LabelsValue            map[string]UnixName            `json:"labels,omitempty" validate:"omitempty"`
	NamespaceValue         *UnixName                      `json:"namespace,omitempty" validate:"omitempty"`
	PrivatePayloadURLValue *URL                           `json:"private_payload_url,omitempty" validate:"omitempty"`
	APIURLValue            *URL                           `json:"api_url,omitempty" validate:"omitempty"`
	RoleValue              *CentralNodeRoleRole           `json:"role,omitempty" validate:"omitempty,oneof=streamer inference identification"`
	StaleTimeoutValue      *Milliseconds                  `json:"stale_timeout,omitempty" validate:"omitempty"`
	StatsValue             *PeerStatsImpl                 `json:"stats,omitempty" validate:"omitempty"`
	DvrsValue              []*DvrConfigImpl               `json:"dvrs,omitempty" validate:"omitempty"`
}

type StreamersListImpl struct {
	TimingValue         any                   `json:"timing,omitempty" validate:"omitempty"`
	EstimatedCountValue *int                  `json:"estimated_count,omitempty" validate:"omitempty"`
	NextValue           *string               `json:"next,omitempty" validate:"omitempty"`
	PrevValue           *string               `json:"prev,omitempty" validate:"omitempty"`
	StreamersValue      []*StreamerConfigImpl `json:"streamers,omitempty" validate:"omitempty"`
}

type StreamsListImpl struct {
	TimingValue         any                 `json:"timing,omitempty" validate:"omitempty"`
	EstimatedCountValue *int                `json:"estimated_count,omitempty" validate:"omitempty"`
	NextValue           *string             `json:"next,omitempty" validate:"omitempty"`
	PrevValue           *string             `json:"prev,omitempty" validate:"omitempty"`
	UpdatedAtValue      *UtcMs              `json:"updated_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	StreamsValue        []*StreamConfigImpl `json:"streams,omitempty" validate:"omitempty"`
}

type TcAudioAacImpl struct {
	AvolValue          *string                   `json:"avol,omitempty" validate:"omitempty"`
	BitrateValue       *TcBitrate                `json:"bitrate,omitempty" validate:"omitempty"`
	ChannelsValue      *TiAudioAacSpecChannels   `json:"channels,omitempty" validate:"omitempty,oneof=1 2 3 4 5 6 7"`
	CodecValue         *string                   `json:"codec,omitempty" validate:"omitempty,oneof=aac mp3 mp2a opus ac3 eac3 pcma pcmu pcm"`
	SampleRateValue    *TiAudioAacSpecSampleRate `json:"sample_rate,omitempty" validate:"omitempty,oneof=96000 88200 64000 48000 44100 32000 24000 22050 16000 12000 11025 8000 0"`
	SplitChannelsValue *bool                     `json:"split_channels,omitempty" validate:"omitempty"`
}

type TcAudioAc3Impl struct {
	AvolValue          *string                   `json:"avol,omitempty" validate:"omitempty"`
	BitrateValue       *TcBitrate                `json:"bitrate,omitempty" validate:"omitempty"`
	ChannelsValue      *TiAudioAc3SpecChannels   `json:"channels,omitempty" validate:"omitempty,oneof=1 2 3 4 5 6"`
	CodecValue         *string                   `json:"codec,omitempty" validate:"omitempty,oneof=aac mp3 mp2a opus ac3 eac3 pcma pcmu pcm"`
	SampleRateValue    *TiAudioAc3SpecSampleRate `json:"sample_rate,omitempty" validate:"omitempty,oneof=48000 44100 32000 0"`
	SplitChannelsValue *bool                     `json:"split_channels,omitempty" validate:"omitempty"`
}

type TcAudioBaseImpl struct {
	AvolValue          *string    `json:"avol,omitempty" validate:"omitempty"`
	BitrateValue       *TcBitrate `json:"bitrate,omitempty" validate:"omitempty"`
	CodecValue         *string    `json:"codec,omitempty" validate:"omitempty,oneof=aac mp3 mp2a opus ac3 eac3 pcma pcmu pcm"`
	SplitChannelsValue *bool      `json:"split_channels,omitempty" validate:"omitempty"`
}

type TcAudioMp2aImpl struct {
	AvolValue          *string                    `json:"avol,omitempty" validate:"omitempty"`
	BitrateValue       *TcBitrate                 `json:"bitrate,omitempty" validate:"omitempty"`
	ChannelsValue      *TiAudioMp2aSpecChannels   `json:"channels,omitempty" validate:"omitempty,oneof=1 2"`
	CodecValue         *string                    `json:"codec,omitempty" validate:"omitempty,oneof=aac mp3 mp2a opus ac3 eac3 pcma pcmu pcm"`
	SampleRateValue    *TiAudioMp2aSpecSampleRate `json:"sample_rate,omitempty" validate:"omitempty,oneof=48000 44100 32000 24000 22050 16000 0"`
	SplitChannelsValue *bool                      `json:"split_channels,omitempty" validate:"omitempty"`
}

type TcAudioMp3Impl struct {
	AvolValue          *string                   `json:"avol,omitempty" validate:"omitempty"`
	BitrateValue       *TcBitrate                `json:"bitrate,omitempty" validate:"omitempty"`
	ChannelsValue      *TiAudioMp3SpecChannels   `json:"channels,omitempty" validate:"omitempty,oneof=1 2"`
	CodecValue         *string                   `json:"codec,omitempty" validate:"omitempty,oneof=aac mp3 mp2a opus ac3 eac3 pcma pcmu pcm"`
	SampleRateValue    *TiAudioMp3SpecSampleRate `json:"sample_rate,omitempty" validate:"omitempty,oneof=48000 44100 32000 24000 22050 16000 12000 11025 8000 0"`
	SplitChannelsValue *bool                     `json:"split_channels,omitempty" validate:"omitempty"`
}

type TcAudioOptsImpl struct {
	AvolValue          *string    `json:"avol,omitempty" validate:"omitempty"`
	BitrateValue       *TcBitrate `json:"bitrate,omitempty" validate:"omitempty"`
	ChannelsValue      any        `json:"channels,omitempty" validate:"omitempty,oneof=1 2 3 4 5 6 7"`
	CodecValue         *string    `json:"codec,omitempty" validate:"omitempty,oneof=aac mp3 mp2a opus ac3 eac3 pcma pcmu pcm"`
	SampleRateValue    any        `json:"sample_rate,omitempty" validate:"omitempty,oneof=96000 88200 64000 48000 44100 32000 24000 22050 16000 12000 11025 8000 0"`
	SplitChannelsValue *bool      `json:"split_channels,omitempty" validate:"omitempty"`
}

type TcAudioOpusImpl struct {
	AvolValue          *string                    `json:"avol,omitempty" validate:"omitempty"`
	BitrateValue       *TcBitrate                 `json:"bitrate,omitempty" validate:"omitempty"`
	ChannelsValue      *TiAudioOpusSpecChannels   `json:"channels,omitempty" validate:"omitempty,oneof=1 2 3 4 5 6"`
	CodecValue         *string                    `json:"codec,omitempty" validate:"omitempty,oneof=aac mp3 mp2a opus ac3 eac3 pcma pcmu pcm"`
	SampleRateValue    *TiAudioOpusSpecSampleRate `json:"sample_rate,omitempty" validate:"omitempty,oneof=48000 24000 16000 12000 8000 0"`
	SplitChannelsValue *bool                      `json:"split_channels,omitempty" validate:"omitempty"`
}

type TcAudioPcmImpl struct {
	AvolValue          *string    `json:"avol,omitempty" validate:"omitempty"`
	BitrateValue       *TcBitrate `json:"bitrate,omitempty" validate:"omitempty"`
	ChannelsValue      *int       `json:"channels,omitempty" validate:"omitempty"`
	CodecValue         *string    `json:"codec,omitempty" validate:"omitempty,oneof=aac mp3 mp2a opus ac3 eac3 pcma pcmu pcm"`
	SampleRateValue    *int       `json:"sample_rate,omitempty" validate:"omitempty"`
	SplitChannelsValue *bool      `json:"split_channels,omitempty" validate:"omitempty"`
}

type TcAudioPcmaImpl struct {
	AvolValue          *string                    `json:"avol,omitempty" validate:"omitempty"`
	BitrateValue       *TcBitrate                 `json:"bitrate,omitempty" validate:"omitempty"`
	ChannelsValue      *TiAudioPcmaSpecChannels   `json:"channels,omitempty" validate:"omitempty,oneof=1"`
	CodecValue         *string                    `json:"codec,omitempty" validate:"omitempty,oneof=aac mp3 mp2a opus ac3 eac3 pcma pcmu pcm"`
	SampleRateValue    *TiAudioPcmaSpecSampleRate `json:"sample_rate,omitempty" validate:"omitempty,oneof=8000 0"`
	SplitChannelsValue *bool                      `json:"split_channels,omitempty" validate:"omitempty"`
}

type TcBurnImpl struct {
	TextValue *TcLabelImpl `json:"text,omitempty" validate:"omitempty"`
	TimeValue *TcLabelImpl `json:"time,omitempty" validate:"omitempty"`
}

// Required: left, top, width, height
type TcCropImpl struct {
	HeightValue int `json:"height" validate:"required"`
	LeftValue   int `json:"left" validate:"required"`
	TopValue    int `json:"top" validate:"required"`
	WidthValue  int `json:"width" validate:"required"`
}

type TcDecoderImpl struct {
	CropValue              *TcCropImpl               `json:"crop,omitempty" validate:"omitempty"`
	DeinterlaceValue       *DeinterlaceSettings      `json:"deinterlace,omitempty" validate:"omitempty"`
	DeinterlaceRateValue   *TcDecoderDeinterlaceRate `json:"deinterlace_rate,omitempty" validate:"omitempty,oneof=frame field"`
	DropFrameIntervalValue *int                      `json:"drop_frame_interval,omitempty" validate:"omitempty,min=1,max=1000"`
	NoDpbValue             *bool                     `json:"no_dpb,omitempty" validate:"omitempty"`
	PixFmtValue            *FrameVideoPixFmt         `json:"pix_fmt,omitempty" validate:"omitempty"`
	StreamingFrameValue    *bool                     `json:"streaming_frame,omitempty" validate:"omitempty"`
}

type TcGlobalImpl struct {
	BurnValue     *TcBurnImpl       `json:"burn,omitempty" validate:"omitempty"`
	DeviceidValue *TcDeviceid       `json:"deviceid,omitempty" validate:"omitempty"`
	ExternalValue *bool             `json:"external,omitempty" validate:"omitempty"`
	GopValue      *int              `json:"gop,omitempty" validate:"omitempty"`
	HwValue       *TranscoderDevice `json:"hw,omitempty" validate:"omitempty"`
	TargetValue   *TranscoderTarget `json:"target,omitempty" validate:"omitempty"`
}

type TcLabelImpl struct {
	BoxValue      *TcLabelBoxImpl  `json:"box,omitempty" validate:"omitempty"`
	FontValue     *TcLabelFontImpl `json:"font,omitempty" validate:"omitempty"`
	PositionValue *TcLabelPosition `json:"position,omitempty" validate:"omitempty,oneof=tl bl tr br c ct cb"`
	TextValue     *string          `json:"text,omitempty" validate:"omitempty"`
	XValue        *int             `json:"x,omitempty" validate:"omitempty"`
	YValue        *int             `json:"y,omitempty" validate:"omitempty"`
}

type TcLabelBoxImpl struct {
	AlphaValue   *float64 `json:"alpha,omitempty" validate:"omitempty,min=0,max=1"`
	BorderwValue *int     `json:"borderw,omitempty" validate:"omitempty"`
	ColorValue   *string  `json:"color,omitempty" validate:"omitempty"`
}

type TcLabelFontImpl struct {
	AlphaValue *float64 `json:"alpha,omitempty" validate:"omitempty,min=0,max=1"`
	ColorValue *string  `json:"color,omitempty" validate:"omitempty"`
	FileValue  *string  `json:"file,omitempty" validate:"omitempty"`
	SizeValue  *int     `json:"size,omitempty" validate:"omitempty"`
}

type TcLogoImpl struct {
	PathValue     *string         `json:"path,omitempty" validate:"omitempty"`
	PositionValue *TcLogoPosition `json:"position,omitempty" validate:"omitempty,oneof=tl tr bl br c"`
	XValue        *int            `json:"x,omitempty" validate:"omitempty"`
	YValue        *int            `json:"y,omitempty" validate:"omitempty"`
}

type TcQpRangeImpl struct {
	QpmaxbValue *int `json:"qpmaxb,omitempty" validate:"omitempty,min=0,max=100"`
	QpmaxiValue *int `json:"qpmaxi,omitempty" validate:"omitempty,min=0,max=100"`
	QpmaxpValue *int `json:"qpmaxp,omitempty" validate:"omitempty,min=0,max=100"`
	QpminbValue *int `json:"qpminb,omitempty" validate:"omitempty,min=0,max=100"`
	QpminiValue *int `json:"qpmini,omitempty" validate:"omitempty,min=0,max=100"`
	QpminpValue *int `json:"qpminp,omitempty" validate:"omitempty,min=0,max=100"`
}

type TcSarImpl struct {
	XValue *int `json:"x,omitempty" validate:"omitempty"`
	YValue *int `json:"y,omitempty" validate:"omitempty"`
}

type TcSizeImpl struct {
	BackgroundValue *string         `json:"background,omitempty" validate:"omitempty"`
	HeightValue     *int            `json:"height,omitempty" validate:"omitempty,min=-1"`
	StrategyValue   *TcSizeStrategy `json:"strategy,omitempty" validate:"omitempty,oneof=crop scale fit"`
	WidthValue      *int            `json:"width,omitempty" validate:"omitempty,min=-1"`
}

// Required: track
type TcVideoOptsImpl struct {
	LevelValue            any                   `json:"level,omitempty" validate:"omitempty"`
	PresetValue           *TcPreset             `json:"preset,omitempty" validate:"omitempty"`
	BframesValue          *int                  `json:"bframes,omitempty" validate:"omitempty"`
	BurnValue             *TcBurnImpl           `json:"burn,omitempty" validate:"omitempty"`
	CodecValue            *TcVideoOptsCodec     `json:"codec,omitempty" validate:"omitempty,oneof=h264 hevc av1 mp2v"`
	ExtraValue            map[string]string     `json:"extra,omitempty" validate:"omitempty"`
	FPSValue              *TcFPS                `json:"fps,omitempty" validate:"omitempty"`
	GopValue              *int                  `json:"gop,omitempty" validate:"omitempty"`
	ProfileValue          *TcProfile            `json:"profile,omitempty" validate:"omitempty"`
	AlogoValue            *TcLogoImpl           `json:"alogo,omitempty" validate:"omitempty"`
	LogoValue             *TcLogoImpl           `json:"logo,omitempty" validate:"omitempty"`
	BitrateValue          *TcBitrate            `json:"bitrate,omitempty" validate:"omitempty"`
	OpenGopValue          *bool                 `json:"open_gop,omitempty" validate:"omitempty"`
	InterlaceValue        *InterlaceSettings    `json:"interlace,omitempty" validate:"omitempty"`
	QpRangeValue          *TcQpRangeImpl        `json:"qp_range,omitempty" validate:"omitempty"`
	RcMethodValue         *RcMethod             `json:"rc_method,omitempty" validate:"omitempty"`
	RefsValue             *int                  `json:"refs,omitempty" validate:"omitempty,min=1,max=6"`
	ResizeModeValue       *TranscoderResizeMode `json:"resize_mode,omitempty" validate:"omitempty"`
	SarValue              *TcSarImpl            `json:"sar,omitempty" validate:"omitempty"`
	SizeValue             *TcSizeImpl           `json:"size,omitempty" validate:"omitempty"`
	TemporalTradeoffValue *int                  `json:"temporal_tradeoff,omitempty" validate:"omitempty"`
	ThreadsValue          *int                  `json:"threads,omitempty" validate:"omitempty"`
	VbvBufsizeValue       *int                  `json:"vbv_bufsize,omitempty" validate:"omitempty"`
	TrackValue            int                   `json:"track" validate:"required"`
}

type ThumbnailsSizeSpecImpl struct {
	HeightValue *int `json:"height,omitempty" validate:"omitempty"`
	WidthValue  *int `json:"width,omitempty" validate:"omitempty"`
}

type ThumbnailsSpecImpl struct {
	EnabledValue any                       `json:"enabled,omitempty" validate:"omitempty"`
	URLValue     *string                   `json:"url,omitempty" validate:"omitempty"`
	SizesValue   []*ThumbnailsSizeSpecImpl `json:"sizes,omitempty" validate:"omitempty"`
}

type TiAudioAacImpl struct {
	BitrateValue       *Speed                    `json:"bitrate,omitempty" validate:"omitempty"`
	ChannelsValue      *TiAudioAacSpecChannels   `json:"channels,omitempty" validate:"omitempty,oneof=1 2 3 4 5 6 7"`
	CodecValue         *string                   `json:"codec,omitempty" validate:"omitempty,oneof=aac mp3 mp2a opus ac3 eac3 pcma pcmu"`
	InputTrackValue    *int                      `json:"input_track,omitempty" validate:"omitempty"`
	LanguageValue      *string                   `json:"language,omitempty" validate:"omitempty"`
	PidValue           *int                      `json:"pid,omitempty" validate:"omitempty"`
	SampleRateValue    *TiAudioAacSpecSampleRate `json:"sample_rate,omitempty" validate:"omitempty,oneof=96000 88200 64000 48000 44100 32000 24000 22050 16000 12000 11025 8000 0"`
	SplitChannelsValue *bool                     `json:"split_channels,omitempty" validate:"omitempty"`
	TitleValue         *string                   `json:"title,omitempty" validate:"omitempty"`
	VolumeValue        *string                   `json:"volume,omitempty" validate:"omitempty"`
	ContentValue       FrameContent              `json:"content" validate:"required"`
}

// Title: AAC codec
type TiAudioAacSpecImpl struct {
	ChannelsValue   *TiAudioAacSpecChannels   `json:"channels,omitempty" validate:"omitempty,oneof=1 2 3 4 5 6 7"`
	SampleRateValue *TiAudioAacSpecSampleRate `json:"sample_rate,omitempty" validate:"omitempty,oneof=96000 88200 64000 48000 44100 32000 24000 22050 16000 12000 11025 8000 0"`
}

type TiAudioAc3Impl struct {
	BitrateValue       *Speed                    `json:"bitrate,omitempty" validate:"omitempty"`
	ChannelsValue      *TiAudioAc3SpecChannels   `json:"channels,omitempty" validate:"omitempty,oneof=1 2 3 4 5 6"`
	CodecValue         *string                   `json:"codec,omitempty" validate:"omitempty,oneof=aac mp3 mp2a opus ac3 eac3 pcma pcmu"`
	InputTrackValue    *int                      `json:"input_track,omitempty" validate:"omitempty"`
	LanguageValue      *string                   `json:"language,omitempty" validate:"omitempty"`
	PidValue           *int                      `json:"pid,omitempty" validate:"omitempty"`
	SampleRateValue    *TiAudioAc3SpecSampleRate `json:"sample_rate,omitempty" validate:"omitempty,oneof=48000 44100 32000 0"`
	SplitChannelsValue *bool                     `json:"split_channels,omitempty" validate:"omitempty"`
	TitleValue         *string                   `json:"title,omitempty" validate:"omitempty"`
	VolumeValue        *string                   `json:"volume,omitempty" validate:"omitempty"`
	ContentValue       FrameContent              `json:"content" validate:"required"`
}

// Title: AC3/EAC3 codec
type TiAudioAc3SpecImpl struct {
	ChannelsValue   *TiAudioAc3SpecChannels   `json:"channels,omitempty" validate:"omitempty,oneof=1 2 3 4 5 6"`
	SampleRateValue *TiAudioAc3SpecSampleRate `json:"sample_rate,omitempty" validate:"omitempty,oneof=48000 44100 32000 0"`
}

type TiAudioMp2aImpl struct {
	BitrateValue       *Speed                     `json:"bitrate,omitempty" validate:"omitempty"`
	ChannelsValue      *TiAudioMp2aSpecChannels   `json:"channels,omitempty" validate:"omitempty,oneof=1 2"`
	CodecValue         *string                    `json:"codec,omitempty" validate:"omitempty,oneof=aac mp3 mp2a opus ac3 eac3 pcma pcmu"`
	InputTrackValue    *int                       `json:"input_track,omitempty" validate:"omitempty"`
	LanguageValue      *string                    `json:"language,omitempty" validate:"omitempty"`
	PidValue           *int                       `json:"pid,omitempty" validate:"omitempty"`
	SampleRateValue    *TiAudioMp2aSpecSampleRate `json:"sample_rate,omitempty" validate:"omitempty,oneof=48000 44100 32000 24000 22050 16000 0"`
	SplitChannelsValue *bool                      `json:"split_channels,omitempty" validate:"omitempty"`
	TitleValue         *string                    `json:"title,omitempty" validate:"omitempty"`
	VolumeValue        *string                    `json:"volume,omitempty" validate:"omitempty"`
	ContentValue       FrameContent               `json:"content" validate:"required"`
}

// Title: MP2 audio codec
type TiAudioMp2aSpecImpl struct {
	ChannelsValue   *TiAudioMp2aSpecChannels   `json:"channels,omitempty" validate:"omitempty,oneof=1 2"`
	SampleRateValue *TiAudioMp2aSpecSampleRate `json:"sample_rate,omitempty" validate:"omitempty,oneof=48000 44100 32000 24000 22050 16000 0"`
}

type TiAudioMp3Impl struct {
	BitrateValue       *Speed                    `json:"bitrate,omitempty" validate:"omitempty"`
	ChannelsValue      *TiAudioMp3SpecChannels   `json:"channels,omitempty" validate:"omitempty,oneof=1 2"`
	CodecValue         *string                   `json:"codec,omitempty" validate:"omitempty,oneof=aac mp3 mp2a opus ac3 eac3 pcma pcmu"`
	InputTrackValue    *int                      `json:"input_track,omitempty" validate:"omitempty"`
	LanguageValue      *string                   `json:"language,omitempty" validate:"omitempty"`
	PidValue           *int                      `json:"pid,omitempty" validate:"omitempty"`
	SampleRateValue    *TiAudioMp3SpecSampleRate `json:"sample_rate,omitempty" validate:"omitempty,oneof=48000 44100 32000 24000 22050 16000 12000 11025 8000 0"`
	SplitChannelsValue *bool                     `json:"split_channels,omitempty" validate:"omitempty"`
	TitleValue         *string                   `json:"title,omitempty" validate:"omitempty"`
	VolumeValue        *string                   `json:"volume,omitempty" validate:"omitempty"`
	ContentValue       FrameContent              `json:"content" validate:"required"`
}

// Title: MP3 codec
type TiAudioMp3SpecImpl struct {
	ChannelsValue   *TiAudioMp3SpecChannels   `json:"channels,omitempty" validate:"omitempty,oneof=1 2"`
	SampleRateValue *TiAudioMp3SpecSampleRate `json:"sample_rate,omitempty" validate:"omitempty,oneof=48000 44100 32000 24000 22050 16000 12000 11025 8000 0"`
}

type TiAudioOpusImpl struct {
	BitrateValue       *Speed                     `json:"bitrate,omitempty" validate:"omitempty"`
	ChannelsValue      *TiAudioOpusSpecChannels   `json:"channels,omitempty" validate:"omitempty,oneof=1 2 3 4 5 6"`
	CodecValue         *string                    `json:"codec,omitempty" validate:"omitempty,oneof=aac mp3 mp2a opus ac3 eac3 pcma pcmu"`
	InputTrackValue    *int                       `json:"input_track,omitempty" validate:"omitempty"`
	LanguageValue      *string                    `json:"language,omitempty" validate:"omitempty"`
	PidValue           *int                       `json:"pid,omitempty" validate:"omitempty"`
	SampleRateValue    *TiAudioOpusSpecSampleRate `json:"sample_rate,omitempty" validate:"omitempty,oneof=48000 24000 16000 12000 8000 0"`
	SplitChannelsValue *bool                      `json:"split_channels,omitempty" validate:"omitempty"`
	TitleValue         *string                    `json:"title,omitempty" validate:"omitempty"`
	VolumeValue        *string                    `json:"volume,omitempty" validate:"omitempty"`
	ContentValue       FrameContent               `json:"content" validate:"required"`
}

// Title: OPUS codec
type TiAudioOpusSpecImpl struct {
	ChannelsValue   *TiAudioOpusSpecChannels   `json:"channels,omitempty" validate:"omitempty,oneof=1 2 3 4 5 6"`
	SampleRateValue *TiAudioOpusSpecSampleRate `json:"sample_rate,omitempty" validate:"omitempty,oneof=48000 24000 16000 12000 8000 0"`
}

type TiAudioPcmImpl struct {
	BitrateValue       *Speed       `json:"bitrate,omitempty" validate:"omitempty"`
	ChannelsValue      *int         `json:"channels,omitempty" validate:"omitempty"`
	CodecValue         *string      `json:"codec,omitempty" validate:"omitempty,oneof=aac mp3 mp2a opus ac3 eac3 pcma pcmu"`
	InputTrackValue    *int         `json:"input_track,omitempty" validate:"omitempty"`
	LanguageValue      *string      `json:"language,omitempty" validate:"omitempty"`
	PidValue           *int         `json:"pid,omitempty" validate:"omitempty"`
	SampleRateValue    *int         `json:"sample_rate,omitempty" validate:"omitempty"`
	SplitChannelsValue *bool        `json:"split_channels,omitempty" validate:"omitempty"`
	TitleValue         *string      `json:"title,omitempty" validate:"omitempty"`
	VolumeValue        *string      `json:"volume,omitempty" validate:"omitempty"`
	ContentValue       FrameContent `json:"content" validate:"required"`
}

// Title: RAW PCM
type TiAudioPcmSpecImpl struct {
	ChannelsValue   *int `json:"channels,omitempty" validate:"omitempty"`
	SampleRateValue *int `json:"sample_rate,omitempty" validate:"omitempty"`
}

type TiAudioPcmaImpl struct {
	BitrateValue       *Speed                     `json:"bitrate,omitempty" validate:"omitempty"`
	ChannelsValue      *TiAudioPcmaSpecChannels   `json:"channels,omitempty" validate:"omitempty,oneof=1"`
	CodecValue         *string                    `json:"codec,omitempty" validate:"omitempty,oneof=aac mp3 mp2a opus ac3 eac3 pcma pcmu"`
	InputTrackValue    *int                       `json:"input_track,omitempty" validate:"omitempty"`
	LanguageValue      *string                    `json:"language,omitempty" validate:"omitempty"`
	PidValue           *int                       `json:"pid,omitempty" validate:"omitempty"`
	SampleRateValue    *TiAudioPcmaSpecSampleRate `json:"sample_rate,omitempty" validate:"omitempty,oneof=8000 0"`
	SplitChannelsValue *bool                      `json:"split_channels,omitempty" validate:"omitempty"`
	TitleValue         *string                    `json:"title,omitempty" validate:"omitempty"`
	VolumeValue        *string                    `json:"volume,omitempty" validate:"omitempty"`
	ContentValue       FrameContent               `json:"content" validate:"required"`
}

// Title: PCM A-law/PCM mu-law codec
type TiAudioPcmaSpecImpl struct {
	ChannelsValue   *TiAudioPcmaSpecChannels   `json:"channels,omitempty" validate:"omitempty,oneof=1"`
	SampleRateValue *TiAudioPcmaSpecSampleRate `json:"sample_rate,omitempty" validate:"omitempty,oneof=8000 0"`
}

type TrackInfoImpl struct {
	TrackIDValue        any                   `json:"track_id,omitempty" validate:"omitempty"`
	LanguageValue       *string               `json:"language,omitempty" validate:"omitempty"`
	PixFmtValue         *FrameVideoPixFmt     `json:"pix_fmt,omitempty" validate:"omitempty"`
	BframesValue        *int                  `json:"bframes,omitempty" validate:"omitempty"`
	BitrateValue        *Speed                `json:"bitrate,omitempty" validate:"omitempty"`
	ChannelsValue       *int                  `json:"channels,omitempty" validate:"omitempty"`
	WidthValue          *Pixels               `json:"width,omitempty" validate:"omitempty"`
	CodecValue          *FrameCodec           `json:"codec,omitempty" validate:"omitempty"`
	AvgGopValue         *int                  `json:"avg_gop,omitempty" validate:"omitempty"`
	FPSValue            *float64              `json:"fps,omitempty" validate:"omitempty"`
	FrameDurationValue  *Ticks                `json:"frame_duration,omitempty" validate:"omitempty"`
	GopSizeValue        *int                  `json:"gop_size,omitempty" validate:"omitempty"`
	HeightValue         *Pixels               `json:"height,omitempty" validate:"omitempty"`
	IsProgressiveValue  *bool                 `json:"is_progressive,omitempty" validate:"omitempty"`
	AvgFPSValue         *float64              `json:"avg_fps,omitempty" validate:"omitempty"`
	BandwidthValue      *Speed                `json:"bandwidth,omitempty" validate:"omitempty"`
	LevelValue          *string               `json:"level,omitempty" validate:"omitempty"`
	LastGopValue        *int                  `json:"last_gop,omitempty" validate:"omitempty"`
	NumRefsFramesValue  *int                  `json:"num_refs_frames,omitempty" validate:"omitempty,min=0,max=32"`
	PidValue            *int                  `json:"pid,omitempty" validate:"omitempty"`
	LengthSizeValue     *int                  `json:"length_size,omitempty" validate:"omitempty"`
	PixelHeightValue    *Pixels               `json:"pixel_height,omitempty" validate:"omitempty"`
	PixelWidthValue     *Pixels               `json:"pixel_width,omitempty" validate:"omitempty"`
	ProfileValue        *string               `json:"profile,omitempty" validate:"omitempty"`
	SampleRateValue     *int                  `json:"sample_rate,omitempty" validate:"omitempty"`
	SarHeightValue      *int                  `json:"sar_height,omitempty" validate:"omitempty"`
	SarWidthValue       *int                  `json:"sar_width,omitempty" validate:"omitempty"`
	TitleValue          *string               `json:"title,omitempty" validate:"omitempty"`
	ContentValue        FrameContent          `json:"content" validate:"required"`
	ClosedCaptionsValue []*ClosedCaptionsImpl `json:"closed_captions,omitempty" validate:"omitempty"`
}

type TrackInfoApplicationImpl struct {
	TrackIDValue       any          `json:"track_id,omitempty" validate:"omitempty"`
	AvgFPSValue        *float64     `json:"avg_fps,omitempty" validate:"omitempty"`
	BandwidthValue     *Speed       `json:"bandwidth,omitempty" validate:"omitempty"`
	BitrateValue       *Speed       `json:"bitrate,omitempty" validate:"omitempty"`
	CodecValue         *FrameCodec  `json:"codec,omitempty" validate:"omitempty"`
	FrameDurationValue *Ticks       `json:"frame_duration,omitempty" validate:"omitempty"`
	LanguageValue      *string      `json:"language,omitempty" validate:"omitempty"`
	PidValue           *int         `json:"pid,omitempty" validate:"omitempty"`
	TitleValue         *string      `json:"title,omitempty" validate:"omitempty"`
	ContentValue       FrameContent `json:"content" validate:"required"`
}

type TrackInfoApplicationSpecificImpl struct {
	LanguageValue *string `json:"language,omitempty" validate:"omitempty"`
}

type TrackInfoAudioImpl struct {
	TrackIDValue       any          `json:"track_id,omitempty" validate:"omitempty"`
	AvgFPSValue        *float64     `json:"avg_fps,omitempty" validate:"omitempty"`
	BandwidthValue     *Speed       `json:"bandwidth,omitempty" validate:"omitempty"`
	BitrateValue       *Speed       `json:"bitrate,omitempty" validate:"omitempty"`
	ChannelsValue      *int         `json:"channels,omitempty" validate:"omitempty"`
	CodecValue         *FrameCodec  `json:"codec,omitempty" validate:"omitempty"`
	FrameDurationValue *Ticks       `json:"frame_duration,omitempty" validate:"omitempty"`
	LanguageValue      *string      `json:"language,omitempty" validate:"omitempty"`
	PidValue           *int         `json:"pid,omitempty" validate:"omitempty"`
	SampleRateValue    *int         `json:"sample_rate,omitempty" validate:"omitempty"`
	TitleValue         *string      `json:"title,omitempty" validate:"omitempty"`
	ContentValue       FrameContent `json:"content" validate:"required"`
}

type TrackInfoAudioSpecificImpl struct {
	ChannelsValue   *int    `json:"channels,omitempty" validate:"omitempty"`
	LanguageValue   *string `json:"language,omitempty" validate:"omitempty"`
	SampleRateValue *int    `json:"sample_rate,omitempty" validate:"omitempty"`
}

type TrackInfoBaseImpl struct {
	AvgFPSValue        *float64 `json:"avg_fps,omitempty" validate:"omitempty"`
	BandwidthValue     *Speed   `json:"bandwidth,omitempty" validate:"omitempty"`
	FrameDurationValue *Ticks   `json:"frame_duration,omitempty" validate:"omitempty"`
	TrackIDValue       any      `json:"track_id,omitempty" validate:"omitempty"`
}

// Required: content
type TrackInfoBaseConfigurableImpl struct {
	BitrateValue *Speed       `json:"bitrate,omitempty" validate:"omitempty"`
	PidValue     *int         `json:"pid,omitempty" validate:"omitempty"`
	TitleValue   *string      `json:"title,omitempty" validate:"omitempty"`
	ContentValue FrameContent `json:"content" validate:"required"`
}

type TrackInfoFullImpl struct {
	TrackIDValue        any                   `json:"track_id,omitempty" validate:"omitempty"`
	LanguageValue       *string               `json:"language,omitempty" validate:"omitempty"`
	PixFmtValue         *FrameVideoPixFmt     `json:"pix_fmt,omitempty" validate:"omitempty"`
	BframesValue        *int                  `json:"bframes,omitempty" validate:"omitempty"`
	BitrateValue        *Speed                `json:"bitrate,omitempty" validate:"omitempty"`
	ChannelsValue       *int                  `json:"channels,omitempty" validate:"omitempty"`
	WidthValue          *Pixels               `json:"width,omitempty" validate:"omitempty"`
	CodecValue          *FrameCodec           `json:"codec,omitempty" validate:"omitempty"`
	AvgGopValue         *int                  `json:"avg_gop,omitempty" validate:"omitempty"`
	FPSValue            *float64              `json:"fps,omitempty" validate:"omitempty"`
	FrameDurationValue  *Ticks                `json:"frame_duration,omitempty" validate:"omitempty"`
	GopSizeValue        *int                  `json:"gop_size,omitempty" validate:"omitempty"`
	HeightValue         *Pixels               `json:"height,omitempty" validate:"omitempty"`
	IsProgressiveValue  *bool                 `json:"is_progressive,omitempty" validate:"omitempty"`
	AvgFPSValue         *float64              `json:"avg_fps,omitempty" validate:"omitempty"`
	BandwidthValue      *Speed                `json:"bandwidth,omitempty" validate:"omitempty"`
	LevelValue          *string               `json:"level,omitempty" validate:"omitempty"`
	LastGopValue        *int                  `json:"last_gop,omitempty" validate:"omitempty"`
	NumRefsFramesValue  *int                  `json:"num_refs_frames,omitempty" validate:"omitempty,min=0,max=32"`
	PidValue            *int                  `json:"pid,omitempty" validate:"omitempty"`
	LengthSizeValue     *int                  `json:"length_size,omitempty" validate:"omitempty"`
	PixelHeightValue    *Pixels               `json:"pixel_height,omitempty" validate:"omitempty"`
	PixelWidthValue     *Pixels               `json:"pixel_width,omitempty" validate:"omitempty"`
	ProfileValue        *string               `json:"profile,omitempty" validate:"omitempty"`
	SampleRateValue     *int                  `json:"sample_rate,omitempty" validate:"omitempty"`
	SarHeightValue      *int                  `json:"sar_height,omitempty" validate:"omitempty"`
	SarWidthValue       *int                  `json:"sar_width,omitempty" validate:"omitempty"`
	TitleValue          *string               `json:"title,omitempty" validate:"omitempty"`
	ContentValue        FrameContent          `json:"content" validate:"required"`
	ClosedCaptionsValue []*ClosedCaptionsImpl `json:"closed_captions,omitempty" validate:"omitempty"`
}

type TrackInfoMetadataImpl struct {
	TrackIDValue       any          `json:"track_id,omitempty" validate:"omitempty"`
	AvgFPSValue        *float64     `json:"avg_fps,omitempty" validate:"omitempty"`
	BandwidthValue     *Speed       `json:"bandwidth,omitempty" validate:"omitempty"`
	BitrateValue       *Speed       `json:"bitrate,omitempty" validate:"omitempty"`
	CodecValue         *FrameCodec  `json:"codec,omitempty" validate:"omitempty"`
	FrameDurationValue *Ticks       `json:"frame_duration,omitempty" validate:"omitempty"`
	PidValue           *int         `json:"pid,omitempty" validate:"omitempty"`
	TitleValue         *string      `json:"title,omitempty" validate:"omitempty"`
	ContentValue       FrameContent `json:"content" validate:"required"`
}

type TrackInfoTextImpl struct {
	TrackIDValue       any          `json:"track_id,omitempty" validate:"omitempty"`
	AvgFPSValue        *float64     `json:"avg_fps,omitempty" validate:"omitempty"`
	BandwidthValue     *Speed       `json:"bandwidth,omitempty" validate:"omitempty"`
	BitrateValue       *Speed       `json:"bitrate,omitempty" validate:"omitempty"`
	CodecValue         *FrameCodec  `json:"codec,omitempty" validate:"omitempty"`
	FrameDurationValue *Ticks       `json:"frame_duration,omitempty" validate:"omitempty"`
	LanguageValue      *string      `json:"language,omitempty" validate:"omitempty"`
	PidValue           *int         `json:"pid,omitempty" validate:"omitempty"`
	TitleValue         *string      `json:"title,omitempty" validate:"omitempty"`
	ContentValue       FrameContent `json:"content" validate:"required"`
}

type TrackInfoTextSpecificImpl struct {
	LanguageValue *string `json:"language,omitempty" validate:"omitempty"`
}

type TrackInfoVideoImpl struct {
	TrackIDValue        any                   `json:"track_id,omitempty" validate:"omitempty"`
	IsProgressiveValue  *bool                 `json:"is_progressive,omitempty" validate:"omitempty"`
	SarWidthValue       *int                  `json:"sar_width,omitempty" validate:"omitempty"`
	BframesValue        *int                  `json:"bframes,omitempty" validate:"omitempty"`
	BitrateValue        *Speed                `json:"bitrate,omitempty" validate:"omitempty"`
	WidthValue          *Pixels               `json:"width,omitempty" validate:"omitempty"`
	CodecValue          *FrameCodec           `json:"codec,omitempty" validate:"omitempty"`
	AvgGopValue         *int                  `json:"avg_gop,omitempty" validate:"omitempty"`
	FPSValue            *float64              `json:"fps,omitempty" validate:"omitempty"`
	FrameDurationValue  *Ticks                `json:"frame_duration,omitempty" validate:"omitempty"`
	GopSizeValue        *int                  `json:"gop_size,omitempty" validate:"omitempty"`
	HeightValue         *Pixels               `json:"height,omitempty" validate:"omitempty"`
	AvgFPSValue         *float64              `json:"avg_fps,omitempty" validate:"omitempty"`
	BandwidthValue      *Speed                `json:"bandwidth,omitempty" validate:"omitempty"`
	LastGopValue        *int                  `json:"last_gop,omitempty" validate:"omitempty"`
	PixelHeightValue    *Pixels               `json:"pixel_height,omitempty" validate:"omitempty"`
	NumRefsFramesValue  *int                  `json:"num_refs_frames,omitempty" validate:"omitempty,min=0,max=32"`
	PidValue            *int                  `json:"pid,omitempty" validate:"omitempty"`
	PixFmtValue         *FrameVideoPixFmt     `json:"pix_fmt,omitempty" validate:"omitempty"`
	LevelValue          *string               `json:"level,omitempty" validate:"omitempty"`
	PixelWidthValue     *Pixels               `json:"pixel_width,omitempty" validate:"omitempty"`
	ProfileValue        *string               `json:"profile,omitempty" validate:"omitempty"`
	SarHeightValue      *int                  `json:"sar_height,omitempty" validate:"omitempty"`
	LengthSizeValue     *int                  `json:"length_size,omitempty" validate:"omitempty"`
	TitleValue          *string               `json:"title,omitempty" validate:"omitempty"`
	ContentValue        FrameContent          `json:"content" validate:"required"`
	ClosedCaptionsValue []*ClosedCaptionsImpl `json:"closed_captions,omitempty" validate:"omitempty"`
}

type TrackInfoVideoConfigurableImpl struct {
	BframesValue       *int              `json:"bframes,omitempty" validate:"omitempty"`
	FPSValue           *float64          `json:"fps,omitempty" validate:"omitempty"`
	GopSizeValue       *int              `json:"gop_size,omitempty" validate:"omitempty"`
	HeightValue        *Pixels           `json:"height,omitempty" validate:"omitempty"`
	LevelValue         *string           `json:"level,omitempty" validate:"omitempty"`
	NumRefsFramesValue *int              `json:"num_refs_frames,omitempty" validate:"omitempty,min=0,max=32"`
	PixFmtValue        *FrameVideoPixFmt `json:"pix_fmt,omitempty" validate:"omitempty"`
	PixelHeightValue   *Pixels           `json:"pixel_height,omitempty" validate:"omitempty"`
	PixelWidthValue    *Pixels           `json:"pixel_width,omitempty" validate:"omitempty"`
	ProfileValue       *string           `json:"profile,omitempty" validate:"omitempty"`
	SarHeightValue     *int              `json:"sar_height,omitempty" validate:"omitempty"`
	SarWidthValue      *int              `json:"sar_width,omitempty" validate:"omitempty"`
	WidthValue         *Pixels           `json:"width,omitempty" validate:"omitempty"`
}

type TrackInfoVideoSpecificImpl struct {
	AvgGopValue         *int                  `json:"avg_gop,omitempty" validate:"omitempty"`
	IsProgressiveValue  *bool                 `json:"is_progressive,omitempty" validate:"omitempty"`
	LastGopValue        *int                  `json:"last_gop,omitempty" validate:"omitempty"`
	LengthSizeValue     *int                  `json:"length_size,omitempty" validate:"omitempty"`
	ClosedCaptionsValue []*ClosedCaptionsImpl `json:"closed_captions,omitempty" validate:"omitempty"`
}

type TranscoderDeviceStatsImpl struct {
	CanInterlaceValue    *bool              `json:"can_interlace,omitempty" validate:"omitempty"`
	CanInternalValue     *bool              `json:"can_internal,omitempty" validate:"omitempty"`
	CanLogoValue         *bool              `json:"can_logo,omitempty" validate:"omitempty"`
	GpuDecValue          *int               `json:"gpu_dec,omitempty" validate:"omitempty"`
	GpuEncValue          *int               `json:"gpu_enc,omitempty" validate:"omitempty"`
	GpuSmValue           *int               `json:"gpu_sm,omitempty" validate:"omitempty"`
	GpuTempValue         *int               `json:"gpu_temp,omitempty" validate:"omitempty"`
	IDValue              *TcDeviceid        `json:"id,omitempty" validate:"omitempty"`
	MemfreeValue         *int               `json:"memFree,omitempty" validate:"omitempty"`
	MemtotalValue        *int               `json:"memTotal,omitempty" validate:"omitempty"`
	MemusedValue         *int               `json:"memUsed,omitempty" validate:"omitempty"`
	NameValue            *string            `json:"name,omitempty" validate:"omitempty"`
	ReconfigSupportValue *TcReconfigSupport `json:"reconfig_support,omitempty" validate:"omitempty"`
	TypeValue            *TranscoderDevice  `json:"type,omitempty" validate:"omitempty"`
}

type TranscoderOptsImpl struct {
	AudioValue   *TcAudioOptsImpl           `json:"audio,omitempty" validate:"omitempty"`
	DecoderValue *TcDecoderImpl             `json:"decoder,omitempty" validate:"omitempty"`
	GlobalValue  *TcGlobalImpl              `json:"global,omitempty" validate:"omitempty"`
	TracksValue  []*TranscoderTrackInfoImpl `json:"tracks,omitempty" validate:"omitempty"`
	VideoValue   []*TcVideoOptsImpl         `json:"video,omitempty" validate:"omitempty"`
}

type TranscoderTrackInfoImpl struct {
	LevelValue            any                   `json:"level,omitempty" validate:"omitempty"`
	OpenGopValue          *bool                 `json:"open_gop,omitempty" validate:"omitempty"`
	TemporalTradeoffValue *int                  `json:"temporal_tradeoff,omitempty" validate:"omitempty"`
	BurnValue             *TcBurnImpl           `json:"burn,omitempty" validate:"omitempty"`
	CodecValue            *FrameCodec           `json:"codec,omitempty" validate:"omitempty"`
	VbvBufsizeValue       *int                  `json:"vbv_bufsize,omitempty" validate:"omitempty"`
	ExtraValue            map[string]string     `json:"extra,omitempty" validate:"omitempty"`
	FPSValue              *TcFPS                `json:"fps,omitempty" validate:"omitempty"`
	GopValue              *int                  `json:"gop,omitempty" validate:"omitempty"`
	InterlaceValue        *InterlaceSettings    `json:"interlace,omitempty" validate:"omitempty"`
	BframesValue          *int                  `json:"bframes,omitempty" validate:"omitempty"`
	LogoValue             *TcLogoImpl           `json:"logo,omitempty" validate:"omitempty"`
	AlogoValue            *TcLogoImpl           `json:"alogo,omitempty" validate:"omitempty"`
	BitrateValue          *Speed                `json:"bitrate,omitempty" validate:"omitempty"`
	ProfileValue          *TcProfile            `json:"profile,omitempty" validate:"omitempty"`
	PidValue              *int                  `json:"pid,omitempty" validate:"omitempty"`
	QpRangeValue          *TcQpRangeImpl        `json:"qp_range,omitempty" validate:"omitempty"`
	RcMethodValue         *RcMethod             `json:"rc_method,omitempty" validate:"omitempty"`
	RefsValue             *int                  `json:"refs,omitempty" validate:"omitempty,min=1,max=6"`
	ResizeModeValue       *TranscoderResizeMode `json:"resize_mode,omitempty" validate:"omitempty"`
	SarValue              *TcSarImpl            `json:"sar,omitempty" validate:"omitempty"`
	SizeValue             *TcSizeImpl           `json:"size,omitempty" validate:"omitempty"`
	PresetValue           *TcPreset             `json:"preset,omitempty" validate:"omitempty"`
	ThreadsValue          *int                  `json:"threads,omitempty" validate:"omitempty"`
	TitleValue            *string               `json:"title,omitempty" validate:"omitempty"`
	ContentValue          FrameContent          `json:"content" validate:"required"`
}

type TranscoderTrackInfoAudioImpl struct {
	ChannelsValue      any          `json:"channels,omitempty" validate:"omitempty,oneof=1 2 3 4 5 6 7"`
	SampleRateValue    any          `json:"sample_rate,omitempty" validate:"omitempty,oneof=96000 88200 64000 48000 44100 32000 24000 22050 16000 12000 11025 8000 0"`
	BitrateValue       *Speed       `json:"bitrate,omitempty" validate:"omitempty"`
	CodecValue         *string      `json:"codec,omitempty" validate:"omitempty,oneof=aac mp3 mp2a opus ac3 eac3 pcma pcmu"`
	InputTrackValue    *int         `json:"input_track,omitempty" validate:"omitempty"`
	LanguageValue      *string      `json:"language,omitempty" validate:"omitempty"`
	PidValue           *int         `json:"pid,omitempty" validate:"omitempty"`
	SplitChannelsValue *bool        `json:"split_channels,omitempty" validate:"omitempty"`
	TitleValue         *string      `json:"title,omitempty" validate:"omitempty"`
	VolumeValue        *string      `json:"volume,omitempty" validate:"omitempty"`
	ContentValue       FrameContent `json:"content" validate:"required"`
}

type TranscoderTrackInfoAudioSpecImpl struct {
	CodecValue         *string `json:"codec,omitempty" validate:"omitempty,oneof=aac mp3 mp2a opus ac3 eac3 pcma pcmu"`
	InputTrackValue    *int    `json:"input_track,omitempty" validate:"omitempty"`
	LanguageValue      *string `json:"language,omitempty" validate:"omitempty"`
	SplitChannelsValue *bool   `json:"split_channels,omitempty" validate:"omitempty"`
	VolumeValue        *string `json:"volume,omitempty" validate:"omitempty"`
}

type TranscoderTrackInfoVideoImpl struct {
	LevelValue            any                   `json:"level,omitempty" validate:"omitempty"`
	OpenGopValue          *bool                 `json:"open_gop,omitempty" validate:"omitempty"`
	TemporalTradeoffValue *int                  `json:"temporal_tradeoff,omitempty" validate:"omitempty"`
	BurnValue             *TcBurnImpl           `json:"burn,omitempty" validate:"omitempty"`
	CodecValue            *FrameCodec           `json:"codec,omitempty" validate:"omitempty"`
	VbvBufsizeValue       *int                  `json:"vbv_bufsize,omitempty" validate:"omitempty"`
	ExtraValue            map[string]string     `json:"extra,omitempty" validate:"omitempty"`
	FPSValue              *TcFPS                `json:"fps,omitempty" validate:"omitempty"`
	GopValue              *int                  `json:"gop,omitempty" validate:"omitempty"`
	InterlaceValue        *InterlaceSettings    `json:"interlace,omitempty" validate:"omitempty"`
	BframesValue          *int                  `json:"bframes,omitempty" validate:"omitempty"`
	LogoValue             *TcLogoImpl           `json:"logo,omitempty" validate:"omitempty"`
	AlogoValue            *TcLogoImpl           `json:"alogo,omitempty" validate:"omitempty"`
	BitrateValue          *Speed                `json:"bitrate,omitempty" validate:"omitempty"`
	ProfileValue          *TcProfile            `json:"profile,omitempty" validate:"omitempty"`
	PidValue              *int                  `json:"pid,omitempty" validate:"omitempty"`
	QpRangeValue          *TcQpRangeImpl        `json:"qp_range,omitempty" validate:"omitempty"`
	RcMethodValue         *RcMethod             `json:"rc_method,omitempty" validate:"omitempty"`
	RefsValue             *int                  `json:"refs,omitempty" validate:"omitempty,min=1,max=6"`
	ResizeModeValue       *TranscoderResizeMode `json:"resize_mode,omitempty" validate:"omitempty"`
	SarValue              *TcSarImpl            `json:"sar,omitempty" validate:"omitempty"`
	SizeValue             *TcSizeImpl           `json:"size,omitempty" validate:"omitempty"`
	PresetValue           *TcPreset             `json:"preset,omitempty" validate:"omitempty"`
	ThreadsValue          *int                  `json:"threads,omitempty" validate:"omitempty"`
	TitleValue            *string               `json:"title,omitempty" validate:"omitempty"`
	ContentValue          FrameContent          `json:"content" validate:"required"`
}

// Required: pid, content, track
type TransponderPidImpl struct {
	BitrateValue    *Speed               `json:"bitrate,omitempty" validate:"omitempty"`
	CodecValue      *FrameCodec          `json:"codec,omitempty" validate:"omitempty"`
	EsInfoValue     *Hexbinary           `json:"es_info,omitempty" validate:"omitempty"`
	StatsValue      *PushPidCountersImpl `json:"stats,omitempty" validate:"omitempty"`
	StreamTypeValue *int                 `json:"stream_type,omitempty" validate:"omitempty,min=1,max=255"`
	ContentValue    string               `json:"content" validate:"required"`
	PidValue        int                  `json:"pid" validate:"required" openmetrics_label:"pid"`
	TrackValue      int                  `json:"track" validate:"required"`
}

// Required: page, lang, type
type TtxtDescriptorsImpl struct {
	LangValue string `json:"lang" validate:"required"`
	TypeValue string `json:"type" validate:"required"`
	PageValue int    `json:"page" validate:"required"`
}

type VbiLinesImpl struct {
	ServiceValue *VbiService `json:"service,omitempty" validate:"omitempty"`
	LinesValue   []VbiLine   `json:"lines,omitempty" validate:"omitempty"`
}

type VisionAlertsImpl struct {
	LowQualityAtValue          *UtcMs `json:"low_quality_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	NotEnoughDetectionsAtValue *UtcMs `json:"not_enough_detections_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	SmallSizeAtValue           *UtcMs `json:"small_size_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
}

type VisionAppearanceImpl struct {
	BoxValue *VisionBoxImpl `json:"box,omitempty" validate:"omitempty"`
}

// Rectangle
// Required: top, left, bottom, right
type VisionBoxImpl struct {
	BottomValue float64 `json:"bottom" validate:"required,min=0,max=1"`
	LeftValue   float64 `json:"left" validate:"required,min=0,max=1"`
	RightValue  float64 `json:"right" validate:"required,min=0,max=1"`
	TopValue    float64 `json:"top" validate:"required,min=0,max=1"`
}

type VisionDetectedFaceImpl struct {
	AppearanceValue       *VisionAppearanceImpl      `json:"appearance,omitempty" validate:"omitempty"`
	ConfidenceValue       *float64                   `json:"confidence,omitempty" validate:"omitempty"`
	FingerprintValue      *VisionFaceFingerprintImpl `json:"fingerprint,omitempty" validate:"omitempty"`
	ThumbnailValue        *VisionImageAttributesImpl `json:"thumbnail,omitempty" validate:"omitempty"`
	ThumbnailQualityValue *float64                   `json:"thumbnail_quality,omitempty" validate:"omitempty"`
	ObjectClassValue      VisionObjectClass          `json:"object_class" validate:"required"`
	DetectedAtValue       UtcMs                      `json:"detected_at" validate:"required,min=1e+12,max=1e+13"`
}

type VisionDetectedLicensePlateImpl struct {
	AppearanceValue       *VisionAppearanceImpl      `json:"appearance,omitempty" validate:"omitempty"`
	ConfidenceValue       *float64                   `json:"confidence,omitempty" validate:"omitempty"`
	FacingSideValue       *VisionVehicleFacingSide   `json:"facing_side,omitempty" validate:"omitempty"`
	PlateTextValue        *string                    `json:"plate_text,omitempty" validate:"omitempty"`
	ThumbnailValue        *VisionImageAttributesImpl `json:"thumbnail,omitempty" validate:"omitempty"`
	ThumbnailQualityValue *float64                   `json:"thumbnail_quality,omitempty" validate:"omitempty"`
	ObjectClassValue      VisionObjectClass          `json:"object_class" validate:"required"`
	DetectedAtValue       UtcMs                      `json:"detected_at" validate:"required,min=1e+12,max=1e+13"`
}

// Required: detected_at, object_class
type VisionDetectedObjectBaseImpl struct {
	AppearanceValue       *VisionAppearanceImpl      `json:"appearance,omitempty" validate:"omitempty"`
	ConfidenceValue       *float64                   `json:"confidence,omitempty" validate:"omitempty"`
	ThumbnailValue        *VisionImageAttributesImpl `json:"thumbnail,omitempty" validate:"omitempty"`
	ThumbnailQualityValue *float64                   `json:"thumbnail_quality,omitempty" validate:"omitempty"`
	ObjectClassValue      VisionObjectClass          `json:"object_class" validate:"required"`
	DetectedAtValue       UtcMs                      `json:"detected_at" validate:"required,min=1e+12,max=1e+13"`
}

type VisionDetectedVehicleImpl struct {
	AppearanceValue          *VisionAppearanceImpl      `json:"appearance,omitempty" validate:"omitempty"`
	ConfidenceValue          *float64                   `json:"confidence,omitempty" validate:"omitempty"`
	LicensePlateMissingValue *bool                      `json:"license_plate_missing,omitempty" validate:"omitempty"`
	PurposeValue             *VisionVehiclePurpose      `json:"purpose,omitempty" validate:"omitempty"`
	ThumbnailValue           *VisionImageAttributesImpl `json:"thumbnail,omitempty" validate:"omitempty"`
	ThumbnailQualityValue    *float64                   `json:"thumbnail_quality,omitempty" validate:"omitempty"`
	ObjectClassValue         VisionObjectClass          `json:"object_class" validate:"required"`
	DetectedAtValue          UtcMs                      `json:"detected_at" validate:"required,min=1e+12,max=1e+13"`
}

// Required: detector_type, region_id
type VisionDetectorConfigImpl struct {
	DetectorTypeValue      *VisionDetectorConfigDetectorTypeImpl      `json:"detector_type" validate:"required"`
	RegionCoordinatesValue *VisionDetectorConfigRegionCoordinatesImpl `json:"region_coordinates,omitempty" validate:"omitempty"`
	StatsValue             *VisionDetectorStatsImpl                   `json:"stats,omitempty" validate:"omitempty"`
	RegionIDValue          string                                     `json:"region_id" validate:"required"`
}

type VisionDetectorConfigDetectorTypeImpl struct {
}

type VisionDetectorConfigRegionCoordinatesImpl struct {
}

type VisionDetectorStatsImpl struct {
	AlertsValue          *VisionAlertsImpl `json:"alerts,omitempty" validate:"omitempty"`
	LastDetectionAtValue *UtcMs            `json:"last_detection_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	StatusValue          *StreamStatus     `json:"status,omitempty" validate:"omitempty"`
}

type VisionEpisodeContextSearchImpl struct {
	OriginatorValue                  *EpisodeOriginatorImpl           `json:"originator,omitempty" validate:"omitempty"`
	PreviewValue                     *Base64                          `json:"preview,omitempty" validate:"omitempty,base64"`
	EpisodeAppearanceTimestampsValue *EpisodeAppearanceTimestampsImpl `json:"episode_appearance_timestamps,omitempty" validate:"omitempty"`
	StartedAtValue                   *UtcMs                           `json:"started_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	EpisodeTypeValue                 *string                          `json:"episode_type,omitempty" validate:"omitempty"`
	FramePreviewValue                *Base64                          `json:"frame_preview,omitempty" validate:"omitempty,base64"`
	ClosedAtValue                    *UtcMs                           `json:"closed_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	RecordingStatusValue             *string                          `json:"recording_status,omitempty" validate:"omitempty"`
	MatchScoreValue                  *float64                         `json:"match_score,omitempty" validate:"omitempty"`
	CloseReasonValue                 *EpisodeCloseReason              `json:"close_reason,omitempty" validate:"omitempty"`
	PreviewTimestampValue            *UtcMs                           `json:"preview_timestamp,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	MediaValue                       MediaName                        `json:"media" validate:"required"`
	OpenedAtValue                    UtcMs                            `json:"opened_at" validate:"required,min=1e+12,max=1e+13"`
	EpisodeIDValue                   SnowflakeID                      `json:"episode_id" validate:"required"`
	UpdatedAtValue                   UtcMs                            `json:"updated_at" validate:"required,min=1e+12,max=1e+13"`
}

type VisionEpisodeFaceImpl struct {
	ClosedAtValue                    *UtcMs                           `json:"closed_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	StartedAtValue                   *UtcMs                           `json:"started_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	EpisodeAppearanceTimestampsValue *EpisodeAppearanceTimestampsImpl `json:"episode_appearance_timestamps,omitempty" validate:"omitempty"`
	RecordingStatusValue             *string                          `json:"recording_status,omitempty" validate:"omitempty"`
	EpisodeTypeValue                 *string                          `json:"episode_type,omitempty" validate:"omitempty"`
	FingerprintValue                 *VisionFaceFingerprintImpl       `json:"fingerprint,omitempty" validate:"omitempty"`
	FramePreviewValue                *Base64                          `json:"frame_preview,omitempty" validate:"omitempty,base64"`
	CloseReasonValue                 *EpisodeCloseReason              `json:"close_reason,omitempty" validate:"omitempty"`
	PreviewTimestampValue            *UtcMs                           `json:"preview_timestamp,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	OriginatorValue                  *EpisodeOriginatorImpl           `json:"originator,omitempty" validate:"omitempty"`
	PreviewValue                     Base64                           `json:"preview" validate:"required,base64"`
	MediaValue                       MediaName                        `json:"media" validate:"required"`
	MatchedPersonsValue              []*VisionPersonMatchImpl         `json:"matched_persons,omitempty" validate:"omitempty"`
	DetectionsValue                  []*VisionDetectedFaceImpl        `json:"detections,omitempty" validate:"omitempty"`
	OpenedAtValue                    UtcMs                            `json:"opened_at" validate:"required,min=1e+12,max=1e+13"`
	EpisodeIDValue                   SnowflakeID                      `json:"episode_id" validate:"required"`
	UpdatedAtValue                   UtcMs                            `json:"updated_at" validate:"required,min=1e+12,max=1e+13"`
}

type VisionEpisodeHumanImpl struct {
	FramePreviewValue                *Base64                          `json:"frame_preview,omitempty" validate:"omitempty,base64"`
	PreviewTimestampValue            *UtcMs                           `json:"preview_timestamp,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	StartedAtValue                   *UtcMs                           `json:"started_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	EpisodeAppearanceTimestampsValue *EpisodeAppearanceTimestampsImpl `json:"episode_appearance_timestamps,omitempty" validate:"omitempty"`
	RecordingStatusValue             *string                          `json:"recording_status,omitempty" validate:"omitempty"`
	EpisodeTypeValue                 *string                          `json:"episode_type,omitempty" validate:"omitempty"`
	ClosedAtValue                    *UtcMs                           `json:"closed_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	PreviewValue                     *Base64                          `json:"preview,omitempty" validate:"omitempty,base64"`
	CloseReasonValue                 *EpisodeCloseReason              `json:"close_reason,omitempty" validate:"omitempty"`
	OriginatorValue                  *EpisodeOriginatorImpl           `json:"originator,omitempty" validate:"omitempty"`
	MediaValue                       MediaName                        `json:"media" validate:"required"`
	DetectionsValue                  []*VisionDetectedObjectBaseImpl  `json:"detections,omitempty" validate:"omitempty"`
	OpenedAtValue                    UtcMs                            `json:"opened_at" validate:"required,min=1e+12,max=1e+13"`
	EpisodeIDValue                   SnowflakeID                      `json:"episode_id" validate:"required"`
	UpdatedAtValue                   UtcMs                            `json:"updated_at" validate:"required,min=1e+12,max=1e+13"`
}

type VisionEpisodeQrCodeImpl struct {
	PreviewTimestampValue            *UtcMs                           `json:"preview_timestamp,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	ClosedAtValue                    *UtcMs                           `json:"closed_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	EpisodeAppearanceTimestampsValue *EpisodeAppearanceTimestampsImpl `json:"episode_appearance_timestamps,omitempty" validate:"omitempty"`
	StartedAtValue                   *UtcMs                           `json:"started_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	EpisodeTypeValue                 *string                          `json:"episode_type,omitempty" validate:"omitempty"`
	FramePreviewValue                *Base64                          `json:"frame_preview,omitempty" validate:"omitempty,base64"`
	CloseReasonValue                 *EpisodeCloseReason              `json:"close_reason,omitempty" validate:"omitempty"`
	RecordingStatusValue             *string                          `json:"recording_status,omitempty" validate:"omitempty"`
	OriginatorValue                  *EpisodeOriginatorImpl           `json:"originator,omitempty" validate:"omitempty"`
	PayloadValue                     *string                          `json:"payload,omitempty" validate:"omitempty"`
	PreviewValue                     *Base64                          `json:"preview,omitempty" validate:"omitempty,base64"`
	MediaValue                       MediaName                        `json:"media" validate:"required"`
	OpenedAtValue                    UtcMs                            `json:"opened_at" validate:"required,min=1e+12,max=1e+13"`
	EpisodeIDValue                   SnowflakeID                      `json:"episode_id" validate:"required"`
	UpdatedAtValue                   UtcMs                            `json:"updated_at" validate:"required,min=1e+12,max=1e+13"`
}

type VisionEpisodeVehicleImpl struct {
	StartedAtValue                   *UtcMs                           `json:"started_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	ClosedAtValue                    *UtcMs                           `json:"closed_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	VehiclePurposeValue              *VisionVehiclePurpose            `json:"vehicle_purpose,omitempty" validate:"omitempty"`
	EpisodeAppearanceTimestampsValue *EpisodeAppearanceTimestampsImpl `json:"episode_appearance_timestamps,omitempty" validate:"omitempty"`
	VehicleFacingSideValue           *VisionVehicleFacingSide         `json:"vehicle_facing_side,omitempty" validate:"omitempty"`
	EpisodeTypeValue                 *string                          `json:"episode_type,omitempty" validate:"omitempty"`
	FramePreviewValue                *Base64                          `json:"frame_preview,omitempty" validate:"omitempty,base64"`
	LicensePlateMissingValue         *bool                            `json:"license_plate_missing,omitempty" validate:"omitempty"`
	VehicleEmergencySubtypeValue     *VisionVehicleEmergencySubtype   `json:"vehicle_emergency_subtype,omitempty" validate:"omitempty"`
	LicensePlateTextValue            *string                          `json:"license_plate_text,omitempty" validate:"omitempty"`
	CloseReasonValue                 *EpisodeCloseReason              `json:"close_reason,omitempty" validate:"omitempty"`
	OriginatorValue                  *EpisodeOriginatorImpl           `json:"originator,omitempty" validate:"omitempty"`
	RecordingStatusValue             *string                          `json:"recording_status,omitempty" validate:"omitempty"`
	PreviewTimestampValue            *UtcMs                           `json:"preview_timestamp,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	PreviewValue                     Base64                           `json:"preview" validate:"required,base64"`
	MediaValue                       MediaName                        `json:"media" validate:"required"`
	DetectionsValue                  []any                            `json:"detections,omitempty" validate:"omitempty"`
	OpenedAtValue                    UtcMs                            `json:"opened_at" validate:"required,min=1e+12,max=1e+13"`
	UpdatedAtValue                   UtcMs                            `json:"updated_at" validate:"required,min=1e+12,max=1e+13"`
	EpisodeIDValue                   SnowflakeID                      `json:"episode_id" validate:"required"`
}

type VisionFaceAttributesImpl struct {
	FingerprintValue *VisionFaceFingerprintImpl `json:"fingerprint,omitempty" validate:"omitempty"`
}

// Digital fingerprint of the face
// Required: data, version
type VisionFaceFingerprintImpl struct {
	DataValue    Base64 `json:"data" validate:"required,base64"`
	VersionValue string `json:"version" validate:"required"`
}

// Required: data
type VisionImageAttributesImpl struct {
	MimeTypeValue *VisionImageMimetype `json:"mime_type,omitempty" validate:"omitempty"`
	Sha256Value   *Hexbinary           `json:"sha256,omitempty" validate:"omitempty,min=64,max=64"`
	DataValue     Base64               `json:"data" validate:"required,base64"`
}

// Attributes of the detected vehicle
type VisionLicensePlateAttributesImpl struct {
	FacingSideValue *VisionVehicleFacingSide `json:"facing_side,omitempty" validate:"omitempty"`
	PlateTextValue  *string                  `json:"plate_text,omitempty" validate:"omitempty"`
}

// Person
// Required: person_id, updated_at, originator
type VisionPersonImpl struct {
	DeletedAtValue    *UtcMs                       `json:"deleted_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	ExternalIDValue   *string                      `json:"external_id,omitempty" validate:"omitempty"`
	OriginatorValue   VisionPersonOriginator       `json:"originator" validate:"required,oneof=api identification_service"`
	FingerprintsValue []*VisionFaceFingerprintImpl `json:"fingerprints,omitempty" validate:"omitempty"`
	PhotosValue       []*VisionImageAttributesImpl `json:"photos,omitempty" validate:"omitempty"`
	PersonIDValue     SnowflakeID                  `json:"person_id" validate:"required"`
	UpdatedAtValue    UtcMs                        `json:"updated_at" validate:"required,min=1e+12,max=1e+13"`
}

// Person matching information
// Required: person, match_score
type VisionPersonMatchImpl struct {
	PersonValue     *VisionPersonImpl `json:"person" validate:"required"`
	MatchScoreValue float64           `json:"match_score" validate:"required"`
}

type VisionPersonsListImpl struct {
	TimingValue         any                 `json:"timing,omitempty" validate:"omitempty"`
	EstimatedCountValue *int                `json:"estimated_count,omitempty" validate:"omitempty"`
	NextValue           *string             `json:"next,omitempty" validate:"omitempty"`
	PrevValue           *string             `json:"prev,omitempty" validate:"omitempty"`
	PersonsValue        []*VisionPersonImpl `json:"persons" validate:"required"`
}

// 2D point
// Required: x, y
type VisionPointImpl struct {
	XValue float64 `json:"x" validate:"required,min=0,max=1"`
	YValue float64 `json:"y" validate:"required,min=0,max=1"`
}

type VisionSpecImpl struct {
	AlgValue       *VisionSpecAlg              `json:"alg,omitempty" validate:"omitempty,oneof=faces plates"`
	AreasValue     *string                     `json:"areas,omitempty" validate:"omitempty"`
	DetectorsValue []*VisionDetectorConfigImpl `json:"detectors,omitempty" validate:"omitempty"`
}

type VisionVehicleAttributesImpl struct {
	LicensePlateMissingValue *bool                 `json:"license_plate_missing,omitempty" validate:"omitempty"`
	PurposeValue             *VisionVehiclePurpose `json:"purpose,omitempty" validate:"omitempty"`
}

type WatcherAgentConfigImpl struct {
	IDValue    *string                `json:"id,omitempty" validate:"omitempty"`
	KeyValue   *string                `json:"key,omitempty" validate:"omitempty"`
	StatsValue *WatcherAgentStatsImpl `json:"stats,omitempty" validate:"omitempty"`
}

type WatcherAgentControlConnectionImpl struct {
	AliveValue           *bool   `json:"alive,omitempty" validate:"omitempty"`
	BytesFromServerValue *Bytes  `json:"bytes_from_server,omitempty" validate:"omitempty"`
	BytesToServerValue   *Bytes  `json:"bytes_to_server,omitempty" validate:"omitempty"`
	HostnameValue        *string `json:"hostname,omitempty" validate:"omitempty"`
	OpenedAtValue        *UtcMs  `json:"opened_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	StatusChangedAtValue *Utc    `json:"status_changed_at,omitempty" validate:"omitempty,min=1e+09,max=1e+10"`
}

type WatcherAgentDataConnectionsImpl struct {
	ConnectionsAttemptedValue *int `json:"connections_attempted,omitempty" validate:"omitempty"`
	ConnectionsCurrentValue   *int `json:"connections_current,omitempty" validate:"omitempty"`
	ConnectionsOpenedValue    *int `json:"connections_opened,omitempty" validate:"omitempty"`
}

type WatcherAgentLogsImpl struct {
	AValue           *string `json:"a,omitempty" validate:"omitempty"`
	AgentIDValue     *string `json:"agent_id,omitempty" validate:"omitempty"`
	BValue           *string `json:"b,omitempty" validate:"omitempty"`
	BufferLimitValue *int    `json:"buffer_limit,omitempty" validate:"omitempty"`
	BufferSizeValue  *int    `json:"buffer_size,omitempty" validate:"omitempty"`
	CidValue         *string `json:"cid,omitempty" validate:"omitempty"`
	MainURLValue     *string `json:"main_url,omitempty" validate:"omitempty"`
	MeminfoValue     *string `json:"meminfo,omitempty" validate:"omitempty"`
	MidValue         *string `json:"mid,omitempty" validate:"omitempty"`
	SerialValue      *string `json:"serial,omitempty" validate:"omitempty"`
	StatusValue      *string `json:"status,omitempty" validate:"omitempty"`
	VersionValue     *string `json:"version,omitempty" validate:"omitempty"`
}

type WatcherAgentStatsImpl struct {
	AgentTypeValue              *string                                     `json:"agent_type,omitempty" validate:"omitempty"`
	ConnectionsEstablishedValue *int                                        `json:"connections_established,omitempty" validate:"omitempty"`
	ConnectionsRequestedValue   *int                                        `json:"connections_requested,omitempty" validate:"omitempty"`
	EndpointConnectionValue     *WatcherAgentControlConnectionImpl          `json:"endpoint_connection,omitempty" validate:"omitempty"`
	LocalIPValue                *Ipv4                                       `json:"local_ip,omitempty" validate:"omitempty"`
	MacAddressValue             *string                                     `json:"mac_address,omitempty" validate:"omitempty"`
	PeerIPValue                 *Ipv4                                       `json:"peer_ip,omitempty" validate:"omitempty"`
	StreampointConnectionValue  *WatcherAgentStatsStreampointConnectionImpl `json:"streampoint_connection,omitempty" validate:"omitempty"`
	VersionValue                *string                                     `json:"version,omitempty" validate:"omitempty"`
}

// Parameters of the connection between Agent and its streampoint.
type WatcherAgentStatsStreampointConnectionImpl struct {
	AliveValue                *bool   `json:"alive,omitempty" validate:"omitempty"`
	BytesFromServerValue      *Bytes  `json:"bytes_from_server,omitempty" validate:"omitempty"`
	BytesToServerValue        *Bytes  `json:"bytes_to_server,omitempty" validate:"omitempty"`
	ConnectionsAttemptedValue *int    `json:"connections_attempted,omitempty" validate:"omitempty"`
	ConnectionsCurrentValue   *int    `json:"connections_current,omitempty" validate:"omitempty"`
	ConnectionsOpenedValue    *int    `json:"connections_opened,omitempty" validate:"omitempty"`
	HostnameValue             *string `json:"hostname,omitempty" validate:"omitempty"`
	OpenedAtValue             *UtcMs  `json:"opened_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	StatusChangedAtValue      *Utc    `json:"status_changed_at,omitempty" validate:"omitempty,min=1e+09,max=1e+10"`
}

type WebrtcAbrOptsImpl struct {
	StartTrackValue *string `json:"start_track,omitempty" validate:"omitempty"`
}

// NewAPICall creates a new APICall instance
func NewAPICall() APICall {
	return &APICallImpl{}
}

// Creation date and time
// Format: date_time (date_time)
// Example: 2021-01-30T08:30:00.432567Z
func (s APICallImpl) CreatedAt() *DateTime {
	return s.CreatedAtValue
}

// Creation date and time
// Format: date_time (date_time)
// Example: 2021-01-30T08:30:00.432567Z
func (s *APICallImpl) SetCreatedAt(v DateTime) APICall {
	if s == nil {
		return nil
	}
	s.CreatedAtValue = &v
	return s
}

// Microseconds that this request took
// Format: microseconds (microseconds)
func (s APICallImpl) Duration() *Microseconds {
	return s.DurationValue
}

// Microseconds that this request took
// Format: microseconds (microseconds)
func (s *APICallImpl) SetDuration(v Microseconds) APICall {
	if s == nil {
		return nil
	}
	s.DurationValue = &v
	return s
}

// IP address of the caller.
// Format: ip (ip)
// Example: 192.34.32.10
func (s APICallImpl) IP() *IP {
	return s.IPValue
}

// IP address of the caller.
// Format: ip (ip)
// Example: 192.34.32.10
func (s *APICallImpl) SetIP(v IP) APICall {
	if s == nil {
		return nil
	}
	s.IPValue = &v
	return s
}

// API method ID.
// Example: streams_list
func (s APICallImpl) OperationID() *string {
	return s.OperationIDValue
}

// API method ID.
// Example: streams_list
func (s *APICallImpl) SetOperationID(v string) APICall {
	if s == nil {
		return nil
	}
	s.OperationIDValue = &v
	return s
}

// The program produced the API call. Content of `X-Originator` header.
// Example: flussonic
func (s APICallImpl) Originator() *string {
	return s.OriginatorValue
}

// The program produced the API call. Content of `X-Originator` header.
// Example: flussonic
func (s *APICallImpl) SetOriginator(v string) APICall {
	if s == nil {
		return nil
	}
	s.OriginatorValue = &v
	return s
}

// Payload data transmitter in the API call.
func (s APICallImpl) Payload() *string {
	return s.PayloadValue
}

// Payload data transmitter in the API call.
func (s *APICallImpl) SetPayload(v string) APICall {
	if s == nil {
		return nil
	}
	s.PayloadValue = &v
	return s
}

// Internal request-id for this operation
func (s APICallImpl) RequestID() *string {
	return s.RequestIDValue
}

// Internal request-id for this operation
func (s *APICallImpl) SetRequestID(v string) APICall {
	if s == nil {
		return nil
	}
	s.RequestIDValue = &v
	return s
}

// Request status code.
func (s APICallImpl) Status() *int {
	return s.StatusValue
}

// Request status code.
func (s *APICallImpl) SetStatus(v int) APICall {
	if s == nil {
		return nil
	}
	s.StatusValue = &v
	return s
}

// The type of the device from which the API call was produced.
// Example: Flussonic 24.04
func (s APICallImpl) UserAgent() *string {
	return s.UserAgentValue
}

// The type of the device from which the API call was produced.
// Example: Flussonic 24.04
func (s *APICallImpl) SetUserAgent(v string) APICall {
	if s == nil {
		return nil
	}
	s.UserAgentValue = &v
	return s
}

// NewAPICallEvent creates a new APICallEvent instance
func NewAPICallEvent() APICallEvent {
	return &APICallEventImpl{}
}

// Creation date and time
// Format: date_time (date_time)
// Example: 2021-01-30T08:30:00.432567Z
func (s APICallEventImpl) CreatedAt() *DateTime {
	return s.CreatedAtValue
}

// Creation date and time
// Format: date_time (date_time)
// Example: 2021-01-30T08:30:00.432567Z
func (s *APICallEventImpl) SetCreatedAt(v DateTime) APICallEvent {
	if s == nil {
		return nil
	}
	s.CreatedAtValue = &v
	return s
}

// Microseconds that this request took
// Format: microseconds (microseconds)
func (s APICallEventImpl) Duration() *Microseconds {
	return s.DurationValue
}

// Microseconds that this request took
// Format: microseconds (microseconds)
func (s *APICallEventImpl) SetDuration(v Microseconds) APICallEvent {
	if s == nil {
		return nil
	}
	s.DurationValue = &v
	return s
}

// Unique identifier of the entity.
// For example, for `agent` it is `agent_id` field.
func (s APICallEventImpl) EntityID() *string {
	return s.EntityIDValue
}

// Unique identifier of the entity.
// For example, for `agent` it is `agent_id` field.
func (s *APICallEventImpl) SetEntityID(v string) APICallEvent {
	if s == nil {
		return nil
	}
	s.EntityIDValue = &v
	return s
}

// Type of the entity.
func (s APICallEventImpl) EntityType() *EntityEventEntityType {
	return s.EntityTypeValue
}

// Type of the entity.
func (s *APICallEventImpl) SetEntityType(v EntityEventEntityType) APICallEvent {
	if s == nil {
		return nil
	}
	s.EntityTypeValue = &v
	return s
}

// The api call.
func (s APICallEventImpl) Event() string {
	return s.EventValue
}

// The api call.
func (s *APICallEventImpl) SetEvent(v string) APICallEvent {
	if s == nil {
		return nil
	}
	s.EventValue = v
	return s
}

// Event identifier.
func (s APICallEventImpl) EventID() *int {
	return s.EventIDValue
}

// Event identifier.
func (s *APICallEventImpl) SetEventID(v int) APICallEvent {
	if s == nil {
		return nil
	}
	s.EventIDValue = &v
	return s
}

// IP address of the caller.
// Format: ip (ip)
// Example: 192.34.32.10
func (s APICallEventImpl) IP() *IP {
	return s.IPValue
}

// IP address of the caller.
// Format: ip (ip)
// Example: 192.34.32.10
func (s *APICallEventImpl) SetIP(v IP) APICallEvent {
	if s == nil {
		return nil
	}
	s.IPValue = &v
	return s
}

// API method ID.
// Example: streams_list
func (s APICallEventImpl) OperationID() *string {
	return s.OperationIDValue
}

// API method ID.
// Example: streams_list
func (s *APICallEventImpl) SetOperationID(v string) APICallEvent {
	if s == nil {
		return nil
	}
	s.OperationIDValue = &v
	return s
}

// The program produced the API call. Content of `X-Originator` header.
// Example: flussonic
func (s APICallEventImpl) Originator() *string {
	return s.OriginatorValue
}

// The program produced the API call. Content of `X-Originator` header.
// Example: flussonic
func (s *APICallEventImpl) SetOriginator(v string) APICallEvent {
	if s == nil {
		return nil
	}
	s.OriginatorValue = &v
	return s
}

// The api call path.
func (s APICallEventImpl) Path() *string {
	return s.PathValue
}

// The api call path.
func (s *APICallEventImpl) SetPath(v string) APICallEvent {
	if s == nil {
		return nil
	}
	s.PathValue = &v
	return s
}

// Payload data transmitter in the API call.
func (s APICallEventImpl) Payload() *string {
	return s.PayloadValue
}

// Payload data transmitter in the API call.
func (s *APICallEventImpl) SetPayload(v string) APICallEvent {
	if s == nil {
		return nil
	}
	s.PayloadValue = &v
	return s
}

// The api call query string.
func (s APICallEventImpl) Qs() *string {
	return s.QsValue
}

// The api call query string.
func (s *APICallEventImpl) SetQs(v string) APICallEvent {
	if s == nil {
		return nil
	}
	s.QsValue = &v
	return s
}

// Internal request-id for this operation
func (s APICallEventImpl) RequestID() *string {
	return s.RequestIDValue
}

// Internal request-id for this operation
func (s *APICallEventImpl) SetRequestID(v string) APICallEvent {
	if s == nil {
		return nil
	}
	s.RequestIDValue = &v
	return s
}

// Originator of event.
// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
// is configured as HTTP/HTTPS url.
// Example: flussonic.host
func (s APICallEventImpl) Server() *string {
	return s.ServerValue
}

// Originator of event.
// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
// is configured as HTTP/HTTPS url.
// Example: flussonic.host
func (s *APICallEventImpl) SetServer(v string) APICallEvent {
	if s == nil {
		return nil
	}
	s.ServerValue = &v
	return s
}

// Request status code.
func (s APICallEventImpl) Status() *int {
	return s.StatusValue
}

// Request status code.
func (s *APICallEventImpl) SetStatus(v int) APICallEvent {
	if s == nil {
		return nil
	}
	s.StatusValue = &v
	return s
}

// Unique identifier of the operation.
// You can use this field to search for events related to same operation.
// Value of this field is taken from the `X-Trace-Id` header.
// If `X-Trace-Id` header is not set, it will be generated automatically.
// Service will use the value of this field to make outgoing requests.
// Format: uuid (uuid)
// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
func (s APICallEventImpl) TraceID() *UUID {
	return s.TraceIDValue
}

// Unique identifier of the operation.
// You can use this field to search for events related to same operation.
// Value of this field is taken from the `X-Trace-Id` header.
// If `X-Trace-Id` header is not set, it will be generated automatically.
// Service will use the value of this field to make outgoing requests.
// Format: uuid (uuid)
// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
func (s *APICallEventImpl) SetTraceID(v UUID) APICallEvent {
	if s == nil {
		return nil
	}
	s.TraceIDValue = &v
	return s
}

// The type of the device from which the API call was produced.
// Example: Flussonic 24.04
func (s APICallEventImpl) UserAgent() *string {
	return s.UserAgentValue
}

// The type of the device from which the API call was produced.
// Example: Flussonic 24.04
func (s *APICallEventImpl) SetUserAgent(v string) APICallEvent {
	if s == nil {
		return nil
	}
	s.UserAgentValue = &v
	return s
}

// The time of the event registration on the server.
// Format: utc_ms (Unix timestamp in milliseconds)
func (s APICallEventImpl) UtcMs() *UtcMs {
	return s.UtcMsValue
}

// The time of the event registration on the server.
// Format: utc_ms (Unix timestamp in milliseconds)
func (s *APICallEventImpl) SetUtcMs(v UtcMs) APICallEvent {
	if s == nil {
		return nil
	}
	s.UtcMsValue = &v
	return s
}

// NewAPIToken creates a new APIToken instance
func NewAPIToken() APIToken {
	return &APITokenImpl{}
}

// A list of scopes that restrict the permissions of this API token.
// The system sets these scopes based on the context and limitations present when the token is created.
// For example, this can be used to specify a particular user or other constraints.
// The token cannot have permissions beyond those defined in this array.
// Examples: [user/15]
func (s APITokenImpl) AuthScopes() []string {
	return s.AuthScopesValue
}

// A list of scopes that restrict the permissions of this API token.
// The system sets these scopes based on the context and limitations present when the token is created.
// For example, this can be used to specify a particular user or other constraints.
// The token cannot have permissions beyond those defined in this array.
// Examples: [user/15]
func (s *APITokenImpl) SetAuthScopes(v []string) APIToken {
	if s == nil {
		return nil
	}
	s.AuthScopesValue = v
	return s
}

// Unique secret string generated by server.
// Examples: $5$tz/6I0KpagoQ9kQN$nnnKQCxuhCOCaZ7q9WEWvHo6.dRb2hawYofHPdAhHV., 1234, IJCo3KGLBf6NAqMCGgHf5gNhpl9
func (s APITokenImpl) Key() string {
	return s.KeyValue
}

// Unique secret string generated by server.
// Examples: $5$tz/6I0KpagoQ9kQN$nnnKQCxuhCOCaZ7q9WEWvHo6.dRb2hawYofHPdAhHV., 1234, IJCo3KGLBf6NAqMCGgHf5gNhpl9
func (s *APITokenImpl) SetKey(v string) APIToken {
	if s == nil {
		return nil
	}
	s.KeyValue = v
	return s
}

// unique name of the token that can be used to distinguish tokens
// Examples: inference_server, root
func (s APITokenImpl) Name() string {
	return s.NameValue
}

// unique name of the token that can be used to distinguish tokens
// Examples: inference_server, root
func (s *APITokenImpl) SetName(v string) APIToken {
	if s == nil {
		return nil
	}
	s.NameValue = v
	return s
}

// list of independent permissions, available for this token
func (s APITokenImpl) Permissions() []APITokenPermission {
	if s.PermissionsValue == nil {
		return nil
	}
	result := make([]APITokenPermission, len(s.PermissionsValue))
	for i, item := range s.PermissionsValue {
		result[i] = item
	}
	return result
}

// list of independent permissions, available for this token
func (s *APITokenImpl) SetPermissions(v []APITokenPermission) APIToken {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*APITokenPermissionImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*APITokenPermissionImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.PermissionsValue = impl
	}
	return s
}

// NewAPITokenPermission creates a new APITokenPermission instance
func NewAPITokenPermission() APITokenPermission {
	return &APITokenPermissionImpl{}
}

// executing this function (if it is a function) is allowed
func (s APITokenPermissionImpl) Execute() *bool {
	return s.ExecuteValue
}

// executing this function (if it is a function) is allowed
func (s *APITokenPermissionImpl) SetExecute(v bool) APITokenPermission {
	if s == nil {
		return nil
	}
	s.ExecuteValue = &v
	return s
}

// listing items is allowed
func (s APITokenPermissionImpl) List() *bool {
	return s.ListValue
}

// listing items is allowed
func (s *APITokenPermissionImpl) SetList(v bool) APITokenPermission {
	if s == nil {
		return nil
	}
	s.ListValue = &v
	return s
}

// reading one item is allowed
func (s APITokenPermissionImpl) Read() *bool {
	return s.ReadValue
}

// reading one item is allowed
func (s *APITokenPermissionImpl) SetRead(v bool) APITokenPermission {
	if s == nil {
		return nil
	}
	s.ReadValue = &v
	return s
}

// List of permission scopes that will be intersected
// Each scope is a name of the collection or a function with nested resource name
// that is covered with this permission
// Examples: [*], [streams/*], [streams/location1%2F*]
func (s APITokenPermissionImpl) Scopes() []string {
	return s.ScopesValue
}

// List of permission scopes that will be intersected
// Each scope is a name of the collection or a function with nested resource name
// that is covered with this permission
// Examples: [*], [streams/*], [streams/location1%2F*]
func (s *APITokenPermissionImpl) SetScopes(v []string) APITokenPermission {
	if s == nil {
		return nil
	}
	s.ScopesValue = v
	return s
}

// writing/updating/deletion one item is allowed
func (s APITokenPermissionImpl) Write() *bool {
	return s.WriteValue
}

// writing/updating/deletion one item is allowed
func (s *APITokenPermissionImpl) SetWrite(v bool) APITokenPermission {
	if s == nil {
		return nil
	}
	s.WriteValue = &v
	return s
}

// NewAPITokensList creates a new APITokensList instance
func NewAPITokensList() APITokensList {
	return &APITokensListImpl{}
}

// List of available api tokens
func (s APITokensListImpl) APITokens() []APIToken {
	if s.APITokensValue == nil {
		return nil
	}
	result := make([]APIToken, len(s.APITokensValue))
	for i, item := range s.APITokensValue {
		result[i] = item
	}
	return result
}

// List of available api tokens
func (s *APITokensListImpl) SetAPITokens(v []APIToken) APITokensList {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*APITokenImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*APITokenImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.APITokensValue = impl
	}
	return s
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s APITokensListImpl) EstimatedCount() *int {
	return s.EstimatedCountValue
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s *APITokensListImpl) SetEstimatedCount(v int) APITokensList {
	if s == nil {
		return nil
	}
	s.EstimatedCountValue = &v
	return s
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s APITokensListImpl) Next() *string {
	return s.NextValue
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s *APITokensListImpl) SetNext(v string) APITokensList {
	if s == nil {
		return nil
	}
	s.NextValue = &v
	return s
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s APITokensListImpl) Prev() *string {
	return s.PrevValue
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s *APITokensListImpl) SetPrev(v string) APITokensList {
	if s == nil {
		return nil
	}
	s.PrevValue = &v
	return s
}

// An object with a list of different timings measured during this API call.
func (s APITokensListImpl) Timing() any {
	return s.TimingValue
}

// An object with a list of different timings measured during this API call.
func (s *APITokensListImpl) SetTiming(v any) APITokensList {
	if s == nil {
		return nil
	}
	s.TimingValue = v
	return s
}

// Collection returns the collection items from APITokensList
func (s APITokensListImpl) Collection() []APIToken {
	return s.APITokens()
}

// NewAdminCredentials creates a new AdminCredentials instance
func NewAdminCredentials() AdminCredentials {
	return &AdminCredentialsImpl{}
}

// Login
// Example: secretlogin
func (s AdminCredentialsImpl) Login() string {
	return s.LoginValue
}

// Login
// Example: secretlogin
func (s *AdminCredentialsImpl) SetLogin(v string) AdminCredentials {
	if s == nil {
		return nil
	}
	s.LoginValue = v
	return s
}

// Password
// Format: password (password)
// Example: passw
func (s AdminCredentialsImpl) Password() Password {
	return s.PasswordValue
}

// Password
// Format: password (password)
// Example: passw
func (s *AdminCredentialsImpl) SetPassword(v Password) AdminCredentials {
	if s == nil {
		return nil
	}
	s.PasswordValue = v
	return s
}

// NewAgentCommandHandling creates a new AgentCommandHandling instance
func NewAgentCommandHandling() AgentCommandHandling {
	return &AgentCommandHandlingImpl{}
}

// Command name.
// Example: streampoint_connect
func (s AgentCommandHandlingImpl) Command() *AgentCommandHandlingCommand {
	return s.CommandValue
}

// Command name.
// Example: streampoint_connect
func (s *AgentCommandHandlingImpl) SetCommand(v AgentCommandHandlingCommand) AgentCommandHandling {
	if s == nil {
		return nil
	}
	s.CommandValue = &v
	return s
}

// Unique identifier of the entity.
// For example, for `agent` it is `agent_id` field.
func (s AgentCommandHandlingImpl) EntityID() *string {
	return s.EntityIDValue
}

// Unique identifier of the entity.
// For example, for `agent` it is `agent_id` field.
func (s *AgentCommandHandlingImpl) SetEntityID(v string) AgentCommandHandling {
	if s == nil {
		return nil
	}
	s.EntityIDValue = &v
	return s
}

// Type of the entity.
func (s AgentCommandHandlingImpl) EntityType() *EntityEventEntityType {
	return s.EntityTypeValue
}

// Type of the entity.
func (s *AgentCommandHandlingImpl) SetEntityType(v EntityEventEntityType) AgentCommandHandling {
	if s == nil {
		return nil
	}
	s.EntityTypeValue = &v
	return s
}

// Error message explaining why command failed.
// If command was successful, this field absent.
func (s AgentCommandHandlingImpl) Error() *AgentCommandHandlingError {
	return s.ErrorValue
}

// Error message explaining why command failed.
// If command was successful, this field absent.
func (s *AgentCommandHandlingImpl) SetError(v AgentCommandHandlingError) AgentCommandHandling {
	if s == nil {
		return nil
	}
	s.ErrorValue = &v
	return s
}

// Event of handling commands via the interaction protocol between the agent and the endpoint.
func (s AgentCommandHandlingImpl) Event() string {
	return s.EventValue
}

// Event of handling commands via the interaction protocol between the agent and the endpoint.
func (s *AgentCommandHandlingImpl) SetEvent(v string) AgentCommandHandling {
	if s == nil {
		return nil
	}
	s.EventValue = v
	return s
}

// Event identifier.
func (s AgentCommandHandlingImpl) EventID() *int {
	return s.EventIDValue
}

// Event identifier.
func (s *AgentCommandHandlingImpl) SetEventID(v int) AgentCommandHandling {
	if s == nil {
		return nil
	}
	s.EventIDValue = &v
	return s
}

func (s AgentCommandHandlingImpl) Initiator() *AgentInitiator {
	return s.InitiatorValue
}

func (s *AgentCommandHandlingImpl) SetInitiator(v AgentInitiator) AgentCommandHandling {
	if s == nil {
		return nil
	}
	s.InitiatorValue = &v
	return s
}

// Payload of the command.
func (s AgentCommandHandlingImpl) Payload() *string {
	return s.PayloadValue
}

// Payload of the command.
func (s *AgentCommandHandlingImpl) SetPayload(v string) AgentCommandHandling {
	if s == nil {
		return nil
	}
	s.PayloadValue = &v
	return s
}

// Originator of event.
// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
// is configured as HTTP/HTTPS url.
// Example: flussonic.host
func (s AgentCommandHandlingImpl) Server() *string {
	return s.ServerValue
}

// Originator of event.
// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
// is configured as HTTP/HTTPS url.
// Example: flussonic.host
func (s *AgentCommandHandlingImpl) SetServer(v string) AgentCommandHandling {
	if s == nil {
		return nil
	}
	s.ServerValue = &v
	return s
}

// Unique identifier of the operation.
// You can use this field to search for events related to same operation.
// Value of this field is taken from the `X-Trace-Id` header.
// If `X-Trace-Id` header is not set, it will be generated automatically.
// Service will use the value of this field to make outgoing requests.
// Format: uuid (uuid)
// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
func (s AgentCommandHandlingImpl) TraceID() *UUID {
	return s.TraceIDValue
}

// Unique identifier of the operation.
// You can use this field to search for events related to same operation.
// Value of this field is taken from the `X-Trace-Id` header.
// If `X-Trace-Id` header is not set, it will be generated automatically.
// Service will use the value of this field to make outgoing requests.
// Format: uuid (uuid)
// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
func (s *AgentCommandHandlingImpl) SetTraceID(v UUID) AgentCommandHandling {
	if s == nil {
		return nil
	}
	s.TraceIDValue = &v
	return s
}

// The time of the event registration on the server.
// Format: utc_ms (Unix timestamp in milliseconds)
func (s AgentCommandHandlingImpl) UtcMs() *UtcMs {
	return s.UtcMsValue
}

// The time of the event registration on the server.
// Format: utc_ms (Unix timestamp in milliseconds)
func (s *AgentCommandHandlingImpl) SetUtcMs(v UtcMs) AgentCommandHandling {
	if s == nil {
		return nil
	}
	s.UtcMsValue = &v
	return s
}

// NewAgentConfigBase creates a new AgentConfigBase instance
func NewAgentConfigBase() AgentConfigBase {
	return &AgentConfigBaseImpl{}
}

// Agent identifier
// Example: 1234567
func (s AgentConfigBaseImpl) ID() *string {
	return s.IDValue
}

// Agent identifier
// Example: 1234567
func (s *AgentConfigBaseImpl) SetID(v string) AgentConfigBase {
	if s == nil {
		return nil
	}
	s.IDValue = &v
	return s
}

// Agent authentication key.
func (s AgentConfigBaseImpl) Key() *string {
	return s.KeyValue
}

// Agent authentication key.
func (s *AgentConfigBaseImpl) SetKey(v string) AgentConfigBase {
	if s == nil {
		return nil
	}
	s.KeyValue = &v
	return s
}

// Agents's metrics and other statistical information.
func (s AgentConfigBaseImpl) Stats() WatcherAgentStats {
	return s.StatsValue
}

// Agents's metrics and other statistical information.
func (s *AgentConfigBaseImpl) SetStats(v WatcherAgentStats) AgentConfigBase {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*WatcherAgentStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// NewAgentConnectFailed creates a new AgentConnectFailed instance
func NewAgentConnectFailed() AgentConnectFailed {
	return &AgentConnectFailedImpl{}
}

// Unique identifier of the entity.
// For example, for `agent` it is `agent_id` field.
func (s AgentConnectFailedImpl) EntityID() *string {
	return s.EntityIDValue
}

// Unique identifier of the entity.
// For example, for `agent` it is `agent_id` field.
func (s *AgentConnectFailedImpl) SetEntityID(v string) AgentConnectFailed {
	if s == nil {
		return nil
	}
	s.EntityIDValue = &v
	return s
}

// Type of the entity.
func (s AgentConnectFailedImpl) EntityType() *EntityEventEntityType {
	return s.EntityTypeValue
}

// Type of the entity.
func (s *AgentConnectFailedImpl) SetEntityType(v EntityEventEntityType) AgentConnectFailed {
	if s == nil {
		return nil
	}
	s.EntityTypeValue = &v
	return s
}

// Agent failed to connect to endpoint.
func (s AgentConnectFailedImpl) Event() string {
	return s.EventValue
}

// Agent failed to connect to endpoint.
func (s *AgentConnectFailedImpl) SetEvent(v string) AgentConnectFailed {
	if s == nil {
		return nil
	}
	s.EventValue = v
	return s
}

// Event identifier.
func (s AgentConnectFailedImpl) EventID() *int {
	return s.EventIDValue
}

// Event identifier.
func (s *AgentConnectFailedImpl) SetEventID(v int) AgentConnectFailed {
	if s == nil {
		return nil
	}
	s.EventIDValue = &v
	return s
}

// Additional information about the error.
func (s AgentConnectFailedImpl) Message() *string {
	return s.MessageValue
}

// Additional information about the error.
func (s *AgentConnectFailedImpl) SetMessage(v string) AgentConnectFailed {
	if s == nil {
		return nil
	}
	s.MessageValue = &v
	return s
}

// Why agent failed to connect.
func (s AgentConnectFailedImpl) Reason() *AgentConnectFailedReason {
	return s.ReasonValue
}

// Why agent failed to connect.
func (s *AgentConnectFailedImpl) SetReason(v AgentConnectFailedReason) AgentConnectFailed {
	if s == nil {
		return nil
	}
	s.ReasonValue = &v
	return s
}

// Originator of event.
// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
// is configured as HTTP/HTTPS url.
// Example: flussonic.host
func (s AgentConnectFailedImpl) Server() *string {
	return s.ServerValue
}

// Originator of event.
// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
// is configured as HTTP/HTTPS url.
// Example: flussonic.host
func (s *AgentConnectFailedImpl) SetServer(v string) AgentConnectFailed {
	if s == nil {
		return nil
	}
	s.ServerValue = &v
	return s
}

// Unique identifier of the operation.
// You can use this field to search for events related to same operation.
// Value of this field is taken from the `X-Trace-Id` header.
// If `X-Trace-Id` header is not set, it will be generated automatically.
// Service will use the value of this field to make outgoing requests.
// Format: uuid (uuid)
// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
func (s AgentConnectFailedImpl) TraceID() *UUID {
	return s.TraceIDValue
}

// Unique identifier of the operation.
// You can use this field to search for events related to same operation.
// Value of this field is taken from the `X-Trace-Id` header.
// If `X-Trace-Id` header is not set, it will be generated automatically.
// Service will use the value of this field to make outgoing requests.
// Format: uuid (uuid)
// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
func (s *AgentConnectFailedImpl) SetTraceID(v UUID) AgentConnectFailed {
	if s == nil {
		return nil
	}
	s.TraceIDValue = &v
	return s
}

// The time of the event registration on the server.
// Format: utc_ms (Unix timestamp in milliseconds)
func (s AgentConnectFailedImpl) UtcMs() *UtcMs {
	return s.UtcMsValue
}

// The time of the event registration on the server.
// Format: utc_ms (Unix timestamp in milliseconds)
func (s *AgentConnectFailedImpl) SetUtcMs(v UtcMs) AgentConnectFailed {
	if s == nil {
		return nil
	}
	s.UtcMsValue = &v
	return s
}

// NewAgentConnected creates a new AgentConnected instance
func NewAgentConnected() AgentConnected {
	return &AgentConnectedImpl{}
}

// Unique identifier of the entity.
// For example, for `agent` it is `agent_id` field.
func (s AgentConnectedImpl) EntityID() *string {
	return s.EntityIDValue
}

// Unique identifier of the entity.
// For example, for `agent` it is `agent_id` field.
func (s *AgentConnectedImpl) SetEntityID(v string) AgentConnected {
	if s == nil {
		return nil
	}
	s.EntityIDValue = &v
	return s
}

// Type of the entity.
func (s AgentConnectedImpl) EntityType() *EntityEventEntityType {
	return s.EntityTypeValue
}

// Type of the entity.
func (s *AgentConnectedImpl) SetEntityType(v EntityEventEntityType) AgentConnected {
	if s == nil {
		return nil
	}
	s.EntityTypeValue = &v
	return s
}

// Agent successfully connected to endpoint.
func (s AgentConnectedImpl) Event() string {
	return s.EventValue
}

// Agent successfully connected to endpoint.
func (s *AgentConnectedImpl) SetEvent(v string) AgentConnected {
	if s == nil {
		return nil
	}
	s.EventValue = v
	return s
}

// Event identifier.
func (s AgentConnectedImpl) EventID() *int {
	return s.EventIDValue
}

// Event identifier.
func (s *AgentConnectedImpl) SetEventID(v int) AgentConnected {
	if s == nil {
		return nil
	}
	s.EventIDValue = &v
	return s
}

// Originator of event.
// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
// is configured as HTTP/HTTPS url.
// Example: flussonic.host
func (s AgentConnectedImpl) Server() *string {
	return s.ServerValue
}

// Originator of event.
// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
// is configured as HTTP/HTTPS url.
// Example: flussonic.host
func (s *AgentConnectedImpl) SetServer(v string) AgentConnected {
	if s == nil {
		return nil
	}
	s.ServerValue = &v
	return s
}

// Unique identifier of the operation.
// You can use this field to search for events related to same operation.
// Value of this field is taken from the `X-Trace-Id` header.
// If `X-Trace-Id` header is not set, it will be generated automatically.
// Service will use the value of this field to make outgoing requests.
// Format: uuid (uuid)
// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
func (s AgentConnectedImpl) TraceID() *UUID {
	return s.TraceIDValue
}

// Unique identifier of the operation.
// You can use this field to search for events related to same operation.
// Value of this field is taken from the `X-Trace-Id` header.
// If `X-Trace-Id` header is not set, it will be generated automatically.
// Service will use the value of this field to make outgoing requests.
// Format: uuid (uuid)
// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
func (s *AgentConnectedImpl) SetTraceID(v UUID) AgentConnected {
	if s == nil {
		return nil
	}
	s.TraceIDValue = &v
	return s
}

// The time of the event registration on the server.
// Format: utc_ms (Unix timestamp in milliseconds)
func (s AgentConnectedImpl) UtcMs() *UtcMs {
	return s.UtcMsValue
}

// The time of the event registration on the server.
// Format: utc_ms (Unix timestamp in milliseconds)
func (s *AgentConnectedImpl) SetUtcMs(v UtcMs) AgentConnected {
	if s == nil {
		return nil
	}
	s.UtcMsValue = &v
	return s
}

// NewAgentDisconnected creates a new AgentDisconnected instance
func NewAgentDisconnected() AgentDisconnected {
	return &AgentDisconnectedImpl{}
}

// Unique identifier of the entity.
// For example, for `agent` it is `agent_id` field.
func (s AgentDisconnectedImpl) EntityID() *string {
	return s.EntityIDValue
}

// Unique identifier of the entity.
// For example, for `agent` it is `agent_id` field.
func (s *AgentDisconnectedImpl) SetEntityID(v string) AgentDisconnected {
	if s == nil {
		return nil
	}
	s.EntityIDValue = &v
	return s
}

// Type of the entity.
func (s AgentDisconnectedImpl) EntityType() *EntityEventEntityType {
	return s.EntityTypeValue
}

// Type of the entity.
func (s *AgentDisconnectedImpl) SetEntityType(v EntityEventEntityType) AgentDisconnected {
	if s == nil {
		return nil
	}
	s.EntityTypeValue = &v
	return s
}

// Agent disconnected from endpoint.
func (s AgentDisconnectedImpl) Event() string {
	return s.EventValue
}

// Agent disconnected from endpoint.
func (s *AgentDisconnectedImpl) SetEvent(v string) AgentDisconnected {
	if s == nil {
		return nil
	}
	s.EventValue = v
	return s
}

// Event identifier.
func (s AgentDisconnectedImpl) EventID() *int {
	return s.EventIDValue
}

// Event identifier.
func (s *AgentDisconnectedImpl) SetEventID(v int) AgentDisconnected {
	if s == nil {
		return nil
	}
	s.EventIDValue = &v
	return s
}

func (s AgentDisconnectedImpl) Initiator() *AgentInitiator {
	return s.InitiatorValue
}

func (s *AgentDisconnectedImpl) SetInitiator(v AgentInitiator) AgentDisconnected {
	if s == nil {
		return nil
	}
	s.InitiatorValue = &v
	return s
}

// Why agent disconnected
func (s AgentDisconnectedImpl) Reason() *AgentDisconnectedReason {
	return s.ReasonValue
}

// Why agent disconnected
func (s *AgentDisconnectedImpl) SetReason(v AgentDisconnectedReason) AgentDisconnected {
	if s == nil {
		return nil
	}
	s.ReasonValue = &v
	return s
}

// Originator of event.
// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
// is configured as HTTP/HTTPS url.
// Example: flussonic.host
func (s AgentDisconnectedImpl) Server() *string {
	return s.ServerValue
}

// Originator of event.
// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
// is configured as HTTP/HTTPS url.
// Example: flussonic.host
func (s *AgentDisconnectedImpl) SetServer(v string) AgentDisconnected {
	if s == nil {
		return nil
	}
	s.ServerValue = &v
	return s
}

// Unique identifier of the operation.
// You can use this field to search for events related to same operation.
// Value of this field is taken from the `X-Trace-Id` header.
// If `X-Trace-Id` header is not set, it will be generated automatically.
// Service will use the value of this field to make outgoing requests.
// Format: uuid (uuid)
// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
func (s AgentDisconnectedImpl) TraceID() *UUID {
	return s.TraceIDValue
}

// Unique identifier of the operation.
// You can use this field to search for events related to same operation.
// Value of this field is taken from the `X-Trace-Id` header.
// If `X-Trace-Id` header is not set, it will be generated automatically.
// Service will use the value of this field to make outgoing requests.
// Format: uuid (uuid)
// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
func (s *AgentDisconnectedImpl) SetTraceID(v UUID) AgentDisconnected {
	if s == nil {
		return nil
	}
	s.TraceIDValue = &v
	return s
}

// The time of the event registration on the server.
// Format: utc_ms (Unix timestamp in milliseconds)
func (s AgentDisconnectedImpl) UtcMs() *UtcMs {
	return s.UtcMsValue
}

// The time of the event registration on the server.
// Format: utc_ms (Unix timestamp in milliseconds)
func (s *AgentDisconnectedImpl) SetUtcMs(v UtcMs) AgentDisconnected {
	if s == nil {
		return nil
	}
	s.UtcMsValue = &v
	return s
}

// NewAgentMakeStreampointLocationError creates a new AgentMakeStreampointLocationError instance
func NewAgentMakeStreampointLocationError() AgentMakeStreampointLocationError {
	return &AgentMakeStreampointLocationErrorImpl{}
}

// Unique identifier of the entity.
// For example, for `agent` it is `agent_id` field.
func (s AgentMakeStreampointLocationErrorImpl) EntityID() *string {
	return s.EntityIDValue
}

// Unique identifier of the entity.
// For example, for `agent` it is `agent_id` field.
func (s *AgentMakeStreampointLocationErrorImpl) SetEntityID(v string) AgentMakeStreampointLocationError {
	if s == nil {
		return nil
	}
	s.EntityIDValue = &v
	return s
}

// Type of the entity.
func (s AgentMakeStreampointLocationErrorImpl) EntityType() *EntityEventEntityType {
	return s.EntityTypeValue
}

// Type of the entity.
func (s *AgentMakeStreampointLocationErrorImpl) SetEntityType(v EntityEventEntityType) AgentMakeStreampointLocationError {
	if s == nil {
		return nil
	}
	s.EntityTypeValue = &v
	return s
}

// Failed to make streampoint location for agent.
func (s AgentMakeStreampointLocationErrorImpl) Event() *string {
	return s.EventValue
}

// Failed to make streampoint location for agent.
func (s *AgentMakeStreampointLocationErrorImpl) SetEvent(v string) AgentMakeStreampointLocationError {
	if s == nil {
		return nil
	}
	s.EventValue = &v
	return s
}

// Event identifier.
func (s AgentMakeStreampointLocationErrorImpl) EventID() *int {
	return s.EventIDValue
}

// Event identifier.
func (s *AgentMakeStreampointLocationErrorImpl) SetEventID(v int) AgentMakeStreampointLocationError {
	if s == nil {
		return nil
	}
	s.EventIDValue = &v
	return s
}

// Additional information about the error.
func (s AgentMakeStreampointLocationErrorImpl) Message() *string {
	return s.MessageValue
}

// Additional information about the error.
func (s *AgentMakeStreampointLocationErrorImpl) SetMessage(v string) AgentMakeStreampointLocationError {
	if s == nil {
		return nil
	}
	s.MessageValue = &v
	return s
}

// Why agent failed to make streampoint location.
func (s AgentMakeStreampointLocationErrorImpl) Reason() *AgentMakeStreampointLocationErrorReason {
	return s.ReasonValue
}

// Why agent failed to make streampoint location.
func (s *AgentMakeStreampointLocationErrorImpl) SetReason(v AgentMakeStreampointLocationErrorReason) AgentMakeStreampointLocationError {
	if s == nil {
		return nil
	}
	s.ReasonValue = &v
	return s
}

// Originator of event.
// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
// is configured as HTTP/HTTPS url.
// Example: flussonic.host
func (s AgentMakeStreampointLocationErrorImpl) Server() *string {
	return s.ServerValue
}

// Originator of event.
// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
// is configured as HTTP/HTTPS url.
// Example: flussonic.host
func (s *AgentMakeStreampointLocationErrorImpl) SetServer(v string) AgentMakeStreampointLocationError {
	if s == nil {
		return nil
	}
	s.ServerValue = &v
	return s
}

// The hostname of current agent's streampoint.
func (s AgentMakeStreampointLocationErrorImpl) Streampoint() *string {
	return s.StreampointValue
}

// The hostname of current agent's streampoint.
func (s *AgentMakeStreampointLocationErrorImpl) SetStreampoint(v string) AgentMakeStreampointLocationError {
	if s == nil {
		return nil
	}
	s.StreampointValue = &v
	return s
}

// Unique identifier of the operation.
// You can use this field to search for events related to same operation.
// Value of this field is taken from the `X-Trace-Id` header.
// If `X-Trace-Id` header is not set, it will be generated automatically.
// Service will use the value of this field to make outgoing requests.
// Format: uuid (uuid)
// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
func (s AgentMakeStreampointLocationErrorImpl) TraceID() *UUID {
	return s.TraceIDValue
}

// Unique identifier of the operation.
// You can use this field to search for events related to same operation.
// Value of this field is taken from the `X-Trace-Id` header.
// If `X-Trace-Id` header is not set, it will be generated automatically.
// Service will use the value of this field to make outgoing requests.
// Format: uuid (uuid)
// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
func (s *AgentMakeStreampointLocationErrorImpl) SetTraceID(v UUID) AgentMakeStreampointLocationError {
	if s == nil {
		return nil
	}
	s.TraceIDValue = &v
	return s
}

// The time of the event registration on the server.
// Format: utc_ms (Unix timestamp in milliseconds)
func (s AgentMakeStreampointLocationErrorImpl) UtcMs() *UtcMs {
	return s.UtcMsValue
}

// The time of the event registration on the server.
// Format: utc_ms (Unix timestamp in milliseconds)
func (s *AgentMakeStreampointLocationErrorImpl) SetUtcMs(v UtcMs) AgentMakeStreampointLocationError {
	if s == nil {
		return nil
	}
	s.UtcMsValue = &v
	return s
}

// NewAuthBackendConfig creates a new AuthBackendConfig instance
func NewAuthBackendConfig() AuthBackendConfig {
	return &AuthBackendConfigImpl{}
}

// Explicit list of countries (two-letter country codes according to ISO 3166-1) that have access to the content without any other checks.
// Flussonic uses the MaxMind GeoLite2 Country database to map a country to a block of IP addresses.
// New releases of GeoIP2 databases come out more often than the releases of Flussonic server, so sometimes the used database can become outdated.
// Therefore we recommend you to install a separate GeoIP2 library and set up Flussonic to use it.
// Example: [RU US]
func (s AuthBackendConfigImpl) AllowCountries() []string {
	return s.AllowCountriesValue
}

// Explicit list of countries (two-letter country codes according to ISO 3166-1) that have access to the content without any other checks.
// Flussonic uses the MaxMind GeoLite2 Country database to map a country to a block of IP addresses.
// New releases of GeoIP2 databases come out more often than the releases of Flussonic server, so sometimes the used database can become outdated.
// Therefore we recommend you to install a separate GeoIP2 library and set up Flussonic to use it.
// Example: [RU US]
func (s *AuthBackendConfigImpl) SetAllowCountries(v []string) AuthBackendConfig {
	if s == nil {
		return nil
	}
	s.AllowCountriesValue = v
	return s
}

// This option defines the default behavior when all backends are not responding (usually, because of errors in HTTP responses) and the session is not started yet.
// If this option is enabled, all clients or devices except those listed in `deny` option will have access to the content.
// If this option is disabled, all clients or devices except those listed in `allow` option will not have access to the content.
func (s AuthBackendConfigImpl) AllowDefault() *bool {
	return s.AllowDefaultValue
}

// This option defines the default behavior when all backends are not responding (usually, because of errors in HTTP responses) and the session is not started yet.
// If this option is enabled, all clients or devices except those listed in `deny` option will have access to the content.
// If this option is disabled, all clients or devices except those listed in `allow` option will not have access to the content.
func (s *AuthBackendConfigImpl) SetAllowDefault(v bool) AuthBackendConfig {
	if s == nil {
		return nil
	}
	s.AllowDefaultValue = &v
	return s
}

// Explicit list of IP-addresses or subnet masks that have access to the content without any other checks.
// Example: [127.0.0.1 10.10.0.0/24]
func (s AuthBackendConfigImpl) AllowIps() []string {
	return s.AllowIpsValue
}

// Explicit list of IP-addresses or subnet masks that have access to the content without any other checks.
// Example: [127.0.0.1 10.10.0.0/24]
func (s *AuthBackendConfigImpl) SetAllowIps(v []string) AuthBackendConfig {
	if s == nil {
		return nil
	}
	s.AllowIpsValue = v
	return s
}

// Explicit list of tokens that give access to the content without any other checks.
// Example: [test_token1 test_token2]
func (s AuthBackendConfigImpl) AllowTokens() []string {
	return s.AllowTokensValue
}

// Explicit list of tokens that give access to the content without any other checks.
// Example: [test_token1 test_token2]
func (s *AuthBackendConfigImpl) SetAllowTokens(v []string) AuthBackendConfig {
	if s == nil {
		return nil
	}
	s.AllowTokensValue = v
	return s
}

// Explicit list of user agents (set-top boxes or browsers) that have access to the content without any other checks.
// Example: [AppleWebKit/533.3 (KHTML, like Gecko) VLC/3.0.8 LibVLC/3.0.8]
func (s AuthBackendConfigImpl) AllowUas() []string {
	return s.AllowUasValue
}

// Explicit list of user agents (set-top boxes or browsers) that have access to the content without any other checks.
// Example: [AppleWebKit/533.3 (KHTML, like Gecko) VLC/3.0.8 LibVLC/3.0.8]
func (s *AuthBackendConfigImpl) SetAllowUas(v []string) AuthBackendConfig {
	if s == nil {
		return nil
	}
	s.AllowUasValue = v
	return s
}

// URL(s) of the HTTP backend(s).
func (s AuthBackendConfigImpl) Backends() []AuthBackendURL {
	if s.BackendsValue == nil {
		return nil
	}
	result := make([]AuthBackendURL, len(s.BackendsValue))
	for i, item := range s.BackendsValue {
		result[i] = item
	}
	return result
}

// URL(s) of the HTTP backend(s).
func (s *AuthBackendConfigImpl) SetBackends(v []AuthBackendURL) AuthBackendConfig {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*AuthBackendURLImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*AuthBackendURLImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.BackendsValue = impl
	}
	return s
}

// Explicit list of countries (two-letter country codes according to ISO 3166-1) that are banned from accessing the content.
// Flussonic uses the MaxMind GeoLite2 Country database to map a country to a block of IP addresses.
// New releases of GeoIP2 databases come out more often than the releases of Flussonic server, so sometimes the used database can become outdated.
// Therefore we recommend you to install a separate GeoIP2 library and set up Flussonic to use it.
// Example: [RU GB]
func (s AuthBackendConfigImpl) DenyCountries() []string {
	return s.DenyCountriesValue
}

// Explicit list of countries (two-letter country codes according to ISO 3166-1) that are banned from accessing the content.
// Flussonic uses the MaxMind GeoLite2 Country database to map a country to a block of IP addresses.
// New releases of GeoIP2 databases come out more often than the releases of Flussonic server, so sometimes the used database can become outdated.
// Therefore we recommend you to install a separate GeoIP2 library and set up Flussonic to use it.
// Example: [RU GB]
func (s *AuthBackendConfigImpl) SetDenyCountries(v []string) AuthBackendConfig {
	if s == nil {
		return nil
	}
	s.DenyCountriesValue = v
	return s
}

// Explicit list of IP-addresses or subnet masks that are banned from accessing the content.
// Example: [8.8.8.8 10.10.0.0/24]
func (s AuthBackendConfigImpl) DenyIps() []string {
	return s.DenyIpsValue
}

// Explicit list of IP-addresses or subnet masks that are banned from accessing the content.
// Example: [8.8.8.8 10.10.0.0/24]
func (s *AuthBackendConfigImpl) SetDenyIps(v []string) AuthBackendConfig {
	if s == nil {
		return nil
	}
	s.DenyIpsValue = v
	return s
}

// Explicit list of tokens that deny access to the content and stop any other checks.
// Example: [test_token3 test_token4]
func (s AuthBackendConfigImpl) DenyTokens() []string {
	return s.DenyTokensValue
}

// Explicit list of tokens that deny access to the content and stop any other checks.
// Example: [test_token3 test_token4]
func (s *AuthBackendConfigImpl) SetDenyTokens(v []string) AuthBackendConfig {
	if s == nil {
		return nil
	}
	s.DenyTokensValue = v
	return s
}

// The list of user agents (set-top boxes or browsers) that are banned from accessing the content.
// Example: [Mobile Safari/533.3 VLC/3.0.8 LibVLC/3.0.8]
func (s AuthBackendConfigImpl) DenyUas() []string {
	return s.DenyUasValue
}

// The list of user agents (set-top boxes or browsers) that are banned from accessing the content.
// Example: [Mobile Safari/533.3 VLC/3.0.8 LibVLC/3.0.8]
func (s *AuthBackendConfigImpl) SetDenyUas(v []string) AuthBackendConfig {
	if s == nil {
		return nil
	}
	s.DenyUasValue = v
	return s
}

// Globally unique [`auth_backend`](https://flussonic.com/doc/complex-authorization-with-backends/) name.
// Format: auth_backend_name (auth_backend_name)
func (s AuthBackendConfigImpl) Name() AuthBackendName {
	return s.NameValue
}

// Globally unique [`auth_backend`](https://flussonic.com/doc/complex-authorization-with-backends/) name.
// Format: auth_backend_name (auth_backend_name)
func (s *AuthBackendConfigImpl) SetName(v AuthBackendName) AuthBackendConfig {
	if s == nil {
		return nil
	}
	s.NameValue = v
	return s
}

// NewAuthBackendURL creates a new AuthBackendURL instance
func NewAuthBackendURL() AuthBackendURL {
	return &AuthBackendURLImpl{}
}

// The URL of an HTTP backend.
// Example: http://stalker-1.iptv.net/auth.php
func (s AuthBackendURLImpl) URL() string {
	return s.URLValue
}

// The URL of an HTTP backend.
// Example: http://stalker-1.iptv.net/auth.php
func (s *AuthBackendURLImpl) SetURL(v string) AuthBackendURL {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// NewAuthBackendsList creates a new AuthBackendsList instance
func NewAuthBackendsList() AuthBackendsList {
	return &AuthBackendsListImpl{}
}

// Configurations of the authorization backends.
func (s AuthBackendsListImpl) AuthBackends() []AuthBackendConfig {
	if s.AuthBackendsValue == nil {
		return nil
	}
	result := make([]AuthBackendConfig, len(s.AuthBackendsValue))
	for i, item := range s.AuthBackendsValue {
		result[i] = item
	}
	return result
}

// Configurations of the authorization backends.
func (s *AuthBackendsListImpl) SetAuthBackends(v []AuthBackendConfig) AuthBackendsList {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*AuthBackendConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*AuthBackendConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.AuthBackendsValue = impl
	}
	return s
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s AuthBackendsListImpl) EstimatedCount() *int {
	return s.EstimatedCountValue
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s *AuthBackendsListImpl) SetEstimatedCount(v int) AuthBackendsList {
	if s == nil {
		return nil
	}
	s.EstimatedCountValue = &v
	return s
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s AuthBackendsListImpl) Next() *string {
	return s.NextValue
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s *AuthBackendsListImpl) SetNext(v string) AuthBackendsList {
	if s == nil {
		return nil
	}
	s.NextValue = &v
	return s
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s AuthBackendsListImpl) Prev() *string {
	return s.PrevValue
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s *AuthBackendsListImpl) SetPrev(v string) AuthBackendsList {
	if s == nil {
		return nil
	}
	s.PrevValue = &v
	return s
}

// An object with a list of different timings measured during this API call.
func (s AuthBackendsListImpl) Timing() any {
	return s.TimingValue
}

// An object with a list of different timings measured during this API call.
func (s *AuthBackendsListImpl) SetTiming(v any) AuthBackendsList {
	if s == nil {
		return nil
	}
	s.TimingValue = v
	return s
}

// Collection returns the collection items from AuthBackendsList
func (s AuthBackendsListImpl) Collection() []AuthBackendConfig {
	return s.AuthBackends()
}

// NewAuthResponseV1 creates a new AuthResponseV1 instance
func NewAuthResponseV1() AuthResponseV1 {
	return &AuthResponseV1Impl{}
}

// Configuration of injecting advertising video clips into played stream.
func (s AuthResponseV1Impl) AdInject() AuthResponseV1AdInject {
	return s.AdInjectValue
}

// Configuration of injecting advertising video clips into played stream.
func (s *AuthResponseV1Impl) SetAdInject(v AuthResponseV1AdInject) AuthResponseV1 {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*AuthResponseV1AdInjectImpl); ok {
		s.AdInjectValue = impl
	}
	return s
}

// Permitted DVR intervals.
// By default when no allowed_dvr_ranges defined all archive is available for requests.
// Empty list means no access.
func (s AuthResponseV1Impl) AllowedDvrRanges() []AuthResponseV1AllowedDvrRangesItem {
	if s.AllowedDvrRangesValue == nil {
		return nil
	}
	result := make([]AuthResponseV1AllowedDvrRangesItem, len(s.AllowedDvrRangesValue))
	for i, item := range s.AllowedDvrRangesValue {
		result[i] = item
	}
	return result
}

// Permitted DVR intervals.
// By default when no allowed_dvr_ranges defined all archive is available for requests.
// Empty list means no access.
func (s *AuthResponseV1Impl) SetAllowedDvrRanges(v []AuthResponseV1AllowedDvrRangesItem) AuthResponseV1 {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*AuthResponseV1AllowedDvrRangesItemImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*AuthResponseV1AllowedDvrRangesItemImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.AllowedDvrRangesValue = impl
	}
	return s
}

// NewAuthResponseV1AdInject creates a new AuthResponseV1AdInject instance
func NewAuthResponseV1AdInject() AuthResponseV1AdInject {
	return &AuthResponseV1AdInjectImpl{}
}

// The paths to the mid-roll advertising files in a VOD location.
// You may choose the mid-roll mode using the `midroll_insert_by` parameter.
// The order of mid-roll playback is defined by the order of values in the array.
// Example: [ad_vod/midroll1.mp4 ad_vod/midroll2.mp4]
func (s AuthResponseV1AdInjectImpl) Midroll() []string {
	return s.MidrollValue
}

// The paths to the mid-roll advertising files in a VOD location.
// You may choose the mid-roll mode using the `midroll_insert_by` parameter.
// The order of mid-roll playback is defined by the order of values in the array.
// Example: [ad_vod/midroll1.mp4 ad_vod/midroll2.mp4]
func (s *AuthResponseV1AdInjectImpl) SetMidroll(v []string) AuthResponseV1AdInject {
	if s == nil {
		return nil
	}
	s.MidrollValue = v
	return s
}

// When to perform midrolls.
func (s AuthResponseV1AdInjectImpl) MidrollInsertBy() *AuthResponseV1AdInjectMidrollInsertBy {
	return s.MidrollInsertByValue
}

// When to perform midrolls.
func (s *AuthResponseV1AdInjectImpl) SetMidrollInsertBy(v AuthResponseV1AdInjectMidrollInsertBy) AuthResponseV1AdInject {
	if s == nil {
		return nil
	}
	s.MidrollInsertByValue = &v
	return s
}

// The interval between showing mid-roll advertisement files.
// Use with `midroll_insert_by=interval` only.
// Example: 180
func (s AuthResponseV1AdInjectImpl) MidrollInterval() *int {
	return s.MidrollIntervalValue
}

// The interval between showing mid-roll advertisement files.
// Use with `midroll_insert_by=interval` only.
// Example: 180
func (s *AuthResponseV1AdInjectImpl) SetMidrollInterval(v int) AuthResponseV1AdInject {
	if s == nil {
		return nil
	}
	s.MidrollIntervalValue = &v
	return s
}

// You can use this option to choose SCTE-35 or SCTE-104 markers having this program_id only for this mid-roll.
// Use with `midroll_insert_by=splicing` only.
// Example: 1
func (s AuthResponseV1AdInjectImpl) MidrollProgramID() *int {
	return s.MidrollProgramIDValue
}

// You can use this option to choose SCTE-35 or SCTE-104 markers having this program_id only for this mid-roll.
// Use with `midroll_insert_by=splicing` only.
// Example: 1
func (s *AuthResponseV1AdInjectImpl) SetMidrollProgramID(v int) AuthResponseV1AdInject {
	if s == nil {
		return nil
	}
	s.MidrollProgramIDValue = &v
	return s
}

// The paths to the pre-roll advertising files in a VOD location.
// All the pre-roll files are played before switching to the main stream:
// * live main stream is *replaced* by the pre-roll so the content may be overlapped by the ads.
// * VOD main stream is entirely played after the pre-roll without overlapping like in a playlist.
// The order of pre-roll playback is defined by the order of values in the array.
// Example: [ad_vod/preroll1.mp4]
func (s AuthResponseV1AdInjectImpl) Preroll() []string {
	return s.PrerollValue
}

// The paths to the pre-roll advertising files in a VOD location.
// All the pre-roll files are played before switching to the main stream:
// * live main stream is *replaced* by the pre-roll so the content may be overlapped by the ads.
// * VOD main stream is entirely played after the pre-roll without overlapping like in a playlist.
// The order of pre-roll playback is defined by the order of values in the array.
// Example: [ad_vod/preroll1.mp4]
func (s *AuthResponseV1AdInjectImpl) SetPreroll(v []string) AuthResponseV1AdInject {
	if s == nil {
		return nil
	}
	s.PrerollValue = v
	return s
}

// The version of ad insertion mechanism used by Flussonic:
// * `v=1` is an extension of the authorization system, it works with HLS and DASH protocols only.
// The ad is inserted to the manifest (playlist), so plugins such as AdBlock can detect and block the advertisement.
// * `v=2` (default) provides more resistance to ad blockers.
// The ad replaces the stream segments within the play session so that it is impossible to distinguish
// whether it is a main stream segment or an ad segment.
// It also allows you to customize the advertisements for a particular user.
// Besides, it works with a single-period as well as a multi-period DASH.
// Example: 2
func (s AuthResponseV1AdInjectImpl) V() *int {
	return s.VValue
}

// The version of ad insertion mechanism used by Flussonic:
// * `v=1` is an extension of the authorization system, it works with HLS and DASH protocols only.
// The ad is inserted to the manifest (playlist), so plugins such as AdBlock can detect and block the advertisement.
// * `v=2` (default) provides more resistance to ad blockers.
// The ad replaces the stream segments within the play session so that it is impossible to distinguish
// whether it is a main stream segment or an ad segment.
// It also allows you to customize the advertisements for a particular user.
// Besides, it works with a single-period as well as a multi-period DASH.
// Example: 2
func (s *AuthResponseV1AdInjectImpl) SetV(v int) AuthResponseV1AdInject {
	if s == nil {
		return nil
	}
	s.VValue = &v
	return s
}

// NewAuthResponseV1AllowedDvrRangesItem creates a new AuthResponseV1AllowedDvrRangesItem instance
func NewAuthResponseV1AllowedDvrRangesItem() AuthResponseV1AllowedDvrRangesItem {
	return &AuthResponseV1AllowedDvrRangesItemImpl{}
}

// End of the interval, exclusive.
// Format: utc (Unix timestamp in seconds)
// Example: 1.71002e+09
func (s AuthResponseV1AllowedDvrRangesItemImpl) ClosedAt() *Utc {
	return s.ClosedAtValue
}

// End of the interval, exclusive.
// Format: utc (Unix timestamp in seconds)
// Example: 1.71002e+09
func (s *AuthResponseV1AllowedDvrRangesItemImpl) SetClosedAt(v Utc) AuthResponseV1AllowedDvrRangesItem {
	if s == nil {
		return nil
	}
	s.ClosedAtValue = &v
	return s
}

// Start of the interval, inclusive.
// Format: utc (Unix timestamp in seconds)
// Example: 1.71001e+09
func (s AuthResponseV1AllowedDvrRangesItemImpl) OpenedAt() *Utc {
	return s.OpenedAtValue
}

// Start of the interval, inclusive.
// Format: utc (Unix timestamp in seconds)
// Example: 1.71001e+09
func (s *AuthResponseV1AllowedDvrRangesItemImpl) SetOpenedAt(v Utc) AuthResponseV1AllowedDvrRangesItem {
	if s == nil {
		return nil
	}
	s.OpenedAtValue = &v
	return s
}

// NewAuthSpec creates a new AuthSpec instance
func NewAuthSpec() AuthSpec {
	return &AuthSpecImpl{}
}

// Explicit list of countries (two-letter country codes according to ISO 3166-1) that have access to the content without any other checks.
// Flussonic uses the MaxMind GeoLite2 Country database to map a country to a block of IP addresses.
// New releases of GeoIP2 databases come out more often than the releases of Flussonic server, so sometimes the used database can become outdated.
// Therefore we recommend you to install a separate GeoIP2 library and set up Flussonic to use it.
// Example: [US DE GB]
func (s AuthSpecImpl) AllowedCountries() []Iso3166 {
	return s.AllowedCountriesValue
}

// Explicit list of countries (two-letter country codes according to ISO 3166-1) that have access to the content without any other checks.
// Flussonic uses the MaxMind GeoLite2 Country database to map a country to a block of IP addresses.
// New releases of GeoIP2 databases come out more often than the releases of Flussonic server, so sometimes the used database can become outdated.
// Therefore we recommend you to install a separate GeoIP2 library and set up Flussonic to use it.
// Example: [US DE GB]
func (s *AuthSpecImpl) SetAllowedCountries(v []Iso3166) AuthSpec {
	if s == nil {
		return nil
	}
	s.AllowedCountriesValue = v
	return s
}

// Explicit list of countries (two-letter country codes according to ISO 3166-1) that are banned from accessing the content.
// Flussonic uses the MaxMind GeoLite2 Country database to map a country to a block of IP addresses.
// New releases of GeoIP2 databases come out more often than the releases of Flussonic server, so sometimes the used database can become outdated.
// Therefore we recommend you to install a separate GeoIP2 library and set up Flussonic to use it.
// Example: [US DE GB]
func (s AuthSpecImpl) DisallowedCountries() []Iso3166 {
	return s.DisallowedCountriesValue
}

// Explicit list of countries (two-letter country codes according to ISO 3166-1) that are banned from accessing the content.
// Flussonic uses the MaxMind GeoLite2 Country database to map a country to a block of IP addresses.
// New releases of GeoIP2 databases come out more often than the releases of Flussonic server, so sometimes the used database can become outdated.
// Therefore we recommend you to install a separate GeoIP2 library and set up Flussonic to use it.
// Example: [US DE GB]
func (s *AuthSpecImpl) SetDisallowedCountries(v []Iso3166) AuthSpec {
	if s == nil {
		return nil
	}
	s.DisallowedCountriesValue = v
	return s
}

// Specifying the domains, within which playing this video is allowed.
// This does not work for those clients that do not pass the value of Referer HTTP header.
// Example: [mycompany.com]
func (s AuthSpecImpl) Domains() []string {
	return s.DomainsValue
}

// Specifying the domains, within which playing this video is allowed.
// This does not work for those clients that do not pass the value of Referer HTTP header.
// Example: [mycompany.com]
func (s *AuthSpecImpl) SetDomains(v []string) AuthSpec {
	if s == nil {
		return nil
	}
	s.DomainsValue = v
	return s
}

// Some additional options.
func (s AuthSpecImpl) Extra() map[string]string {
	return s.ExtraValue
}

// Some additional options.
func (s *AuthSpecImpl) SetExtra(v map[string]string) AuthSpec {
	if s == nil {
		return nil
	}
	s.ExtraValue = v
	return s
}

// The maximal number of streams or files the user can view simultaneously.
// This limitation allows to prevent users from full restreaming to their servers.
// Example: 5000
func (s AuthSpecImpl) MaxSessions() *int {
	return s.MaxSessionsValue
}

// The maximal number of streams or files the user can view simultaneously.
// This limitation allows to prevent users from full restreaming to their servers.
// Example: 5000
func (s *AuthSpecImpl) SetMaxSessions(v int) AuthSpec {
	if s == nil {
		return nil
	}
	s.MaxSessionsValue = &v
	return s
}

// A list of keys to generate a session ID value, allowing to configure the authorization scheme
// which is a hash sum calculated as follows: `hash(name + ip + proto)`.
// This parameter allows to finish one session and start another one with the same authorization token.
// The keys `name`,`ip`, and `proto` are required.
// Example: [name token proto ip]
func (s AuthSpecImpl) SessionKeys() []SessionKey {
	return s.SessionKeysValue
}

// A list of keys to generate a session ID value, allowing to configure the authorization scheme
// which is a hash sum calculated as follows: `hash(name + ip + proto)`.
// This parameter allows to finish one session and start another one with the same authorization token.
// The keys `name`,`ip`, and `proto` are required.
// Example: [name token proto ip]
func (s *AuthSpecImpl) SetSessionKeys(v []SessionKey) AuthSpec {
	if s == nil {
		return nil
	}
	s.SessionKeysValue = v
	return s
}

// If this option is enabled and `max_sessions` limitation is used, the extra sessions are interrupted not immediately, but in 30 or 90 seconds.
// This can be useful for middlewares that cannot generate a new token for every new stream or file request
// and therefore need time to understand that all sessions are being used.
// Example: false
func (s AuthSpecImpl) SoftLimitation() *bool {
	return s.SoftLimitationValue
}

// If this option is enabled and `max_sessions` limitation is used, the extra sessions are interrupted not immediately, but in 30 or 90 seconds.
// This can be useful for middlewares that cannot generate a new token for every new stream or file request
// and therefore need time to understand that all sessions are being used.
// Example: false
func (s *AuthSpecImpl) SetSoftLimitation(v bool) AuthSpec {
	if s == nil {
		return nil
	}
	s.SoftLimitationValue = &v
	return s
}

// The URL of an HTTP backend.
// Example: http://middleware-address/auth/v2
func (s AuthSpecImpl) URL() *AuthURL {
	return s.URLValue
}

// The URL of an HTTP backend.
// Example: http://middleware-address/auth/v2
func (s *AuthSpecImpl) SetURL(v AuthURL) AuthSpec {
	if s == nil {
		return nil
	}
	s.URLValue = &v
	return s
}

// NewBackupConfig creates a new BackupConfig instance
func NewBackupConfig() BackupConfig {
	return &BackupConfigImpl{}
}

// The time (in seconds) for Flussonic to switch to the fallback source if the main source stops sending audio frames.
// Example: 5
func (s BackupConfigImpl) AudioTimeout() *int {
	return s.AudioTimeoutValue
}

// The time (in seconds) for Flussonic to switch to the fallback source if the main source stops sending audio frames.
// Example: 5
func (s *BackupConfigImpl) SetAudioTimeout(v int) BackupConfig {
	if s == nil {
		return nil
	}
	s.AudioTimeoutValue = &v
	return s
}

// Whether or not to record a backup to DVR.
// Set to `False` by default (backup is not recorded).
func (s BackupConfigImpl) Dvr() *bool {
	return s.DvrValue
}

// Whether or not to record a backup to DVR.
// Set to `False` by default (backup is not recorded).
func (s *BackupConfigImpl) SetDvr(v bool) BackupConfig {
	if s == nil {
		return nil
	}
	s.DvrValue = &v
	return s
}

// Path to the backup file in a VOD location on the server (**not on the local disk!**).
// The backup file is played to fill in a time interval when the source is down.
// Example: vod/blank.mp4
func (s BackupConfigImpl) File() *string {
	return s.FileValue
}

// Path to the backup file in a VOD location on the server (**not on the local disk!**).
// The backup file is played to fill in a time interval when the source is down.
// Example: vod/blank.mp4
func (s *BackupConfigImpl) SetFile(v string) BackupConfig {
	if s == nil {
		return nil
	}
	s.FileValue = &v
	return s
}

// The time (in seconds) for Flussonic to switch to the fallback source if the main source stops sending frames.
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// This option takes any type of frames into account.
// If you do not specify timeout specifically for a fallback source, then in the absence of frames, `source_timeout` of the main source will be used.
// Example: 10
func (s BackupConfigImpl) Timeout() *int {
	return s.TimeoutValue
}

// The time (in seconds) for Flussonic to switch to the fallback source if the main source stops sending frames.
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// This option takes any type of frames into account.
// If you do not specify timeout specifically for a fallback source, then in the absence of frames, `source_timeout` of the main source will be used.
// Example: 10
func (s *BackupConfigImpl) SetTimeout(v int) BackupConfig {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// Whether or not to transcode the backup file. Set to `True` by default.
// If set to `False`, backup file frames will bypass as-is to the output stream.
// Should not be set to `False` unless the backup file has the same stream characteristics
// as the live stream.
func (s BackupConfigImpl) Transcode() *bool {
	return s.TranscodeValue
}

// Whether or not to transcode the backup file. Set to `True` by default.
// If set to `False`, backup file frames will bypass as-is to the output stream.
// Should not be set to `False` unless the backup file has the same stream characteristics
// as the live stream.
func (s *BackupConfigImpl) SetTranscode(v bool) BackupConfig {
	if s == nil {
		return nil
	}
	s.TranscodeValue = &v
	return s
}

// The time (in seconds) for Flussonic to switch to the fallback source if the main source stops sending video frames.
// Example: 4
func (s BackupConfigImpl) VideoTimeout() *int {
	return s.VideoTimeoutValue
}

// The time (in seconds) for Flussonic to switch to the fallback source if the main source stops sending video frames.
// Example: 4
func (s *BackupConfigImpl) SetVideoTimeout(v int) BackupConfig {
	if s == nil {
		return nil
	}
	s.VideoTimeoutValue = &v
	return s
}

// NewBalancerConfig creates a new BalancerConfig instance
func NewBalancerConfig() BalancerConfig {
	return &BalancerConfigImpl{}
}

// Balancing mode
func (s BalancerConfigImpl) Mode() *BalancerConfigMode {
	return s.ModeValue
}

// Balancing mode
func (s *BalancerConfigImpl) SetMode(v BalancerConfigMode) BalancerConfig {
	if s == nil {
		return nil
	}
	s.ModeValue = &v
	return s
}

// Globally unique balancer name.
// Format: media_name (media_name)
func (s BalancerConfigImpl) Name() *MediaName {
	return s.NameValue
}

// Globally unique balancer name.
// Format: media_name (media_name)
func (s *BalancerConfigImpl) SetName(v MediaName) BalancerConfig {
	if s == nil {
		return nil
	}
	s.NameValue = &v
	return s
}

// Balancer will distribute requests between these servers.
func (s BalancerConfigImpl) Servers() []BalancerServerConfig {
	if s.ServersValue == nil {
		return nil
	}
	result := make([]BalancerServerConfig, len(s.ServersValue))
	for i, item := range s.ServersValue {
		result[i] = item
	}
	return result
}

// Balancer will distribute requests between these servers.
func (s *BalancerConfigImpl) SetServers(v []BalancerServerConfig) BalancerConfig {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*BalancerServerConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*BalancerServerConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.ServersValue = impl
	}
	return s
}

// NewBalancerServerConfig creates a new BalancerServerConfig instance
func NewBalancerServerConfig() BalancerServerConfig {
	return &BalancerServerConfigImpl{}
}

// Client will be redirected to the peer if its IP belongs to one of these countries.
func (s BalancerServerConfigImpl) Countries() []Iso3166 {
	return s.CountriesValue
}

// Client will be redirected to the peer if its IP belongs to one of these countries.
func (s *BalancerServerConfigImpl) SetCountries(v []Iso3166) BalancerServerConfig {
	if s == nil {
		return nil
	}
	s.CountriesValue = v
	return s
}

// This flag allows to redirect a request to this peer if "countries" list not matched.
func (s BalancerServerConfigImpl) CountriesDefault() *bool {
	return s.CountriesDefaultValue
}

// This flag allows to redirect a request to this peer if "countries" list not matched.
func (s *BalancerServerConfigImpl) SetCountriesDefault(v bool) BalancerServerConfig {
	if s == nil {
		return nil
	}
	s.CountriesDefaultValue = &v
	return s
}

// Maximum allowed bitrate, request is redirecting if current bitrate is lower.
// Format: speed (speed)
func (s BalancerServerConfigImpl) MaxBitrate() *Speed {
	return s.MaxBitrateValue
}

// Maximum allowed bitrate, request is redirecting if current bitrate is lower.
// Format: speed (speed)
func (s *BalancerServerConfigImpl) SetMaxBitrate(v Speed) BalancerServerConfig {
	if s == nil {
		return nil
	}
	s.MaxBitrateValue = &v
	return s
}

// Hostname of the peer. Can refer to globally defined peer.
// Format: server_name (server_name)
func (s BalancerServerConfigImpl) Name() *ServerName {
	return s.NameValue
}

// Hostname of the peer. Can refer to globally defined peer.
// Format: server_name (server_name)
func (s *BalancerServerConfigImpl) SetName(v ServerName) BalancerServerConfig {
	if s == nil {
		return nil
	}
	s.NameValue = &v
	return s
}

// NewBalancersList creates a new BalancersList instance
func NewBalancersList() BalancersList {
	return &BalancersListImpl{}
}

// The list of balancers.
func (s BalancersListImpl) Balancers() []BalancerConfig {
	if s.BalancersValue == nil {
		return nil
	}
	result := make([]BalancerConfig, len(s.BalancersValue))
	for i, item := range s.BalancersValue {
		result[i] = item
	}
	return result
}

// The list of balancers.
func (s *BalancersListImpl) SetBalancers(v []BalancerConfig) BalancersList {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*BalancerConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*BalancerConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.BalancersValue = impl
	}
	return s
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s BalancersListImpl) EstimatedCount() *int {
	return s.EstimatedCountValue
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s *BalancersListImpl) SetEstimatedCount(v int) BalancersList {
	if s == nil {
		return nil
	}
	s.EstimatedCountValue = &v
	return s
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s BalancersListImpl) Next() *string {
	return s.NextValue
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s *BalancersListImpl) SetNext(v string) BalancersList {
	if s == nil {
		return nil
	}
	s.NextValue = &v
	return s
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s BalancersListImpl) Prev() *string {
	return s.PrevValue
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s *BalancersListImpl) SetPrev(v string) BalancersList {
	if s == nil {
		return nil
	}
	s.PrevValue = &v
	return s
}

// An object with a list of different timings measured during this API call.
func (s BalancersListImpl) Timing() any {
	return s.TimingValue
}

// An object with a list of different timings measured during this API call.
func (s *BalancersListImpl) SetTiming(v any) BalancersList {
	if s == nil {
		return nil
	}
	s.TimingValue = v
	return s
}

// Collection returns the collection items from BalancersList
func (s BalancersListImpl) Collection() []BalancerConfig {
	return s.Balancers()
}

// NewCentralAgentConfig creates a new CentralAgentConfig instance
func NewCentralAgentConfig() CentralAgentConfig {
	return &CentralAgentConfigImpl{}
}

// Agent identifier
// Example: 1234567
func (s CentralAgentConfigImpl) ID() *string {
	return s.IDValue
}

// Agent identifier
// Example: 1234567
func (s *CentralAgentConfigImpl) SetID(v string) CentralAgentConfig {
	if s == nil {
		return nil
	}
	s.IDValue = &v
	return s
}

// Agent authentication key.
func (s CentralAgentConfigImpl) Key() *string {
	return s.KeyValue
}

// Agent authentication key.
func (s *CentralAgentConfigImpl) SetKey(v string) CentralAgentConfig {
	if s == nil {
		return nil
	}
	s.KeyValue = &v
	return s
}

// Current layout of agent.
// This field will be ignored for agents with an existing stream on update, use `stream.layout` instead.
// Central will provide configuration to nodes based on this layout.
func (s CentralAgentConfigImpl) Layout() CentralStreamLayoutBase {
	return s.LayoutValue
}

// Current layout of agent.
// This field will be ignored for agents with an existing stream on update, use `stream.layout` instead.
// Central will provide configuration to nodes based on this layout.
func (s *CentralAgentConfigImpl) SetLayout(v CentralStreamLayoutBase) CentralAgentConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*CentralStreamLayoutBaseImpl); ok {
		s.LayoutValue = impl
	}
	return s
}

// Agents's metrics and other statistical information.
func (s CentralAgentConfigImpl) Stats() WatcherAgentStats {
	return s.StatsValue
}

// Agents's metrics and other statistical information.
func (s *CentralAgentConfigImpl) SetStats(v WatcherAgentStats) CentralAgentConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*WatcherAgentStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// NewCentralAgentLayoutList creates a new CentralAgentLayoutList instance
func NewCentralAgentLayoutList() CentralAgentLayoutList {
	return &CentralAgentLayoutListImpl{}
}

// List of agent layouts
func (s CentralAgentLayoutListImpl) Layouts() []CentralAgentLayoutListItem {
	if s.LayoutsValue == nil {
		return nil
	}
	result := make([]CentralAgentLayoutListItem, len(s.LayoutsValue))
	for i, item := range s.LayoutsValue {
		result[i] = item
	}
	return result
}

// List of agent layouts
func (s *CentralAgentLayoutListImpl) SetLayouts(v []CentralAgentLayoutListItem) CentralAgentLayoutList {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*CentralAgentLayoutListItemImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*CentralAgentLayoutListItemImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.LayoutsValue = impl
	}
	return s
}

// NewCentralAgentLayoutListItem creates a new CentralAgentLayoutListItem instance
func NewCentralAgentLayoutListItem() CentralAgentLayoutListItem {
	return &CentralAgentLayoutListItemImpl{}
}

// Time when the node change occurred
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s CentralAgentLayoutListItemImpl) CreatedAt() *UtcMs {
	return s.CreatedAtValue
}

// Time when the node change occurred
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s *CentralAgentLayoutListItemImpl) SetCreatedAt(v UtcMs) CentralAgentLayoutListItem {
	if s == nil {
		return nil
	}
	s.CreatedAtValue = &v
	return s
}

// ID of the agent
func (s CentralAgentLayoutListItemImpl) ID() *string {
	return s.IDValue
}

// ID of the agent
func (s *CentralAgentLayoutListItemImpl) SetID(v string) CentralAgentLayoutListItem {
	if s == nil {
		return nil
	}
	s.IDValue = &v
	return s
}

// Hostname of current ingest on which the stream is being captured
// Format: server_name (server_name)
func (s CentralAgentLayoutListItemImpl) Ingest() *ServerName {
	return s.IngestValue
}

// Hostname of current ingest on which the stream is being captured
// Format: server_name (server_name)
func (s *CentralAgentLayoutListItemImpl) SetIngest(v ServerName) CentralAgentLayoutListItem {
	if s == nil {
		return nil
	}
	s.IngestValue = &v
	return s
}

// Service or admin user who changed the layout of the stream using an API call.
func (s CentralAgentLayoutListItemImpl) Originator() *CentralStreamLayoutOriginator {
	return s.OriginatorValue
}

// Service or admin user who changed the layout of the stream using an API call.
func (s *CentralAgentLayoutListItemImpl) SetOriginator(v CentralStreamLayoutOriginator) CentralAgentLayoutListItem {
	if s == nil {
		return nil
	}
	s.OriginatorValue = &v
	return s
}

// NewCentralAgentsList creates a new CentralAgentsList instance
func NewCentralAgentsList() CentralAgentsList {
	return &CentralAgentsListImpl{}
}

// The list of Agents fetched according to the query parameters.
func (s CentralAgentsListImpl) Agents() []CentralAgentConfig {
	if s.AgentsValue == nil {
		return nil
	}
	result := make([]CentralAgentConfig, len(s.AgentsValue))
	for i, item := range s.AgentsValue {
		result[i] = item
	}
	return result
}

// The list of Agents fetched according to the query parameters.
func (s *CentralAgentsListImpl) SetAgents(v []CentralAgentConfig) CentralAgentsList {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*CentralAgentConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*CentralAgentConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.AgentsValue = impl
	}
	return s
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s CentralAgentsListImpl) EstimatedCount() *int {
	return s.EstimatedCountValue
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s *CentralAgentsListImpl) SetEstimatedCount(v int) CentralAgentsList {
	if s == nil {
		return nil
	}
	s.EstimatedCountValue = &v
	return s
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s CentralAgentsListImpl) Next() *string {
	return s.NextValue
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s *CentralAgentsListImpl) SetNext(v string) CentralAgentsList {
	if s == nil {
		return nil
	}
	s.NextValue = &v
	return s
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s CentralAgentsListImpl) Prev() *string {
	return s.PrevValue
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s *CentralAgentsListImpl) SetPrev(v string) CentralAgentsList {
	if s == nil {
		return nil
	}
	s.PrevValue = &v
	return s
}

// An object with a list of different timings measured during this API call.
func (s CentralAgentsListImpl) Timing() any {
	return s.TimingValue
}

// An object with a list of different timings measured during this API call.
func (s *CentralAgentsListImpl) SetTiming(v any) CentralAgentsList {
	if s == nil {
		return nil
	}
	s.TimingValue = v
	return s
}

// Collection returns the collection items from CentralAgentsList
func (s CentralAgentsListImpl) Collection() []CentralAgentConfig {
	return s.Agents()
}

// NewCentralConfig creates a new CentralConfig instance
func NewCentralConfig() CentralConfig {
	return &CentralConfigImpl{}
}

// API_KEY is used to access Central API
// Example: api_key
func (s CentralConfigImpl) APIKey() string {
	return s.APIKeyValue
}

// API_KEY is used to access Central API
// Example: api_key
func (s *CentralConfigImpl) SetAPIKey(v string) CentralConfig {
	if s == nil {
		return nil
	}
	s.APIKeyValue = v
	return s
}

// API URL used for setting the hostname and port under which Central is accessible by Flussonic for CONFIG_EXTERNAL and http_proxy requests
// Format: url (url)
// Example: http://central.ru:9019/streamer/api/v3
func (s CentralConfigImpl) APIURL() *URL {
	return s.APIURLValue
}

// API URL used for setting the hostname and port under which Central is accessible by Flussonic for CONFIG_EXTERNAL and http_proxy requests
// Format: url (url)
// Example: http://central.ru:9019/streamer/api/v3
func (s *CentralConfigImpl) SetAPIURL(v URL) CentralConfig {
	if s == nil {
		return nil
	}
	s.APIURLValue = &v
	return s
}

// Describes how entral interacts with nodes in the cluster
func (s CentralConfigImpl) Cluster() CentralConfigCluster {
	return s.ClusterValue
}

// Describes how entral interacts with nodes in the cluster
func (s *CentralConfigImpl) SetCluster(v CentralConfigCluster) CentralConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*CentralConfigClusterImpl); ok {
		s.ClusterValue = impl
	}
	return s
}

// You can use the default value or increase it to reduce server load, but increase time for the streamer to receive changes.
// Example: 5000
func (s CentralConfigImpl) ConfigExternalReconciliationInterval() *float64 {
	return s.ConfigExternalReconciliationIntervalValue
}

// You can use the default value or increase it to reduce server load, but increase time for the streamer to receive changes.
// Example: 5000
func (s *CentralConfigImpl) SetConfigExternalReconciliationInterval(v float64) CentralConfig {
	if s == nil {
		return nil
	}
	s.ConfigExternalReconciliationIntervalValue = &v
	return s
}

// The configuration of database connection
func (s CentralConfigImpl) Database() CentralConfigDatabase {
	return s.DatabaseValue
}

// The configuration of database connection
func (s *CentralConfigImpl) SetDatabase(v CentralConfigDatabase) CentralConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*CentralConfigDatabaseImpl); ok {
		s.DatabaseValue = impl
	}
	return s
}

// Credentials for administrator access to the server.
func (s CentralConfigImpl) EditAuth() AdminCredentials {
	return s.EditAuthValue
}

// Credentials for administrator access to the server.
func (s *CentralConfigImpl) SetEditAuth(v AdminCredentials) CentralConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*AdminCredentialsImpl); ok {
		s.EditAuthValue = impl
	}
	return s
}

// Delay in milliseconds after which episodes from the buffer will be inserted into the database.
// Set 0 to disable buffer accumulation before inserting episodes into the database.
// Format: milliseconds (milliseconds)
// Example: 3000
func (s CentralConfigImpl) EpisodesBufferDelay() *Milliseconds {
	return s.EpisodesBufferDelayValue
}

// Delay in milliseconds after which episodes from the buffer will be inserted into the database.
// Set 0 to disable buffer accumulation before inserting episodes into the database.
// Format: milliseconds (milliseconds)
// Example: 3000
func (s *CentralConfigImpl) SetEpisodesBufferDelay(v Milliseconds) CentralConfig {
	if s == nil {
		return nil
	}
	s.EpisodesBufferDelayValue = &v
	return s
}

// Limit on the number of episodes in the buffer.
// If the number of episodes in the buffer exceeds the limit, the insertion into the database will be done instantly, regardless of the limit.
// Set 0 to disable buffer accumulation before inserting episodes into the database.
// Example: 100
func (s CentralConfigImpl) EpisodesBufferLimit() *float64 {
	return s.EpisodesBufferLimitValue
}

// Limit on the number of episodes in the buffer.
// If the number of episodes in the buffer exceeds the limit, the insertion into the database will be done instantly, regardless of the limit.
// Set 0 to disable buffer accumulation before inserting episodes into the database.
// Example: 100
func (s *CentralConfigImpl) SetEpisodesBufferLimit(v float64) CentralConfig {
	if s == nil {
		return nil
	}
	s.EpisodesBufferLimitValue = &v
	return s
}

// Enables layouter
// Example: false
func (s CentralConfigImpl) LayouterEnabled() *string {
	return s.LayouterEnabledValue
}

// Enables layouter
// Example: false
func (s *CentralConfigImpl) SetLayouterEnabled(v string) CentralConfig {
	if s == nil {
		return nil
	}
	s.LayouterEnabledValue = &v
	return s
}

// Interval in milliseconds between layouter runs
// Format: milliseconds (milliseconds)
// Example: 30000
func (s CentralConfigImpl) LayouterSleepingInterval() *Milliseconds {
	return s.LayouterSleepingIntervalValue
}

// Interval in milliseconds between layouter runs
// Format: milliseconds (milliseconds)
// Example: 30000
func (s *CentralConfigImpl) SetLayouterSleepingInterval(v Milliseconds) CentralConfig {
	if s == nil {
		return nil
	}
	s.LayouterSleepingIntervalValue = &v
	return s
}

// The configuration of network listeners.
func (s CentralConfigImpl) Listeners() Listeners {
	return s.ListenersValue
}

// The configuration of network listeners.
func (s *CentralConfigImpl) SetListeners(v Listeners) CentralConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ListenersImpl); ok {
		s.ListenersValue = impl
	}
	return s
}

// Enables logging HTTP-requests
// Example: false
func (s CentralConfigImpl) LogRequests() *string {
	return s.LogRequestsValue
}

// Enables logging HTTP-requests
// Example: false
func (s *CentralConfigImpl) SetLogRequests(v string) CentralConfig {
	if s == nil {
		return nil
	}
	s.LogRequestsValue = &v
	return s
}

// Set logging level
// Example: error
func (s CentralConfigImpl) Loglevel() *Loglevel {
	return s.LoglevelValue
}

// Set logging level
// Example: error
func (s *CentralConfigImpl) SetLoglevel(v Loglevel) CentralConfig {
	if s == nil {
		return nil
	}
	s.LoglevelValue = &v
	return s
}

// URL (agent or collector) that is used to collect traces and spans with configuration in query parameters.
// FORMAT: `http://{JAEGER-URL}?service_name={CENTRAL_NAME}` (The prefix central will be added to the service name)
// Format: url (url)
// Example: http://jaeger-server:14268/v1/traces?service_name=some-name
func (s CentralConfigImpl) OpentelemetryURL() *URL {
	return s.OpentelemetryURLValue
}

// URL (agent or collector) that is used to collect traces and spans with configuration in query parameters.
// FORMAT: `http://{JAEGER-URL}?service_name={CENTRAL_NAME}` (The prefix central will be added to the service name)
// Format: url (url)
// Example: http://jaeger-server:14268/v1/traces?service_name=some-name
func (s *CentralConfigImpl) SetOpentelemetryURL(v URL) CentralConfig {
	if s == nil {
		return nil
	}
	s.OpentelemetryURLValue = &v
	return s
}

// The configuration of Redis connection.
// If not specified, Central will store temporary data in memory.
// Using Redis is useful in multi-instance installation to store data between instances. In other cases specifying this field is not recommended.
func (s CentralConfigImpl) Redis() CentralConfigRedis {
	return s.RedisValue
}

// The configuration of Redis connection.
// If not specified, Central will store temporary data in memory.
// Using Redis is useful in multi-instance installation to store data between instances. In other cases specifying this field is not recommended.
func (s *CentralConfigImpl) SetRedis(v CentralConfigRedis) CentralConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*CentralConfigRedisImpl); ok {
		s.RedisValue = impl
	}
	return s
}

// Unique server ID generated on a first start or license change.
// Should not changing until running on the same hardware.
// Format: uuid (uuid)
func (s CentralConfigImpl) ServerID() *UUID {
	return s.ServerIDValue
}

// Unique server ID generated on a first start or license change.
// Should not changing until running on the same hardware.
// Format: uuid (uuid)
func (s *CentralConfigImpl) SetServerID(v UUID) CentralConfig {
	if s == nil {
		return nil
	}
	s.ServerIDValue = &v
	return s
}

// Server runtime stats
func (s CentralConfigImpl) Stats() CentralStats {
	return s.StatsValue
}

// Server runtime stats
func (s *CentralConfigImpl) SetStats(v CentralStats) CentralConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*CentralStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// The number of failed health checks in the last hour after which the streamer is considered unhealthy.
// Useful for identifying unstable streamer.
// Example: 5
func (s CentralConfigImpl) StreamerHealthcheckFailsThreshold() *float64 {
	return s.StreamerHealthcheckFailsThresholdValue
}

// The number of failed health checks in the last hour after which the streamer is considered unhealthy.
// Useful for identifying unstable streamer.
// Example: 5
func (s *CentralConfigImpl) SetStreamerHealthcheckFailsThreshold(v float64) CentralConfig {
	if s == nil {
		return nil
	}
	s.StreamerHealthcheckFailsThresholdValue = &v
	return s
}

// NewCentralConfigCluster creates a new CentralConfigCluster instance
func NewCentralConfigCluster() CentralConfigCluster {
	return &CentralConfigClusterImpl{}
}

// If enabled Central will provide [configuration](#tag/streamer/operation/streamer_save%7Cbody__0%7Cconfig) to nodes in cluster.
// Also, Central will automatically provide `config_external` configuration to nodes.
// You must disable this option if you are using orchestration system for deployment and management.
// Example: true
func (s CentralConfigClusterImpl) NodeConfigProvisionEnabled() *bool {
	return s.NodeConfigProvisionEnabledValue
}

// If enabled Central will provide [configuration](#tag/streamer/operation/streamer_save%7Cbody__0%7Cconfig) to nodes in cluster.
// Also, Central will automatically provide `config_external` configuration to nodes.
// You must disable this option if you are using orchestration system for deployment and management.
// Example: true
func (s *CentralConfigClusterImpl) SetNodeConfigProvisionEnabled(v bool) CentralConfigCluster {
	if s == nil {
		return nil
	}
	s.NodeConfigProvisionEnabledValue = &v
	return s
}

// Number of retries for sending requests to streamers
// Example: 5
func (s CentralConfigClusterImpl) StreamerConnectorRetries() *int {
	return s.StreamerConnectorRetriesValue
}

// Number of retries for sending requests to streamers
// Example: 5
func (s *CentralConfigClusterImpl) SetStreamerConnectorRetries(v int) CentralConfigCluster {
	if s == nil {
		return nil
	}
	s.StreamerConnectorRetriesValue = &v
	return s
}

// NewCentralConfigDatabase creates a new CentralConfigDatabase instance
func NewCentralConfigDatabase() CentralConfigDatabase {
	return &CentralConfigDatabaseImpl{}
}

// The number of retries for Central to connect with its database
// Example: 20
func (s CentralConfigDatabaseImpl) ConnectMaxRetries() *int {
	return s.ConnectMaxRetriesValue
}

// The number of retries for Central to connect with its database
// Example: 20
func (s *CentralConfigDatabaseImpl) SetConnectMaxRetries(v int) CentralConfigDatabase {
	if s == nil {
		return nil
	}
	s.ConnectMaxRetriesValue = &v
	return s
}

// Timeout of retry for Central to connect with its database
// Example: 2s
func (s CentralConfigDatabaseImpl) ConnectRetryTimeout() *string {
	return s.ConnectRetryTimeoutValue
}

// Timeout of retry for Central to connect with its database
// Example: 2s
func (s *CentralConfigDatabaseImpl) SetConnectRetryTimeout(v string) CentralConfigDatabase {
	if s == nil {
		return nil
	}
	s.ConnectRetryTimeoutValue = &v
	return s
}

// Max connection pool size that Central use to connect with database
// Example: 40
func (s CentralConfigDatabaseImpl) MaxConnections() *int {
	return s.MaxConnectionsValue
}

// Max connection pool size that Central use to connect with database
// Example: 40
func (s *CentralConfigDatabaseImpl) SetMaxConnections(v int) CentralConfigDatabase {
	if s == nil {
		return nil
	}
	s.MaxConnectionsValue = &v
	return s
}

// Connection string to PostgreSQL database.
// Format: `postgres://[user[:password]@][host][:port][/dbname][?param1=value1&...&paramN=valueN]`
// Allowed parameters:
// - `sslmode` - configuring SSL connection to the database.
// This parameter defines whether and how SSL should be used to connect to the database.
// Possible values include `disable`, `allow`, `prefer`, `require`, `verify-ca`, and `verify-full`.
// - `default_query_exec_mode` - if you use PgBouncer, it's necessary to set this parameter to `cache_describe`.
// Example: postgres://central:pass@localhost:5432/central_dev
func (s CentralConfigDatabaseImpl) URL() string {
	return s.URLValue
}

// Connection string to PostgreSQL database.
// Format: `postgres://[user[:password]@][host][:port][/dbname][?param1=value1&...&paramN=valueN]`
// Allowed parameters:
// - `sslmode` - configuring SSL connection to the database.
// This parameter defines whether and how SSL should be used to connect to the database.
// Possible values include `disable`, `allow`, `prefer`, `require`, `verify-ca`, and `verify-full`.
// - `default_query_exec_mode` - if you use PgBouncer, it's necessary to set this parameter to `cache_describe`.
// Example: postgres://central:pass@localhost:5432/central_dev
func (s *CentralConfigDatabaseImpl) SetURL(v string) CentralConfigDatabase {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// NewCentralConfigRedis creates a new CentralConfigRedis instance
func NewCentralConfigRedis() CentralConfigRedis {
	return &CentralConfigRedisImpl{}
}

// The number of retries for Central to connect with its database
// Example: 20
func (s CentralConfigRedisImpl) ConnectMaxRetries() *int {
	return s.ConnectMaxRetriesValue
}

// The number of retries for Central to connect with its database
// Example: 20
func (s *CentralConfigRedisImpl) SetConnectMaxRetries(v int) CentralConfigRedis {
	if s == nil {
		return nil
	}
	s.ConnectMaxRetriesValue = &v
	return s
}

// Timeout of retry for Central to connect with its database
// Example: 2s
func (s CentralConfigRedisImpl) ConnectRetryTimeout() *string {
	return s.ConnectRetryTimeoutValue
}

// Timeout of retry for Central to connect with its database
// Example: 2s
func (s *CentralConfigRedisImpl) SetConnectRetryTimeout(v string) CentralConfigRedis {
	if s == nil {
		return nil
	}
	s.ConnectRetryTimeoutValue = &v
	return s
}

// Max connection pool size that Central use to connect with database
// Example: 40
func (s CentralConfigRedisImpl) MaxConnections() *int {
	return s.MaxConnectionsValue
}

// Max connection pool size that Central use to connect with database
// Example: 40
func (s *CentralConfigRedisImpl) SetMaxConnections(v int) CentralConfigRedis {
	if s == nil {
		return nil
	}
	s.MaxConnectionsValue = &v
	return s
}

// Connection string to Redis database
// Format: `redis://[:<password>]@<host>:<port>/<db>`
// Example: redis://:pass@localhost:6379
func (s CentralConfigRedisImpl) URL() *string {
	return s.URLValue
}

// Connection string to Redis database
// Format: `redis://[:<password>]@<host>:<port>/<db>`
// Example: redis://:pass@localhost:6379
func (s *CentralConfigRedisImpl) SetURL(v string) CentralConfigRedis {
	if s == nil {
		return nil
	}
	s.URLValue = &v
	return s
}

// NewCentralDiskPredictions creates a new CentralDiskPredictions instance
func NewCentralDiskPredictions() CentralDiskPredictions {
	return &CentralDiskPredictionsImpl{}
}

// Estimated disk usage in percent.
// This value is estimated on the based on streamer disk space and current configurations of streams processed by the streamer,
// which specify the rate of data writing to disk by them and the duration of their data storage.
// Note: This value represents what percentage of the disk will be filled when all streams on the streamer reach the point where the disk is static.
// It can be greater than 100% if streamer can't store estimated amount of data.
// Format: percent (percent)
func (s CentralDiskPredictionsImpl) EstimatedDiskUsage() *Percent {
	return s.EstimatedDiskUsageValue
}

// Estimated disk usage in percent.
// This value is estimated on the based on streamer disk space and current configurations of streams processed by the streamer,
// which specify the rate of data writing to disk by them and the duration of their data storage.
// Note: This value represents what percentage of the disk will be filled when all streams on the streamer reach the point where the disk is static.
// It can be greater than 100% if streamer can't store estimated amount of data.
// Format: percent (percent)
func (s *CentralDiskPredictionsImpl) SetEstimatedDiskUsage(v Percent) CentralDiskPredictions {
	if s == nil {
		return nil
	}
	s.EstimatedDiskUsageValue = &v
	return s
}

// NewCentralDvrConfig creates a new CentralDvrConfig instance
func NewCentralDvrConfig() CentralDvrConfig {
	return &CentralDvrConfigImpl{}
}

// DVR configuration name.
// Format: dvr_name (dvr_name)
func (s CentralDvrConfigImpl) Name() *DvrName {
	return s.NameValue
}

// DVR configuration name.
// Format: dvr_name (dvr_name)
func (s *CentralDvrConfigImpl) SetName(v DvrName) CentralDvrConfig {
	if s == nil {
		return nil
	}
	s.NameValue = &v
	return s
}

// NewCentralDvrsList creates a new CentralDvrsList instance
func NewCentralDvrsList() CentralDvrsList {
	return &CentralDvrsListImpl{}
}

// List of available dvr storages
func (s CentralDvrsListImpl) Dvrs() []CentralDvrConfig {
	if s.DvrsValue == nil {
		return nil
	}
	result := make([]CentralDvrConfig, len(s.DvrsValue))
	for i, item := range s.DvrsValue {
		result[i] = item
	}
	return result
}

// List of available dvr storages
func (s *CentralDvrsListImpl) SetDvrs(v []CentralDvrConfig) CentralDvrsList {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*CentralDvrConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*CentralDvrConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.DvrsValue = impl
	}
	return s
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s CentralDvrsListImpl) EstimatedCount() *int {
	return s.EstimatedCountValue
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s *CentralDvrsListImpl) SetEstimatedCount(v int) CentralDvrsList {
	if s == nil {
		return nil
	}
	s.EstimatedCountValue = &v
	return s
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s CentralDvrsListImpl) Next() *string {
	return s.NextValue
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s *CentralDvrsListImpl) SetNext(v string) CentralDvrsList {
	if s == nil {
		return nil
	}
	s.NextValue = &v
	return s
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s CentralDvrsListImpl) Prev() *string {
	return s.PrevValue
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s *CentralDvrsListImpl) SetPrev(v string) CentralDvrsList {
	if s == nil {
		return nil
	}
	s.PrevValue = &v
	return s
}

// An object with a list of different timings measured during this API call.
func (s CentralDvrsListImpl) Timing() any {
	return s.TimingValue
}

// An object with a list of different timings measured during this API call.
func (s *CentralDvrsListImpl) SetTiming(v any) CentralDvrsList {
	if s == nil {
		return nil
	}
	s.TimingValue = v
	return s
}

// Collection returns the collection items from CentralDvrsList
func (s CentralDvrsListImpl) Collection() []CentralDvrConfig {
	return s.Dvrs()
}

// NewCentralEvent creates a new CentralEvent instance
func NewCentralEvent() CentralEvent {
	return &CentralEventImpl{}
}

// Number of updated agents (without streams) layouts.
func (s CentralEventImpl) AgentsUpdated() *int {
	return s.AgentsUpdatedValue
}

// Number of updated agents (without streams) layouts.
func (s *CentralEventImpl) SetAgentsUpdated(v int) CentralEvent {
	if s == nil {
		return nil
	}
	s.AgentsUpdatedValue = &v
	return s
}

// Command name.
// Example: streampoint_connect
func (s CentralEventImpl) Command() *AgentCommandHandlingCommand {
	return s.CommandValue
}

// Command name.
// Example: streampoint_connect
func (s *CentralEventImpl) SetCommand(v AgentCommandHandlingCommand) CentralEvent {
	if s == nil {
		return nil
	}
	s.CommandValue = &v
	return s
}

// Creation date and time
// Format: date_time (date_time)
// Example: 2021-01-30T08:30:00.432567Z
func (s CentralEventImpl) CreatedAt() *DateTime {
	return s.CreatedAtValue
}

// Creation date and time
// Format: date_time (date_time)
// Example: 2021-01-30T08:30:00.432567Z
func (s *CentralEventImpl) SetCreatedAt(v DateTime) CentralEvent {
	if s == nil {
		return nil
	}
	s.CreatedAtValue = &v
	return s
}

// Microseconds that this request took
// Format: microseconds (microseconds)
func (s CentralEventImpl) Duration() *Microseconds {
	return s.DurationValue
}

// Microseconds that this request took
// Format: microseconds (microseconds)
func (s *CentralEventImpl) SetDuration(v Microseconds) CentralEvent {
	if s == nil {
		return nil
	}
	s.DurationValue = &v
	return s
}

// Entity configuration containing only those fields that are supported by Layouter.
// For supported fields see [Layouter Schema](https://flussonic.com/doc/api/layouter/)
func (s CentralEventImpl) EntityBody() any {
	return s.EntityBodyValue
}

// Entity configuration containing only those fields that are supported by Layouter.
// For supported fields see [Layouter Schema](https://flussonic.com/doc/api/layouter/)
func (s *CentralEventImpl) SetEntityBody(v any) CentralEvent {
	if s == nil {
		return nil
	}
	s.EntityBodyValue = v
	return s
}

// Unique identifier of the entity.
// For example, for `agent` it is `agent_id` field.
func (s CentralEventImpl) EntityID() *string {
	return s.EntityIDValue
}

// Unique identifier of the entity.
// For example, for `agent` it is `agent_id` field.
func (s *CentralEventImpl) SetEntityID(v string) CentralEvent {
	if s == nil {
		return nil
	}
	s.EntityIDValue = &v
	return s
}

// Type of the entity.
func (s CentralEventImpl) EntityType() *EntityEventEntityType {
	return s.EntityTypeValue
}

// Type of the entity.
func (s *CentralEventImpl) SetEntityType(v EntityEventEntityType) CentralEvent {
	if s == nil {
		return nil
	}
	s.EntityTypeValue = &v
	return s
}

// Error message explaining why command failed.
// If command was successful, this field absent.
// /structured error
func (s CentralEventImpl) Error() any {
	return s.ErrorValue
}

// Error message explaining why command failed.
// If command was successful, this field absent.
// /structured error
func (s *CentralEventImpl) SetError(v any) CentralEvent {
	if s == nil {
		return nil
	}
	s.ErrorValue = v
	return s
}

// Server started booting./Server started successfully./Database error./The api call./Event of handling commands via the interaction protocol between the agent and the endpoint./Agent failed to connect to endpoint./Agent successfully connected to endpoint./Agent disconnected from endpoint./Failed to make streampoint location for agent.
// /Layouter process agents (without streams) success./Layouter process agents (without streams) error./Layouter process streams success./Layouter process streams error./Entity fetched by Layouter. It may be Streamer, Stream or Agent.
// /Result of processing fetched entities
// /Layouter started fetching entities for processing
func (s CentralEventImpl) Event() string {
	return s.EventValue
}

// Server started booting./Server started successfully./Database error./The api call./Event of handling commands via the interaction protocol between the agent and the endpoint./Agent failed to connect to endpoint./Agent successfully connected to endpoint./Agent disconnected from endpoint./Failed to make streampoint location for agent.
// /Layouter process agents (without streams) success./Layouter process agents (without streams) error./Layouter process streams success./Layouter process streams error./Entity fetched by Layouter. It may be Streamer, Stream or Agent.
// /Result of processing fetched entities
// /Layouter started fetching entities for processing
func (s *CentralEventImpl) SetEvent(v string) CentralEvent {
	if s == nil {
		return nil
	}
	s.EventValue = v
	return s
}

// Event identifier.
func (s CentralEventImpl) EventID() *int {
	return s.EventIDValue
}

// Event identifier.
func (s *CentralEventImpl) SetEventID(v int) CentralEvent {
	if s == nil {
		return nil
	}
	s.EventIDValue = &v
	return s
}

// Full version of service with the build number.
func (s CentralEventImpl) FullVersion() *string {
	return s.FullVersionValue
}

// Full version of service with the build number.
func (s *CentralEventImpl) SetFullVersion(v string) CentralEvent {
	if s == nil {
		return nil
	}
	s.FullVersionValue = &v
	return s
}

func (s CentralEventImpl) Initiator() *AgentInitiator {
	return s.InitiatorValue
}

func (s *CentralEventImpl) SetInitiator(v AgentInitiator) CentralEvent {
	if s == nil {
		return nil
	}
	s.InitiatorValue = &v
	return s
}

// The ID of the started instance.
func (s CentralEventImpl) InstanceID() *string {
	return s.InstanceIDValue
}

// The ID of the started instance.
func (s *CentralEventImpl) SetInstanceID(v string) CentralEvent {
	if s == nil {
		return nil
	}
	s.InstanceIDValue = &v
	return s
}

// IP address of the caller.
// Format: ip (ip)
// Example: 192.34.32.10
func (s CentralEventImpl) IP() *IP {
	return s.IPValue
}

// IP address of the caller.
// Format: ip (ip)
// Example: 192.34.32.10
func (s *CentralEventImpl) SetIP(v IP) CentralEvent {
	if s == nil {
		return nil
	}
	s.IPValue = &v
	return s
}

// The error message./Additional information about the error.
func (s CentralEventImpl) Message() *string {
	return s.MessageValue
}

// The error message./Additional information about the error.
func (s *CentralEventImpl) SetMessage(v string) CentralEvent {
	if s == nil {
		return nil
	}
	s.MessageValue = &v
	return s
}

// API method ID.
// Example: streams_list
func (s CentralEventImpl) OperationID() *string {
	return s.OperationIDValue
}

// API method ID.
// Example: streams_list
func (s *CentralEventImpl) SetOperationID(v string) CentralEvent {
	if s == nil {
		return nil
	}
	s.OperationIDValue = &v
	return s
}

// The program produced the API call. Content of `X-Originator` header.
// Example: flussonic
func (s CentralEventImpl) Originator() *string {
	return s.OriginatorValue
}

// The program produced the API call. Content of `X-Originator` header.
// Example: flussonic
func (s *CentralEventImpl) SetOriginator(v string) CentralEvent {
	if s == nil {
		return nil
	}
	s.OriginatorValue = &v
	return s
}

// The api call path.
func (s CentralEventImpl) Path() *string {
	return s.PathValue
}

// The api call path.
func (s *CentralEventImpl) SetPath(v string) CentralEvent {
	if s == nil {
		return nil
	}
	s.PathValue = &v
	return s
}

// Payload data transmitter in the API call./Payload of the command.
func (s CentralEventImpl) Payload() *string {
	return s.PayloadValue
}

// Payload data transmitter in the API call./Payload of the command.
func (s *CentralEventImpl) SetPayload(v string) CentralEvent {
	if s == nil {
		return nil
	}
	s.PayloadValue = &v
	return s
}

func (s CentralEventImpl) PreviousState() *PreviousServerState {
	return s.PreviousStateValue
}

func (s *CentralEventImpl) SetPreviousState(v PreviousServerState) CentralEvent {
	if s == nil {
		return nil
	}
	s.PreviousStateValue = &v
	return s
}

// The api call query string.
func (s CentralEventImpl) Qs() *string {
	return s.QsValue
}

// The api call query string.
func (s *CentralEventImpl) SetQs(v string) CentralEvent {
	if s == nil {
		return nil
	}
	s.QsValue = &v
	return s
}

// The query that caused the error.
func (s CentralEventImpl) Query() *string {
	return s.QueryValue
}

// The query that caused the error.
func (s *CentralEventImpl) SetQuery(v string) CentralEvent {
	if s == nil {
		return nil
	}
	s.QueryValue = &v
	return s
}

// Why agent failed to connect./Why agent disconnected/Why agent failed to make streampoint location.
func (s CentralEventImpl) Reason() any {
	return s.ReasonValue
}

// Why agent failed to connect./Why agent disconnected/Why agent failed to make streampoint location.
func (s *CentralEventImpl) SetReason(v any) CentralEvent {
	if s == nil {
		return nil
	}
	s.ReasonValue = v
	return s
}

// List of relayouts made by Layouter
func (s CentralEventImpl) Relayouts() []CentralStreamLayoutListItem {
	if s.RelayoutsValue == nil {
		return nil
	}
	result := make([]CentralStreamLayoutListItem, len(s.RelayoutsValue))
	for i, item := range s.RelayoutsValue {
		result[i] = item
	}
	return result
}

// List of relayouts made by Layouter
func (s *CentralEventImpl) SetRelayouts(v []CentralStreamLayoutListItem) CentralEvent {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*CentralStreamLayoutListItemImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*CentralStreamLayoutListItemImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.RelayoutsValue = impl
	}
	return s
}

// Internal request-id for this operation
func (s CentralEventImpl) RequestID() *string {
	return s.RequestIDValue
}

// Internal request-id for this operation
func (s *CentralEventImpl) SetRequestID(v string) CentralEvent {
	if s == nil {
		return nil
	}
	s.RequestIDValue = &v
	return s
}

// Originator of event.
// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
// is configured as HTTP/HTTPS url.
// Example: flussonic.host
func (s CentralEventImpl) Server() *string {
	return s.ServerValue
}

// Originator of event.
// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
// is configured as HTTP/HTTPS url.
// Example: flussonic.host
func (s *CentralEventImpl) SetServer(v string) CentralEvent {
	if s == nil {
		return nil
	}
	s.ServerValue = &v
	return s
}

// Request status code.
func (s CentralEventImpl) Status() *int {
	return s.StatusValue
}

// Request status code.
func (s *CentralEventImpl) SetStatus(v int) CentralEvent {
	if s == nil {
		return nil
	}
	s.StatusValue = &v
	return s
}

// The hostname of current agent's streampoint.
func (s CentralEventImpl) Streampoint() *string {
	return s.StreampointValue
}

// The hostname of current agent's streampoint.
func (s *CentralEventImpl) SetStreampoint(v string) CentralEvent {
	if s == nil {
		return nil
	}
	s.StreampointValue = &v
	return s
}

// Number of updated streams layouts.
func (s CentralEventImpl) StreamsUpdated() *int {
	return s.StreamsUpdatedValue
}

// Number of updated streams layouts.
func (s *CentralEventImpl) SetStreamsUpdated(v int) CentralEvent {
	if s == nil {
		return nil
	}
	s.StreamsUpdatedValue = &v
	return s
}

// Unique identifier of the operation.
// You can use this field to search for events related to same operation.
// Value of this field is taken from the `X-Trace-Id` header.
// If `X-Trace-Id` header is not set, it will be generated automatically.
// Service will use the value of this field to make outgoing requests.
// Format: uuid (uuid)
// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
func (s CentralEventImpl) TraceID() *UUID {
	return s.TraceIDValue
}

// Unique identifier of the operation.
// You can use this field to search for events related to same operation.
// Value of this field is taken from the `X-Trace-Id` header.
// If `X-Trace-Id` header is not set, it will be generated automatically.
// Service will use the value of this field to make outgoing requests.
// Format: uuid (uuid)
// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
func (s *CentralEventImpl) SetTraceID(v UUID) CentralEvent {
	if s == nil {
		return nil
	}
	s.TraceIDValue = &v
	return s
}

// The type of the device from which the API call was produced.
// Example: Flussonic 24.04
func (s CentralEventImpl) UserAgent() *string {
	return s.UserAgentValue
}

// The type of the device from which the API call was produced.
// Example: Flussonic 24.04
func (s *CentralEventImpl) SetUserAgent(v string) CentralEvent {
	if s == nil {
		return nil
	}
	s.UserAgentValue = &v
	return s
}

// The time of the event registration on the server.
// Format: utc_ms (Unix timestamp in milliseconds)
func (s CentralEventImpl) UtcMs() *UtcMs {
	return s.UtcMsValue
}

// The time of the event registration on the server.
// Format: utc_ms (Unix timestamp in milliseconds)
func (s *CentralEventImpl) SetUtcMs(v UtcMs) CentralEvent {
	if s == nil {
		return nil
	}
	s.UtcMsValue = &v
	return s
}

// Version of service./Version of Service.
func (s CentralEventImpl) Version() *string {
	return s.VersionValue
}

// Version of service./Version of Service.
func (s *CentralEventImpl) SetVersion(v string) CentralEvent {
	if s == nil {
		return nil
	}
	s.VersionValue = &v
	return s
}

// NewCentralEventsList creates a new CentralEventsList instance
func NewCentralEventsList() CentralEventsList {
	return &CentralEventsListImpl{}
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s CentralEventsListImpl) EstimatedCount() *int {
	return s.EstimatedCountValue
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s *CentralEventsListImpl) SetEstimatedCount(v int) CentralEventsList {
	if s == nil {
		return nil
	}
	s.EstimatedCountValue = &v
	return s
}

// List of central events
func (s CentralEventsListImpl) Events() []CentralEvent {
	if s.EventsValue == nil {
		return nil
	}
	result := make([]CentralEvent, len(s.EventsValue))
	for i, item := range s.EventsValue {
		result[i] = item
	}
	return result
}

// List of central events
func (s *CentralEventsListImpl) SetEvents(v []CentralEvent) CentralEventsList {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*CentralEventImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*CentralEventImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.EventsValue = impl
	}
	return s
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s CentralEventsListImpl) Next() *string {
	return s.NextValue
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s *CentralEventsListImpl) SetNext(v string) CentralEventsList {
	if s == nil {
		return nil
	}
	s.NextValue = &v
	return s
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s CentralEventsListImpl) Prev() *string {
	return s.PrevValue
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s *CentralEventsListImpl) SetPrev(v string) CentralEventsList {
	if s == nil {
		return nil
	}
	s.PrevValue = &v
	return s
}

// An object with a list of different timings measured during this API call.
func (s CentralEventsListImpl) Timing() any {
	return s.TimingValue
}

// An object with a list of different timings measured during this API call.
func (s *CentralEventsListImpl) SetTiming(v any) CentralEventsList {
	if s == nil {
		return nil
	}
	s.TimingValue = v
	return s
}

// Collection returns the collection items from CentralEventsList
func (s CentralEventsListImpl) Collection() []CentralEvent {
	return s.Events()
}

// NewCentralHealthcheckStatus creates a new CentralHealthcheckStatus instance
func NewCentralHealthcheckStatus() CentralHealthcheckStatus {
	return &CentralHealthcheckStatusImpl{}
}

// List of healthcheck checks with their results.
func (s CentralHealthcheckStatusImpl) Checks() CentralHealthcheckStatusChecks {
	return s.ChecksValue
}

// List of healthcheck checks with their results.
func (s *CentralHealthcheckStatusImpl) SetChecks(v CentralHealthcheckStatusChecks) CentralHealthcheckStatus {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*CentralHealthcheckStatusChecksImpl); ok {
		s.ChecksValue = impl
	}
	return s
}

// Status of the healthcheck.
func (s CentralHealthcheckStatusImpl) Status() *CentralHealthcheckStatusStatus {
	return s.StatusValue
}

// Status of the healthcheck.
func (s *CentralHealthcheckStatusImpl) SetStatus(v CentralHealthcheckStatusStatus) CentralHealthcheckStatus {
	if s == nil {
		return nil
	}
	s.StatusValue = &v
	return s
}

// Unix timestamp of the last status change.
// Format: utc_ms (Unix timestamp in milliseconds)
func (s CentralHealthcheckStatusImpl) StatusChangedAt() *UtcMs {
	return s.StatusChangedAtValue
}

// Unix timestamp of the last status change.
// Format: utc_ms (Unix timestamp in milliseconds)
func (s *CentralHealthcheckStatusImpl) SetStatusChangedAt(v UtcMs) CentralHealthcheckStatus {
	if s == nil {
		return nil
	}
	s.StatusChangedAtValue = &v
	return s
}

// NewCentralHealthcheckStatusChecks creates a new CentralHealthcheckStatusChecks instance
func NewCentralHealthcheckStatusChecks() CentralHealthcheckStatusChecks {
	return &CentralHealthcheckStatusChecksImpl{}
}

// `true` if peer has no `error` in
// [stats.config_external_status](https://flussonic.com/doc/api/central/#tag/streamer/operation/streamer_get/response__0%7Cstats%7Cconfig_external_status) field.
func (s CentralHealthcheckStatusChecksImpl) ConfigExternalOk() *bool {
	return s.ConfigExternalOkValue
}

// `true` if peer has no `error` in
// [stats.config_external_status](https://flussonic.com/doc/api/central/#tag/streamer/operation/streamer_get/response__0%7Cstats%7Cconfig_external_status) field.
func (s *CentralHealthcheckStatusChecksImpl) SetConfigExternalOk(v bool) CentralHealthcheckStatusChecks {
	if s == nil {
		return nil
	}
	s.ConfigExternalOkValue = &v
	return s
}

// `true` if peer has no `error` in
// [stats.config_error](https://flussonic.com/doc/api/central/#tag/streamer/operation/streamer_get/response__0%7Cstats%7Cconfig_error) field.
func (s CentralHealthcheckStatusChecksImpl) ConfigOk() *bool {
	return s.ConfigOkValue
}

// `true` if peer has no `error` in
// [stats.config_error](https://flussonic.com/doc/api/central/#tag/streamer/operation/streamer_get/response__0%7Cstats%7Cconfig_error) field.
func (s *CentralHealthcheckStatusChecksImpl) SetConfigOk(v bool) CentralHealthcheckStatusChecks {
	if s == nil {
		return nil
	}
	s.ConfigOkValue = &v
	return s
}

// List of errors details
func (s CentralHealthcheckStatusChecksImpl) ErrorsDetails() []CentralHealthcheckStatusChecksErrorsDetailsItem {
	if s.ErrorsDetailsValue == nil {
		return nil
	}
	result := make([]CentralHealthcheckStatusChecksErrorsDetailsItem, len(s.ErrorsDetailsValue))
	for i, item := range s.ErrorsDetailsValue {
		result[i] = item
	}
	return result
}

// List of errors details
func (s *CentralHealthcheckStatusChecksImpl) SetErrorsDetails(v []CentralHealthcheckStatusChecksErrorsDetailsItem) CentralHealthcheckStatusChecks {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*CentralHealthcheckStatusChecksErrorsDetailsItemImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*CentralHealthcheckStatusChecksErrorsDetailsItemImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.ErrorsDetailsValue = impl
	}
	return s
}

// `true` if peer is reachable from central by its credentials
func (s CentralHealthcheckStatusChecksImpl) Reachable() *bool {
	return s.ReachableValue
}

// `true` if peer is reachable from central by its credentials
func (s *CentralHealthcheckStatusChecksImpl) SetReachable(v bool) CentralHealthcheckStatusChecks {
	if s == nil {
		return nil
	}
	s.ReachableValue = &v
	return s
}

// `true` if rproxy configuration is valid
func (s CentralHealthcheckStatusChecksImpl) RproxyOk() *bool {
	return s.RproxyOkValue
}

// `true` if rproxy configuration is valid
func (s *CentralHealthcheckStatusChecksImpl) SetRproxyOk(v bool) CentralHealthcheckStatusChecks {
	if s == nil {
		return nil
	}
	s.RproxyOkValue = &v
	return s
}

// `true` if peer is running
func (s CentralHealthcheckStatusChecksImpl) Running() *bool {
	return s.RunningValue
}

// `true` if peer is running
func (s *CentralHealthcheckStatusChecksImpl) SetRunning(v bool) CentralHealthcheckStatusChecks {
	if s == nil {
		return nil
	}
	s.RunningValue = &v
	return s
}

// `true` if server time is synchronized between peer and central
func (s CentralHealthcheckStatusChecksImpl) TimeSynchronized() *bool {
	return s.TimeSynchronizedValue
}

// `true` if server time is synchronized between peer and central
func (s *CentralHealthcheckStatusChecksImpl) SetTimeSynchronized(v bool) CentralHealthcheckStatusChecks {
	if s == nil {
		return nil
	}
	s.TimeSynchronizedValue = &v
	return s
}

// `true` if peer has a valid cluster key
func (s CentralHealthcheckStatusChecksImpl) ValidClusterKey() *bool {
	return s.ValidClusterKeyValue
}

// `true` if peer has a valid cluster key
func (s *CentralHealthcheckStatusChecksImpl) SetValidClusterKey(v bool) CentralHealthcheckStatusChecks {
	if s == nil {
		return nil
	}
	s.ValidClusterKeyValue = &v
	return s
}

// NewCentralHealthcheckStatusChecksErrorsDetailsItem creates a new CentralHealthcheckStatusChecksErrorsDetailsItem instance
func NewCentralHealthcheckStatusChecksErrorsDetailsItem() CentralHealthcheckStatusChecksErrorsDetailsItem {
	return &CentralHealthcheckStatusChecksErrorsDetailsItemImpl{}
}

// Error message
func (s CentralHealthcheckStatusChecksErrorsDetailsItemImpl) Error() *string {
	return s.ErrorValue
}

// Error message
func (s *CentralHealthcheckStatusChecksErrorsDetailsItemImpl) SetError(v string) CentralHealthcheckStatusChecksErrorsDetailsItem {
	if s == nil {
		return nil
	}
	s.ErrorValue = &v
	return s
}

// Failed healthcheck rule name
func (s CentralHealthcheckStatusChecksErrorsDetailsItemImpl) Rule() *string {
	return s.RuleValue
}

// Failed healthcheck rule name
func (s *CentralHealthcheckStatusChecksErrorsDetailsItemImpl) SetRule(v string) CentralHealthcheckStatusChecksErrorsDetailsItem {
	if s == nil {
		return nil
	}
	s.RuleValue = &v
	return s
}

// NewCentralIdentificationNode creates a new CentralIdentificationNode instance
func NewCentralIdentificationNode() CentralIdentificationNode {
	return &CentralIdentificationNodeImpl{}
}

// The URL for provisioning of configuration from the managing server to the streamer.
// This URL does not have to be public but must be accessible from the managing server.
// The API URL can also be used as Public and/or Private payload URL if they are not set.
// When used as Public payload URL, the API URL shall be public to allow playback from this streamer.
// Format: url (url)
// Example: http://streamer.local:8080
func (s CentralIdentificationNodeImpl) APIURL() *URL {
	return s.APIURLValue
}

// The URL for provisioning of configuration from the managing server to the streamer.
// This URL does not have to be public but must be accessible from the managing server.
// The API URL can also be used as Public and/or Private payload URL if they are not set.
// When used as Public payload URL, the API URL shall be public to allow playback from this streamer.
// Format: url (url)
// Example: http://streamer.local:8080
func (s *CentralIdentificationNodeImpl) SetAPIURL(v URL) CentralIdentificationNode {
	if s == nil {
		return nil
	}
	s.APIURLValue = &v
	return s
}

// Maximal number of streams.
// Example: 5
func (s CentralIdentificationNodeImpl) ChannelLimit() *int {
	return s.ChannelLimitValue
}

// Maximal number of streams.
// Example: 5
func (s *CentralIdentificationNodeImpl) SetChannelLimit(v int) CentralIdentificationNode {
	if s == nil {
		return nil
	}
	s.ChannelLimitValue = &v
	return s
}

// The key for authorization for inter-Flussonic connections.
// All cluster peers should have the same cluster key.
// Example: xS6i6Q3DCc5nEvnu
func (s CentralIdentificationNodeImpl) ClusterKey() *string {
	return s.ClusterKeyValue
}

// The key for authorization for inter-Flussonic connections.
// All cluster peers should have the same cluster key.
// Example: xS6i6Q3DCc5nEvnu
func (s *CentralIdentificationNodeImpl) SetClusterKey(v string) CentralIdentificationNode {
	if s == nil {
		return nil
	}
	s.ClusterKeyValue = &v
	return s
}

// CPU limit in percents.
// Format: percent (percent)
// Example: 10
func (s CentralIdentificationNodeImpl) CpuLimit() *Percent {
	return s.CpuLimitValue
}

// CPU limit in percents.
// Format: percent (percent)
// Example: 10
func (s *CentralIdentificationNodeImpl) SetCpuLimit(v Percent) CentralIdentificationNode {
	if s == nil {
		return nil
	}
	s.CpuLimitValue = &v
	return s
}

// How often the peer will try to get the data from the remote server via internal API.
// Format: milliseconds (milliseconds)
// Example: 1000
func (s CentralIdentificationNodeImpl) FetchTimeout() *Milliseconds {
	return s.FetchTimeoutValue
}

// How often the peer will try to get the data from the remote server via internal API.
// Format: milliseconds (milliseconds)
// Example: 1000
func (s *CentralIdentificationNodeImpl) SetFetchTimeout(v Milliseconds) CentralIdentificationNode {
	if s == nil {
		return nil
	}
	s.FetchTimeoutValue = &v
	return s
}

// Streamer's identifier in the cluster.
// The managing server may try using this hostname to access the streamer
// if API URL is not specified.
// Format: server_name (server_name)
// Example: peer.example.com
func (s CentralIdentificationNodeImpl) Hostname() *ServerName {
	return s.HostnameValue
}

// Streamer's identifier in the cluster.
// The managing server may try using this hostname to access the streamer
// if API URL is not specified.
// Format: server_name (server_name)
// Example: peer.example.com
func (s *CentralIdentificationNodeImpl) SetHostname(v ServerName) CentralIdentificationNode {
	if s == nil {
		return nil
	}
	s.HostnameValue = &v
	return s
}

// Deprecated field. Will be deleted at 23.09
// Maximal output bitrate of the peer.
// Format: speed (speed)
func (s CentralIdentificationNodeImpl) MaxBitrate() *Speed {
	return s.MaxBitrateValue
}

// Deprecated field. Will be deleted at 23.09
// Maximal output bitrate of the peer.
// Format: speed (speed)
func (s *CentralIdentificationNodeImpl) SetMaxBitrate(v Speed) CentralIdentificationNode {
	if s == nil {
		return nil
	}
	s.MaxBitrateValue = &v
	return s
}

// Streamer's logical namespace, used for interacting with streams of the same namespace. By default, a streamer has no assigned namespace. In this default state, it can interact with streams that also have no assigned namespace. If a namespace is explicitly set, the streamer will only interact with streams possessing that specific namespace.
// For example, the layouter will distribute streams only to streamers with the same namespace. The `dynamic_streams_list` endpoint will operate exclusively within a single namespace.
// ***Use case:***
// Namespaces provide strict, system-wide resource isolation, fundamentally separating streams and streamers into independent segments. This ensures no interaction, archive access, inference processing, or layout operations occur between different namespaces.
// Unlike labels, which offer flexible, attribute-based layout control within a namespace, namespaces define an absolute boundary: resources from one namespace cannot interact with resources from another.
// ***Important:***
// A namespace can only be assigned when the streamer is created and cannot be changed afterwards.
// Format: unix_name (Contains only alphanumeric characters (a-z, A-Z, 0-9), underscores (_), hyphens (-) and periods (.).)
// Pattern: ^[a-zA-Z0-9_.-]+$
// Example: example
func (s CentralIdentificationNodeImpl) Namespace() *UnixName {
	return s.NamespaceValue
}

// Streamer's logical namespace, used for interacting with streams of the same namespace. By default, a streamer has no assigned namespace. In this default state, it can interact with streams that also have no assigned namespace. If a namespace is explicitly set, the streamer will only interact with streams possessing that specific namespace.
// For example, the layouter will distribute streams only to streamers with the same namespace. The `dynamic_streams_list` endpoint will operate exclusively within a single namespace.
// ***Use case:***
// Namespaces provide strict, system-wide resource isolation, fundamentally separating streams and streamers into independent segments. This ensures no interaction, archive access, inference processing, or layout operations occur between different namespaces.
// Unlike labels, which offer flexible, attribute-based layout control within a namespace, namespaces define an absolute boundary: resources from one namespace cannot interact with resources from another.
// ***Important:***
// A namespace can only be assigned when the streamer is created and cannot be changed afterwards.
// Format: unix_name (Contains only alphanumeric characters (a-z, A-Z, 0-9), underscores (_), hyphens (-) and periods (.).)
// Pattern: ^[a-zA-Z0-9_.-]+$
// Example: example
func (s *CentralIdentificationNodeImpl) SetNamespace(v UnixName) CentralIdentificationNode {
	if s == nil {
		return nil
	}
	s.NamespaceValue = &v
	return s
}

// Role of node
func (s CentralIdentificationNodeImpl) Role() *CentralNodeRoleRole {
	return s.RoleValue
}

// Role of node
func (s *CentralIdentificationNodeImpl) SetRole(v CentralNodeRoleRole) CentralIdentificationNode {
	if s == nil {
		return nil
	}
	s.RoleValue = &v
	return s
}

// The time after which deleted streams on this server are considered to be inactive
// and cannot be used in the `cluster_ingest` mechanism.
// Format: milliseconds (milliseconds)
// Example: 1000
func (s CentralIdentificationNodeImpl) StaleTimeout() *Milliseconds {
	return s.StaleTimeoutValue
}

// The time after which deleted streams on this server are considered to be inactive
// and cannot be used in the `cluster_ingest` mechanism.
// Format: milliseconds (milliseconds)
// Example: 1000
func (s *CentralIdentificationNodeImpl) SetStaleTimeout(v Milliseconds) CentralIdentificationNode {
	if s == nil {
		return nil
	}
	s.StaleTimeoutValue = &v
	return s
}

// Statistics on peers in the cluster.
func (s CentralIdentificationNodeImpl) Stats() PeerStats {
	return s.StatsValue
}

// Statistics on peers in the cluster.
func (s *CentralIdentificationNodeImpl) SetStats(v PeerStats) CentralIdentificationNode {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*PeerStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// NewCentralInferenceNode creates a new CentralInferenceNode instance
func NewCentralInferenceNode() CentralInferenceNode {
	return &CentralInferenceNodeImpl{}
}

// The URL for provisioning of configuration from the managing server to the streamer.
// This URL does not have to be public but must be accessible from the managing server.
// The API URL can also be used as Public and/or Private payload URL if they are not set.
// When used as Public payload URL, the API URL shall be public to allow playback from this streamer.
// Format: url (url)
// Example: http://streamer.local:8080
func (s CentralInferenceNodeImpl) APIURL() *URL {
	return s.APIURLValue
}

// The URL for provisioning of configuration from the managing server to the streamer.
// This URL does not have to be public but must be accessible from the managing server.
// The API URL can also be used as Public and/or Private payload URL if they are not set.
// When used as Public payload URL, the API URL shall be public to allow playback from this streamer.
// Format: url (url)
// Example: http://streamer.local:8080
func (s *CentralInferenceNodeImpl) SetAPIURL(v URL) CentralInferenceNode {
	if s == nil {
		return nil
	}
	s.APIURLValue = &v
	return s
}

// Maximal number of streams.
// Example: 5
func (s CentralInferenceNodeImpl) ChannelLimit() *int {
	return s.ChannelLimitValue
}

// Maximal number of streams.
// Example: 5
func (s *CentralInferenceNodeImpl) SetChannelLimit(v int) CentralInferenceNode {
	if s == nil {
		return nil
	}
	s.ChannelLimitValue = &v
	return s
}

// The key for authorization for inter-Flussonic connections.
// All cluster peers should have the same cluster key.
// Example: xS6i6Q3DCc5nEvnu
func (s CentralInferenceNodeImpl) ClusterKey() *string {
	return s.ClusterKeyValue
}

// The key for authorization for inter-Flussonic connections.
// All cluster peers should have the same cluster key.
// Example: xS6i6Q3DCc5nEvnu
func (s *CentralInferenceNodeImpl) SetClusterKey(v string) CentralInferenceNode {
	if s == nil {
		return nil
	}
	s.ClusterKeyValue = &v
	return s
}

// CPU limit in percents.
// Format: percent (percent)
// Example: 10
func (s CentralInferenceNodeImpl) CpuLimit() *Percent {
	return s.CpuLimitValue
}

// CPU limit in percents.
// Format: percent (percent)
// Example: 10
func (s *CentralInferenceNodeImpl) SetCpuLimit(v Percent) CentralInferenceNode {
	if s == nil {
		return nil
	}
	s.CpuLimitValue = &v
	return s
}

// How often the peer will try to get the data from the remote server via internal API.
// Format: milliseconds (milliseconds)
// Example: 1000
func (s CentralInferenceNodeImpl) FetchTimeout() *Milliseconds {
	return s.FetchTimeoutValue
}

// How often the peer will try to get the data from the remote server via internal API.
// Format: milliseconds (milliseconds)
// Example: 1000
func (s *CentralInferenceNodeImpl) SetFetchTimeout(v Milliseconds) CentralInferenceNode {
	if s == nil {
		return nil
	}
	s.FetchTimeoutValue = &v
	return s
}

// Streamer's identifier in the cluster.
// The managing server may try using this hostname to access the streamer
// if API URL is not specified.
// Format: server_name (server_name)
// Example: peer.example.com
func (s CentralInferenceNodeImpl) Hostname() *ServerName {
	return s.HostnameValue
}

// Streamer's identifier in the cluster.
// The managing server may try using this hostname to access the streamer
// if API URL is not specified.
// Format: server_name (server_name)
// Example: peer.example.com
func (s *CentralInferenceNodeImpl) SetHostname(v ServerName) CentralInferenceNode {
	if s == nil {
		return nil
	}
	s.HostnameValue = &v
	return s
}

func (s CentralInferenceNodeImpl) Labels() map[string]UnixName {
	return s.LabelsValue
}

func (s *CentralInferenceNodeImpl) SetLabels(v map[string]UnixName) CentralInferenceNode {
	if s == nil {
		return nil
	}
	s.LabelsValue = v
	return s
}

// Deprecated field. Will be deleted at 23.09
// Maximal output bitrate of the peer.
// Format: speed (speed)
func (s CentralInferenceNodeImpl) MaxBitrate() *Speed {
	return s.MaxBitrateValue
}

// Deprecated field. Will be deleted at 23.09
// Maximal output bitrate of the peer.
// Format: speed (speed)
func (s *CentralInferenceNodeImpl) SetMaxBitrate(v Speed) CentralInferenceNode {
	if s == nil {
		return nil
	}
	s.MaxBitrateValue = &v
	return s
}

// Streamer's logical namespace, used for interacting with streams of the same namespace. By default, a streamer has no assigned namespace. In this default state, it can interact with streams that also have no assigned namespace. If a namespace is explicitly set, the streamer will only interact with streams possessing that specific namespace.
// For example, the layouter will distribute streams only to streamers with the same namespace. The `dynamic_streams_list` endpoint will operate exclusively within a single namespace.
// ***Use case:***
// Namespaces provide strict, system-wide resource isolation, fundamentally separating streams and streamers into independent segments. This ensures no interaction, archive access, inference processing, or layout operations occur between different namespaces.
// Unlike labels, which offer flexible, attribute-based layout control within a namespace, namespaces define an absolute boundary: resources from one namespace cannot interact with resources from another.
// ***Important:***
// A namespace can only be assigned when the streamer is created and cannot be changed afterwards.
// Format: unix_name (Contains only alphanumeric characters (a-z, A-Z, 0-9), underscores (_), hyphens (-) and periods (.).)
// Pattern: ^[a-zA-Z0-9_.-]+$
// Example: example
func (s CentralInferenceNodeImpl) Namespace() *UnixName {
	return s.NamespaceValue
}

// Streamer's logical namespace, used for interacting with streams of the same namespace. By default, a streamer has no assigned namespace. In this default state, it can interact with streams that also have no assigned namespace. If a namespace is explicitly set, the streamer will only interact with streams possessing that specific namespace.
// For example, the layouter will distribute streams only to streamers with the same namespace. The `dynamic_streams_list` endpoint will operate exclusively within a single namespace.
// ***Use case:***
// Namespaces provide strict, system-wide resource isolation, fundamentally separating streams and streamers into independent segments. This ensures no interaction, archive access, inference processing, or layout operations occur between different namespaces.
// Unlike labels, which offer flexible, attribute-based layout control within a namespace, namespaces define an absolute boundary: resources from one namespace cannot interact with resources from another.
// ***Important:***
// A namespace can only be assigned when the streamer is created and cannot be changed afterwards.
// Format: unix_name (Contains only alphanumeric characters (a-z, A-Z, 0-9), underscores (_), hyphens (-) and periods (.).)
// Pattern: ^[a-zA-Z0-9_.-]+$
// Example: example
func (s *CentralInferenceNodeImpl) SetNamespace(v UnixName) CentralInferenceNode {
	if s == nil {
		return nil
	}
	s.NamespaceValue = &v
	return s
}

// Role of node
func (s CentralInferenceNodeImpl) Role() *CentralNodeRoleRole {
	return s.RoleValue
}

// Role of node
func (s *CentralInferenceNodeImpl) SetRole(v CentralNodeRoleRole) CentralInferenceNode {
	if s == nil {
		return nil
	}
	s.RoleValue = &v
	return s
}

// The time after which deleted streams on this server are considered to be inactive
// and cannot be used in the `cluster_ingest` mechanism.
// Format: milliseconds (milliseconds)
// Example: 1000
func (s CentralInferenceNodeImpl) StaleTimeout() *Milliseconds {
	return s.StaleTimeoutValue
}

// The time after which deleted streams on this server are considered to be inactive
// and cannot be used in the `cluster_ingest` mechanism.
// Format: milliseconds (milliseconds)
// Example: 1000
func (s *CentralInferenceNodeImpl) SetStaleTimeout(v Milliseconds) CentralInferenceNode {
	if s == nil {
		return nil
	}
	s.StaleTimeoutValue = &v
	return s
}

// Statistics on peers in the cluster.
func (s CentralInferenceNodeImpl) Stats() PeerStats {
	return s.StatsValue
}

// Statistics on peers in the cluster.
func (s *CentralInferenceNodeImpl) SetStats(v PeerStats) CentralInferenceNode {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*PeerStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// NewCentralNodeLayoutDecision creates a new CentralNodeLayoutDecision instance
func NewCentralNodeLayoutDecision() CentralNodeLayoutDecision {
	return &CentralNodeLayoutDecisionImpl{}
}

// Hostname of streamer
// Format: server_name (server_name)
// Example: streamer1.com
func (s CentralNodeLayoutDecisionImpl) Hostname() *ServerName {
	return s.HostnameValue
}

// Hostname of streamer
// Format: server_name (server_name)
// Example: streamer1.com
func (s *CentralNodeLayoutDecisionImpl) SetHostname(v ServerName) CentralNodeLayoutDecision {
	if s == nil {
		return nil
	}
	s.HostnameValue = &v
	return s
}

// This field is true if the stream can be layouted on this node.
// Example: false
func (s CentralNodeLayoutDecisionImpl) NodeDecision() *bool {
	return s.NodeDecisionValue
}

// This field is true if the stream can be layouted on this node.
// Example: false
func (s *CentralNodeLayoutDecisionImpl) SetNodeDecision(v bool) CentralNodeLayoutDecision {
	if s == nil {
		return nil
	}
	s.NodeDecisionValue = &v
	return s
}

// List of decision reasons explaining why the stream cannot be layouted on this node. This field may be empty if stream can be layouted on this node.
// Example: [stream_misses_node_required_labels node_misses_stream_required_labels node_channel_limit_exceeded]
func (s CentralNodeLayoutDecisionImpl) Reasons() []CentralNodeLayoutDecisionReason {
	return s.ReasonsValue
}

// List of decision reasons explaining why the stream cannot be layouted on this node. This field may be empty if stream can be layouted on this node.
// Example: [stream_misses_node_required_labels node_misses_stream_required_labels node_channel_limit_exceeded]
func (s *CentralNodeLayoutDecisionImpl) SetReasons(v []CentralNodeLayoutDecisionReason) CentralNodeLayoutDecision {
	if s == nil {
		return nil
	}
	s.ReasonsValue = v
	return s
}

// Role of node
func (s CentralNodeLayoutDecisionImpl) Role() *CentralNodeRoleRole {
	return s.RoleValue
}

// Role of node
func (s *CentralNodeLayoutDecisionImpl) SetRole(v CentralNodeRoleRole) CentralNodeLayoutDecision {
	if s == nil {
		return nil
	}
	s.RoleValue = &v
	return s
}

// NewCentralNodeRole creates a new CentralNodeRole instance
func NewCentralNodeRole() CentralNodeRole {
	return &CentralNodeRoleImpl{}
}

// Role of node
func (s CentralNodeRoleImpl) Role() *CentralNodeRoleRole {
	return s.RoleValue
}

// Role of node
func (s *CentralNodeRoleImpl) SetRole(v CentralNodeRoleRole) CentralNodeRole {
	if s == nil {
		return nil
	}
	s.RoleValue = &v
	return s
}

// NewCentralStats creates a new CentralStats instance
func NewCentralStats() CentralStats {
	return &CentralStatsImpl{}
}

// Unique runtime ID of this instance. Updated with the restart.
// Format: uuid (uuid)
// Example: 61893b15-75b2-4fcb-b4cf-ae1dd0858ea2
func (s CentralStatsImpl) ID() *UUID {
	return s.IDValue
}

// Unique runtime ID of this instance. Updated with the restart.
// Format: uuid (uuid)
// Example: 61893b15-75b2-4fcb-b4cf-ae1dd0858ea2
func (s *CentralStatsImpl) SetID(v UUID) CentralStats {
	if s == nil {
		return nil
	}
	s.IDValue = &v
	return s
}

// Package version of the server. Might be simple a number of release like 21.11 or longer if you have a rolling release installed.
// Format: server_version (server_version)
// Example: 23.10
func (s CentralStatsImpl) ServerVersion() *ServerVersion {
	return s.ServerVersionValue
}

// Package version of the server. Might be simple a number of release like 21.11 or longer if you have a rolling release installed.
// Format: server_version (server_version)
// Example: 23.10
func (s *CentralStatsImpl) SetServerVersion(v ServerVersion) CentralStats {
	if s == nil {
		return nil
	}
	s.ServerVersionValue = &v
	return s
}

// Boot time of this instance.
// Format: utc (Unix timestamp in seconds)
// Example: 1.639337825e+09
func (s CentralStatsImpl) StartedAt() *Utc {
	return s.StartedAtValue
}

// Boot time of this instance.
// Format: utc (Unix timestamp in seconds)
// Example: 1.639337825e+09
func (s *CentralStatsImpl) SetStartedAt(v Utc) CentralStats {
	if s == nil {
		return nil
	}
	s.StartedAtValue = &v
	return s
}

// The server uptime.
// Format: seconds (seconds)
// Example: 4.325502e+06
func (s CentralStatsImpl) Uptime() *Seconds {
	return s.UptimeValue
}

// The server uptime.
// Format: seconds (seconds)
// Example: 4.325502e+06
func (s *CentralStatsImpl) SetUptime(v Seconds) CentralStats {
	if s == nil {
		return nil
	}
	s.UptimeValue = &v
	return s
}

// NewCentralStreamConfig creates a new CentralStreamConfig instance
func NewCentralStreamConfig() CentralStreamConfig {
	return &CentralStreamConfigImpl{}
}

// Whether to add an audio-only version of an HLS stream.
// Used to create App Store compliant HLS streams to deliver the content to Apple iOS devices.
// Example: true
func (s CentralStreamConfigImpl) AddAudioOnly() *bool {
	return s.AddAudioOnlyValue
}

// Whether to add an audio-only version of an HLS stream.
// Used to create App Store compliant HLS streams to deliver the content to Apple iOS devices.
// Example: true
func (s *CentralStreamConfigImpl) SetAddAudioOnly(v bool) CentralStreamConfig {
	if s == nil {
		return nil
	}
	s.AddAudioOnlyValue = &v
	return s
}

// If a connected source does not send audio data within this timeout period (in seconds),
// the source connection is considered to be lost.
// This is a default configuration for a stream, can be modified for any input.
// Format: seconds (seconds)
// Example: 20
func (s CentralStreamConfigImpl) AudioTimeout() *Seconds {
	return s.AudioTimeoutValue
}

// If a connected source does not send audio data within this timeout period (in seconds),
// the source connection is considered to be lost.
// This is a default configuration for a stream, can be modified for any input.
// Format: seconds (seconds)
// Example: 20
func (s *CentralStreamConfigImpl) SetAudioTimeout(v Seconds) CentralStreamConfig {
	if s == nil {
		return nil
	}
	s.AudioTimeoutValue = &v
	return s
}

// This option has sense only for published streams. For all other behavior is undefined and unpredicted.
// If the value is greater than 0, Central will generate episodes for the stream automatically based on the
// [stream DVR ranges](https://flussonic.com/doc/api/reference/#tag/stream-dvr/operation/stream_dvr_ranges_list).
// Each range is considered an episode given that at least timeout seconds passed between these ranges.
// An episode is created at the start of the publication and is closed after a timeout after the end of publication.
// If new publication started in less than timeout - two publications will be merged into one episode.
// Format: seconds (seconds)
func (s CentralStreamConfigImpl) AutogeneratedEpisodesCloseTimeout() *Seconds {
	return s.AutogeneratedEpisodesCloseTimeoutValue
}

// This option has sense only for published streams. For all other behavior is undefined and unpredicted.
// If the value is greater than 0, Central will generate episodes for the stream automatically based on the
// [stream DVR ranges](https://flussonic.com/doc/api/reference/#tag/stream-dvr/operation/stream_dvr_ranges_list).
// Each range is considered an episode given that at least timeout seconds passed between these ranges.
// An episode is created at the start of the publication and is closed after a timeout after the end of publication.
// If new publication started in less than timeout - two publications will be merged into one episode.
// Format: seconds (seconds)
func (s *CentralStreamConfigImpl) SetAutogeneratedEpisodesCloseTimeout(v Seconds) CentralStreamConfig {
	if s == nil {
		return nil
	}
	s.AutogeneratedEpisodesCloseTimeoutValue = &v
	return s
}

// When all inputs are down, this can be used to show at least something to users.
// It is important to understand that backup video behaves differently, not as inputs.
// It is not a _last input_ in the list. After any input stops sending frames, timer starts.
// After `source_timeout` seconds backup starts working, while all other inputs are still trying to
// connect and start working.
// So backup and all inputs are working in parallel.
func (s CentralStreamConfigImpl) Backup() BackupConfig {
	return s.BackupValue
}

// When all inputs are down, this can be used to show at least something to users.
// It is important to understand that backup video behaves differently, not as inputs.
// It is not a _last input_ in the list. After any input stops sending frames, timer starts.
// After `source_timeout` seconds backup starts working, while all other inputs are still trying to
// connect and start working.
// So backup and all inputs are working in parallel.
func (s *CentralStreamConfigImpl) SetBackup(v BackupConfig) CentralStreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*BackupConfigImpl); ok {
		s.BackupValue = impl
	}
	return s
}

// Chunk duration in LL-HLS manifest to be used for tunning latency.
// Format: milliseconds (milliseconds)
// Example: 200
func (s CentralStreamConfigImpl) ChunkDuration() *Milliseconds {
	return s.ChunkDurationValue
}

// Chunk duration in LL-HLS manifest to be used for tunning latency.
// Format: milliseconds (milliseconds)
// Example: 200
func (s *CentralStreamConfigImpl) SetChunkDuration(v Milliseconds) CentralStreamConfig {
	if s == nil {
		return nil
	}
	s.ChunkDurationValue = &v
	return s
}

// User-defined claims about the stream parameters.
// Set this field so that [layouter](https://flussonic.com/doc/api/layouter/) can rely on this data when distributing streams.
func (s CentralStreamConfigImpl) Claims() CentralStreamLayoutConfigClaims {
	return s.ClaimsValue
}

// User-defined claims about the stream parameters.
// Set this field so that [layouter](https://flussonic.com/doc/api/layouter/) can rely on this data when distributing streams.
func (s *CentralStreamConfigImpl) SetClaims(v CentralStreamLayoutConfigClaims) CentralStreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*CentralStreamLayoutConfigClaimsImpl); ok {
		s.ClaimsValue = impl
	}
	return s
}

// Stream's lifetime after the last client was disconnected (can be expressed in *seconds* or set to `False`).
// Applicable to on-demand streams **only**.
// Example: 485
func (s CentralStreamConfigImpl) ClientsTimeout() any {
	return s.ClientsTimeoutValue
}

// Stream's lifetime after the last client was disconnected (can be expressed in *seconds* or set to `False`).
// Applicable to on-demand streams **only**.
// Example: 485
func (s *CentralStreamConfigImpl) SetClientsTimeout(v any) CentralStreamConfig {
	if s == nil {
		return nil
	}
	s.ClientsTimeoutValue = v
	return s
}

// Human-readable description of the stream.
// Example: This is a test stream
func (s CentralStreamConfigImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the stream.
// Example: This is a test stream
func (s *CentralStreamConfigImpl) SetComment(v string) CentralStreamConfig {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Part of the effective config from the configuration file.
func (s CentralStreamConfigImpl) ConfigOnDisk() StreamConfigStripped {
	return s.ConfigOnDiskValue
}

// Part of the effective config from the configuration file.
func (s *CentralStreamConfigImpl) SetConfigOnDisk(v StreamConfigStripped) CentralStreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*StreamConfigStrippedImpl); ok {
		s.ConfigOnDiskValue = impl
	}
	return s
}

// Whether a stream is disabled. Disabled streams are inactive and do not run.
// Displayed only with the API calls.
// Example: false
func (s CentralStreamConfigImpl) Disabled() *bool {
	return s.DisabledValue
}

// Whether a stream is disabled. Disabled streams are inactive and do not run.
// Displayed only with the API calls.
// Example: false
func (s *CentralStreamConfigImpl) SetDisabled(v bool) CentralStreamConfig {
	if s == nil {
		return nil
	}
	s.DisabledValue = &v
	return s
}

// Configuraton of Digital Rights Management system (DRM).
func (s CentralStreamConfigImpl) Drm() DrmSpec {
	return s.DrmValue
}

// Configuraton of Digital Rights Management system (DRM).
func (s *CentralStreamConfigImpl) SetDrm(v DrmSpec) CentralStreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*DrmSpecImpl); ok {
		s.DrmValue = impl
	}
	return s
}

// This parameter allows to manage subtitles in an output stream.
// Example: replace
func (s CentralStreamConfigImpl) Dvbocr() *StreamConfigInputDvbocr {
	return s.DvbocrValue
}

// This parameter allows to manage subtitles in an output stream.
// Example: replace
func (s *CentralStreamConfigImpl) SetDvbocr(v StreamConfigInputDvbocr) CentralStreamConfig {
	if s == nil {
		return nil
	}
	s.DvbocrValue = &v
	return s
}

// DVR configuraton.
func (s CentralStreamConfigImpl) Dvr() StreamDvrSpec {
	return s.DvrValue
}

// DVR configuraton.
func (s *CentralStreamConfigImpl) SetDvr(v StreamDvrSpec) CentralStreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*StreamDvrSpecImpl); ok {
		s.DvrValue = impl
	}
	return s
}

// Whether to extract EPG from the input.
// Example: true
func (s CentralStreamConfigImpl) EpgEnabled() *bool {
	return s.EpgEnabledValue
}

// Whether to extract EPG from the input.
// Example: true
func (s *CentralStreamConfigImpl) SetEpgEnabled(v bool) CentralStreamConfig {
	if s == nil {
		return nil
	}
	s.EpgEnabledValue = &v
	return s
}

// Whether to enable SCTE-35 ad insertion markers signaling in HLS manifest.
// Ad markers can be included in SCTE-35 (`scte35`), AWS (`aws`), EXT-X-DATERANGE (`rfc8216`) formats or not included (`false`).
// Example: scte35
func (s CentralStreamConfigImpl) HlsScte35() *StreamConfigMediaHlsScte35 {
	return s.HlsScte35Value
}

// Whether to enable SCTE-35 ad insertion markers signaling in HLS manifest.
// Ad markers can be included in SCTE-35 (`scte35`), AWS (`aws`), EXT-X-DATERANGE (`rfc8216`) formats or not included (`false`).
// Example: scte35
func (s *CentralStreamConfigImpl) SetHlsScte35(v StreamConfigMediaHlsScte35) CentralStreamConfig {
	if s == nil {
		return nil
	}
	s.HlsScte35Value = &v
	return s
}

// Use this option for fine-grained control over each input track.
// You can select, rename, change name and title for each video, audio track.
func (s CentralStreamConfigImpl) InputMediaInfo() InputMediaInfo {
	return s.InputMediaInfoValue
}

// Use this option for fine-grained control over each input track.
// You can select, rename, change name and title for each video, audio track.
func (s *CentralStreamConfigImpl) SetInputMediaInfo(v InputMediaInfo) CentralStreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputMediaInfoImpl); ok {
		s.InputMediaInfoValue = impl
	}
	return s
}

// List of stream inputs.
// ***Important:*** A stream without any inputs can receive video frames **only** if backup file is specified.
func (s CentralStreamConfigImpl) Inputs() []StreamInput {
	if s.InputsValue == nil {
		return nil
	}
	result := make([]StreamInput, len(s.InputsValue))
	for i, item := range s.InputsValue {
		result[i] = item
	}
	return result
}

// List of stream inputs.
// ***Important:*** A stream without any inputs can receive video frames **only** if backup file is specified.
func (s *CentralStreamConfigImpl) SetInputs(v []StreamInput) CentralStreamConfig {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*StreamInputImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*StreamInputImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.InputsValue = impl
	}
	return s
}

// A key to sign jpeg_snapshot requests
func (s CentralStreamConfigImpl) JpegSnapshotSignKey() *string {
	return s.JpegSnapshotSignKeyValue
}

// A key to sign jpeg_snapshot requests
func (s *CentralStreamConfigImpl) SetJpegSnapshotSignKey(v string) CentralStreamConfig {
	if s == nil {
		return nil
	}
	s.JpegSnapshotSignKeyValue = &v
	return s
}

// Stream labels in key value format.
// Key is a string in unix_name format (alphanumeric characters, underscores, hyphens and periods).
// See [Layouter schema](https://flussonic.com/doc/api/layouter/#tag/stream/operation/streams_list/response%7Cstreams%7Clabels)
// for more details.
func (s CentralStreamConfigImpl) Labels() map[string]UnixName {
	return s.LabelsValue
}

// Stream labels in key value format.
// Key is a string in unix_name format (alphanumeric characters, underscores, hyphens and periods).
// See [Layouter schema](https://flussonic.com/doc/api/layouter/#tag/stream/operation/streams_list/response%7Cstreams%7Clabels)
// for more details.
func (s *CentralStreamConfigImpl) SetLabels(v map[string]UnixName) CentralStreamConfig {
	if s == nil {
		return nil
	}
	s.LabelsValue = v
	return s
}

// Current layout of stream. Central will provide configuration to nodes based on this layout.
func (s CentralStreamConfigImpl) Layout() CentralStreamLayout {
	return s.LayoutValue
}

// Current layout of stream. Central will provide configuration to nodes based on this layout.
func (s *CentralStreamConfigImpl) SetLayout(v CentralStreamLayout) CentralStreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*CentralStreamLayoutImpl); ok {
		s.LayoutValue = impl
	}
	return s
}

// The maximum time that Media Server will set for attempts to reconnect to sources when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s CentralStreamConfigImpl) MaxRetryTimeout() *Seconds {
	return s.MaxRetryTimeoutValue
}

// The maximum time that Media Server will set for attempts to reconnect to sources when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s *CentralStreamConfigImpl) SetMaxRetryTimeout(v Seconds) CentralStreamConfig {
	if s == nil {
		return nil
	}
	s.MaxRetryTimeoutValue = &v
	return s
}

// Deprecated field. Will be deleted at 23.12
// The param is deprecated and now used only for onvif_url and onvif_profile options.
func (s CentralStreamConfigImpl) Meta() map[string]string {
	return s.MetaValue
}

// Deprecated field. Will be deleted at 23.12
// The param is deprecated and now used only for onvif_url and onvif_profile options.
func (s *CentralStreamConfigImpl) SetMeta(v map[string]string) CentralStreamConfig {
	if s == nil {
		return nil
	}
	s.MetaValue = v
	return s
}

// It allows to specify pack information about ac3 for outgoing MPEGTS-TS streams. The default value is `system_b`.
func (s CentralStreamConfigImpl) MpegtsAc3() *OutputMpegtsAc3 {
	return s.MpegtsAc3Value
}

// It allows to specify pack information about ac3 for outgoing MPEGTS-TS streams. The default value is `system_b`.
func (s *CentralStreamConfigImpl) SetMpegtsAc3(v OutputMpegtsAc3) CentralStreamConfig {
	if s == nil {
		return nil
	}
	s.MpegtsAc3Value = &v
	return s
}

// This parameter sets PIDs values for outgoing MPEG-TS streams. PID contains information about the TS package content and can be decoded according to special service tables.
// It is possible to set PID values for PMT, SDT, video, and audio tracks. Tracks are numbered starting from one.
// The code `a1=123` sets a PID value for the first audio track. It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, `t0=100` sets PID=101 for the first track, 102 for the second, and so on. Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s CentralStreamConfigImpl) MpegtsPids() OutputMpegtsPids {
	return s.MpegtsPidsValue
}

// This parameter sets PIDs values for outgoing MPEG-TS streams. PID contains information about the TS package content and can be decoded according to special service tables.
// It is possible to set PID values for PMT, SDT, video, and audio tracks. Tracks are numbered starting from one.
// The code `a1=123` sets a PID value for the first audio track. It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, `t0=100` sets PID=101 for the first track, 102 for the second, and so on. Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s *CentralStreamConfigImpl) SetMpegtsPids(v OutputMpegtsPids) CentralStreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*OutputMpegtsPidsImpl); ok {
		s.MpegtsPidsValue = impl
	}
	return s
}

// Globally unique stream name.
// Note that the name could not be changed after the stream is created.
// Format: media_name (media_name)
// Examples: Decklink-Stream, Dektec-Stream, hockey1, mylive/bunny, test_stream
func (s CentralStreamConfigImpl) Name() MediaName {
	return s.NameValue
}

// Globally unique stream name.
// Note that the name could not be changed after the stream is created.
// Format: media_name (media_name)
// Examples: Decklink-Stream, Dektec-Stream, hockey1, mylive/bunny, test_stream
func (s *CentralStreamConfigImpl) SetName(v MediaName) CentralStreamConfig {
	if s == nil {
		return nil
	}
	s.NameValue = v
	return s
}

// Where the stream is initialized: config, user play/publication, or remote
// cluster server.
// Example: config
func (s CentralStreamConfigImpl) NamedBy() *NamedBy {
	return s.NamedByValue
}

// Where the stream is initialized: config, user play/publication, or remote
// cluster server.
// Example: config
func (s *CentralStreamConfigImpl) SetNamedBy(v NamedBy) CentralStreamConfig {
	if s == nil {
		return nil
	}
	s.NamedByValue = &v
	return s
}

// Stream's logical namespace. Stream operations are only possible on streamers within the same namespace. By default, a stream has no assigned namespace. In this default state, it can interact with streamers that also have no assigned namespace. If a namespace is explicitly set, the stream will only interact with streamers possessing that specific namespace.
// For example, the layouter will distribute streams only to streamers with the same namespace. The `dynamic_streams_list` endpoint will operate exclusively within a single namespace.
// ***Use case:***
// Namespaces provide strict, system-wide resource isolation, fundamentally separating streams and streamers into independent segments. This ensures no interaction, archive access, inference processing, or layout operations occur between different namespaces.
// Unlike labels, which offer flexible, attribute-based layout control within a namespace, namespaces define an absolute boundary: resources from one namespace cannot interact with resources from another.
// ***Important:***
// A namespace can only be assigned when the stream is created and cannot be changed afterwards.
// Format: unix_name (Contains only alphanumeric characters (a-z, A-Z, 0-9), underscores (_), hyphens (-) and periods (.).)
// Pattern: ^[a-zA-Z0-9_.-]+$
// Example: example
func (s CentralStreamConfigImpl) Namespace() *UnixName {
	return s.NamespaceValue
}

// Stream's logical namespace. Stream operations are only possible on streamers within the same namespace. By default, a stream has no assigned namespace. In this default state, it can interact with streamers that also have no assigned namespace. If a namespace is explicitly set, the stream will only interact with streamers possessing that specific namespace.
// For example, the layouter will distribute streams only to streamers with the same namespace. The `dynamic_streams_list` endpoint will operate exclusively within a single namespace.
// ***Use case:***
// Namespaces provide strict, system-wide resource isolation, fundamentally separating streams and streamers into independent segments. This ensures no interaction, archive access, inference processing, or layout operations occur between different namespaces.
// Unlike labels, which offer flexible, attribute-based layout control within a namespace, namespaces define an absolute boundary: resources from one namespace cannot interact with resources from another.
// ***Important:***
// A namespace can only be assigned when the stream is created and cannot be changed afterwards.
// Format: unix_name (Contains only alphanumeric characters (a-z, A-Z, 0-9), underscores (_), hyphens (-) and periods (.).)
// Pattern: ^[a-zA-Z0-9_.-]+$
// Example: example
func (s *CentralStreamConfigImpl) SetNamespace(v UnixName) CentralStreamConfig {
	if s == nil {
		return nil
	}
	s.NamespaceValue = &v
	return s
}

// Configuration of authorization backend for play sessions.
func (s CentralStreamConfigImpl) OnPlay() AuthSpec {
	return s.OnPlayValue
}

// Configuration of authorization backend for play sessions.
func (s *CentralStreamConfigImpl) SetOnPlay(v AuthSpec) CentralStreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*AuthSpecImpl); ok {
		s.OnPlayValue = impl
	}
	return s
}

// Configuration of authorization backend for publish sessions.
func (s CentralStreamConfigImpl) OnPublish() AuthSpec {
	return s.OnPublishValue
}

// Configuration of authorization backend for publish sessions.
func (s *CentralStreamConfigImpl) SetOnPublish(v AuthSpec) CentralStreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*AuthSpecImpl); ok {
		s.OnPublishValue = impl
	}
	return s
}

// This parameter sets playback HTTP headers for streams.
func (s CentralStreamConfigImpl) PlaybackHeaders() []PlaybackHeaders {
	if s.PlaybackHeadersValue == nil {
		return nil
	}
	result := make([]PlaybackHeaders, len(s.PlaybackHeadersValue))
	for i, item := range s.PlaybackHeadersValue {
		result[i] = item
	}
	return result
}

// This parameter sets playback HTTP headers for streams.
func (s *CentralStreamConfigImpl) SetPlaybackHeaders(v []PlaybackHeaders) CentralStreamConfig {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*PlaybackHeadersImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*PlaybackHeadersImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.PlaybackHeadersValue = impl
	}
	return s
}

// Position of the stream in order of streams in the config file, if declared.
// Format: sort_index (sort_index)
// Example: 2
func (s CentralStreamConfigImpl) Position() *SortIndex {
	return s.PositionValue
}

// Position of the stream in order of streams in the config file, if declared.
// Format: sort_index (sort_index)
// Example: 2
func (s *CentralStreamConfigImpl) SetPosition(v SortIndex) CentralStreamConfig {
	if s == nil {
		return nil
	}
	s.PositionValue = &v
	return s
}

// The time (in seconds) that Media Server reserves for preloading the data, i. e. *buffering*.
// Prepush is always defined through GoP, but this option provides you with a more flexible way
// to configure the buffer size, e. g. a 1-3 or 7-10 seconds time interval.
// The bigger the buffer size, the better the user experience is for the users
// with a bad internet connection. However, the latency also increases.
// If set to `False` to remove the latency, the stream's start time
// increases. To decrease it, reduce the GoP size and make the bitrate higher
// or the video quality lower.
// Example: false
func (s CentralStreamConfigImpl) Prepush() any {
	return s.PrepushValue
}

// The time (in seconds) that Media Server reserves for preloading the data, i. e. *buffering*.
// Prepush is always defined through GoP, but this option provides you with a more flexible way
// to configure the buffer size, e. g. a 1-3 or 7-10 seconds time interval.
// The bigger the buffer size, the better the user experience is for the users
// with a bad internet connection. However, the latency also increases.
// If set to `False` to remove the latency, the stream's start time
// increases. To decrease it, reduce the GoP size and make the bitrate higher
// or the video quality lower.
// Example: false
func (s *CentralStreamConfigImpl) SetPrepush(v any) CentralStreamConfig {
	if s == nil {
		return nil
	}
	s.PrepushValue = v
	return s
}

// Configuration to allow/forbid playing the stream via various protocols.
// - If the `whitelist` option is set to 'true', the server allows a playback only for listed protocols;
// - If the `whitelist` option is set to 'false', the server forbids a playback for listed protocols;
// - Server allows a playback for all the protocols by default.
func (s CentralStreamConfigImpl) Protocols() PlayProtocolsSpec {
	return s.ProtocolsValue
}

// Configuration to allow/forbid playing the stream via various protocols.
// - If the `whitelist` option is set to 'true', the server allows a playback only for listed protocols;
// - If the `whitelist` option is set to 'false', the server forbids a playback for listed protocols;
// - Server allows a playback for all the protocols by default.
func (s *CentralStreamConfigImpl) SetProtocols(v PlayProtocolsSpec) CentralStreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*PlayProtocolsSpecImpl); ok {
		s.ProtocolsValue = impl
	}
	return s
}

// Deprecated field. Will be deleted at 25.03
// Human-readable name of the content provider. Used, for example, for MPEG-TS.
// Deprecated, use `input_media_info.provider` instead
// Example: SportsTV
func (s CentralStreamConfigImpl) Provider() *string {
	return s.ProviderValue
}

// Deprecated field. Will be deleted at 25.03
// Human-readable name of the content provider. Used, for example, for MPEG-TS.
// Deprecated, use `input_media_info.provider` instead
// Example: SportsTV
func (s *CentralStreamConfigImpl) SetProvider(v string) CentralStreamConfig {
	if s == nil {
		return nil
	}
	s.ProviderValue = &v
	return s
}

// A list of pushes. When a server initiates the connection and sends a stream
// to other server(s), it is called a `push`.
func (s CentralStreamConfigImpl) Pushes() []StreamPush {
	if s.PushesValue == nil {
		return nil
	}
	result := make([]StreamPush, len(s.PushesValue))
	for i, item := range s.PushesValue {
		result[i] = item
	}
	return result
}

// A list of pushes. When a server initiates the connection and sends a stream
// to other server(s), it is called a `push`.
func (s *CentralStreamConfigImpl) SetPushes(v []StreamPush) CentralStreamConfig {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*StreamPushImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*StreamPushImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.PushesValue = impl
	}
	return s
}

// How often to re-check secondary inputs. If this option is not set than check is never performed.
// Format: seconds (seconds)
// Example: 120
func (s CentralStreamConfigImpl) RecheckSecondaryInputsInterval() *Seconds {
	return s.RecheckSecondaryInputsIntervalValue
}

// How often to re-check secondary inputs. If this option is not set than check is never performed.
// Format: seconds (seconds)
// Example: 120
func (s *CentralStreamConfigImpl) SetRecheckSecondaryInputsInterval(v Seconds) CentralStreamConfig {
	if s == nil {
		return nil
	}
	s.RecheckSecondaryInputsIntervalValue = &v
	return s
}

// Number of attempts for the server to reconnect to a data source.
// Applicable to on-demand streams **only**. If not defined, server will constantly try to reconnect (unlimited number of retries).
// If the input does not become active after specified amount of attempts, stream shuts down till the next user request.
func (s CentralStreamConfigImpl) RetryLimit() *int {
	return s.RetryLimitValue
}

// Number of attempts for the server to reconnect to a data source.
// Applicable to on-demand streams **only**. If not defined, server will constantly try to reconnect (unlimited number of retries).
// If the input does not become active after specified amount of attempts, stream shuts down till the next user request.
func (s *CentralStreamConfigImpl) SetRetryLimit(v int) CentralStreamConfig {
	if s == nil {
		return nil
	}
	s.RetryLimitValue = &v
	return s
}

// Number of segments stored in memory for the segment-based protocols, such as HLS and DASH.
// Added to HLS live manifest. Do not forget that one more segment is stored for stale clients
// that come too late, but the latest segment is not shown in the manifest.
// Example: 4
func (s CentralStreamConfigImpl) SegmentCount() *int {
	return s.SegmentCountValue
}

// Number of segments stored in memory for the segment-based protocols, such as HLS and DASH.
// Added to HLS live manifest. Do not forget that one more segment is stored for stale clients
// that come too late, but the latest segment is not shown in the manifest.
// Example: 4
func (s *CentralStreamConfigImpl) SetSegmentCount(v int) CentralStreamConfig {
	if s == nil {
		return nil
	}
	s.SegmentCountValue = &v
	return s
}

// The time of the segment duration. Used for the protocols like HLS or DASH.
// The disk config offers this value in seconds.
// Example: 5000
func (s CentralStreamConfigImpl) SegmentDuration() *Milliseconds {
	return s.SegmentDurationValue
}

// The time of the segment duration. Used for the protocols like HLS or DASH.
// The disk config offers this value in seconds.
// Example: 5000
func (s *CentralStreamConfigImpl) SetSegmentDuration(v Milliseconds) CentralStreamConfig {
	if s == nil {
		return nil
	}
	s.SegmentDurationValue = &v
	return s
}

// If a connected source does not send any data within this timeout period (in seconds),
// the source connection is considered to be lost.
// This is a default configuration for a stream, can be modified for any input.
// Example: 10
func (s CentralStreamConfigImpl) SourceTimeout() any {
	return s.SourceTimeoutValue
}

// If a connected source does not send any data within this timeout period (in seconds),
// the source connection is considered to be lost.
// This is a default configuration for a stream, can be modified for any input.
// Example: 10
func (s *CentralStreamConfigImpl) SetSourceTimeout(v any) CentralStreamConfig {
	if s == nil {
		return nil
	}
	s.SourceTimeoutValue = v
	return s
}

// SRT2 publishing configuration for a stream.
func (s CentralStreamConfigImpl) Srt2Publish() SrtConfig {
	return s.Srt2PublishValue
}

// SRT2 publishing configuration for a stream.
func (s *CentralStreamConfigImpl) SetSrt2Publish(v SrtConfig) CentralStreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*SrtConfigImpl); ok {
		s.Srt2PublishValue = impl
	}
	return s
}

// Deprecated field. Will be deleted at 24.06
// Stream name was resolved via `srt_port_resolve` call.
// See [endpoint](https://flussonic.com/doc/api/config-external/#tag/srt/operation/srt_port_resolve)
// and [listener](https://flussonic.com/doc/api/reference/#tag/config/operation/config_save%7Cbody%7Clisteners%7Csrt)
// for feature description.
// This parameter now lives in `stats` object.
// Example: false
func (s CentralStreamConfigImpl) SrtPortResolve() *bool {
	return s.SrtPortResolveValue
}

// Deprecated field. Will be deleted at 24.06
// Stream name was resolved via `srt_port_resolve` call.
// See [endpoint](https://flussonic.com/doc/api/config-external/#tag/srt/operation/srt_port_resolve)
// and [listener](https://flussonic.com/doc/api/reference/#tag/config/operation/config_save%7Cbody%7Clisteners%7Csrt)
// for feature description.
// This parameter now lives in `stats` object.
// Example: false
func (s *CentralStreamConfigImpl) SetSrtPortResolve(v bool) CentralStreamConfig {
	if s == nil {
		return nil
	}
	s.SrtPortResolveValue = &v
	return s
}

// SRT publishing configuration for a stream.
func (s CentralStreamConfigImpl) SrtPublish() SrtConfig {
	return s.SrtPublishValue
}

// SRT publishing configuration for a stream.
func (s *CentralStreamConfigImpl) SetSrtPublish(v SrtConfig) CentralStreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*SrtConfigImpl); ok {
		s.SrtPublishValue = impl
	}
	return s
}

// Whether a stream is `static` or not.
// If set to `True` the server will try to keep this stream running even if
// there are no viewers or errors encountered.
// Streamer restarts *all* `static` streams even if any internal errors occur
// and the `static` streams crash.
// Example: true
func (s CentralStreamConfigImpl) Static() *bool {
	return s.StaticValue
}

// Whether a stream is `static` or not.
// If set to `True` the server will try to keep this stream running even if
// there are no viewers or errors encountered.
// Streamer restarts *all* `static` streams even if any internal errors occur
// and the `static` streams crash.
// Example: true
func (s *CentralStreamConfigImpl) SetStatic(v bool) CentralStreamConfig {
	if s == nil {
		return nil
	}
	s.StaticValue = &v
	return s
}

// Stream's metrics and other statistical information.
func (s CentralStreamConfigImpl) Stats() StreamStats {
	return s.StatsValue
}

// Stream's metrics and other statistical information.
func (s *CentralStreamConfigImpl) SetStats(v StreamStats) CentralStreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*StreamStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// Template of the stream.
// Format: media_name (media_name)
// Example: sports-hd
func (s CentralStreamConfigImpl) Template() *MediaName {
	return s.TemplateValue
}

// Template of the stream.
// Format: media_name (media_name)
// Example: sports-hd
func (s *CentralStreamConfigImpl) SetTemplate(v MediaName) CentralStreamConfig {
	if s == nil {
		return nil
	}
	s.TemplateValue = &v
	return s
}

// Configuration of thumbnails generator.
func (s CentralStreamConfigImpl) Thumbnails() ThumbnailsSpec {
	return s.ThumbnailsValue
}

// Configuration of thumbnails generator.
func (s *CentralStreamConfigImpl) SetThumbnails(v ThumbnailsSpec) CentralStreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ThumbnailsSpecImpl); ok {
		s.ThumbnailsValue = impl
	}
	return s
}

// Human-readable title of the stream. Provided for SDT MPEG-TS table or
// SDP RTSP title parameter.
// Example: Hockey channel
func (s CentralStreamConfigImpl) Title() *string {
	return s.TitleValue
}

// Human-readable title of the stream. Provided for SDT MPEG-TS table or
// SDP RTSP title parameter.
// Example: Hockey channel
func (s *CentralStreamConfigImpl) SetTitle(v string) CentralStreamConfig {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// Configuration of the transcoder settings.
// Examples: map[]
func (s CentralStreamConfigImpl) Transcoder() TranscoderOpts {
	return s.TranscoderValue
}

// Configuration of the transcoder settings.
// Examples: map[]
func (s *CentralStreamConfigImpl) SetTranscoder(v TranscoderOpts) CentralStreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*TranscoderOptsImpl); ok {
		s.TranscoderValue = impl
	}
	return s
}

// Transport protocol for WebRTC.
func (s CentralStreamConfigImpl) Transport() *WebrtcTransport {
	return s.TransportValue
}

// Transport protocol for WebRTC.
func (s *CentralStreamConfigImpl) SetTransport(v WebrtcTransport) CentralStreamConfig {
	if s == nil {
		return nil
	}
	s.TransportValue = &v
	return s
}

// The time of the last change of any stream field.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637098611e+12
func (s CentralStreamConfigImpl) UpdatedAt() UtcMs {
	return s.UpdatedAtValue
}

// The time of the last change of any stream field.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637098611e+12
func (s *CentralStreamConfigImpl) SetUpdatedAt(v UtcMs) CentralStreamConfig {
	if s == nil {
		return nil
	}
	s.UpdatedAtValue = v
	return s
}

// A string starting the addresses of separate segments within a *segment-based* playlists (HLS or DASH).
// Each sub-playlist is stored on Media Server.
// If set to `false`, the configured value in a template will be disabled.
func (s CentralStreamConfigImpl) URLPrefix() *URLPrefix {
	return s.URLPrefixValue
}

// A string starting the addresses of separate segments within a *segment-based* playlists (HLS or DASH).
// Each sub-playlist is stored on Media Server.
// If set to `false`, the configured value in a template will be disabled.
func (s *CentralStreamConfigImpl) SetURLPrefix(v *URLPrefix) CentralStreamConfig {
	if s == nil {
		return nil
	}
	s.URLPrefixValue = v
	return s
}

// If a connected source does not send video data within this timeout period (in seconds),
// the source connection is considered to be lost.
// This is a default configuration for a stream, can be modified for any input.
// Format: seconds (seconds)
// Example: 20
func (s CentralStreamConfigImpl) VideoTimeout() *Seconds {
	return s.VideoTimeoutValue
}

// If a connected source does not send video data within this timeout period (in seconds),
// the source connection is considered to be lost.
// This is a default configuration for a stream, can be modified for any input.
// Format: seconds (seconds)
// Example: 20
func (s *CentralStreamConfigImpl) SetVideoTimeout(v Seconds) CentralStreamConfig {
	if s == nil {
		return nil
	}
	s.VideoTimeoutValue = &v
	return s
}

// Video analytics parameters.
func (s CentralStreamConfigImpl) Vision() VisionSpec {
	return s.VisionValue
}

// Video analytics parameters.
func (s *CentralStreamConfigImpl) SetVision(v VisionSpec) CentralStreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionSpecImpl); ok {
		s.VisionValue = impl
	}
	return s
}

// WebRTC play configuration for a stream.
func (s CentralStreamConfigImpl) WebrtcAbr() WebrtcAbrOpts {
	return s.WebrtcAbrValue
}

// WebRTC play configuration for a stream.
func (s *CentralStreamConfigImpl) SetWebrtcAbr(v WebrtcAbrOpts) CentralStreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*WebrtcAbrOptsImpl); ok {
		s.WebrtcAbrValue = impl
	}
	return s
}

// NewCentralStreamConfigAdditional creates a new CentralStreamConfigAdditional instance
func NewCentralStreamConfigAdditional() CentralStreamConfigAdditional {
	return &CentralStreamConfigAdditionalImpl{}
}

// This option has sense only for published streams. For all other behavior is undefined and unpredicted.
// If the value is greater than 0, Central will generate episodes for the stream automatically based on the
// [stream DVR ranges](https://flussonic.com/doc/api/reference/#tag/stream-dvr/operation/stream_dvr_ranges_list).
// Each range is considered an episode given that at least timeout seconds passed between these ranges.
// An episode is created at the start of the publication and is closed after a timeout after the end of publication.
// If new publication started in less than timeout - two publications will be merged into one episode.
// Format: seconds (seconds)
func (s CentralStreamConfigAdditionalImpl) AutogeneratedEpisodesCloseTimeout() *Seconds {
	return s.AutogeneratedEpisodesCloseTimeoutValue
}

// This option has sense only for published streams. For all other behavior is undefined and unpredicted.
// If the value is greater than 0, Central will generate episodes for the stream automatically based on the
// [stream DVR ranges](https://flussonic.com/doc/api/reference/#tag/stream-dvr/operation/stream_dvr_ranges_list).
// Each range is considered an episode given that at least timeout seconds passed between these ranges.
// An episode is created at the start of the publication and is closed after a timeout after the end of publication.
// If new publication started in less than timeout - two publications will be merged into one episode.
// Format: seconds (seconds)
func (s *CentralStreamConfigAdditionalImpl) SetAutogeneratedEpisodesCloseTimeout(v Seconds) CentralStreamConfigAdditional {
	if s == nil {
		return nil
	}
	s.AutogeneratedEpisodesCloseTimeoutValue = &v
	return s
}

// Stream's logical namespace. Stream operations are only possible on streamers within the same namespace. By default, a stream has no assigned namespace. In this default state, it can interact with streamers that also have no assigned namespace. If a namespace is explicitly set, the stream will only interact with streamers possessing that specific namespace.
// For example, the layouter will distribute streams only to streamers with the same namespace. The `dynamic_streams_list` endpoint will operate exclusively within a single namespace.
// ***Use case:***
// Namespaces provide strict, system-wide resource isolation, fundamentally separating streams and streamers into independent segments. This ensures no interaction, archive access, inference processing, or layout operations occur between different namespaces.
// Unlike labels, which offer flexible, attribute-based layout control within a namespace, namespaces define an absolute boundary: resources from one namespace cannot interact with resources from another.
// ***Important:***
// A namespace can only be assigned when the stream is created and cannot be changed afterwards.
// Format: unix_name (Contains only alphanumeric characters (a-z, A-Z, 0-9), underscores (_), hyphens (-) and periods (.).)
// Pattern: ^[a-zA-Z0-9_.-]+$
// Example: example
func (s CentralStreamConfigAdditionalImpl) Namespace() *UnixName {
	return s.NamespaceValue
}

// Stream's logical namespace. Stream operations are only possible on streamers within the same namespace. By default, a stream has no assigned namespace. In this default state, it can interact with streamers that also have no assigned namespace. If a namespace is explicitly set, the stream will only interact with streamers possessing that specific namespace.
// For example, the layouter will distribute streams only to streamers with the same namespace. The `dynamic_streams_list` endpoint will operate exclusively within a single namespace.
// ***Use case:***
// Namespaces provide strict, system-wide resource isolation, fundamentally separating streams and streamers into independent segments. This ensures no interaction, archive access, inference processing, or layout operations occur between different namespaces.
// Unlike labels, which offer flexible, attribute-based layout control within a namespace, namespaces define an absolute boundary: resources from one namespace cannot interact with resources from another.
// ***Important:***
// A namespace can only be assigned when the stream is created and cannot be changed afterwards.
// Format: unix_name (Contains only alphanumeric characters (a-z, A-Z, 0-9), underscores (_), hyphens (-) and periods (.).)
// Pattern: ^[a-zA-Z0-9_.-]+$
// Example: example
func (s *CentralStreamConfigAdditionalImpl) SetNamespace(v UnixName) CentralStreamConfigAdditional {
	if s == nil {
		return nil
	}
	s.NamespaceValue = &v
	return s
}

// The time of the last change of any stream field.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637098611e+12
func (s CentralStreamConfigAdditionalImpl) UpdatedAt() UtcMs {
	return s.UpdatedAtValue
}

// The time of the last change of any stream field.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637098611e+12
func (s *CentralStreamConfigAdditionalImpl) SetUpdatedAt(v UtcMs) CentralStreamConfigAdditional {
	if s == nil {
		return nil
	}
	s.UpdatedAtValue = v
	return s
}

// NewCentralStreamLayout creates a new CentralStreamLayout instance
func NewCentralStreamLayout() CentralStreamLayout {
	return &CentralStreamLayoutImpl{}
}

// Reason why layout was changed
func (s CentralStreamLayoutImpl) ChangeReason() *CentralStreamLayoutChangeReason {
	return s.ChangeReasonValue
}

// Reason why layout was changed
func (s *CentralStreamLayoutImpl) SetChangeReason(v CentralStreamLayoutChangeReason) CentralStreamLayout {
	if s == nil {
		return nil
	}
	s.ChangeReasonValue = &v
	return s
}

// Time when the node change occurred
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s CentralStreamLayoutImpl) CreatedAt() *UtcMs {
	return s.CreatedAtValue
}

// Time when the node change occurred
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s *CentralStreamLayoutImpl) SetCreatedAt(v UtcMs) CentralStreamLayout {
	if s == nil {
		return nil
	}
	s.CreatedAtValue = &v
	return s
}

// Current nodes on which the dvr backup is saving
func (s CentralStreamLayoutImpl) DvrBackups() []ServerName {
	return s.DvrBackupsValue
}

// Current nodes on which the dvr backup is saving
func (s *CentralStreamLayoutImpl) SetDvrBackups(v []ServerName) CentralStreamLayout {
	if s == nil {
		return nil
	}
	s.DvrBackupsValue = v
	return s
}

// Hostname of node on which the stream was captured before failover.
// This field is used to restore the [layout.ingest](https://flussonic.com/doc/api/central/#tag/stream/operation/stream_get/response%7Clayout%7Cingest)
// after failover.
// Format: server_name (server_name)
func (s CentralStreamLayoutImpl) FailoverFrom() *ServerName {
	return s.FailoverFromValue
}

// Hostname of node on which the stream was captured before failover.
// This field is used to restore the [layout.ingest](https://flussonic.com/doc/api/central/#tag/stream/operation/stream_get/response%7Clayout%7Cingest)
// after failover.
// Format: server_name (server_name)
func (s *CentralStreamLayoutImpl) SetFailoverFrom(v ServerName) CentralStreamLayout {
	if s == nil {
		return nil
	}
	s.FailoverFromValue = &v
	return s
}

// Hostname of current inference node on which stream analytics running.
// Format: server_name (server_name)
func (s CentralStreamLayoutImpl) Inference() *ServerName {
	return s.InferenceValue
}

// Hostname of current inference node on which stream analytics running.
// Format: server_name (server_name)
func (s *CentralStreamLayoutImpl) SetInference(v ServerName) CentralStreamLayout {
	if s == nil {
		return nil
	}
	s.InferenceValue = &v
	return s
}

// Hostname of current ingest on which the stream is being captured
// Format: server_name (server_name)
func (s CentralStreamLayoutImpl) Ingest() *ServerName {
	return s.IngestValue
}

// Hostname of current ingest on which the stream is being captured
// Format: server_name (server_name)
func (s *CentralStreamLayoutImpl) SetIngest(v ServerName) CentralStreamLayout {
	if s == nil {
		return nil
	}
	s.IngestValue = &v
	return s
}

// History of layout ingest. This field includes only 5 last records.
// This field is only returned with explicit `include_ingest_history=true` query param.
func (s CentralStreamLayoutImpl) IngestHistory() []CentralStreamLayoutBase {
	if s.IngestHistoryValue == nil {
		return nil
	}
	result := make([]CentralStreamLayoutBase, len(s.IngestHistoryValue))
	for i, item := range s.IngestHistoryValue {
		result[i] = item
	}
	return result
}

// History of layout ingest. This field includes only 5 last records.
// This field is only returned with explicit `include_ingest_history=true` query param.
func (s *CentralStreamLayoutImpl) SetIngestHistory(v []CentralStreamLayoutBase) CentralStreamLayout {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*CentralStreamLayoutBaseImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*CentralStreamLayoutBaseImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.IngestHistoryValue = impl
	}
	return s
}

// List of decisions made by [layouter](https://flussonic.com/doc/api/layouter/) for each node.
// These decisions are used to determine the final layout of the stream.
func (s CentralStreamLayoutImpl) NodeLayoutDecisions() []CentralNodeLayoutDecision {
	if s.NodeLayoutDecisionsValue == nil {
		return nil
	}
	result := make([]CentralNodeLayoutDecision, len(s.NodeLayoutDecisionsValue))
	for i, item := range s.NodeLayoutDecisionsValue {
		result[i] = item
	}
	return result
}

// List of decisions made by [layouter](https://flussonic.com/doc/api/layouter/) for each node.
// These decisions are used to determine the final layout of the stream.
func (s *CentralStreamLayoutImpl) SetNodeLayoutDecisions(v []CentralNodeLayoutDecision) CentralStreamLayout {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*CentralNodeLayoutDecisionImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*CentralNodeLayoutDecisionImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.NodeLayoutDecisionsValue = impl
	}
	return s
}

// Service or admin user who changed the layout of the stream using an API call.
func (s CentralStreamLayoutImpl) Originator() *CentralStreamLayoutOriginator {
	return s.OriginatorValue
}

// Service or admin user who changed the layout of the stream using an API call.
func (s *CentralStreamLayoutImpl) SetOriginator(v CentralStreamLayoutOriginator) CentralStreamLayout {
	if s == nil {
		return nil
	}
	s.OriginatorValue = &v
	return s
}

// NewCentralStreamLayoutBase creates a new CentralStreamLayoutBase instance
func NewCentralStreamLayoutBase() CentralStreamLayoutBase {
	return &CentralStreamLayoutBaseImpl{}
}

// Time when the node change occurred
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s CentralStreamLayoutBaseImpl) CreatedAt() *UtcMs {
	return s.CreatedAtValue
}

// Time when the node change occurred
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s *CentralStreamLayoutBaseImpl) SetCreatedAt(v UtcMs) CentralStreamLayoutBase {
	if s == nil {
		return nil
	}
	s.CreatedAtValue = &v
	return s
}

// Hostname of current ingest on which the stream is being captured
// Format: server_name (server_name)
func (s CentralStreamLayoutBaseImpl) Ingest() *ServerName {
	return s.IngestValue
}

// Hostname of current ingest on which the stream is being captured
// Format: server_name (server_name)
func (s *CentralStreamLayoutBaseImpl) SetIngest(v ServerName) CentralStreamLayoutBase {
	if s == nil {
		return nil
	}
	s.IngestValue = &v
	return s
}

// Service or admin user who changed the layout of the stream using an API call.
func (s CentralStreamLayoutBaseImpl) Originator() *CentralStreamLayoutOriginator {
	return s.OriginatorValue
}

// Service or admin user who changed the layout of the stream using an API call.
func (s *CentralStreamLayoutBaseImpl) SetOriginator(v CentralStreamLayoutOriginator) CentralStreamLayoutBase {
	if s == nil {
		return nil
	}
	s.OriginatorValue = &v
	return s
}

// NewCentralStreamLayoutConfig creates a new CentralStreamLayoutConfig instance
func NewCentralStreamLayoutConfig() CentralStreamLayoutConfig {
	return &CentralStreamLayoutConfigImpl{}
}

// User-defined claims about the stream parameters.
// Set this field so that [layouter](https://flussonic.com/doc/api/layouter/) can rely on this data when distributing streams.
func (s CentralStreamLayoutConfigImpl) Claims() CentralStreamLayoutConfigClaims {
	return s.ClaimsValue
}

// User-defined claims about the stream parameters.
// Set this field so that [layouter](https://flussonic.com/doc/api/layouter/) can rely on this data when distributing streams.
func (s *CentralStreamLayoutConfigImpl) SetClaims(v CentralStreamLayoutConfigClaims) CentralStreamLayoutConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*CentralStreamLayoutConfigClaimsImpl); ok {
		s.ClaimsValue = impl
	}
	return s
}

// Current layout of stream. Central will provide configuration to nodes based on this layout.
func (s CentralStreamLayoutConfigImpl) Layout() CentralStreamLayout {
	return s.LayoutValue
}

// Current layout of stream. Central will provide configuration to nodes based on this layout.
func (s *CentralStreamLayoutConfigImpl) SetLayout(v CentralStreamLayout) CentralStreamLayoutConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*CentralStreamLayoutImpl); ok {
		s.LayoutValue = impl
	}
	return s
}

// NewCentralStreamLayoutConfigClaims creates a new CentralStreamLayoutConfigClaims instance
func NewCentralStreamLayoutConfigClaims() CentralStreamLayoutConfigClaims {
	return &CentralStreamLayoutConfigClaimsImpl{}
}

// Stream bitrate in kbps.
// This value is used to calculate disk and network consumption.
// Format: speed (speed)
// Example: 2543
func (s CentralStreamLayoutConfigClaimsImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// Stream bitrate in kbps.
// This value is used to calculate disk and network consumption.
// Format: speed (speed)
// Example: 2543
func (s *CentralStreamLayoutConfigClaimsImpl) SetBitrate(v Speed) CentralStreamLayoutConfigClaims {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// NewCentralStreamLayoutList creates a new CentralStreamLayoutList instance
func NewCentralStreamLayoutList() CentralStreamLayoutList {
	return &CentralStreamLayoutListImpl{}
}

// List of streams layouts
func (s CentralStreamLayoutListImpl) Layouts() []CentralStreamLayoutListItem {
	if s.LayoutsValue == nil {
		return nil
	}
	result := make([]CentralStreamLayoutListItem, len(s.LayoutsValue))
	for i, item := range s.LayoutsValue {
		result[i] = item
	}
	return result
}

// List of streams layouts
func (s *CentralStreamLayoutListImpl) SetLayouts(v []CentralStreamLayoutListItem) CentralStreamLayoutList {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*CentralStreamLayoutListItemImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*CentralStreamLayoutListItemImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.LayoutsValue = impl
	}
	return s
}

// NewCentralStreamLayoutListItem creates a new CentralStreamLayoutListItem instance
func NewCentralStreamLayoutListItem() CentralStreamLayoutListItem {
	return &CentralStreamLayoutListItemImpl{}
}

// Reason why layout was changed
func (s CentralStreamLayoutListItemImpl) ChangeReason() *CentralStreamLayoutChangeReason {
	return s.ChangeReasonValue
}

// Reason why layout was changed
func (s *CentralStreamLayoutListItemImpl) SetChangeReason(v CentralStreamLayoutChangeReason) CentralStreamLayoutListItem {
	if s == nil {
		return nil
	}
	s.ChangeReasonValue = &v
	return s
}

// Time when the node change occurred
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s CentralStreamLayoutListItemImpl) CreatedAt() *UtcMs {
	return s.CreatedAtValue
}

// Time when the node change occurred
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s *CentralStreamLayoutListItemImpl) SetCreatedAt(v UtcMs) CentralStreamLayoutListItem {
	if s == nil {
		return nil
	}
	s.CreatedAtValue = &v
	return s
}

// Current nodes on which the dvr backup is saving
func (s CentralStreamLayoutListItemImpl) DvrBackups() []ServerName {
	return s.DvrBackupsValue
}

// Current nodes on which the dvr backup is saving
func (s *CentralStreamLayoutListItemImpl) SetDvrBackups(v []ServerName) CentralStreamLayoutListItem {
	if s == nil {
		return nil
	}
	s.DvrBackupsValue = v
	return s
}

// Hostname of node on which the stream was captured before failover.
// This field is used to restore the [layout.ingest](https://flussonic.com/doc/api/central/#tag/stream/operation/stream_get/response%7Clayout%7Cingest)
// after failover.
// Format: server_name (server_name)
func (s CentralStreamLayoutListItemImpl) FailoverFrom() *ServerName {
	return s.FailoverFromValue
}

// Hostname of node on which the stream was captured before failover.
// This field is used to restore the [layout.ingest](https://flussonic.com/doc/api/central/#tag/stream/operation/stream_get/response%7Clayout%7Cingest)
// after failover.
// Format: server_name (server_name)
func (s *CentralStreamLayoutListItemImpl) SetFailoverFrom(v ServerName) CentralStreamLayoutListItem {
	if s == nil {
		return nil
	}
	s.FailoverFromValue = &v
	return s
}

// Hostname of current inference node on which stream analytics running.
// Format: server_name (server_name)
func (s CentralStreamLayoutListItemImpl) Inference() *ServerName {
	return s.InferenceValue
}

// Hostname of current inference node on which stream analytics running.
// Format: server_name (server_name)
func (s *CentralStreamLayoutListItemImpl) SetInference(v ServerName) CentralStreamLayoutListItem {
	if s == nil {
		return nil
	}
	s.InferenceValue = &v
	return s
}

// Hostname of current ingest on which the stream is being captured
// Format: server_name (server_name)
func (s CentralStreamLayoutListItemImpl) Ingest() *ServerName {
	return s.IngestValue
}

// Hostname of current ingest on which the stream is being captured
// Format: server_name (server_name)
func (s *CentralStreamLayoutListItemImpl) SetIngest(v ServerName) CentralStreamLayoutListItem {
	if s == nil {
		return nil
	}
	s.IngestValue = &v
	return s
}

// History of layout ingest. This field includes only 5 last records.
// This field is only returned with explicit `include_ingest_history=true` query param.
func (s CentralStreamLayoutListItemImpl) IngestHistory() []CentralStreamLayoutBase {
	if s.IngestHistoryValue == nil {
		return nil
	}
	result := make([]CentralStreamLayoutBase, len(s.IngestHistoryValue))
	for i, item := range s.IngestHistoryValue {
		result[i] = item
	}
	return result
}

// History of layout ingest. This field includes only 5 last records.
// This field is only returned with explicit `include_ingest_history=true` query param.
func (s *CentralStreamLayoutListItemImpl) SetIngestHistory(v []CentralStreamLayoutBase) CentralStreamLayoutListItem {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*CentralStreamLayoutBaseImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*CentralStreamLayoutBaseImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.IngestHistoryValue = impl
	}
	return s
}

// Name of the stream
func (s CentralStreamLayoutListItemImpl) Name() *string {
	return s.NameValue
}

// Name of the stream
func (s *CentralStreamLayoutListItemImpl) SetName(v string) CentralStreamLayoutListItem {
	if s == nil {
		return nil
	}
	s.NameValue = &v
	return s
}

// List of decisions made by [layouter](https://flussonic.com/doc/api/layouter/) for each node.
// These decisions are used to determine the final layout of the stream.
func (s CentralStreamLayoutListItemImpl) NodeLayoutDecisions() []CentralNodeLayoutDecision {
	if s.NodeLayoutDecisionsValue == nil {
		return nil
	}
	result := make([]CentralNodeLayoutDecision, len(s.NodeLayoutDecisionsValue))
	for i, item := range s.NodeLayoutDecisionsValue {
		result[i] = item
	}
	return result
}

// List of decisions made by [layouter](https://flussonic.com/doc/api/layouter/) for each node.
// These decisions are used to determine the final layout of the stream.
func (s *CentralStreamLayoutListItemImpl) SetNodeLayoutDecisions(v []CentralNodeLayoutDecision) CentralStreamLayoutListItem {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*CentralNodeLayoutDecisionImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*CentralNodeLayoutDecisionImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.NodeLayoutDecisionsValue = impl
	}
	return s
}

// Service or admin user who changed the layout of the stream using an API call.
func (s CentralStreamLayoutListItemImpl) Originator() *CentralStreamLayoutOriginator {
	return s.OriginatorValue
}

// Service or admin user who changed the layout of the stream using an API call.
func (s *CentralStreamLayoutListItemImpl) SetOriginator(v CentralStreamLayoutOriginator) CentralStreamLayoutListItem {
	if s == nil {
		return nil
	}
	s.OriginatorValue = &v
	return s
}

// NewCentralStreamLayoutPrediction creates a new CentralStreamLayoutPrediction instance
func NewCentralStreamLayoutPrediction() CentralStreamLayoutPrediction {
	return &CentralStreamLayoutPredictionImpl{}
}

// List of streams layout changes
func (s CentralStreamLayoutPredictionImpl) Changes() []CentralStreamLayoutListItem {
	if s.ChangesValue == nil {
		return nil
	}
	result := make([]CentralStreamLayoutListItem, len(s.ChangesValue))
	for i, item := range s.ChangesValue {
		result[i] = item
	}
	return result
}

// List of streams layout changes
func (s *CentralStreamLayoutPredictionImpl) SetChanges(v []CentralStreamLayoutListItem) CentralStreamLayoutPrediction {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*CentralStreamLayoutListItemImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*CentralStreamLayoutListItemImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.ChangesValue = impl
	}
	return s
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s CentralStreamLayoutPredictionImpl) EstimatedCount() *int {
	return s.EstimatedCountValue
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s *CentralStreamLayoutPredictionImpl) SetEstimatedCount(v int) CentralStreamLayoutPrediction {
	if s == nil {
		return nil
	}
	s.EstimatedCountValue = &v
	return s
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s CentralStreamLayoutPredictionImpl) Next() *string {
	return s.NextValue
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s *CentralStreamLayoutPredictionImpl) SetNext(v string) CentralStreamLayoutPrediction {
	if s == nil {
		return nil
	}
	s.NextValue = &v
	return s
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s CentralStreamLayoutPredictionImpl) Prev() *string {
	return s.PrevValue
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s *CentralStreamLayoutPredictionImpl) SetPrev(v string) CentralStreamLayoutPrediction {
	if s == nil {
		return nil
	}
	s.PrevValue = &v
	return s
}

// An object with a list of different timings measured during this API call.
func (s CentralStreamLayoutPredictionImpl) Timing() any {
	return s.TimingValue
}

// An object with a list of different timings measured during this API call.
func (s *CentralStreamLayoutPredictionImpl) SetTiming(v any) CentralStreamLayoutPrediction {
	if s == nil {
		return nil
	}
	s.TimingValue = v
	return s
}

// Collection returns the collection items from CentralStreamLayoutPrediction
func (s CentralStreamLayoutPredictionImpl) Collection() []CentralStreamLayoutListItem {
	return s.Changes()
}

// NewCentralStreamLayouts creates a new CentralStreamLayouts instance
func NewCentralStreamLayouts() CentralStreamLayouts {
	return &CentralStreamLayoutsImpl{}
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s CentralStreamLayoutsImpl) EstimatedCount() *int {
	return s.EstimatedCountValue
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s *CentralStreamLayoutsImpl) SetEstimatedCount(v int) CentralStreamLayouts {
	if s == nil {
		return nil
	}
	s.EstimatedCountValue = &v
	return s
}

// List of streams layouts records according to the query parameters.
func (s CentralStreamLayoutsImpl) Layouts() []CentralStreamLayout {
	if s.LayoutsValue == nil {
		return nil
	}
	result := make([]CentralStreamLayout, len(s.LayoutsValue))
	for i, item := range s.LayoutsValue {
		result[i] = item
	}
	return result
}

// List of streams layouts records according to the query parameters.
func (s *CentralStreamLayoutsImpl) SetLayouts(v []CentralStreamLayout) CentralStreamLayouts {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*CentralStreamLayoutImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*CentralStreamLayoutImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.LayoutsValue = impl
	}
	return s
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s CentralStreamLayoutsImpl) Next() *string {
	return s.NextValue
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s *CentralStreamLayoutsImpl) SetNext(v string) CentralStreamLayouts {
	if s == nil {
		return nil
	}
	s.NextValue = &v
	return s
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s CentralStreamLayoutsImpl) Prev() *string {
	return s.PrevValue
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s *CentralStreamLayoutsImpl) SetPrev(v string) CentralStreamLayouts {
	if s == nil {
		return nil
	}
	s.PrevValue = &v
	return s
}

// An object with a list of different timings measured during this API call.
func (s CentralStreamLayoutsImpl) Timing() any {
	return s.TimingValue
}

// An object with a list of different timings measured during this API call.
func (s *CentralStreamLayoutsImpl) SetTiming(v any) CentralStreamLayouts {
	if s == nil {
		return nil
	}
	s.TimingValue = v
	return s
}

// Collection returns the collection items from CentralStreamLayouts
func (s CentralStreamLayoutsImpl) Collection() []CentralStreamLayout {
	return s.Layouts()
}

// NewCentralStreamerLayoutPrediction creates a new CentralStreamerLayoutPrediction instance
func NewCentralStreamerLayoutPrediction() CentralStreamerLayoutPrediction {
	return &CentralStreamerLayoutPredictionImpl{}
}

// Predicted layout based on changed properties of streamer grouped by hostname and role.
// The result does not contain unchanged streamers.
// If streamer config was not changed, the result will be empty.
func (s CentralStreamerLayoutPredictionImpl) Changes() []CentralStreamerLayoutPredictionItem {
	if s.ChangesValue == nil {
		return nil
	}
	result := make([]CentralStreamerLayoutPredictionItem, len(s.ChangesValue))
	for i, item := range s.ChangesValue {
		result[i] = item
	}
	return result
}

// Predicted layout based on changed properties of streamer grouped by hostname and role.
// The result does not contain unchanged streamers.
// If streamer config was not changed, the result will be empty.
func (s *CentralStreamerLayoutPredictionImpl) SetChanges(v []CentralStreamerLayoutPredictionItem) CentralStreamerLayoutPrediction {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*CentralStreamerLayoutPredictionItemImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*CentralStreamerLayoutPredictionItemImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.ChangesValue = impl
	}
	return s
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s CentralStreamerLayoutPredictionImpl) EstimatedCount() *int {
	return s.EstimatedCountValue
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s *CentralStreamerLayoutPredictionImpl) SetEstimatedCount(v int) CentralStreamerLayoutPrediction {
	if s == nil {
		return nil
	}
	s.EstimatedCountValue = &v
	return s
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s CentralStreamerLayoutPredictionImpl) Next() *string {
	return s.NextValue
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s *CentralStreamerLayoutPredictionImpl) SetNext(v string) CentralStreamerLayoutPrediction {
	if s == nil {
		return nil
	}
	s.NextValue = &v
	return s
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s CentralStreamerLayoutPredictionImpl) Prev() *string {
	return s.PrevValue
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s *CentralStreamerLayoutPredictionImpl) SetPrev(v string) CentralStreamerLayoutPrediction {
	if s == nil {
		return nil
	}
	s.PrevValue = &v
	return s
}

// An object with a list of different timings measured during this API call.
func (s CentralStreamerLayoutPredictionImpl) Timing() any {
	return s.TimingValue
}

// An object with a list of different timings measured during this API call.
func (s *CentralStreamerLayoutPredictionImpl) SetTiming(v any) CentralStreamerLayoutPrediction {
	if s == nil {
		return nil
	}
	s.TimingValue = v
	return s
}

// Collection returns the collection items from CentralStreamerLayoutPrediction
func (s CentralStreamerLayoutPredictionImpl) Collection() []CentralStreamerLayoutPredictionItem {
	return s.Changes()
}

// NewCentralStreamerLayoutPredictionItem creates a new CentralStreamerLayoutPredictionItem instance
func NewCentralStreamerLayoutPredictionItem() CentralStreamerLayoutPredictionItem {
	return &CentralStreamerLayoutPredictionItemImpl{}
}

// Number of streams assigned to the streamer after the layouter iteration.
// Example: 123
func (s CentralStreamerLayoutPredictionItemImpl) After() *int {
	return s.AfterValue
}

// Number of streams assigned to the streamer after the layouter iteration.
// Example: 123
func (s *CentralStreamerLayoutPredictionItemImpl) SetAfter(v int) CentralStreamerLayoutPredictionItem {
	if s == nil {
		return nil
	}
	s.AfterValue = &v
	return s
}

// Number of streams assigned to the streamer before the layouter iteration.
// Example: 321
func (s CentralStreamerLayoutPredictionItemImpl) Before() *int {
	return s.BeforeValue
}

// Number of streams assigned to the streamer before the layouter iteration.
// Example: 321
func (s *CentralStreamerLayoutPredictionItemImpl) SetBefore(v int) CentralStreamerLayoutPredictionItem {
	if s == nil {
		return nil
	}
	s.BeforeValue = &v
	return s
}

// `after - before` value.
// Example: 1
func (s CentralStreamerLayoutPredictionItemImpl) Delta() *int {
	return s.DeltaValue
}

// `after - before` value.
// Example: 1
func (s *CentralStreamerLayoutPredictionItemImpl) SetDelta(v int) CentralStreamerLayoutPredictionItem {
	if s == nil {
		return nil
	}
	s.DeltaValue = &v
	return s
}

// Hostname of streamer
// Format: server_name (server_name)
// Example: streamer1
func (s CentralStreamerLayoutPredictionItemImpl) Hostname() *ServerName {
	return s.HostnameValue
}

// Hostname of streamer
// Format: server_name (server_name)
// Example: streamer1
func (s *CentralStreamerLayoutPredictionItemImpl) SetHostname(v ServerName) CentralStreamerLayoutPredictionItem {
	if s == nil {
		return nil
	}
	s.HostnameValue = &v
	return s
}

// Layout role of streamer.
// Example: ingest
func (s CentralStreamerLayoutPredictionItemImpl) Role() *CentralStreamerLayoutPredictionItemRole {
	return s.RoleValue
}

// Layout role of streamer.
// Example: ingest
func (s *CentralStreamerLayoutPredictionItemImpl) SetRole(v CentralStreamerLayoutPredictionItemRole) CentralStreamerLayoutPredictionItem {
	if s == nil {
		return nil
	}
	s.RoleValue = &v
	return s
}

// NewCentralStreamerNode creates a new CentralStreamerNode instance
func NewCentralStreamerNode() CentralStreamerNode {
	return &CentralStreamerNodeImpl{}
}

// The URL for provisioning of configuration from the managing server to the streamer.
// This URL does not have to be public but must be accessible from the managing server.
// The API URL can also be used as Public and/or Private payload URL if they are not set.
// When used as Public payload URL, the API URL shall be public to allow playback from this streamer.
// Format: url (url)
// Example: http://streamer.local:8080
func (s CentralStreamerNodeImpl) APIURL() *URL {
	return s.APIURLValue
}

// The URL for provisioning of configuration from the managing server to the streamer.
// This URL does not have to be public but must be accessible from the managing server.
// The API URL can also be used as Public and/or Private payload URL if they are not set.
// When used as Public payload URL, the API URL shall be public to allow playback from this streamer.
// Format: url (url)
// Example: http://streamer.local:8080
func (s *CentralStreamerNodeImpl) SetAPIURL(v URL) CentralStreamerNode {
	if s == nil {
		return nil
	}
	s.APIURLValue = &v
	return s
}

// Maximal number of streams.
// Example: 5
func (s CentralStreamerNodeImpl) ChannelLimit() *int {
	return s.ChannelLimitValue
}

// Maximal number of streams.
// Example: 5
func (s *CentralStreamerNodeImpl) SetChannelLimit(v int) CentralStreamerNode {
	if s == nil {
		return nil
	}
	s.ChannelLimitValue = &v
	return s
}

// The key for authorization for inter-Flussonic connections.
// All cluster peers should have the same cluster key.
// Example: xS6i6Q3DCc5nEvnu
func (s CentralStreamerNodeImpl) ClusterKey() *string {
	return s.ClusterKeyValue
}

// The key for authorization for inter-Flussonic connections.
// All cluster peers should have the same cluster key.
// Example: xS6i6Q3DCc5nEvnu
func (s *CentralStreamerNodeImpl) SetClusterKey(v string) CentralStreamerNode {
	if s == nil {
		return nil
	}
	s.ClusterKeyValue = &v
	return s
}

// Flussonic Media Server configuration which will be provided to Streamer
func (s CentralStreamerNodeImpl) Config() CentralStreamerNodeConfig {
	return s.ConfigValue
}

// Flussonic Media Server configuration which will be provided to Streamer
func (s *CentralStreamerNodeImpl) SetConfig(v CentralStreamerNodeConfig) CentralStreamerNode {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*CentralStreamerNodeConfigImpl); ok {
		s.ConfigValue = impl
	}
	return s
}

// CPU limit in percents.
// Format: percent (percent)
// Example: 10
func (s CentralStreamerNodeImpl) CpuLimit() *Percent {
	return s.CpuLimitValue
}

// CPU limit in percents.
// Format: percent (percent)
// Example: 10
func (s *CentralStreamerNodeImpl) SetCpuLimit(v Percent) CentralStreamerNode {
	if s == nil {
		return nil
	}
	s.CpuLimitValue = &v
	return s
}

// The configuration of the DVRs
func (s CentralStreamerNodeImpl) Dvrs() []DvrConfig {
	if s.DvrsValue == nil {
		return nil
	}
	result := make([]DvrConfig, len(s.DvrsValue))
	for i, item := range s.DvrsValue {
		result[i] = item
	}
	return result
}

// The configuration of the DVRs
func (s *CentralStreamerNodeImpl) SetDvrs(v []DvrConfig) CentralStreamerNode {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*DvrConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*DvrConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.DvrsValue = impl
	}
	return s
}

// How often the peer will try to get the data from the remote server via internal API.
// Format: milliseconds (milliseconds)
// Example: 1000
func (s CentralStreamerNodeImpl) FetchTimeout() *Milliseconds {
	return s.FetchTimeoutValue
}

// How often the peer will try to get the data from the remote server via internal API.
// Format: milliseconds (milliseconds)
// Example: 1000
func (s *CentralStreamerNodeImpl) SetFetchTimeout(v Milliseconds) CentralStreamerNode {
	if s == nil {
		return nil
	}
	s.FetchTimeoutValue = &v
	return s
}

// Streamer's identifier in the cluster.
// The managing server may try using this hostname to access the streamer
// if API URL is not specified.
// Format: server_name (server_name)
// Example: peer.example.com
func (s CentralStreamerNodeImpl) Hostname() *ServerName {
	return s.HostnameValue
}

// Streamer's identifier in the cluster.
// The managing server may try using this hostname to access the streamer
// if API URL is not specified.
// Format: server_name (server_name)
// Example: peer.example.com
func (s *CentralStreamerNodeImpl) SetHostname(v ServerName) CentralStreamerNode {
	if s == nil {
		return nil
	}
	s.HostnameValue = &v
	return s
}

// Flag indicating the Streamer's ability to act as a restreamer.
// See [dynamic_streams_list](https://flussonic.com/doc/api/config-external/#tag/stream/operation/dynamic_streams_list)
// operation for more info
func (s CentralStreamerNodeImpl) IsRestreamer() *bool {
	return s.IsRestreamerValue
}

// Flag indicating the Streamer's ability to act as a restreamer.
// See [dynamic_streams_list](https://flussonic.com/doc/api/config-external/#tag/stream/operation/dynamic_streams_list)
// operation for more info
func (s *CentralStreamerNodeImpl) SetIsRestreamer(v bool) CentralStreamerNode {
	if s == nil {
		return nil
	}
	s.IsRestreamerValue = &v
	return s
}

func (s CentralStreamerNodeImpl) Labels() map[string]UnixName {
	return s.LabelsValue
}

func (s *CentralStreamerNodeImpl) SetLabels(v map[string]UnixName) CentralStreamerNode {
	if s == nil {
		return nil
	}
	s.LabelsValue = v
	return s
}

// Deprecated field. Will be deleted at 23.09
// Maximal output bitrate of the peer.
// Format: speed (speed)
func (s CentralStreamerNodeImpl) MaxBitrate() *Speed {
	return s.MaxBitrateValue
}

// Deprecated field. Will be deleted at 23.09
// Maximal output bitrate of the peer.
// Format: speed (speed)
func (s *CentralStreamerNodeImpl) SetMaxBitrate(v Speed) CentralStreamerNode {
	if s == nil {
		return nil
	}
	s.MaxBitrateValue = &v
	return s
}

// Streamer's logical namespace, used for interacting with streams of the same namespace. By default, a streamer has no assigned namespace. In this default state, it can interact with streams that also have no assigned namespace. If a namespace is explicitly set, the streamer will only interact with streams possessing that specific namespace.
// For example, the layouter will distribute streams only to streamers with the same namespace. The `dynamic_streams_list` endpoint will operate exclusively within a single namespace.
// ***Use case:***
// Namespaces provide strict, system-wide resource isolation, fundamentally separating streams and streamers into independent segments. This ensures no interaction, archive access, inference processing, or layout operations occur between different namespaces.
// Unlike labels, which offer flexible, attribute-based layout control within a namespace, namespaces define an absolute boundary: resources from one namespace cannot interact with resources from another.
// ***Important:***
// A namespace can only be assigned when the streamer is created and cannot be changed afterwards.
// Format: unix_name (Contains only alphanumeric characters (a-z, A-Z, 0-9), underscores (_), hyphens (-) and periods (.).)
// Pattern: ^[a-zA-Z0-9_.-]+$
// Example: example
func (s CentralStreamerNodeImpl) Namespace() *UnixName {
	return s.NamespaceValue
}

// Streamer's logical namespace, used for interacting with streams of the same namespace. By default, a streamer has no assigned namespace. In this default state, it can interact with streams that also have no assigned namespace. If a namespace is explicitly set, the streamer will only interact with streams possessing that specific namespace.
// For example, the layouter will distribute streams only to streamers with the same namespace. The `dynamic_streams_list` endpoint will operate exclusively within a single namespace.
// ***Use case:***
// Namespaces provide strict, system-wide resource isolation, fundamentally separating streams and streamers into independent segments. This ensures no interaction, archive access, inference processing, or layout operations occur between different namespaces.
// Unlike labels, which offer flexible, attribute-based layout control within a namespace, namespaces define an absolute boundary: resources from one namespace cannot interact with resources from another.
// ***Important:***
// A namespace can only be assigned when the streamer is created and cannot be changed afterwards.
// Format: unix_name (Contains only alphanumeric characters (a-z, A-Z, 0-9), underscores (_), hyphens (-) and periods (.).)
// Pattern: ^[a-zA-Z0-9_.-]+$
// Example: example
func (s *CentralStreamerNodeImpl) SetNamespace(v UnixName) CentralStreamerNode {
	if s == nil {
		return nil
	}
	s.NamespaceValue = &v
	return s
}

// The internal address for communication in a local network (by default, it is equal to API URL).
// Format: url (url)
// Example: http://streamer.local
func (s CentralStreamerNodeImpl) PrivatePayloadURL() *URL {
	return s.PrivatePayloadURLValue
}

// The internal address for communication in a local network (by default, it is equal to API URL).
// Format: url (url)
// Example: http://streamer.local
func (s *CentralStreamerNodeImpl) SetPrivatePayloadURL(v URL) CentralStreamerNode {
	if s == nil {
		return nil
	}
	s.PrivatePayloadURLValue = &v
	return s
}

// The public address that is exposed to clients. It can also contain a port number.
// The client will be redirected to this URL and port when requesting for the stream captured on the peer
// even if other `http` port is set in the peer's own config.
// Format: url (url)
// Example: http://public.example.com
func (s CentralStreamerNodeImpl) PublicPayloadURL() *URL {
	return s.PublicPayloadURLValue
}

// The public address that is exposed to clients. It can also contain a port number.
// The client will be redirected to this URL and port when requesting for the stream captured on the peer
// even if other `http` port is set in the peer's own config.
// Format: url (url)
// Example: http://public.example.com
func (s *CentralStreamerNodeImpl) SetPublicPayloadURL(v URL) CentralStreamerNode {
	if s == nil {
		return nil
	}
	s.PublicPayloadURLValue = &v
	return s
}

// Role of node
func (s CentralStreamerNodeImpl) Role() *CentralNodeRoleRole {
	return s.RoleValue
}

// Role of node
func (s *CentralStreamerNodeImpl) SetRole(v CentralNodeRoleRole) CentralStreamerNode {
	if s == nil {
		return nil
	}
	s.RoleValue = &v
	return s
}

// The time after which deleted streams on this server are considered to be inactive
// and cannot be used in the `cluster_ingest` mechanism.
// Format: milliseconds (milliseconds)
// Example: 1000
func (s CentralStreamerNodeImpl) StaleTimeout() *Milliseconds {
	return s.StaleTimeoutValue
}

// The time after which deleted streams on this server are considered to be inactive
// and cannot be used in the `cluster_ingest` mechanism.
// Format: milliseconds (milliseconds)
// Example: 1000
func (s *CentralStreamerNodeImpl) SetStaleTimeout(v Milliseconds) CentralStreamerNode {
	if s == nil {
		return nil
	}
	s.StaleTimeoutValue = &v
	return s
}

// Statistics on peers in the cluster.
func (s CentralStreamerNodeImpl) Stats() PeerStats {
	return s.StatsValue
}

// Statistics on peers in the cluster.
func (s *CentralStreamerNodeImpl) SetStats(v PeerStats) CentralStreamerNode {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*PeerStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// Server network bandwidth limit in kbit.
// This value is used to calculate the current network load status.
// Format: speed (speed)
// Example: 1024
func (s CentralStreamerNodeImpl) TotalBandwidth() *Speed {
	return s.TotalBandwidthValue
}

// Server network bandwidth limit in kbit.
// This value is used to calculate the current network load status.
// Format: speed (speed)
// Example: 1024
func (s *CentralStreamerNodeImpl) SetTotalBandwidth(v Speed) CentralStreamerNode {
	if s == nil {
		return nil
	}
	s.TotalBandwidthValue = &v
	return s
}

// NewCentralStreamerNodeConfig creates a new CentralStreamerNodeConfig instance
func NewCentralStreamerNodeConfig() CentralStreamerNodeConfig {
	return &CentralStreamerNodeConfigImpl{}
}

// The cluster key to unite several servers with the same key into a cluster.
// Example: xS6i6Q3DCc5nEvnu
func (s CentralStreamerNodeConfigImpl) ClusterKey() *string {
	return s.ClusterKeyValue
}

// The cluster key to unite several servers with the same key into a cluster.
// Example: xS6i6Q3DCc5nEvnu
func (s *CentralStreamerNodeConfigImpl) SetClusterKey(v string) CentralStreamerNodeConfig {
	if s == nil {
		return nil
	}
	s.ClusterKeyValue = &v
	return s
}

// The configuration of event notifications
func (s CentralStreamerNodeConfigImpl) EventSinks() []EventSinkConfig {
	if s.EventSinksValue == nil {
		return nil
	}
	result := make([]EventSinkConfig, len(s.EventSinksValue))
	for i, item := range s.EventSinksValue {
		result[i] = item
	}
	return result
}

// The configuration of event notifications
func (s *CentralStreamerNodeConfigImpl) SetEventSinks(v []EventSinkConfig) CentralStreamerNodeConfig {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*EventSinkConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*EventSinkConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.EventSinksValue = impl
	}
	return s
}

// List of HTTP prefixes that can be handled via call to remote http server
func (s CentralStreamerNodeConfigImpl) HTTPProxies() []HTTPProxyConfig {
	if s.HTTPProxiesValue == nil {
		return nil
	}
	result := make([]HTTPProxyConfig, len(s.HTTPProxiesValue))
	for i, item := range s.HTTPProxiesValue {
		result[i] = item
	}
	return result
}

// List of HTTP prefixes that can be handled via call to remote http server
func (s *CentralStreamerNodeConfigImpl) SetHTTPProxies(v []HTTPProxyConfig) CentralStreamerNodeConfig {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*HTTPProxyConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*HTTPProxyConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.HTTPProxiesValue = impl
	}
	return s
}

// The configuration of the port forwarding.
func (s CentralStreamerNodeConfigImpl) Rproxy() RproxyConfig {
	return s.RproxyValue
}

// The configuration of the port forwarding.
func (s *CentralStreamerNodeConfigImpl) SetRproxy(v RproxyConfig) CentralStreamerNodeConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*RproxyConfigImpl); ok {
		s.RproxyValue = impl
	}
	return s
}

// The configuration of server domain name and aliases
func (s CentralStreamerNodeConfigImpl) ServerNames() []ServerNameConfig {
	if s.ServerNamesValue == nil {
		return nil
	}
	result := make([]ServerNameConfig, len(s.ServerNamesValue))
	for i, item := range s.ServerNamesValue {
		result[i] = item
	}
	return result
}

// The configuration of server domain name and aliases
func (s *CentralStreamerNodeConfigImpl) SetServerNames(v []ServerNameConfig) CentralStreamerNodeConfig {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*ServerNameConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*ServerNameConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.ServerNamesValue = impl
	}
	return s
}

// NewCentralStreamsList creates a new CentralStreamsList instance
func NewCentralStreamsList() CentralStreamsList {
	return &CentralStreamsListImpl{}
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s CentralStreamsListImpl) EstimatedCount() *int {
	return s.EstimatedCountValue
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s *CentralStreamsListImpl) SetEstimatedCount(v int) CentralStreamsList {
	if s == nil {
		return nil
	}
	s.EstimatedCountValue = &v
	return s
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s CentralStreamsListImpl) Next() *string {
	return s.NextValue
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s *CentralStreamsListImpl) SetNext(v string) CentralStreamsList {
	if s == nil {
		return nil
	}
	s.NextValue = &v
	return s
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s CentralStreamsListImpl) Prev() *string {
	return s.PrevValue
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s *CentralStreamsListImpl) SetPrev(v string) CentralStreamsList {
	if s == nil {
		return nil
	}
	s.PrevValue = &v
	return s
}

// List of fetched streams according to the query parameters.
func (s CentralStreamsListImpl) Streams() []CentralStreamConfig {
	if s.StreamsValue == nil {
		return nil
	}
	result := make([]CentralStreamConfig, len(s.StreamsValue))
	for i, item := range s.StreamsValue {
		result[i] = item
	}
	return result
}

// List of fetched streams according to the query parameters.
func (s *CentralStreamsListImpl) SetStreams(v []CentralStreamConfig) CentralStreamsList {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*CentralStreamConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*CentralStreamConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.StreamsValue = impl
	}
	return s
}

// An object with a list of different timings measured during this API call.
func (s CentralStreamsListImpl) Timing() any {
	return s.TimingValue
}

// An object with a list of different timings measured during this API call.
func (s *CentralStreamsListImpl) SetTiming(v any) CentralStreamsList {
	if s == nil {
		return nil
	}
	s.TimingValue = v
	return s
}

// Collection returns the collection items from CentralStreamsList
func (s CentralStreamsListImpl) Collection() []CentralStreamConfig {
	return s.Streams()
}

// NewClosedCaptions creates a new ClosedCaptions instance
func NewClosedCaptions() ClosedCaptions {
	return &ClosedCaptionsImpl{}
}

// Language of closed captions.
// Example: eng
func (s ClosedCaptionsImpl) Language() *string {
	return s.LanguageValue
}

// Language of closed captions.
// Example: eng
func (s *ClosedCaptionsImpl) SetLanguage(v string) ClosedCaptions {
	if s == nil {
		return nil
	}
	s.LanguageValue = &v
	return s
}

// Under what name the audio track will be displayed on the player.
// Example: English
func (s ClosedCaptionsImpl) Name() *string {
	return s.NameValue
}

// Under what name the audio track will be displayed on the player.
// Example: English
func (s *ClosedCaptionsImpl) SetName(v string) ClosedCaptions {
	if s == nil {
		return nil
	}
	s.NameValue = &v
	return s
}

// NewClusterHealthMetricsTotal creates a new ClusterHealthMetricsTotal instance
func NewClusterHealthMetricsTotal() ClusterHealthMetricsTotal {
	return &ClusterHealthMetricsTotalImpl{}
}

// Number of degraded entities
func (s ClusterHealthMetricsTotalImpl) Degradated() *int {
	return s.DegradatedValue
}

// Number of degraded entities
func (s *ClusterHealthMetricsTotalImpl) SetDegradated(v int) ClusterHealthMetricsTotal {
	if s == nil {
		return nil
	}
	s.DegradatedValue = &v
	return s
}

// Number of disabled entities
func (s ClusterHealthMetricsTotalImpl) Disabled() *int {
	return s.DisabledValue
}

// Number of disabled entities
func (s *ClusterHealthMetricsTotalImpl) SetDisabled(v int) ClusterHealthMetricsTotal {
	if s == nil {
		return nil
	}
	s.DisabledValue = &v
	return s
}

// Number of operational entities
func (s ClusterHealthMetricsTotalImpl) Operational() *int {
	return s.OperationalValue
}

// Number of operational entities
func (s *ClusterHealthMetricsTotalImpl) SetOperational(v int) ClusterHealthMetricsTotal {
	if s == nil {
		return nil
	}
	s.OperationalValue = &v
	return s
}

// Number of outage entities
func (s ClusterHealthMetricsTotalImpl) Outage() *int {
	return s.OutageValue
}

// Number of outage entities
func (s *ClusterHealthMetricsTotalImpl) SetOutage(v int) ClusterHealthMetricsTotal {
	if s == nil {
		return nil
	}
	s.OutageValue = &v
	return s
}

// Number of partial outage entities
func (s ClusterHealthMetricsTotalImpl) PartialOutage() *int {
	return s.PartialOutageValue
}

// Number of partial outage entities
func (s *ClusterHealthMetricsTotalImpl) SetPartialOutage(v int) ClusterHealthMetricsTotal {
	if s == nil {
		return nil
	}
	s.PartialOutageValue = &v
	return s
}

// Total number of entities
func (s ClusterHealthMetricsTotalImpl) Total() *int {
	return s.TotalValue
}

// Total number of entities
func (s *ClusterHealthMetricsTotalImpl) SetTotal(v int) ClusterHealthMetricsTotal {
	if s == nil {
		return nil
	}
	s.TotalValue = &v
	return s
}

// NewClusterHealthStats creates a new ClusterHealthStats instance
func NewClusterHealthStats() ClusterHealthStats {
	return &ClusterHealthStatsImpl{}
}

// Number of agents, grouped by status
func (s ClusterHealthStatsImpl) AgentMetricsTotal() ClusterHealthMetricsTotal {
	return s.AgentMetricsTotalValue
}

// Number of agents, grouped by status
func (s *ClusterHealthStatsImpl) SetAgentMetricsTotal(v ClusterHealthMetricsTotal) ClusterHealthStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ClusterHealthMetricsTotalImpl); ok {
		s.AgentMetricsTotalValue = impl
	}
	return s
}

// Metrics collection time
// Format: utc_ms (Unix timestamp in milliseconds)
func (s ClusterHealthStatsImpl) CollectedAt() *UtcMs {
	return s.CollectedAtValue
}

// Metrics collection time
// Format: utc_ms (Unix timestamp in milliseconds)
func (s *ClusterHealthStatsImpl) SetCollectedAt(v UtcMs) ClusterHealthStats {
	if s == nil {
		return nil
	}
	s.CollectedAtValue = &v
	return s
}

// Unique server ID generated on a first run.
// Format: uuid (uuid)
// Example: 123e4567-e89b-12d3-a456-426655440000
func (s ClusterHealthStatsImpl) ServerID() *UUID {
	return s.ServerIDValue
}

// Unique server ID generated on a first run.
// Format: uuid (uuid)
// Example: 123e4567-e89b-12d3-a456-426655440000
func (s *ClusterHealthStatsImpl) SetServerID(v UUID) ClusterHealthStats {
	if s == nil {
		return nil
	}
	s.ServerIDValue = &v
	return s
}

// Number of streams, grouped by status
func (s ClusterHealthStatsImpl) StreamMetricsTotal() ClusterHealthMetricsTotal {
	return s.StreamMetricsTotalValue
}

// Number of streams, grouped by status
func (s *ClusterHealthStatsImpl) SetStreamMetricsTotal(v ClusterHealthMetricsTotal) ClusterHealthStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ClusterHealthMetricsTotalImpl); ok {
		s.StreamMetricsTotalValue = impl
	}
	return s
}

// Cluster total bitrate metrics
func (s ClusterHealthStatsImpl) StreamerBitrateMetricsTotal() ClusterHealthStatsStreamerBitrateMetricsTotal {
	return s.StreamerBitrateMetricsTotalValue
}

// Cluster total bitrate metrics
func (s *ClusterHealthStatsImpl) SetStreamerBitrateMetricsTotal(v ClusterHealthStatsStreamerBitrateMetricsTotal) ClusterHealthStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ClusterHealthStatsStreamerBitrateMetricsTotalImpl); ok {
		s.StreamerBitrateMetricsTotalValue = impl
	}
	return s
}

// Streamer stats
func (s ClusterHealthStatsImpl) StreamerMetrics() []ClusterHealthStreamerStats {
	if s.StreamerMetricsValue == nil {
		return nil
	}
	result := make([]ClusterHealthStreamerStats, len(s.StreamerMetricsValue))
	for i, item := range s.StreamerMetricsValue {
		result[i] = item
	}
	return result
}

// Streamer stats
func (s *ClusterHealthStatsImpl) SetStreamerMetrics(v []ClusterHealthStreamerStats) ClusterHealthStats {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*ClusterHealthStreamerStatsImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*ClusterHealthStreamerStatsImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.StreamerMetricsValue = impl
	}
	return s
}

// Number of streamers, grouped by status
func (s ClusterHealthStatsImpl) StreamerMetricsTotal() ClusterHealthMetricsTotal {
	return s.StreamerMetricsTotalValue
}

// Number of streamers, grouped by status
func (s *ClusterHealthStatsImpl) SetStreamerMetricsTotal(v ClusterHealthMetricsTotal) ClusterHealthStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ClusterHealthMetricsTotalImpl); ok {
		s.StreamerMetricsTotalValue = impl
	}
	return s
}

// The running version of instance in format TAGCNUM. TAG is a five-digit number that contains the year number, month number, and version number. CNUM is a four-digit number that indicates the commit number. Number 240100023 represents version 24.01-23.
// Example: 2.40100023e+08
func (s ClusterHealthStatsImpl) Version() *int {
	return s.VersionValue
}

// The running version of instance in format TAGCNUM. TAG is a five-digit number that contains the year number, month number, and version number. CNUM is a four-digit number that indicates the commit number. Number 240100023 represents version 24.01-23.
// Example: 2.40100023e+08
func (s *ClusterHealthStatsImpl) SetVersion(v int) ClusterHealthStats {
	if s == nil {
		return nil
	}
	s.VersionValue = &v
	return s
}

// NewClusterHealthStatsStreamerBitrateMetricsTotal creates a new ClusterHealthStatsStreamerBitrateMetricsTotal instance
func NewClusterHealthStatsStreamerBitrateMetricsTotal() ClusterHealthStatsStreamerBitrateMetricsTotal {
	return &ClusterHealthStatsStreamerBitrateMetricsTotalImpl{}
}

// Current incoming speed (bitrate) of the data transmission over the network of all streamers.
// Format: speed (speed)
func (s ClusterHealthStatsStreamerBitrateMetricsTotalImpl) InputKbit() *Speed {
	return s.InputKbitValue
}

// Current incoming speed (bitrate) of the data transmission over the network of all streamers.
// Format: speed (speed)
func (s *ClusterHealthStatsStreamerBitrateMetricsTotalImpl) SetInputKbit(v Speed) ClusterHealthStatsStreamerBitrateMetricsTotal {
	if s == nil {
		return nil
	}
	s.InputKbitValue = &v
	return s
}

// Current outgoing speed (bitrate) of the data transmission over the network of all streamers.
// Format: speed (speed)
func (s ClusterHealthStatsStreamerBitrateMetricsTotalImpl) OutputKbit() *Speed {
	return s.OutputKbitValue
}

// Current outgoing speed (bitrate) of the data transmission over the network of all streamers.
// Format: speed (speed)
func (s *ClusterHealthStatsStreamerBitrateMetricsTotalImpl) SetOutputKbit(v Speed) ClusterHealthStatsStreamerBitrateMetricsTotal {
	if s == nil {
		return nil
	}
	s.OutputKbitValue = &v
	return s
}

// NewClusterHealthStreamerStats creates a new ClusterHealthStreamerStats instance
func NewClusterHealthStreamerStats() ClusterHealthStreamerStats {
	return &ClusterHealthStreamerStatsImpl{}
}

// Streamer agents info.
func (s ClusterHealthStreamerStatsImpl) AgentMetrics() ClusterHealthStreamerStatsAgentMetrics {
	return s.AgentMetricsValue
}

// Streamer agents info.
func (s *ClusterHealthStreamerStatsImpl) SetAgentMetrics(v ClusterHealthStreamerStatsAgentMetrics) ClusterHealthStreamerStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ClusterHealthStreamerStatsAgentMetricsImpl); ok {
		s.AgentMetricsValue = impl
	}
	return s
}

// Streamer config info.
func (s ClusterHealthStreamerStatsImpl) Config() ClusterHealthStreamerStatsConfig {
	return s.ConfigValue
}

// Streamer config info.
func (s *ClusterHealthStreamerStatsImpl) SetConfig(v ClusterHealthStreamerStatsConfig) ClusterHealthStreamerStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ClusterHealthStreamerStatsConfigImpl); ok {
		s.ConfigValue = impl
	}
	return s
}

// CPU usage info.
func (s ClusterHealthStreamerStatsImpl) Cpu() ClusterHealthStreamerStatsCpu {
	return s.CpuValue
}

// CPU usage info.
func (s *ClusterHealthStreamerStatsImpl) SetCpu(v ClusterHealthStreamerStatsCpu) ClusterHealthStreamerStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ClusterHealthStreamerStatsCpuImpl); ok {
		s.CpuValue = impl
	}
	return s
}

// Hostname of streamer.
// Format: server_name (server_name)
func (s ClusterHealthStreamerStatsImpl) Hostname() ServerName {
	return s.HostnameValue
}

// Hostname of streamer.
// Format: server_name (server_name)
func (s *ClusterHealthStreamerStatsImpl) SetHostname(v ServerName) ClusterHealthStreamerStats {
	if s == nil {
		return nil
	}
	s.HostnameValue = v
	return s
}

// Memory usage info.
func (s ClusterHealthStreamerStatsImpl) Memory() ClusterHealthStreamerStatsMemory {
	return s.MemoryValue
}

// Memory usage info.
func (s *ClusterHealthStreamerStatsImpl) SetMemory(v ClusterHealthStreamerStatsMemory) ClusterHealthStreamerStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ClusterHealthStreamerStatsMemoryImpl); ok {
		s.MemoryValue = impl
	}
	return s
}

// Network IO info.
func (s ClusterHealthStreamerStatsImpl) Network() ClusterHealthStreamerStatsNetwork {
	return s.NetworkValue
}

// Network IO info.
func (s *ClusterHealthStreamerStatsImpl) SetNetwork(v ClusterHealthStreamerStatsNetwork) ClusterHealthStreamerStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ClusterHealthStreamerStatsNetworkImpl); ok {
		s.NetworkValue = impl
	}
	return s
}

func (s ClusterHealthStreamerStatsImpl) Status() *ClusterHealthStatus {
	return s.StatusValue
}

func (s *ClusterHealthStreamerStatsImpl) SetStatus(v ClusterHealthStatus) ClusterHealthStreamerStats {
	if s == nil {
		return nil
	}
	s.StatusValue = &v
	return s
}

// Total disk usage info.
func (s ClusterHealthStreamerStatsImpl) Storage() ClusterHealthStreamerStatsStorage {
	return s.StorageValue
}

// Total disk usage info.
func (s *ClusterHealthStreamerStatsImpl) SetStorage(v ClusterHealthStreamerStatsStorage) ClusterHealthStreamerStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ClusterHealthStreamerStatsStorageImpl); ok {
		s.StorageValue = impl
	}
	return s
}

// Streamer streams info.
func (s ClusterHealthStreamerStatsImpl) StreamMetrics() ClusterHealthStreamerStatsStreamMetrics {
	return s.StreamMetricsValue
}

// Streamer streams info.
func (s *ClusterHealthStreamerStatsImpl) SetStreamMetrics(v ClusterHealthStreamerStatsStreamMetrics) ClusterHealthStreamerStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ClusterHealthStreamerStatsStreamMetricsImpl); ok {
		s.StreamMetricsValue = impl
	}
	return s
}

// The server uptime.
// Format: seconds (seconds)
// Example: 4.325502e+06
func (s ClusterHealthStreamerStatsImpl) Uptime() *Seconds {
	return s.UptimeValue
}

// The server uptime.
// Format: seconds (seconds)
// Example: 4.325502e+06
func (s *ClusterHealthStreamerStatsImpl) SetUptime(v Seconds) ClusterHealthStreamerStats {
	if s == nil {
		return nil
	}
	s.UptimeValue = &v
	return s
}

// NewClusterHealthStreamerStatsAgentMetrics creates a new ClusterHealthStreamerStatsAgentMetrics instance
func NewClusterHealthStreamerStatsAgentMetrics() ClusterHealthStreamerStatsAgentMetrics {
	return &ClusterHealthStreamerStatsAgentMetricsImpl{}
}

// Number of degraded entities
func (s ClusterHealthStreamerStatsAgentMetricsImpl) Degradated() *int {
	return s.DegradatedValue
}

// Number of degraded entities
func (s *ClusterHealthStreamerStatsAgentMetricsImpl) SetDegradated(v int) ClusterHealthStreamerStatsAgentMetrics {
	if s == nil {
		return nil
	}
	s.DegradatedValue = &v
	return s
}

// Number of disabled entities
func (s ClusterHealthStreamerStatsAgentMetricsImpl) Disabled() *int {
	return s.DisabledValue
}

// Number of disabled entities
func (s *ClusterHealthStreamerStatsAgentMetricsImpl) SetDisabled(v int) ClusterHealthStreamerStatsAgentMetrics {
	if s == nil {
		return nil
	}
	s.DisabledValue = &v
	return s
}

// Number of operational entities
func (s ClusterHealthStreamerStatsAgentMetricsImpl) Operational() *int {
	return s.OperationalValue
}

// Number of operational entities
func (s *ClusterHealthStreamerStatsAgentMetricsImpl) SetOperational(v int) ClusterHealthStreamerStatsAgentMetrics {
	if s == nil {
		return nil
	}
	s.OperationalValue = &v
	return s
}

// Number of outage entities
func (s ClusterHealthStreamerStatsAgentMetricsImpl) Outage() *int {
	return s.OutageValue
}

// Number of outage entities
func (s *ClusterHealthStreamerStatsAgentMetricsImpl) SetOutage(v int) ClusterHealthStreamerStatsAgentMetrics {
	if s == nil {
		return nil
	}
	s.OutageValue = &v
	return s
}

// Number of partial outage entities
func (s ClusterHealthStreamerStatsAgentMetricsImpl) PartialOutage() *int {
	return s.PartialOutageValue
}

// Number of partial outage entities
func (s *ClusterHealthStreamerStatsAgentMetricsImpl) SetPartialOutage(v int) ClusterHealthStreamerStatsAgentMetrics {
	if s == nil {
		return nil
	}
	s.PartialOutageValue = &v
	return s
}

func (s ClusterHealthStreamerStatsAgentMetricsImpl) Status() *ClusterHealthStatus {
	return s.StatusValue
}

func (s *ClusterHealthStreamerStatsAgentMetricsImpl) SetStatus(v ClusterHealthStatus) ClusterHealthStreamerStatsAgentMetrics {
	if s == nil {
		return nil
	}
	s.StatusValue = &v
	return s
}

// Total number of entities
func (s ClusterHealthStreamerStatsAgentMetricsImpl) Total() *int {
	return s.TotalValue
}

// Total number of entities
func (s *ClusterHealthStreamerStatsAgentMetricsImpl) SetTotal(v int) ClusterHealthStreamerStatsAgentMetrics {
	if s == nil {
		return nil
	}
	s.TotalValue = &v
	return s
}

// NewClusterHealthStreamerStatsConfig creates a new ClusterHealthStreamerStatsConfig instance
func NewClusterHealthStreamerStatsConfig() ClusterHealthStreamerStatsConfig {
	return &ClusterHealthStreamerStatsConfigImpl{}
}

func (s ClusterHealthStreamerStatsConfigImpl) Status() *ClusterHealthStatus {
	return s.StatusValue
}

func (s *ClusterHealthStreamerStatsConfigImpl) SetStatus(v ClusterHealthStatus) ClusterHealthStreamerStatsConfig {
	if s == nil {
		return nil
	}
	s.StatusValue = &v
	return s
}

// NewClusterHealthStreamerStatsCpu creates a new ClusterHealthStreamerStatsCpu instance
func NewClusterHealthStreamerStatsCpu() ClusterHealthStreamerStatsCpu {
	return &ClusterHealthStreamerStatsCpuImpl{}
}

func (s ClusterHealthStreamerStatsCpuImpl) Status() *ClusterHealthStatus {
	return s.StatusValue
}

func (s *ClusterHealthStreamerStatsCpuImpl) SetStatus(v ClusterHealthStatus) ClusterHealthStreamerStatsCpu {
	if s == nil {
		return nil
	}
	s.StatusValue = &v
	return s
}

// CPU usage on the server.
// Format: percent (percent)
// Example: 48
func (s ClusterHealthStreamerStatsCpuImpl) Usage() *Percent {
	return s.UsageValue
}

// CPU usage on the server.
// Format: percent (percent)
// Example: 48
func (s *ClusterHealthStreamerStatsCpuImpl) SetUsage(v Percent) ClusterHealthStreamerStatsCpu {
	if s == nil {
		return nil
	}
	s.UsageValue = &v
	return s
}

// NewClusterHealthStreamerStatsMemory creates a new ClusterHealthStreamerStatsMemory instance
func NewClusterHealthStreamerStatsMemory() ClusterHealthStreamerStatsMemory {
	return &ClusterHealthStreamerStatsMemoryImpl{}
}

func (s ClusterHealthStreamerStatsMemoryImpl) Status() *ClusterHealthStatus {
	return s.StatusValue
}

func (s *ClusterHealthStreamerStatsMemoryImpl) SetStatus(v ClusterHealthStatus) ClusterHealthStreamerStatsMemory {
	if s == nil {
		return nil
	}
	s.StatusValue = &v
	return s
}

// Memory usage on the server.
// Format: percent (percent)
// Example: 27
func (s ClusterHealthStreamerStatsMemoryImpl) Usage() *Percent {
	return s.UsageValue
}

// Memory usage on the server.
// Format: percent (percent)
// Example: 27
func (s *ClusterHealthStreamerStatsMemoryImpl) SetUsage(v Percent) ClusterHealthStreamerStatsMemory {
	if s == nil {
		return nil
	}
	s.UsageValue = &v
	return s
}

// NewClusterHealthStreamerStatsNetwork creates a new ClusterHealthStreamerStatsNetwork instance
func NewClusterHealthStreamerStatsNetwork() ClusterHealthStreamerStatsNetwork {
	return &ClusterHealthStreamerStatsNetworkImpl{}
}

// Inbound network info on the server.
func (s ClusterHealthStreamerStatsNetworkImpl) InKbit() ClusterHealthStreamerStatsNetworkInKbit {
	return s.InKbitValue
}

// Inbound network info on the server.
func (s *ClusterHealthStreamerStatsNetworkImpl) SetInKbit(v ClusterHealthStreamerStatsNetworkInKbit) ClusterHealthStreamerStatsNetwork {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ClusterHealthStreamerStatsNetworkInKbitImpl); ok {
		s.InKbitValue = impl
	}
	return s
}

// Outbound network info on the server.
func (s ClusterHealthStreamerStatsNetworkImpl) OutKbit() ClusterHealthStreamerStatsNetworkOutKbit {
	return s.OutKbitValue
}

// Outbound network info on the server.
func (s *ClusterHealthStreamerStatsNetworkImpl) SetOutKbit(v ClusterHealthStreamerStatsNetworkOutKbit) ClusterHealthStreamerStatsNetwork {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ClusterHealthStreamerStatsNetworkOutKbitImpl); ok {
		s.OutKbitValue = impl
	}
	return s
}

// NewClusterHealthStreamerStatsNetworkInKbit creates a new ClusterHealthStreamerStatsNetworkInKbit instance
func NewClusterHealthStreamerStatsNetworkInKbit() ClusterHealthStreamerStatsNetworkInKbit {
	return &ClusterHealthStreamerStatsNetworkInKbitImpl{}
}

func (s ClusterHealthStreamerStatsNetworkInKbitImpl) Status() *ClusterHealthStatus {
	return s.StatusValue
}

func (s *ClusterHealthStreamerStatsNetworkInKbitImpl) SetStatus(v ClusterHealthStatus) ClusterHealthStreamerStatsNetworkInKbit {
	if s == nil {
		return nil
	}
	s.StatusValue = &v
	return s
}

// Inbound network usage on the server.
// Format: speed (speed)
func (s ClusterHealthStreamerStatsNetworkInKbitImpl) Usage() *Speed {
	return s.UsageValue
}

// Inbound network usage on the server.
// Format: speed (speed)
func (s *ClusterHealthStreamerStatsNetworkInKbitImpl) SetUsage(v Speed) ClusterHealthStreamerStatsNetworkInKbit {
	if s == nil {
		return nil
	}
	s.UsageValue = &v
	return s
}

// NewClusterHealthStreamerStatsNetworkOutKbit creates a new ClusterHealthStreamerStatsNetworkOutKbit instance
func NewClusterHealthStreamerStatsNetworkOutKbit() ClusterHealthStreamerStatsNetworkOutKbit {
	return &ClusterHealthStreamerStatsNetworkOutKbitImpl{}
}

func (s ClusterHealthStreamerStatsNetworkOutKbitImpl) Status() *ClusterHealthStatus {
	return s.StatusValue
}

func (s *ClusterHealthStreamerStatsNetworkOutKbitImpl) SetStatus(v ClusterHealthStatus) ClusterHealthStreamerStatsNetworkOutKbit {
	if s == nil {
		return nil
	}
	s.StatusValue = &v
	return s
}

// Outbound network usage on the server.
// Format: speed (speed)
func (s ClusterHealthStreamerStatsNetworkOutKbitImpl) Usage() *Speed {
	return s.UsageValue
}

// Outbound network usage on the server.
// Format: speed (speed)
func (s *ClusterHealthStreamerStatsNetworkOutKbitImpl) SetUsage(v Speed) ClusterHealthStreamerStatsNetworkOutKbit {
	if s == nil {
		return nil
	}
	s.UsageValue = &v
	return s
}

// NewClusterHealthStreamerStatsStorage creates a new ClusterHealthStreamerStatsStorage instance
func NewClusterHealthStreamerStatsStorage() ClusterHealthStreamerStatsStorage {
	return &ClusterHealthStreamerStatsStorageImpl{}
}

func (s ClusterHealthStreamerStatsStorageImpl) Status() *ClusterHealthStatus {
	return s.StatusValue
}

func (s *ClusterHealthStreamerStatsStorageImpl) SetStatus(v ClusterHealthStatus) ClusterHealthStreamerStatsStorage {
	if s == nil {
		return nil
	}
	s.StatusValue = &v
	return s
}

// Total disk space usage on the server.
// Format: percent (percent)
// Example: 18
func (s ClusterHealthStreamerStatsStorageImpl) Usage() *Percent {
	return s.UsageValue
}

// Total disk space usage on the server.
// Format: percent (percent)
// Example: 18
func (s *ClusterHealthStreamerStatsStorageImpl) SetUsage(v Percent) ClusterHealthStreamerStatsStorage {
	if s == nil {
		return nil
	}
	s.UsageValue = &v
	return s
}

// NewClusterHealthStreamerStatsStreamMetrics creates a new ClusterHealthStreamerStatsStreamMetrics instance
func NewClusterHealthStreamerStatsStreamMetrics() ClusterHealthStreamerStatsStreamMetrics {
	return &ClusterHealthStreamerStatsStreamMetricsImpl{}
}

// Number of degraded entities
func (s ClusterHealthStreamerStatsStreamMetricsImpl) Degradated() *int {
	return s.DegradatedValue
}

// Number of degraded entities
func (s *ClusterHealthStreamerStatsStreamMetricsImpl) SetDegradated(v int) ClusterHealthStreamerStatsStreamMetrics {
	if s == nil {
		return nil
	}
	s.DegradatedValue = &v
	return s
}

// Number of disabled entities
func (s ClusterHealthStreamerStatsStreamMetricsImpl) Disabled() *int {
	return s.DisabledValue
}

// Number of disabled entities
func (s *ClusterHealthStreamerStatsStreamMetricsImpl) SetDisabled(v int) ClusterHealthStreamerStatsStreamMetrics {
	if s == nil {
		return nil
	}
	s.DisabledValue = &v
	return s
}

// Number of operational entities
func (s ClusterHealthStreamerStatsStreamMetricsImpl) Operational() *int {
	return s.OperationalValue
}

// Number of operational entities
func (s *ClusterHealthStreamerStatsStreamMetricsImpl) SetOperational(v int) ClusterHealthStreamerStatsStreamMetrics {
	if s == nil {
		return nil
	}
	s.OperationalValue = &v
	return s
}

// Number of outage entities
func (s ClusterHealthStreamerStatsStreamMetricsImpl) Outage() *int {
	return s.OutageValue
}

// Number of outage entities
func (s *ClusterHealthStreamerStatsStreamMetricsImpl) SetOutage(v int) ClusterHealthStreamerStatsStreamMetrics {
	if s == nil {
		return nil
	}
	s.OutageValue = &v
	return s
}

// Number of partial outage entities
func (s ClusterHealthStreamerStatsStreamMetricsImpl) PartialOutage() *int {
	return s.PartialOutageValue
}

// Number of partial outage entities
func (s *ClusterHealthStreamerStatsStreamMetricsImpl) SetPartialOutage(v int) ClusterHealthStreamerStatsStreamMetrics {
	if s == nil {
		return nil
	}
	s.PartialOutageValue = &v
	return s
}

func (s ClusterHealthStreamerStatsStreamMetricsImpl) Status() *ClusterHealthStatus {
	return s.StatusValue
}

func (s *ClusterHealthStreamerStatsStreamMetricsImpl) SetStatus(v ClusterHealthStatus) ClusterHealthStreamerStatsStreamMetrics {
	if s == nil {
		return nil
	}
	s.StatusValue = &v
	return s
}

// Total number of entities
func (s ClusterHealthStreamerStatsStreamMetricsImpl) Total() *int {
	return s.TotalValue
}

// Total number of entities
func (s *ClusterHealthStreamerStatsStreamMetricsImpl) SetTotal(v int) ClusterHealthStreamerStatsStreamMetrics {
	if s == nil {
		return nil
	}
	s.TotalValue = &v
	return s
}

// NewCollectionResponse creates a new CollectionResponse instance
func NewCollectionResponse() CollectionResponse {
	return &CollectionResponseImpl{}
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s CollectionResponseImpl) EstimatedCount() *int {
	return s.EstimatedCountValue
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s *CollectionResponseImpl) SetEstimatedCount(v int) CollectionResponse {
	if s == nil {
		return nil
	}
	s.EstimatedCountValue = &v
	return s
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s CollectionResponseImpl) Next() *string {
	return s.NextValue
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s *CollectionResponseImpl) SetNext(v string) CollectionResponse {
	if s == nil {
		return nil
	}
	s.NextValue = &v
	return s
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s CollectionResponseImpl) Prev() *string {
	return s.PrevValue
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s *CollectionResponseImpl) SetPrev(v string) CollectionResponse {
	if s == nil {
		return nil
	}
	s.PrevValue = &v
	return s
}

// An object with a list of different timings measured during this API call.
func (s CollectionResponseImpl) Timing() any {
	return s.TimingValue
}

// An object with a list of different timings measured during this API call.
func (s *CollectionResponseImpl) SetTiming(v any) CollectionResponse {
	if s == nil {
		return nil
	}
	s.TimingValue = v
	return s
}

// NewConfigErrorStatus creates a new ConfigErrorStatus instance
func NewConfigErrorStatus() ConfigErrorStatus {
	return &ConfigErrorStatusImpl{}
}

// The column number pointing to where the error was detected.
// Example: 20
func (s ConfigErrorStatusImpl) Col() *int {
	return s.ColValue
}

// The column number pointing to where the error was detected.
// Example: 20
func (s *ConfigErrorStatusImpl) SetCol(v int) ConfigErrorStatus {
	if s == nil {
		return nil
	}
	s.ColValue = &v
	return s
}

// Partial configuration that can be recovered if an error occurs.
func (s ConfigErrorStatusImpl) Config() any {
	return s.ConfigValue
}

// Partial configuration that can be recovered if an error occurs.
func (s *ConfigErrorStatusImpl) SetConfig(v any) ConfigErrorStatus {
	if s == nil {
		return nil
	}
	s.ConfigValue = v
	return s
}

// Some other details that may help to identify the error.
func (s ConfigErrorStatusImpl) Detail() any {
	return s.DetailValue
}

// Some other details that may help to identify the error.
func (s *ConfigErrorStatusImpl) SetDetail(v any) ConfigErrorStatus {
	if s == nil {
		return nil
	}
	s.DetailValue = v
	return s
}

// Short error description.
// Example: bad_url
func (s ConfigErrorStatusImpl) Error() *string {
	return s.ErrorValue
}

// Short error description.
// Example: bad_url
func (s *ConfigErrorStatusImpl) SetError(v string) ConfigErrorStatus {
	if s == nil {
		return nil
	}
	s.ErrorValue = &v
	return s
}

// Last column with something valid.
// Example: 5
func (s ConfigErrorStatusImpl) FirstErrorCol() *int {
	return s.FirstErrorColValue
}

// Last column with something valid.
// Example: 5
func (s *ConfigErrorStatusImpl) SetFirstErrorCol(v int) ConfigErrorStatus {
	if s == nil {
		return nil
	}
	s.FirstErrorColValue = &v
	return s
}

// If an error takes up to several lines, it is the first line where the error was detected.
// Example: 14
func (s ConfigErrorStatusImpl) FirstErrorLine() *int {
	return s.FirstErrorLineValue
}

// If an error takes up to several lines, it is the first line where the error was detected.
// Example: 14
func (s *ConfigErrorStatusImpl) SetFirstErrorLine(v int) ConfigErrorStatus {
	if s == nil {
		return nil
	}
	s.FirstErrorLineValue = &v
	return s
}

// Line number pointing to where an error was detected.
// Example: 15
func (s ConfigErrorStatusImpl) Line() *int {
	return s.LineValue
}

// Line number pointing to where an error was detected.
// Example: 15
func (s *ConfigErrorStatusImpl) SetLine(v int) ConfigErrorStatus {
	if s == nil {
		return nil
	}
	s.LineValue = &v
	return s
}

// Config path to the erroneous element.
// Example: [streams 0 inputs 0 url input_url]
func (s ConfigErrorStatusImpl) Path() []ConfigPathSegment {
	return s.PathValue
}

// Config path to the erroneous element.
// Example: [streams 0 inputs 0 url input_url]
func (s *ConfigErrorStatusImpl) SetPath(v []ConfigPathSegment) ConfigErrorStatus {
	if s == nil {
		return nil
	}
	s.PathValue = v
	return s
}

// NewConfigExternalErrorStatus creates a new ConfigExternalErrorStatus instance
func NewConfigExternalErrorStatus() ConfigExternalErrorStatus {
	return &ConfigExternalErrorStatusImpl{}
}

// HTTP response code
func (s ConfigExternalErrorStatusImpl) Code() *int {
	return s.CodeValue
}

// HTTP response code
func (s *ConfigExternalErrorStatusImpl) SetCode(v int) ConfigExternalErrorStatus {
	if s == nil {
		return nil
	}
	s.CodeValue = &v
	return s
}

// Detailed error description (optional)
func (s ConfigExternalErrorStatusImpl) Detail() *string {
	return s.DetailValue
}

// Detailed error description (optional)
func (s *ConfigExternalErrorStatusImpl) SetDetail(v string) ConfigExternalErrorStatus {
	if s == nil {
		return nil
	}
	s.DetailValue = &v
	return s
}

// Error description (optional)
// Example: invalid_authorization
func (s ConfigExternalErrorStatusImpl) Error() *string {
	return s.ErrorValue
}

// Error description (optional)
// Example: invalid_authorization
func (s *ConfigExternalErrorStatusImpl) SetError(v string) ConfigExternalErrorStatus {
	if s == nil {
		return nil
	}
	s.ErrorValue = &v
	return s
}

// Config path to the erroneous element.
// Example: [streams 0 inputs 0 url input_url]
func (s ConfigExternalErrorStatusImpl) Path() []ConfigPathSegment {
	return s.PathValue
}

// Config path to the erroneous element.
// Example: [streams 0 inputs 0 url input_url]
func (s *ConfigExternalErrorStatusImpl) SetPath(v []ConfigPathSegment) ConfigExternalErrorStatus {
	if s == nil {
		return nil
	}
	s.PathValue = v
	return s
}

func (s ConfigExternalErrorStatusImpl) Reason() *RequestErrorReason {
	return s.ReasonValue
}

func (s *ConfigExternalErrorStatusImpl) SetReason(v RequestErrorReason) ConfigExternalErrorStatus {
	if s == nil {
		return nil
	}
	s.ReasonValue = &v
	return s
}

// External config status
func (s ConfigExternalErrorStatusImpl) Status() *ConfigExternalErrorStatusStatus {
	return s.StatusValue
}

// External config status
func (s *ConfigExternalErrorStatusImpl) SetStatus(v ConfigExternalErrorStatusStatus) ConfigExternalErrorStatus {
	if s == nil {
		return nil
	}
	s.StatusValue = &v
	return s
}

// Conditions of the error occurrence.
func (s ConfigExternalErrorStatusImpl) While() *ConfigExternalErrorStatusWhile {
	return s.WhileValue
}

// Conditions of the error occurrence.
func (s *ConfigExternalErrorStatusImpl) SetWhile(v ConfigExternalErrorStatusWhile) ConfigExternalErrorStatus {
	if s == nil {
		return nil
	}
	s.WhileValue = &v
	return s
}

// NewDatabaseError creates a new DatabaseError instance
func NewDatabaseError() DatabaseError {
	return &DatabaseErrorImpl{}
}

// Database error.
func (s DatabaseErrorImpl) Event() string {
	return s.EventValue
}

// Database error.
func (s *DatabaseErrorImpl) SetEvent(v string) DatabaseError {
	if s == nil {
		return nil
	}
	s.EventValue = v
	return s
}

// Event identifier.
func (s DatabaseErrorImpl) EventID() *int {
	return s.EventIDValue
}

// Event identifier.
func (s *DatabaseErrorImpl) SetEventID(v int) DatabaseError {
	if s == nil {
		return nil
	}
	s.EventIDValue = &v
	return s
}

// The error message.
func (s DatabaseErrorImpl) Message() *string {
	return s.MessageValue
}

// The error message.
func (s *DatabaseErrorImpl) SetMessage(v string) DatabaseError {
	if s == nil {
		return nil
	}
	s.MessageValue = &v
	return s
}

// The query that caused the error.
func (s DatabaseErrorImpl) Query() *string {
	return s.QueryValue
}

// The query that caused the error.
func (s *DatabaseErrorImpl) SetQuery(v string) DatabaseError {
	if s == nil {
		return nil
	}
	s.QueryValue = &v
	return s
}

// Originator of event.
// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
// is configured as HTTP/HTTPS url.
// Example: flussonic.host
func (s DatabaseErrorImpl) Server() *string {
	return s.ServerValue
}

// Originator of event.
// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
// is configured as HTTP/HTTPS url.
// Example: flussonic.host
func (s *DatabaseErrorImpl) SetServer(v string) DatabaseError {
	if s == nil {
		return nil
	}
	s.ServerValue = &v
	return s
}

// Unique identifier of the operation.
// You can use this field to search for events related to same operation.
// Value of this field is taken from the `X-Trace-Id` header.
// If `X-Trace-Id` header is not set, it will be generated automatically.
// Service will use the value of this field to make outgoing requests.
// Format: uuid (uuid)
// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
func (s DatabaseErrorImpl) TraceID() *UUID {
	return s.TraceIDValue
}

// Unique identifier of the operation.
// You can use this field to search for events related to same operation.
// Value of this field is taken from the `X-Trace-Id` header.
// If `X-Trace-Id` header is not set, it will be generated automatically.
// Service will use the value of this field to make outgoing requests.
// Format: uuid (uuid)
// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
func (s *DatabaseErrorImpl) SetTraceID(v UUID) DatabaseError {
	if s == nil {
		return nil
	}
	s.TraceIDValue = &v
	return s
}

// The time of the event registration on the server.
// Format: utc_ms (Unix timestamp in milliseconds)
func (s DatabaseErrorImpl) UtcMs() *UtcMs {
	return s.UtcMsValue
}

// The time of the event registration on the server.
// Format: utc_ms (Unix timestamp in milliseconds)
func (s *DatabaseErrorImpl) SetUtcMs(v UtcMs) DatabaseError {
	if s == nil {
		return nil
	}
	s.UtcMsValue = &v
	return s
}

// NewDrmBase creates a new DrmBase instance
func NewDrmBase() DrmBase {
	return &DrmBaseImpl{}
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s DrmBaseImpl) Encryption() *string {
	return s.EncryptionValue
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s *DrmBaseImpl) SetEncryption(v string) DrmBase {
	if s == nil {
		return nil
	}
	s.EncryptionValue = &v
	return s
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s DrmBaseImpl) Expires() *int {
	return s.ExpiresValue
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s *DrmBaseImpl) SetExpires(v int) DrmBase {
	if s == nil {
		return nil
	}
	s.ExpiresValue = &v
	return s
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s DrmBaseImpl) Keyserver() *string {
	return s.KeyserverValue
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s *DrmBaseImpl) SetKeyserver(v string) DrmBase {
	if s == nil {
		return nil
	}
	s.KeyserverValue = &v
	return s
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s DrmBaseImpl) ResourceID() *DrmResourceID {
	return s.ResourceIDValue
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s *DrmBaseImpl) SetResourceID(v DrmResourceID) DrmBase {
	if s == nil {
		return nil
	}
	s.ResourceIDValue = &v
	return s
}

// NewDrmCpixBase creates a new DrmCpixBase instance
func NewDrmCpixBase() DrmCpixBase {
	return &DrmCpixBaseImpl{}
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s DrmCpixBaseImpl) Encryption() *string {
	return s.EncryptionValue
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s *DrmCpixBaseImpl) SetEncryption(v string) DrmCpixBase {
	if s == nil {
		return nil
	}
	s.EncryptionValue = &v
	return s
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s DrmCpixBaseImpl) Expires() *int {
	return s.ExpiresValue
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s *DrmCpixBaseImpl) SetExpires(v int) DrmCpixBase {
	if s == nil {
		return nil
	}
	s.ExpiresValue = &v
	return s
}

// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
// It is employed only one time in any session.
// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
// Usually, IV is received from a DRM provider.
func (s DrmCpixBaseImpl) Iv() *string {
	return s.IvValue
}

// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
// It is employed only one time in any session.
// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
// Usually, IV is received from a DRM provider.
func (s *DrmCpixBaseImpl) SetIv(v string) DrmCpixBase {
	if s == nil {
		return nil
	}
	s.IvValue = &v
	return s
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s DrmCpixBaseImpl) Keyserver() *string {
	return s.KeyserverValue
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s *DrmCpixBaseImpl) SetKeyserver(v string) DrmCpixBase {
	if s == nil {
		return nil
	}
	s.KeyserverValue = &v
	return s
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s DrmCpixBaseImpl) ResourceID() *DrmResourceID {
	return s.ResourceIDValue
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s *DrmCpixBaseImpl) SetResourceID(v DrmResourceID) DrmCpixBase {
	if s == nil {
		return nil
	}
	s.ResourceIDValue = &v
	return s
}

// This parameter is used to specify applicable DRM systems.
// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
func (s DrmCpixBaseImpl) Systems() []DrmSystem {
	return s.SystemsValue
}

// This parameter is used to specify applicable DRM systems.
// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
func (s *DrmCpixBaseImpl) SetSystems(v []DrmSystem) DrmCpixBase {
	if s == nil {
		return nil
	}
	s.SystemsValue = v
	return s
}

// NewDrmEncKey creates a new DrmEncKey instance
func NewDrmEncKey() DrmEncKey {
	return &DrmEncKeyImpl{}
}

// Encryption Key in hex or file. Length must be 128 bit.
// Example: 0x76359e1212952a6db42b41eeb94ceb29
func (s DrmEncKeyImpl) Key() *string {
	return s.KeyValue
}

// Encryption Key in hex or file. Length must be 128 bit.
// Example: 0x76359e1212952a6db42b41eeb94ceb29
func (s *DrmEncKeyImpl) SetKey(v string) DrmEncKey {
	if s == nil {
		return nil
	}
	s.KeyValue = &v
	return s
}

// NewDrmEncKeyURL creates a new DrmEncKeyURL instance
func NewDrmEncKeyURL() DrmEncKeyURL {
	return &DrmEncKeyURLImpl{}
}

// Http link which specifies how to obtain the key. It is URI attribute of HLS manifest EXT-X-KEY method.
func (s DrmEncKeyURLImpl) URL() *string {
	return s.URLValue
}

// Http link which specifies how to obtain the key. It is URI attribute of HLS manifest EXT-X-KEY method.
func (s *DrmEncKeyURLImpl) SetURL(v string) DrmEncKeyURL {
	if s == nil {
		return nil
	}
	s.URLValue = &v
	return s
}

// NewDrmIv creates a new DrmIv instance
func NewDrmIv() DrmIv {
	return &DrmIvImpl{}
}

// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
// It is employed only one time in any session.
// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
// Usually, IV is received from a DRM provider.
func (s DrmIvImpl) Iv() *string {
	return s.IvValue
}

// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
// It is employed only one time in any session.
// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
// Usually, IV is received from a DRM provider.
func (s *DrmIvImpl) SetIv(v string) DrmIv {
	if s == nil {
		return nil
	}
	s.IvValue = &v
	return s
}

// NewDrmKeyosBase creates a new DrmKeyosBase instance
func NewDrmKeyosBase() DrmKeyosBase {
	return &DrmKeyosBaseImpl{}
}

// A unique identifier of the content, used for Widevine DRM.
// By default, it is equal to the stream name.
func (s DrmKeyosBaseImpl) ContentID() *string {
	return s.ContentIDValue
}

// A unique identifier of the content, used for Widevine DRM.
// By default, it is equal to the stream name.
func (s *DrmKeyosBaseImpl) SetContentID(v string) DrmKeyosBase {
	if s == nil {
		return nil
	}
	s.ContentIDValue = &v
	return s
}

// Path to end user certificate file.
func (s DrmKeyosBaseImpl) EndUserCert() *string {
	return s.EndUserCertValue
}

// Path to end user certificate file.
func (s *DrmKeyosBaseImpl) SetEndUserCert(v string) DrmKeyosBase {
	if s == nil {
		return nil
	}
	s.EndUserCertValue = &v
	return s
}

// Path to end user private key file
func (s DrmKeyosBaseImpl) EndUserPrivateKey() *string {
	return s.EndUserPrivateKeyValue
}

// Path to end user private key file
func (s *DrmKeyosBaseImpl) SetEndUserPrivateKey(v string) DrmKeyosBase {
	if s == nil {
		return nil
	}
	s.EndUserPrivateKeyValue = &v
	return s
}

// Deprecated field. Will be deleted at 25.04
// A unique identifier of the user
func (s DrmKeyosBaseImpl) Userkey() *string {
	return s.UserkeyValue
}

// Deprecated field. Will be deleted at 25.04
// A unique identifier of the user
func (s *DrmKeyosBaseImpl) SetUserkey(v string) DrmKeyosBase {
	if s == nil {
		return nil
	}
	s.UserkeyValue = &v
	return s
}

// NewDrmSpec creates a new DrmSpec instance
func NewDrmSpec() DrmSpec {
	return &DrmSpecImpl{}
}

// ID of the Irdeto DRM account.
func (s DrmSpecImpl) AccountID() *string {
	return s.AccountIDValue
}

// ID of the Irdeto DRM account.
func (s *DrmSpecImpl) SetAccountID(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.AccountIDValue = &v
	return s
}

// AES (Advanced Encryption Standard) key. Used for Widevine DRM.
func (s DrmSpecImpl) AesKey() *string {
	return s.AesKeyValue
}

// AES (Advanced Encryption Standard) key. Used for Widevine DRM.
func (s *DrmSpecImpl) SetAesKey(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.AesKeyValue = &v
	return s
}

// Authentication server for DRMtoday.
// Example: https://auth.drmtoday.com
func (s DrmSpecImpl) AuthServer() *string {
	return s.AuthServerValue
}

// Authentication server for DRMtoday.
// Example: https://auth.drmtoday.com
func (s *DrmSpecImpl) SetAuthServer(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.AuthServerValue = &v
	return s
}

// A unique identifier of the content, used for Widevine DRM.
// By default, it is equal to the stream name.
func (s DrmSpecImpl) ContentID() *string {
	return s.ContentIDValue
}

// A unique identifier of the content, used for Widevine DRM.
// By default, it is equal to the stream name.
func (s *DrmSpecImpl) SetContentID(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.ContentIDValue = &v
	return s
}

// The uuid of the CPIX/SPEKE ingest configuration
func (s DrmSpecImpl) CpixConfigID() *string {
	return s.CpixConfigIDValue
}

// The uuid of the CPIX/SPEKE ingest configuration
func (s *DrmSpecImpl) SetCpixConfigID(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.CpixConfigIDValue = &v
	return s
}

// An API authentication token that is generated when you sign up for the PallyCon service at https://login.pallycon.com/.
func (s DrmSpecImpl) EncToken() *string {
	return s.EncTokenValue
}

// An API authentication token that is generated when you sign up for the PallyCon service at https://login.pallycon.com/.
func (s *DrmSpecImpl) SetEncToken(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.EncTokenValue = &v
	return s
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s DrmSpecImpl) Encryption() *string {
	return s.EncryptionValue
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s *DrmSpecImpl) SetEncryption(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.EncryptionValue = &v
	return s
}

// Path to end user certificate file.
func (s DrmSpecImpl) EndUserCert() *string {
	return s.EndUserCertValue
}

// Path to end user certificate file.
func (s *DrmSpecImpl) SetEndUserCert(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.EndUserCertValue = &v
	return s
}

// Path to end user private key file
func (s DrmSpecImpl) EndUserPrivateKey() *string {
	return s.EndUserPrivateKeyValue
}

// Path to end user private key file
func (s *DrmSpecImpl) SetEndUserPrivateKey(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.EndUserPrivateKeyValue = &v
	return s
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s DrmSpecImpl) Expires() *int {
	return s.ExpiresValue
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s *DrmSpecImpl) SetExpires(v int) DrmSpec {
	if s == nil {
		return nil
	}
	s.ExpiresValue = &v
	return s
}

// Whether to use FairPlay system for key generation.
// If set to `false`, the requests for FairPlay encryption key are disabled.
func (s DrmSpecImpl) Fp() *string {
	return s.FpValue
}

// Whether to use FairPlay system for key generation.
// If set to `false`, the requests for FairPlay encryption key are disabled.
func (s *DrmSpecImpl) SetFp(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.FpValue = &v
	return s
}

// This parameter is used for encryption of HLS streams.
// For successful playback of an AES128 encrypted HLS streams on some modern devices (running on Tizen 5),
// set this pareameter to `false`.
func (s DrmSpecImpl) HlsExtXKeyIv() *bool {
	return s.HlsExtXKeyIvValue
}

// This parameter is used for encryption of HLS streams.
// For successful playback of an AES128 encrypted HLS streams on some modern devices (running on Tizen 5),
// set this pareameter to `false`.
func (s *DrmSpecImpl) SetHlsExtXKeyIv(v bool) DrmSpec {
	if s == nil {
		return nil
	}
	s.HlsExtXKeyIvValue = &v
	return s
}

// A hostname of Irdeto DRM key server.
func (s DrmSpecImpl) IcHost() *string {
	return s.IcHostValue
}

// A hostname of Irdeto DRM key server.
func (s *DrmSpecImpl) SetIcHost(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.IcHostValue = &v
	return s
}

// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
// It is employed only one time in any session.
// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
// Usually, IV is received from a DRM provider.
func (s DrmSpecImpl) Iv() *string {
	return s.IvValue
}

// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
// It is employed only one time in any session.
// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
// Usually, IV is received from a DRM provider.
func (s *DrmSpecImpl) SetIv(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.IvValue = &v
	return s
}

// Encryption Key in hex or file. Length must be 128 bit.
// Example: 0x76359e1212952a6db42b41eeb94ceb29
func (s DrmSpecImpl) Key() *string {
	return s.KeyValue
}

// Encryption Key in hex or file. Length must be 128 bit.
// Example: 0x76359e1212952a6db42b41eeb94ceb29
func (s *DrmSpecImpl) SetKey(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.KeyValue = &v
	return s
}

// An arbitrary Base64-encoded string of 30 bytes.
// It is necessary for PlayReady to create an encryption key.
func (s DrmSpecImpl) Keyseed() *string {
	return s.KeyseedValue
}

// An arbitrary Base64-encoded string of 30 bytes.
// It is necessary for PlayReady to create an encryption key.
func (s *DrmSpecImpl) SetKeyseed(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.KeyseedValue = &v
	return s
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s DrmSpecImpl) Keyserver() *string {
	return s.KeyserverValue
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s *DrmSpecImpl) SetKeyserver(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.KeyserverValue = &v
	return s
}

// License URL, used for PlayReady DRM.
// Format: url (url)
func (s DrmSpecImpl) LaURL() *URL {
	return s.LaURLValue
}

// License URL, used for PlayReady DRM.
// Format: url (url)
func (s *DrmSpecImpl) SetLaURL(v URL) DrmSpec {
	if s == nil {
		return nil
	}
	s.LaURLValue = &v
	return s
}

// Axinom Management Key
func (s DrmSpecImpl) ManagementKey() *string {
	return s.ManagementKeyValue
}

// Axinom Management Key
func (s *DrmSpecImpl) SetManagementKey(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.ManagementKeyValue = &v
	return s
}

// The uuid of the merchant at DRMtoday.
func (s DrmSpecImpl) MerchantID() *string {
	return s.MerchantIDValue
}

// The uuid of the merchant at DRMtoday.
func (s *DrmSpecImpl) SetMerchantID(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.MerchantIDValue = &v
	return s
}

// A password for API account./A password for authorization of a user on a key server.
func (s DrmSpecImpl) Password() *string {
	return s.PasswordValue
}

// A password for API account./A password for authorization of a user on a key server.
func (s *DrmSpecImpl) SetPassword(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.PasswordValue = &v
	return s
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s DrmSpecImpl) ResourceID() *DrmResourceID {
	return s.ResourceIDValue
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s *DrmSpecImpl) SetResourceID(v DrmResourceID) DrmSpec {
	if s == nil {
		return nil
	}
	s.ResourceIDValue = &v
	return s
}

// A part of the keyserver's URL: `https://SITE.solocoo.tv/SITEadmintools/papi/SECRET/method`.
func (s DrmSpecImpl) Secret() *string {
	return s.SecretValue
}

// A part of the keyserver's URL: `https://SITE.solocoo.tv/SITEadmintools/papi/SECRET/method`.
func (s *DrmSpecImpl) SetSecret(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.SecretValue = &v
	return s
}

// A unique ID of the signer.
// Flussonic uses it to connect to the key server when using test key for Widevine DRM.
func (s DrmSpecImpl) Signer() *string {
	return s.SignerValue
}

// A unique ID of the signer.
// Flussonic uses it to connect to the key server when using test key for Widevine DRM.
func (s *DrmSpecImpl) SetSigner(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.SignerValue = &v
	return s
}

// A part of the keyserver's URL: `https://SITE.solocoo.tv/SITEadmintools/papi/SECRET/method`.
func (s DrmSpecImpl) Site() *string {
	return s.SiteValue
}

// A part of the keyserver's URL: `https://SITE.solocoo.tv/SITEadmintools/papi/SECRET/method`.
func (s *DrmSpecImpl) SetSite(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.SiteValue = &v
	return s
}

// This parameter is used to specify applicable DRM systems.
// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
func (s DrmSpecImpl) Systems() []DrmSystem {
	return s.SystemsValue
}

// This parameter is used to specify applicable DRM systems.
// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
func (s *DrmSpecImpl) SetSystems(v []DrmSystem) DrmSpec {
	if s == nil {
		return nil
	}
	s.SystemsValue = v
	return s
}

// Axinom Tenant Id
func (s DrmSpecImpl) TenantID() *string {
	return s.TenantIDValue
}

// Axinom Tenant Id
func (s *DrmSpecImpl) SetTenantID(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.TenantIDValue = &v
	return s
}

// Http link which specifies how to obtain the key. It is URI attribute of HLS manifest EXT-X-KEY method.
func (s DrmSpecImpl) URL() *string {
	return s.URLValue
}

// Http link which specifies how to obtain the key. It is URI attribute of HLS manifest EXT-X-KEY method.
func (s *DrmSpecImpl) SetURL(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.URLValue = &v
	return s
}

// A user name for authorization of a user on a key server.
func (s DrmSpecImpl) User() *string {
	return s.UserValue
}

// A user name for authorization of a user on a key server.
func (s *DrmSpecImpl) SetUser(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.UserValue = &v
	return s
}

// The URL sent to the client for watching the content.
// Example: https://public-keyserver.mycompany.com
func (s DrmSpecImpl) UserKeyserver() *string {
	return s.UserKeyserverValue
}

// The URL sent to the client for watching the content.
// Example: https://public-keyserver.mycompany.com
func (s *DrmSpecImpl) SetUserKeyserver(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.UserKeyserverValue = &v
	return s
}

// A user name of the Irdeto DRM user.
func (s DrmSpecImpl) UserName() *string {
	return s.UserNameValue
}

// A user name of the Irdeto DRM user.
func (s *DrmSpecImpl) SetUserName(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.UserNameValue = &v
	return s
}

// A custom key server path
// Example: 12345/nks/conax
func (s DrmSpecImpl) UserPath() *string {
	return s.UserPathValue
}

// A custom key server path
// Example: 12345/nks/conax
func (s *DrmSpecImpl) SetUserPath(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.UserPathValue = &v
	return s
}

// Deprecated field. Will be deleted at 25.04
// A unique identifier of the user
func (s DrmSpecImpl) Userkey() *string {
	return s.UserkeyValue
}

// Deprecated field. Will be deleted at 25.04
// A unique identifier of the user
func (s *DrmSpecImpl) SetUserkey(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.UserkeyValue = &v
	return s
}

// The login name of an API account.
func (s DrmSpecImpl) Username() *string {
	return s.UsernameValue
}

// The login name of an API account.
func (s *DrmSpecImpl) SetUsername(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.UsernameValue = &v
	return s
}

// FIXME: Aes128
// /FIXME: Axinom
// /BuyDRM
// /Clear Key is a lightweight DRM mode, where decryption keys are provided directly to the player. Its easy to
// integrate (simple JSON key/KID), requires minimal infrastructure, and can work via a license URL or with
// client-embedded keys.
// /FIXME: Conax
// /FIXME: Cpix
// /FIXME: DRMtoday
// /FIXME: Ezdrm
// /FIXME: Ezdrm classic
// /FIXME: GS DRM
// /FIXME: Irdeto
// /KeyOs
// /FIXME: Pallycon
// /FIXME: Playready
// /FIXME: Sample AES
// /Sample AES which uses KEYFORMAT=identity. It allows to encrypt and decrypt content using clear text AES key.
// The identity value for KEYFORMAT should be used only for testing.
// /FIXME: Solocoo
// /FIXME: Verimatrix
// /FIXME: Widevine
func (s DrmSpecImpl) Vendor() string {
	return s.VendorValue
}

// FIXME: Aes128
// /FIXME: Axinom
// /BuyDRM
// /Clear Key is a lightweight DRM mode, where decryption keys are provided directly to the player. Its easy to
// integrate (simple JSON key/KID), requires minimal infrastructure, and can work via a license URL or with
// client-embedded keys.
// /FIXME: Conax
// /FIXME: Cpix
// /FIXME: DRMtoday
// /FIXME: Ezdrm
// /FIXME: Ezdrm classic
// /FIXME: GS DRM
// /FIXME: Irdeto
// /KeyOs
// /FIXME: Pallycon
// /FIXME: Playready
// /FIXME: Sample AES
// /Sample AES which uses KEYFORMAT=identity. It allows to encrypt and decrypt content using clear text AES key.
// The identity value for KEYFORMAT should be used only for testing.
// /FIXME: Solocoo
// /FIXME: Verimatrix
// /FIXME: Widevine
func (s *DrmSpecImpl) SetVendor(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.VendorValue = v
	return s
}

// NewDrmSystems creates a new DrmSystems instance
func NewDrmSystems() DrmSystems {
	return &DrmSystemsImpl{}
}

// This parameter is used to specify applicable DRM systems.
// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
func (s DrmSystemsImpl) Systems() []DrmSystem {
	return s.SystemsValue
}

// This parameter is used to specify applicable DRM systems.
// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
func (s *DrmSystemsImpl) SetSystems(v []DrmSystem) DrmSystems {
	if s == nil {
		return nil
	}
	s.SystemsValue = v
	return s
}

// NewDrmVendorAes128 creates a new DrmVendorAes128 instance
func NewDrmVendorAes128() DrmVendorAes128 {
	return &DrmVendorAes128Impl{}
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s DrmVendorAes128Impl) Encryption() *string {
	return s.EncryptionValue
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s *DrmVendorAes128Impl) SetEncryption(v string) DrmVendorAes128 {
	if s == nil {
		return nil
	}
	s.EncryptionValue = &v
	return s
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s DrmVendorAes128Impl) Expires() *int {
	return s.ExpiresValue
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s *DrmVendorAes128Impl) SetExpires(v int) DrmVendorAes128 {
	if s == nil {
		return nil
	}
	s.ExpiresValue = &v
	return s
}

// This parameter is used for encryption of HLS streams.
// For successful playback of an AES128 encrypted HLS streams on some modern devices (running on Tizen 5),
// set this pareameter to `false`.
func (s DrmVendorAes128Impl) HlsExtXKeyIv() *bool {
	return s.HlsExtXKeyIvValue
}

// This parameter is used for encryption of HLS streams.
// For successful playback of an AES128 encrypted HLS streams on some modern devices (running on Tizen 5),
// set this pareameter to `false`.
func (s *DrmVendorAes128Impl) SetHlsExtXKeyIv(v bool) DrmVendorAes128 {
	if s == nil {
		return nil
	}
	s.HlsExtXKeyIvValue = &v
	return s
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s DrmVendorAes128Impl) Keyserver() *string {
	return s.KeyserverValue
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s *DrmVendorAes128Impl) SetKeyserver(v string) DrmVendorAes128 {
	if s == nil {
		return nil
	}
	s.KeyserverValue = &v
	return s
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s DrmVendorAes128Impl) ResourceID() *DrmResourceID {
	return s.ResourceIDValue
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s *DrmVendorAes128Impl) SetResourceID(v DrmResourceID) DrmVendorAes128 {
	if s == nil {
		return nil
	}
	s.ResourceIDValue = &v
	return s
}

// FIXME: Aes128
func (s DrmVendorAes128Impl) Vendor() string {
	return s.VendorValue
}

// FIXME: Aes128
func (s *DrmVendorAes128Impl) SetVendor(v string) DrmVendorAes128 {
	if s == nil {
		return nil
	}
	s.VendorValue = v
	return s
}

// NewDrmVendorAxinom creates a new DrmVendorAxinom instance
func NewDrmVendorAxinom() DrmVendorAxinom {
	return &DrmVendorAxinomImpl{}
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s DrmVendorAxinomImpl) Encryption() *string {
	return s.EncryptionValue
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s *DrmVendorAxinomImpl) SetEncryption(v string) DrmVendorAxinom {
	if s == nil {
		return nil
	}
	s.EncryptionValue = &v
	return s
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s DrmVendorAxinomImpl) Expires() *int {
	return s.ExpiresValue
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s *DrmVendorAxinomImpl) SetExpires(v int) DrmVendorAxinom {
	if s == nil {
		return nil
	}
	s.ExpiresValue = &v
	return s
}

// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
// It is employed only one time in any session.
// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
// Usually, IV is received from a DRM provider.
func (s DrmVendorAxinomImpl) Iv() *string {
	return s.IvValue
}

// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
// It is employed only one time in any session.
// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
// Usually, IV is received from a DRM provider.
func (s *DrmVendorAxinomImpl) SetIv(v string) DrmVendorAxinom {
	if s == nil {
		return nil
	}
	s.IvValue = &v
	return s
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s DrmVendorAxinomImpl) Keyserver() *string {
	return s.KeyserverValue
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s *DrmVendorAxinomImpl) SetKeyserver(v string) DrmVendorAxinom {
	if s == nil {
		return nil
	}
	s.KeyserverValue = &v
	return s
}

// Axinom Management Key
func (s DrmVendorAxinomImpl) ManagementKey() *string {
	return s.ManagementKeyValue
}

// Axinom Management Key
func (s *DrmVendorAxinomImpl) SetManagementKey(v string) DrmVendorAxinom {
	if s == nil {
		return nil
	}
	s.ManagementKeyValue = &v
	return s
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s DrmVendorAxinomImpl) ResourceID() *DrmResourceID {
	return s.ResourceIDValue
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s *DrmVendorAxinomImpl) SetResourceID(v DrmResourceID) DrmVendorAxinom {
	if s == nil {
		return nil
	}
	s.ResourceIDValue = &v
	return s
}

// This parameter is used to specify applicable DRM systems.
// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
func (s DrmVendorAxinomImpl) Systems() []DrmSystem {
	return s.SystemsValue
}

// This parameter is used to specify applicable DRM systems.
// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
func (s *DrmVendorAxinomImpl) SetSystems(v []DrmSystem) DrmVendorAxinom {
	if s == nil {
		return nil
	}
	s.SystemsValue = v
	return s
}

// Axinom Tenant Id
func (s DrmVendorAxinomImpl) TenantID() *string {
	return s.TenantIDValue
}

// Axinom Tenant Id
func (s *DrmVendorAxinomImpl) SetTenantID(v string) DrmVendorAxinom {
	if s == nil {
		return nil
	}
	s.TenantIDValue = &v
	return s
}

// FIXME: Axinom
func (s DrmVendorAxinomImpl) Vendor() string {
	return s.VendorValue
}

// FIXME: Axinom
func (s *DrmVendorAxinomImpl) SetVendor(v string) DrmVendorAxinom {
	if s == nil {
		return nil
	}
	s.VendorValue = v
	return s
}

// NewDrmVendorBuydrm creates a new DrmVendorBuydrm instance
func NewDrmVendorBuydrm() DrmVendorBuydrm {
	return &DrmVendorBuydrmImpl{}
}

// A unique identifier of the content, used for Widevine DRM.
// By default, it is equal to the stream name.
func (s DrmVendorBuydrmImpl) ContentID() *string {
	return s.ContentIDValue
}

// A unique identifier of the content, used for Widevine DRM.
// By default, it is equal to the stream name.
func (s *DrmVendorBuydrmImpl) SetContentID(v string) DrmVendorBuydrm {
	if s == nil {
		return nil
	}
	s.ContentIDValue = &v
	return s
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s DrmVendorBuydrmImpl) Encryption() *string {
	return s.EncryptionValue
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s *DrmVendorBuydrmImpl) SetEncryption(v string) DrmVendorBuydrm {
	if s == nil {
		return nil
	}
	s.EncryptionValue = &v
	return s
}

// Path to end user certificate file.
func (s DrmVendorBuydrmImpl) EndUserCert() *string {
	return s.EndUserCertValue
}

// Path to end user certificate file.
func (s *DrmVendorBuydrmImpl) SetEndUserCert(v string) DrmVendorBuydrm {
	if s == nil {
		return nil
	}
	s.EndUserCertValue = &v
	return s
}

// Path to end user private key file
func (s DrmVendorBuydrmImpl) EndUserPrivateKey() *string {
	return s.EndUserPrivateKeyValue
}

// Path to end user private key file
func (s *DrmVendorBuydrmImpl) SetEndUserPrivateKey(v string) DrmVendorBuydrm {
	if s == nil {
		return nil
	}
	s.EndUserPrivateKeyValue = &v
	return s
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s DrmVendorBuydrmImpl) Expires() *int {
	return s.ExpiresValue
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s *DrmVendorBuydrmImpl) SetExpires(v int) DrmVendorBuydrm {
	if s == nil {
		return nil
	}
	s.ExpiresValue = &v
	return s
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s DrmVendorBuydrmImpl) Keyserver() *string {
	return s.KeyserverValue
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s *DrmVendorBuydrmImpl) SetKeyserver(v string) DrmVendorBuydrm {
	if s == nil {
		return nil
	}
	s.KeyserverValue = &v
	return s
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s DrmVendorBuydrmImpl) ResourceID() *DrmResourceID {
	return s.ResourceIDValue
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s *DrmVendorBuydrmImpl) SetResourceID(v DrmResourceID) DrmVendorBuydrm {
	if s == nil {
		return nil
	}
	s.ResourceIDValue = &v
	return s
}

// Deprecated field. Will be deleted at 25.04
// A unique identifier of the user
func (s DrmVendorBuydrmImpl) Userkey() *string {
	return s.UserkeyValue
}

// Deprecated field. Will be deleted at 25.04
// A unique identifier of the user
func (s *DrmVendorBuydrmImpl) SetUserkey(v string) DrmVendorBuydrm {
	if s == nil {
		return nil
	}
	s.UserkeyValue = &v
	return s
}

// BuyDRM
func (s DrmVendorBuydrmImpl) Vendor() string {
	return s.VendorValue
}

// BuyDRM
func (s *DrmVendorBuydrmImpl) SetVendor(v string) DrmVendorBuydrm {
	if s == nil {
		return nil
	}
	s.VendorValue = v
	return s
}

// NewDrmVendorClearkey creates a new DrmVendorClearkey instance
func NewDrmVendorClearkey() DrmVendorClearkey {
	return &DrmVendorClearkeyImpl{}
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s DrmVendorClearkeyImpl) Encryption() *string {
	return s.EncryptionValue
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s *DrmVendorClearkeyImpl) SetEncryption(v string) DrmVendorClearkey {
	if s == nil {
		return nil
	}
	s.EncryptionValue = &v
	return s
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s DrmVendorClearkeyImpl) Expires() *int {
	return s.ExpiresValue
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s *DrmVendorClearkeyImpl) SetExpires(v int) DrmVendorClearkey {
	if s == nil {
		return nil
	}
	s.ExpiresValue = &v
	return s
}

// Encryption Key in hex or file. Length must be 128 bit.
// Example: 0x76359e1212952a6db42b41eeb94ceb29
func (s DrmVendorClearkeyImpl) Key() *string {
	return s.KeyValue
}

// Encryption Key in hex or file. Length must be 128 bit.
// Example: 0x76359e1212952a6db42b41eeb94ceb29
func (s *DrmVendorClearkeyImpl) SetKey(v string) DrmVendorClearkey {
	if s == nil {
		return nil
	}
	s.KeyValue = &v
	return s
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s DrmVendorClearkeyImpl) Keyserver() *string {
	return s.KeyserverValue
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s *DrmVendorClearkeyImpl) SetKeyserver(v string) DrmVendorClearkey {
	if s == nil {
		return nil
	}
	s.KeyserverValue = &v
	return s
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s DrmVendorClearkeyImpl) ResourceID() *DrmResourceID {
	return s.ResourceIDValue
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s *DrmVendorClearkeyImpl) SetResourceID(v DrmResourceID) DrmVendorClearkey {
	if s == nil {
		return nil
	}
	s.ResourceIDValue = &v
	return s
}

// Clear Key is a lightweight DRM mode, where decryption keys are provided directly to the player. Its easy to
// integrate (simple JSON key/KID), requires minimal infrastructure, and can work via a license URL or with
// client-embedded keys.
func (s DrmVendorClearkeyImpl) Vendor() string {
	return s.VendorValue
}

// Clear Key is a lightweight DRM mode, where decryption keys are provided directly to the player. Its easy to
// integrate (simple JSON key/KID), requires minimal infrastructure, and can work via a license URL or with
// client-embedded keys.
func (s *DrmVendorClearkeyImpl) SetVendor(v string) DrmVendorClearkey {
	if s == nil {
		return nil
	}
	s.VendorValue = v
	return s
}

// NewDrmVendorConax creates a new DrmVendorConax instance
func NewDrmVendorConax() DrmVendorConax {
	return &DrmVendorConaxImpl{}
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s DrmVendorConaxImpl) Encryption() *string {
	return s.EncryptionValue
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s *DrmVendorConaxImpl) SetEncryption(v string) DrmVendorConax {
	if s == nil {
		return nil
	}
	s.EncryptionValue = &v
	return s
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s DrmVendorConaxImpl) Expires() *int {
	return s.ExpiresValue
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s *DrmVendorConaxImpl) SetExpires(v int) DrmVendorConax {
	if s == nil {
		return nil
	}
	s.ExpiresValue = &v
	return s
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s DrmVendorConaxImpl) Keyserver() *string {
	return s.KeyserverValue
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s *DrmVendorConaxImpl) SetKeyserver(v string) DrmVendorConax {
	if s == nil {
		return nil
	}
	s.KeyserverValue = &v
	return s
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s DrmVendorConaxImpl) ResourceID() *DrmResourceID {
	return s.ResourceIDValue
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s *DrmVendorConaxImpl) SetResourceID(v DrmResourceID) DrmVendorConax {
	if s == nil {
		return nil
	}
	s.ResourceIDValue = &v
	return s
}

// This parameter is used to specify applicable DRM systems.
// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
func (s DrmVendorConaxImpl) Systems() []DrmSystem {
	return s.SystemsValue
}

// This parameter is used to specify applicable DRM systems.
// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
func (s *DrmVendorConaxImpl) SetSystems(v []DrmSystem) DrmVendorConax {
	if s == nil {
		return nil
	}
	s.SystemsValue = v
	return s
}

// A custom key server path
// Example: 12345/nks/conax
func (s DrmVendorConaxImpl) UserPath() *string {
	return s.UserPathValue
}

// A custom key server path
// Example: 12345/nks/conax
func (s *DrmVendorConaxImpl) SetUserPath(v string) DrmVendorConax {
	if s == nil {
		return nil
	}
	s.UserPathValue = &v
	return s
}

// FIXME: Conax
func (s DrmVendorConaxImpl) Vendor() string {
	return s.VendorValue
}

// FIXME: Conax
func (s *DrmVendorConaxImpl) SetVendor(v string) DrmVendorConax {
	if s == nil {
		return nil
	}
	s.VendorValue = v
	return s
}

// NewDrmVendorCpix creates a new DrmVendorCpix instance
func NewDrmVendorCpix() DrmVendorCpix {
	return &DrmVendorCpixImpl{}
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s DrmVendorCpixImpl) Encryption() *string {
	return s.EncryptionValue
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s *DrmVendorCpixImpl) SetEncryption(v string) DrmVendorCpix {
	if s == nil {
		return nil
	}
	s.EncryptionValue = &v
	return s
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s DrmVendorCpixImpl) Expires() *int {
	return s.ExpiresValue
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s *DrmVendorCpixImpl) SetExpires(v int) DrmVendorCpix {
	if s == nil {
		return nil
	}
	s.ExpiresValue = &v
	return s
}

// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
// It is employed only one time in any session.
// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
// Usually, IV is received from a DRM provider.
func (s DrmVendorCpixImpl) Iv() *string {
	return s.IvValue
}

// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
// It is employed only one time in any session.
// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
// Usually, IV is received from a DRM provider.
func (s *DrmVendorCpixImpl) SetIv(v string) DrmVendorCpix {
	if s == nil {
		return nil
	}
	s.IvValue = &v
	return s
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s DrmVendorCpixImpl) Keyserver() *string {
	return s.KeyserverValue
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s *DrmVendorCpixImpl) SetKeyserver(v string) DrmVendorCpix {
	if s == nil {
		return nil
	}
	s.KeyserverValue = &v
	return s
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s DrmVendorCpixImpl) ResourceID() *DrmResourceID {
	return s.ResourceIDValue
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s *DrmVendorCpixImpl) SetResourceID(v DrmResourceID) DrmVendorCpix {
	if s == nil {
		return nil
	}
	s.ResourceIDValue = &v
	return s
}

// This parameter is used to specify applicable DRM systems.
// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
func (s DrmVendorCpixImpl) Systems() []DrmSystem {
	return s.SystemsValue
}

// This parameter is used to specify applicable DRM systems.
// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
func (s *DrmVendorCpixImpl) SetSystems(v []DrmSystem) DrmVendorCpix {
	if s == nil {
		return nil
	}
	s.SystemsValue = v
	return s
}

// FIXME: Cpix
func (s DrmVendorCpixImpl) Vendor() string {
	return s.VendorValue
}

// FIXME: Cpix
func (s *DrmVendorCpixImpl) SetVendor(v string) DrmVendorCpix {
	if s == nil {
		return nil
	}
	s.VendorValue = v
	return s
}

// NewDrmVendorDrmtoday creates a new DrmVendorDrmtoday instance
func NewDrmVendorDrmtoday() DrmVendorDrmtoday {
	return &DrmVendorDrmtodayImpl{}
}

// Authentication server for DRMtoday.
// Example: https://auth.drmtoday.com
func (s DrmVendorDrmtodayImpl) AuthServer() *string {
	return s.AuthServerValue
}

// Authentication server for DRMtoday.
// Example: https://auth.drmtoday.com
func (s *DrmVendorDrmtodayImpl) SetAuthServer(v string) DrmVendorDrmtoday {
	if s == nil {
		return nil
	}
	s.AuthServerValue = &v
	return s
}

// The uuid of the CPIX/SPEKE ingest configuration
func (s DrmVendorDrmtodayImpl) CpixConfigID() *string {
	return s.CpixConfigIDValue
}

// The uuid of the CPIX/SPEKE ingest configuration
func (s *DrmVendorDrmtodayImpl) SetCpixConfigID(v string) DrmVendorDrmtoday {
	if s == nil {
		return nil
	}
	s.CpixConfigIDValue = &v
	return s
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s DrmVendorDrmtodayImpl) Encryption() *string {
	return s.EncryptionValue
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s *DrmVendorDrmtodayImpl) SetEncryption(v string) DrmVendorDrmtoday {
	if s == nil {
		return nil
	}
	s.EncryptionValue = &v
	return s
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s DrmVendorDrmtodayImpl) Expires() *int {
	return s.ExpiresValue
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s *DrmVendorDrmtodayImpl) SetExpires(v int) DrmVendorDrmtoday {
	if s == nil {
		return nil
	}
	s.ExpiresValue = &v
	return s
}

// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
// It is employed only one time in any session.
// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
// Usually, IV is received from a DRM provider.
func (s DrmVendorDrmtodayImpl) Iv() *string {
	return s.IvValue
}

// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
// It is employed only one time in any session.
// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
// Usually, IV is received from a DRM provider.
func (s *DrmVendorDrmtodayImpl) SetIv(v string) DrmVendorDrmtoday {
	if s == nil {
		return nil
	}
	s.IvValue = &v
	return s
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s DrmVendorDrmtodayImpl) Keyserver() *string {
	return s.KeyserverValue
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s *DrmVendorDrmtodayImpl) SetKeyserver(v string) DrmVendorDrmtoday {
	if s == nil {
		return nil
	}
	s.KeyserverValue = &v
	return s
}

// The uuid of the merchant at DRMtoday.
func (s DrmVendorDrmtodayImpl) MerchantID() *string {
	return s.MerchantIDValue
}

// The uuid of the merchant at DRMtoday.
func (s *DrmVendorDrmtodayImpl) SetMerchantID(v string) DrmVendorDrmtoday {
	if s == nil {
		return nil
	}
	s.MerchantIDValue = &v
	return s
}

// A password for API account.
func (s DrmVendorDrmtodayImpl) Password() *string {
	return s.PasswordValue
}

// A password for API account.
func (s *DrmVendorDrmtodayImpl) SetPassword(v string) DrmVendorDrmtoday {
	if s == nil {
		return nil
	}
	s.PasswordValue = &v
	return s
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s DrmVendorDrmtodayImpl) ResourceID() *DrmResourceID {
	return s.ResourceIDValue
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s *DrmVendorDrmtodayImpl) SetResourceID(v DrmResourceID) DrmVendorDrmtoday {
	if s == nil {
		return nil
	}
	s.ResourceIDValue = &v
	return s
}

// This parameter is used to specify applicable DRM systems.
// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
func (s DrmVendorDrmtodayImpl) Systems() []DrmSystem {
	return s.SystemsValue
}

// This parameter is used to specify applicable DRM systems.
// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
func (s *DrmVendorDrmtodayImpl) SetSystems(v []DrmSystem) DrmVendorDrmtoday {
	if s == nil {
		return nil
	}
	s.SystemsValue = v
	return s
}

// The login name of an API account.
func (s DrmVendorDrmtodayImpl) Username() *string {
	return s.UsernameValue
}

// The login name of an API account.
func (s *DrmVendorDrmtodayImpl) SetUsername(v string) DrmVendorDrmtoday {
	if s == nil {
		return nil
	}
	s.UsernameValue = &v
	return s
}

// FIXME: DRMtoday
func (s DrmVendorDrmtodayImpl) Vendor() string {
	return s.VendorValue
}

// FIXME: DRMtoday
func (s *DrmVendorDrmtodayImpl) SetVendor(v string) DrmVendorDrmtoday {
	if s == nil {
		return nil
	}
	s.VendorValue = v
	return s
}

// NewDrmVendorEzdrm creates a new DrmVendorEzdrm instance
func NewDrmVendorEzdrm() DrmVendorEzdrm {
	return &DrmVendorEzdrmImpl{}
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s DrmVendorEzdrmImpl) Encryption() *string {
	return s.EncryptionValue
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s *DrmVendorEzdrmImpl) SetEncryption(v string) DrmVendorEzdrm {
	if s == nil {
		return nil
	}
	s.EncryptionValue = &v
	return s
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s DrmVendorEzdrmImpl) Expires() *int {
	return s.ExpiresValue
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s *DrmVendorEzdrmImpl) SetExpires(v int) DrmVendorEzdrm {
	if s == nil {
		return nil
	}
	s.ExpiresValue = &v
	return s
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s DrmVendorEzdrmImpl) Keyserver() *string {
	return s.KeyserverValue
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s *DrmVendorEzdrmImpl) SetKeyserver(v string) DrmVendorEzdrm {
	if s == nil {
		return nil
	}
	s.KeyserverValue = &v
	return s
}

// A password for authorization of a user on a key server.
func (s DrmVendorEzdrmImpl) Password() *string {
	return s.PasswordValue
}

// A password for authorization of a user on a key server.
func (s *DrmVendorEzdrmImpl) SetPassword(v string) DrmVendorEzdrm {
	if s == nil {
		return nil
	}
	s.PasswordValue = &v
	return s
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s DrmVendorEzdrmImpl) ResourceID() *DrmResourceID {
	return s.ResourceIDValue
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s *DrmVendorEzdrmImpl) SetResourceID(v DrmResourceID) DrmVendorEzdrm {
	if s == nil {
		return nil
	}
	s.ResourceIDValue = &v
	return s
}

// A user name for authorization of a user on a key server.
func (s DrmVendorEzdrmImpl) User() *string {
	return s.UserValue
}

// A user name for authorization of a user on a key server.
func (s *DrmVendorEzdrmImpl) SetUser(v string) DrmVendorEzdrm {
	if s == nil {
		return nil
	}
	s.UserValue = &v
	return s
}

// FIXME: Ezdrm
func (s DrmVendorEzdrmImpl) Vendor() string {
	return s.VendorValue
}

// FIXME: Ezdrm
func (s *DrmVendorEzdrmImpl) SetVendor(v string) DrmVendorEzdrm {
	if s == nil {
		return nil
	}
	s.VendorValue = v
	return s
}

// NewDrmVendorEzdrmClassic creates a new DrmVendorEzdrmClassic instance
func NewDrmVendorEzdrmClassic() DrmVendorEzdrmClassic {
	return &DrmVendorEzdrmClassicImpl{}
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s DrmVendorEzdrmClassicImpl) Encryption() *string {
	return s.EncryptionValue
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s *DrmVendorEzdrmClassicImpl) SetEncryption(v string) DrmVendorEzdrmClassic {
	if s == nil {
		return nil
	}
	s.EncryptionValue = &v
	return s
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s DrmVendorEzdrmClassicImpl) Expires() *int {
	return s.ExpiresValue
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s *DrmVendorEzdrmClassicImpl) SetExpires(v int) DrmVendorEzdrmClassic {
	if s == nil {
		return nil
	}
	s.ExpiresValue = &v
	return s
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s DrmVendorEzdrmClassicImpl) Keyserver() *string {
	return s.KeyserverValue
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s *DrmVendorEzdrmClassicImpl) SetKeyserver(v string) DrmVendorEzdrmClassic {
	if s == nil {
		return nil
	}
	s.KeyserverValue = &v
	return s
}

// A password for authorization of a user on a key server.
func (s DrmVendorEzdrmClassicImpl) Password() *string {
	return s.PasswordValue
}

// A password for authorization of a user on a key server.
func (s *DrmVendorEzdrmClassicImpl) SetPassword(v string) DrmVendorEzdrmClassic {
	if s == nil {
		return nil
	}
	s.PasswordValue = &v
	return s
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s DrmVendorEzdrmClassicImpl) ResourceID() *DrmResourceID {
	return s.ResourceIDValue
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s *DrmVendorEzdrmClassicImpl) SetResourceID(v DrmResourceID) DrmVendorEzdrmClassic {
	if s == nil {
		return nil
	}
	s.ResourceIDValue = &v
	return s
}

// A user name for authorization of a user on a key server.
func (s DrmVendorEzdrmClassicImpl) User() *string {
	return s.UserValue
}

// A user name for authorization of a user on a key server.
func (s *DrmVendorEzdrmClassicImpl) SetUser(v string) DrmVendorEzdrmClassic {
	if s == nil {
		return nil
	}
	s.UserValue = &v
	return s
}

// FIXME: Ezdrm classic
func (s DrmVendorEzdrmClassicImpl) Vendor() string {
	return s.VendorValue
}

// FIXME: Ezdrm classic
func (s *DrmVendorEzdrmClassicImpl) SetVendor(v string) DrmVendorEzdrmClassic {
	if s == nil {
		return nil
	}
	s.VendorValue = v
	return s
}

// NewDrmVendorGsdrm creates a new DrmVendorGsdrm instance
func NewDrmVendorGsdrm() DrmVendorGsdrm {
	return &DrmVendorGsdrmImpl{}
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s DrmVendorGsdrmImpl) Encryption() *string {
	return s.EncryptionValue
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s *DrmVendorGsdrmImpl) SetEncryption(v string) DrmVendorGsdrm {
	if s == nil {
		return nil
	}
	s.EncryptionValue = &v
	return s
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s DrmVendorGsdrmImpl) Expires() *int {
	return s.ExpiresValue
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s *DrmVendorGsdrmImpl) SetExpires(v int) DrmVendorGsdrm {
	if s == nil {
		return nil
	}
	s.ExpiresValue = &v
	return s
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s DrmVendorGsdrmImpl) Keyserver() *string {
	return s.KeyserverValue
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s *DrmVendorGsdrmImpl) SetKeyserver(v string) DrmVendorGsdrm {
	if s == nil {
		return nil
	}
	s.KeyserverValue = &v
	return s
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s DrmVendorGsdrmImpl) ResourceID() *DrmResourceID {
	return s.ResourceIDValue
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s *DrmVendorGsdrmImpl) SetResourceID(v DrmResourceID) DrmVendorGsdrm {
	if s == nil {
		return nil
	}
	s.ResourceIDValue = &v
	return s
}

// FIXME: GS DRM
func (s DrmVendorGsdrmImpl) Vendor() string {
	return s.VendorValue
}

// FIXME: GS DRM
func (s *DrmVendorGsdrmImpl) SetVendor(v string) DrmVendorGsdrm {
	if s == nil {
		return nil
	}
	s.VendorValue = v
	return s
}

// NewDrmVendorIrdeto creates a new DrmVendorIrdeto instance
func NewDrmVendorIrdeto() DrmVendorIrdeto {
	return &DrmVendorIrdetoImpl{}
}

// ID of the Irdeto DRM account.
func (s DrmVendorIrdetoImpl) AccountID() *string {
	return s.AccountIDValue
}

// ID of the Irdeto DRM account.
func (s *DrmVendorIrdetoImpl) SetAccountID(v string) DrmVendorIrdeto {
	if s == nil {
		return nil
	}
	s.AccountIDValue = &v
	return s
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s DrmVendorIrdetoImpl) Encryption() *string {
	return s.EncryptionValue
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s *DrmVendorIrdetoImpl) SetEncryption(v string) DrmVendorIrdeto {
	if s == nil {
		return nil
	}
	s.EncryptionValue = &v
	return s
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s DrmVendorIrdetoImpl) Expires() *int {
	return s.ExpiresValue
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s *DrmVendorIrdetoImpl) SetExpires(v int) DrmVendorIrdeto {
	if s == nil {
		return nil
	}
	s.ExpiresValue = &v
	return s
}

// A hostname of Irdeto DRM key server.
func (s DrmVendorIrdetoImpl) IcHost() *string {
	return s.IcHostValue
}

// A hostname of Irdeto DRM key server.
func (s *DrmVendorIrdetoImpl) SetIcHost(v string) DrmVendorIrdeto {
	if s == nil {
		return nil
	}
	s.IcHostValue = &v
	return s
}

// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
// It is employed only one time in any session.
// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
// Usually, IV is received from a DRM provider.
func (s DrmVendorIrdetoImpl) Iv() *string {
	return s.IvValue
}

// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
// It is employed only one time in any session.
// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
// Usually, IV is received from a DRM provider.
func (s *DrmVendorIrdetoImpl) SetIv(v string) DrmVendorIrdeto {
	if s == nil {
		return nil
	}
	s.IvValue = &v
	return s
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s DrmVendorIrdetoImpl) Keyserver() *string {
	return s.KeyserverValue
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s *DrmVendorIrdetoImpl) SetKeyserver(v string) DrmVendorIrdeto {
	if s == nil {
		return nil
	}
	s.KeyserverValue = &v
	return s
}

// A password for authorization of a user on a key server.
func (s DrmVendorIrdetoImpl) Password() *string {
	return s.PasswordValue
}

// A password for authorization of a user on a key server.
func (s *DrmVendorIrdetoImpl) SetPassword(v string) DrmVendorIrdeto {
	if s == nil {
		return nil
	}
	s.PasswordValue = &v
	return s
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s DrmVendorIrdetoImpl) ResourceID() *DrmResourceID {
	return s.ResourceIDValue
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s *DrmVendorIrdetoImpl) SetResourceID(v DrmResourceID) DrmVendorIrdeto {
	if s == nil {
		return nil
	}
	s.ResourceIDValue = &v
	return s
}

// This parameter is used to specify applicable DRM systems.
// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
func (s DrmVendorIrdetoImpl) Systems() []DrmSystem {
	return s.SystemsValue
}

// This parameter is used to specify applicable DRM systems.
// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
func (s *DrmVendorIrdetoImpl) SetSystems(v []DrmSystem) DrmVendorIrdeto {
	if s == nil {
		return nil
	}
	s.SystemsValue = v
	return s
}

// A user name of the Irdeto DRM user.
func (s DrmVendorIrdetoImpl) UserName() *string {
	return s.UserNameValue
}

// A user name of the Irdeto DRM user.
func (s *DrmVendorIrdetoImpl) SetUserName(v string) DrmVendorIrdeto {
	if s == nil {
		return nil
	}
	s.UserNameValue = &v
	return s
}

// FIXME: Irdeto
func (s DrmVendorIrdetoImpl) Vendor() string {
	return s.VendorValue
}

// FIXME: Irdeto
func (s *DrmVendorIrdetoImpl) SetVendor(v string) DrmVendorIrdeto {
	if s == nil {
		return nil
	}
	s.VendorValue = v
	return s
}

// NewDrmVendorKeyos creates a new DrmVendorKeyos instance
func NewDrmVendorKeyos() DrmVendorKeyos {
	return &DrmVendorKeyosImpl{}
}

// A unique identifier of the content, used for Widevine DRM.
// By default, it is equal to the stream name.
func (s DrmVendorKeyosImpl) ContentID() *string {
	return s.ContentIDValue
}

// A unique identifier of the content, used for Widevine DRM.
// By default, it is equal to the stream name.
func (s *DrmVendorKeyosImpl) SetContentID(v string) DrmVendorKeyos {
	if s == nil {
		return nil
	}
	s.ContentIDValue = &v
	return s
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s DrmVendorKeyosImpl) Encryption() *string {
	return s.EncryptionValue
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s *DrmVendorKeyosImpl) SetEncryption(v string) DrmVendorKeyos {
	if s == nil {
		return nil
	}
	s.EncryptionValue = &v
	return s
}

// Path to end user certificate file.
func (s DrmVendorKeyosImpl) EndUserCert() *string {
	return s.EndUserCertValue
}

// Path to end user certificate file.
func (s *DrmVendorKeyosImpl) SetEndUserCert(v string) DrmVendorKeyos {
	if s == nil {
		return nil
	}
	s.EndUserCertValue = &v
	return s
}

// Path to end user private key file
func (s DrmVendorKeyosImpl) EndUserPrivateKey() *string {
	return s.EndUserPrivateKeyValue
}

// Path to end user private key file
func (s *DrmVendorKeyosImpl) SetEndUserPrivateKey(v string) DrmVendorKeyos {
	if s == nil {
		return nil
	}
	s.EndUserPrivateKeyValue = &v
	return s
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s DrmVendorKeyosImpl) Expires() *int {
	return s.ExpiresValue
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s *DrmVendorKeyosImpl) SetExpires(v int) DrmVendorKeyos {
	if s == nil {
		return nil
	}
	s.ExpiresValue = &v
	return s
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s DrmVendorKeyosImpl) Keyserver() *string {
	return s.KeyserverValue
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s *DrmVendorKeyosImpl) SetKeyserver(v string) DrmVendorKeyos {
	if s == nil {
		return nil
	}
	s.KeyserverValue = &v
	return s
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s DrmVendorKeyosImpl) ResourceID() *DrmResourceID {
	return s.ResourceIDValue
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s *DrmVendorKeyosImpl) SetResourceID(v DrmResourceID) DrmVendorKeyos {
	if s == nil {
		return nil
	}
	s.ResourceIDValue = &v
	return s
}

// Deprecated field. Will be deleted at 25.04
// A unique identifier of the user
func (s DrmVendorKeyosImpl) Userkey() *string {
	return s.UserkeyValue
}

// Deprecated field. Will be deleted at 25.04
// A unique identifier of the user
func (s *DrmVendorKeyosImpl) SetUserkey(v string) DrmVendorKeyos {
	if s == nil {
		return nil
	}
	s.UserkeyValue = &v
	return s
}

// KeyOs
func (s DrmVendorKeyosImpl) Vendor() string {
	return s.VendorValue
}

// KeyOs
func (s *DrmVendorKeyosImpl) SetVendor(v string) DrmVendorKeyos {
	if s == nil {
		return nil
	}
	s.VendorValue = v
	return s
}

// NewDrmVendorPallycon creates a new DrmVendorPallycon instance
func NewDrmVendorPallycon() DrmVendorPallycon {
	return &DrmVendorPallyconImpl{}
}

// An API authentication token that is generated when you sign up for the PallyCon service at https://login.pallycon.com/.
func (s DrmVendorPallyconImpl) EncToken() *string {
	return s.EncTokenValue
}

// An API authentication token that is generated when you sign up for the PallyCon service at https://login.pallycon.com/.
func (s *DrmVendorPallyconImpl) SetEncToken(v string) DrmVendorPallycon {
	if s == nil {
		return nil
	}
	s.EncTokenValue = &v
	return s
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s DrmVendorPallyconImpl) Encryption() *string {
	return s.EncryptionValue
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s *DrmVendorPallyconImpl) SetEncryption(v string) DrmVendorPallycon {
	if s == nil {
		return nil
	}
	s.EncryptionValue = &v
	return s
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s DrmVendorPallyconImpl) Expires() *int {
	return s.ExpiresValue
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s *DrmVendorPallyconImpl) SetExpires(v int) DrmVendorPallycon {
	if s == nil {
		return nil
	}
	s.ExpiresValue = &v
	return s
}

// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
// It is employed only one time in any session.
// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
// Usually, IV is received from a DRM provider.
func (s DrmVendorPallyconImpl) Iv() *string {
	return s.IvValue
}

// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
// It is employed only one time in any session.
// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
// Usually, IV is received from a DRM provider.
func (s *DrmVendorPallyconImpl) SetIv(v string) DrmVendorPallycon {
	if s == nil {
		return nil
	}
	s.IvValue = &v
	return s
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s DrmVendorPallyconImpl) Keyserver() *string {
	return s.KeyserverValue
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s *DrmVendorPallyconImpl) SetKeyserver(v string) DrmVendorPallycon {
	if s == nil {
		return nil
	}
	s.KeyserverValue = &v
	return s
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s DrmVendorPallyconImpl) ResourceID() *DrmResourceID {
	return s.ResourceIDValue
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s *DrmVendorPallyconImpl) SetResourceID(v DrmResourceID) DrmVendorPallycon {
	if s == nil {
		return nil
	}
	s.ResourceIDValue = &v
	return s
}

// This parameter is used to specify applicable DRM systems.
// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
func (s DrmVendorPallyconImpl) Systems() []DrmSystem {
	return s.SystemsValue
}

// This parameter is used to specify applicable DRM systems.
// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
func (s *DrmVendorPallyconImpl) SetSystems(v []DrmSystem) DrmVendorPallycon {
	if s == nil {
		return nil
	}
	s.SystemsValue = v
	return s
}

// FIXME: Pallycon
func (s DrmVendorPallyconImpl) Vendor() string {
	return s.VendorValue
}

// FIXME: Pallycon
func (s *DrmVendorPallyconImpl) SetVendor(v string) DrmVendorPallycon {
	if s == nil {
		return nil
	}
	s.VendorValue = v
	return s
}

// NewDrmVendorPlayready creates a new DrmVendorPlayready instance
func NewDrmVendorPlayready() DrmVendorPlayready {
	return &DrmVendorPlayreadyImpl{}
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s DrmVendorPlayreadyImpl) Encryption() *string {
	return s.EncryptionValue
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s *DrmVendorPlayreadyImpl) SetEncryption(v string) DrmVendorPlayready {
	if s == nil {
		return nil
	}
	s.EncryptionValue = &v
	return s
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s DrmVendorPlayreadyImpl) Expires() *int {
	return s.ExpiresValue
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s *DrmVendorPlayreadyImpl) SetExpires(v int) DrmVendorPlayready {
	if s == nil {
		return nil
	}
	s.ExpiresValue = &v
	return s
}

// An arbitrary Base64-encoded string of 30 bytes.
// It is necessary for PlayReady to create an encryption key.
func (s DrmVendorPlayreadyImpl) Keyseed() *string {
	return s.KeyseedValue
}

// An arbitrary Base64-encoded string of 30 bytes.
// It is necessary for PlayReady to create an encryption key.
func (s *DrmVendorPlayreadyImpl) SetKeyseed(v string) DrmVendorPlayready {
	if s == nil {
		return nil
	}
	s.KeyseedValue = &v
	return s
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s DrmVendorPlayreadyImpl) Keyserver() *string {
	return s.KeyserverValue
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s *DrmVendorPlayreadyImpl) SetKeyserver(v string) DrmVendorPlayready {
	if s == nil {
		return nil
	}
	s.KeyserverValue = &v
	return s
}

// License URL, used for PlayReady DRM.
// Format: url (url)
func (s DrmVendorPlayreadyImpl) LaURL() *URL {
	return s.LaURLValue
}

// License URL, used for PlayReady DRM.
// Format: url (url)
func (s *DrmVendorPlayreadyImpl) SetLaURL(v URL) DrmVendorPlayready {
	if s == nil {
		return nil
	}
	s.LaURLValue = &v
	return s
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s DrmVendorPlayreadyImpl) ResourceID() *DrmResourceID {
	return s.ResourceIDValue
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s *DrmVendorPlayreadyImpl) SetResourceID(v DrmResourceID) DrmVendorPlayready {
	if s == nil {
		return nil
	}
	s.ResourceIDValue = &v
	return s
}

// FIXME: Playready
func (s DrmVendorPlayreadyImpl) Vendor() string {
	return s.VendorValue
}

// FIXME: Playready
func (s *DrmVendorPlayreadyImpl) SetVendor(v string) DrmVendorPlayready {
	if s == nil {
		return nil
	}
	s.VendorValue = v
	return s
}

// NewDrmVendorSampleAes creates a new DrmVendorSampleAes instance
func NewDrmVendorSampleAes() DrmVendorSampleAes {
	return &DrmVendorSampleAesImpl{}
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s DrmVendorSampleAesImpl) Encryption() *string {
	return s.EncryptionValue
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s *DrmVendorSampleAesImpl) SetEncryption(v string) DrmVendorSampleAes {
	if s == nil {
		return nil
	}
	s.EncryptionValue = &v
	return s
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s DrmVendorSampleAesImpl) Expires() *int {
	return s.ExpiresValue
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s *DrmVendorSampleAesImpl) SetExpires(v int) DrmVendorSampleAes {
	if s == nil {
		return nil
	}
	s.ExpiresValue = &v
	return s
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s DrmVendorSampleAesImpl) Keyserver() *string {
	return s.KeyserverValue
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s *DrmVendorSampleAesImpl) SetKeyserver(v string) DrmVendorSampleAes {
	if s == nil {
		return nil
	}
	s.KeyserverValue = &v
	return s
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s DrmVendorSampleAesImpl) ResourceID() *DrmResourceID {
	return s.ResourceIDValue
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s *DrmVendorSampleAesImpl) SetResourceID(v DrmResourceID) DrmVendorSampleAes {
	if s == nil {
		return nil
	}
	s.ResourceIDValue = &v
	return s
}

// FIXME: Sample AES
func (s DrmVendorSampleAesImpl) Vendor() string {
	return s.VendorValue
}

// FIXME: Sample AES
func (s *DrmVendorSampleAesImpl) SetVendor(v string) DrmVendorSampleAes {
	if s == nil {
		return nil
	}
	s.VendorValue = v
	return s
}

// NewDrmVendorSampleAesIdentity creates a new DrmVendorSampleAesIdentity instance
func NewDrmVendorSampleAesIdentity() DrmVendorSampleAesIdentity {
	return &DrmVendorSampleAesIdentityImpl{}
}

// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
// It is employed only one time in any session.
// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
// Usually, IV is received from a DRM provider.
func (s DrmVendorSampleAesIdentityImpl) Iv() *string {
	return s.IvValue
}

// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
// It is employed only one time in any session.
// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
// Usually, IV is received from a DRM provider.
func (s *DrmVendorSampleAesIdentityImpl) SetIv(v string) DrmVendorSampleAesIdentity {
	if s == nil {
		return nil
	}
	s.IvValue = &v
	return s
}

// Encryption Key in hex or file. Length must be 128 bit.
// Example: 0x76359e1212952a6db42b41eeb94ceb29
func (s DrmVendorSampleAesIdentityImpl) Key() *string {
	return s.KeyValue
}

// Encryption Key in hex or file. Length must be 128 bit.
// Example: 0x76359e1212952a6db42b41eeb94ceb29
func (s *DrmVendorSampleAesIdentityImpl) SetKey(v string) DrmVendorSampleAesIdentity {
	if s == nil {
		return nil
	}
	s.KeyValue = &v
	return s
}

// Http link which specifies how to obtain the key. It is URI attribute of HLS manifest EXT-X-KEY method.
func (s DrmVendorSampleAesIdentityImpl) URL() *string {
	return s.URLValue
}

// Http link which specifies how to obtain the key. It is URI attribute of HLS manifest EXT-X-KEY method.
func (s *DrmVendorSampleAesIdentityImpl) SetURL(v string) DrmVendorSampleAesIdentity {
	if s == nil {
		return nil
	}
	s.URLValue = &v
	return s
}

// Sample AES which uses KEYFORMAT=identity. It allows to encrypt and decrypt content using clear text AES key.
// The identity value for KEYFORMAT should be used only for testing.
func (s DrmVendorSampleAesIdentityImpl) Vendor() string {
	return s.VendorValue
}

// Sample AES which uses KEYFORMAT=identity. It allows to encrypt and decrypt content using clear text AES key.
// The identity value for KEYFORMAT should be used only for testing.
func (s *DrmVendorSampleAesIdentityImpl) SetVendor(v string) DrmVendorSampleAesIdentity {
	if s == nil {
		return nil
	}
	s.VendorValue = v
	return s
}

// NewDrmVendorSolocoo creates a new DrmVendorSolocoo instance
func NewDrmVendorSolocoo() DrmVendorSolocoo {
	return &DrmVendorSolocooImpl{}
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s DrmVendorSolocooImpl) Encryption() *string {
	return s.EncryptionValue
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s *DrmVendorSolocooImpl) SetEncryption(v string) DrmVendorSolocoo {
	if s == nil {
		return nil
	}
	s.EncryptionValue = &v
	return s
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s DrmVendorSolocooImpl) Expires() *int {
	return s.ExpiresValue
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s *DrmVendorSolocooImpl) SetExpires(v int) DrmVendorSolocoo {
	if s == nil {
		return nil
	}
	s.ExpiresValue = &v
	return s
}

// Whether to use FairPlay system for key generation.
// If set to `false`, the requests for FairPlay encryption key are disabled.
func (s DrmVendorSolocooImpl) Fp() *string {
	return s.FpValue
}

// Whether to use FairPlay system for key generation.
// If set to `false`, the requests for FairPlay encryption key are disabled.
func (s *DrmVendorSolocooImpl) SetFp(v string) DrmVendorSolocoo {
	if s == nil {
		return nil
	}
	s.FpValue = &v
	return s
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s DrmVendorSolocooImpl) Keyserver() *string {
	return s.KeyserverValue
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s *DrmVendorSolocooImpl) SetKeyserver(v string) DrmVendorSolocoo {
	if s == nil {
		return nil
	}
	s.KeyserverValue = &v
	return s
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s DrmVendorSolocooImpl) ResourceID() *DrmResourceID {
	return s.ResourceIDValue
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s *DrmVendorSolocooImpl) SetResourceID(v DrmResourceID) DrmVendorSolocoo {
	if s == nil {
		return nil
	}
	s.ResourceIDValue = &v
	return s
}

// A part of the keyserver's URL: `https://SITE.solocoo.tv/SITEadmintools/papi/SECRET/method`.
func (s DrmVendorSolocooImpl) Secret() *string {
	return s.SecretValue
}

// A part of the keyserver's URL: `https://SITE.solocoo.tv/SITEadmintools/papi/SECRET/method`.
func (s *DrmVendorSolocooImpl) SetSecret(v string) DrmVendorSolocoo {
	if s == nil {
		return nil
	}
	s.SecretValue = &v
	return s
}

// A part of the keyserver's URL: `https://SITE.solocoo.tv/SITEadmintools/papi/SECRET/method`.
func (s DrmVendorSolocooImpl) Site() *string {
	return s.SiteValue
}

// A part of the keyserver's URL: `https://SITE.solocoo.tv/SITEadmintools/papi/SECRET/method`.
func (s *DrmVendorSolocooImpl) SetSite(v string) DrmVendorSolocoo {
	if s == nil {
		return nil
	}
	s.SiteValue = &v
	return s
}

// FIXME: Solocoo
func (s DrmVendorSolocooImpl) Vendor() string {
	return s.VendorValue
}

// FIXME: Solocoo
func (s *DrmVendorSolocooImpl) SetVendor(v string) DrmVendorSolocoo {
	if s == nil {
		return nil
	}
	s.VendorValue = v
	return s
}

// NewDrmVendorVerimatrix creates a new DrmVendorVerimatrix instance
func NewDrmVendorVerimatrix() DrmVendorVerimatrix {
	return &DrmVendorVerimatrixImpl{}
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s DrmVendorVerimatrixImpl) Encryption() *string {
	return s.EncryptionValue
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s *DrmVendorVerimatrixImpl) SetEncryption(v string) DrmVendorVerimatrix {
	if s == nil {
		return nil
	}
	s.EncryptionValue = &v
	return s
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s DrmVendorVerimatrixImpl) Expires() *int {
	return s.ExpiresValue
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s *DrmVendorVerimatrixImpl) SetExpires(v int) DrmVendorVerimatrix {
	if s == nil {
		return nil
	}
	s.ExpiresValue = &v
	return s
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s DrmVendorVerimatrixImpl) Keyserver() *string {
	return s.KeyserverValue
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s *DrmVendorVerimatrixImpl) SetKeyserver(v string) DrmVendorVerimatrix {
	if s == nil {
		return nil
	}
	s.KeyserverValue = &v
	return s
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s DrmVendorVerimatrixImpl) ResourceID() *DrmResourceID {
	return s.ResourceIDValue
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s *DrmVendorVerimatrixImpl) SetResourceID(v DrmResourceID) DrmVendorVerimatrix {
	if s == nil {
		return nil
	}
	s.ResourceIDValue = &v
	return s
}

// The URL sent to the client for watching the content.
// Example: https://public-keyserver.mycompany.com
func (s DrmVendorVerimatrixImpl) UserKeyserver() *string {
	return s.UserKeyserverValue
}

// The URL sent to the client for watching the content.
// Example: https://public-keyserver.mycompany.com
func (s *DrmVendorVerimatrixImpl) SetUserKeyserver(v string) DrmVendorVerimatrix {
	if s == nil {
		return nil
	}
	s.UserKeyserverValue = &v
	return s
}

// FIXME: Verimatrix
func (s DrmVendorVerimatrixImpl) Vendor() string {
	return s.VendorValue
}

// FIXME: Verimatrix
func (s *DrmVendorVerimatrixImpl) SetVendor(v string) DrmVendorVerimatrix {
	if s == nil {
		return nil
	}
	s.VendorValue = v
	return s
}

// NewDrmVendorWidevine creates a new DrmVendorWidevine instance
func NewDrmVendorWidevine() DrmVendorWidevine {
	return &DrmVendorWidevineImpl{}
}

// AES (Advanced Encryption Standard) key. Used for Widevine DRM.
func (s DrmVendorWidevineImpl) AesKey() *string {
	return s.AesKeyValue
}

// AES (Advanced Encryption Standard) key. Used for Widevine DRM.
func (s *DrmVendorWidevineImpl) SetAesKey(v string) DrmVendorWidevine {
	if s == nil {
		return nil
	}
	s.AesKeyValue = &v
	return s
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s DrmVendorWidevineImpl) Encryption() *string {
	return s.EncryptionValue
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s *DrmVendorWidevineImpl) SetEncryption(v string) DrmVendorWidevine {
	if s == nil {
		return nil
	}
	s.EncryptionValue = &v
	return s
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s DrmVendorWidevineImpl) Expires() *int {
	return s.ExpiresValue
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s *DrmVendorWidevineImpl) SetExpires(v int) DrmVendorWidevine {
	if s == nil {
		return nil
	}
	s.ExpiresValue = &v
	return s
}

// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
// It is employed only one time in any session.
// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
// Usually, IV is received from a DRM provider.
func (s DrmVendorWidevineImpl) Iv() *string {
	return s.IvValue
}

// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
// It is employed only one time in any session.
// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
// Usually, IV is received from a DRM provider.
func (s *DrmVendorWidevineImpl) SetIv(v string) DrmVendorWidevine {
	if s == nil {
		return nil
	}
	s.IvValue = &v
	return s
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s DrmVendorWidevineImpl) Keyserver() *string {
	return s.KeyserverValue
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s *DrmVendorWidevineImpl) SetKeyserver(v string) DrmVendorWidevine {
	if s == nil {
		return nil
	}
	s.KeyserverValue = &v
	return s
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s DrmVendorWidevineImpl) ResourceID() *DrmResourceID {
	return s.ResourceIDValue
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s *DrmVendorWidevineImpl) SetResourceID(v DrmResourceID) DrmVendorWidevine {
	if s == nil {
		return nil
	}
	s.ResourceIDValue = &v
	return s
}

// A unique ID of the signer.
// Flussonic uses it to connect to the key server when using test key for Widevine DRM.
func (s DrmVendorWidevineImpl) Signer() *string {
	return s.SignerValue
}

// A unique ID of the signer.
// Flussonic uses it to connect to the key server when using test key for Widevine DRM.
func (s *DrmVendorWidevineImpl) SetSigner(v string) DrmVendorWidevine {
	if s == nil {
		return nil
	}
	s.SignerValue = &v
	return s
}

// FIXME: Widevine
func (s DrmVendorWidevineImpl) Vendor() string {
	return s.VendorValue
}

// FIXME: Widevine
func (s *DrmVendorWidevineImpl) SetVendor(v string) DrmVendorWidevine {
	if s == nil {
		return nil
	}
	s.VendorValue = v
	return s
}

// NewDvrBaseConfig creates a new DvrBaseConfig instance
func NewDvrBaseConfig() DvrBaseConfig {
	return &DvrBaseConfigImpl{}
}

// Maximum disk consumption in percents. When this limit is reached,
// the oldest segment of the recording will be overridden by later data.
// It important to understand that this is not a "per-stream" option, this option means
// that cleaning of this stream will be triggered if overall disk usage reaches this number.
// If you have all streams with configuration 98% and one stream with 95%, it will be permanently
// empty.
// Format: percent (percent)
// Example: 98
func (s DvrBaseConfigImpl) DiskUsageLimit() *Percent {
	return s.DiskUsageLimitValue
}

// Maximum disk consumption in percents. When this limit is reached,
// the oldest segment of the recording will be overridden by later data.
// It important to understand that this is not a "per-stream" option, this option means
// that cleaning of this stream will be triggered if overall disk usage reaches this number.
// If you have all streams with configuration 98% and one stream with 95%, it will be permanently
// empty.
// Format: percent (percent)
// Example: 98
func (s *DvrBaseConfigImpl) SetDiskUsageLimit(v Percent) DvrBaseConfig {
	if s == nil {
		return nil
	}
	s.DiskUsageLimitValue = &v
	return s
}

// Additional archive depth in seconds for episodes. If set, episodes and their corresponding DVR record
// will be saved for `expiration + episodes_expiration` seconds.
// The archive clean-up within `[expiration, expiration+episodes_expiration]` seconds of the
// recording performed depending on [external_episodes_list](https://flussonic.com/doc/api/config-external/#tag/dvr/operation/external_episodes_list)
// response of `episodes_url`.
// Anything older than `expiration+episodes_expiration` seconds will
// be cleaned even if `episodes_url` does not respond.
// Format: seconds (seconds)
// Examples: 6.048e+06
func (s DvrBaseConfigImpl) EpisodesExpiration() *Seconds {
	return s.EpisodesExpirationValue
}

// Additional archive depth in seconds for episodes. If set, episodes and their corresponding DVR record
// will be saved for `expiration + episodes_expiration` seconds.
// The archive clean-up within `[expiration, expiration+episodes_expiration]` seconds of the
// recording performed depending on [external_episodes_list](https://flussonic.com/doc/api/config-external/#tag/dvr/operation/external_episodes_list)
// response of `episodes_url`.
// Anything older than `expiration+episodes_expiration` seconds will
// be cleaned even if `episodes_url` does not respond.
// Format: seconds (seconds)
// Examples: 6.048e+06
func (s *DvrBaseConfigImpl) SetEpisodesExpiration(v Seconds) DvrBaseConfig {
	if s == nil {
		return nil
	}
	s.EpisodesExpirationValue = &v
	return s
}

// External URL that will be triggered for fetching episodes list.
// Take a look at config_external API for method `external_episodes_list`.
// If the `episodes_url` not set or responds with any HTTP code other than `200` or `501` or does not respond within a timeout,
// the archive clean-up is only performed by `episodes_expiration` time while `expiration` and `storage_limit` are ignored until the `episodes_url` restores.
// If `episodes_url` is a blank string, then current config_external API endpoint will be used to request episodes.
// It is most common usage of this field.
// Examples: , http://central-host.local/config-external/episodes
func (s DvrBaseConfigImpl) EpisodesURL() *string {
	return s.EpisodesURLValue
}

// External URL that will be triggered for fetching episodes list.
// Take a look at config_external API for method `external_episodes_list`.
// If the `episodes_url` not set or responds with any HTTP code other than `200` or `501` or does not respond within a timeout,
// the archive clean-up is only performed by `episodes_expiration` time while `expiration` and `storage_limit` are ignored until the `episodes_url` restores.
// If `episodes_url` is a blank string, then current config_external API endpoint will be used to request episodes.
// It is most common usage of this field.
// Examples: , http://central-host.local/config-external/episodes
func (s *DvrBaseConfigImpl) SetEpisodesURL(v string) DvrBaseConfig {
	if s == nil {
		return nil
	}
	s.EpisodesURLValue = &v
	return s
}

// Archive depth - a period (in seconds) back from the current moment during which the
// contigious part of archive is stored.
// As time goes, the parts of the recording which are older than the archive depth are deleted.
// If you have option `episodes_expiration` enabled, then some parts of DVR that are
// locked by episode signalling mechanism may be kept more than this `expiration` depth.
// If `episodes_url` does not respond, the archive clean-up by `expiration` is not performed;
// only the archive with expired episodes (`episodes_expiration`) is cleaned up until the `episodes_url` restores.
// Format: seconds (seconds)
// Examples: 604800
func (s DvrBaseConfigImpl) Expiration() *Seconds {
	return s.ExpirationValue
}

// Archive depth - a period (in seconds) back from the current moment during which the
// contigious part of archive is stored.
// As time goes, the parts of the recording which are older than the archive depth are deleted.
// If you have option `episodes_expiration` enabled, then some parts of DVR that are
// locked by episode signalling mechanism may be kept more than this `expiration` depth.
// If `episodes_url` does not respond, the archive clean-up by `expiration` is not performed;
// only the archive with expired episodes (`episodes_expiration`) is cleaned up until the `episodes_url` restores.
// Format: seconds (seconds)
// Examples: 604800
func (s *DvrBaseConfigImpl) SetExpiration(v Seconds) DvrBaseConfig {
	if s == nil {
		return nil
	}
	s.ExpirationValue = &v
	return s
}

// One or several time intervals for recording by schedule.
// The beginning and the end of each interval are set in "hhmm" format (without leading zeros ) according to UTC standard.
// For example, `2330` is for 23:30, `800` - for 08:00. The interval can go over midnight, e.g. 22:00-1:30. In this case it is set as follows: `[2200,130]`.
// Scheduled recording can be useful for the channels with part-time broadcasting.
// It allows to save disk space significantly.
// Example: [[800 1600] [2200 130]]
func (s DvrBaseConfigImpl) Schedule() [][]int {
	return s.ScheduleValue
}

// One or several time intervals for recording by schedule.
// The beginning and the end of each interval are set in "hhmm" format (without leading zeros ) according to UTC standard.
// For example, `2330` is for 23:30, `800` - for 08:00. The interval can go over midnight, e.g. 22:00-1:30. In this case it is set as follows: `[2200,130]`.
// Scheduled recording can be useful for the channels with part-time broadcasting.
// It allows to save disk space significantly.
// Example: [[800 1600] [2200 130]]
func (s *DvrBaseConfigImpl) SetSchedule(v [][]int) DvrBaseConfig {
	if s == nil {
		return nil
	}
	s.ScheduleValue = v
	return s
}

// Maximum disk consumption in bytes. When this limit is reached,
// the oldest segment of the recording will be overridden by later data.
// This option affects both continuous recording and locked episodes (see `episodes_url`).
// If `episodes_url` does not respond, the archive clean-up by `storage_limit` is not performed
// to avoid deleting the recordings that should not be deleted.
// Format: bytes (bytes)
// Example: 4e+11
func (s DvrBaseConfigImpl) StorageLimit() *Bytes {
	return s.StorageLimitValue
}

// Maximum disk consumption in bytes. When this limit is reached,
// the oldest segment of the recording will be overridden by later data.
// This option affects both continuous recording and locked episodes (see `episodes_url`).
// If `episodes_url` does not respond, the archive clean-up by `storage_limit` is not performed
// to avoid deleting the recordings that should not be deleted.
// Format: bytes (bytes)
// Example: 4e+11
func (s *DvrBaseConfigImpl) SetStorageLimit(v Bytes) DvrBaseConfig {
	if s == nil {
		return nil
	}
	s.StorageLimitValue = &v
	return s
}

// NewDvrCapacityStats creates a new DvrCapacityStats instance
func NewDvrCapacityStats() DvrCapacityStats {
	return &DvrCapacityStatsImpl{}
}

// The number of blobs on the disk that are enlisted in individual stream indexes.
// It must be equal to blobs_count_db and can be different in case of software
// or hardware errors.
func (s DvrCapacityStatsImpl) BlobsCount() *int {
	return s.BlobsCountValue
}

// The number of blobs on the disk that are enlisted in individual stream indexes.
// It must be equal to blobs_count_db and can be different in case of software
// or hardware errors.
func (s *DvrCapacityStatsImpl) SetBlobsCount(v int) DvrCapacityStats {
	if s == nil {
		return nil
	}
	s.BlobsCountValue = &v
	return s
}

// The number of blobs on the disk according to centralized Raid DB that is
// used to allocate blobs across whole storage.
func (s DvrCapacityStatsImpl) BlobsCountDb() *int {
	return s.BlobsCountDbValue
}

// The number of blobs on the disk according to centralized Raid DB that is
// used to allocate blobs across whole storage.
func (s *DvrCapacityStatsImpl) SetBlobsCountDb(v int) DvrCapacityStats {
	if s == nil {
		return nil
	}
	s.BlobsCountDbValue = &v
	return s
}

// Disk capacity in bytes.
// Format: bytes (bytes)
func (s DvrCapacityStatsImpl) Size() *Bytes {
	return s.SizeValue
}

// Disk capacity in bytes.
// Format: bytes (bytes)
func (s *DvrCapacityStatsImpl) SetSize(v Bytes) DvrCapacityStats {
	if s == nil {
		return nil
	}
	s.SizeValue = &v
	return s
}

// Disk utilization percentage.
// Format: percent (percent)
func (s DvrCapacityStatsImpl) Usage() *Percent {
	return s.UsageValue
}

// Disk utilization percentage.
// Format: percent (percent)
func (s *DvrCapacityStatsImpl) SetUsage(v Percent) DvrCapacityStats {
	if s == nil {
		return nil
	}
	s.UsageValue = &v
	return s
}

// Used disk space in bytes according to linux metrics. It must be equal (almost equal) to
// `used_index`. If it differs more than in 1%, then it means that there are lot of unknown files.
// If this disk is used exclusively for Raid, then it may mean that some blobs are lost from
// database and repairing is required.
// Format: bytes (bytes)
func (s DvrCapacityStatsImpl) Used() *Bytes {
	return s.UsedValue
}

// Used disk space in bytes according to linux metrics. It must be equal (almost equal) to
// `used_index`. If it differs more than in 1%, then it means that there are lot of unknown files.
// If this disk is used exclusively for Raid, then it may mean that some blobs are lost from
// database and repairing is required.
// Format: bytes (bytes)
func (s *DvrCapacityStatsImpl) SetUsed(v Bytes) DvrCapacityStats {
	if s == nil {
		return nil
	}
	s.UsedValue = &v
	return s
}

// Used disk space in bytes according to internal database index.
// Format: bytes (bytes)
func (s DvrCapacityStatsImpl) UsedIndex() *Bytes {
	return s.UsedIndexValue
}

// Used disk space in bytes according to internal database index.
// Format: bytes (bytes)
func (s *DvrCapacityStatsImpl) SetUsedIndex(v Bytes) DvrCapacityStats {
	if s == nil {
		return nil
	}
	s.UsedIndexValue = &v
	return s
}

// NewDvrConfig creates a new DvrConfig instance
func NewDvrConfig() DvrConfig {
	return &DvrConfigImpl{}
}

// The number of disks to write the archive.
func (s DvrConfigImpl) Active() *int {
	return s.ActiveValue
}

// The number of disks to write the archive.
func (s *DvrConfigImpl) SetActive(v int) DvrConfig {
	if s == nil {
		return nil
	}
	s.ActiveValue = &v
	return s
}

// If this parameter is set to 'true' (by default),
// Flussonic will check if the disks were mounted properly before writing to them.
func (s DvrConfigImpl) CheckMount() *bool {
	return s.CheckMountValue
}

// If this parameter is set to 'true' (by default),
// Flussonic will check if the disks were mounted properly before writing to them.
func (s *DvrConfigImpl) SetCheckMount(v bool) DvrConfig {
	if s == nil {
		return nil
	}
	s.CheckMountValue = &v
	return s
}

// Maximum disk consumption in percents. When this limit is reached,
// the oldest segment of the recording will be overridden by later data.
// It important to understand that this is not a "per-stream" option, this option means
// that cleaning of this stream will be triggered if overall disk usage reaches this number.
// If you have all streams with configuration 98% and one stream with 95%, it will be permanently
// empty.
// Format: percent (percent)
// Example: 98
func (s DvrConfigImpl) DiskUsageLimit() *Percent {
	return s.DiskUsageLimitValue
}

// Maximum disk consumption in percents. When this limit is reached,
// the oldest segment of the recording will be overridden by later data.
// It important to understand that this is not a "per-stream" option, this option means
// that cleaning of this stream will be triggered if overall disk usage reaches this number.
// If you have all streams with configuration 98% and one stream with 95%, it will be permanently
// empty.
// Format: percent (percent)
// Example: 98
func (s *DvrConfigImpl) SetDiskUsageLimit(v Percent) DvrConfig {
	if s == nil {
		return nil
	}
	s.DiskUsageLimitValue = &v
	return s
}

// RAID disks mounted on the server.
func (s DvrConfigImpl) Disks() []RaidDiskConfig {
	if s.DisksValue == nil {
		return nil
	}
	result := make([]RaidDiskConfig, len(s.DisksValue))
	for i, item := range s.DisksValue {
		result[i] = item
	}
	return result
}

// RAID disks mounted on the server.
func (s *DvrConfigImpl) SetDisks(v []RaidDiskConfig) DvrConfig {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*RaidDiskConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*RaidDiskConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.DisksValue = impl
	}
	return s
}

// Additional archive depth in seconds for episodes. If set, episodes and their corresponding DVR record
// will be saved for `expiration + episodes_expiration` seconds.
// The archive clean-up within `[expiration, expiration+episodes_expiration]` seconds of the
// recording performed depending on [external_episodes_list](https://flussonic.com/doc/api/config-external/#tag/dvr/operation/external_episodes_list)
// response of `episodes_url`.
// Anything older than `expiration+episodes_expiration` seconds will
// be cleaned even if `episodes_url` does not respond.
// Format: seconds (seconds)
// Examples: 6.048e+06
func (s DvrConfigImpl) EpisodesExpiration() *Seconds {
	return s.EpisodesExpirationValue
}

// Additional archive depth in seconds for episodes. If set, episodes and their corresponding DVR record
// will be saved for `expiration + episodes_expiration` seconds.
// The archive clean-up within `[expiration, expiration+episodes_expiration]` seconds of the
// recording performed depending on [external_episodes_list](https://flussonic.com/doc/api/config-external/#tag/dvr/operation/external_episodes_list)
// response of `episodes_url`.
// Anything older than `expiration+episodes_expiration` seconds will
// be cleaned even if `episodes_url` does not respond.
// Format: seconds (seconds)
// Examples: 6.048e+06
func (s *DvrConfigImpl) SetEpisodesExpiration(v Seconds) DvrConfig {
	if s == nil {
		return nil
	}
	s.EpisodesExpirationValue = &v
	return s
}

// External URL that will be triggered for fetching episodes list.
// Take a look at config_external API for method `external_episodes_list`.
// If the `episodes_url` not set or responds with any HTTP code other than `200` or `501` or does not respond within a timeout,
// the archive clean-up is only performed by `episodes_expiration` time while `expiration` and `storage_limit` are ignored until the `episodes_url` restores.
// If `episodes_url` is a blank string, then current config_external API endpoint will be used to request episodes.
// It is most common usage of this field.
// Examples: , http://central-host.local/config-external/episodes
func (s DvrConfigImpl) EpisodesURL() *string {
	return s.EpisodesURLValue
}

// External URL that will be triggered for fetching episodes list.
// Take a look at config_external API for method `external_episodes_list`.
// If the `episodes_url` not set or responds with any HTTP code other than `200` or `501` or does not respond within a timeout,
// the archive clean-up is only performed by `episodes_expiration` time while `expiration` and `storage_limit` are ignored until the `episodes_url` restores.
// If `episodes_url` is a blank string, then current config_external API endpoint will be used to request episodes.
// It is most common usage of this field.
// Examples: , http://central-host.local/config-external/episodes
func (s *DvrConfigImpl) SetEpisodesURL(v string) DvrConfig {
	if s == nil {
		return nil
	}
	s.EpisodesURLValue = &v
	return s
}

// Archive depth - a period (in seconds) back from the current moment during which the
// contigious part of archive is stored.
// As time goes, the parts of the recording which are older than the archive depth are deleted.
// If you have option `episodes_expiration` enabled, then some parts of DVR that are
// locked by episode signalling mechanism may be kept more than this `expiration` depth.
// If `episodes_url` does not respond, the archive clean-up by `expiration` is not performed;
// only the archive with expired episodes (`episodes_expiration`) is cleaned up until the `episodes_url` restores.
// Format: seconds (seconds)
// Examples: 604800
func (s DvrConfigImpl) Expiration() *Seconds {
	return s.ExpirationValue
}

// Archive depth - a period (in seconds) back from the current moment during which the
// contigious part of archive is stored.
// As time goes, the parts of the recording which are older than the archive depth are deleted.
// If you have option `episodes_expiration` enabled, then some parts of DVR that are
// locked by episode signalling mechanism may be kept more than this `expiration` depth.
// If `episodes_url` does not respond, the archive clean-up by `expiration` is not performed;
// only the archive with expired episodes (`episodes_expiration`) is cleaned up until the `episodes_url` restores.
// Format: seconds (seconds)
// Examples: 604800
func (s *DvrConfigImpl) SetExpiration(v Seconds) DvrConfig {
	if s == nil {
		return nil
	}
	s.ExpirationValue = &v
	return s
}

// A directory on an SSD disk where the data will be cached.
// Format: disk_path (disk_path)
func (s DvrConfigImpl) Index() *DiskPath {
	return s.IndexValue
}

// A directory on an SSD disk where the data will be cached.
// Format: disk_path (disk_path)
func (s *DvrConfigImpl) SetIndex(v DiskPath) DvrConfig {
	if s == nil {
		return nil
	}
	s.IndexValue = &v
	return s
}

// DVR configuration name.
// Format: dvr_name (dvr_name)
func (s DvrConfigImpl) Name() DvrName {
	return s.NameValue
}

// DVR configuration name.
// Format: dvr_name (dvr_name)
func (s *DvrConfigImpl) SetName(v DvrName) DvrConfig {
	if s == nil {
		return nil
	}
	s.NameValue = v
	return s
}

// This value is present if RAID (redundant array of independent disks) is enabled. Learn more in [Flussonic RAID for DVR](https://flussonic.com/doc/extend-video-storage-on-fly/).
func (s DvrConfigImpl) Raid() *DvrRaidLevel {
	return s.RaidValue
}

// This value is present if RAID (redundant array of independent disks) is enabled. Learn more in [Flussonic RAID for DVR](https://flussonic.com/doc/extend-video-storage-on-fly/).
func (s *DvrConfigImpl) SetRaid(v DvrRaidLevel) DvrConfig {
	if s == nil {
		return nil
	}
	s.RaidValue = &v
	return s
}

// A path where the DVR archive is stored.
// Format: dvr_url (dvr_url)
func (s DvrConfigImpl) Root() DvrURL {
	return s.RootValue
}

// A path where the DVR archive is stored.
// Format: dvr_url (dvr_url)
func (s *DvrConfigImpl) SetRoot(v DvrURL) DvrConfig {
	if s == nil {
		return nil
	}
	s.RootValue = v
	return s
}

// One or several time intervals for recording by schedule.
// The beginning and the end of each interval are set in "hhmm" format (without leading zeros ) according to UTC standard.
// For example, `2330` is for 23:30, `800` - for 08:00. The interval can go over midnight, e.g. 22:00-1:30. In this case it is set as follows: `[2200,130]`.
// Scheduled recording can be useful for the channels with part-time broadcasting.
// It allows to save disk space significantly.
// Example: [[800 1600] [2200 130]]
func (s DvrConfigImpl) Schedule() [][]int {
	return s.ScheduleValue
}

// One or several time intervals for recording by schedule.
// The beginning and the end of each interval are set in "hhmm" format (without leading zeros ) according to UTC standard.
// For example, `2330` is for 23:30, `800` - for 08:00. The interval can go over midnight, e.g. 22:00-1:30. In this case it is set as follows: `[2200,130]`.
// Scheduled recording can be useful for the channels with part-time broadcasting.
// It allows to save disk space significantly.
// Example: [[800 1600] [2200 130]]
func (s *DvrConfigImpl) SetSchedule(v [][]int) DvrConfig {
	if s == nil {
		return nil
	}
	s.ScheduleValue = v
	return s
}

// The runtime statistics about DVR.
func (s DvrConfigImpl) Stats() DvrStorageConfigStats {
	return s.StatsValue
}

// The runtime statistics about DVR.
func (s *DvrConfigImpl) SetStats(v DvrStorageConfigStats) DvrConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*DvrStorageConfigStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// Maximum disk consumption in bytes. When this limit is reached,
// the oldest segment of the recording will be overridden by later data.
// This option affects both continuous recording and locked episodes (see `episodes_url`).
// If `episodes_url` does not respond, the archive clean-up by `storage_limit` is not performed
// to avoid deleting the recordings that should not be deleted.
// Format: bytes (bytes)
// Example: 4e+11
func (s DvrConfigImpl) StorageLimit() *Bytes {
	return s.StorageLimitValue
}

// Maximum disk consumption in bytes. When this limit is reached,
// the oldest segment of the recording will be overridden by later data.
// This option affects both continuous recording and locked episodes (see `episodes_url`).
// If `episodes_url` does not respond, the archive clean-up by `storage_limit` is not performed
// to avoid deleting the recordings that should not be deleted.
// Format: bytes (bytes)
// Example: 4e+11
func (s *DvrConfigImpl) SetStorageLimit(v Bytes) DvrConfig {
	if s == nil {
		return nil
	}
	s.StorageLimitValue = &v
	return s
}

// NewDvrInfo creates a new DvrInfo instance
func NewDvrInfo() DvrInfo {
	return &DvrInfoImpl{}
}

// The size of the recorded archive.
// Format: bytes (bytes)
// Example: 1.296e+11
func (s DvrInfoImpl) Bytes() *Bytes {
	return s.BytesValue
}

// The size of the recorded archive.
// Format: bytes (bytes)
// Example: 1.296e+11
func (s *DvrInfoImpl) SetBytes(v Bytes) DvrInfo {
	if s == nil {
		return nil
	}
	s.BytesValue = &v
	return s
}

// The time interval between the start of the *first* recording segment and the end of the *last* one.
// Format: seconds (seconds)
// Example: 259200
func (s DvrInfoImpl) Depth() Seconds {
	return s.DepthValue
}

// The time interval between the start of the *first* recording segment and the end of the *last* one.
// Format: seconds (seconds)
// Example: 259200
func (s *DvrInfoImpl) SetDepth(v Seconds) DvrInfo {
	if s == nil {
		return nil
	}
	s.DepthValue = v
	return s
}

// Deprecated field. Will be deleted at 25.07
// The size of the recorded archive. Please, use bytes instead.
// Format: bytes (bytes)
// Example: 1.099511627776e+12
func (s DvrInfoImpl) DiskSize() *Bytes {
	return s.DiskSizeValue
}

// Deprecated field. Will be deleted at 25.07
// The size of the recorded archive. Please, use bytes instead.
// Format: bytes (bytes)
// Example: 1.099511627776e+12
func (s *DvrInfoImpl) SetDiskSize(v Bytes) DvrInfo {
	if s == nil {
		return nil
	}
	s.DiskSizeValue = &v
	return s
}

// A total duration of the recorded segments, excluding recording gaps.
// It can be smaller than depth if you have gaps.
// Format: seconds (seconds)
// Example: 172800
func (s DvrInfoImpl) Duration() *Seconds {
	return s.DurationValue
}

// A total duration of the recorded segments, excluding recording gaps.
// It can be smaller than depth if you have gaps.
// Format: seconds (seconds)
// Example: 172800
func (s *DvrInfoImpl) SetDuration(v Seconds) DvrInfo {
	if s == nil {
		return nil
	}
	s.DurationValue = &v
	return s
}

// The UTC timestamp of the first recording in this archive.
// Format: utc (Unix timestamp in seconds)
// Example: 1.641045644e+09
func (s DvrInfoImpl) From() Utc {
	return s.FromValue
}

// The UTC timestamp of the first recording in this archive.
// Format: utc (Unix timestamp in seconds)
// Example: 1.641045644e+09
func (s *DvrInfoImpl) SetFrom(v Utc) DvrInfo {
	if s == nil {
		return nil
	}
	s.FromValue = v
	return s
}

// Deprecated field. Will be deleted at 24.09
// The list of DVR ranges. The param is replaced with `ranges_list` method.
func (s DvrInfoImpl) Ranges() []DvrRange {
	if s.RangesValue == nil {
		return nil
	}
	result := make([]DvrRange, len(s.RangesValue))
	for i, item := range s.RangesValue {
		result[i] = item
	}
	return result
}

// Deprecated field. Will be deleted at 24.09
// The list of DVR ranges. The param is replaced with `ranges_list` method.
func (s *DvrInfoImpl) SetRanges(v []DvrRange) DvrInfo {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*DvrRangeImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*DvrRangeImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.RangesValue = impl
	}
	return s
}

// NewDvrRange creates a new DvrRange instance
func NewDvrRange() DvrRange {
	return &DvrRangeImpl{}
}

// The the of the last recorded data.
// Please notice that closed_at could be changed. There are two reasons.
// - Cleaner process reduced data. Read [more](https://flussonic.com/doc/api/reference/#tag/stream/operation/stream_get/response%7Cdvr%7Cepisodes_url).
// - Recording is still working. Near real-time value means that DVR is active at the moment.
// This is a replacement for `duration` field
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s DvrRangeImpl) ClosedAt() *UtcMs {
	return s.ClosedAtValue
}

// The the of the last recorded data.
// Please notice that closed_at could be changed. There are two reasons.
// - Cleaner process reduced data. Read [more](https://flussonic.com/doc/api/reference/#tag/stream/operation/stream_get/response%7Cdvr%7Cepisodes_url).
// - Recording is still working. Near real-time value means that DVR is active at the moment.
// This is a replacement for `duration` field
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *DvrRangeImpl) SetClosedAt(v UtcMs) DvrRange {
	if s == nil {
		return nil
	}
	s.ClosedAtValue = &v
	return s
}

// Deprecated field. Will be deleted at 24.11
// The duration of the recorded DVR range.
// Use closed_at instead of this field.
// Format: seconds (seconds)
// Example: 28800
func (s DvrRangeImpl) Duration() *Seconds {
	return s.DurationValue
}

// Deprecated field. Will be deleted at 24.11
// The duration of the recorded DVR range.
// Use closed_at instead of this field.
// Format: seconds (seconds)
// Example: 28800
func (s *DvrRangeImpl) SetDuration(v Seconds) DvrRange {
	if s == nil {
		return nil
	}
	s.DurationValue = &v
	return s
}

// Deprecated field. Will be deleted at 24.11
// The beginning of the recorded DVR range. Use opened_at instead.
// Mention that opened_at has milliseconds
// Format: utc (Unix timestamp in seconds)
// Example: 1.525186456e+09
func (s DvrRangeImpl) From() *Utc {
	return s.FromValue
}

// Deprecated field. Will be deleted at 24.11
// The beginning of the recorded DVR range. Use opened_at instead.
// Mention that opened_at has milliseconds
// Format: utc (Unix timestamp in seconds)
// Example: 1.525186456e+09
func (s *DvrRangeImpl) SetFrom(v Utc) DvrRange {
	if s == nil {
		return nil
	}
	s.FromValue = &v
	return s
}

// The time when this range was started. Naming is standard for whole flussonic ecosystem.
// Is a replacement for field `from`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s DvrRangeImpl) OpenedAt() *UtcMs {
	return s.OpenedAtValue
}

// The time when this range was started. Naming is standard for whole flussonic ecosystem.
// Is a replacement for field `from`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *DvrRangeImpl) SetOpenedAt(v UtcMs) DvrRange {
	if s == nil {
		return nil
	}
	s.OpenedAtValue = &v
	return s
}

// NewDvrStorageConfig creates a new DvrStorageConfig instance
func NewDvrStorageConfig() DvrStorageConfig {
	return &DvrStorageConfigImpl{}
}

// The number of disks to write the archive.
func (s DvrStorageConfigImpl) Active() *int {
	return s.ActiveValue
}

// The number of disks to write the archive.
func (s *DvrStorageConfigImpl) SetActive(v int) DvrStorageConfig {
	if s == nil {
		return nil
	}
	s.ActiveValue = &v
	return s
}

// If this parameter is set to 'true' (by default),
// Flussonic will check if the disks were mounted properly before writing to them.
func (s DvrStorageConfigImpl) CheckMount() *bool {
	return s.CheckMountValue
}

// If this parameter is set to 'true' (by default),
// Flussonic will check if the disks were mounted properly before writing to them.
func (s *DvrStorageConfigImpl) SetCheckMount(v bool) DvrStorageConfig {
	if s == nil {
		return nil
	}
	s.CheckMountValue = &v
	return s
}

// RAID disks mounted on the server.
func (s DvrStorageConfigImpl) Disks() []RaidDiskConfig {
	if s.DisksValue == nil {
		return nil
	}
	result := make([]RaidDiskConfig, len(s.DisksValue))
	for i, item := range s.DisksValue {
		result[i] = item
	}
	return result
}

// RAID disks mounted on the server.
func (s *DvrStorageConfigImpl) SetDisks(v []RaidDiskConfig) DvrStorageConfig {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*RaidDiskConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*RaidDiskConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.DisksValue = impl
	}
	return s
}

// A directory on an SSD disk where the data will be cached.
// Format: disk_path (disk_path)
func (s DvrStorageConfigImpl) Index() *DiskPath {
	return s.IndexValue
}

// A directory on an SSD disk where the data will be cached.
// Format: disk_path (disk_path)
func (s *DvrStorageConfigImpl) SetIndex(v DiskPath) DvrStorageConfig {
	if s == nil {
		return nil
	}
	s.IndexValue = &v
	return s
}

// DVR configuration name.
// Format: dvr_name (dvr_name)
func (s DvrStorageConfigImpl) Name() DvrName {
	return s.NameValue
}

// DVR configuration name.
// Format: dvr_name (dvr_name)
func (s *DvrStorageConfigImpl) SetName(v DvrName) DvrStorageConfig {
	if s == nil {
		return nil
	}
	s.NameValue = v
	return s
}

// This value is present if RAID (redundant array of independent disks) is enabled. Learn more in [Flussonic RAID for DVR](https://flussonic.com/doc/extend-video-storage-on-fly/).
func (s DvrStorageConfigImpl) Raid() *DvrRaidLevel {
	return s.RaidValue
}

// This value is present if RAID (redundant array of independent disks) is enabled. Learn more in [Flussonic RAID for DVR](https://flussonic.com/doc/extend-video-storage-on-fly/).
func (s *DvrStorageConfigImpl) SetRaid(v DvrRaidLevel) DvrStorageConfig {
	if s == nil {
		return nil
	}
	s.RaidValue = &v
	return s
}

// A path where the DVR archive is stored.
// Format: dvr_url (dvr_url)
func (s DvrStorageConfigImpl) Root() DvrURL {
	return s.RootValue
}

// A path where the DVR archive is stored.
// Format: dvr_url (dvr_url)
func (s *DvrStorageConfigImpl) SetRoot(v DvrURL) DvrStorageConfig {
	if s == nil {
		return nil
	}
	s.RootValue = v
	return s
}

// The runtime statistics about DVR.
func (s DvrStorageConfigImpl) Stats() DvrStorageConfigStats {
	return s.StatsValue
}

// The runtime statistics about DVR.
func (s *DvrStorageConfigImpl) SetStats(v DvrStorageConfigStats) DvrStorageConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*DvrStorageConfigStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// NewDvrStorageConfigStats creates a new DvrStorageConfigStats instance
func NewDvrStorageConfigStats() DvrStorageConfigStats {
	return &DvrStorageConfigStatsImpl{}
}

// The number of blobs on the disk that are enlisted in individual stream indexes.
// It must be equal to blobs_count_db and can be different in case of software
// or hardware errors.
func (s DvrStorageConfigStatsImpl) BlobsCount() *int {
	return s.BlobsCountValue
}

// The number of blobs on the disk that are enlisted in individual stream indexes.
// It must be equal to blobs_count_db and can be different in case of software
// or hardware errors.
func (s *DvrStorageConfigStatsImpl) SetBlobsCount(v int) DvrStorageConfigStats {
	if s == nil {
		return nil
	}
	s.BlobsCountValue = &v
	return s
}

// The number of blobs on the disk according to centralized Raid DB that is
// used to allocate blobs across whole storage.
func (s DvrStorageConfigStatsImpl) BlobsCountDb() *int {
	return s.BlobsCountDbValue
}

// The number of blobs on the disk according to centralized Raid DB that is
// used to allocate blobs across whole storage.
func (s *DvrStorageConfigStatsImpl) SetBlobsCountDb(v int) DvrStorageConfigStats {
	if s == nil {
		return nil
	}
	s.BlobsCountDbValue = &v
	return s
}

// The runtime DVR errors.
func (s DvrStorageConfigStatsImpl) Errors() DvrStorageErrors {
	return s.ErrorsValue
}

// The runtime DVR errors.
func (s *DvrStorageConfigStatsImpl) SetErrors(v DvrStorageErrors) DvrStorageConfigStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*DvrStorageErrorsImpl); ok {
		s.ErrorsValue = impl
	}
	return s
}

// Disk capacity in bytes.
// Format: bytes (bytes)
func (s DvrStorageConfigStatsImpl) Size() *Bytes {
	return s.SizeValue
}

// Disk capacity in bytes.
// Format: bytes (bytes)
func (s *DvrStorageConfigStatsImpl) SetSize(v Bytes) DvrStorageConfigStats {
	if s == nil {
		return nil
	}
	s.SizeValue = &v
	return s
}

// Disk utilization percentage.
// Format: percent (percent)
func (s DvrStorageConfigStatsImpl) Usage() *Percent {
	return s.UsageValue
}

// Disk utilization percentage.
// Format: percent (percent)
func (s *DvrStorageConfigStatsImpl) SetUsage(v Percent) DvrStorageConfigStats {
	if s == nil {
		return nil
	}
	s.UsageValue = &v
	return s
}

// Used disk space in bytes according to linux metrics. It must be equal (almost equal) to
// `used_index`. If it differs more than in 1%, then it means that there are lot of unknown files.
// If this disk is used exclusively for Raid, then it may mean that some blobs are lost from
// database and repairing is required.
// Format: bytes (bytes)
func (s DvrStorageConfigStatsImpl) Used() *Bytes {
	return s.UsedValue
}

// Used disk space in bytes according to linux metrics. It must be equal (almost equal) to
// `used_index`. If it differs more than in 1%, then it means that there are lot of unknown files.
// If this disk is used exclusively for Raid, then it may mean that some blobs are lost from
// database and repairing is required.
// Format: bytes (bytes)
func (s *DvrStorageConfigStatsImpl) SetUsed(v Bytes) DvrStorageConfigStats {
	if s == nil {
		return nil
	}
	s.UsedValue = &v
	return s
}

// Used disk space in bytes according to internal database index.
// Format: bytes (bytes)
func (s DvrStorageConfigStatsImpl) UsedIndex() *Bytes {
	return s.UsedIndexValue
}

// Used disk space in bytes according to internal database index.
// Format: bytes (bytes)
func (s *DvrStorageConfigStatsImpl) SetUsedIndex(v Bytes) DvrStorageConfigStats {
	if s == nil {
		return nil
	}
	s.UsedIndexValue = &v
	return s
}

// NewDvrStorageErrors creates a new DvrStorageErrors instance
func NewDvrStorageErrors() DvrStorageErrors {
	return &DvrStorageErrorsImpl{}
}

// Total number of collapsed segments while writing to the archive. Collapsed segments are pack of segments written together occur due to lack of storage performance.
func (s DvrStorageErrorsImpl) CollapsedWriteCount() *int {
	return s.CollapsedWriteCountValue
}

// Total number of collapsed segments while writing to the archive. Collapsed segments are pack of segments written together occur due to lack of storage performance.
func (s *DvrStorageErrorsImpl) SetCollapsedWriteCount(v int) DvrStorageErrors {
	if s == nil {
		return nil
	}
	s.CollapsedWriteCountValue = &v
	return s
}

// Total number of errors while deleting from the archive.
func (s DvrStorageErrorsImpl) DeleteErrors() *int {
	return s.DeleteErrorsValue
}

// Total number of errors while deleting from the archive.
func (s *DvrStorageErrorsImpl) SetDeleteErrors(v int) DvrStorageErrors {
	if s == nil {
		return nil
	}
	s.DeleteErrorsValue = &v
	return s
}

// Total number of dropped segments while writing to the archive.
func (s DvrStorageErrorsImpl) DropWriteCount() *int {
	return s.DropWriteCountValue
}

// Total number of dropped segments while writing to the archive.
func (s *DvrStorageErrorsImpl) SetDropWriteCount(v int) DvrStorageErrors {
	if s == nil {
		return nil
	}
	s.DropWriteCountValue = &v
	return s
}

// Total number of errors while reading the archive.
func (s DvrStorageErrorsImpl) ReadErrors() *int {
	return s.ReadErrorsValue
}

// Total number of errors while reading the archive.
func (s *DvrStorageErrorsImpl) SetReadErrors(v int) DvrStorageErrors {
	if s == nil {
		return nil
	}
	s.ReadErrorsValue = &v
	return s
}

// Total number of errors while writing to the archive.
func (s DvrStorageErrorsImpl) WriteErrors() *int {
	return s.WriteErrorsValue
}

// Total number of errors while writing to the archive.
func (s *DvrStorageErrorsImpl) SetWriteErrors(v int) DvrStorageErrors {
	if s == nil {
		return nil
	}
	s.WriteErrorsValue = &v
	return s
}

// NewDvrStorageStats creates a new DvrStorageStats instance
func NewDvrStorageStats() DvrStorageStats {
	return &DvrStorageStatsImpl{}
}

// The runtime DVR errors.
func (s DvrStorageStatsImpl) Errors() DvrStorageErrors {
	return s.ErrorsValue
}

// The runtime DVR errors.
func (s *DvrStorageStatsImpl) SetErrors(v DvrStorageErrors) DvrStorageStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*DvrStorageErrorsImpl); ok {
		s.ErrorsValue = impl
	}
	return s
}

// NewEntityEvent creates a new EntityEvent instance
func NewEntityEvent() EntityEvent {
	return &EntityEventImpl{}
}

// Unique identifier of the entity.
// For example, for `agent` it is `agent_id` field.
func (s EntityEventImpl) EntityID() *string {
	return s.EntityIDValue
}

// Unique identifier of the entity.
// For example, for `agent` it is `agent_id` field.
func (s *EntityEventImpl) SetEntityID(v string) EntityEvent {
	if s == nil {
		return nil
	}
	s.EntityIDValue = &v
	return s
}

// Type of the entity.
func (s EntityEventImpl) EntityType() *EntityEventEntityType {
	return s.EntityTypeValue
}

// Type of the entity.
func (s *EntityEventImpl) SetEntityType(v EntityEventEntityType) EntityEvent {
	if s == nil {
		return nil
	}
	s.EntityTypeValue = &v
	return s
}

// Event identifier.
func (s EntityEventImpl) EventID() *int {
	return s.EventIDValue
}

// Event identifier.
func (s *EntityEventImpl) SetEventID(v int) EntityEvent {
	if s == nil {
		return nil
	}
	s.EventIDValue = &v
	return s
}

// Originator of event.
// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
// is configured as HTTP/HTTPS url.
// Example: flussonic.host
func (s EntityEventImpl) Server() *string {
	return s.ServerValue
}

// Originator of event.
// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
// is configured as HTTP/HTTPS url.
// Example: flussonic.host
func (s *EntityEventImpl) SetServer(v string) EntityEvent {
	if s == nil {
		return nil
	}
	s.ServerValue = &v
	return s
}

// Unique identifier of the operation.
// You can use this field to search for events related to same operation.
// Value of this field is taken from the `X-Trace-Id` header.
// If `X-Trace-Id` header is not set, it will be generated automatically.
// Service will use the value of this field to make outgoing requests.
// Format: uuid (uuid)
// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
func (s EntityEventImpl) TraceID() *UUID {
	return s.TraceIDValue
}

// Unique identifier of the operation.
// You can use this field to search for events related to same operation.
// Value of this field is taken from the `X-Trace-Id` header.
// If `X-Trace-Id` header is not set, it will be generated automatically.
// Service will use the value of this field to make outgoing requests.
// Format: uuid (uuid)
// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
func (s *EntityEventImpl) SetTraceID(v UUID) EntityEvent {
	if s == nil {
		return nil
	}
	s.TraceIDValue = &v
	return s
}

// The time of the event registration on the server.
// Format: utc_ms (Unix timestamp in milliseconds)
func (s EntityEventImpl) UtcMs() *UtcMs {
	return s.UtcMsValue
}

// The time of the event registration on the server.
// Format: utc_ms (Unix timestamp in milliseconds)
func (s *EntityEventImpl) SetUtcMs(v UtcMs) EntityEvent {
	if s == nil {
		return nil
	}
	s.UtcMsValue = &v
	return s
}

// NewEpisode creates a new Episode instance
func NewEpisode() Episode {
	return &EpisodeImpl{}
}

// The reason for closing the episode.
func (s EpisodeImpl) CloseReason() *EpisodeCloseReason {
	return s.CloseReasonValue
}

// The reason for closing the episode.
func (s *EpisodeImpl) SetCloseReason(v EpisodeCloseReason) Episode {
	if s == nil {
		return nil
	}
	s.CloseReasonValue = &v
	return s
}

// Episode emitter can decide that episode considered closed and will not grow further.
// `closed_at` MUST NOT change, it must be emitted only once.
// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
// of the episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s EpisodeImpl) ClosedAt() *UtcMs {
	return s.ClosedAtValue
}

// Episode emitter can decide that episode considered closed and will not grow further.
// `closed_at` MUST NOT change, it must be emitted only once.
// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
// of the episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *EpisodeImpl) SetClosedAt(v UtcMs) Episode {
	if s == nil {
		return nil
	}
	s.ClosedAtValue = &v
	return s
}

// Detections associated with this episode
func (s EpisodeImpl) Detections() any {
	return s.DetectionsValue
}

// Detections associated with this episode
func (s *EpisodeImpl) SetDetections(v any) Episode {
	if s == nil {
		return nil
	}
	s.DetectionsValue = v
	return s
}

// The time when the episode appeared in the service relative to the server time.
func (s EpisodeImpl) EpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps {
	return s.EpisodeAppearanceTimestampsValue
}

// The time when the episode appeared in the service relative to the server time.
func (s *EpisodeImpl) SetEpisodeAppearanceTimestamps(v EpisodeAppearanceTimestamps) Episode {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*EpisodeAppearanceTimestampsImpl); ok {
		s.EpisodeAppearanceTimestampsValue = impl
	}
	return s
}

// Unique identifier of the episode. Must be created by the system that first creates this episode.
// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
// handle very long integers.
// Format: snowflake_id (snowflake_id)
// Examples: 1.722279170848854e+18
func (s EpisodeImpl) EpisodeID() SnowflakeID {
	return s.EpisodeIDValue
}

// Unique identifier of the episode. Must be created by the system that first creates this episode.
// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
// handle very long integers.
// Format: snowflake_id (snowflake_id)
// Examples: 1.722279170848854e+18
func (s *EpisodeImpl) SetEpisodeID(v SnowflakeID) Episode {
	if s == nil {
		return nil
	}
	s.EpisodeIDValue = v
	return s
}

// Generic stream episode/Face is detected/Vehicle is detected/Human is detected/Episode matches context search text query/QR-code is detected/Custom episode type.
// Use this field to define your own episode types when integrating custom analytics.
// If episode type is not specified, episode will be saved with `generic` type.
func (s EpisodeImpl) EpisodeType() *string {
	return s.EpisodeTypeValue
}

// Generic stream episode/Face is detected/Vehicle is detected/Human is detected/Episode matches context search text query/QR-code is detected/Custom episode type.
// Use this field to define your own episode types when integrating custom analytics.
// If episode type is not specified, episode will be saved with `generic` type.
func (s *EpisodeImpl) SetEpisodeType(v string) Episode {
	if s == nil {
		return nil
	}
	s.EpisodeTypeValue = &v
	return s
}

// The fingerprint of the detected face
func (s EpisodeImpl) Fingerprint() VisionFaceFingerprint {
	return s.FingerprintValue
}

// The fingerprint of the detected face
func (s *EpisodeImpl) SetFingerprint(v VisionFaceFingerprint) Episode {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionFaceFingerprintImpl); ok {
		s.FingerprintValue = impl
	}
	return s
}

// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
// Format: base64 (base64)
func (s EpisodeImpl) FramePreview() *Base64 {
	return s.FramePreviewValue
}

// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
// Format: base64 (base64)
func (s *EpisodeImpl) SetFramePreview(v Base64) Episode {
	if s == nil {
		return nil
	}
	s.FramePreviewValue = &v
	return s
}

// Indicates if no license plate is detected on this vehicle
func (s EpisodeImpl) LicensePlateMissing() *bool {
	return s.LicensePlateMissingValue
}

// Indicates if no license plate is detected on this vehicle
func (s *EpisodeImpl) SetLicensePlateMissing(v bool) Episode {
	if s == nil {
		return nil
	}
	s.LicensePlateMissingValue = &v
	return s
}

// Recognized vehicle's license plate number
func (s EpisodeImpl) LicensePlateText() *string {
	return s.LicensePlateTextValue
}

// Recognized vehicle's license plate number
func (s *EpisodeImpl) SetLicensePlateText(v string) Episode {
	if s == nil {
		return nil
	}
	s.LicensePlateTextValue = &v
	return s
}

// Maximum matching score between the text query and episode.
// Examples: 0.2345
func (s EpisodeImpl) MatchScore() *float64 {
	return s.MatchScoreValue
}

// Maximum matching score between the text query and episode.
// Examples: 0.2345
func (s *EpisodeImpl) SetMatchScore(v float64) Episode {
	if s == nil {
		return nil
	}
	s.MatchScoreValue = &v
	return s
}

// List of matched persons with similarity metric.
// Videoanalytics identification service enriches episode's data and fills this field
// with the list of persons that are similar to the face detected in this episode.
func (s EpisodeImpl) MatchedPersons() []VisionPersonMatch {
	if s.MatchedPersonsValue == nil {
		return nil
	}
	result := make([]VisionPersonMatch, len(s.MatchedPersonsValue))
	for i, item := range s.MatchedPersonsValue {
		result[i] = item
	}
	return result
}

// List of matched persons with similarity metric.
// Videoanalytics identification service enriches episode's data and fills this field
// with the list of persons that are similar to the face detected in this episode.
func (s *EpisodeImpl) SetMatchedPersons(v []VisionPersonMatch) Episode {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*VisionPersonMatchImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*VisionPersonMatchImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.MatchedPersonsValue = impl
	}
	return s
}

// Stream name on which this episode exists.
// Format: media_name (media_name)
func (s EpisodeImpl) Media() MediaName {
	return s.MediaValue
}

// Stream name on which this episode exists.
// Format: media_name (media_name)
func (s *EpisodeImpl) SetMedia(v MediaName) Episode {
	if s == nil {
		return nil
	}
	s.MediaValue = v
	return s
}

// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
// sort as by `opened_at`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s EpisodeImpl) OpenedAt() UtcMs {
	return s.OpenedAtValue
}

// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
// sort as by `opened_at`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *EpisodeImpl) SetOpenedAt(v UtcMs) Episode {
	if s == nil {
		return nil
	}
	s.OpenedAtValue = v
	return s
}

// This describes the way this episode was updated, whether via an inference node or an API.
// In the case of an inference node, its hostname will be provided.
func (s EpisodeImpl) Originator() EpisodeOriginator {
	return s.OriginatorValue
}

// This describes the way this episode was updated, whether via an inference node or an API.
// In the case of an inference node, its hostname will be provided.
func (s *EpisodeImpl) SetOriginator(v EpisodeOriginator) Episode {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*EpisodeOriginatorImpl); ok {
		s.OriginatorValue = impl
	}
	return s
}

// Raw data extracted from QR-code/Custom episode payload. Use this field to provide additional information about the episode.
func (s EpisodeImpl) Payload() any {
	return s.PayloadValue
}

// Raw data extracted from QR-code/Custom episode payload. Use this field to provide additional information about the episode.
func (s *EpisodeImpl) SetPayload(v any) Episode {
	if s == nil {
		return nil
	}
	s.PayloadValue = v
	return s
}

// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// /Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Preview contains an image of person's face and has a resolution about 200 x 200 pixels with maximum size about 10 kilobytes.
// /Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Preview contains an image of vehicle's license plate and has a resolution about 160 x 64 pixels with maximum size about 10 kilobytes.
func (s EpisodeImpl) Preview() *Base64 {
	return s.PreviewValue
}

// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// /Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Preview contains an image of person's face and has a resolution about 200 x 200 pixels with maximum size about 10 kilobytes.
// /Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Preview contains an image of vehicle's license plate and has a resolution about 160 x 64 pixels with maximum size about 10 kilobytes.
func (s *EpisodeImpl) SetPreview(v Base64) Episode {
	if s == nil {
		return nil
	}
	s.PreviewValue = &v
	return s
}

// The time when the preview of this episode is available.
// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
// for details.
// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s EpisodeImpl) PreviewTimestamp() *UtcMs {
	return s.PreviewTimestampValue
}

// The time when the preview of this episode is available.
// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
// for details.
// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *EpisodeImpl) SetPreviewTimestamp(v UtcMs) Episode {
	if s == nil {
		return nil
	}
	s.PreviewTimestampValue = &v
	return s
}

// DVR recording status: fully recorded, not recorded, or partially recorded
func (s EpisodeImpl) RecordingStatus() *string {
	return s.RecordingStatusValue
}

// DVR recording status: fully recorded, not recorded, or partially recorded
func (s *EpisodeImpl) SetRecordingStatus(v string) Episode {
	if s == nil {
		return nil
	}
	s.RecordingStatusValue = &v
	return s
}

// This field can be used as indication of the fact that some system have checked and ensured that
// this episode has really started at some time, that may differ from `opened_at`.
// For example video analytics will use this field for the time when this episode was confirmed as confident.
// May be not relevant for television systems.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s EpisodeImpl) StartedAt() *UtcMs {
	return s.StartedAtValue
}

// This field can be used as indication of the fact that some system have checked and ensured that
// this episode has really started at some time, that may differ from `opened_at`.
// For example video analytics will use this field for the time when this episode was confirmed as confident.
// May be not relevant for television systems.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *EpisodeImpl) SetStartedAt(v UtcMs) Episode {
	if s == nil {
		return nil
	}
	s.StartedAtValue = &v
	return s
}

// The time of last change of the episode.
// System that processes episodes and can send them to other systems, MUST update this field
// on any changes in this episode.
// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
// this `updated_at` can be used as a sort key for fetching fresh updates.
// Consumer of the episodes can use `updated_at` in the following scenario:
// * fetch all exisiting episodes from the source
// * take biggest `updated_at` from this dataset, it will be T
// * ask source for all episodes with `updated_at > T`
// This algorithm can be used for fetching update stream from the source.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637098611e+12
func (s EpisodeImpl) UpdatedAt() UtcMs {
	return s.UpdatedAtValue
}

// The time of last change of the episode.
// System that processes episodes and can send them to other systems, MUST update this field
// on any changes in this episode.
// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
// this `updated_at` can be used as a sort key for fetching fresh updates.
// Consumer of the episodes can use `updated_at` in the following scenario:
// * fetch all exisiting episodes from the source
// * take biggest `updated_at` from this dataset, it will be T
// * ask source for all episodes with `updated_at > T`
// This algorithm can be used for fetching update stream from the source.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637098611e+12
func (s *EpisodeImpl) SetUpdatedAt(v UtcMs) Episode {
	if s == nil {
		return nil
	}
	s.UpdatedAtValue = v
	return s
}

// Emergency type of the vehicle.
func (s EpisodeImpl) VehicleEmergencySubtype() *VisionVehicleEmergencySubtype {
	return s.VehicleEmergencySubtypeValue
}

// Emergency type of the vehicle.
func (s *EpisodeImpl) SetVehicleEmergencySubtype(v VisionVehicleEmergencySubtype) Episode {
	if s == nil {
		return nil
	}
	s.VehicleEmergencySubtypeValue = &v
	return s
}

// Shows from which side the vehicle was detected.
func (s EpisodeImpl) VehicleFacingSide() *VisionVehicleFacingSide {
	return s.VehicleFacingSideValue
}

// Shows from which side the vehicle was detected.
func (s *EpisodeImpl) SetVehicleFacingSide(v VisionVehicleFacingSide) Episode {
	if s == nil {
		return nil
	}
	s.VehicleFacingSideValue = &v
	return s
}

// The purpose of the vehicle, e.g. emergency or regular.
func (s EpisodeImpl) VehiclePurpose() *VisionVehiclePurpose {
	return s.VehiclePurposeValue
}

// The purpose of the vehicle, e.g. emergency or regular.
func (s *EpisodeImpl) SetVehiclePurpose(v VisionVehiclePurpose) Episode {
	if s == nil {
		return nil
	}
	s.VehiclePurposeValue = &v
	return s
}

// NewEpisodeAppearanceTimestamps creates a new EpisodeAppearanceTimestamps instance
func NewEpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps {
	return &EpisodeAppearanceTimestampsImpl{}
}

// The time when this episode was fetched by Central.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637098611e+12
func (s EpisodeAppearanceTimestampsImpl) CentralTimestamp() *UtcMs {
	return s.CentralTimestampValue
}

// The time when this episode was fetched by Central.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637098611e+12
func (s *EpisodeAppearanceTimestampsImpl) SetCentralTimestamp(v UtcMs) EpisodeAppearanceTimestamps {
	if s == nil {
		return nil
	}
	s.CentralTimestampValue = &v
	return s
}

// The time when this episode was created in inference service.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s EpisodeAppearanceTimestampsImpl) InferenceTimestamp() *UtcMs {
	return s.InferenceTimestampValue
}

// The time when this episode was created in inference service.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s *EpisodeAppearanceTimestampsImpl) SetInferenceTimestamp(v UtcMs) EpisodeAppearanceTimestamps {
	if s == nil {
		return nil
	}
	s.InferenceTimestampValue = &v
	return s
}

// NewEpisodeBase creates a new EpisodeBase instance
func NewEpisodeBase() EpisodeBase {
	return &EpisodeBaseImpl{}
}

// The reason for closing the episode.
func (s EpisodeBaseImpl) CloseReason() *EpisodeCloseReason {
	return s.CloseReasonValue
}

// The reason for closing the episode.
func (s *EpisodeBaseImpl) SetCloseReason(v EpisodeCloseReason) EpisodeBase {
	if s == nil {
		return nil
	}
	s.CloseReasonValue = &v
	return s
}

// Episode emitter can decide that episode considered closed and will not grow further.
// `closed_at` MUST NOT change, it must be emitted only once.
// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
// of the episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s EpisodeBaseImpl) ClosedAt() *UtcMs {
	return s.ClosedAtValue
}

// Episode emitter can decide that episode considered closed and will not grow further.
// `closed_at` MUST NOT change, it must be emitted only once.
// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
// of the episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *EpisodeBaseImpl) SetClosedAt(v UtcMs) EpisodeBase {
	if s == nil {
		return nil
	}
	s.ClosedAtValue = &v
	return s
}

// The time when the episode appeared in the service relative to the server time.
func (s EpisodeBaseImpl) EpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps {
	return s.EpisodeAppearanceTimestampsValue
}

// The time when the episode appeared in the service relative to the server time.
func (s *EpisodeBaseImpl) SetEpisodeAppearanceTimestamps(v EpisodeAppearanceTimestamps) EpisodeBase {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*EpisodeAppearanceTimestampsImpl); ok {
		s.EpisodeAppearanceTimestampsValue = impl
	}
	return s
}

// Unique identifier of the episode. Must be created by the system that first creates this episode.
// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
// handle very long integers.
// Format: snowflake_id (snowflake_id)
// Examples: 1.722279170848854e+18
func (s EpisodeBaseImpl) EpisodeID() SnowflakeID {
	return s.EpisodeIDValue
}

// Unique identifier of the episode. Must be created by the system that first creates this episode.
// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
// handle very long integers.
// Format: snowflake_id (snowflake_id)
// Examples: 1.722279170848854e+18
func (s *EpisodeBaseImpl) SetEpisodeID(v SnowflakeID) EpisodeBase {
	if s == nil {
		return nil
	}
	s.EpisodeIDValue = v
	return s
}

// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
// Format: base64 (base64)
func (s EpisodeBaseImpl) FramePreview() *Base64 {
	return s.FramePreviewValue
}

// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
// Format: base64 (base64)
func (s *EpisodeBaseImpl) SetFramePreview(v Base64) EpisodeBase {
	if s == nil {
		return nil
	}
	s.FramePreviewValue = &v
	return s
}

// Stream name on which this episode exists.
// Format: media_name (media_name)
func (s EpisodeBaseImpl) Media() MediaName {
	return s.MediaValue
}

// Stream name on which this episode exists.
// Format: media_name (media_name)
func (s *EpisodeBaseImpl) SetMedia(v MediaName) EpisodeBase {
	if s == nil {
		return nil
	}
	s.MediaValue = v
	return s
}

// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
// sort as by `opened_at`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s EpisodeBaseImpl) OpenedAt() UtcMs {
	return s.OpenedAtValue
}

// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
// sort as by `opened_at`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *EpisodeBaseImpl) SetOpenedAt(v UtcMs) EpisodeBase {
	if s == nil {
		return nil
	}
	s.OpenedAtValue = v
	return s
}

// This describes the way this episode was updated, whether via an inference node or an API.
// In the case of an inference node, its hostname will be provided.
func (s EpisodeBaseImpl) Originator() EpisodeOriginator {
	return s.OriginatorValue
}

// This describes the way this episode was updated, whether via an inference node or an API.
// In the case of an inference node, its hostname will be provided.
func (s *EpisodeBaseImpl) SetOriginator(v EpisodeOriginator) EpisodeBase {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*EpisodeOriginatorImpl); ok {
		s.OriginatorValue = impl
	}
	return s
}

// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Format: base64 (base64)
func (s EpisodeBaseImpl) Preview() *Base64 {
	return s.PreviewValue
}

// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Format: base64 (base64)
func (s *EpisodeBaseImpl) SetPreview(v Base64) EpisodeBase {
	if s == nil {
		return nil
	}
	s.PreviewValue = &v
	return s
}

// The time when the preview of this episode is available.
// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
// for details.
// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s EpisodeBaseImpl) PreviewTimestamp() *UtcMs {
	return s.PreviewTimestampValue
}

// The time when the preview of this episode is available.
// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
// for details.
// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *EpisodeBaseImpl) SetPreviewTimestamp(v UtcMs) EpisodeBase {
	if s == nil {
		return nil
	}
	s.PreviewTimestampValue = &v
	return s
}

// DVR recording status: fully recorded, not recorded, or partially recorded
func (s EpisodeBaseImpl) RecordingStatus() *string {
	return s.RecordingStatusValue
}

// DVR recording status: fully recorded, not recorded, or partially recorded
func (s *EpisodeBaseImpl) SetRecordingStatus(v string) EpisodeBase {
	if s == nil {
		return nil
	}
	s.RecordingStatusValue = &v
	return s
}

// This field can be used as indication of the fact that some system have checked and ensured that
// this episode has really started at some time, that may differ from `opened_at`.
// For example video analytics will use this field for the time when this episode was confirmed as confident.
// May be not relevant for television systems.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s EpisodeBaseImpl) StartedAt() *UtcMs {
	return s.StartedAtValue
}

// This field can be used as indication of the fact that some system have checked and ensured that
// this episode has really started at some time, that may differ from `opened_at`.
// For example video analytics will use this field for the time when this episode was confirmed as confident.
// May be not relevant for television systems.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *EpisodeBaseImpl) SetStartedAt(v UtcMs) EpisodeBase {
	if s == nil {
		return nil
	}
	s.StartedAtValue = &v
	return s
}

// The time of last change of the episode.
// System that processes episodes and can send them to other systems, MUST update this field
// on any changes in this episode.
// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
// this `updated_at` can be used as a sort key for fetching fresh updates.
// Consumer of the episodes can use `updated_at` in the following scenario:
// * fetch all exisiting episodes from the source
// * take biggest `updated_at` from this dataset, it will be T
// * ask source for all episodes with `updated_at > T`
// This algorithm can be used for fetching update stream from the source.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637098611e+12
func (s EpisodeBaseImpl) UpdatedAt() UtcMs {
	return s.UpdatedAtValue
}

// The time of last change of the episode.
// System that processes episodes and can send them to other systems, MUST update this field
// on any changes in this episode.
// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
// this `updated_at` can be used as a sort key for fetching fresh updates.
// Consumer of the episodes can use `updated_at` in the following scenario:
// * fetch all exisiting episodes from the source
// * take biggest `updated_at` from this dataset, it will be T
// * ask source for all episodes with `updated_at > T`
// This algorithm can be used for fetching update stream from the source.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637098611e+12
func (s *EpisodeBaseImpl) SetUpdatedAt(v UtcMs) EpisodeBase {
	if s == nil {
		return nil
	}
	s.UpdatedAtValue = v
	return s
}

// NewEpisodeCustom creates a new EpisodeCustom instance
func NewEpisodeCustom() EpisodeCustom {
	return &EpisodeCustomImpl{}
}

// The reason for closing the episode.
func (s EpisodeCustomImpl) CloseReason() *EpisodeCloseReason {
	return s.CloseReasonValue
}

// The reason for closing the episode.
func (s *EpisodeCustomImpl) SetCloseReason(v EpisodeCloseReason) EpisodeCustom {
	if s == nil {
		return nil
	}
	s.CloseReasonValue = &v
	return s
}

// Episode emitter can decide that episode considered closed and will not grow further.
// `closed_at` MUST NOT change, it must be emitted only once.
// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
// of the episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s EpisodeCustomImpl) ClosedAt() *UtcMs {
	return s.ClosedAtValue
}

// Episode emitter can decide that episode considered closed and will not grow further.
// `closed_at` MUST NOT change, it must be emitted only once.
// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
// of the episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *EpisodeCustomImpl) SetClosedAt(v UtcMs) EpisodeCustom {
	if s == nil {
		return nil
	}
	s.ClosedAtValue = &v
	return s
}

// The time when the episode appeared in the service relative to the server time.
func (s EpisodeCustomImpl) EpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps {
	return s.EpisodeAppearanceTimestampsValue
}

// The time when the episode appeared in the service relative to the server time.
func (s *EpisodeCustomImpl) SetEpisodeAppearanceTimestamps(v EpisodeAppearanceTimestamps) EpisodeCustom {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*EpisodeAppearanceTimestampsImpl); ok {
		s.EpisodeAppearanceTimestampsValue = impl
	}
	return s
}

// Unique identifier of the episode. Must be created by the system that first creates this episode.
// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
// handle very long integers.
// Format: snowflake_id (snowflake_id)
// Examples: 1.722279170848854e+18
func (s EpisodeCustomImpl) EpisodeID() SnowflakeID {
	return s.EpisodeIDValue
}

// Unique identifier of the episode. Must be created by the system that first creates this episode.
// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
// handle very long integers.
// Format: snowflake_id (snowflake_id)
// Examples: 1.722279170848854e+18
func (s *EpisodeCustomImpl) SetEpisodeID(v SnowflakeID) EpisodeCustom {
	if s == nil {
		return nil
	}
	s.EpisodeIDValue = v
	return s
}

// Custom episode type.
// Use this field to define your own episode types when integrating custom analytics.
// If episode type is not specified, episode will be saved with `generic` type.
func (s EpisodeCustomImpl) EpisodeType() *string {
	return s.EpisodeTypeValue
}

// Custom episode type.
// Use this field to define your own episode types when integrating custom analytics.
// If episode type is not specified, episode will be saved with `generic` type.
func (s *EpisodeCustomImpl) SetEpisodeType(v string) EpisodeCustom {
	if s == nil {
		return nil
	}
	s.EpisodeTypeValue = &v
	return s
}

// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
// Format: base64 (base64)
func (s EpisodeCustomImpl) FramePreview() *Base64 {
	return s.FramePreviewValue
}

// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
// Format: base64 (base64)
func (s *EpisodeCustomImpl) SetFramePreview(v Base64) EpisodeCustom {
	if s == nil {
		return nil
	}
	s.FramePreviewValue = &v
	return s
}

// Stream name on which this episode exists.
// Format: media_name (media_name)
func (s EpisodeCustomImpl) Media() MediaName {
	return s.MediaValue
}

// Stream name on which this episode exists.
// Format: media_name (media_name)
func (s *EpisodeCustomImpl) SetMedia(v MediaName) EpisodeCustom {
	if s == nil {
		return nil
	}
	s.MediaValue = v
	return s
}

// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
// sort as by `opened_at`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s EpisodeCustomImpl) OpenedAt() UtcMs {
	return s.OpenedAtValue
}

// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
// sort as by `opened_at`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *EpisodeCustomImpl) SetOpenedAt(v UtcMs) EpisodeCustom {
	if s == nil {
		return nil
	}
	s.OpenedAtValue = v
	return s
}

// This describes the way this episode was updated, whether via an inference node or an API.
// In the case of an inference node, its hostname will be provided.
func (s EpisodeCustomImpl) Originator() EpisodeOriginator {
	return s.OriginatorValue
}

// This describes the way this episode was updated, whether via an inference node or an API.
// In the case of an inference node, its hostname will be provided.
func (s *EpisodeCustomImpl) SetOriginator(v EpisodeOriginator) EpisodeCustom {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*EpisodeOriginatorImpl); ok {
		s.OriginatorValue = impl
	}
	return s
}

// Custom episode payload. Use this field to provide additional information about the episode.
func (s EpisodeCustomImpl) Payload() any {
	return s.PayloadValue
}

// Custom episode payload. Use this field to provide additional information about the episode.
func (s *EpisodeCustomImpl) SetPayload(v any) EpisodeCustom {
	if s == nil {
		return nil
	}
	s.PayloadValue = v
	return s
}

// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Format: base64 (base64)
func (s EpisodeCustomImpl) Preview() *Base64 {
	return s.PreviewValue
}

// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Format: base64 (base64)
func (s *EpisodeCustomImpl) SetPreview(v Base64) EpisodeCustom {
	if s == nil {
		return nil
	}
	s.PreviewValue = &v
	return s
}

// The time when the preview of this episode is available.
// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
// for details.
// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s EpisodeCustomImpl) PreviewTimestamp() *UtcMs {
	return s.PreviewTimestampValue
}

// The time when the preview of this episode is available.
// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
// for details.
// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *EpisodeCustomImpl) SetPreviewTimestamp(v UtcMs) EpisodeCustom {
	if s == nil {
		return nil
	}
	s.PreviewTimestampValue = &v
	return s
}

// DVR recording status: fully recorded, not recorded, or partially recorded
func (s EpisodeCustomImpl) RecordingStatus() *string {
	return s.RecordingStatusValue
}

// DVR recording status: fully recorded, not recorded, or partially recorded
func (s *EpisodeCustomImpl) SetRecordingStatus(v string) EpisodeCustom {
	if s == nil {
		return nil
	}
	s.RecordingStatusValue = &v
	return s
}

// This field can be used as indication of the fact that some system have checked and ensured that
// this episode has really started at some time, that may differ from `opened_at`.
// For example video analytics will use this field for the time when this episode was confirmed as confident.
// May be not relevant for television systems.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s EpisodeCustomImpl) StartedAt() *UtcMs {
	return s.StartedAtValue
}

// This field can be used as indication of the fact that some system have checked and ensured that
// this episode has really started at some time, that may differ from `opened_at`.
// For example video analytics will use this field for the time when this episode was confirmed as confident.
// May be not relevant for television systems.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *EpisodeCustomImpl) SetStartedAt(v UtcMs) EpisodeCustom {
	if s == nil {
		return nil
	}
	s.StartedAtValue = &v
	return s
}

// The time of last change of the episode.
// System that processes episodes and can send them to other systems, MUST update this field
// on any changes in this episode.
// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
// this `updated_at` can be used as a sort key for fetching fresh updates.
// Consumer of the episodes can use `updated_at` in the following scenario:
// * fetch all exisiting episodes from the source
// * take biggest `updated_at` from this dataset, it will be T
// * ask source for all episodes with `updated_at > T`
// This algorithm can be used for fetching update stream from the source.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637098611e+12
func (s EpisodeCustomImpl) UpdatedAt() UtcMs {
	return s.UpdatedAtValue
}

// The time of last change of the episode.
// System that processes episodes and can send them to other systems, MUST update this field
// on any changes in this episode.
// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
// this `updated_at` can be used as a sort key for fetching fresh updates.
// Consumer of the episodes can use `updated_at` in the following scenario:
// * fetch all exisiting episodes from the source
// * take biggest `updated_at` from this dataset, it will be T
// * ask source for all episodes with `updated_at > T`
// This algorithm can be used for fetching update stream from the source.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637098611e+12
func (s *EpisodeCustomImpl) SetUpdatedAt(v UtcMs) EpisodeCustom {
	if s == nil {
		return nil
	}
	s.UpdatedAtValue = v
	return s
}

// NewEpisodeGeneric creates a new EpisodeGeneric instance
func NewEpisodeGeneric() EpisodeGeneric {
	return &EpisodeGenericImpl{}
}

// The reason for closing the episode.
func (s EpisodeGenericImpl) CloseReason() *EpisodeCloseReason {
	return s.CloseReasonValue
}

// The reason for closing the episode.
func (s *EpisodeGenericImpl) SetCloseReason(v EpisodeCloseReason) EpisodeGeneric {
	if s == nil {
		return nil
	}
	s.CloseReasonValue = &v
	return s
}

// Episode emitter can decide that episode considered closed and will not grow further.
// `closed_at` MUST NOT change, it must be emitted only once.
// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
// of the episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s EpisodeGenericImpl) ClosedAt() *UtcMs {
	return s.ClosedAtValue
}

// Episode emitter can decide that episode considered closed and will not grow further.
// `closed_at` MUST NOT change, it must be emitted only once.
// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
// of the episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *EpisodeGenericImpl) SetClosedAt(v UtcMs) EpisodeGeneric {
	if s == nil {
		return nil
	}
	s.ClosedAtValue = &v
	return s
}

// The time when the episode appeared in the service relative to the server time.
func (s EpisodeGenericImpl) EpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps {
	return s.EpisodeAppearanceTimestampsValue
}

// The time when the episode appeared in the service relative to the server time.
func (s *EpisodeGenericImpl) SetEpisodeAppearanceTimestamps(v EpisodeAppearanceTimestamps) EpisodeGeneric {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*EpisodeAppearanceTimestampsImpl); ok {
		s.EpisodeAppearanceTimestampsValue = impl
	}
	return s
}

// Unique identifier of the episode. Must be created by the system that first creates this episode.
// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
// handle very long integers.
// Format: snowflake_id (snowflake_id)
// Examples: 1.722279170848854e+18
func (s EpisodeGenericImpl) EpisodeID() SnowflakeID {
	return s.EpisodeIDValue
}

// Unique identifier of the episode. Must be created by the system that first creates this episode.
// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
// handle very long integers.
// Format: snowflake_id (snowflake_id)
// Examples: 1.722279170848854e+18
func (s *EpisodeGenericImpl) SetEpisodeID(v SnowflakeID) EpisodeGeneric {
	if s == nil {
		return nil
	}
	s.EpisodeIDValue = v
	return s
}

// Generic stream episode
func (s EpisodeGenericImpl) EpisodeType() *string {
	return s.EpisodeTypeValue
}

// Generic stream episode
func (s *EpisodeGenericImpl) SetEpisodeType(v string) EpisodeGeneric {
	if s == nil {
		return nil
	}
	s.EpisodeTypeValue = &v
	return s
}

// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
// Format: base64 (base64)
func (s EpisodeGenericImpl) FramePreview() *Base64 {
	return s.FramePreviewValue
}

// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
// Format: base64 (base64)
func (s *EpisodeGenericImpl) SetFramePreview(v Base64) EpisodeGeneric {
	if s == nil {
		return nil
	}
	s.FramePreviewValue = &v
	return s
}

// Stream name on which this episode exists.
// Format: media_name (media_name)
func (s EpisodeGenericImpl) Media() MediaName {
	return s.MediaValue
}

// Stream name on which this episode exists.
// Format: media_name (media_name)
func (s *EpisodeGenericImpl) SetMedia(v MediaName) EpisodeGeneric {
	if s == nil {
		return nil
	}
	s.MediaValue = v
	return s
}

// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
// sort as by `opened_at`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s EpisodeGenericImpl) OpenedAt() UtcMs {
	return s.OpenedAtValue
}

// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
// sort as by `opened_at`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *EpisodeGenericImpl) SetOpenedAt(v UtcMs) EpisodeGeneric {
	if s == nil {
		return nil
	}
	s.OpenedAtValue = v
	return s
}

// This describes the way this episode was updated, whether via an inference node or an API.
// In the case of an inference node, its hostname will be provided.
func (s EpisodeGenericImpl) Originator() EpisodeOriginator {
	return s.OriginatorValue
}

// This describes the way this episode was updated, whether via an inference node or an API.
// In the case of an inference node, its hostname will be provided.
func (s *EpisodeGenericImpl) SetOriginator(v EpisodeOriginator) EpisodeGeneric {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*EpisodeOriginatorImpl); ok {
		s.OriginatorValue = impl
	}
	return s
}

// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Format: base64 (base64)
func (s EpisodeGenericImpl) Preview() *Base64 {
	return s.PreviewValue
}

// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Format: base64 (base64)
func (s *EpisodeGenericImpl) SetPreview(v Base64) EpisodeGeneric {
	if s == nil {
		return nil
	}
	s.PreviewValue = &v
	return s
}

// The time when the preview of this episode is available.
// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
// for details.
// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s EpisodeGenericImpl) PreviewTimestamp() *UtcMs {
	return s.PreviewTimestampValue
}

// The time when the preview of this episode is available.
// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
// for details.
// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *EpisodeGenericImpl) SetPreviewTimestamp(v UtcMs) EpisodeGeneric {
	if s == nil {
		return nil
	}
	s.PreviewTimestampValue = &v
	return s
}

// DVR recording status: fully recorded, not recorded, or partially recorded
func (s EpisodeGenericImpl) RecordingStatus() *string {
	return s.RecordingStatusValue
}

// DVR recording status: fully recorded, not recorded, or partially recorded
func (s *EpisodeGenericImpl) SetRecordingStatus(v string) EpisodeGeneric {
	if s == nil {
		return nil
	}
	s.RecordingStatusValue = &v
	return s
}

// This field can be used as indication of the fact that some system have checked and ensured that
// this episode has really started at some time, that may differ from `opened_at`.
// For example video analytics will use this field for the time when this episode was confirmed as confident.
// May be not relevant for television systems.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s EpisodeGenericImpl) StartedAt() *UtcMs {
	return s.StartedAtValue
}

// This field can be used as indication of the fact that some system have checked and ensured that
// this episode has really started at some time, that may differ from `opened_at`.
// For example video analytics will use this field for the time when this episode was confirmed as confident.
// May be not relevant for television systems.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *EpisodeGenericImpl) SetStartedAt(v UtcMs) EpisodeGeneric {
	if s == nil {
		return nil
	}
	s.StartedAtValue = &v
	return s
}

// The time of last change of the episode.
// System that processes episodes and can send them to other systems, MUST update this field
// on any changes in this episode.
// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
// this `updated_at` can be used as a sort key for fetching fresh updates.
// Consumer of the episodes can use `updated_at` in the following scenario:
// * fetch all exisiting episodes from the source
// * take biggest `updated_at` from this dataset, it will be T
// * ask source for all episodes with `updated_at > T`
// This algorithm can be used for fetching update stream from the source.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637098611e+12
func (s EpisodeGenericImpl) UpdatedAt() UtcMs {
	return s.UpdatedAtValue
}

// The time of last change of the episode.
// System that processes episodes and can send them to other systems, MUST update this field
// on any changes in this episode.
// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
// this `updated_at` can be used as a sort key for fetching fresh updates.
// Consumer of the episodes can use `updated_at` in the following scenario:
// * fetch all exisiting episodes from the source
// * take biggest `updated_at` from this dataset, it will be T
// * ask source for all episodes with `updated_at > T`
// This algorithm can be used for fetching update stream from the source.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637098611e+12
func (s *EpisodeGenericImpl) SetUpdatedAt(v UtcMs) EpisodeGeneric {
	if s == nil {
		return nil
	}
	s.UpdatedAtValue = v
	return s
}

// NewEpisodeOriginator creates a new EpisodeOriginator instance
func NewEpisodeOriginator() EpisodeOriginator {
	return &EpisodeOriginatorImpl{}
}

// This field will provide hostname if the source is an inference node or motion detector.
// Example: example.com
func (s EpisodeOriginatorImpl) Hostname() *string {
	return s.HostnameValue
}

// This field will provide hostname if the source is an inference node or motion detector.
// Example: example.com
func (s *EpisodeOriginatorImpl) SetHostname(v string) EpisodeOriginator {
	if s == nil {
		return nil
	}
	s.HostnameValue = &v
	return s
}

func (s EpisodeOriginatorImpl) Source() EpisodeOriginatorSource {
	return s.SourceValue
}

func (s *EpisodeOriginatorImpl) SetSource(v EpisodeOriginatorSource) EpisodeOriginator {
	if s == nil {
		return nil
	}
	s.SourceValue = v
	return s
}

// NewEpisodesList creates a new EpisodesList instance
func NewEpisodesList() EpisodesList {
	return &EpisodesListImpl{}
}

// The list of Episodes fetched according to the query parameters.
func (s EpisodesListImpl) Episodes() []Episode {
	if s.EpisodesValue == nil {
		return nil
	}
	result := make([]Episode, len(s.EpisodesValue))
	for i, item := range s.EpisodesValue {
		result[i] = item
	}
	return result
}

// The list of Episodes fetched according to the query parameters.
func (s *EpisodesListImpl) SetEpisodes(v []Episode) EpisodesList {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*EpisodeImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*EpisodeImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.EpisodesValue = impl
	}
	return s
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s EpisodesListImpl) EstimatedCount() *int {
	return s.EstimatedCountValue
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s *EpisodesListImpl) SetEstimatedCount(v int) EpisodesList {
	if s == nil {
		return nil
	}
	s.EstimatedCountValue = &v
	return s
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s EpisodesListImpl) Next() *string {
	return s.NextValue
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s *EpisodesListImpl) SetNext(v string) EpisodesList {
	if s == nil {
		return nil
	}
	s.NextValue = &v
	return s
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s EpisodesListImpl) Prev() *string {
	return s.PrevValue
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s *EpisodesListImpl) SetPrev(v string) EpisodesList {
	if s == nil {
		return nil
	}
	s.PrevValue = &v
	return s
}

// An object with a list of different timings measured during this API call.
func (s EpisodesListImpl) Timing() any {
	return s.TimingValue
}

// An object with a list of different timings measured during this API call.
func (s *EpisodesListImpl) SetTiming(v any) EpisodesList {
	if s == nil {
		return nil
	}
	s.TimingValue = v
	return s
}

// Collection returns the collection items from EpisodesList
func (s EpisodesListImpl) Collection() []Episode {
	return s.Episodes()
}

// NewError creates a new Error instance
func NewError() Error {
	return &ErrorImpl{}
}

// an application-specific error code, expressed as a string value
func (s ErrorImpl) Code() *string {
	return s.CodeValue
}

// an application-specific error code, expressed as a string value
func (s *ErrorImpl) SetCode(v string) Error {
	if s == nil {
		return nil
	}
	s.CodeValue = &v
	return s
}

// a unique identifier for this particular occurrence of the problem
func (s ErrorImpl) ID() *string {
	return s.IDValue
}

// a unique identifier for this particular occurrence of the problem
func (s *ErrorImpl) SetID(v string) Error {
	if s == nil {
		return nil
	}
	s.IDValue = &v
	return s
}

// a meta object containing non-standard meta-information about the error.
func (s ErrorImpl) Meta() map[string]string {
	return s.MetaValue
}

// a meta object containing non-standard meta-information about the error.
func (s *ErrorImpl) SetMeta(v map[string]string) Error {
	if s == nil {
		return nil
	}
	s.MetaValue = v
	return s
}

// an object containing references to the source of the error
func (s ErrorImpl) Source() ErrorSource {
	return s.SourceValue
}

// an object containing references to the source of the error
func (s *ErrorImpl) SetSource(v ErrorSource) Error {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ErrorSourceImpl); ok {
		s.SourceValue = impl
	}
	return s
}

// the HTTP status code applicable to this problem, expressed as a string value
func (s ErrorImpl) Status() *string {
	return s.StatusValue
}

// the HTTP status code applicable to this problem, expressed as a string value
func (s *ErrorImpl) SetStatus(v string) Error {
	if s == nil {
		return nil
	}
	s.StatusValue = &v
	return s
}

// a short, human-readable summary of the problem that SHOULD NOT change from
// occurrence to occurrence of the problem, except for purposes of localization
func (s ErrorImpl) Title() *string {
	return s.TitleValue
}

// a short, human-readable summary of the problem that SHOULD NOT change from
// occurrence to occurrence of the problem, except for purposes of localization
func (s *ErrorImpl) SetTitle(v string) Error {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// NewErrorResponse creates a new ErrorResponse instance
func NewErrorResponse() ErrorResponse {
	return &ErrorResponseImpl{}
}

// List of structured errors
func (s ErrorResponseImpl) Errors() []Error {
	if s.ErrorsValue == nil {
		return nil
	}
	result := make([]Error, len(s.ErrorsValue))
	for i, item := range s.ErrorsValue {
		result[i] = item
	}
	return result
}

// List of structured errors
func (s *ErrorResponseImpl) SetErrors(v []Error) ErrorResponse {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*ErrorImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*ErrorImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.ErrorsValue = impl
	}
	return s
}

// NewErrorSource creates a new ErrorSource instance
func NewErrorSource() ErrorSource {
	return &ErrorSourceImpl{}
}

// a string indicating which URI query parameter caused the error.
func (s ErrorSourceImpl) Parameter() *string {
	return s.ParameterValue
}

// a string indicating which URI query parameter caused the error.
func (s *ErrorSourceImpl) SetParameter(v string) ErrorSource {
	if s == nil {
		return nil
	}
	s.ParameterValue = &v
	return s
}

// a JSON Pointer [RFC6901] to the associated entity in the request document
// [e.g. `"/data"` for a primary data object, or `"/data/attributes/title"` for a specific attribute].
func (s ErrorSourceImpl) Pointer() *string {
	return s.PointerValue
}

// a JSON Pointer [RFC6901] to the associated entity in the request document
// [e.g. `"/data"` for a primary data object, or `"/data/attributes/title"` for a specific attribute].
func (s *ErrorSourceImpl) SetPointer(v string) ErrorSource {
	if s == nil {
		return nil
	}
	s.PointerValue = &v
	return s
}

// NewEventDefault creates a new EventDefault instance
func NewEventDefault() EventDefault {
	return &EventDefaultImpl{}
}

// Event identifier.
func (s EventDefaultImpl) EventID() *int {
	return s.EventIDValue
}

// Event identifier.
func (s *EventDefaultImpl) SetEventID(v int) EventDefault {
	if s == nil {
		return nil
	}
	s.EventIDValue = &v
	return s
}

// Originator of event.
// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
// is configured as HTTP/HTTPS url.
// Example: flussonic.host
func (s EventDefaultImpl) Server() *string {
	return s.ServerValue
}

// Originator of event.
// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
// is configured as HTTP/HTTPS url.
// Example: flussonic.host
func (s *EventDefaultImpl) SetServer(v string) EventDefault {
	if s == nil {
		return nil
	}
	s.ServerValue = &v
	return s
}

// Unique identifier of the operation.
// You can use this field to search for events related to same operation.
// Value of this field is taken from the `X-Trace-Id` header.
// If `X-Trace-Id` header is not set, it will be generated automatically.
// Service will use the value of this field to make outgoing requests.
// Format: uuid (uuid)
// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
func (s EventDefaultImpl) TraceID() *UUID {
	return s.TraceIDValue
}

// Unique identifier of the operation.
// You can use this field to search for events related to same operation.
// Value of this field is taken from the `X-Trace-Id` header.
// If `X-Trace-Id` header is not set, it will be generated automatically.
// Service will use the value of this field to make outgoing requests.
// Format: uuid (uuid)
// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
func (s *EventDefaultImpl) SetTraceID(v UUID) EventDefault {
	if s == nil {
		return nil
	}
	s.TraceIDValue = &v
	return s
}

// The time of the event registration on the server.
// Format: utc_ms (Unix timestamp in milliseconds)
func (s EventDefaultImpl) UtcMs() *UtcMs {
	return s.UtcMsValue
}

// The time of the event registration on the server.
// Format: utc_ms (Unix timestamp in milliseconds)
func (s *EventDefaultImpl) SetUtcMs(v UtcMs) EventDefault {
	if s == nil {
		return nil
	}
	s.UtcMsValue = &v
	return s
}

// NewEventSinkConfig creates a new EventSinkConfig instance
func NewEventSinkConfig() EventSinkConfig {
	return &EventSinkConfigImpl{}
}

// If specified, only the events that match **every** filter in the filter set will not be be passed to the event sink target.
// That is, if even one of the conditions is not satisfied, an event will be processed.
// Each filter (condition) has several possible values. For an event to satisfy the condition,
// an event should match **any** of the specified values, not all of them.
// Examples: [map[event:[stream_stopped, stream_started, source_*]]]
func (s EventSinkConfigImpl) Except() []map[string][]string {
	return s.ExceptValue
}

// If specified, only the events that match **every** filter in the filter set will not be be passed to the event sink target.
// That is, if even one of the conditions is not satisfied, an event will be processed.
// Each filter (condition) has several possible values. For an event to satisfy the condition,
// an event should match **any** of the specified values, not all of them.
// Examples: [map[event:[stream_stopped, stream_started, source_*]]]
func (s *EventSinkConfigImpl) SetExcept(v []map[string][]string) EventSinkConfig {
	if s == nil {
		return nil
	}
	s.ExceptValue = v
	return s
}

// Some additional options.
func (s EventSinkConfigImpl) Extra() map[string]string {
	return s.ExtraValue
}

// Some additional options.
func (s *EventSinkConfigImpl) SetExtra(v map[string]string) EventSinkConfig {
	if s == nil {
		return nil
	}
	s.ExtraValue = v
	return s
}

// Specify logging level for this sink. Anything more verbose than it will not get into this sink.
func (s EventSinkConfigImpl) Level() *Loglevel {
	return s.LevelValue
}

// Specify logging level for this sink. Anything more verbose than it will not get into this sink.
func (s *EventSinkConfigImpl) SetLevel(v Loglevel) EventSinkConfig {
	if s == nil {
		return nil
	}
	s.LevelValue = &v
	return s
}

// Maximal number of log files with events (JSON or text) that can be stored on a disk.
// When this limit is reached, log rotation is performed: the oldest files will be overridden by later data.
// Example: 100
func (s EventSinkConfigImpl) MaxDepth() *int {
	return s.MaxDepthValue
}

// Maximal number of log files with events (JSON or text) that can be stored on a disk.
// When this limit is reached, log rotation is performed: the oldest files will be overridden by later data.
// Example: 100
func (s *EventSinkConfigImpl) SetMaxDepth(v int) EventSinkConfig {
	if s == nil {
		return nil
	}
	s.MaxDepthValue = &v
	return s
}

// Maximum size of a log file.
// When this limit is reached, log rotation is performed: the oldest events will be overridden by later data.
// Format: bytes (bytes)
// Example: 10000
func (s EventSinkConfigImpl) MaxSize() *Bytes {
	return s.MaxSizeValue
}

// Maximum size of a log file.
// When this limit is reached, log rotation is performed: the oldest events will be overridden by later data.
// Format: bytes (bytes)
// Example: 10000
func (s *EventSinkConfigImpl) SetMaxSize(v Bytes) EventSinkConfig {
	if s == nil {
		return nil
	}
	s.MaxSizeValue = &v
	return s
}

// Globally unique event sink name.
// Format: event_sink_name (event_sink_name)
// Example: my_json_sink
func (s EventSinkConfigImpl) Name() EventSinkName {
	return s.NameValue
}

// Globally unique event sink name.
// Format: event_sink_name (event_sink_name)
// Example: my_json_sink
func (s *EventSinkConfigImpl) SetName(v EventSinkName) EventSinkConfig {
	if s == nil {
		return nil
	}
	s.NameValue = v
	return s
}

// If specified, only the events that match **every** filter in the filter set will be passed to the event sink target.
// That is, if even one of the conditions is not satisfied, an event will **not** be processed.
// Each filter (condition) has several possible values. For an event to satisfy the condition,
// an event should match **any** of the specified values, not all of them.
// Examples: [map[event:[listener_start], group:[system_overloaded]]]
func (s EventSinkConfigImpl) Only() []map[string][]string {
	return s.OnlyValue
}

// If specified, only the events that match **every** filter in the filter set will be passed to the event sink target.
// That is, if even one of the conditions is not satisfied, an event will **not** be processed.
// Each filter (condition) has several possible values. For an event to satisfy the condition,
// an event should match **any** of the specified values, not all of them.
// Examples: [map[event:[listener_start], group:[system_overloaded]]]
func (s *EventSinkConfigImpl) SetOnly(v []map[string][]string) EventSinkConfig {
	if s == nil {
		return nil
	}
	s.OnlyValue = v
	return s
}

// If an error occurs (`HTTP 500` or any other error), then *Flussonic* will try to buffer events and send them later.
// The option defines the **number** of events to keep in memory for further delivery.
// The default value is `unlimited`.
// Example: 1000
func (s EventSinkConfigImpl) ResendLimit() *int {
	return s.ResendLimitValue
}

// If an error occurs (`HTTP 500` or any other error), then *Flussonic* will try to buffer events and send them later.
// The option defines the **number** of events to keep in memory for further delivery.
// The default value is `unlimited`.
// Example: 1000
func (s *EventSinkConfigImpl) SetResendLimit(v int) EventSinkConfig {
	if s == nil {
		return nil
	}
	s.ResendLimitValue = &v
	return s
}

// How often *Flussonic* will try to resend non-confirmed events to the handler (in seconds).
// Example: 10
func (s EventSinkConfigImpl) ResendTimeout() *int {
	return s.ResendTimeoutValue
}

// How often *Flussonic* will try to resend non-confirmed events to the handler (in seconds).
// Example: 10
func (s *EventSinkConfigImpl) SetResendTimeout(v int) EventSinkConfig {
	if s == nil {
		return nil
	}
	s.ResendTimeoutValue = &v
	return s
}

// The delay (in seconds) before sending an event to the sink after saving it into the buffer.
// This parameter allows to lower frequency of sending events.
// If there are more than 100 events in the buffer, all of them will be sent to the sink without any delay.
// Format: seconds (seconds)
// Example: 1
func (s EventSinkConfigImpl) ThrottleDelay() *Seconds {
	return s.ThrottleDelayValue
}

// The delay (in seconds) before sending an event to the sink after saving it into the buffer.
// This parameter allows to lower frequency of sending events.
// If there are more than 100 events in the buffer, all of them will be sent to the sink without any delay.
// Format: seconds (seconds)
// Example: 1
func (s *EventSinkConfigImpl) SetThrottleDelay(v Seconds) EventSinkConfig {
	if s == nil {
		return nil
	}
	s.ThrottleDelayValue = &v
	return s
}

// Path where events are sent.
// * For event handler, it is the URL of an HTTP handler or the path to a lua script:  `http://URL`, `https://URL`, or `path_to_lua_script.lua`.
// * For event logging, it is the path to a log file (human-readable text file or JSON): `log://path_to_log_file.log` or `jsonlog://path_to_log_file.json`.
// Pattern: ^(log|jsonlog|http|https)://.+$|^pid://<[0-9]+\.[0-9]+\.[0-9]+>$
// Example: jsonlog:///var/log/events-json.log
func (s EventSinkConfigImpl) URL() string {
	return s.URLValue
}

// Path where events are sent.
// * For event handler, it is the URL of an HTTP handler or the path to a lua script:  `http://URL`, `https://URL`, or `path_to_lua_script.lua`.
// * For event logging, it is the path to a log file (human-readable text file or JSON): `log://path_to_log_file.log` or `jsonlog://path_to_log_file.json`.
// Pattern: ^(log|jsonlog|http|https)://.+$|^pid://<[0-9]+\.[0-9]+\.[0-9]+>$
// Example: jsonlog:///var/log/events-json.log
func (s *EventSinkConfigImpl) SetURL(v string) EventSinkConfig {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// NewExternalEpisode creates a new ExternalEpisode instance
func NewExternalEpisode() ExternalEpisode {
	return &ExternalEpisodeImpl{}
}

// The time when this episode was closed.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s ExternalEpisodeImpl) ClosedAt() *UtcMs {
	return s.ClosedAtValue
}

// The time when this episode was closed.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s *ExternalEpisodeImpl) SetClosedAt(v UtcMs) ExternalEpisode {
	if s == nil {
		return nil
	}
	s.ClosedAtValue = &v
	return s
}

// The time when this episode was created.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s ExternalEpisodeImpl) OpenedAt() UtcMs {
	return s.OpenedAtValue
}

// The time when this episode was created.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s *ExternalEpisodeImpl) SetOpenedAt(v UtcMs) ExternalEpisode {
	if s == nil {
		return nil
	}
	s.OpenedAtValue = v
	return s
}

// The time of last detection associated with this episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637098611e+12
func (s ExternalEpisodeImpl) UpdatedAt() UtcMs {
	return s.UpdatedAtValue
}

// The time of last detection associated with this episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637098611e+12
func (s *ExternalEpisodeImpl) SetUpdatedAt(v UtcMs) ExternalEpisode {
	if s == nil {
		return nil
	}
	s.UpdatedAtValue = v
	return s
}

// NewExternalEpisodesList creates a new ExternalEpisodesList instance
func NewExternalEpisodesList() ExternalEpisodesList {
	return &ExternalEpisodesListImpl{}
}

// The list of Episodes fetched according to the query parameters.
func (s ExternalEpisodesListImpl) Episodes() []ExternalEpisode {
	if s.EpisodesValue == nil {
		return nil
	}
	result := make([]ExternalEpisode, len(s.EpisodesValue))
	for i, item := range s.EpisodesValue {
		result[i] = item
	}
	return result
}

// The list of Episodes fetched according to the query parameters.
func (s *ExternalEpisodesListImpl) SetEpisodes(v []ExternalEpisode) ExternalEpisodesList {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*ExternalEpisodeImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*ExternalEpisodeImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.EpisodesValue = impl
	}
	return s
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s ExternalEpisodesListImpl) EstimatedCount() *int {
	return s.EstimatedCountValue
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s *ExternalEpisodesListImpl) SetEstimatedCount(v int) ExternalEpisodesList {
	if s == nil {
		return nil
	}
	s.EstimatedCountValue = &v
	return s
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s ExternalEpisodesListImpl) Next() *string {
	return s.NextValue
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s *ExternalEpisodesListImpl) SetNext(v string) ExternalEpisodesList {
	if s == nil {
		return nil
	}
	s.NextValue = &v
	return s
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s ExternalEpisodesListImpl) Prev() *string {
	return s.PrevValue
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s *ExternalEpisodesListImpl) SetPrev(v string) ExternalEpisodesList {
	if s == nil {
		return nil
	}
	s.PrevValue = &v
	return s
}

// An object with a list of different timings measured during this API call.
func (s ExternalEpisodesListImpl) Timing() any {
	return s.TimingValue
}

// An object with a list of different timings measured during this API call.
func (s *ExternalEpisodesListImpl) SetTiming(v any) ExternalEpisodesList {
	if s == nil {
		return nil
	}
	s.TimingValue = v
	return s
}

// Collection returns the collection items from ExternalEpisodesList
func (s ExternalEpisodesListImpl) Collection() []ExternalEpisode {
	return s.Episodes()
}

// NewForwardPortsConfig creates a new ForwardPortsConfig instance
func NewForwardPortsConfig() ForwardPortsConfig {
	return &ForwardPortsConfigImpl{}
}

// The handler name.
func (s ForwardPortsConfigImpl) Handler() *string {
	return s.HandlerValue
}

// The handler name.
func (s *ForwardPortsConfigImpl) SetHandler(v string) ForwardPortsConfig {
	if s == nil {
		return nil
	}
	s.HandlerValue = &v
	return s
}

// The handler options.
func (s ForwardPortsConfigImpl) Options() any {
	return s.OptionsValue
}

// The handler options.
func (s *ForwardPortsConfigImpl) SetOptions(v any) ForwardPortsConfig {
	if s == nil {
		return nil
	}
	s.OptionsValue = v
	return s
}

// NewGenrefStatus creates a new GenrefStatus instance
func NewGenrefStatus() GenrefStatus {
	return &GenrefStatusImpl{}
}

// If true genref port is a physical port, else genref port is a virtual port (internal clock-lock feature).
func (s GenrefStatusImpl) External() *bool {
	return s.ExternalValue
}

// If true genref port is a physical port, else genref port is a virtual port (internal clock-lock feature).
func (s *GenrefStatusImpl) SetExternal(v bool) GenrefStatus {
	if s == nil {
		return nil
	}
	s.ExternalValue = &v
	return s
}

// Detected genref input port number.
func (s GenrefStatusImpl) Port() *int {
	return s.PortValue
}

// Detected genref input port number.
func (s *GenrefStatusImpl) SetPort(v int) GenrefStatus {
	if s == nil {
		return nil
	}
	s.PortValue = &v
	return s
}

// Configured reference signal video standard.
func (s GenrefStatusImpl) Vstd() *string {
	return s.VstdValue
}

// Configured reference signal video standard.
func (s *GenrefStatusImpl) SetVstd(v string) GenrefStatus {
	if s == nil {
		return nil
	}
	s.VstdValue = &v
	return s
}

// Detected (actual) reference signal video standard.
func (s GenrefStatusImpl) VstdDetected() *string {
	return s.VstdDetectedValue
}

// Detected (actual) reference signal video standard.
func (s *GenrefStatusImpl) SetVstdDetected(v string) GenrefStatus {
	if s == nil {
		return nil
	}
	s.VstdDetectedValue = &v
	return s
}

// NewH26xDecoderCounters creates a new H26xDecoderCounters instance
func NewH26xDecoderCounters() H26xDecoderCounters {
	return &H26xDecoderCountersImpl{}
}

// Number of NAL units, which `forbidden_zero_bit` is set to one.
func (s H26xDecoderCountersImpl) DiscardedBrokenNalCount() *int {
	return s.DiscardedBrokenNalCountValue
}

// Number of NAL units, which `forbidden_zero_bit` is set to one.
func (s *H26xDecoderCountersImpl) SetDiscardedBrokenNalCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.DiscardedBrokenNalCountValue = &v
	return s
}

// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
// This counter shows number of discarded `Fragmentation Units`
func (s H26xDecoderCountersImpl) DiscardedFuCount() *int {
	return s.DiscardedFuCountValue
}

// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
// This counter shows number of discarded `Fragmentation Units`
func (s *H26xDecoderCountersImpl) SetDiscardedFuCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.DiscardedFuCountValue = &v
	return s
}

// Number of discarded NAL units.
func (s H26xDecoderCountersImpl) DiscardedNalCount() *int {
	return s.DiscardedNalCountValue
}

// Number of discarded NAL units.
func (s *H26xDecoderCountersImpl) SetDiscardedNalCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.DiscardedNalCountValue = &v
	return s
}

// Number of NAL units, which type is not allowed in `non-interleaved packetization mode`.
func (s H26xDecoderCountersImpl) DiscardedNotAllowedNalCount() *int {
	return s.DiscardedNotAllowedNalCountValue
}

// Number of NAL units, which type is not allowed in `non-interleaved packetization mode`.
func (s *H26xDecoderCountersImpl) SetDiscardedNotAllowedNalCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.DiscardedNotAllowedNalCountValue = &v
	return s
}

// Number of discarded `SEI` NAL units
func (s H26xDecoderCountersImpl) DiscardedSeiCount() *int {
	return s.DiscardedSeiCountValue
}

// Number of discarded `SEI` NAL units
func (s *H26xDecoderCountersImpl) SetDiscardedSeiCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.DiscardedSeiCountValue = &v
	return s
}

// There is workaround to not interrupt `FU` sequence if `end-FU` followed by `middle-FU`.
// This counter shows how many time the workaround was applied.
func (s H26xDecoderCountersImpl) FuEndThenMiddleWorkaroundCount() *int {
	return s.FuEndThenMiddleWorkaroundCountValue
}

// There is workaround to not interrupt `FU` sequence if `end-FU` followed by `middle-FU`.
// This counter shows how many time the workaround was applied.
func (s *H26xDecoderCountersImpl) SetFuEndThenMiddleWorkaroundCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.FuEndThenMiddleWorkaroundCountValue = &v
	return s
}

// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
// This counter shows number of `Fragmentation Units` which `Start bit` and `End bit` are set to one in the same `FU` header
func (s H26xDecoderCountersImpl) FuHasBothStartEndBitsCount() *int {
	return s.FuHasBothStartEndBitsCountValue
}

// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
// This counter shows number of `Fragmentation Units` which `Start bit` and `End bit` are set to one in the same `FU` header
func (s *H26xDecoderCountersImpl) SetFuHasBothStartEndBitsCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.FuHasBothStartEndBitsCountValue = &v
	return s
}

// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
// `Fragmentation Units` pattern must have a `Start FU`, `End FU` and could have `FUs` between these ones.
// This counter indicates how many times pattern was broken.
func (s H26xDecoderCountersImpl) FuPatternIsBrokenCount() *int {
	return s.FuPatternIsBrokenCountValue
}

// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
// `Fragmentation Units` pattern must have a `Start FU`, `End FU` and could have `FUs` between these ones.
// This counter indicates how many times pattern was broken.
func (s *H26xDecoderCountersImpl) SetFuPatternIsBrokenCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.FuPatternIsBrokenCountValue = &v
	return s
}

// NAL deframentation could be interrupted by unexpected NAL or broken/incomplete packet.
// If NAL deframentation is interrupted then incomplete fragment of NAL is not discarded and used in decoding process.
// This counter indicates how many incomplete NALs were used.
func (s H26xDecoderCountersImpl) IncompleteNalCount() *int {
	return s.IncompleteNalCountValue
}

// NAL deframentation could be interrupted by unexpected NAL or broken/incomplete packet.
// If NAL deframentation is interrupted then incomplete fragment of NAL is not discarded and used in decoding process.
// This counter indicates how many incomplete NALs were used.
func (s *H26xDecoderCountersImpl) SetIncompleteNalCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.IncompleteNalCountValue = &v
	return s
}

// Number of `SEI` NAL units with bad payload
func (s H26xDecoderCountersImpl) InvalidSeiPayloadCount() *int {
	return s.InvalidSeiPayloadCountValue
}

// Number of `SEI` NAL units with bad payload
func (s *H26xDecoderCountersImpl) SetInvalidSeiPayloadCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.InvalidSeiPayloadCountValue = &v
	return s
}

// Number of `SEI` NAL units with invalid size
func (s H26xDecoderCountersImpl) InvalidSeiSizeCount() *int {
	return s.InvalidSeiSizeCountValue
}

// Number of `SEI` NAL units with invalid size
func (s *H26xDecoderCountersImpl) SetInvalidSeiSizeCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.InvalidSeiSizeCountValue = &v
	return s
}

// Number of `SEI` NAL units with invalid type
func (s H26xDecoderCountersImpl) InvalidSeiTypeCount() *int {
	return s.InvalidSeiTypeCountValue
}

// Number of `SEI` NAL units with invalid type
func (s *H26xDecoderCountersImpl) SetInvalidSeiTypeCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.InvalidSeiTypeCountValue = &v
	return s
}

// How many NAL `AGGREGATION` units handled by this decoder.
func (s H26xDecoderCountersImpl) NalAggregationCount() *int {
	return s.NalAggregationCountValue
}

// How many NAL `AGGREGATION` units handled by this decoder.
func (s *H26xDecoderCountersImpl) SetNalAggregationCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.NalAggregationCountValue = &v
	return s
}

// How many NAL `AUD` units handled by this decoder.
func (s H26xDecoderCountersImpl) NalAudCount() *int {
	return s.NalAudCountValue
}

// How many NAL `AUD` units handled by this decoder.
func (s *H26xDecoderCountersImpl) SetNalAudCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.NalAudCountValue = &v
	return s
}

// How many NAL units handled by this decoder.
func (s H26xDecoderCountersImpl) NalCount() *int {
	return s.NalCountValue
}

// How many NAL units handled by this decoder.
func (s *H26xDecoderCountersImpl) SetNalCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.NalCountValue = &v
	return s
}

// How many NAL `FILLER` units handled by this decoder.
func (s H26xDecoderCountersImpl) NalFillerCount() *int {
	return s.NalFillerCountValue
}

// How many NAL `FILLER` units handled by this decoder.
func (s *H26xDecoderCountersImpl) SetNalFillerCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.NalFillerCountValue = &v
	return s
}

// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
// This counter shows how many `Fragmentation Units` handled by this decoder.
func (s H26xDecoderCountersImpl) NalFuCount() *int {
	return s.NalFuCountValue
}

// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
// This counter shows how many `Fragmentation Units` handled by this decoder.
func (s *H26xDecoderCountersImpl) SetNalFuCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.NalFuCountValue = &v
	return s
}

// How many NAL `IDR` units handled by this decoder.
func (s H26xDecoderCountersImpl) NalIdrCount() *int {
	return s.NalIdrCountValue
}

// How many NAL `IDR` units handled by this decoder.
func (s *H26xDecoderCountersImpl) SetNalIdrCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.NalIdrCountValue = &v
	return s
}

// How many other NAL units handled by this decoder.
func (s H26xDecoderCountersImpl) NalOtherCount() *int {
	return s.NalOtherCountValue
}

// How many other NAL units handled by this decoder.
func (s *H26xDecoderCountersImpl) SetNalOtherCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.NalOtherCountValue = &v
	return s
}

// How many NAL `PPS` units handled by this decoder.
func (s H26xDecoderCountersImpl) NalPpsCount() *int {
	return s.NalPpsCountValue
}

// How many NAL `PPS` units handled by this decoder.
func (s *H26xDecoderCountersImpl) SetNalPpsCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.NalPpsCountValue = &v
	return s
}

// How many NAL `SEI` units handled by this decoder.
func (s H26xDecoderCountersImpl) NalSeiCount() *int {
	return s.NalSeiCountValue
}

// How many NAL `SEI` units handled by this decoder.
func (s *H26xDecoderCountersImpl) SetNalSeiCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.NalSeiCountValue = &v
	return s
}

// How many NAL `SINGLE` units handled by this decoder.
func (s H26xDecoderCountersImpl) NalSingleCount() *int {
	return s.NalSingleCountValue
}

// How many NAL `SINGLE` units handled by this decoder.
func (s *H26xDecoderCountersImpl) SetNalSingleCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.NalSingleCountValue = &v
	return s
}

// How many NAL `SLICE` units handled by this decoder.
func (s H26xDecoderCountersImpl) NalSliceCount() *int {
	return s.NalSliceCountValue
}

// How many NAL `SLICE` units handled by this decoder.
func (s *H26xDecoderCountersImpl) SetNalSliceCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.NalSliceCountValue = &v
	return s
}

// How many NAL `SPS` units handled by this decoder.
func (s H26xDecoderCountersImpl) NalSpsCount() *int {
	return s.NalSpsCountValue
}

// How many NAL `SPS` units handled by this decoder.
func (s *H26xDecoderCountersImpl) SetNalSpsCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.NalSpsCountValue = &v
	return s
}

// How many NAL `STAP_A` units handled by this decoder.
func (s H26xDecoderCountersImpl) NalStapACount() *int {
	return s.NalStapACountValue
}

// How many NAL `STAP_A` units handled by this decoder.
func (s *H26xDecoderCountersImpl) SetNalStapACount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.NalStapACountValue = &v
	return s
}

// How many NAL `VPS` units handled by this decoder.
func (s H26xDecoderCountersImpl) NalVpsCount() *int {
	return s.NalVpsCountValue
}

// How many NAL `VPS` units handled by this decoder.
func (s *H26xDecoderCountersImpl) SetNalVpsCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.NalVpsCountValue = &v
	return s
}

// NewHTTPProxyConfig creates a new HTTPProxyConfig instance
func NewHTTPProxyConfig() HTTPProxyConfig {
	return &HTTPProxyConfigImpl{}
}

// If this flag is set, then streamer will redirect from "/" to this proxy configuration.
func (s HTTPProxyConfigImpl) Mainpage() *bool {
	return s.MainpageValue
}

// If this flag is set, then streamer will redirect from "/" to this proxy configuration.
func (s *HTTPProxyConfigImpl) SetMainpage(v bool) HTTPProxyConfig {
	if s == nil {
		return nil
	}
	s.MainpageValue = &v
	return s
}

// HTTP prefix that will be intercepted by this http proxy configuration
// Format: media_name (media_name)
func (s HTTPProxyConfigImpl) Prefix() MediaName {
	return s.PrefixValue
}

// HTTP prefix that will be intercepted by this http proxy configuration
// Format: media_name (media_name)
func (s *HTTPProxyConfigImpl) SetPrefix(v MediaName) HTTPProxyConfig {
	if s == nil {
		return nil
	}
	s.PrefixValue = v
	return s
}

// The runtime statistics about http proxy
func (s HTTPProxyConfigImpl) Stats() HTTPProxyStats {
	return s.StatsValue
}

// The runtime statistics about http proxy
func (s *HTTPProxyConfigImpl) SetStats(v HTTPProxyStats) HTTPProxyConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*HTTPProxyStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// Upstream url
// Format: url (url)
func (s HTTPProxyConfigImpl) URL() URL {
	return s.URLValue
}

// Upstream url
// Format: url (url)
func (s *HTTPProxyConfigImpl) SetURL(v URL) HTTPProxyConfig {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// NewHTTPProxyStats creates a new HTTPProxyStats instance
func NewHTTPProxyStats() HTTPProxyStats {
	return &HTTPProxyStatsImpl{}
}

// Number of requests with HTTP code 1xx (e.g. protocol upgrades)
// Example: 1000
func (s HTTPProxyStatsImpl) HTTP100() *int {
	return s.HTTP100Value
}

// Number of requests with HTTP code 1xx (e.g. protocol upgrades)
// Example: 1000
func (s *HTTPProxyStatsImpl) SetHTTP100(v int) HTTPProxyStats {
	if s == nil {
		return nil
	}
	s.HTTP100Value = &v
	return s
}

// Number of requests with HTTP code 2xx
// Example: 1000
func (s HTTPProxyStatsImpl) HTTP200() *int {
	return s.HTTP200Value
}

// Number of requests with HTTP code 2xx
// Example: 1000
func (s *HTTPProxyStatsImpl) SetHTTP200(v int) HTTPProxyStats {
	if s == nil {
		return nil
	}
	s.HTTP200Value = &v
	return s
}

// Number of requests with HTTP code 3xx
// Example: 10
func (s HTTPProxyStatsImpl) HTTP300() *int {
	return s.HTTP300Value
}

// Number of requests with HTTP code 3xx
// Example: 10
func (s *HTTPProxyStatsImpl) SetHTTP300(v int) HTTPProxyStats {
	if s == nil {
		return nil
	}
	s.HTTP300Value = &v
	return s
}

// Number of requests with HTTP code 4xx
// Example: 10
func (s HTTPProxyStatsImpl) HTTP400() *int {
	return s.HTTP400Value
}

// Number of requests with HTTP code 4xx
// Example: 10
func (s *HTTPProxyStatsImpl) SetHTTP400(v int) HTTPProxyStats {
	if s == nil {
		return nil
	}
	s.HTTP400Value = &v
	return s
}

// Number of requests with HTTP code 5xx
// Example: 10
func (s HTTPProxyStatsImpl) HTTP500() *int {
	return s.HTTP500Value
}

// Number of requests with HTTP code 5xx
// Example: 10
func (s *HTTPProxyStatsImpl) SetHTTP500(v int) HTTPProxyStats {
	if s == nil {
		return nil
	}
	s.HTTP500Value = &v
	return s
}

// Total number of requests with protocol upgrade (e.g. websocket)
// Example: 1000
func (s HTTPProxyStatsImpl) ProtocolUpgrades() *int {
	return s.ProtocolUpgradesValue
}

// Total number of requests with protocol upgrade (e.g. websocket)
// Example: 1000
func (s *HTTPProxyStatsImpl) SetProtocolUpgrades(v int) HTTPProxyStats {
	if s == nil {
		return nil
	}
	s.ProtocolUpgradesValue = &v
	return s
}

// Number of requests with error on proxy itself
// Example: 10
func (s HTTPProxyStatsImpl) ProxyError() *int {
	return s.ProxyErrorValue
}

// Number of requests with error on proxy itself
// Example: 10
func (s *HTTPProxyStatsImpl) SetProxyError(v int) HTTPProxyStats {
	if s == nil {
		return nil
	}
	s.ProxyErrorValue = &v
	return s
}

// Number of requests with connection errors - econnrefused, etc
// Example: 10
func (s HTTPProxyStatsImpl) ProxyErrorConnection() *int {
	return s.ProxyErrorConnectionValue
}

// Number of requests with connection errors - econnrefused, etc
// Example: 10
func (s *HTTPProxyStatsImpl) SetProxyErrorConnection(v int) HTTPProxyStats {
	if s == nil {
		return nil
	}
	s.ProxyErrorConnectionValue = &v
	return s
}

// Total number of requests this prefix received
// Example: 1000
func (s HTTPProxyStatsImpl) Requests() *int {
	return s.RequestsValue
}

// Total number of requests this prefix received
// Example: 1000
func (s *HTTPProxyStatsImpl) SetRequests(v int) HTTPProxyStats {
	if s == nil {
		return nil
	}
	s.RequestsValue = &v
	return s
}

// Number of API calls that took more than 500ms and less than 1s
// Example: 2
func (s HTTPProxyStatsImpl) Time1000Ms() *int {
	return s.Time1000MsValue
}

// Number of API calls that took more than 500ms and less than 1s
// Example: 2
func (s *HTTPProxyStatsImpl) SetTime1000Ms(v int) HTTPProxyStats {
	if s == nil {
		return nil
	}
	s.Time1000MsValue = &v
	return s
}

// Number of API calls that took less than 100ms
// Example: 10
func (s HTTPProxyStatsImpl) Time100Ms() *int {
	return s.Time100MsValue
}

// Number of API calls that took less than 100ms
// Example: 10
func (s *HTTPProxyStatsImpl) SetTime100Ms(v int) HTTPProxyStats {
	if s == nil {
		return nil
	}
	s.Time100MsValue = &v
	return s
}

// Number of API calls that took more than 1s and less than 5s
// Example: 2
func (s HTTPProxyStatsImpl) Time5000Ms() *int {
	return s.Time5000MsValue
}

// Number of API calls that took more than 1s and less than 5s
// Example: 2
func (s *HTTPProxyStatsImpl) SetTime5000Ms(v int) HTTPProxyStats {
	if s == nil {
		return nil
	}
	s.Time5000MsValue = &v
	return s
}

// Number of API calls that took more than 100ms and less than 500ms
// Example: 5
func (s HTTPProxyStatsImpl) Time500Ms() *int {
	return s.Time500MsValue
}

// Number of API calls that took more than 100ms and less than 500ms
// Example: 5
func (s *HTTPProxyStatsImpl) SetTime500Ms(v int) HTTPProxyStats {
	if s == nil {
		return nil
	}
	s.Time500MsValue = &v
	return s
}

// Number of API calls that took more than 5s
// Example: 1
func (s HTTPProxyStatsImpl) TimeLongms() *int {
	return s.TimeLongmsValue
}

// Number of API calls that took more than 5s
// Example: 1
func (s *HTTPProxyStatsImpl) SetTimeLongms(v int) HTTPProxyStats {
	if s == nil {
		return nil
	}
	s.TimeLongmsValue = &v
	return s
}

// NewInputAgentCounters creates a new InputAgentCounters instance
func NewInputAgentCounters() InputAgentCounters {
	return &InputAgentCountersImpl{}
}

// These errors indicate that the agent does not have enough buffer size to handle outgoing traffic.
func (s InputAgentCountersImpl) ErrorsBufferOverrun() *int {
	return s.ErrorsBufferOverrunValue
}

// These errors indicate that the agent does not have enough buffer size to handle outgoing traffic.
func (s *InputAgentCountersImpl) SetErrorsBufferOverrun(v int) InputAgentCounters {
	if s == nil {
		return nil
	}
	s.ErrorsBufferOverrunValue = &v
	return s
}

// The agent was unable to open the requested connection. These errors may indicate problems opening the TCP socket on the agent or the remote host is unreacheable.
func (s InputAgentCountersImpl) ErrorsConnFailed() *int {
	return s.ErrorsConnFailedValue
}

// The agent was unable to open the requested connection. These errors may indicate problems opening the TCP socket on the agent or the remote host is unreacheable.
func (s *InputAgentCountersImpl) SetErrorsConnFailed(v int) InputAgentCounters {
	if s == nil {
		return nil
	}
	s.ErrorsConnFailedValue = &v
	return s
}

// These errors indicate that the agent is receiving invalid requests.
func (s InputAgentCountersImpl) ErrorsInvalidRequest() *int {
	return s.ErrorsInvalidRequestValue
}

// These errors indicate that the agent is receiving invalid requests.
func (s *InputAgentCountersImpl) SetErrorsInvalidRequest(v int) InputAgentCounters {
	if s == nil {
		return nil
	}
	s.ErrorsInvalidRequestValue = &v
	return s
}

// These errors indicate that the agent does not have enough memory to establish a connection to the remote host.
func (s InputAgentCountersImpl) ErrorsOutOfMemory() *int {
	return s.ErrorsOutOfMemoryValue
}

// These errors indicate that the agent does not have enough memory to establish a connection to the remote host.
func (s *InputAgentCountersImpl) SetErrorsOutOfMemory(v int) InputAgentCounters {
	if s == nil {
		return nil
	}
	s.ErrorsOutOfMemoryValue = &v
	return s
}

// Unknown errors counter.
func (s InputAgentCountersImpl) ErrorsUnknown() *int {
	return s.ErrorsUnknownValue
}

// Unknown errors counter.
func (s *InputAgentCountersImpl) SetErrorsUnknown(v int) InputAgentCounters {
	if s == nil {
		return nil
	}
	s.ErrorsUnknownValue = &v
	return s
}

// NewInputCounters creates a new InputCounters instance
func NewInputCounters() InputCounters {
	return &InputCountersImpl{}
}

// How many Ad markers passed to this stream from the inputs.
func (s InputCountersImpl) AdSplicesIngested() *int {
	return s.AdSplicesIngestedValue
}

// How many Ad markers passed to this stream from the inputs.
func (s *InputCountersImpl) SetAdSplicesIngested(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.AdSplicesIngestedValue = &v
	return s
}

// How many Ad markers inserted to this stream by user.
func (s InputCountersImpl) AdSplicesInserted() *int {
	return s.AdSplicesInsertedValue
}

// How many Ad markers inserted to this stream by user.
func (s *InputCountersImpl) SetAdSplicesInserted(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.AdSplicesInsertedValue = &v
	return s
}

func (s InputCountersImpl) Agent() InputAgentCounters {
	return s.AgentValue
}

func (s *InputCountersImpl) SetAgent(v InputAgentCounters) InputCounters {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputAgentCountersImpl); ok {
		s.AgentValue = impl
	}
	return s
}

// Number of bytes received by this stream from live sources.
// It will be counted before transcoding and will sum all inputs working together.
// Format: bytes (bytes)
func (s InputCountersImpl) Bytes() *Bytes {
	return s.BytesValue
}

// Number of bytes received by this stream from live sources.
// It will be counted before transcoding and will sum all inputs working together.
// Format: bytes (bytes)
func (s *InputCountersImpl) SetBytes(v Bytes) InputCounters {
	if s == nil {
		return nil
	}
	s.BytesValue = &v
	return s
}

// Number of bytes received by this stream when downloading from remote DVR.
// Format: bytes (bytes)
func (s InputCountersImpl) BytesDvr() *Bytes {
	return s.BytesDvrValue
}

// Number of bytes received by this stream when downloading from remote DVR.
// Format: bytes (bytes)
func (s *InputCountersImpl) SetBytesDvr(v Bytes) InputCounters {
	if s == nil {
		return nil
	}
	s.BytesDvrValue = &v
	return s
}

// Sum of all other specific errors in the last minute
// Example: 0
func (s InputCountersImpl) ErrorRate() *int {
	return s.ErrorRateValue
}

// Sum of all other specific errors in the last minute
// Example: 0
func (s *InputCountersImpl) SetErrorRate(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.ErrorRateValue = &v
	return s
}

// Sum of all other specific errors. Can be used for triggering alert on any error
// Example: 0
func (s InputCountersImpl) Errors() *int {
	return s.ErrorsValue
}

// Sum of all other specific errors. Can be used for triggering alert on any error
// Example: 0
func (s *InputCountersImpl) SetErrors(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.ErrorsValue = &v
	return s
}

// How many times we've got 403 (eaccess).
func (s InputCountersImpl) Errors403() *int {
	return s.Errors403Value
}

// How many times we've got 403 (eaccess).
func (s *InputCountersImpl) SetErrors403(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.Errors403Value = &v
	return s
}

// How many times we've got 404 (enoent).
func (s InputCountersImpl) Errors404() *int {
	return s.Errors404Value
}

// How many times we've got 404 (enoent).
func (s *InputCountersImpl) SetErrors404(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.Errors404Value = &v
	return s
}

// How many times we've got 500 (backend error).
func (s InputCountersImpl) Errors500() *int {
	return s.Errors500Value
}

// How many times we've got 500 (backend error).
func (s *InputCountersImpl) SetErrors500(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.Errors500Value = &v
	return s
}

// Demultiplexing was done right, but content is broken.
func (s InputCountersImpl) ErrorsBrokenPayload() *int {
	return s.ErrorsBrokenPayloadValue
}

// Demultiplexing was done right, but content is broken.
func (s *InputCountersImpl) SetErrorsBrokenPayload(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.ErrorsBrokenPayloadValue = &v
	return s
}

// How many times input was restarted due to internal crash.
// This may happen due to unhandled input.
func (s InputCountersImpl) ErrorsCrashed() *int {
	return s.ErrorsCrashedValue
}

// How many times input was restarted due to internal crash.
// This may happen due to unhandled input.
func (s *InputCountersImpl) SetErrorsCrashed(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.ErrorsCrashedValue = &v
	return s
}

// Decoder reset count due to abnormal DTS change. Can happen in MPEG-TS, RTP.
func (s InputCountersImpl) ErrorsDecoderReset() *int {
	return s.ErrorsDecoderResetValue
}

// Decoder reset count due to abnormal DTS change. Can happen in MPEG-TS, RTP.
func (s *InputCountersImpl) SetErrorsDecoderReset(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.ErrorsDecoderResetValue = &v
	return s
}

// This can be used as a `TS_sync_loss` - how many times MPEG-TS sync was lost.
// Also this counter refers to RTSP desync, when camera starts dropping TCP data and
// we have to find packet boundaries.
// Here we write count of such resynchronizations.
func (s InputCountersImpl) ErrorsDesync() *int {
	return s.ErrorsDesyncValue
}

// This can be used as a `TS_sync_loss` - how many times MPEG-TS sync was lost.
// Also this counter refers to RTSP desync, when camera starts dropping TCP data and
// we have to find packet boundaries.
// Here we write count of such resynchronizations.
func (s *InputCountersImpl) SetErrorsDesync(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.ErrorsDesyncValue = &v
	return s
}

// Dropped frames count due timestamp adjustment.
func (s InputCountersImpl) ErrorsDroppedFrames() *int {
	return s.ErrorsDroppedFramesValue
}

// Dropped frames count due timestamp adjustment.
func (s *InputCountersImpl) SetErrorsDroppedFrames(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.ErrorsDroppedFramesValue = &v
	return s
}

// RTP, MPEG-TS or other protocols have enough information to tell how many packets were lost
func (s InputCountersImpl) ErrorsLostPackets() *int {
	return s.ErrorsLostPacketsValue
}

// RTP, MPEG-TS or other protocols have enough information to tell how many packets were lost
func (s *InputCountersImpl) SetErrorsLostPackets(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.ErrorsLostPacketsValue = &v
	return s
}

// how many times PAT was missing during 0,5 seconds or pid 0 misses PAT
// `PAT_error`
func (s InputCountersImpl) ErrorsTSPat() *int {
	return s.ErrorsTSPatValue
}

// how many times PAT was missing during 0,5 seconds or pid 0 misses PAT
// `PAT_error`
func (s *InputCountersImpl) SetErrorsTSPat(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.ErrorsTSPatValue = &v
	return s
}

// How many times have received PAT that was missing required service (program)
func (s InputCountersImpl) ErrorsTSServiceLost() *int {
	return s.ErrorsTSServiceLostValue
}

// How many times have received PAT that was missing required service (program)
func (s *InputCountersImpl) SetErrorsTSServiceLost(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.ErrorsTSServiceLostValue = &v
	return s
}

// Number of connection restarts to fix ts_stuck issue. Can happen in RTSP.
func (s InputCountersImpl) ErrorsTSStuckRestarts() *int {
	return s.ErrorsTSStuckRestartsValue
}

// Number of connection restarts to fix ts_stuck issue. Can happen in RTSP.
func (s *InputCountersImpl) SetErrorsTSStuckRestarts(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.ErrorsTSStuckRestartsValue = &v
	return s
}

// Number of frames passed to this stream from the inputs.
func (s InputCountersImpl) Frames() *int {
	return s.FramesValue
}

// Number of frames passed to this stream from the inputs.
func (s *InputCountersImpl) SetFrames(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.FramesValue = &v
	return s
}

// Aggregated: how many times this stream has switched between different inputs.
// Individual input: number of times switched to this input.
func (s InputCountersImpl) InputSwitches() *int {
	return s.InputSwitchesValue
}

// Aggregated: how many times this stream has switched between different inputs.
// Individual input: number of times switched to this input.
func (s *InputCountersImpl) SetInputSwitches(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.InputSwitchesValue = &v
	return s
}

// Number of secondary inputs that have some problems.
// Example: 0
func (s InputCountersImpl) InvalidSecondaryInputs() *int {
	return s.InvalidSecondaryInputsValue
}

// Number of secondary inputs that have some problems.
// Example: 0
func (s *InputCountersImpl) SetInvalidSecondaryInputs(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.InvalidSecondaryInputsValue = &v
	return s
}

// Indicates, how often does media_info changes
func (s InputCountersImpl) MediaInfoChanges() *int {
	return s.MediaInfoChangesValue
}

// Indicates, how often does media_info changes
func (s *InputCountersImpl) SetMediaInfoChanges(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.MediaInfoChangesValue = &v
	return s
}

func (s InputCountersImpl) MotionDetector() InputMotionDetectorCounters {
	return s.MotionDetectorValue
}

func (s *InputCountersImpl) SetMotionDetector(v InputMotionDetectorCounters) InputCounters {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputMotionDetectorCountersImpl); ok {
		s.MotionDetectorValue = impl
	}
	return s
}

// How many seconds has this stream had no frames.
// Format: seconds (seconds)
func (s InputCountersImpl) NumSecNoData() *Seconds {
	return s.NumSecNoDataValue
}

// How many seconds has this stream had no frames.
// Format: seconds (seconds)
func (s *InputCountersImpl) SetNumSecNoData(v Seconds) InputCounters {
	if s == nil {
		return nil
	}
	s.NumSecNoDataValue = &v
	return s
}

// How many seconds has this stream played from primary input.
// Format: seconds (seconds)
func (s InputCountersImpl) NumSecOnPrimaryInput() *Seconds {
	return s.NumSecOnPrimaryInputValue
}

// How many seconds has this stream played from primary input.
// Format: seconds (seconds)
func (s *InputCountersImpl) SetNumSecOnPrimaryInput(v Seconds) InputCounters {
	if s == nil {
		return nil
	}
	s.NumSecOnPrimaryInputValue = &v
	return s
}

// How many seconds has this stream played from secondary inputs.
// Format: seconds (seconds)
func (s InputCountersImpl) NumSecOnSecondaryInput() *Seconds {
	return s.NumSecOnSecondaryInputValue
}

// How many seconds has this stream played from secondary inputs.
// Format: seconds (seconds)
func (s *InputCountersImpl) SetNumSecOnSecondaryInput(v Seconds) InputCounters {
	if s == nil {
		return nil
	}
	s.NumSecOnSecondaryInputValue = &v
	return s
}

// Per pid statistics calculated for MPEG-TS input
func (s InputCountersImpl) Pids() []InputPidCounters {
	if s.PidsValue == nil {
		return nil
	}
	result := make([]InputPidCounters, len(s.PidsValue))
	for i, item := range s.PidsValue {
		result[i] = item
	}
	return result
}

// Per pid statistics calculated for MPEG-TS input
func (s *InputCountersImpl) SetPids(v []InputPidCounters) InputCounters {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*InputPidCountersImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*InputPidCountersImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.PidsValue = impl
	}
	return s
}

// Source may send frames not in the order they should be played. It will be catched and reordered.
// This counter indicates how many times did it happened.
func (s InputCountersImpl) ReorderCount() *int {
	return s.ReorderCountValue
}

// Source may send frames not in the order they should be played. It will be catched and reordered.
// This counter indicates how many times did it happened.
func (s *InputCountersImpl) SetReorderCount(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.ReorderCountValue = &v
	return s
}

// Source may send frames timestamps faster or slower than realtime.
// Live stream will catch it and resync. This counter indicates how many times did it happened.
func (s InputCountersImpl) ResyncCountDrift() *int {
	return s.ResyncCountDriftValue
}

// Source may send frames timestamps faster or slower than realtime.
// Live stream will catch it and resync. This counter indicates how many times did it happened.
func (s *InputCountersImpl) SetResyncCountDrift(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.ResyncCountDriftValue = &v
	return s
}

// Source may change timestamps without any signalling. This counter indicates how bad is the source
func (s InputCountersImpl) ResyncCountJump() *int {
	return s.ResyncCountJumpValue
}

// Source may change timestamps without any signalling. This counter indicates how bad is the source
func (s *InputCountersImpl) SetResyncCountJump(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.ResyncCountJumpValue = &v
	return s
}

// Stream timestamps are synchronized with real time. This counter tells, how many times
// it was syncronized after source reconnect.
func (s InputCountersImpl) ResyncCountNormal() *int {
	return s.ResyncCountNormalValue
}

// Stream timestamps are synchronized with real time. This counter tells, how many times
// it was syncronized after source reconnect.
func (s *InputCountersImpl) SetResyncCountNormal(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.ResyncCountNormalValue = &v
	return s
}

// How many times has this stream retried to connect to source
func (s InputCountersImpl) Retries() *int {
	return s.RetriesValue
}

// How many times has this stream retried to connect to source
func (s *InputCountersImpl) SetRetries(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.RetriesValue = &v
	return s
}

// Per channel statistics calculated for RTP input
func (s InputCountersImpl) RTPChannels() []InputRTPCounters {
	if s.RTPChannelsValue == nil {
		return nil
	}
	result := make([]InputRTPCounters, len(s.RTPChannelsValue))
	for i, item := range s.RTPChannelsValue {
		result[i] = item
	}
	return result
}

// Per channel statistics calculated for RTP input
func (s *InputCountersImpl) SetRTPChannels(v []InputRTPCounters) InputCounters {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*InputRTPCountersImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*InputRTPCountersImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.RTPChannelsValue = impl
	}
	return s
}

func (s InputCountersImpl) Sdi() InputSdiCounters {
	return s.SdiValue
}

func (s *InputCountersImpl) SetSdi(v InputSdiCounters) InputCounters {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputSdiCountersImpl); ok {
		s.SdiValue = impl
	}
	return s
}

func (s InputCountersImpl) Srt() InputSrtCounters {
	return s.SrtValue
}

func (s *InputCountersImpl) SetSrt(v InputSrtCounters) InputCounters {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputSrtCountersImpl); ok {
		s.SrtValue = impl
	}
	return s
}

// Number of secondary inputs that have no problems.
// Example: 2
func (s InputCountersImpl) ValidSecondaryInputs() *int {
	return s.ValidSecondaryInputsValue
}

// Number of secondary inputs that have no problems.
// Example: 2
func (s *InputCountersImpl) SetValidSecondaryInputs(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.ValidSecondaryInputsValue = &v
	return s
}

// NewInputMediaInfo creates a new InputMediaInfo instance
func NewInputMediaInfo() InputMediaInfo {
	return &InputMediaInfoImpl{}
}

// The program ID for MPEG TS streams.
// Example: 110
func (s InputMediaInfoImpl) ProgramID() *int {
	return s.ProgramIDValue
}

// The program ID for MPEG TS streams.
// Example: 110
func (s *InputMediaInfoImpl) SetProgramID(v int) InputMediaInfo {
	if s == nil {
		return nil
	}
	s.ProgramIDValue = &v
	return s
}

// The media provider of this content.
// Example: Netflix
func (s InputMediaInfoImpl) Provider() *string {
	return s.ProviderValue
}

// The media provider of this content.
// Example: Netflix
func (s *InputMediaInfoImpl) SetProvider(v string) InputMediaInfo {
	if s == nil {
		return nil
	}
	s.ProviderValue = &v
	return s
}

// The identifier of the transport stream for MPEG TS streams.
// Example: 253
func (s InputMediaInfoImpl) StreamID() *int {
	return s.StreamIDValue
}

// The identifier of the transport stream for MPEG TS streams.
// Example: 253
func (s *InputMediaInfoImpl) SetStreamID(v int) InputMediaInfo {
	if s == nil {
		return nil
	}
	s.StreamIDValue = &v
	return s
}

// Human-readable title of the media.
// Example: Bunny
func (s InputMediaInfoImpl) Title() *string {
	return s.TitleValue
}

// Human-readable title of the media.
// Example: Bunny
func (s *InputMediaInfoImpl) SetTitle(v string) InputMediaInfo {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// Just like a regular `track_info`, but with matching rules,
// that allow to select which input track must be mapped to output
func (s InputMediaInfoImpl) Tracks() []InputTrackInfo {
	if s.TracksValue == nil {
		return nil
	}
	result := make([]InputTrackInfo, len(s.TracksValue))
	for i, item := range s.TracksValue {
		result[i] = item
	}
	return result
}

// Just like a regular `track_info`, but with matching rules,
// that allow to select which input track must be mapped to output
func (s *InputMediaInfoImpl) SetTracks(v []InputTrackInfo) InputMediaInfo {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*InputTrackInfoImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*InputTrackInfoImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.TracksValue = impl
	}
	return s
}

// NewInputMotionDetectorCounters creates a new InputMotionDetectorCounters instance
func NewInputMotionDetectorCounters() InputMotionDetectorCounters {
	return &InputMotionDetectorCountersImpl{}
}

// Number of collected episodes.
func (s InputMotionDetectorCountersImpl) EpisodesCount() *int {
	return s.EpisodesCountValue
}

// Number of collected episodes.
func (s *InputMotionDetectorCountersImpl) SetEpisodesCount(v int) InputMotionDetectorCounters {
	if s == nil {
		return nil
	}
	s.EpisodesCountValue = &v
	return s
}

// Number of responses with broken content.
func (s InputMotionDetectorCountersImpl) ErrorsBrokenPayload() *int {
	return s.ErrorsBrokenPayloadValue
}

// Number of responses with broken content.
func (s *InputMotionDetectorCountersImpl) SetErrorsBrokenPayload(v int) InputMotionDetectorCounters {
	if s == nil {
		return nil
	}
	s.ErrorsBrokenPayloadValue = &v
	return s
}

// `ONVIF Event Handling Test Specification` says that valid values for `CurrentTime` and `TerminationTime` are
// `TerminationTime >= CurrentTime + InitialTerminationTime`.
// How many responses did not met the condition.
func (s InputMotionDetectorCountersImpl) ErrorsIncorrectTimeValuesCount() *int {
	return s.ErrorsIncorrectTimeValuesCountValue
}

// `ONVIF Event Handling Test Specification` says that valid values for `CurrentTime` and `TerminationTime` are
// `TerminationTime >= CurrentTime + InitialTerminationTime`.
// How many responses did not met the condition.
func (s *InputMotionDetectorCountersImpl) SetErrorsIncorrectTimeValuesCount(v int) InputMotionDetectorCounters {
	if s == nil {
		return nil
	}
	s.ErrorsIncorrectTimeValuesCountValue = &v
	return s
}

// Number of failed request attempts because of no agent connected.
func (s InputMotionDetectorCountersImpl) ErrorsNoAgentConnected() *int {
	return s.ErrorsNoAgentConnectedValue
}

// Number of failed request attempts because of no agent connected.
func (s *InputMotionDetectorCountersImpl) SetErrorsNoAgentConnected(v int) InputMotionDetectorCounters {
	if s == nil {
		return nil
	}
	s.ErrorsNoAgentConnectedValue = &v
	return s
}

// Number of attempts to request disabled or unsupported ONVIF service
func (s InputMotionDetectorCountersImpl) ErrorsNoServiceCount() *int {
	return s.ErrorsNoServiceCountValue
}

// Number of attempts to request disabled or unsupported ONVIF service
func (s *InputMotionDetectorCountersImpl) SetErrorsNoServiceCount(v int) InputMotionDetectorCounters {
	if s == nil {
		return nil
	}
	s.ErrorsNoServiceCountValue = &v
	return s
}

// Number of not authorized requests
func (s InputMotionDetectorCountersImpl) ErrorsNotAuthorizedCount() *int {
	return s.ErrorsNotAuthorizedCountValue
}

// Number of not authorized requests
func (s *InputMotionDetectorCountersImpl) SetErrorsNotAuthorizedCount(v int) InputMotionDetectorCounters {
	if s == nil {
		return nil
	}
	s.ErrorsNotAuthorizedCountValue = &v
	return s
}

// Number of failed requests because of bad url or network issues.
func (s InputMotionDetectorCountersImpl) ErrorsURLUnreachableCount() *int {
	return s.ErrorsURLUnreachableCountValue
}

// Number of failed requests because of bad url or network issues.
func (s *InputMotionDetectorCountersImpl) SetErrorsURLUnreachableCount(v int) InputMotionDetectorCounters {
	if s == nil {
		return nil
	}
	s.ErrorsURLUnreachableCountValue = &v
	return s
}

// Number of detected motions.
func (s InputMotionDetectorCountersImpl) MotionDetectedCount() *int {
	return s.MotionDetectedCountValue
}

// Number of detected motions.
func (s *InputMotionDetectorCountersImpl) SetMotionDetectedCount(v int) InputMotionDetectorCounters {
	if s == nil {
		return nil
	}
	s.MotionDetectedCountValue = &v
	return s
}

// NewInputPidCounters creates a new InputPidCounters instance
func NewInputPidCounters() InputPidCounters {
	return &InputPidCountersImpl{}
}

// How many PES packets were started not from startcode
func (s InputPidCountersImpl) BrokenPesCount() *int {
	return s.BrokenPesCountValue
}

// How many PES packets were started not from startcode
func (s *InputPidCountersImpl) SetBrokenPesCount(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.BrokenPesCountValue = &v
	return s
}

// How many bytes were discarded due to lack of PES startcode
func (s InputPidCountersImpl) BrokenPesSum() *int {
	return s.BrokenPesSumValue
}

// How many bytes were discarded due to lack of PES startcode
func (s *InputPidCountersImpl) SetBrokenPesSum(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.BrokenPesSumValue = &v
	return s
}

// How many times PTS was less than PCR or previous PTS
func (s InputPidCountersImpl) CorrectedBackwardPts() *int {
	return s.CorrectedBackwardPtsValue
}

// How many times PTS was less than PCR or previous PTS
func (s *InputPidCountersImpl) SetCorrectedBackwardPts(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.CorrectedBackwardPtsValue = &v
	return s
}

// Unhandled crashes inside mpegts decoding process due
func (s InputPidCountersImpl) Crashed() *int {
	return s.CrashedValue
}

// Unhandled crashes inside mpegts decoding process due
func (s *InputPidCountersImpl) SetCrashed(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.CrashedValue = &v
	return s
}

// How many times was discarded too big ES buffer without making a frame of it
func (s InputPidCountersImpl) DiscardedBufferCount() *int {
	return s.DiscardedBufferCountValue
}

// How many times was discarded too big ES buffer without making a frame of it
func (s *InputPidCountersImpl) SetDiscardedBufferCount(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.DiscardedBufferCountValue = &v
	return s
}

// How many bytes were lost due to discarding ES buffer
func (s InputPidCountersImpl) DiscardedBufferSum() *int {
	return s.DiscardedBufferSumValue
}

// How many bytes were lost due to discarding ES buffer
func (s *InputPidCountersImpl) SetDiscardedBufferSum(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.DiscardedBufferSumValue = &v
	return s
}

// Time on this PID jumped back from reference PTS and it was not a roll over zero
func (s InputPidCountersImpl) DtsGoesBackwards() *int {
	return s.DtsGoesBackwardsValue
}

// Time on this PID jumped back from reference PTS and it was not a roll over zero
func (s *InputPidCountersImpl) SetDtsGoesBackwards(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.DtsGoesBackwardsValue = &v
	return s
}

// Time on this PID jumped forward too far away from reference PTS
func (s InputPidCountersImpl) DtsJumpForward() *int {
	return s.DtsJumpForwardValue
}

// Time on this PID jumped forward too far away from reference PTS
func (s *InputPidCountersImpl) SetDtsJumpForward(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.DtsJumpForwardValue = &v
	return s
}

// Packets without payload and adaptation field
func (s InputPidCountersImpl) EmptyPackets() *int {
	return s.EmptyPacketsValue
}

// Packets without payload and adaptation field
func (s *InputPidCountersImpl) SetEmptyPackets(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.EmptyPacketsValue = &v
	return s
}

// Packets with adaptation field larger than packet size
func (s InputPidCountersImpl) ErrorsAdaptationBroken() *int {
	return s.ErrorsAdaptationBrokenValue
}

// Packets with adaptation field larger than packet size
func (s *InputPidCountersImpl) SetErrorsAdaptationBroken(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.ErrorsAdaptationBrokenValue = &v
	return s
}

// How many times pid has been lost
func (s InputPidCountersImpl) ErrorsPidLost() *int {
	return s.ErrorsPidLostValue
}

// How many times pid has been lost
func (s *InputPidCountersImpl) SetErrorsPidLost(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.ErrorsPidLostValue = &v
	return s
}

// how many MPEG-TS packets were received with non-contigious contiuity counters.
// `Continuity_count_error`
// Example: 0
func (s InputPidCountersImpl) ErrorsTSCc() *int {
	return s.ErrorsTSCcValue
}

// how many MPEG-TS packets were received with non-contigious contiuity counters.
// `Continuity_count_error`
// Example: 0
func (s *InputPidCountersImpl) SetErrorsTSCc(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.ErrorsTSCcValue = &v
	return s
}

// how many times PMT was not received after 0,5 seconds
// `PMT_error`
func (s InputPidCountersImpl) ErrorsTSPmt() *int {
	return s.ErrorsTSPmtValue
}

// how many times PMT was not received after 0,5 seconds
// `PMT_error`
func (s *InputPidCountersImpl) SetErrorsTSPmt(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.ErrorsTSPmtValue = &v
	return s
}

// How many times have received PSI entry with broken checksum
// `CRC_error`
func (s InputPidCountersImpl) ErrorsTSPsiChecksum() *int {
	return s.ErrorsTSPsiChecksumValue
}

// How many times have received PSI entry with broken checksum
// `CRC_error`
func (s *InputPidCountersImpl) SetErrorsTSPsiChecksum(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.ErrorsTSPsiChecksumValue = &v
	return s
}

// Amount of scrambled TS packets
func (s InputPidCountersImpl) ErrorsTSScrambled() *int {
	return s.ErrorsTSScrambledValue
}

// Amount of scrambled TS packets
func (s *InputPidCountersImpl) SetErrorsTSScrambled(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.ErrorsTSScrambledValue = &v
	return s
}

// How many MPEG-TS packets with Transport Error Indicator were received
// `Transport_error`, 2.1
func (s InputPidCountersImpl) ErrorsTSTei() *int {
	return s.ErrorsTSTeiValue
}

// How many MPEG-TS packets with Transport Error Indicator were received
// `Transport_error`, 2.1
func (s *InputPidCountersImpl) SetErrorsTSTei(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.ErrorsTSTeiValue = &v
	return s
}

// How many H264(5) NAL fillers were seen in the input
func (s InputPidCountersImpl) FillersCount() *int {
	return s.FillersCountValue
}

// How many H264(5) NAL fillers were seen in the input
func (s *InputPidCountersImpl) SetFillersCount(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.FillersCountValue = &v
	return s
}

// How many bytes were seen in NAL fillers
func (s InputPidCountersImpl) FillersSum() *int {
	return s.FillersSumValue
}

// How many bytes were seen in NAL fillers
func (s *InputPidCountersImpl) SetFillersSum(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.FillersSumValue = &v
	return s
}

// Frame count on this pid
func (s InputPidCountersImpl) Frames() *int {
	return s.FramesValue
}

// Frame count on this pid
func (s *InputPidCountersImpl) SetFrames(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.FramesValue = &v
	return s
}

// How many MPEG-TS packets with 188 bytes on this pid received
func (s InputPidCountersImpl) Packets() *int {
	return s.PacketsValue
}

// How many MPEG-TS packets with 188 bytes on this pid received
func (s *InputPidCountersImpl) SetPackets(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.PacketsValue = &v
	return s
}

// How many PES packets were on the Padding streamId
func (s InputPidCountersImpl) PaddingPesCount() *int {
	return s.PaddingPesCountValue
}

// How many PES packets were on the Padding streamId
func (s *InputPidCountersImpl) SetPaddingPesCount(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.PaddingPesCountValue = &v
	return s
}

// How many bytes were in PES packets on the Padding streamId
func (s InputPidCountersImpl) PaddingPesSum() *int {
	return s.PaddingPesSumValue
}

// How many bytes were in PES packets on the Padding streamId
func (s *InputPidCountersImpl) SetPaddingPesSum(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.PaddingPesSumValue = &v
	return s
}

// If PTS is drifting away from PCR, it can be resynchronized with PCR. This is a resync count
func (s InputPidCountersImpl) PcrResync() *int {
	return s.PcrResyncValue
}

// If PTS is drifting away from PCR, it can be resynchronized with PCR. This is a resync count
func (s *InputPidCountersImpl) SetPcrResync(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.PcrResyncValue = &v
	return s
}

// Related MPEG-TS pid with following problems
func (s InputPidCountersImpl) Pid() int {
	return s.PidValue
}

// Related MPEG-TS pid with following problems
func (s *InputPidCountersImpl) SetPid(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.PidValue = v
	return s
}

// What program does have this pid
func (s InputPidCountersImpl) Pnr() *int {
	return s.PnrValue
}

// What program does have this pid
func (s *InputPidCountersImpl) SetPnr(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.PnrValue = &v
	return s
}

// In case of CC error last frame can be repeated. This is a count of repeated frames
func (s InputPidCountersImpl) RepeatedFrames() *int {
	return s.RepeatedFramesValue
}

// In case of CC error last frame can be repeated. This is a count of repeated frames
func (s *InputPidCountersImpl) SetRepeatedFrames(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.RepeatedFramesValue = &v
	return s
}

// Jumps of timestamps inside a MPEG-TS stream
func (s InputPidCountersImpl) TimeCorrections() *int {
	return s.TimeCorrectionsValue
}

// Jumps of timestamps inside a MPEG-TS stream
func (s *InputPidCountersImpl) SetTimeCorrections(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.TimeCorrectionsValue = &v
	return s
}

// Jump of the PTS was so big from previous, that had to flush all frames and restart parsing
func (s InputPidCountersImpl) TooLargeDtsJump() *int {
	return s.TooLargeDtsJumpValue
}

// Jump of the PTS was so big from previous, that had to flush all frames and restart parsing
func (s *InputPidCountersImpl) SetTooLargeDtsJump(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.TooLargeDtsJumpValue = &v
	return s
}

// NewInputRTPCounters creates a new InputRTPCounters instance
func NewInputRTPCounters() InputRTPCounters {
	return &InputRTPCountersImpl{}
}

// How many bytes received for this channel
func (s InputRTPCountersImpl) Bytes() *int {
	return s.BytesValue
}

// How many bytes received for this channel
func (s *InputRTPCountersImpl) SetBytes(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.BytesValue = &v
	return s
}

// RTP channel number
// Example: 0
func (s InputRTPCountersImpl) ChannelID() int {
	return s.ChannelIDValue
}

// RTP channel number
// Example: 0
func (s *InputRTPCountersImpl) SetChannelID(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.ChannelIDValue = v
	return s
}

// Content of the track transmitted in the channel
// Example: video
func (s InputRTPCountersImpl) Content() *string {
	return s.ContentValue
}

// Content of the track transmitted in the channel
// Example: video
func (s *InputRTPCountersImpl) SetContent(v string) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.ContentValue = &v
	return s
}

// Number of NAL units, which `forbidden_zero_bit` is set to one.
func (s InputRTPCountersImpl) DiscardedBrokenNalCount() *int {
	return s.DiscardedBrokenNalCountValue
}

// Number of NAL units, which `forbidden_zero_bit` is set to one.
func (s *InputRTPCountersImpl) SetDiscardedBrokenNalCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.DiscardedBrokenNalCountValue = &v
	return s
}

// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
// This counter shows number of discarded `Fragmentation Units`
func (s InputRTPCountersImpl) DiscardedFuCount() *int {
	return s.DiscardedFuCountValue
}

// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
// This counter shows number of discarded `Fragmentation Units`
func (s *InputRTPCountersImpl) SetDiscardedFuCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.DiscardedFuCountValue = &v
	return s
}

// Number of discarded NAL units.
func (s InputRTPCountersImpl) DiscardedNalCount() *int {
	return s.DiscardedNalCountValue
}

// Number of discarded NAL units.
func (s *InputRTPCountersImpl) SetDiscardedNalCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.DiscardedNalCountValue = &v
	return s
}

// Number of NAL units, which type is not allowed in `non-interleaved packetization mode`.
func (s InputRTPCountersImpl) DiscardedNotAllowedNalCount() *int {
	return s.DiscardedNotAllowedNalCountValue
}

// Number of NAL units, which type is not allowed in `non-interleaved packetization mode`.
func (s *InputRTPCountersImpl) SetDiscardedNotAllowedNalCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.DiscardedNotAllowedNalCountValue = &v
	return s
}

// Number of discarded `SEI` NAL units
func (s InputRTPCountersImpl) DiscardedSeiCount() *int {
	return s.DiscardedSeiCountValue
}

// Number of discarded `SEI` NAL units
func (s *InputRTPCountersImpl) SetDiscardedSeiCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.DiscardedSeiCountValue = &v
	return s
}

// Demultiplexing was done right, but content is broken.
func (s InputRTPCountersImpl) ErrorsBrokenPayload() *int {
	return s.ErrorsBrokenPayloadValue
}

// Demultiplexing was done right, but content is broken.
func (s *InputRTPCountersImpl) SetErrorsBrokenPayload(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.ErrorsBrokenPayloadValue = &v
	return s
}

// Number of frames which dts is same as previous frame dts.
func (s InputRTPCountersImpl) ErrorsDtsStuck() *int {
	return s.ErrorsDtsStuckValue
}

// Number of frames which dts is same as previous frame dts.
func (s *InputRTPCountersImpl) SetErrorsDtsStuck(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.ErrorsDtsStuckValue = &v
	return s
}

// RTP have enough information to tell how many packets were lost
func (s InputRTPCountersImpl) ErrorsLostPackets() *int {
	return s.ErrorsLostPacketsValue
}

// RTP have enough information to tell how many packets were lost
func (s *InputRTPCountersImpl) SetErrorsLostPackets(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.ErrorsLostPacketsValue = &v
	return s
}

// How many frames received for this channel
func (s InputRTPCountersImpl) Frames() *int {
	return s.FramesValue
}

// How many frames received for this channel
func (s *InputRTPCountersImpl) SetFrames(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.FramesValue = &v
	return s
}

// There is workaround to not interrupt `FU` sequence if `end-FU` followed by `middle-FU`.
// This counter shows how many time the workaround was applied.
func (s InputRTPCountersImpl) FuEndThenMiddleWorkaroundCount() *int {
	return s.FuEndThenMiddleWorkaroundCountValue
}

// There is workaround to not interrupt `FU` sequence if `end-FU` followed by `middle-FU`.
// This counter shows how many time the workaround was applied.
func (s *InputRTPCountersImpl) SetFuEndThenMiddleWorkaroundCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.FuEndThenMiddleWorkaroundCountValue = &v
	return s
}

// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
// This counter shows number of `Fragmentation Units` which `Start bit` and `End bit` are set to one in the same `FU` header
func (s InputRTPCountersImpl) FuHasBothStartEndBitsCount() *int {
	return s.FuHasBothStartEndBitsCountValue
}

// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
// This counter shows number of `Fragmentation Units` which `Start bit` and `End bit` are set to one in the same `FU` header
func (s *InputRTPCountersImpl) SetFuHasBothStartEndBitsCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.FuHasBothStartEndBitsCountValue = &v
	return s
}

// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
// `Fragmentation Units` pattern must have a `Start FU`, `End FU` and could have `FUs` between these ones.
// This counter indicates how many times pattern was broken.
func (s InputRTPCountersImpl) FuPatternIsBrokenCount() *int {
	return s.FuPatternIsBrokenCountValue
}

// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
// `Fragmentation Units` pattern must have a `Start FU`, `End FU` and could have `FUs` between these ones.
// This counter indicates how many times pattern was broken.
func (s *InputRTPCountersImpl) SetFuPatternIsBrokenCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.FuPatternIsBrokenCountValue = &v
	return s
}

// NAL deframentation could be interrupted by unexpected NAL or broken/incomplete packet.
// If NAL deframentation is interrupted then incomplete fragment of NAL is not discarded and used in decoding process.
// This counter indicates how many incomplete NALs were used.
func (s InputRTPCountersImpl) IncompleteNalCount() *int {
	return s.IncompleteNalCountValue
}

// NAL deframentation could be interrupted by unexpected NAL or broken/incomplete packet.
// If NAL deframentation is interrupted then incomplete fragment of NAL is not discarded and used in decoding process.
// This counter indicates how many incomplete NALs were used.
func (s *InputRTPCountersImpl) SetIncompleteNalCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.IncompleteNalCountValue = &v
	return s
}

// Number of `SEI` NAL units with bad payload
func (s InputRTPCountersImpl) InvalidSeiPayloadCount() *int {
	return s.InvalidSeiPayloadCountValue
}

// Number of `SEI` NAL units with bad payload
func (s *InputRTPCountersImpl) SetInvalidSeiPayloadCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.InvalidSeiPayloadCountValue = &v
	return s
}

// Number of `SEI` NAL units with invalid size
func (s InputRTPCountersImpl) InvalidSeiSizeCount() *int {
	return s.InvalidSeiSizeCountValue
}

// Number of `SEI` NAL units with invalid size
func (s *InputRTPCountersImpl) SetInvalidSeiSizeCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.InvalidSeiSizeCountValue = &v
	return s
}

// Number of `SEI` NAL units with invalid type
func (s InputRTPCountersImpl) InvalidSeiTypeCount() *int {
	return s.InvalidSeiTypeCountValue
}

// Number of `SEI` NAL units with invalid type
func (s *InputRTPCountersImpl) SetInvalidSeiTypeCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.InvalidSeiTypeCountValue = &v
	return s
}

// Number of RTP packets which marker bit is set to one.
func (s InputRTPCountersImpl) MarkerPacketsCount() *int {
	return s.MarkerPacketsCountValue
}

// Number of RTP packets which marker bit is set to one.
func (s *InputRTPCountersImpl) SetMarkerPacketsCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.MarkerPacketsCountValue = &v
	return s
}

// How many NACK messages are sent for this channel
func (s InputRTPCountersImpl) NackCount() *int {
	return s.NackCountValue
}

// How many NACK messages are sent for this channel
func (s *InputRTPCountersImpl) SetNackCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.NackCountValue = &v
	return s
}

// How many NAL `AGGREGATION` units handled by this decoder.
func (s InputRTPCountersImpl) NalAggregationCount() *int {
	return s.NalAggregationCountValue
}

// How many NAL `AGGREGATION` units handled by this decoder.
func (s *InputRTPCountersImpl) SetNalAggregationCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.NalAggregationCountValue = &v
	return s
}

// How many NAL `AUD` units handled by this decoder.
func (s InputRTPCountersImpl) NalAudCount() *int {
	return s.NalAudCountValue
}

// How many NAL `AUD` units handled by this decoder.
func (s *InputRTPCountersImpl) SetNalAudCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.NalAudCountValue = &v
	return s
}

// How many NAL units handled by this decoder.
func (s InputRTPCountersImpl) NalCount() *int {
	return s.NalCountValue
}

// How many NAL units handled by this decoder.
func (s *InputRTPCountersImpl) SetNalCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.NalCountValue = &v
	return s
}

// How many NAL `FILLER` units handled by this decoder.
func (s InputRTPCountersImpl) NalFillerCount() *int {
	return s.NalFillerCountValue
}

// How many NAL `FILLER` units handled by this decoder.
func (s *InputRTPCountersImpl) SetNalFillerCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.NalFillerCountValue = &v
	return s
}

// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
// This counter shows how many `Fragmentation Units` handled by this decoder.
func (s InputRTPCountersImpl) NalFuCount() *int {
	return s.NalFuCountValue
}

// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
// This counter shows how many `Fragmentation Units` handled by this decoder.
func (s *InputRTPCountersImpl) SetNalFuCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.NalFuCountValue = &v
	return s
}

// How many NAL `IDR` units handled by this decoder.
func (s InputRTPCountersImpl) NalIdrCount() *int {
	return s.NalIdrCountValue
}

// How many NAL `IDR` units handled by this decoder.
func (s *InputRTPCountersImpl) SetNalIdrCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.NalIdrCountValue = &v
	return s
}

// How many other NAL units handled by this decoder.
func (s InputRTPCountersImpl) NalOtherCount() *int {
	return s.NalOtherCountValue
}

// How many other NAL units handled by this decoder.
func (s *InputRTPCountersImpl) SetNalOtherCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.NalOtherCountValue = &v
	return s
}

// How many NAL `PPS` units handled by this decoder.
func (s InputRTPCountersImpl) NalPpsCount() *int {
	return s.NalPpsCountValue
}

// How many NAL `PPS` units handled by this decoder.
func (s *InputRTPCountersImpl) SetNalPpsCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.NalPpsCountValue = &v
	return s
}

// How many NAL `SEI` units handled by this decoder.
func (s InputRTPCountersImpl) NalSeiCount() *int {
	return s.NalSeiCountValue
}

// How many NAL `SEI` units handled by this decoder.
func (s *InputRTPCountersImpl) SetNalSeiCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.NalSeiCountValue = &v
	return s
}

// How many NAL `SINGLE` units handled by this decoder.
func (s InputRTPCountersImpl) NalSingleCount() *int {
	return s.NalSingleCountValue
}

// How many NAL `SINGLE` units handled by this decoder.
func (s *InputRTPCountersImpl) SetNalSingleCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.NalSingleCountValue = &v
	return s
}

// How many NAL `SLICE` units handled by this decoder.
func (s InputRTPCountersImpl) NalSliceCount() *int {
	return s.NalSliceCountValue
}

// How many NAL `SLICE` units handled by this decoder.
func (s *InputRTPCountersImpl) SetNalSliceCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.NalSliceCountValue = &v
	return s
}

// How many NAL `SPS` units handled by this decoder.
func (s InputRTPCountersImpl) NalSpsCount() *int {
	return s.NalSpsCountValue
}

// How many NAL `SPS` units handled by this decoder.
func (s *InputRTPCountersImpl) SetNalSpsCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.NalSpsCountValue = &v
	return s
}

// How many NAL `STAP_A` units handled by this decoder.
func (s InputRTPCountersImpl) NalStapACount() *int {
	return s.NalStapACountValue
}

// How many NAL `STAP_A` units handled by this decoder.
func (s *InputRTPCountersImpl) SetNalStapACount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.NalStapACountValue = &v
	return s
}

// How many NAL `VPS` units handled by this decoder.
func (s InputRTPCountersImpl) NalVpsCount() *int {
	return s.NalVpsCountValue
}

// How many NAL `VPS` units handled by this decoder.
func (s *InputRTPCountersImpl) SetNalVpsCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.NalVpsCountValue = &v
	return s
}

// If no marker bit packet is received after 400 RTP packets then decoder switches to `no_marker_mode` and
// makes frame on each timecode change.
// This flag shows if decoder works in `no_marker_mode`.
func (s InputRTPCountersImpl) NoMarkerModeFlag() *bool {
	return s.NoMarkerModeFlagValue
}

// If no marker bit packet is received after 400 RTP packets then decoder switches to `no_marker_mode` and
// makes frame on each timecode change.
// This flag shows if decoder works in `no_marker_mode`.
func (s *InputRTPCountersImpl) SetNoMarkerModeFlag(v bool) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.NoMarkerModeFlagValue = &v
	return s
}

// Number of rtp packets rejected due to wrong payload type
func (s InputRTPCountersImpl) PtRejectCount() *int {
	return s.PtRejectCountValue
}

// Number of rtp packets rejected due to wrong payload type
func (s *InputRTPCountersImpl) SetPtRejectCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.PtRejectCountValue = &v
	return s
}

// Total size of rejected packets due to wrong payload type (pt_reject_count) rtp packets
func (s InputRTPCountersImpl) PtRejectSum() *int {
	return s.PtRejectSumValue
}

// Total size of rejected packets due to wrong payload type (pt_reject_count) rtp packets
func (s *InputRTPCountersImpl) SetPtRejectSum(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.PtRejectSumValue = &v
	return s
}

// How many RTCP packets received for this channel
func (s InputRTPCountersImpl) RtcpPackets() *int {
	return s.RtcpPacketsValue
}

// How many RTCP packets received for this channel
func (s *InputRTPCountersImpl) SetRtcpPackets(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.RtcpPacketsValue = &v
	return s
}

// How many RTP packets received for this channel
func (s InputRTPCountersImpl) RTPPackets() *int {
	return s.RTPPacketsValue
}

// How many RTP packets received for this channel
func (s *InputRTPCountersImpl) SetRTPPackets(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.RTPPacketsValue = &v
	return s
}

// Sender wallclock deviation from server time in ms. Positive value means that sender time is ahead of server time.
func (s InputRTPCountersImpl) SenderClockDeviation() *int {
	return s.SenderClockDeviationValue
}

// Sender wallclock deviation from server time in ms. Positive value means that sender time is ahead of server time.
func (s *InputRTPCountersImpl) SetSenderClockDeviation(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.SenderClockDeviationValue = &v
	return s
}

// Number of rtcp SR packets which `RTP timestamp` is equal to the previous rtcp SR packet `RTP timestamp`.
func (s InputRTPCountersImpl) SrTSStuck() *int {
	return s.SrTSStuckValue
}

// Number of rtcp SR packets which `RTP timestamp` is equal to the previous rtcp SR packet `RTP timestamp`.
func (s *InputRTPCountersImpl) SetSrTSStuck(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.SrTSStuckValue = &v
	return s
}

// Time on this channel is jumped back from reference wallclock.
func (s InputRTPCountersImpl) TSGoesBackwards() *int {
	return s.TSGoesBackwardsValue
}

// Time on this channel is jumped back from reference wallclock.
func (s *InputRTPCountersImpl) SetTSGoesBackwards(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.TSGoesBackwardsValue = &v
	return s
}

// Time on this channel is jumped forward from reference wallclock.
func (s InputRTPCountersImpl) TSJumpForward() *int {
	return s.TSJumpForwardValue
}

// Time on this channel is jumped forward from reference wallclock.
func (s *InputRTPCountersImpl) SetTSJumpForward(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.TSJumpForwardValue = &v
	return s
}

// https://datatracker.ietf.org/doc/html/rfc6184#section-4.1
// access unit: A set of NAL units always containing a primary coded picture.  In addition to the primary coded
// picture, an access unit may also contain one or more redundant coded pictures or other NAL units not containing
// slices or slice data partitions of a coded picture.  The decoding of an access unit always results in a
// decoded picture.
// There is `marker bit` in RTP packet which is set for the very last packet of the access unit indicated by the RTP timestamp.
// It is protocol violation if received RTP packet has the same timestamp as previous marker bit packet.
// This counter is a number of RTP packets which `RTP timestamp` is equal to previous RTP marker bit packet.
func (s InputRTPCountersImpl) TSStuck() *int {
	return s.TSStuckValue
}

// https://datatracker.ietf.org/doc/html/rfc6184#section-4.1
// access unit: A set of NAL units always containing a primary coded picture.  In addition to the primary coded
// picture, an access unit may also contain one or more redundant coded pictures or other NAL units not containing
// slices or slice data partitions of a coded picture.  The decoding of an access unit always results in a
// decoded picture.
// There is `marker bit` in RTP packet which is set for the very last packet of the access unit indicated by the RTP timestamp.
// It is protocol violation if received RTP packet has the same timestamp as previous marker bit packet.
// This counter is a number of RTP packets which `RTP timestamp` is equal to previous RTP marker bit packet.
func (s *InputRTPCountersImpl) SetTSStuck(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.TSStuckValue = &v
	return s
}

// NewInputSdiCounters creates a new InputSdiCounters instance
func NewInputSdiCounters() InputSdiCounters {
	return &InputSdiCountersImpl{}
}

// Gauge of average duration of incoming frame calculated in real time.
func (s InputSdiCountersImpl) AvgRecvDuration() *int {
	return s.AvgRecvDurationValue
}

// Gauge of average duration of incoming frame calculated in real time.
func (s *InputSdiCountersImpl) SetAvgRecvDuration(v int) InputSdiCounters {
	if s == nil {
		return nil
	}
	s.AvgRecvDurationValue = &v
	return s
}

// Frames injected to fix client-side SDI stream drift.
func (s InputSdiCountersImpl) CompensatedFrames() *int {
	return s.CompensatedFramesValue
}

// Frames injected to fix client-side SDI stream drift.
func (s *InputSdiCountersImpl) SetCompensatedFrames(v int) InputSdiCounters {
	if s == nil {
		return nil
	}
	s.CompensatedFramesValue = &v
	return s
}

// Counter of configured audio sdi channels without samples or non valid.
func (s InputSdiCountersImpl) ErrorLostAudio() *int {
	return s.ErrorLostAudioValue
}

// Counter of configured audio sdi channels without samples or non valid.
func (s *InputSdiCountersImpl) SetErrorLostAudio(v int) InputSdiCounters {
	if s == nil {
		return nil
	}
	s.ErrorLostAudioValue = &v
	return s
}

// The frame was dropped due to too high CPU load.
func (s InputSdiCountersImpl) ErrorsCpuStall() *int {
	return s.ErrorsCpuStallValue
}

// The frame was dropped due to too high CPU load.
func (s *InputSdiCountersImpl) SetErrorsCpuStall(v int) InputSdiCounters {
	if s == nil {
		return nil
	}
	s.ErrorsCpuStallValue = &v
	return s
}

// Frame data is duplicated from previous frame because the input was too slow.
func (s InputSdiCountersImpl) ErrorsDuplicate() *int {
	return s.ErrorsDuplicateValue
}

// Frame data is duplicated from previous frame because the input was too slow.
func (s *InputSdiCountersImpl) SetErrorsDuplicate(v int) InputSdiCounters {
	if s == nil {
		return nil
	}
	s.ErrorsDuplicateValue = &v
	return s
}

// Frames dropped due to 'No signal'.
func (s InputSdiCountersImpl) ErrorsNoSignal() *int {
	return s.ErrorsNoSignalValue
}

// Frames dropped due to 'No signal'.
func (s *InputSdiCountersImpl) SetErrorsNoSignal(v int) InputSdiCounters {
	if s == nil {
		return nil
	}
	s.ErrorsNoSignalValue = &v
	return s
}

// Frame time is the same as the previous frame.
func (s InputSdiCountersImpl) ErrorsTSDuplicate() *int {
	return s.ErrorsTSDuplicateValue
}

// Frame time is the same as the previous frame.
func (s *InputSdiCountersImpl) SetErrorsTSDuplicate(v int) InputSdiCounters {
	if s == nil {
		return nil
	}
	s.ErrorsTSDuplicateValue = &v
	return s
}

// Gauge of maximum deviation from the estimated frame duration.
func (s InputSdiCountersImpl) PeakDurationDeviation() *int {
	return s.PeakDurationDeviationValue
}

// Gauge of maximum deviation from the estimated frame duration.
func (s *InputSdiCountersImpl) SetPeakDurationDeviation(v int) InputSdiCounters {
	if s == nil {
		return nil
	}
	s.PeakDurationDeviationValue = &v
	return s
}

// NewInputSrtCounters creates a new InputSrtCounters instance
func NewInputSrtCounters() InputSrtCounters {
	return &InputSrtCountersImpl{}
}

// How many SRT packets were dropped by various reasons
func (s InputSrtCountersImpl) ErrorDroppedPackets() *int {
	return s.ErrorDroppedPacketsValue
}

// How many SRT packets were dropped by various reasons
func (s *InputSrtCountersImpl) SetErrorDroppedPackets(v int) InputSrtCounters {
	if s == nil {
		return nil
	}
	s.ErrorDroppedPacketsValue = &v
	return s
}

// How many SRT packets were lost
func (s InputSrtCountersImpl) ErrorLostPackets() *int {
	return s.ErrorLostPacketsValue
}

// How many SRT packets were lost
func (s *InputSrtCountersImpl) SetErrorLostPackets(v int) InputSrtCounters {
	if s == nil {
		return nil
	}
	s.ErrorLostPacketsValue = &v
	return s
}

// Receiver buffering delay
func (s InputSrtCountersImpl) Latency() *int {
	return s.LatencyValue
}

// Receiver buffering delay
func (s *InputSrtCountersImpl) SetLatency(v int) InputSrtCounters {
	if s == nil {
		return nil
	}
	s.LatencyValue = &v
	return s
}

// Total incoming SRT packets counter
func (s InputSrtCountersImpl) Packets() *int {
	return s.PacketsValue
}

// Total incoming SRT packets counter
func (s *InputSrtCountersImpl) SetPackets(v int) InputSrtCounters {
	if s == nil {
		return nil
	}
	s.PacketsValue = &v
	return s
}

// How many packets were retransmitted
func (s InputSrtCountersImpl) RetransmittedPackets() *int {
	return s.RetransmittedPacketsValue
}

// How many packets were retransmitted
func (s *InputSrtCountersImpl) SetRetransmittedPackets(v int) InputSrtCounters {
	if s == nil {
		return nil
	}
	s.RetransmittedPacketsValue = &v
	return s
}

// Round-trip time
func (s InputSrtCountersImpl) Rtt() *int {
	return s.RttValue
}

// Round-trip time
func (s *InputSrtCountersImpl) SetRtt(v int) InputSrtCounters {
	if s == nil {
		return nil
	}
	s.RttValue = &v
	return s
}

// NewInputStats creates a new InputStats instance
func NewInputStats() InputStats {
	return &InputStatsImpl{}
}

// Whether this input is selected as active for the stream.
// Example: true
func (s InputStatsImpl) Active() *bool {
	return s.ActiveValue
}

// Whether this input is selected as active for the stream.
// Example: true
func (s *InputStatsImpl) SetActive(v bool) InputStats {
	if s == nil {
		return nil
	}
	s.ActiveValue = &v
	return s
}

// How many Ad markers passed to this stream from the inputs.
func (s InputStatsImpl) AdSplicesIngested() *int {
	return s.AdSplicesIngestedValue
}

// How many Ad markers passed to this stream from the inputs.
func (s *InputStatsImpl) SetAdSplicesIngested(v int) InputStats {
	if s == nil {
		return nil
	}
	s.AdSplicesIngestedValue = &v
	return s
}

// How many Ad markers inserted to this stream by user.
func (s InputStatsImpl) AdSplicesInserted() *int {
	return s.AdSplicesInsertedValue
}

// How many Ad markers inserted to this stream by user.
func (s *InputStatsImpl) SetAdSplicesInserted(v int) InputStats {
	if s == nil {
		return nil
	}
	s.AdSplicesInsertedValue = &v
	return s
}

func (s InputStatsImpl) Agent() InputAgentCounters {
	return s.AgentValue
}

func (s *InputStatsImpl) SetAgent(v InputAgentCounters) InputStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputAgentCountersImpl); ok {
		s.AgentValue = impl
	}
	return s
}

// Number of bytes received by this stream from live sources.
// It will be counted before transcoding and will sum all inputs working together.
// Format: bytes (bytes)
func (s InputStatsImpl) Bytes() *Bytes {
	return s.BytesValue
}

// Number of bytes received by this stream from live sources.
// It will be counted before transcoding and will sum all inputs working together.
// Format: bytes (bytes)
func (s *InputStatsImpl) SetBytes(v Bytes) InputStats {
	if s == nil {
		return nil
	}
	s.BytesValue = &v
	return s
}

// Number of bytes received by this stream when downloading from remote DVR.
// Format: bytes (bytes)
func (s InputStatsImpl) BytesDvr() *Bytes {
	return s.BytesDvrValue
}

// Number of bytes received by this stream when downloading from remote DVR.
// Format: bytes (bytes)
func (s *InputStatsImpl) SetBytesDvr(v Bytes) InputStats {
	if s == nil {
		return nil
	}
	s.BytesDvrValue = &v
	return s
}

// Indicates that the stream sources have different track sets, which may cause switching problems. The list of tracks to be compared is obtained only when the sources are checked or started, until then the stream is considered normal.
func (s InputStatsImpl) DivergentInputs() *bool {
	return s.DivergentInputsValue
}

// Indicates that the stream sources have different track sets, which may cause switching problems. The list of tracks to be compared is obtained only when the sources are checked or started, until then the stream is considered normal.
func (s *InputStatsImpl) SetDivergentInputs(v bool) InputStats {
	if s == nil {
		return nil
	}
	s.DivergentInputsValue = &v
	return s
}

// Information about DVR that this input has
func (s InputStatsImpl) DvrInfo() DvrInfo {
	return s.DvrInfoValue
}

// Information about DVR that this input has
func (s *InputStatsImpl) SetDvrInfo(v DvrInfo) InputStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*DvrInfoImpl); ok {
		s.DvrInfoValue = impl
	}
	return s
}

// Sum of all other specific errors in the last minute
// Example: 0
func (s InputStatsImpl) ErrorRate() *int {
	return s.ErrorRateValue
}

// Sum of all other specific errors in the last minute
// Example: 0
func (s *InputStatsImpl) SetErrorRate(v int) InputStats {
	if s == nil {
		return nil
	}
	s.ErrorRateValue = &v
	return s
}

// Sum of all other specific errors. Can be used for triggering alert on any error
// Example: 0
func (s InputStatsImpl) Errors() *int {
	return s.ErrorsValue
}

// Sum of all other specific errors. Can be used for triggering alert on any error
// Example: 0
func (s *InputStatsImpl) SetErrors(v int) InputStats {
	if s == nil {
		return nil
	}
	s.ErrorsValue = &v
	return s
}

// How many times we've got 403 (eaccess).
func (s InputStatsImpl) Errors403() *int {
	return s.Errors403Value
}

// How many times we've got 403 (eaccess).
func (s *InputStatsImpl) SetErrors403(v int) InputStats {
	if s == nil {
		return nil
	}
	s.Errors403Value = &v
	return s
}

// How many times we've got 404 (enoent).
func (s InputStatsImpl) Errors404() *int {
	return s.Errors404Value
}

// How many times we've got 404 (enoent).
func (s *InputStatsImpl) SetErrors404(v int) InputStats {
	if s == nil {
		return nil
	}
	s.Errors404Value = &v
	return s
}

// How many times we've got 500 (backend error).
func (s InputStatsImpl) Errors500() *int {
	return s.Errors500Value
}

// How many times we've got 500 (backend error).
func (s *InputStatsImpl) SetErrors500(v int) InputStats {
	if s == nil {
		return nil
	}
	s.Errors500Value = &v
	return s
}

// Demultiplexing was done right, but content is broken.
func (s InputStatsImpl) ErrorsBrokenPayload() *int {
	return s.ErrorsBrokenPayloadValue
}

// Demultiplexing was done right, but content is broken.
func (s *InputStatsImpl) SetErrorsBrokenPayload(v int) InputStats {
	if s == nil {
		return nil
	}
	s.ErrorsBrokenPayloadValue = &v
	return s
}

// How many times input was restarted due to internal crash.
// This may happen due to unhandled input.
func (s InputStatsImpl) ErrorsCrashed() *int {
	return s.ErrorsCrashedValue
}

// How many times input was restarted due to internal crash.
// This may happen due to unhandled input.
func (s *InputStatsImpl) SetErrorsCrashed(v int) InputStats {
	if s == nil {
		return nil
	}
	s.ErrorsCrashedValue = &v
	return s
}

// Decoder reset count due to abnormal DTS change. Can happen in MPEG-TS, RTP.
func (s InputStatsImpl) ErrorsDecoderReset() *int {
	return s.ErrorsDecoderResetValue
}

// Decoder reset count due to abnormal DTS change. Can happen in MPEG-TS, RTP.
func (s *InputStatsImpl) SetErrorsDecoderReset(v int) InputStats {
	if s == nil {
		return nil
	}
	s.ErrorsDecoderResetValue = &v
	return s
}

// This can be used as a `TS_sync_loss` - how many times MPEG-TS sync was lost.
// Also this counter refers to RTSP desync, when camera starts dropping TCP data and
// we have to find packet boundaries.
// Here we write count of such resynchronizations.
func (s InputStatsImpl) ErrorsDesync() *int {
	return s.ErrorsDesyncValue
}

// This can be used as a `TS_sync_loss` - how many times MPEG-TS sync was lost.
// Also this counter refers to RTSP desync, when camera starts dropping TCP data and
// we have to find packet boundaries.
// Here we write count of such resynchronizations.
func (s *InputStatsImpl) SetErrorsDesync(v int) InputStats {
	if s == nil {
		return nil
	}
	s.ErrorsDesyncValue = &v
	return s
}

// Dropped frames count due timestamp adjustment.
func (s InputStatsImpl) ErrorsDroppedFrames() *int {
	return s.ErrorsDroppedFramesValue
}

// Dropped frames count due timestamp adjustment.
func (s *InputStatsImpl) SetErrorsDroppedFrames(v int) InputStats {
	if s == nil {
		return nil
	}
	s.ErrorsDroppedFramesValue = &v
	return s
}

// RTP, MPEG-TS or other protocols have enough information to tell how many packets were lost
func (s InputStatsImpl) ErrorsLostPackets() *int {
	return s.ErrorsLostPacketsValue
}

// RTP, MPEG-TS or other protocols have enough information to tell how many packets were lost
func (s *InputStatsImpl) SetErrorsLostPackets(v int) InputStats {
	if s == nil {
		return nil
	}
	s.ErrorsLostPacketsValue = &v
	return s
}

// how many times PAT was missing during 0,5 seconds or pid 0 misses PAT
// `PAT_error`
func (s InputStatsImpl) ErrorsTSPat() *int {
	return s.ErrorsTSPatValue
}

// how many times PAT was missing during 0,5 seconds or pid 0 misses PAT
// `PAT_error`
func (s *InputStatsImpl) SetErrorsTSPat(v int) InputStats {
	if s == nil {
		return nil
	}
	s.ErrorsTSPatValue = &v
	return s
}

// How many times have received PAT that was missing required service (program)
func (s InputStatsImpl) ErrorsTSServiceLost() *int {
	return s.ErrorsTSServiceLostValue
}

// How many times have received PAT that was missing required service (program)
func (s *InputStatsImpl) SetErrorsTSServiceLost(v int) InputStats {
	if s == nil {
		return nil
	}
	s.ErrorsTSServiceLostValue = &v
	return s
}

// Number of connection restarts to fix ts_stuck issue. Can happen in RTSP.
func (s InputStatsImpl) ErrorsTSStuckRestarts() *int {
	return s.ErrorsTSStuckRestartsValue
}

// Number of connection restarts to fix ts_stuck issue. Can happen in RTSP.
func (s *InputStatsImpl) SetErrorsTSStuckRestarts(v int) InputStats {
	if s == nil {
		return nil
	}
	s.ErrorsTSStuckRestartsValue = &v
	return s
}

// Number of frames passed to this stream from the inputs.
func (s InputStatsImpl) Frames() *int {
	return s.FramesValue
}

// Number of frames passed to this stream from the inputs.
func (s *InputStatsImpl) SetFrames(v int) InputStats {
	if s == nil {
		return nil
	}
	s.FramesValue = &v
	return s
}

// Aggregated: how many times this stream has switched between different inputs.
// Individual input: number of times switched to this input.
func (s InputStatsImpl) InputSwitches() *int {
	return s.InputSwitchesValue
}

// Aggregated: how many times this stream has switched between different inputs.
// Individual input: number of times switched to this input.
func (s *InputStatsImpl) SetInputSwitches(v int) InputStats {
	if s == nil {
		return nil
	}
	s.InputSwitchesValue = &v
	return s
}

// Number of secondary inputs that have some problems.
// Example: 0
func (s InputStatsImpl) InvalidSecondaryInputs() *int {
	return s.InvalidSecondaryInputsValue
}

// Number of secondary inputs that have some problems.
// Example: 0
func (s *InputStatsImpl) SetInvalidSecondaryInputs(v int) InputStats {
	if s == nil {
		return nil
	}
	s.InvalidSecondaryInputsValue = &v
	return s
}

// IP address of the connected peer.
// Example: 172.16.25.73
func (s InputStatsImpl) IP() *string {
	return s.IPValue
}

// IP address of the connected peer.
// Example: 172.16.25.73
func (s *InputStatsImpl) SetIP(v string) InputStats {
	if s == nil {
		return nil
	}
	s.IPValue = &v
	return s
}

// Technical description of the input content.
func (s InputStatsImpl) MediaInfo() MediaInfo {
	return s.MediaInfoValue
}

// Technical description of the input content.
func (s *InputStatsImpl) SetMediaInfo(v MediaInfo) InputStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*MediaInfoImpl); ok {
		s.MediaInfoValue = impl
	}
	return s
}

// Indicates, how often does media_info changes
func (s InputStatsImpl) MediaInfoChanges() *int {
	return s.MediaInfoChangesValue
}

// Indicates, how often does media_info changes
func (s *InputStatsImpl) SetMediaInfoChanges(v int) InputStats {
	if s == nil {
		return nil
	}
	s.MediaInfoChangesValue = &v
	return s
}

func (s InputStatsImpl) MotionDetector() InputMotionDetectorCounters {
	return s.MotionDetectorValue
}

func (s *InputStatsImpl) SetMotionDetector(v InputMotionDetectorCounters) InputStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputMotionDetectorCountersImpl); ok {
		s.MotionDetectorValue = impl
	}
	return s
}

// How many seconds has this stream had no frames.
// Format: seconds (seconds)
func (s InputStatsImpl) NumSecNoData() *Seconds {
	return s.NumSecNoDataValue
}

// How many seconds has this stream had no frames.
// Format: seconds (seconds)
func (s *InputStatsImpl) SetNumSecNoData(v Seconds) InputStats {
	if s == nil {
		return nil
	}
	s.NumSecNoDataValue = &v
	return s
}

// How many seconds has this stream played from primary input.
// Format: seconds (seconds)
func (s InputStatsImpl) NumSecOnPrimaryInput() *Seconds {
	return s.NumSecOnPrimaryInputValue
}

// How many seconds has this stream played from primary input.
// Format: seconds (seconds)
func (s *InputStatsImpl) SetNumSecOnPrimaryInput(v Seconds) InputStats {
	if s == nil {
		return nil
	}
	s.NumSecOnPrimaryInputValue = &v
	return s
}

// How many seconds has this stream played from secondary inputs.
// Format: seconds (seconds)
func (s InputStatsImpl) NumSecOnSecondaryInput() *Seconds {
	return s.NumSecOnSecondaryInputValue
}

// How many seconds has this stream played from secondary inputs.
// Format: seconds (seconds)
func (s *InputStatsImpl) SetNumSecOnSecondaryInput(v Seconds) InputStats {
	if s == nil {
		return nil
	}
	s.NumSecOnSecondaryInputValue = &v
	return s
}

// The time when this session was created.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s InputStatsImpl) OpenedAt() *UtcMs {
	return s.OpenedAtValue
}

// The time when this session was created.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s *InputStatsImpl) SetOpenedAt(v UtcMs) InputStats {
	if s == nil {
		return nil
	}
	s.OpenedAtValue = &v
	return s
}

// Per pid statistics calculated for MPEG-TS input
func (s InputStatsImpl) Pids() []InputPidCounters {
	if s.PidsValue == nil {
		return nil
	}
	result := make([]InputPidCounters, len(s.PidsValue))
	for i, item := range s.PidsValue {
		result[i] = item
	}
	return result
}

// Per pid statistics calculated for MPEG-TS input
func (s *InputStatsImpl) SetPids(v []InputPidCounters) InputStats {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*InputPidCountersImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*InputPidCountersImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.PidsValue = impl
	}
	return s
}

// Protocol used for the data transmission in the session.
// Example: dash
func (s InputStatsImpl) Proto() *Protocol {
	return s.ProtoValue
}

// Protocol used for the data transmission in the session.
// Example: dash
func (s *InputStatsImpl) SetProto(v Protocol) InputStats {
	if s == nil {
		return nil
	}
	s.ProtoValue = &v
	return s
}

// Source may send frames not in the order they should be played. It will be catched and reordered.
// This counter indicates how many times did it happened.
func (s InputStatsImpl) ReorderCount() *int {
	return s.ReorderCountValue
}

// Source may send frames not in the order they should be played. It will be catched and reordered.
// This counter indicates how many times did it happened.
func (s *InputStatsImpl) SetReorderCount(v int) InputStats {
	if s == nil {
		return nil
	}
	s.ReorderCountValue = &v
	return s
}

// Source may send frames timestamps faster or slower than realtime.
// Live stream will catch it and resync. This counter indicates how many times did it happened.
func (s InputStatsImpl) ResyncCountDrift() *int {
	return s.ResyncCountDriftValue
}

// Source may send frames timestamps faster or slower than realtime.
// Live stream will catch it and resync. This counter indicates how many times did it happened.
func (s *InputStatsImpl) SetResyncCountDrift(v int) InputStats {
	if s == nil {
		return nil
	}
	s.ResyncCountDriftValue = &v
	return s
}

// Source may change timestamps without any signalling. This counter indicates how bad is the source
func (s InputStatsImpl) ResyncCountJump() *int {
	return s.ResyncCountJumpValue
}

// Source may change timestamps without any signalling. This counter indicates how bad is the source
func (s *InputStatsImpl) SetResyncCountJump(v int) InputStats {
	if s == nil {
		return nil
	}
	s.ResyncCountJumpValue = &v
	return s
}

// Stream timestamps are synchronized with real time. This counter tells, how many times
// it was syncronized after source reconnect.
func (s InputStatsImpl) ResyncCountNormal() *int {
	return s.ResyncCountNormalValue
}

// Stream timestamps are synchronized with real time. This counter tells, how many times
// it was syncronized after source reconnect.
func (s *InputStatsImpl) SetResyncCountNormal(v int) InputStats {
	if s == nil {
		return nil
	}
	s.ResyncCountNormalValue = &v
	return s
}

// How many times has this stream retried to connect to source
func (s InputStatsImpl) Retries() *int {
	return s.RetriesValue
}

// How many times has this stream retried to connect to source
func (s *InputStatsImpl) SetRetries(v int) InputStats {
	if s == nil {
		return nil
	}
	s.RetriesValue = &v
	return s
}

// Per channel statistics calculated for RTP input
func (s InputStatsImpl) RTPChannels() []InputRTPCounters {
	if s.RTPChannelsValue == nil {
		return nil
	}
	result := make([]InputRTPCounters, len(s.RTPChannelsValue))
	for i, item := range s.RTPChannelsValue {
		result[i] = item
	}
	return result
}

// Per channel statistics calculated for RTP input
func (s *InputStatsImpl) SetRTPChannels(v []InputRTPCounters) InputStats {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*InputRTPCountersImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*InputRTPCountersImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.RTPChannelsValue = impl
	}
	return s
}

func (s InputStatsImpl) Sdi() InputSdiCounters {
	return s.SdiValue
}

func (s *InputStatsImpl) SetSdi(v InputSdiCounters) InputStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputSdiCountersImpl); ok {
		s.SdiValue = impl
	}
	return s
}

func (s InputStatsImpl) Srt() InputSrtCounters {
	return s.SrtValue
}

func (s *InputStatsImpl) SetSrt(v InputSrtCounters) InputStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputSrtCountersImpl); ok {
		s.SrtValue = impl
	}
	return s
}

// The time period during which no frames were received from the stream's input.
// Format: ticks (ticks)
// Example: 1284
func (s InputStatsImpl) TSDelay() *Ticks {
	return s.TSDelayValue
}

// The time period during which no frames were received from the stream's input.
// Format: ticks (ticks)
// Example: 1284
func (s *InputStatsImpl) SetTSDelay(v Ticks) InputStats {
	if s == nil {
		return nil
	}
	s.TSDelayValue = &v
	return s
}

// The time period during which no frames were received per each track according to `media_info`
// Example: [1284]
func (s InputStatsImpl) TSDelayPerTracks() []Ticks {
	return s.TSDelayPerTracksValue
}

// The time period during which no frames were received per each track according to `media_info`
// Example: [1284]
func (s *InputStatsImpl) SetTSDelayPerTracks(v []Ticks) InputStats {
	if s == nil {
		return nil
	}
	s.TSDelayPerTracksValue = v
	return s
}

// Deprecated field. Will be deleted at 25.03
// Final URL after redirects.
// Deprecated because was never actually used.
// Format: url (url)
// Example: udp://239.0.0.1:1234
func (s InputStatsImpl) URL() *URL {
	return s.URLValue
}

// Deprecated field. Will be deleted at 25.03
// Final URL after redirects.
// Deprecated because was never actually used.
// Format: url (url)
// Example: udp://239.0.0.1:1234
func (s *InputStatsImpl) SetURL(v URL) InputStats {
	if s == nil {
		return nil
	}
	s.URLValue = &v
	return s
}

// Client's user agent for selected protocol.
// Example: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML. like Gecko) Chrome/90.0.4430.72 Safari/537.36
func (s InputStatsImpl) UserAgent() *string {
	return s.UserAgentValue
}

// Client's user agent for selected protocol.
// Example: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML. like Gecko) Chrome/90.0.4430.72 Safari/537.36
func (s *InputStatsImpl) SetUserAgent(v string) InputStats {
	if s == nil {
		return nil
	}
	s.UserAgentValue = &v
	return s
}

// Number of secondary inputs that have no problems.
// Example: 2
func (s InputStatsImpl) ValidSecondaryInputs() *int {
	return s.ValidSecondaryInputsValue
}

// Number of secondary inputs that have no problems.
// Example: 2
func (s *InputStatsImpl) SetValidSecondaryInputs(v int) InputStats {
	if s == nil {
		return nil
	}
	s.ValidSecondaryInputsValue = &v
	return s
}

// NewInputTrackInfo creates a new InputTrackInfo instance
func NewInputTrackInfo() InputTrackInfo {
	return &InputTrackInfoImpl{}
}

// Set of matching rules that will be checked
// to select from input tracks
func (s InputTrackInfoImpl) Match() InputTrackInfoMatch {
	return s.MatchValue
}

// Set of matching rules that will be checked
// to select from input tracks
func (s *InputTrackInfoImpl) SetMatch(v InputTrackInfoMatch) InputTrackInfo {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputTrackInfoMatchImpl); ok {
		s.MatchValue = impl
	}
	return s
}

// NewInputTrackInfoMatch creates a new InputTrackInfoMatch instance
func NewInputTrackInfoMatch() InputTrackInfoMatch {
	return &InputTrackInfoMatchImpl{}
}

// Select input codec
// Example: ac3
func (s InputTrackInfoMatchImpl) Codec() *FrameCodec {
	return s.CodecValue
}

// Select input codec
// Example: ac3
func (s *InputTrackInfoMatchImpl) SetCodec(v FrameCodec) InputTrackInfoMatch {
	if s == nil {
		return nil
	}
	s.CodecValue = &v
	return s
}

// SUnfortunately, the sources may change the index of track without notice.
// Please, use matching by index only and only if no other match option is suitable.
// Example: 2
func (s InputTrackInfoMatchImpl) Index() *int {
	return s.IndexValue
}

// SUnfortunately, the sources may change the index of track without notice.
// Please, use matching by index only and only if no other match option is suitable.
// Example: 2
func (s *InputTrackInfoMatchImpl) SetIndex(v int) InputTrackInfoMatch {
	if s == nil {
		return nil
	}
	s.IndexValue = &v
	return s
}

// Select input track language
// Example: eng
func (s InputTrackInfoMatchImpl) Language() *string {
	return s.LanguageValue
}

// Select input track language
// Example: eng
func (s *InputTrackInfoMatchImpl) SetLanguage(v string) InputTrackInfoMatch {
	if s == nil {
		return nil
	}
	s.LanguageValue = &v
	return s
}

// NewLayouterEntityFetched creates a new LayouterEntityFetched instance
func NewLayouterEntityFetched() LayouterEntityFetched {
	return &LayouterEntityFetchedImpl{}
}

// Entity configuration containing only those fields that are supported by Layouter.
// For supported fields see [Layouter Schema](https://flussonic.com/doc/api/layouter/)
func (s LayouterEntityFetchedImpl) EntityBody() any {
	return s.EntityBodyValue
}

// Entity configuration containing only those fields that are supported by Layouter.
// For supported fields see [Layouter Schema](https://flussonic.com/doc/api/layouter/)
func (s *LayouterEntityFetchedImpl) SetEntityBody(v any) LayouterEntityFetched {
	if s == nil {
		return nil
	}
	s.EntityBodyValue = v
	return s
}

// Unique identifier of the entity.
// For example, for `agent` it is `agent_id` field.
func (s LayouterEntityFetchedImpl) EntityID() *string {
	return s.EntityIDValue
}

// Unique identifier of the entity.
// For example, for `agent` it is `agent_id` field.
func (s *LayouterEntityFetchedImpl) SetEntityID(v string) LayouterEntityFetched {
	if s == nil {
		return nil
	}
	s.EntityIDValue = &v
	return s
}

// Type of the entity.
func (s LayouterEntityFetchedImpl) EntityType() *EntityEventEntityType {
	return s.EntityTypeValue
}

// Type of the entity.
func (s *LayouterEntityFetchedImpl) SetEntityType(v EntityEventEntityType) LayouterEntityFetched {
	if s == nil {
		return nil
	}
	s.EntityTypeValue = &v
	return s
}

// Entity fetched by Layouter. It may be Streamer, Stream or Agent.
func (s LayouterEntityFetchedImpl) Event() string {
	return s.EventValue
}

// Entity fetched by Layouter. It may be Streamer, Stream or Agent.
func (s *LayouterEntityFetchedImpl) SetEvent(v string) LayouterEntityFetched {
	if s == nil {
		return nil
	}
	s.EventValue = v
	return s
}

// Event identifier.
func (s LayouterEntityFetchedImpl) EventID() *int {
	return s.EventIDValue
}

// Event identifier.
func (s *LayouterEntityFetchedImpl) SetEventID(v int) LayouterEntityFetched {
	if s == nil {
		return nil
	}
	s.EventIDValue = &v
	return s
}

// Originator of event.
// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
// is configured as HTTP/HTTPS url.
// Example: flussonic.host
func (s LayouterEntityFetchedImpl) Server() *string {
	return s.ServerValue
}

// Originator of event.
// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
// is configured as HTTP/HTTPS url.
// Example: flussonic.host
func (s *LayouterEntityFetchedImpl) SetServer(v string) LayouterEntityFetched {
	if s == nil {
		return nil
	}
	s.ServerValue = &v
	return s
}

// Unique identifier of the operation.
// You can use this field to search for events related to same operation.
// Value of this field is taken from the `X-Trace-Id` header.
// If `X-Trace-Id` header is not set, it will be generated automatically.
// Service will use the value of this field to make outgoing requests.
// Format: uuid (uuid)
// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
func (s LayouterEntityFetchedImpl) TraceID() *UUID {
	return s.TraceIDValue
}

// Unique identifier of the operation.
// You can use this field to search for events related to same operation.
// Value of this field is taken from the `X-Trace-Id` header.
// If `X-Trace-Id` header is not set, it will be generated automatically.
// Service will use the value of this field to make outgoing requests.
// Format: uuid (uuid)
// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
func (s *LayouterEntityFetchedImpl) SetTraceID(v UUID) LayouterEntityFetched {
	if s == nil {
		return nil
	}
	s.TraceIDValue = &v
	return s
}

// The time of the event registration on the server.
// Format: utc_ms (Unix timestamp in milliseconds)
func (s LayouterEntityFetchedImpl) UtcMs() *UtcMs {
	return s.UtcMsValue
}

// The time of the event registration on the server.
// Format: utc_ms (Unix timestamp in milliseconds)
func (s *LayouterEntityFetchedImpl) SetUtcMs(v UtcMs) LayouterEntityFetched {
	if s == nil {
		return nil
	}
	s.UtcMsValue = &v
	return s
}

// NewLayouterFetchingStarted creates a new LayouterFetchingStarted instance
func NewLayouterFetchingStarted() LayouterFetchingStarted {
	return &LayouterFetchingStartedImpl{}
}

// Layouter started fetching entities for processing
func (s LayouterFetchingStartedImpl) Event() string {
	return s.EventValue
}

// Layouter started fetching entities for processing
func (s *LayouterFetchingStartedImpl) SetEvent(v string) LayouterFetchingStarted {
	if s == nil {
		return nil
	}
	s.EventValue = v
	return s
}

// Event identifier.
func (s LayouterFetchingStartedImpl) EventID() *int {
	return s.EventIDValue
}

// Event identifier.
func (s *LayouterFetchingStartedImpl) SetEventID(v int) LayouterFetchingStarted {
	if s == nil {
		return nil
	}
	s.EventIDValue = &v
	return s
}

// Originator of event.
// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
// is configured as HTTP/HTTPS url.
// Example: flussonic.host
func (s LayouterFetchingStartedImpl) Server() *string {
	return s.ServerValue
}

// Originator of event.
// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
// is configured as HTTP/HTTPS url.
// Example: flussonic.host
func (s *LayouterFetchingStartedImpl) SetServer(v string) LayouterFetchingStarted {
	if s == nil {
		return nil
	}
	s.ServerValue = &v
	return s
}

// Unique identifier of the operation.
// You can use this field to search for events related to same operation.
// Value of this field is taken from the `X-Trace-Id` header.
// If `X-Trace-Id` header is not set, it will be generated automatically.
// Service will use the value of this field to make outgoing requests.
// Format: uuid (uuid)
// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
func (s LayouterFetchingStartedImpl) TraceID() *UUID {
	return s.TraceIDValue
}

// Unique identifier of the operation.
// You can use this field to search for events related to same operation.
// Value of this field is taken from the `X-Trace-Id` header.
// If `X-Trace-Id` header is not set, it will be generated automatically.
// Service will use the value of this field to make outgoing requests.
// Format: uuid (uuid)
// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
func (s *LayouterFetchingStartedImpl) SetTraceID(v UUID) LayouterFetchingStarted {
	if s == nil {
		return nil
	}
	s.TraceIDValue = &v
	return s
}

// The time of the event registration on the server.
// Format: utc_ms (Unix timestamp in milliseconds)
func (s LayouterFetchingStartedImpl) UtcMs() *UtcMs {
	return s.UtcMsValue
}

// The time of the event registration on the server.
// Format: utc_ms (Unix timestamp in milliseconds)
func (s *LayouterFetchingStartedImpl) SetUtcMs(v UtcMs) LayouterFetchingStarted {
	if s == nil {
		return nil
	}
	s.UtcMsValue = &v
	return s
}

// NewLayouterProcessAgentsError creates a new LayouterProcessAgentsError instance
func NewLayouterProcessAgentsError() LayouterProcessAgentsError {
	return &LayouterProcessAgentsErrorImpl{}
}

// structured error
func (s LayouterProcessAgentsErrorImpl) Error() Error {
	return s.ErrorValue
}

// structured error
func (s *LayouterProcessAgentsErrorImpl) SetError(v Error) LayouterProcessAgentsError {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ErrorImpl); ok {
		s.ErrorValue = impl
	}
	return s
}

// Layouter process agents (without streams) error.
func (s LayouterProcessAgentsErrorImpl) Event() string {
	return s.EventValue
}

// Layouter process agents (without streams) error.
func (s *LayouterProcessAgentsErrorImpl) SetEvent(v string) LayouterProcessAgentsError {
	if s == nil {
		return nil
	}
	s.EventValue = v
	return s
}

// Event identifier.
func (s LayouterProcessAgentsErrorImpl) EventID() *int {
	return s.EventIDValue
}

// Event identifier.
func (s *LayouterProcessAgentsErrorImpl) SetEventID(v int) LayouterProcessAgentsError {
	if s == nil {
		return nil
	}
	s.EventIDValue = &v
	return s
}

// Originator of event.
// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
// is configured as HTTP/HTTPS url.
// Example: flussonic.host
func (s LayouterProcessAgentsErrorImpl) Server() *string {
	return s.ServerValue
}

// Originator of event.
// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
// is configured as HTTP/HTTPS url.
// Example: flussonic.host
func (s *LayouterProcessAgentsErrorImpl) SetServer(v string) LayouterProcessAgentsError {
	if s == nil {
		return nil
	}
	s.ServerValue = &v
	return s
}

// Unique identifier of the operation.
// You can use this field to search for events related to same operation.
// Value of this field is taken from the `X-Trace-Id` header.
// If `X-Trace-Id` header is not set, it will be generated automatically.
// Service will use the value of this field to make outgoing requests.
// Format: uuid (uuid)
// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
func (s LayouterProcessAgentsErrorImpl) TraceID() *UUID {
	return s.TraceIDValue
}

// Unique identifier of the operation.
// You can use this field to search for events related to same operation.
// Value of this field is taken from the `X-Trace-Id` header.
// If `X-Trace-Id` header is not set, it will be generated automatically.
// Service will use the value of this field to make outgoing requests.
// Format: uuid (uuid)
// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
func (s *LayouterProcessAgentsErrorImpl) SetTraceID(v UUID) LayouterProcessAgentsError {
	if s == nil {
		return nil
	}
	s.TraceIDValue = &v
	return s
}

// The time of the event registration on the server.
// Format: utc_ms (Unix timestamp in milliseconds)
func (s LayouterProcessAgentsErrorImpl) UtcMs() *UtcMs {
	return s.UtcMsValue
}

// The time of the event registration on the server.
// Format: utc_ms (Unix timestamp in milliseconds)
func (s *LayouterProcessAgentsErrorImpl) SetUtcMs(v UtcMs) LayouterProcessAgentsError {
	if s == nil {
		return nil
	}
	s.UtcMsValue = &v
	return s
}

// NewLayouterProcessAgentsSuccess creates a new LayouterProcessAgentsSuccess instance
func NewLayouterProcessAgentsSuccess() LayouterProcessAgentsSuccess {
	return &LayouterProcessAgentsSuccessImpl{}
}

// Number of updated agents (without streams) layouts.
func (s LayouterProcessAgentsSuccessImpl) AgentsUpdated() *int {
	return s.AgentsUpdatedValue
}

// Number of updated agents (without streams) layouts.
func (s *LayouterProcessAgentsSuccessImpl) SetAgentsUpdated(v int) LayouterProcessAgentsSuccess {
	if s == nil {
		return nil
	}
	s.AgentsUpdatedValue = &v
	return s
}

// Layouter process agents (without streams) success.
func (s LayouterProcessAgentsSuccessImpl) Event() string {
	return s.EventValue
}

// Layouter process agents (without streams) success.
func (s *LayouterProcessAgentsSuccessImpl) SetEvent(v string) LayouterProcessAgentsSuccess {
	if s == nil {
		return nil
	}
	s.EventValue = v
	return s
}

// Event identifier.
func (s LayouterProcessAgentsSuccessImpl) EventID() *int {
	return s.EventIDValue
}

// Event identifier.
func (s *LayouterProcessAgentsSuccessImpl) SetEventID(v int) LayouterProcessAgentsSuccess {
	if s == nil {
		return nil
	}
	s.EventIDValue = &v
	return s
}

// Originator of event.
// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
// is configured as HTTP/HTTPS url.
// Example: flussonic.host
func (s LayouterProcessAgentsSuccessImpl) Server() *string {
	return s.ServerValue
}

// Originator of event.
// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
// is configured as HTTP/HTTPS url.
// Example: flussonic.host
func (s *LayouterProcessAgentsSuccessImpl) SetServer(v string) LayouterProcessAgentsSuccess {
	if s == nil {
		return nil
	}
	s.ServerValue = &v
	return s
}

// Unique identifier of the operation.
// You can use this field to search for events related to same operation.
// Value of this field is taken from the `X-Trace-Id` header.
// If `X-Trace-Id` header is not set, it will be generated automatically.
// Service will use the value of this field to make outgoing requests.
// Format: uuid (uuid)
// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
func (s LayouterProcessAgentsSuccessImpl) TraceID() *UUID {
	return s.TraceIDValue
}

// Unique identifier of the operation.
// You can use this field to search for events related to same operation.
// Value of this field is taken from the `X-Trace-Id` header.
// If `X-Trace-Id` header is not set, it will be generated automatically.
// Service will use the value of this field to make outgoing requests.
// Format: uuid (uuid)
// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
func (s *LayouterProcessAgentsSuccessImpl) SetTraceID(v UUID) LayouterProcessAgentsSuccess {
	if s == nil {
		return nil
	}
	s.TraceIDValue = &v
	return s
}

// The time of the event registration on the server.
// Format: utc_ms (Unix timestamp in milliseconds)
func (s LayouterProcessAgentsSuccessImpl) UtcMs() *UtcMs {
	return s.UtcMsValue
}

// The time of the event registration on the server.
// Format: utc_ms (Unix timestamp in milliseconds)
func (s *LayouterProcessAgentsSuccessImpl) SetUtcMs(v UtcMs) LayouterProcessAgentsSuccess {
	if s == nil {
		return nil
	}
	s.UtcMsValue = &v
	return s
}

// NewLayouterProcessStreamsError creates a new LayouterProcessStreamsError instance
func NewLayouterProcessStreamsError() LayouterProcessStreamsError {
	return &LayouterProcessStreamsErrorImpl{}
}

// structured error
func (s LayouterProcessStreamsErrorImpl) Error() Error {
	return s.ErrorValue
}

// structured error
func (s *LayouterProcessStreamsErrorImpl) SetError(v Error) LayouterProcessStreamsError {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ErrorImpl); ok {
		s.ErrorValue = impl
	}
	return s
}

// Layouter process streams error.
func (s LayouterProcessStreamsErrorImpl) Event() string {
	return s.EventValue
}

// Layouter process streams error.
func (s *LayouterProcessStreamsErrorImpl) SetEvent(v string) LayouterProcessStreamsError {
	if s == nil {
		return nil
	}
	s.EventValue = v
	return s
}

// Event identifier.
func (s LayouterProcessStreamsErrorImpl) EventID() *int {
	return s.EventIDValue
}

// Event identifier.
func (s *LayouterProcessStreamsErrorImpl) SetEventID(v int) LayouterProcessStreamsError {
	if s == nil {
		return nil
	}
	s.EventIDValue = &v
	return s
}

// Originator of event.
// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
// is configured as HTTP/HTTPS url.
// Example: flussonic.host
func (s LayouterProcessStreamsErrorImpl) Server() *string {
	return s.ServerValue
}

// Originator of event.
// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
// is configured as HTTP/HTTPS url.
// Example: flussonic.host
func (s *LayouterProcessStreamsErrorImpl) SetServer(v string) LayouterProcessStreamsError {
	if s == nil {
		return nil
	}
	s.ServerValue = &v
	return s
}

// Unique identifier of the operation.
// You can use this field to search for events related to same operation.
// Value of this field is taken from the `X-Trace-Id` header.
// If `X-Trace-Id` header is not set, it will be generated automatically.
// Service will use the value of this field to make outgoing requests.
// Format: uuid (uuid)
// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
func (s LayouterProcessStreamsErrorImpl) TraceID() *UUID {
	return s.TraceIDValue
}

// Unique identifier of the operation.
// You can use this field to search for events related to same operation.
// Value of this field is taken from the `X-Trace-Id` header.
// If `X-Trace-Id` header is not set, it will be generated automatically.
// Service will use the value of this field to make outgoing requests.
// Format: uuid (uuid)
// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
func (s *LayouterProcessStreamsErrorImpl) SetTraceID(v UUID) LayouterProcessStreamsError {
	if s == nil {
		return nil
	}
	s.TraceIDValue = &v
	return s
}

// The time of the event registration on the server.
// Format: utc_ms (Unix timestamp in milliseconds)
func (s LayouterProcessStreamsErrorImpl) UtcMs() *UtcMs {
	return s.UtcMsValue
}

// The time of the event registration on the server.
// Format: utc_ms (Unix timestamp in milliseconds)
func (s *LayouterProcessStreamsErrorImpl) SetUtcMs(v UtcMs) LayouterProcessStreamsError {
	if s == nil {
		return nil
	}
	s.UtcMsValue = &v
	return s
}

// NewLayouterProcessStreamsSuccess creates a new LayouterProcessStreamsSuccess instance
func NewLayouterProcessStreamsSuccess() LayouterProcessStreamsSuccess {
	return &LayouterProcessStreamsSuccessImpl{}
}

// Layouter process streams success.
func (s LayouterProcessStreamsSuccessImpl) Event() string {
	return s.EventValue
}

// Layouter process streams success.
func (s *LayouterProcessStreamsSuccessImpl) SetEvent(v string) LayouterProcessStreamsSuccess {
	if s == nil {
		return nil
	}
	s.EventValue = v
	return s
}

// Event identifier.
func (s LayouterProcessStreamsSuccessImpl) EventID() *int {
	return s.EventIDValue
}

// Event identifier.
func (s *LayouterProcessStreamsSuccessImpl) SetEventID(v int) LayouterProcessStreamsSuccess {
	if s == nil {
		return nil
	}
	s.EventIDValue = &v
	return s
}

// Originator of event.
// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
// is configured as HTTP/HTTPS url.
// Example: flussonic.host
func (s LayouterProcessStreamsSuccessImpl) Server() *string {
	return s.ServerValue
}

// Originator of event.
// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
// is configured as HTTP/HTTPS url.
// Example: flussonic.host
func (s *LayouterProcessStreamsSuccessImpl) SetServer(v string) LayouterProcessStreamsSuccess {
	if s == nil {
		return nil
	}
	s.ServerValue = &v
	return s
}

// Number of updated streams layouts.
func (s LayouterProcessStreamsSuccessImpl) StreamsUpdated() *int {
	return s.StreamsUpdatedValue
}

// Number of updated streams layouts.
func (s *LayouterProcessStreamsSuccessImpl) SetStreamsUpdated(v int) LayouterProcessStreamsSuccess {
	if s == nil {
		return nil
	}
	s.StreamsUpdatedValue = &v
	return s
}

// Unique identifier of the operation.
// You can use this field to search for events related to same operation.
// Value of this field is taken from the `X-Trace-Id` header.
// If `X-Trace-Id` header is not set, it will be generated automatically.
// Service will use the value of this field to make outgoing requests.
// Format: uuid (uuid)
// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
func (s LayouterProcessStreamsSuccessImpl) TraceID() *UUID {
	return s.TraceIDValue
}

// Unique identifier of the operation.
// You can use this field to search for events related to same operation.
// Value of this field is taken from the `X-Trace-Id` header.
// If `X-Trace-Id` header is not set, it will be generated automatically.
// Service will use the value of this field to make outgoing requests.
// Format: uuid (uuid)
// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
func (s *LayouterProcessStreamsSuccessImpl) SetTraceID(v UUID) LayouterProcessStreamsSuccess {
	if s == nil {
		return nil
	}
	s.TraceIDValue = &v
	return s
}

// The time of the event registration on the server.
// Format: utc_ms (Unix timestamp in milliseconds)
func (s LayouterProcessStreamsSuccessImpl) UtcMs() *UtcMs {
	return s.UtcMsValue
}

// The time of the event registration on the server.
// Format: utc_ms (Unix timestamp in milliseconds)
func (s *LayouterProcessStreamsSuccessImpl) SetUtcMs(v UtcMs) LayouterProcessStreamsSuccess {
	if s == nil {
		return nil
	}
	s.UtcMsValue = &v
	return s
}

// NewLayouterProcessingResult creates a new LayouterProcessingResult instance
func NewLayouterProcessingResult() LayouterProcessingResult {
	return &LayouterProcessingResultImpl{}
}

// Result of processing fetched entities
func (s LayouterProcessingResultImpl) Event() string {
	return s.EventValue
}

// Result of processing fetched entities
func (s *LayouterProcessingResultImpl) SetEvent(v string) LayouterProcessingResult {
	if s == nil {
		return nil
	}
	s.EventValue = v
	return s
}

// Event identifier.
func (s LayouterProcessingResultImpl) EventID() *int {
	return s.EventIDValue
}

// Event identifier.
func (s *LayouterProcessingResultImpl) SetEventID(v int) LayouterProcessingResult {
	if s == nil {
		return nil
	}
	s.EventIDValue = &v
	return s
}

// List of relayouts made by Layouter
func (s LayouterProcessingResultImpl) Relayouts() []CentralStreamLayoutListItem {
	if s.RelayoutsValue == nil {
		return nil
	}
	result := make([]CentralStreamLayoutListItem, len(s.RelayoutsValue))
	for i, item := range s.RelayoutsValue {
		result[i] = item
	}
	return result
}

// List of relayouts made by Layouter
func (s *LayouterProcessingResultImpl) SetRelayouts(v []CentralStreamLayoutListItem) LayouterProcessingResult {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*CentralStreamLayoutListItemImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*CentralStreamLayoutListItemImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.RelayoutsValue = impl
	}
	return s
}

// Originator of event.
// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
// is configured as HTTP/HTTPS url.
// Example: flussonic.host
func (s LayouterProcessingResultImpl) Server() *string {
	return s.ServerValue
}

// Originator of event.
// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
// is configured as HTTP/HTTPS url.
// Example: flussonic.host
func (s *LayouterProcessingResultImpl) SetServer(v string) LayouterProcessingResult {
	if s == nil {
		return nil
	}
	s.ServerValue = &v
	return s
}

// Unique identifier of the operation.
// You can use this field to search for events related to same operation.
// Value of this field is taken from the `X-Trace-Id` header.
// If `X-Trace-Id` header is not set, it will be generated automatically.
// Service will use the value of this field to make outgoing requests.
// Format: uuid (uuid)
// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
func (s LayouterProcessingResultImpl) TraceID() *UUID {
	return s.TraceIDValue
}

// Unique identifier of the operation.
// You can use this field to search for events related to same operation.
// Value of this field is taken from the `X-Trace-Id` header.
// If `X-Trace-Id` header is not set, it will be generated automatically.
// Service will use the value of this field to make outgoing requests.
// Format: uuid (uuid)
// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
func (s *LayouterProcessingResultImpl) SetTraceID(v UUID) LayouterProcessingResult {
	if s == nil {
		return nil
	}
	s.TraceIDValue = &v
	return s
}

// The time of the event registration on the server.
// Format: utc_ms (Unix timestamp in milliseconds)
func (s LayouterProcessingResultImpl) UtcMs() *UtcMs {
	return s.UtcMsValue
}

// The time of the event registration on the server.
// Format: utc_ms (Unix timestamp in milliseconds)
func (s *LayouterProcessingResultImpl) SetUtcMs(v UtcMs) LayouterProcessingResult {
	if s == nil {
		return nil
	}
	s.UtcMsValue = &v
	return s
}

// NewListenConfig creates a new ListenConfig instance
func NewListenConfig() ListenConfig {
	return &ListenConfigImpl{}
}

// Network address that will be used for listening.
// Example: 10.0.35.1
func (s ListenConfigImpl) Address() *string {
	return s.AddressValue
}

// Network address that will be used for listening.
// Example: 10.0.35.1
func (s *ListenConfigImpl) SetAddress(v string) ListenConfig {
	if s == nil {
		return nil
	}
	s.AddressValue = &v
	return s
}

// Port that will be used for listening.
// Format: network_port (network_port)
// Example: 80
func (s ListenConfigImpl) Port() NetworkPort {
	return s.PortValue
}

// Port that will be used for listening.
// Format: network_port (network_port)
// Example: 80
func (s *ListenConfigImpl) SetPort(v NetworkPort) ListenConfig {
	if s == nil {
		return nil
	}
	s.PortValue = v
	return s
}

// NewListenHTTPConfig creates a new ListenHTTPConfig instance
func NewListenHTTPConfig() ListenHTTPConfig {
	return &ListenHTTPConfigImpl{}
}

// Network address that will be used for listening.
// Example: 10.0.35.1
func (s ListenHTTPConfigImpl) Address() *string {
	return s.AddressValue
}

// Network address that will be used for listening.
// Example: 10.0.35.1
func (s *ListenHTTPConfigImpl) SetAddress(v string) ListenHTTPConfig {
	if s == nil {
		return nil
	}
	s.AddressValue = &v
	return s
}

// If false, listener do not serve api calls.
func (s ListenHTTPConfigImpl) API() *bool {
	return s.APIValue
}

// If false, listener do not serve api calls.
func (s *ListenHTTPConfigImpl) SetAPI(v bool) ListenHTTPConfig {
	if s == nil {
		return nil
	}
	s.APIValue = &v
	return s
}

// Port that will be used for listening.
// Format: network_port (network_port)
// Example: 80
func (s ListenHTTPConfigImpl) Port() NetworkPort {
	return s.PortValue
}

// Port that will be used for listening.
// Format: network_port (network_port)
// Example: 80
func (s *ListenHTTPConfigImpl) SetPort(v NetworkPort) ListenHTTPConfig {
	if s == nil {
		return nil
	}
	s.PortValue = v
	return s
}

// Time from when the connection is accepted to when the request body is fully read
// Example: 5
func (s ListenHTTPConfigImpl) ReadTimeout() *int {
	return s.ReadTimeoutValue
}

// Time from when the connection is accepted to when the request body is fully read
// Example: 5
func (s *ListenHTTPConfigImpl) SetReadTimeout(v int) ListenHTTPConfig {
	if s == nil {
		return nil
	}
	s.ReadTimeoutValue = &v
	return s
}

// Time from the end of the request header read to the end of the response write
// Example: 5
func (s ListenHTTPConfigImpl) WriteTimeout() *int {
	return s.WriteTimeoutValue
}

// Time from the end of the request header read to the end of the response write
// Example: 5
func (s *ListenHTTPConfigImpl) SetWriteTimeout(v int) ListenHTTPConfig {
	if s == nil {
		return nil
	}
	s.WriteTimeoutValue = &v
	return s
}

// NewListenHTTPConfigParams creates a new ListenHTTPConfigParams instance
func NewListenHTTPConfigParams() ListenHTTPConfigParams {
	return &ListenHTTPConfigParamsImpl{}
}

// If false, listener do not serve api calls.
func (s ListenHTTPConfigParamsImpl) API() *bool {
	return s.APIValue
}

// If false, listener do not serve api calls.
func (s *ListenHTTPConfigParamsImpl) SetAPI(v bool) ListenHTTPConfigParams {
	if s == nil {
		return nil
	}
	s.APIValue = &v
	return s
}

// Time from when the connection is accepted to when the request body is fully read
// Example: 5
func (s ListenHTTPConfigParamsImpl) ReadTimeout() *int {
	return s.ReadTimeoutValue
}

// Time from when the connection is accepted to when the request body is fully read
// Example: 5
func (s *ListenHTTPConfigParamsImpl) SetReadTimeout(v int) ListenHTTPConfigParams {
	if s == nil {
		return nil
	}
	s.ReadTimeoutValue = &v
	return s
}

// Time from the end of the request header read to the end of the response write
// Example: 5
func (s ListenHTTPConfigParamsImpl) WriteTimeout() *int {
	return s.WriteTimeoutValue
}

// Time from the end of the request header read to the end of the response write
// Example: 5
func (s *ListenHTTPConfigParamsImpl) SetWriteTimeout(v int) ListenHTTPConfigParams {
	if s == nil {
		return nil
	}
	s.WriteTimeoutValue = &v
	return s
}

// NewListenHTTPSConfig creates a new ListenHTTPSConfig instance
func NewListenHTTPSConfig() ListenHTTPSConfig {
	return &ListenHTTPSConfigImpl{}
}

// Network address that will be used for listening.
// Example: 10.0.35.1
func (s ListenHTTPSConfigImpl) Address() *string {
	return s.AddressValue
}

// Network address that will be used for listening.
// Example: 10.0.35.1
func (s *ListenHTTPSConfigImpl) SetAddress(v string) ListenHTTPSConfig {
	if s == nil {
		return nil
	}
	s.AddressValue = &v
	return s
}

// If false, listener do not serve api calls.
func (s ListenHTTPSConfigImpl) API() *bool {
	return s.APIValue
}

// If false, listener do not serve api calls.
func (s *ListenHTTPSConfigImpl) SetAPI(v bool) ListenHTTPSConfig {
	if s == nil {
		return nil
	}
	s.APIValue = &v
	return s
}

// Path to ssl certificate
// Example: /etc/letsencrypt/live/central/fullchain.pem
func (s ListenHTTPSConfigImpl) Certificate() *string {
	return s.CertificateValue
}

// Path to ssl certificate
// Example: /etc/letsencrypt/live/central/fullchain.pem
func (s *ListenHTTPSConfigImpl) SetCertificate(v string) ListenHTTPSConfig {
	if s == nil {
		return nil
	}
	s.CertificateValue = &v
	return s
}

// Path to ssl certificate key
// Example: /etc/letsencrypt/live/central/privkey.pem
func (s ListenHTTPSConfigImpl) CertificateKey() *string {
	return s.CertificateKeyValue
}

// Path to ssl certificate key
// Example: /etc/letsencrypt/live/central/privkey.pem
func (s *ListenHTTPSConfigImpl) SetCertificateKey(v string) ListenHTTPSConfig {
	if s == nil {
		return nil
	}
	s.CertificateKeyValue = &v
	return s
}

// Port that will be used for listening.
// Format: network_port (network_port)
// Example: 80
func (s ListenHTTPSConfigImpl) Port() NetworkPort {
	return s.PortValue
}

// Port that will be used for listening.
// Format: network_port (network_port)
// Example: 80
func (s *ListenHTTPSConfigImpl) SetPort(v NetworkPort) ListenHTTPSConfig {
	if s == nil {
		return nil
	}
	s.PortValue = v
	return s
}

// Time from when the connection is accepted to when the request body is fully read
// Example: 5
func (s ListenHTTPSConfigImpl) ReadTimeout() *int {
	return s.ReadTimeoutValue
}

// Time from when the connection is accepted to when the request body is fully read
// Example: 5
func (s *ListenHTTPSConfigImpl) SetReadTimeout(v int) ListenHTTPSConfig {
	if s == nil {
		return nil
	}
	s.ReadTimeoutValue = &v
	return s
}

// List of SSL protocol versions that will be used for listening.
// Example: [tlsv1.1 tlsv1.2]
func (s ListenHTTPSConfigImpl) SslProtocols() []TlsVersion {
	return s.SslProtocolsValue
}

// List of SSL protocol versions that will be used for listening.
// Example: [tlsv1.1 tlsv1.2]
func (s *ListenHTTPSConfigImpl) SetSslProtocols(v []TlsVersion) ListenHTTPSConfig {
	if s == nil {
		return nil
	}
	s.SslProtocolsValue = v
	return s
}

// Time from the end of the request header read to the end of the response write
// Example: 5
func (s ListenHTTPSConfigImpl) WriteTimeout() *int {
	return s.WriteTimeoutValue
}

// Time from the end of the request header read to the end of the response write
// Example: 5
func (s *ListenHTTPSConfigImpl) SetWriteTimeout(v int) ListenHTTPSConfig {
	if s == nil {
		return nil
	}
	s.WriteTimeoutValue = &v
	return s
}

// NewListenSslConfig creates a new ListenSslConfig instance
func NewListenSslConfig() ListenSslConfig {
	return &ListenSslConfigImpl{}
}

// Path to ssl certificate
// Example: /etc/letsencrypt/live/central/fullchain.pem
func (s ListenSslConfigImpl) Certificate() *string {
	return s.CertificateValue
}

// Path to ssl certificate
// Example: /etc/letsencrypt/live/central/fullchain.pem
func (s *ListenSslConfigImpl) SetCertificate(v string) ListenSslConfig {
	if s == nil {
		return nil
	}
	s.CertificateValue = &v
	return s
}

// Path to ssl certificate key
// Example: /etc/letsencrypt/live/central/privkey.pem
func (s ListenSslConfigImpl) CertificateKey() *string {
	return s.CertificateKeyValue
}

// Path to ssl certificate key
// Example: /etc/letsencrypt/live/central/privkey.pem
func (s *ListenSslConfigImpl) SetCertificateKey(v string) ListenSslConfig {
	if s == nil {
		return nil
	}
	s.CertificateKeyValue = &v
	return s
}

// List of SSL protocol versions that will be used for listening.
// Example: [tlsv1.1 tlsv1.2]
func (s ListenSslConfigImpl) SslProtocols() []TlsVersion {
	return s.SslProtocolsValue
}

// List of SSL protocol versions that will be used for listening.
// Example: [tlsv1.1 tlsv1.2]
func (s *ListenSslConfigImpl) SetSslProtocols(v []TlsVersion) ListenSslConfig {
	if s == nil {
		return nil
	}
	s.SslProtocolsValue = v
	return s
}

// NewListeners creates a new Listeners instance
func NewListeners() Listeners {
	return &ListenersImpl{}
}

// List of HTTP ports or `host:port` pairs that will be used for listening.
// Examples: [map[api:false, port:80]]
func (s ListenersImpl) HTTP() []ListenHTTPConfig {
	if s.HTTPValue == nil {
		return nil
	}
	result := make([]ListenHTTPConfig, len(s.HTTPValue))
	for i, item := range s.HTTPValue {
		result[i] = item
	}
	return result
}

// List of HTTP ports or `host:port` pairs that will be used for listening.
// Examples: [map[api:false, port:80]]
func (s *ListenersImpl) SetHTTP(v []ListenHTTPConfig) Listeners {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*ListenHTTPConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*ListenHTTPConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.HTTPValue = impl
	}
	return s
}

// List of HTTPS ports or `host:port` pairs that will be used for listening.
// Examples: [map[port:443]]
func (s ListenersImpl) HTTPS() []ListenHTTPSConfig {
	if s.HTTPSValue == nil {
		return nil
	}
	result := make([]ListenHTTPSConfig, len(s.HTTPSValue))
	for i, item := range s.HTTPSValue {
		result[i] = item
	}
	return result
}

// List of HTTPS ports or `host:port` pairs that will be used for listening.
// Examples: [map[port:443]]
func (s *ListenersImpl) SetHTTPS(v []ListenHTTPSConfig) Listeners {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*ListenHTTPSConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*ListenHTTPSConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.HTTPSValue = impl
	}
	return s
}

// NewMediaInfo creates a new MediaInfo instance
func NewMediaInfo() MediaInfo {
	return &MediaInfoImpl{}
}

// Duration of the media, if applicable.
// Format: ticks (ticks)
func (s MediaInfoImpl) Duration() *Ticks {
	return s.DurationValue
}

// Duration of the media, if applicable.
// Format: ticks (ticks)
func (s *MediaInfoImpl) SetDuration(v Ticks) MediaInfo {
	if s == nil {
		return nil
	}
	s.DurationValue = &v
	return s
}

// Whether it is a file with a finite start and end time or a live stream.
// Example: stream
func (s MediaInfoImpl) FlowType() *MediaInfoSpecificFlowType {
	return s.FlowTypeValue
}

// Whether it is a file with a finite start and end time or a live stream.
// Example: stream
func (s *MediaInfoImpl) SetFlowType(v MediaInfoSpecificFlowType) MediaInfo {
	if s == nil {
		return nil
	}
	s.FlowTypeValue = &v
	return s
}

// The program ID for MPEG TS streams.
// Example: 110
func (s MediaInfoImpl) ProgramID() *int {
	return s.ProgramIDValue
}

// The program ID for MPEG TS streams.
// Example: 110
func (s *MediaInfoImpl) SetProgramID(v int) MediaInfo {
	if s == nil {
		return nil
	}
	s.ProgramIDValue = &v
	return s
}

// The media provider of this content.
// Example: Netflix
func (s MediaInfoImpl) Provider() *string {
	return s.ProviderValue
}

// The media provider of this content.
// Example: Netflix
func (s *MediaInfoImpl) SetProvider(v string) MediaInfo {
	if s == nil {
		return nil
	}
	s.ProviderValue = &v
	return s
}

// The identifier of the transport stream for MPEG TS streams.
// Example: 253
func (s MediaInfoImpl) StreamID() *int {
	return s.StreamIDValue
}

// The identifier of the transport stream for MPEG TS streams.
// Example: 253
func (s *MediaInfoImpl) SetStreamID(v int) MediaInfo {
	if s == nil {
		return nil
	}
	s.StreamIDValue = &v
	return s
}

// Human-readable title of the media.
// Example: Bunny
func (s MediaInfoImpl) Title() *string {
	return s.TitleValue
}

// Human-readable title of the media.
// Example: Bunny
func (s *MediaInfoImpl) SetTitle(v string) MediaInfo {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// Information about available tracks (video, audio, or text).
func (s MediaInfoImpl) Tracks() []TrackInfo {
	if s.TracksValue == nil {
		return nil
	}
	result := make([]TrackInfo, len(s.TracksValue))
	for i, item := range s.TracksValue {
		result[i] = item
	}
	return result
}

// Information about available tracks (video, audio, or text).
func (s *MediaInfoImpl) SetTracks(v []TrackInfo) MediaInfo {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*TrackInfoImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*TrackInfoImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.TracksValue = impl
	}
	return s
}

// NewMediaInfoCommon creates a new MediaInfoCommon instance
func NewMediaInfoCommon() MediaInfoCommon {
	return &MediaInfoCommonImpl{}
}

// The program ID for MPEG TS streams.
// Example: 110
func (s MediaInfoCommonImpl) ProgramID() *int {
	return s.ProgramIDValue
}

// The program ID for MPEG TS streams.
// Example: 110
func (s *MediaInfoCommonImpl) SetProgramID(v int) MediaInfoCommon {
	if s == nil {
		return nil
	}
	s.ProgramIDValue = &v
	return s
}

// The media provider of this content.
// Example: Netflix
func (s MediaInfoCommonImpl) Provider() *string {
	return s.ProviderValue
}

// The media provider of this content.
// Example: Netflix
func (s *MediaInfoCommonImpl) SetProvider(v string) MediaInfoCommon {
	if s == nil {
		return nil
	}
	s.ProviderValue = &v
	return s
}

// The identifier of the transport stream for MPEG TS streams.
// Example: 253
func (s MediaInfoCommonImpl) StreamID() *int {
	return s.StreamIDValue
}

// The identifier of the transport stream for MPEG TS streams.
// Example: 253
func (s *MediaInfoCommonImpl) SetStreamID(v int) MediaInfoCommon {
	if s == nil {
		return nil
	}
	s.StreamIDValue = &v
	return s
}

// Human-readable title of the media.
// Example: Bunny
func (s MediaInfoCommonImpl) Title() *string {
	return s.TitleValue
}

// Human-readable title of the media.
// Example: Bunny
func (s *MediaInfoCommonImpl) SetTitle(v string) MediaInfoCommon {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// NewMediaInfoSpecific creates a new MediaInfoSpecific instance
func NewMediaInfoSpecific() MediaInfoSpecific {
	return &MediaInfoSpecificImpl{}
}

// Duration of the media, if applicable.
// Format: ticks (ticks)
func (s MediaInfoSpecificImpl) Duration() *Ticks {
	return s.DurationValue
}

// Duration of the media, if applicable.
// Format: ticks (ticks)
func (s *MediaInfoSpecificImpl) SetDuration(v Ticks) MediaInfoSpecific {
	if s == nil {
		return nil
	}
	s.DurationValue = &v
	return s
}

// Whether it is a file with a finite start and end time or a live stream.
// Example: stream
func (s MediaInfoSpecificImpl) FlowType() *MediaInfoSpecificFlowType {
	return s.FlowTypeValue
}

// Whether it is a file with a finite start and end time or a live stream.
// Example: stream
func (s *MediaInfoSpecificImpl) SetFlowType(v MediaInfoSpecificFlowType) MediaInfoSpecific {
	if s == nil {
		return nil
	}
	s.FlowTypeValue = &v
	return s
}

// Information about available tracks (video, audio, or text).
func (s MediaInfoSpecificImpl) Tracks() []TrackInfo {
	if s.TracksValue == nil {
		return nil
	}
	result := make([]TrackInfo, len(s.TracksValue))
	for i, item := range s.TracksValue {
		result[i] = item
	}
	return result
}

// Information about available tracks (video, audio, or text).
func (s *MediaInfoSpecificImpl) SetTracks(v []TrackInfo) MediaInfoSpecific {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*TrackInfoImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*TrackInfoImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.TracksValue = impl
	}
	return s
}

// NewOpenmetricsLabels creates a new OpenmetricsLabels instance
func NewOpenmetricsLabels() OpenmetricsLabels {
	return &OpenmetricsLabelsImpl{}
}

// NewOutputMpegtsPids creates a new OutputMpegtsPids instance
func NewOutputMpegtsPids() OutputMpegtsPids {
	return &OutputMpegtsPidsImpl{}
}

// The default algorithm of selecting PID for a track.
// * `auto`: track PID = PMT PID + track ID,
// where PMT PID is the PID of Program Map Table and track ID is a number of the track set by Flussonic
// (usually, all video tracks and then all audio tracks are numbered starting from 1).
// * `increment`: track PID = previous track PID + 1.
func (s OutputMpegtsPidsImpl) Default() *string {
	return s.DefaultValue
}

// The default algorithm of selecting PID for a track.
// * `auto`: track PID = PMT PID + track ID,
// where PMT PID is the PID of Program Map Table and track ID is a number of the track set by Flussonic
// (usually, all video tracks and then all audio tracks are numbered starting from 1).
// * `increment`: track PID = previous track PID + 1.
func (s *OutputMpegtsPidsImpl) SetDefault(v string) OutputMpegtsPids {
	if s == nil {
		return nil
	}
	s.DefaultValue = &v
	return s
}

// Information about a particular media track.
func (s OutputMpegtsPidsImpl) Media() []TransponderPid {
	if s.MediaValue == nil {
		return nil
	}
	result := make([]TransponderPid, len(s.MediaValue))
	for i, item := range s.MediaValue {
		result[i] = item
	}
	return result
}

// Information about a particular media track.
func (s *OutputMpegtsPidsImpl) SetMedia(v []TransponderPid) OutputMpegtsPids {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*TransponderPidImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*TransponderPidImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.MediaValue = impl
	}
	return s
}

// PID of the elementary stream that contains PCR (Program Clock Reference) in the outgoing MPEG-TS stream.
// PCR is the time label used for synchronization of a stream playback with real time.
// Additionally, for DVB streams it is used for managing a decoder and its buffer.
// In this case, PCR gives a signal to the frames with DTS<PCR to be sent to the decoder from the buffer.
// This mechanism allows to compensate different sizes of frames: if a frame is too big to be played in time with a specified FPS, the frames from the buffer are played.
func (s OutputMpegtsPidsImpl) Pcr() *int {
	return s.PcrValue
}

// PID of the elementary stream that contains PCR (Program Clock Reference) in the outgoing MPEG-TS stream.
// PCR is the time label used for synchronization of a stream playback with real time.
// Additionally, for DVB streams it is used for managing a decoder and its buffer.
// In this case, PCR gives a signal to the frames with DTS<PCR to be sent to the decoder from the buffer.
// This mechanism allows to compensate different sizes of frames: if a frame is too big to be played in time with a specified FPS, the frames from the buffer are played.
func (s *OutputMpegtsPidsImpl) SetPcr(v int) OutputMpegtsPids {
	if s == nil {
		return nil
	}
	s.PcrValue = &v
	return s
}

// PID  of the elementary stream that contains Program Map Table (PMT) in the outgoing MPEG-TS stream.
// PMT contains the description of each program and lists the PIDs of elementary streams associated with that program.
// For instance, a transport stream used in digital television might contain three programs, to represent three television channels.
// Suppose each channel consists of one video stream, one or two audio streams, and any necessary metadata.
// A receiver wishing to decode one of the three channels merely has to decode the payloads of each PID associated with its program.
// It can discard the contents of all other PIDs.
func (s OutputMpegtsPidsImpl) Pmt() *int {
	return s.PmtValue
}

// PID  of the elementary stream that contains Program Map Table (PMT) in the outgoing MPEG-TS stream.
// PMT contains the description of each program and lists the PIDs of elementary streams associated with that program.
// For instance, a transport stream used in digital television might contain three programs, to represent three television channels.
// Suppose each channel consists of one video stream, one or two audio streams, and any necessary metadata.
// A receiver wishing to decode one of the three channels merely has to decode the payloads of each PID associated with its program.
// It can discard the contents of all other PIDs.
func (s *OutputMpegtsPidsImpl) SetPmt(v int) OutputMpegtsPids {
	if s == nil {
		return nil
	}
	s.PmtValue = &v
	return s
}

// PID  of the elementary stream that contains Service Description Table (SDT) in the outgoing MPEG-TS stream.
// SDT provides information about services contained in MPEG-TS stream.
func (s OutputMpegtsPidsImpl) Sdt() *int {
	return s.SdtValue
}

// PID  of the elementary stream that contains Service Description Table (SDT) in the outgoing MPEG-TS stream.
// SDT provides information about services contained in MPEG-TS stream.
func (s *OutputMpegtsPidsImpl) SetSdt(v int) OutputMpegtsPids {
	if s == nil {
		return nil
	}
	s.SdtValue = &v
	return s
}

// NewPartitionStats creates a new PartitionStats instance
func NewPartitionStats() PartitionStats {
	return &PartitionStatsImpl{}
}

// The block device or file related to a mount path.
// Format: disk_device (disk_device)
// Example: sda1
func (s PartitionStatsImpl) Device() *DiskDevice {
	return s.DeviceValue
}

// The block device or file related to a mount path.
// Format: disk_device (disk_device)
// Example: sda1
func (s *PartitionStatsImpl) SetDevice(v DiskDevice) PartitionStats {
	if s == nil {
		return nil
	}
	s.DeviceValue = &v
	return s
}

// Percentage of IO utilization for device related to a mount path.
// Format: percent (percent)
// Example: 42
func (s PartitionStatsImpl) IoUtil() *Percent {
	return s.IoUtilValue
}

// Percentage of IO utilization for device related to a mount path.
// Format: percent (percent)
// Example: 42
func (s *PartitionStatsImpl) SetIoUtil(v Percent) PartitionStats {
	if s == nil {
		return nil
	}
	s.IoUtilValue = &v
	return s
}

// Mount path.
// Format: disk_path (disk_path)
// Example: _var_lib_docker_overlay2_3684778579db0a4d418fdc1a8a6953b680ab92d179a7d6f9506710d073095e36_merged
func (s PartitionStatsImpl) Path() *DiskPath {
	return s.PathValue
}

// Mount path.
// Format: disk_path (disk_path)
// Example: _var_lib_docker_overlay2_3684778579db0a4d418fdc1a8a6953b680ab92d179a7d6f9506710d073095e36_merged
func (s *PartitionStatsImpl) SetPath(v DiskPath) PartitionStats {
	if s == nil {
		return nil
	}
	s.PathValue = &v
	return s
}

// Total number of megabytes shown by the OS for this partition.
// Format: megabytes (megabytes)
// Example: 45423
func (s PartitionStatsImpl) TotalMb() *Megabytes {
	return s.TotalMbValue
}

// Total number of megabytes shown by the OS for this partition.
// Format: megabytes (megabytes)
// Example: 45423
func (s *PartitionStatsImpl) SetTotalMb(v Megabytes) PartitionStats {
	if s == nil {
		return nil
	}
	s.TotalMbValue = &v
	return s
}

// Percentage of usage of this partition.
// Format: percent (percent)
// Example: 30
func (s PartitionStatsImpl) Usage() *Percent {
	return s.UsageValue
}

// Percentage of usage of this partition.
// Format: percent (percent)
// Example: 30
func (s *PartitionStatsImpl) SetUsage(v Percent) PartitionStats {
	if s == nil {
		return nil
	}
	s.UsageValue = &v
	return s
}

// NewPeerConfig creates a new PeerConfig instance
func NewPeerConfig() PeerConfig {
	return &PeerConfigImpl{}
}

// The URL for provisioning of configuration from the managing server to the streamer.
// This URL does not have to be public but must be accessible from the managing server.
// The API URL can also be used as Public and/or Private payload URL if they are not set.
// When used as Public payload URL, the API URL shall be public to allow playback from this streamer.
// Format: url (url)
// Example: http://streamer.local:8080
func (s PeerConfigImpl) APIURL() *URL {
	return s.APIURLValue
}

// The URL for provisioning of configuration from the managing server to the streamer.
// This URL does not have to be public but must be accessible from the managing server.
// The API URL can also be used as Public and/or Private payload URL if they are not set.
// When used as Public payload URL, the API URL shall be public to allow playback from this streamer.
// Format: url (url)
// Example: http://streamer.local:8080
func (s *PeerConfigImpl) SetAPIURL(v URL) PeerConfig {
	if s == nil {
		return nil
	}
	s.APIURLValue = &v
	return s
}

// Maximal number of streams.
// Example: 5
func (s PeerConfigImpl) ChannelLimit() *int {
	return s.ChannelLimitValue
}

// Maximal number of streams.
// Example: 5
func (s *PeerConfigImpl) SetChannelLimit(v int) PeerConfig {
	if s == nil {
		return nil
	}
	s.ChannelLimitValue = &v
	return s
}

// The key for authorization for inter-Flussonic connections.
// All cluster peers should have the same cluster key.
// Example: xS6i6Q3DCc5nEvnu
func (s PeerConfigImpl) ClusterKey() *string {
	return s.ClusterKeyValue
}

// The key for authorization for inter-Flussonic connections.
// All cluster peers should have the same cluster key.
// Example: xS6i6Q3DCc5nEvnu
func (s *PeerConfigImpl) SetClusterKey(v string) PeerConfig {
	if s == nil {
		return nil
	}
	s.ClusterKeyValue = &v
	return s
}

// CPU limit in percents.
// Format: percent (percent)
// Example: 10
func (s PeerConfigImpl) CpuLimit() *Percent {
	return s.CpuLimitValue
}

// CPU limit in percents.
// Format: percent (percent)
// Example: 10
func (s *PeerConfigImpl) SetCpuLimit(v Percent) PeerConfig {
	if s == nil {
		return nil
	}
	s.CpuLimitValue = &v
	return s
}

// How often the peer will try to get the data from the remote server via internal API.
// Format: milliseconds (milliseconds)
// Example: 1000
func (s PeerConfigImpl) FetchTimeout() *Milliseconds {
	return s.FetchTimeoutValue
}

// How often the peer will try to get the data from the remote server via internal API.
// Format: milliseconds (milliseconds)
// Example: 1000
func (s *PeerConfigImpl) SetFetchTimeout(v Milliseconds) PeerConfig {
	if s == nil {
		return nil
	}
	s.FetchTimeoutValue = &v
	return s
}

// Streamer's identifier in the cluster.
// The managing server may try using this hostname to access the streamer
// if API URL is not specified.
// Format: server_name (server_name)
// Example: peer.example.com
func (s PeerConfigImpl) Hostname() *ServerName {
	return s.HostnameValue
}

// Streamer's identifier in the cluster.
// The managing server may try using this hostname to access the streamer
// if API URL is not specified.
// Format: server_name (server_name)
// Example: peer.example.com
func (s *PeerConfigImpl) SetHostname(v ServerName) PeerConfig {
	if s == nil {
		return nil
	}
	s.HostnameValue = &v
	return s
}

// Deprecated field. Will be deleted at 23.09
// Maximal output bitrate of the peer.
// Format: speed (speed)
func (s PeerConfigImpl) MaxBitrate() *Speed {
	return s.MaxBitrateValue
}

// Deprecated field. Will be deleted at 23.09
// Maximal output bitrate of the peer.
// Format: speed (speed)
func (s *PeerConfigImpl) SetMaxBitrate(v Speed) PeerConfig {
	if s == nil {
		return nil
	}
	s.MaxBitrateValue = &v
	return s
}

// Streamer's logical namespace, used for interacting with streams of the same namespace. By default, a streamer has no assigned namespace. In this default state, it can interact with streams that also have no assigned namespace. If a namespace is explicitly set, the streamer will only interact with streams possessing that specific namespace.
// For example, the layouter will distribute streams only to streamers with the same namespace. The `dynamic_streams_list` endpoint will operate exclusively within a single namespace.
// ***Use case:***
// Namespaces provide strict, system-wide resource isolation, fundamentally separating streams and streamers into independent segments. This ensures no interaction, archive access, inference processing, or layout operations occur between different namespaces.
// Unlike labels, which offer flexible, attribute-based layout control within a namespace, namespaces define an absolute boundary: resources from one namespace cannot interact with resources from another.
// ***Important:***
// A namespace can only be assigned when the streamer is created and cannot be changed afterwards.
// Format: unix_name (Contains only alphanumeric characters (a-z, A-Z, 0-9), underscores (_), hyphens (-) and periods (.).)
// Pattern: ^[a-zA-Z0-9_.-]+$
// Example: example
func (s PeerConfigImpl) Namespace() *UnixName {
	return s.NamespaceValue
}

// Streamer's logical namespace, used for interacting with streams of the same namespace. By default, a streamer has no assigned namespace. In this default state, it can interact with streams that also have no assigned namespace. If a namespace is explicitly set, the streamer will only interact with streams possessing that specific namespace.
// For example, the layouter will distribute streams only to streamers with the same namespace. The `dynamic_streams_list` endpoint will operate exclusively within a single namespace.
// ***Use case:***
// Namespaces provide strict, system-wide resource isolation, fundamentally separating streams and streamers into independent segments. This ensures no interaction, archive access, inference processing, or layout operations occur between different namespaces.
// Unlike labels, which offer flexible, attribute-based layout control within a namespace, namespaces define an absolute boundary: resources from one namespace cannot interact with resources from another.
// ***Important:***
// A namespace can only be assigned when the streamer is created and cannot be changed afterwards.
// Format: unix_name (Contains only alphanumeric characters (a-z, A-Z, 0-9), underscores (_), hyphens (-) and periods (.).)
// Pattern: ^[a-zA-Z0-9_.-]+$
// Example: example
func (s *PeerConfigImpl) SetNamespace(v UnixName) PeerConfig {
	if s == nil {
		return nil
	}
	s.NamespaceValue = &v
	return s
}

// The time after which deleted streams on this server are considered to be inactive
// and cannot be used in the `cluster_ingest` mechanism.
// Format: milliseconds (milliseconds)
// Example: 1000
func (s PeerConfigImpl) StaleTimeout() *Milliseconds {
	return s.StaleTimeoutValue
}

// The time after which deleted streams on this server are considered to be inactive
// and cannot be used in the `cluster_ingest` mechanism.
// Format: milliseconds (milliseconds)
// Example: 1000
func (s *PeerConfigImpl) SetStaleTimeout(v Milliseconds) PeerConfig {
	if s == nil {
		return nil
	}
	s.StaleTimeoutValue = &v
	return s
}

// Statistics on peers in the cluster.
func (s PeerConfigImpl) Stats() PeerStats {
	return s.StatsValue
}

// Statistics on peers in the cluster.
func (s *PeerConfigImpl) SetStats(v PeerStats) PeerConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*PeerStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// NewPeerStats creates a new PeerStats instance
func NewPeerStats() PeerStats {
	return &PeerStatsImpl{}
}

// Outbound bandwidth usage (load balancing in `usage` mode is based on this value).
// Format: percent (percent)
// Example: 67
func (s PeerStatsImpl) BandwidthUsage() *Percent {
	return s.BandwidthUsageValue
}

// Outbound bandwidth usage (load balancing in `usage` mode is based on this value).
// Format: percent (percent)
// Example: 67
func (s *PeerStatsImpl) SetBandwidthUsage(v Percent) PeerStats {
	if s == nil {
		return nil
	}
	s.BandwidthUsageValue = &v
	return s
}

// Build version
func (s PeerStatsImpl) Build() *int {
	return s.BuildValue
}

// Build version
func (s *PeerStatsImpl) SetBuild(v int) PeerStats {
	if s == nil {
		return nil
	}
	s.BuildValue = &v
	return s
}

// Information about errors in the config file.
func (s PeerStatsImpl) ConfigError() ConfigErrorStatus {
	return s.ConfigErrorValue
}

// Information about errors in the config file.
func (s *PeerStatsImpl) SetConfigError(v ConfigErrorStatus) PeerStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ConfigErrorStatusImpl); ok {
		s.ConfigErrorValue = impl
	}
	return s
}

// Information about current external config status
func (s PeerStatsImpl) ConfigExternalStatus() ConfigExternalErrorStatus {
	return s.ConfigExternalStatusValue
}

// Information about current external config status
func (s *PeerStatsImpl) SetConfigExternalStatus(v ConfigExternalErrorStatus) PeerStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ConfigExternalErrorStatusImpl); ok {
		s.ConfigExternalStatusValue = impl
	}
	return s
}

// Current runtime version of config. We do not declare exact structure, but we promise
// that it will be always comparable and increasing (if server has proper NTP configuration, of course).
// Right now it is a tuple of server start time and incrementing version of config.
// Example: [1.636709231e+09 4]
func (s PeerStatsImpl) ConfigVersion() []int {
	return s.ConfigVersionValue
}

// Current runtime version of config. We do not declare exact structure, but we promise
// that it will be always comparable and increasing (if server has proper NTP configuration, of course).
// Right now it is a tuple of server start time and incrementing version of config.
// Example: [1.636709231e+09 4]
func (s *PeerStatsImpl) SetConfigVersion(v []int) PeerStats {
	if s == nil {
		return nil
	}
	s.ConfigVersionValue = v
	return s
}

// CPU usage on the server.
// Format: percent (percent)
// Example: 48
func (s PeerStatsImpl) CpuUsage() *Percent {
	return s.CpuUsageValue
}

// CPU usage on the server.
// Format: percent (percent)
// Example: 48
func (s *PeerStatsImpl) SetCpuUsage(v Percent) PeerStats {
	if s == nil {
		return nil
	}
	s.CpuUsageValue = &v
	return s
}

// Description of an error, if any.
func (s PeerStatsImpl) Error() *string {
	return s.ErrorValue
}

// Description of an error, if any.
func (s *PeerStatsImpl) SetError(v string) PeerStats {
	if s == nil {
		return nil
	}
	s.ErrorValue = &v
	return s
}

func (s PeerStatsImpl) HealthcheckStatus() CentralHealthcheckStatus {
	return s.HealthcheckStatusValue
}

func (s *PeerStatsImpl) SetHealthcheckStatus(v CentralHealthcheckStatus) PeerStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*CentralHealthcheckStatusImpl); ok {
		s.HealthcheckStatusValue = impl
	}
	return s
}

// Hostname of your server. Please, use FQDN, do not leave your Linux misconfigured.
// Example: openapi.flussonic.com
func (s PeerStatsImpl) Hostname() *string {
	return s.HostnameValue
}

// Hostname of your server. Please, use FQDN, do not leave your Linux misconfigured.
// Example: openapi.flussonic.com
func (s *PeerStatsImpl) SetHostname(v string) PeerStats {
	if s == nil {
		return nil
	}
	s.HostnameValue = &v
	return s
}

// Unique runtime ID of this instance. Updated with the restart.
// Format: uuid (uuid)
// Example: 61893b15-75b2-4fcb-b4cf-ae1dd0858ea2
func (s PeerStatsImpl) ID() *UUID {
	return s.IDValue
}

// Unique runtime ID of this instance. Updated with the restart.
// Format: uuid (uuid)
// Example: 61893b15-75b2-4fcb-b4cf-ae1dd0858ea2
func (s *PeerStatsImpl) SetID(v UUID) PeerStats {
	if s == nil {
		return nil
	}
	s.IDValue = &v
	return s
}

// Current incoming speed (bitrate) of the data transmission over the network.
// Format: speed (speed)
// Example: 400300
func (s PeerStatsImpl) InputKbit() *Speed {
	return s.InputKbitValue
}

// Current incoming speed (bitrate) of the data transmission over the network.
// Format: speed (speed)
// Example: 400300
func (s *PeerStatsImpl) SetInputKbit(v Speed) PeerStats {
	if s == nil {
		return nil
	}
	s.InputKbitValue = &v
	return s
}

// The flag shows if Flussonic runs on Flussonic Coder.
func (s PeerStatsImpl) IsChassis() *bool {
	return s.IsChassisValue
}

// The flag shows if Flussonic runs on Flussonic Coder.
func (s *PeerStatsImpl) SetIsChassis(v bool) PeerStats {
	if s == nil {
		return nil
	}
	s.IsChassisValue = &v
	return s
}

// The code of the license applied on the server.
// Example: uO8v12HJhNXVj5gM
func (s PeerStatsImpl) LicenseTxt() *string {
	return s.LicenseTxtValue
}

// The code of the license applied on the server.
// Example: uO8v12HJhNXVj5gM
func (s *PeerStatsImpl) SetLicenseTxt(v string) PeerStats {
	if s == nil {
		return nil
	}
	s.LicenseTxtValue = &v
	return s
}

// The license type.
func (s PeerStatsImpl) LicenseType() *LicenseType {
	return s.LicenseTypeValue
}

// The license type.
func (s *PeerStatsImpl) SetLicenseType(v LicenseType) PeerStats {
	if s == nil {
		return nil
	}
	s.LicenseTypeValue = &v
	return s
}

// Memory usage on the server.
// Format: percent (percent)
// Example: 27
func (s PeerStatsImpl) MemoryUsage() *Percent {
	return s.MemoryUsageValue
}

// Memory usage on the server.
// Format: percent (percent)
// Example: 27
func (s *PeerStatsImpl) SetMemoryUsage(v Percent) PeerStats {
	if s == nil {
		return nil
	}
	s.MemoryUsageValue = &v
	return s
}

// Notification about a newer version in the repository.
// Format: server_version (server_version)
// Example: 22.01
func (s PeerStatsImpl) NextVersion() *ServerVersion {
	return s.NextVersionValue
}

// Notification about a newer version in the repository.
// Format: server_version (server_version)
// Example: 22.01
func (s *PeerStatsImpl) SetNextVersion(v ServerVersion) PeerStats {
	if s == nil {
		return nil
	}
	s.NextVersionValue = &v
	return s
}

// Current response time
// Format: utc_ms (Unix timestamp in milliseconds)
func (s PeerStatsImpl) Now() *UtcMs {
	return s.NowValue
}

// Current response time
// Format: utc_ms (Unix timestamp in milliseconds)
func (s *PeerStatsImpl) SetNow(v UtcMs) PeerStats {
	if s == nil {
		return nil
	}
	s.NowValue = &v
	return s
}

// The number of streams that are ready to be served to the clients.
// Example: 27
func (s PeerStatsImpl) OnlineStreams() *int {
	return s.OnlineStreamsValue
}

// The number of streams that are ready to be served to the clients.
// Example: 27
func (s *PeerStatsImpl) SetOnlineStreams(v int) PeerStats {
	if s == nil {
		return nil
	}
	s.OnlineStreamsValue = &v
	return s
}

// The number of opened files.
// Example: 5
func (s PeerStatsImpl) OpenedFiles() *int {
	return s.OpenedFilesValue
}

// The number of opened files.
// Example: 5
func (s *PeerStatsImpl) SetOpenedFiles(v int) PeerStats {
	if s == nil {
		return nil
	}
	s.OpenedFilesValue = &v
	return s
}

// Current outgoing speed (bitrate) of the data transmission over the network.
// Format: speed (speed)
// Example: 500400
func (s PeerStatsImpl) OutputKbit() *Speed {
	return s.OutputKbitValue
}

// Current outgoing speed (bitrate) of the data transmission over the network.
// Format: speed (speed)
// Example: 500400
func (s *PeerStatsImpl) SetOutputKbit(v Speed) PeerStats {
	if s == nil {
		return nil
	}
	s.OutputKbitValue = &v
	return s
}

// The list of disk partitions on the server.
func (s PeerStatsImpl) Partitions() []PartitionStats {
	if s.PartitionsValue == nil {
		return nil
	}
	result := make([]PartitionStats, len(s.PartitionsValue))
	for i, item := range s.PartitionsValue {
		result[i] = item
	}
	return result
}

// The list of disk partitions on the server.
func (s *PeerStatsImpl) SetPartitions(v []PartitionStats) PeerStats {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*PartitionStatsImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*PartitionStatsImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.PartitionsValue = impl
	}
	return s
}

// Predictions of future stats based on the current state of the cluster.
func (s PeerStatsImpl) Predictions() PeerStatsPredictions {
	return s.PredictionsValue
}

// Predictions of future stats based on the current state of the cluster.
func (s *PeerStatsImpl) SetPredictions(v PeerStatsPredictions) PeerStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*PeerStatsPredictionsImpl); ok {
		s.PredictionsValue = impl
	}
	return s
}

// Shows if rproxy is configured.
func (s PeerStatsImpl) Rproxy() *bool {
	return s.RproxyValue
}

// Shows if rproxy is configured.
func (s *PeerStatsImpl) SetRproxy(v bool) PeerStats {
	if s == nil {
		return nil
	}
	s.RproxyValue = &v
	return s
}

// Shows if rproxy is running.
func (s PeerStatsImpl) RproxyRunning() *bool {
	return s.RproxyRunningValue
}

// Shows if rproxy is running.
func (s *PeerStatsImpl) SetRproxyRunning(v bool) PeerStats {
	if s == nil {
		return nil
	}
	s.RproxyRunningValue = &v
	return s
}

// Erlang scheduler load.
// Format: percent (percent)
// Example: 40
func (s PeerStatsImpl) SchedulerLoad() *Percent {
	return s.SchedulerLoadValue
}

// Erlang scheduler load.
// Format: percent (percent)
// Example: 40
func (s *PeerStatsImpl) SetSchedulerLoad(v Percent) PeerStats {
	if s == nil {
		return nil
	}
	s.SchedulerLoadValue = &v
	return s
}

// Package version of the server. Might be simple a number of release like 21.11 or longer if you have a rolling release installed.
// Format: server_version (server_version)
// Example: 23.04
func (s PeerStatsImpl) ServerVersion() *ServerVersion {
	return s.ServerVersionValue
}

// Package version of the server. Might be simple a number of release like 21.11 or longer if you have a rolling release installed.
// Format: server_version (server_version)
// Example: 23.04
func (s *PeerStatsImpl) SetServerVersion(v ServerVersion) PeerStats {
	if s == nil {
		return nil
	}
	s.ServerVersionValue = &v
	return s
}

// Boot time of this instance.
// Format: utc (Unix timestamp in seconds)
// Example: 1.639337825e+09
func (s PeerStatsImpl) StartedAt() *Utc {
	return s.StartedAtValue
}

// Boot time of this instance.
// Format: utc (Unix timestamp in seconds)
// Example: 1.639337825e+09
func (s *PeerStatsImpl) SetStartedAt(v Utc) PeerStats {
	if s == nil {
		return nil
	}
	s.StartedAtValue = &v
	return s
}

// *Flussonic* will always try to start even if there are severe errors that do not
// allow functioning.
// `starting` status means you should wait for some time (not more than
// a minute).
// `running` status means all configuration was loaded. However, the status does not provide
// an information about your streams and the quality of provided service.
// All other statuses mean there are some severe problems on the server
// that cannot be repaired by Flussonic itself.
func (s PeerStatsImpl) StreamerStatus() *ServerStatsStreamerStatus {
	return s.StreamerStatusValue
}

// *Flussonic* will always try to start even if there are severe errors that do not
// allow functioning.
// `starting` status means you should wait for some time (not more than
// a minute).
// `running` status means all configuration was loaded. However, the status does not provide
// an information about your streams and the quality of provided service.
// All other statuses mean there are some severe problems on the server
// that cannot be repaired by Flussonic itself.
func (s *PeerStatsImpl) SetStreamerStatus(v ServerStatsStreamerStatus) PeerStats {
	if s == nil {
		return nil
	}
	s.StreamerStatusValue = &v
	return s
}

// Human-readable format of errors and alerts that need to be fixed.
// Provided by some *Flussonic* subsystems.
func (s PeerStatsImpl) TextAlerts() map[string]string {
	return s.TextAlertsValue
}

// Human-readable format of errors and alerts that need to be fixed.
// Provided by some *Flussonic* subsystems.
func (s *PeerStatsImpl) SetTextAlerts(v map[string]string) PeerStats {
	if s == nil {
		return nil
	}
	s.TextAlertsValue = v
	return s
}

// Deprecated field. Will be deleted at 22.03
// Total server bandwidth.
// Format: speed (speed)
func (s PeerStatsImpl) TotalBandwidth() *Speed {
	return s.TotalBandwidthValue
}

// Deprecated field. Will be deleted at 22.03
// Total server bandwidth.
// Format: speed (speed)
func (s *PeerStatsImpl) SetTotalBandwidth(v Speed) PeerStats {
	if s == nil {
		return nil
	}
	s.TotalBandwidthValue = &v
	return s
}

// The number of clients receiving the streams from the server at the moment of request.
// Example: 2040
func (s PeerStatsImpl) TotalClients() *int {
	return s.TotalClientsValue
}

// The number of clients receiving the streams from the server at the moment of request.
// Example: 2040
func (s *PeerStatsImpl) SetTotalClients(v int) PeerStats {
	if s == nil {
		return nil
	}
	s.TotalClientsValue = &v
	return s
}

// The number of streams created on the server.
// Example: 45
func (s PeerStatsImpl) TotalStreams() *int {
	return s.TotalStreamsValue
}

// The number of streams created on the server.
// Example: 45
func (s *PeerStatsImpl) SetTotalStreams(v int) PeerStats {
	if s == nil {
		return nil
	}
	s.TotalStreamsValue = &v
	return s
}

// Shows if the server's CPU can be used for transcoding
// (i.e. if the `flussonic-transcoder` package is installed on the server).
func (s PeerStatsImpl) Transcoder() *bool {
	return s.TranscoderValue
}

// Shows if the server's CPU can be used for transcoding
// (i.e. if the `flussonic-transcoder` package is installed on the server).
func (s *PeerStatsImpl) SetTranscoder(v bool) PeerStats {
	if s == nil {
		return nil
	}
	s.TranscoderValue = &v
	return s
}

// Statistics on the devices used for transcoding.
func (s PeerStatsImpl) TranscoderDevices() []TranscoderDeviceStats {
	if s.TranscoderDevicesValue == nil {
		return nil
	}
	result := make([]TranscoderDeviceStats, len(s.TranscoderDevicesValue))
	for i, item := range s.TranscoderDevicesValue {
		result[i] = item
	}
	return result
}

// Statistics on the devices used for transcoding.
func (s *PeerStatsImpl) SetTranscoderDevices(v []TranscoderDeviceStats) PeerStats {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*TranscoderDeviceStatsImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*TranscoderDeviceStatsImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.TranscoderDevicesValue = impl
	}
	return s
}

// The server uptime.
// Format: seconds (seconds)
// Example: 4.325502e+06
func (s PeerStatsImpl) Uptime() *Seconds {
	return s.UptimeValue
}

// The server uptime.
// Format: seconds (seconds)
// Example: 4.325502e+06
func (s *PeerStatsImpl) SetUptime(v Seconds) PeerStats {
	if s == nil {
		return nil
	}
	s.UptimeValue = &v
	return s
}

// Shows if Flussonic Watcher is enabled in the license.
func (s PeerStatsImpl) Vsaas() *bool {
	return s.VsaasValue
}

// Shows if Flussonic Watcher is enabled in the license.
func (s *PeerStatsImpl) SetVsaas(v bool) PeerStats {
	if s == nil {
		return nil
	}
	s.VsaasValue = &v
	return s
}

// Shows if Watcher branding is enabled in the license.
func (s PeerStatsImpl) VsaasBranding() *bool {
	return s.VsaasBrandingValue
}

// Shows if Watcher branding is enabled in the license.
func (s *PeerStatsImpl) SetVsaasBranding(v bool) PeerStats {
	if s == nil {
		return nil
	}
	s.VsaasBrandingValue = &v
	return s
}

// Shows if Watcher is currently running.
func (s PeerStatsImpl) VsaasRunning() *bool {
	return s.VsaasRunningValue
}

// Shows if Watcher is currently running.
func (s *PeerStatsImpl) SetVsaasRunning(v bool) PeerStats {
	if s == nil {
		return nil
	}
	s.VsaasRunningValue = &v
	return s
}

// NewPeerStatsPredictions creates a new PeerStatsPredictions instance
func NewPeerStatsPredictions() PeerStatsPredictions {
	return &PeerStatsPredictionsImpl{}
}

func (s PeerStatsPredictionsImpl) Disk() CentralDiskPredictions {
	return s.DiskValue
}

func (s *PeerStatsPredictionsImpl) SetDisk(v CentralDiskPredictions) PeerStatsPredictions {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*CentralDiskPredictionsImpl); ok {
		s.DiskValue = impl
	}
	return s
}

// NewPlayProtocolsSpec creates a new PlayProtocolsSpec instance
func NewPlayProtocolsSpec() PlayProtocolsSpec {
	return &PlayProtocolsSpecImpl{}
}

// Whether to allow or deny API requests, depending on the `whitelist` properties.
func (s PlayProtocolsSpecImpl) API() *bool {
	return s.APIValue
}

// Whether to allow or deny API requests, depending on the `whitelist` properties.
func (s *PlayProtocolsSpecImpl) SetAPI(v bool) PlayProtocolsSpec {
	if s == nil {
		return nil
	}
	s.APIValue = &v
	return s
}

// Whether to allow or deny an LL-HLS stream playback, depending on the `whitelist` properties.
func (s PlayProtocolsSpecImpl) Cmaf() *bool {
	return s.CmafValue
}

// Whether to allow or deny an LL-HLS stream playback, depending on the `whitelist` properties.
func (s *PlayProtocolsSpecImpl) SetCmaf(v bool) PlayProtocolsSpec {
	if s == nil {
		return nil
	}
	s.CmafValue = &v
	return s
}

// Whether to allow or deny a DASH stream playback, depending on the `whitelist` properties.
func (s PlayProtocolsSpecImpl) Dash() *bool {
	return s.DashValue
}

// Whether to allow or deny a DASH stream playback, depending on the `whitelist` properties.
func (s *PlayProtocolsSpecImpl) SetDash(v bool) PlayProtocolsSpec {
	if s == nil {
		return nil
	}
	s.DashValue = &v
	return s
}

// Whether to allow or deny an HLS stream playback, depending on the `whitelist` properties.
func (s PlayProtocolsSpecImpl) Hls() *bool {
	return s.HlsValue
}

// Whether to allow or deny an HLS stream playback, depending on the `whitelist` properties.
func (s *PlayProtocolsSpecImpl) SetHls(v bool) PlayProtocolsSpec {
	if s == nil {
		return nil
	}
	s.HlsValue = &v
	return s
}

// Whether to allow or deny delivering JPEG thumbnails over HTTP(S), depending on the `whitelist` properties.
func (s PlayProtocolsSpecImpl) Jpeg() *bool {
	return s.JpegValue
}

// Whether to allow or deny delivering JPEG thumbnails over HTTP(S), depending on the `whitelist` properties.
func (s *PlayProtocolsSpecImpl) SetJpeg(v bool) PlayProtocolsSpec {
	if s == nil {
		return nil
	}
	s.JpegValue = &v
	return s
}

// Whether to allow or deny an M4F stream playback, depending on the `whitelist` properties.
func (s PlayProtocolsSpecImpl) M4f() *bool {
	return s.M4fValue
}

// Whether to allow or deny an M4F stream playback, depending on the `whitelist` properties.
func (s *PlayProtocolsSpecImpl) SetM4f(v bool) PlayProtocolsSpec {
	if s == nil {
		return nil
	}
	s.M4fValue = &v
	return s
}

// Whether to allow or deny an M4S stream playback, depending on the `whitelist` properties.
func (s PlayProtocolsSpecImpl) M4s() *bool {
	return s.M4sValue
}

// Whether to allow or deny an M4S stream playback, depending on the `whitelist` properties.
func (s *PlayProtocolsSpecImpl) SetM4s(v bool) PlayProtocolsSpec {
	if s == nil {
		return nil
	}
	s.M4sValue = &v
	return s
}

// Whether to allow or deny an MP4 file download over HTTP(S), depending on the `whitelist` properties.
// Used to export DVR segment(s) in MP4 file.
func (s PlayProtocolsSpecImpl) Mp4() *bool {
	return s.Mp4Value
}

// Whether to allow or deny an MP4 file download over HTTP(S), depending on the `whitelist` properties.
// Used to export DVR segment(s) in MP4 file.
func (s *PlayProtocolsSpecImpl) SetMp4(v bool) PlayProtocolsSpec {
	if s == nil {
		return nil
	}
	s.Mp4Value = &v
	return s
}

// Whether to allow or deny an MSE-LD stream playback, depending on the `whitelist` properties.
func (s PlayProtocolsSpecImpl) Mseld() *bool {
	return s.MseldValue
}

// Whether to allow or deny an MSE-LD stream playback, depending on the `whitelist` properties.
func (s *PlayProtocolsSpecImpl) SetMseld(v bool) PlayProtocolsSpec {
	if s == nil {
		return nil
	}
	s.MseldValue = &v
	return s
}

// Whether to allow or deny an MSS stream playback, depending on the `whitelist` properties.
func (s PlayProtocolsSpecImpl) Mss() *bool {
	return s.MssValue
}

// Whether to allow or deny an MSS stream playback, depending on the `whitelist` properties.
func (s *PlayProtocolsSpecImpl) SetMss(v bool) PlayProtocolsSpec {
	if s == nil {
		return nil
	}
	s.MssValue = &v
	return s
}

// Whether to allow or deny playback in embed.html, depending on the `whitelist` properties.
func (s PlayProtocolsSpecImpl) Player() *bool {
	return s.PlayerValue
}

// Whether to allow or deny playback in embed.html, depending on the `whitelist` properties.
func (s *PlayProtocolsSpecImpl) SetPlayer(v bool) PlayProtocolsSpec {
	if s == nil {
		return nil
	}
	s.PlayerValue = &v
	return s
}

// Whether to allow or deny an RTMP stream playback, depending on the `whitelist` properties.
func (s PlayProtocolsSpecImpl) Rtmp() *bool {
	return s.RtmpValue
}

// Whether to allow or deny an RTMP stream playback, depending on the `whitelist` properties.
func (s *PlayProtocolsSpecImpl) SetRtmp(v bool) PlayProtocolsSpec {
	if s == nil {
		return nil
	}
	s.RtmpValue = &v
	return s
}

// Whether to allow or deny an RTSP stream playback, depending on the `whitelist` properties.
func (s PlayProtocolsSpecImpl) Rtsp() *bool {
	return s.RtspValue
}

// Whether to allow or deny an RTSP stream playback, depending on the `whitelist` properties.
func (s *PlayProtocolsSpecImpl) SetRtsp(v bool) PlayProtocolsSpec {
	if s == nil {
		return nil
	}
	s.RtspValue = &v
	return s
}

// Whether to allow or deny a SHOUTcast/Icecast stream playback, depending on the `whitelist` properties.
func (s PlayProtocolsSpecImpl) Shoutcast() *bool {
	return s.ShoutcastValue
}

// Whether to allow or deny a SHOUTcast/Icecast stream playback, depending on the `whitelist` properties.
func (s *PlayProtocolsSpecImpl) SetShoutcast(v bool) PlayProtocolsSpec {
	if s == nil {
		return nil
	}
	s.ShoutcastValue = &v
	return s
}

// Whether to allow or deny an SRT stream playback, depending on the `whitelist` properties.
func (s PlayProtocolsSpecImpl) Srt() *bool {
	return s.SrtValue
}

// Whether to allow or deny an SRT stream playback, depending on the `whitelist` properties.
func (s *PlayProtocolsSpecImpl) SetSrt(v bool) PlayProtocolsSpec {
	if s == nil {
		return nil
	}
	s.SrtValue = &v
	return s
}

// Whether to allow or deny an MPEG-TS stream playback over HTTP(S), depending on the `whitelist` properties.
func (s PlayProtocolsSpecImpl) Tshttp() *bool {
	return s.TshttpValue
}

// Whether to allow or deny an MPEG-TS stream playback over HTTP(S), depending on the `whitelist` properties.
func (s *PlayProtocolsSpecImpl) SetTshttp(v bool) PlayProtocolsSpec {
	if s == nil {
		return nil
	}
	s.TshttpValue = &v
	return s
}

// Whether to allow or deny an WebRTC stream playback, depending on the `whitelist` properties.
func (s PlayProtocolsSpecImpl) Webrtc() *bool {
	return s.WebrtcValue
}

// Whether to allow or deny an WebRTC stream playback, depending on the `whitelist` properties.
func (s *PlayProtocolsSpecImpl) SetWebrtc(v bool) PlayProtocolsSpec {
	if s == nil {
		return nil
	}
	s.WebrtcValue = &v
	return s
}

// - If set to `True`, server **allows** a playback only for listed protocols;
// - If set to `False`, server **forbids** a playback only for listed protocols;
func (s PlayProtocolsSpecImpl) Whitelist() *bool {
	return s.WhitelistValue
}

// - If set to `True`, server **allows** a playback only for listed protocols;
// - If set to `False`, server **forbids** a playback only for listed protocols;
func (s *PlayProtocolsSpecImpl) SetWhitelist(v bool) PlayProtocolsSpec {
	if s == nil {
		return nil
	}
	s.WhitelistValue = &v
	return s
}

// NewPlaybackHeaders creates a new PlaybackHeaders instance
func NewPlaybackHeaders() PlaybackHeaders {
	return &PlaybackHeadersImpl{}
}

// HTTP headers in name-value format for manifest requests.
// Example: map[Cache-Control:max-age=3600]
func (s PlaybackHeadersImpl) Headers() map[string]string {
	return s.HeadersValue
}

// HTTP headers in name-value format for manifest requests.
// Example: map[Cache-Control:max-age=3600]
func (s *PlaybackHeadersImpl) SetHeaders(v map[string]string) PlaybackHeaders {
	if s == nil {
		return nil
	}
	s.HeadersValue = v
	return s
}

// Playback type for which the HTTP headers apply.
// Example: live
func (s PlaybackHeadersImpl) Playback() *PlaybackHeadersPlayback {
	return s.PlaybackValue
}

// Playback type for which the HTTP headers apply.
// Example: live
func (s *PlaybackHeadersImpl) SetPlayback(v PlaybackHeadersPlayback) PlaybackHeaders {
	if s == nil {
		return nil
	}
	s.PlaybackValue = &v
	return s
}

// Configuration to allow/forbid headers for various playback protocols.
func (s PlaybackHeadersImpl) Protocols() PlayProtocolsSpec {
	return s.ProtocolsValue
}

// Configuration to allow/forbid headers for various playback protocols.
func (s *PlaybackHeadersImpl) SetProtocols(v PlayProtocolsSpec) PlaybackHeaders {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*PlayProtocolsSpecImpl); ok {
		s.ProtocolsValue = impl
	}
	return s
}

// HTTP headers in name-value format for segment requests.
// Example: map[Cache-Control:max-age=3600]
func (s PlaybackHeadersImpl) SegmentHeaders() map[string]string {
	return s.SegmentHeadersValue
}

// HTTP headers in name-value format for segment requests.
// Example: map[Cache-Control:max-age=3600]
func (s *PlaybackHeadersImpl) SetSegmentHeaders(v map[string]string) PlaybackHeaders {
	if s == nil {
		return nil
	}
	s.SegmentHeadersValue = v
	return s
}

// NewPushCounters creates a new PushCounters instance
func NewPushCounters() PushCounters {
	return &PushCountersImpl{}
}

// Total amount of bytes sent since the pusher was created.
// Format: bytes (bytes)
func (s PushCountersImpl) Bytes() *Bytes {
	return s.BytesValue
}

// Total amount of bytes sent since the pusher was created.
// Format: bytes (bytes)
func (s *PushCountersImpl) SetBytes(v Bytes) PushCounters {
	if s == nil {
		return nil
	}
	s.BytesValue = &v
	return s
}

// The encoded bytes count.
// Format: bytes (bytes)
func (s PushCountersImpl) EncodedBytes() *Bytes {
	return s.EncodedBytesValue
}

// The encoded bytes count.
// Format: bytes (bytes)
func (s *PushCountersImpl) SetEncodedBytes(v Bytes) PushCounters {
	if s == nil {
		return nil
	}
	s.EncodedBytesValue = &v
	return s
}

// How many times we've got 401 (unauthorized).
func (s PushCountersImpl) Errors401() *int {
	return s.Errors401Value
}

// How many times we've got 401 (unauthorized).
func (s *PushCountersImpl) SetErrors401(v int) PushCounters {
	if s == nil {
		return nil
	}
	s.Errors401Value = &v
	return s
}

// How many times we've got 403 (forbidden).
func (s PushCountersImpl) Errors403() *int {
	return s.Errors403Value
}

// How many times we've got 403 (forbidden).
func (s *PushCountersImpl) SetErrors403(v int) PushCounters {
	if s == nil {
		return nil
	}
	s.Errors403Value = &v
	return s
}

// How many times we've got 404 (enoent).
func (s PushCountersImpl) Errors404() *int {
	return s.Errors404Value
}

// How many times we've got 404 (enoent).
func (s *PushCountersImpl) SetErrors404(v int) PushCounters {
	if s == nil {
		return nil
	}
	s.Errors404Value = &v
	return s
}

// How many times we've got 409 (double_publish_denied).
func (s PushCountersImpl) Errors409() *int {
	return s.Errors409Value
}

// How many times we've got 409 (double_publish_denied).
func (s *PushCountersImpl) SetErrors409(v int) PushCounters {
	if s == nil {
		return nil
	}
	s.Errors409Value = &v
	return s
}

// How many times we've got 500 (server_error).
func (s PushCountersImpl) Errors500() *int {
	return s.Errors500Value
}

// How many times we've got 500 (server_error).
func (s *PushCountersImpl) SetErrors500(v int) PushCounters {
	if s == nil {
		return nil
	}
	s.Errors500Value = &v
	return s
}

// Number of errors during of audio frame decoding to raw format.
func (s PushCountersImpl) ErrorsAudioFrameDecode() *int {
	return s.ErrorsAudioFrameDecodeValue
}

// Number of errors during of audio frame decoding to raw format.
func (s *PushCountersImpl) SetErrorsAudioFrameDecode(v int) PushCounters {
	if s == nil {
		return nil
	}
	s.ErrorsAudioFrameDecodeValue = &v
	return s
}

// How many times pusher unexpectedly lost connection with peer
func (s PushCountersImpl) ErrorsConnectionLost() *int {
	return s.ErrorsConnectionLostValue
}

// How many times pusher unexpectedly lost connection with peer
func (s *PushCountersImpl) SetErrorsConnectionLost(v int) PushCounters {
	if s == nil {
		return nil
	}
	s.ErrorsConnectionLostValue = &v
	return s
}

// How many times internal device buffer was overflowed.
func (s PushCountersImpl) ErrorsDeviceBufferOverflow() *int {
	return s.ErrorsDeviceBufferOverflowValue
}

// How many times internal device buffer was overflowed.
func (s *PushCountersImpl) SetErrorsDeviceBufferOverflow(v int) PushCounters {
	if s == nil {
		return nil
	}
	s.ErrorsDeviceBufferOverflowValue = &v
	return s
}

// How much times pusher was unable to open (attach to) device for pushing
func (s PushCountersImpl) ErrorsDeviceNotOpened() *int {
	return s.ErrorsDeviceNotOpenedValue
}

// How much times pusher was unable to open (attach to) device for pushing
func (s *PushCountersImpl) SetErrorsDeviceNotOpened(v int) PushCounters {
	if s == nil {
		return nil
	}
	s.ErrorsDeviceNotOpenedValue = &v
	return s
}

// Number of dropped frames
func (s PushCountersImpl) ErrorsDroppedFrames() *int {
	return s.ErrorsDroppedFramesValue
}

// Number of dropped frames
func (s *PushCountersImpl) SetErrorsDroppedFrames(v int) PushCounters {
	if s == nil {
		return nil
	}
	s.ErrorsDroppedFramesValue = &v
	return s
}

// Number of dropped segments
func (s PushCountersImpl) ErrorsDroppedSegments() *int {
	return s.ErrorsDroppedSegmentsValue
}

// Number of dropped segments
func (s *PushCountersImpl) SetErrorsDroppedSegments(v int) PushCounters {
	if s == nil {
		return nil
	}
	s.ErrorsDroppedSegmentsValue = &v
	return s
}

// How many times pusher did not establish connection because of destination peer is not reached
func (s PushCountersImpl) ErrorsNoDestination() *int {
	return s.ErrorsNoDestinationValue
}

// How many times pusher did not establish connection because of destination peer is not reached
func (s *PushCountersImpl) SetErrorsNoDestination(v int) PushCounters {
	if s == nil {
		return nil
	}
	s.ErrorsNoDestinationValue = &v
	return s
}

// How many times pusher did not establish connection because of missing or wrong credentials
func (s PushCountersImpl) ErrorsNotAuthorized() *int {
	return s.ErrorsNotAuthorizedValue
}

// How many times pusher did not establish connection because of missing or wrong credentials
func (s *PushCountersImpl) SetErrorsNotAuthorized(v int) PushCounters {
	if s == nil {
		return nil
	}
	s.ErrorsNotAuthorizedValue = &v
	return s
}

// How many times pusher was stopped because of redirect limit is reached
func (s PushCountersImpl) ErrorsRedirectLimit() *int {
	return s.ErrorsRedirectLimitValue
}

// How many times pusher was stopped because of redirect limit is reached
func (s *PushCountersImpl) SetErrorsRedirectLimit(v int) PushCounters {
	if s == nil {
		return nil
	}
	s.ErrorsRedirectLimitValue = &v
	return s
}

// How many times pusher was stopped due to overload
func (s PushCountersImpl) ErrorsStopOverloaded() *int {
	return s.ErrorsStopOverloadedValue
}

// How many times pusher was stopped due to overload
func (s *PushCountersImpl) SetErrorsStopOverloaded(v int) PushCounters {
	if s == nil {
		return nil
	}
	s.ErrorsStopOverloadedValue = &v
	return s
}

// How many times pusher got TLS errors.
func (s PushCountersImpl) ErrorsTls() *int {
	return s.ErrorsTlsValue
}

// How many times pusher got TLS errors.
func (s *PushCountersImpl) SetErrorsTls(v int) PushCounters {
	if s == nil {
		return nil
	}
	s.ErrorsTlsValue = &v
	return s
}

// Number of errors during of video frame decoding to raw format.
func (s PushCountersImpl) ErrorsVideoFrameDecode() *int {
	return s.ErrorsVideoFrameDecodeValue
}

// Number of errors during of video frame decoding to raw format.
func (s *PushCountersImpl) SetErrorsVideoFrameDecode(v int) PushCounters {
	if s == nil {
		return nil
	}
	s.ErrorsVideoFrameDecodeValue = &v
	return s
}

// Number of frames sent by this pusher.
func (s PushCountersImpl) Frames() *int {
	return s.FramesValue
}

// Number of frames sent by this pusher.
func (s *PushCountersImpl) SetFrames(v int) PushCounters {
	if s == nil {
		return nil
	}
	s.FramesValue = &v
	return s
}

// SDI card output clock-lock state.
func (s PushCountersImpl) GenlockStatus() *GenlockStatus {
	return s.GenlockStatusValue
}

// SDI card output clock-lock state.
func (s *PushCountersImpl) SetGenlockStatus(v GenlockStatus) PushCounters {
	if s == nil {
		return nil
	}
	s.GenlockStatusValue = &v
	return s
}

// SDI card reference port (Ref In Port) status.
func (s PushCountersImpl) GenrefStatus() GenrefStatus {
	return s.GenrefStatusValue
}

// SDI card reference port (Ref In Port) status.
func (s *PushCountersImpl) SetGenrefStatus(v GenrefStatus) PushCounters {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*GenrefStatusImpl); ok {
		s.GenrefStatusValue = impl
	}
	return s
}

// The time in milliseconds when the pusher instance was created.
// Format: utc_ms (Unix timestamp in milliseconds)
func (s PushCountersImpl) OpenedAt() *UtcMs {
	return s.OpenedAtValue
}

// The time in milliseconds when the pusher instance was created.
// Format: utc_ms (Unix timestamp in milliseconds)
func (s *PushCountersImpl) SetOpenedAt(v UtcMs) PushCounters {
	if s == nil {
		return nil
	}
	s.OpenedAtValue = &v
	return s
}

// Per pid statistics for MPEG-TS encoding calculated for the pusher
func (s PushCountersImpl) Pids() []PushPidCounters {
	if s.PidsValue == nil {
		return nil
	}
	result := make([]PushPidCounters, len(s.PidsValue))
	for i, item := range s.PidsValue {
		result[i] = item
	}
	return result
}

// Per pid statistics for MPEG-TS encoding calculated for the pusher
func (s *PushCountersImpl) SetPids(v []PushPidCounters) PushCounters {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*PushPidCountersImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*PushPidCountersImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.PidsValue = impl
	}
	return s
}

// How many times there were no data to push in pusher queue
func (s PushCountersImpl) PusherQueueExhaustedCount() *int {
	return s.PusherQueueExhaustedCountValue
}

// How many times there were no data to push in pusher queue
func (s *PushCountersImpl) SetPusherQueueExhaustedCount(v int) PushCounters {
	if s == nil {
		return nil
	}
	s.PusherQueueExhaustedCountValue = &v
	return s
}

// How many times pusher was restarted
func (s PushCountersImpl) PusherRestarts() *int {
	return s.PusherRestartsValue
}

// How many times pusher was restarted
func (s *PushCountersImpl) SetPusherRestarts(v int) PushCounters {
	if s == nil {
		return nil
	}
	s.PusherRestartsValue = &v
	return s
}

// Number of retries since the last successful push.
func (s PushCountersImpl) ResentPackets() *int {
	return s.ResentPacketsValue
}

// Number of retries since the last successful push.
func (s *PushCountersImpl) SetResentPackets(v int) PushCounters {
	if s == nil {
		return nil
	}
	s.ResentPacketsValue = &v
	return s
}

// Number of segments sent by this pusher.
func (s PushCountersImpl) Segments() *int {
	return s.SegmentsValue
}

// Number of segments sent by this pusher.
func (s *PushCountersImpl) SetSegments(v int) PushCounters {
	if s == nil {
		return nil
	}
	s.SegmentsValue = &v
	return s
}

// State of the standby push.
func (s PushCountersImpl) StandbyStatus() *PusherStandbyStatus {
	return s.StandbyStatusValue
}

// State of the standby push.
func (s *PushCountersImpl) SetStandbyStatus(v PusherStandbyStatus) PushCounters {
	if s == nil {
		return nil
	}
	s.StandbyStatusValue = &v
	return s
}

// State of the push session.
func (s PushCountersImpl) Status() *PusherStatus {
	return s.StatusValue
}

// State of the push session.
func (s *PushCountersImpl) SetStatus(v *PusherStatus) PushCounters {
	if s == nil {
		return nil
	}
	s.StatusValue = v
	return s
}

// Deprecated field. Will be deleted at 26.03
// The fillers bytes count for system traffic. Currently this field is always zero.
// Format: bytes (bytes)
func (s PushCountersImpl) SysFillersBytes() *Bytes {
	return s.SysFillersBytesValue
}

// Deprecated field. Will be deleted at 26.03
// The fillers bytes count for system traffic. Currently this field is always zero.
// Format: bytes (bytes)
func (s *PushCountersImpl) SetSysFillersBytes(v Bytes) PushCounters {
	if s == nil {
		return nil
	}
	s.SysFillersBytesValue = &v
	return s
}

// The payload bytes count for system traffic.
// Format: bytes (bytes)
func (s PushCountersImpl) SysPayloadBytes() *Bytes {
	return s.SysPayloadBytesValue
}

// The payload bytes count for system traffic.
// Format: bytes (bytes)
func (s *PushCountersImpl) SetSysPayloadBytes(v Bytes) PushCounters {
	if s == nil {
		return nil
	}
	s.SysPayloadBytesValue = &v
	return s
}

// The stuff packets count for system traffic.
func (s PushCountersImpl) SysStuffingPackets() *int {
	return s.SysStuffingPacketsValue
}

// The stuff packets count for system traffic.
func (s *PushCountersImpl) SetSysStuffingPackets(v int) PushCounters {
	if s == nil {
		return nil
	}
	s.SysStuffingPacketsValue = &v
	return s
}

// Obfuscated URL where to push to
// Format: input_url (input_url)
func (s PushCountersImpl) URL() *InputURL {
	return s.URLValue
}

// Obfuscated URL where to push to
// Format: input_url (input_url)
func (s *PushCountersImpl) SetURL(v InputURL) PushCounters {
	if s == nil {
		return nil
	}
	s.URLValue = &v
	return s
}

// NewPushPidCounters creates a new PushPidCounters instance
func NewPushPidCounters() PushPidCounters {
	return &PushPidCountersImpl{}
}

// Bitrate on this PID, configured or autotuned.
// Format: speed (speed)
func (s PushPidCountersImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// Bitrate on this PID, configured or autotuned.
// Format: speed (speed)
func (s *PushPidCountersImpl) SetBitrate(v Speed) PushPidCounters {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// Content of the track (e.g. audio, video, text).
func (s PushPidCountersImpl) Content() *FrameContent {
	return s.ContentValue
}

// Content of the track (e.g. audio, video, text).
func (s *PushPidCountersImpl) SetContent(v FrameContent) PushPidCounters {
	if s == nil {
		return nil
	}
	s.ContentValue = &v
	return s
}

// Number of times a frame was dropped on this PID due to DTS going backward.
// Each such event currently triggers a full program reset.
func (s PushPidCountersImpl) ErrorsDtsGoesBackward() *int {
	return s.ErrorsDtsGoesBackwardValue
}

// Number of times a frame was dropped on this PID due to DTS going backward.
// Each such event currently triggers a full program reset.
func (s *PushPidCountersImpl) SetErrorsDtsGoesBackward(v int) PushPidCounters {
	if s == nil {
		return nil
	}
	s.ErrorsDtsGoesBackwardValue = &v
	return s
}

// Number of times a frame was dropped on this PID due to a forward DTS jump.
// Each such event currently triggers a full program reset.
func (s PushPidCountersImpl) ErrorsDtsJumpsForward() *int {
	return s.ErrorsDtsJumpsForwardValue
}

// Number of times a frame was dropped on this PID due to a forward DTS jump.
// Each such event currently triggers a full program reset.
func (s *PushPidCountersImpl) SetErrorsDtsJumpsForward(v int) PushPidCounters {
	if s == nil {
		return nil
	}
	s.ErrorsDtsJumpsForwardValue = &v
	return s
}

// Number of times this PID was dropped from the output multiplexed stream (e.g., due to prebuffer exhaustion).
func (s PushPidCountersImpl) ErrorsPidOff() *int {
	return s.ErrorsPidOffValue
}

// Number of times this PID was dropped from the output multiplexed stream (e.g., due to prebuffer exhaustion).
func (s *PushPidCountersImpl) SetErrorsPidOff(v int) PushPidCounters {
	if s == nil {
		return nil
	}
	s.ErrorsPidOffValue = &v
	return s
}

// Number of PID start errors caused by DTS values too far in the future.
// Each such event currently triggers a full program reset.
func (s PushPidCountersImpl) ErrorsStartFutureDts() *int {
	return s.ErrorsStartFutureDtsValue
}

// Number of PID start errors caused by DTS values too far in the future.
// Each such event currently triggers a full program reset.
func (s *PushPidCountersImpl) SetErrorsStartFutureDts(v int) PushPidCounters {
	if s == nil {
		return nil
	}
	s.ErrorsStartFutureDtsValue = &v
	return s
}

// Number of PID start errors caused by late DTS.
// Each such event currently triggers a full program reset.
func (s PushPidCountersImpl) ErrorsStartLateDts() *int {
	return s.ErrorsStartLateDtsValue
}

// Number of PID start errors caused by late DTS.
// Each such event currently triggers a full program reset.
func (s *PushPidCountersImpl) SetErrorsStartLateDts(v int) PushPidCounters {
	if s == nil {
		return nil
	}
	s.ErrorsStartLateDtsValue = &v
	return s
}

// Number of times a frame was received on an unconfigured PID.
// Usually occurs after reconfiguration.
func (s PushPidCountersImpl) ErrorsUnconfiguredQueue() *int {
	return s.ErrorsUnconfiguredQueueValue
}

// Number of times a frame was received on an unconfigured PID.
// Usually occurs after reconfiguration.
func (s *PushPidCountersImpl) SetErrorsUnconfiguredQueue(v int) PushPidCounters {
	if s == nil {
		return nil
	}
	s.ErrorsUnconfiguredQueueValue = &v
	return s
}

// The number of bytes exceeding the allocated bandwidth.
// Format: bytes (bytes)
func (s PushPidCountersImpl) ExceededBytes() *Bytes {
	return s.ExceededBytesValue
}

// The number of bytes exceeding the allocated bandwidth.
// Format: bytes (bytes)
func (s *PushPidCountersImpl) SetExceededBytes(v Bytes) PushPidCounters {
	if s == nil {
		return nil
	}
	s.ExceededBytesValue = &v
	return s
}

// The number of PES packets with an instant bitrate boost.
func (s PushPidCountersImpl) ExceededFrames() *int {
	return s.ExceededFramesValue
}

// The number of PES packets with an instant bitrate boost.
func (s *PushPidCountersImpl) SetExceededFrames(v int) PushPidCounters {
	if s == nil {
		return nil
	}
	s.ExceededFramesValue = &v
	return s
}

// How many MPEG-TS packets with NAL fillers on this PID produced.
func (s PushPidCountersImpl) FillerPackets() *int {
	return s.FillerPacketsValue
}

// How many MPEG-TS packets with NAL fillers on this PID produced.
func (s *PushPidCountersImpl) SetFillerPackets(v int) PushPidCounters {
	if s == nil {
		return nil
	}
	s.FillerPacketsValue = &v
	return s
}

// Deprecated field. Will be deleted at 25.11
// The filler bytes count.
// Use `filler_packets` instead.
// Format: bytes (bytes)
func (s PushPidCountersImpl) Fillers() *Bytes {
	return s.FillersValue
}

// Deprecated field. Will be deleted at 25.11
// The filler bytes count.
// Use `filler_packets` instead.
// Format: bytes (bytes)
func (s *PushPidCountersImpl) SetFillers(v Bytes) PushPidCounters {
	if s == nil {
		return nil
	}
	s.FillersValue = &v
	return s
}

// Deprecated field. Will be deleted at 25.11
// How many bytes were seen in NAL fillers.
// Use `filler_packets` instead.
// Format: bytes (bytes)
func (s PushPidCountersImpl) FillersBytes() *Bytes {
	return s.FillersBytesValue
}

// Deprecated field. Will be deleted at 25.11
// How many bytes were seen in NAL fillers.
// Use `filler_packets` instead.
// Format: bytes (bytes)
func (s *PushPidCountersImpl) SetFillersBytes(v Bytes) PushPidCounters {
	if s == nil {
		return nil
	}
	s.FillersBytesValue = &v
	return s
}

// Highest recorded level of the TS buffer.
// With too big values the HRD buffer may be filling up completely (overflow).
// Format: milliseconds (milliseconds)
func (s PushPidCountersImpl) MaxBuffer() *Milliseconds {
	return s.MaxBufferValue
}

// Highest recorded level of the TS buffer.
// With too big values the HRD buffer may be filling up completely (overflow).
// Format: milliseconds (milliseconds)
func (s *PushPidCountersImpl) SetMaxBuffer(v Milliseconds) PushPidCounters {
	if s == nil {
		return nil
	}
	s.MaxBufferValue = &v
	return s
}

// Lowest recorded level of the TS buffer.
// With too small values the HRD buffer may be completely empty (underflow).
// Format: milliseconds (milliseconds)
func (s PushPidCountersImpl) MinBuffer() *Milliseconds {
	return s.MinBufferValue
}

// Lowest recorded level of the TS buffer.
// With too small values the HRD buffer may be completely empty (underflow).
// Format: milliseconds (milliseconds)
func (s *PushPidCountersImpl) SetMinBuffer(v Milliseconds) PushPidCounters {
	if s == nil {
		return nil
	}
	s.MinBufferValue = &v
	return s
}

// How many MPEG-TS packets with 188 bytes on this PID produced.
func (s PushPidCountersImpl) Packets() *int {
	return s.PacketsValue
}

// How many MPEG-TS packets with 188 bytes on this PID produced.
func (s *PushPidCountersImpl) SetPackets(v int) PushPidCounters {
	if s == nil {
		return nil
	}
	s.PacketsValue = &v
	return s
}

// Deprecated field. Will be deleted at 25.11
// The payload bytes count.
// Use `payload_bytes` instead.
// Format: bytes (bytes)
func (s PushPidCountersImpl) Payload() *Bytes {
	return s.PayloadValue
}

// Deprecated field. Will be deleted at 25.11
// The payload bytes count.
// Use `payload_bytes` instead.
// Format: bytes (bytes)
func (s *PushPidCountersImpl) SetPayload(v Bytes) PushPidCounters {
	if s == nil {
		return nil
	}
	s.PayloadValue = &v
	return s
}

// The payload bytes count.
// Format: bytes (bytes)
func (s PushPidCountersImpl) PayloadBytes() *Bytes {
	return s.PayloadBytesValue
}

// The payload bytes count.
// Format: bytes (bytes)
func (s *PushPidCountersImpl) SetPayloadBytes(v Bytes) PushPidCounters {
	if s == nil {
		return nil
	}
	s.PayloadBytesValue = &v
	return s
}

// Related MPEG-TS PID.
func (s PushPidCountersImpl) Pid() int {
	return s.PidValue
}

// Related MPEG-TS PID.
func (s *PushPidCountersImpl) SetPid(v int) PushPidCounters {
	if s == nil {
		return nil
	}
	s.PidValue = v
	return s
}

// Program ID this PID belongs to.
func (s PushPidCountersImpl) Pnr() *int {
	return s.PnrValue
}

// Program ID this PID belongs to.
func (s *PushPidCountersImpl) SetPnr(v int) PushPidCounters {
	if s == nil {
		return nil
	}
	s.PnrValue = &v
	return s
}

// Deprecated field. Will be deleted at 25.11
// The stuff packets count.
// Use `stuffing_packets` instead.
func (s PushPidCountersImpl) Stuffing() *int {
	return s.StuffingValue
}

// Deprecated field. Will be deleted at 25.11
// The stuff packets count.
// Use `stuffing_packets` instead.
func (s *PushPidCountersImpl) SetStuffing(v int) PushPidCounters {
	if s == nil {
		return nil
	}
	s.StuffingValue = &v
	return s
}

// How many NULL packets (PID 0x1FFF) inserted when no data is scheduled on this PID.
func (s PushPidCountersImpl) StuffingPackets() *int {
	return s.StuffingPacketsValue
}

// How many NULL packets (PID 0x1FFF) inserted when no data is scheduled on this PID.
func (s *PushPidCountersImpl) SetStuffingPackets(v int) PushPidCounters {
	if s == nil {
		return nil
	}
	s.StuffingPacketsValue = &v
	return s
}

// The trimmed bytes count.
// Format: bytes (bytes)
func (s PushPidCountersImpl) TrimmedBytes() *Bytes {
	return s.TrimmedBytesValue
}

// The trimmed bytes count.
// Format: bytes (bytes)
func (s *PushPidCountersImpl) SetTrimmedBytes(v Bytes) PushPidCounters {
	if s == nil {
		return nil
	}
	s.TrimmedBytesValue = &v
	return s
}

// The trimmed PES packets count.
func (s PushPidCountersImpl) TrimmedFrames() *int {
	return s.TrimmedFramesValue
}

// The trimmed PES packets count.
func (s *PushPidCountersImpl) SetTrimmedFrames(v int) PushPidCounters {
	if s == nil {
		return nil
	}
	s.TrimmedFramesValue = &v
	return s
}

// NewRTPCountersBase creates a new RTPCountersBase instance
func NewRTPCountersBase() RTPCountersBase {
	return &RTPCountersBaseImpl{}
}

// How many bytes received for this channel
func (s RTPCountersBaseImpl) Bytes() *int {
	return s.BytesValue
}

// How many bytes received for this channel
func (s *RTPCountersBaseImpl) SetBytes(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.BytesValue = &v
	return s
}

// RTP channel number
// Example: 0
func (s RTPCountersBaseImpl) ChannelID() int {
	return s.ChannelIDValue
}

// RTP channel number
// Example: 0
func (s *RTPCountersBaseImpl) SetChannelID(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.ChannelIDValue = v
	return s
}

// Content of the track transmitted in the channel
// Example: video
func (s RTPCountersBaseImpl) Content() *string {
	return s.ContentValue
}

// Content of the track transmitted in the channel
// Example: video
func (s *RTPCountersBaseImpl) SetContent(v string) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.ContentValue = &v
	return s
}

// Demultiplexing was done right, but content is broken.
func (s RTPCountersBaseImpl) ErrorsBrokenPayload() *int {
	return s.ErrorsBrokenPayloadValue
}

// Demultiplexing was done right, but content is broken.
func (s *RTPCountersBaseImpl) SetErrorsBrokenPayload(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.ErrorsBrokenPayloadValue = &v
	return s
}

// Number of frames which dts is same as previous frame dts.
func (s RTPCountersBaseImpl) ErrorsDtsStuck() *int {
	return s.ErrorsDtsStuckValue
}

// Number of frames which dts is same as previous frame dts.
func (s *RTPCountersBaseImpl) SetErrorsDtsStuck(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.ErrorsDtsStuckValue = &v
	return s
}

// RTP have enough information to tell how many packets were lost
func (s RTPCountersBaseImpl) ErrorsLostPackets() *int {
	return s.ErrorsLostPacketsValue
}

// RTP have enough information to tell how many packets were lost
func (s *RTPCountersBaseImpl) SetErrorsLostPackets(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.ErrorsLostPacketsValue = &v
	return s
}

// How many frames received for this channel
func (s RTPCountersBaseImpl) Frames() *int {
	return s.FramesValue
}

// How many frames received for this channel
func (s *RTPCountersBaseImpl) SetFrames(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.FramesValue = &v
	return s
}

// Number of RTP packets which marker bit is set to one.
func (s RTPCountersBaseImpl) MarkerPacketsCount() *int {
	return s.MarkerPacketsCountValue
}

// Number of RTP packets which marker bit is set to one.
func (s *RTPCountersBaseImpl) SetMarkerPacketsCount(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.MarkerPacketsCountValue = &v
	return s
}

// How many NACK messages are sent for this channel
func (s RTPCountersBaseImpl) NackCount() *int {
	return s.NackCountValue
}

// How many NACK messages are sent for this channel
func (s *RTPCountersBaseImpl) SetNackCount(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.NackCountValue = &v
	return s
}

// If no marker bit packet is received after 400 RTP packets then decoder switches to `no_marker_mode` and
// makes frame on each timecode change.
// This flag shows if decoder works in `no_marker_mode`.
func (s RTPCountersBaseImpl) NoMarkerModeFlag() *bool {
	return s.NoMarkerModeFlagValue
}

// If no marker bit packet is received after 400 RTP packets then decoder switches to `no_marker_mode` and
// makes frame on each timecode change.
// This flag shows if decoder works in `no_marker_mode`.
func (s *RTPCountersBaseImpl) SetNoMarkerModeFlag(v bool) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.NoMarkerModeFlagValue = &v
	return s
}

// Number of rtp packets rejected due to wrong payload type
func (s RTPCountersBaseImpl) PtRejectCount() *int {
	return s.PtRejectCountValue
}

// Number of rtp packets rejected due to wrong payload type
func (s *RTPCountersBaseImpl) SetPtRejectCount(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.PtRejectCountValue = &v
	return s
}

// Total size of rejected packets due to wrong payload type (pt_reject_count) rtp packets
func (s RTPCountersBaseImpl) PtRejectSum() *int {
	return s.PtRejectSumValue
}

// Total size of rejected packets due to wrong payload type (pt_reject_count) rtp packets
func (s *RTPCountersBaseImpl) SetPtRejectSum(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.PtRejectSumValue = &v
	return s
}

// How many RTCP packets received for this channel
func (s RTPCountersBaseImpl) RtcpPackets() *int {
	return s.RtcpPacketsValue
}

// How many RTCP packets received for this channel
func (s *RTPCountersBaseImpl) SetRtcpPackets(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.RtcpPacketsValue = &v
	return s
}

// How many RTP packets received for this channel
func (s RTPCountersBaseImpl) RTPPackets() *int {
	return s.RTPPacketsValue
}

// How many RTP packets received for this channel
func (s *RTPCountersBaseImpl) SetRTPPackets(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.RTPPacketsValue = &v
	return s
}

// Sender wallclock deviation from server time in ms. Positive value means that sender time is ahead of server time.
func (s RTPCountersBaseImpl) SenderClockDeviation() *int {
	return s.SenderClockDeviationValue
}

// Sender wallclock deviation from server time in ms. Positive value means that sender time is ahead of server time.
func (s *RTPCountersBaseImpl) SetSenderClockDeviation(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.SenderClockDeviationValue = &v
	return s
}

// Number of rtcp SR packets which `RTP timestamp` is equal to the previous rtcp SR packet `RTP timestamp`.
func (s RTPCountersBaseImpl) SrTSStuck() *int {
	return s.SrTSStuckValue
}

// Number of rtcp SR packets which `RTP timestamp` is equal to the previous rtcp SR packet `RTP timestamp`.
func (s *RTPCountersBaseImpl) SetSrTSStuck(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.SrTSStuckValue = &v
	return s
}

// Time on this channel is jumped back from reference wallclock.
func (s RTPCountersBaseImpl) TSGoesBackwards() *int {
	return s.TSGoesBackwardsValue
}

// Time on this channel is jumped back from reference wallclock.
func (s *RTPCountersBaseImpl) SetTSGoesBackwards(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.TSGoesBackwardsValue = &v
	return s
}

// Time on this channel is jumped forward from reference wallclock.
func (s RTPCountersBaseImpl) TSJumpForward() *int {
	return s.TSJumpForwardValue
}

// Time on this channel is jumped forward from reference wallclock.
func (s *RTPCountersBaseImpl) SetTSJumpForward(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.TSJumpForwardValue = &v
	return s
}

// https://datatracker.ietf.org/doc/html/rfc6184#section-4.1
// access unit: A set of NAL units always containing a primary coded picture.  In addition to the primary coded
// picture, an access unit may also contain one or more redundant coded pictures or other NAL units not containing
// slices or slice data partitions of a coded picture.  The decoding of an access unit always results in a
// decoded picture.
// There is `marker bit` in RTP packet which is set for the very last packet of the access unit indicated by the RTP timestamp.
// It is protocol violation if received RTP packet has the same timestamp as previous marker bit packet.
// This counter is a number of RTP packets which `RTP timestamp` is equal to previous RTP marker bit packet.
func (s RTPCountersBaseImpl) TSStuck() *int {
	return s.TSStuckValue
}

// https://datatracker.ietf.org/doc/html/rfc6184#section-4.1
// access unit: A set of NAL units always containing a primary coded picture.  In addition to the primary coded
// picture, an access unit may also contain one or more redundant coded pictures or other NAL units not containing
// slices or slice data partitions of a coded picture.  The decoding of an access unit always results in a
// decoded picture.
// There is `marker bit` in RTP packet which is set for the very last packet of the access unit indicated by the RTP timestamp.
// It is protocol violation if received RTP packet has the same timestamp as previous marker bit packet.
// This counter is a number of RTP packets which `RTP timestamp` is equal to previous RTP marker bit packet.
func (s *RTPCountersBaseImpl) SetTSStuck(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.TSStuckValue = &v
	return s
}

// NewRaidDiskConfig creates a new RaidDiskConfig instance
func NewRaidDiskConfig() RaidDiskConfig {
	return &RaidDiskConfigImpl{}
}

// The mode of using the disk.
// Example: keep
func (s RaidDiskConfigImpl) Mode() *RaidDiskMode {
	return s.ModeValue
}

// The mode of using the disk.
// Example: keep
func (s *RaidDiskConfigImpl) SetMode(v RaidDiskMode) RaidDiskConfig {
	if s == nil {
		return nil
	}
	s.ModeValue = &v
	return s
}

// The path to a mounted disk.
// Format: disk_path (disk_path)
// Example: volume1
func (s RaidDiskConfigImpl) Path() DiskPath {
	return s.PathValue
}

// The path to a mounted disk.
// Format: disk_path (disk_path)
// Example: volume1
func (s *RaidDiskConfigImpl) SetPath(v DiskPath) RaidDiskConfig {
	if s == nil {
		return nil
	}
	s.PathValue = v
	return s
}

// The runtime statistics about RAID. The statistics shows the state of disks.
// Learn more in [Flussonic RAID for DVR](https://flussonic.com/doc/extend-video-storage-on-fly/#dvr-flussonic-raid-stats)
func (s RaidDiskConfigImpl) Stats() RaidDiskConfigStats {
	return s.StatsValue
}

// The runtime statistics about RAID. The statistics shows the state of disks.
// Learn more in [Flussonic RAID for DVR](https://flussonic.com/doc/extend-video-storage-on-fly/#dvr-flussonic-raid-stats)
func (s *RaidDiskConfigImpl) SetStats(v RaidDiskConfigStats) RaidDiskConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*RaidDiskConfigStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// NewRaidDiskConfigStats creates a new RaidDiskConfigStats instance
func NewRaidDiskConfigStats() RaidDiskConfigStats {
	return &RaidDiskConfigStatsImpl{}
}

// The number of blobs on the disk that are enlisted in individual stream indexes.
// It must be equal to blobs_count_db and can be different in case of software
// or hardware errors.
func (s RaidDiskConfigStatsImpl) BlobsCount() *int {
	return s.BlobsCountValue
}

// The number of blobs on the disk that are enlisted in individual stream indexes.
// It must be equal to blobs_count_db and can be different in case of software
// or hardware errors.
func (s *RaidDiskConfigStatsImpl) SetBlobsCount(v int) RaidDiskConfigStats {
	if s == nil {
		return nil
	}
	s.BlobsCountValue = &v
	return s
}

// The number of blobs on the disk according to centralized Raid DB that is
// used to allocate blobs across whole storage.
func (s RaidDiskConfigStatsImpl) BlobsCountDb() *int {
	return s.BlobsCountDbValue
}

// The number of blobs on the disk according to centralized Raid DB that is
// used to allocate blobs across whole storage.
func (s *RaidDiskConfigStatsImpl) SetBlobsCountDb(v int) RaidDiskConfigStats {
	if s == nil {
		return nil
	}
	s.BlobsCountDbValue = &v
	return s
}

// Errors of using the disk.
func (s RaidDiskConfigStatsImpl) Errors() RaidDiskErrors {
	return s.ErrorsValue
}

// Errors of using the disk.
func (s *RaidDiskConfigStatsImpl) SetErrors(v RaidDiskErrors) RaidDiskConfigStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*RaidDiskErrorsImpl); ok {
		s.ErrorsValue = impl
	}
	return s
}

// Disk I/O utilization percentage from `/proc/devstat`.
// Format: percent (percent)
func (s RaidDiskConfigStatsImpl) IoUsage() *Percent {
	return s.IoUsageValue
}

// Disk I/O utilization percentage from `/proc/devstat`.
// Format: percent (percent)
func (s *RaidDiskConfigStatsImpl) SetIoUsage(v Percent) RaidDiskConfigStats {
	if s == nil {
		return nil
	}
	s.IoUsageValue = &v
	return s
}

// The estimated migration end time, in UTC seconds.
// Format: utc (Unix timestamp in seconds)
func (s RaidDiskConfigStatsImpl) MigrationEta() *Utc {
	return s.MigrationEtaValue
}

// The estimated migration end time, in UTC seconds.
// Format: utc (Unix timestamp in seconds)
func (s *RaidDiskConfigStatsImpl) SetMigrationEta(v Utc) RaidDiskConfigStats {
	if s == nil {
		return nil
	}
	s.MigrationEtaValue = &v
	return s
}

// The speed of copying the last blob, in bytes per second.
// Format: speed (speed)
func (s RaidDiskConfigStatsImpl) MigrationSpeed() *Speed {
	return s.MigrationSpeedValue
}

// The speed of copying the last blob, in bytes per second.
// Format: speed (speed)
func (s *RaidDiskConfigStatsImpl) SetMigrationSpeed(v Speed) RaidDiskConfigStats {
	if s == nil {
		return nil
	}
	s.MigrationSpeedValue = &v
	return s
}

// The time when the values of `migration_speed` and `migration_eta` were last updated.
// Format: utc (Unix timestamp in seconds)
func (s RaidDiskConfigStatsImpl) MigrationUpdated() *Utc {
	return s.MigrationUpdatedValue
}

// The time when the values of `migration_speed` and `migration_eta` were last updated.
// Format: utc (Unix timestamp in seconds)
func (s *RaidDiskConfigStatsImpl) SetMigrationUpdated(v Utc) RaidDiskConfigStats {
	if s == nil {
		return nil
	}
	s.MigrationUpdatedValue = &v
	return s
}

// The mode of using the disk.
// Example: keep
func (s RaidDiskConfigStatsImpl) Mode() *RaidDiskMode {
	return s.ModeValue
}

// The mode of using the disk.
// Example: keep
func (s *RaidDiskConfigStatsImpl) SetMode(v RaidDiskMode) RaidDiskConfigStats {
	if s == nil {
		return nil
	}
	s.ModeValue = &v
	return s
}

// Whether the disk is mounted correctly.
func (s RaidDiskConfigStatsImpl) Mounted() *bool {
	return s.MountedValue
}

// Whether the disk is mounted correctly.
func (s *RaidDiskConfigStatsImpl) SetMounted(v bool) RaidDiskConfigStats {
	if s == nil {
		return nil
	}
	s.MountedValue = &v
	return s
}

// Disk capacity in bytes.
// Format: bytes (bytes)
func (s RaidDiskConfigStatsImpl) Size() *Bytes {
	return s.SizeValue
}

// Disk capacity in bytes.
// Format: bytes (bytes)
func (s *RaidDiskConfigStatsImpl) SetSize(v Bytes) RaidDiskConfigStats {
	if s == nil {
		return nil
	}
	s.SizeValue = &v
	return s
}

// Disk utilization percentage.
// Format: percent (percent)
func (s RaidDiskConfigStatsImpl) Usage() *Percent {
	return s.UsageValue
}

// Disk utilization percentage.
// Format: percent (percent)
func (s *RaidDiskConfigStatsImpl) SetUsage(v Percent) RaidDiskConfigStats {
	if s == nil {
		return nil
	}
	s.UsageValue = &v
	return s
}

// Used disk space in bytes according to linux metrics. It must be equal (almost equal) to
// `used_index`. If it differs more than in 1%, then it means that there are lot of unknown files.
// If this disk is used exclusively for Raid, then it may mean that some blobs are lost from
// database and repairing is required.
// Format: bytes (bytes)
func (s RaidDiskConfigStatsImpl) Used() *Bytes {
	return s.UsedValue
}

// Used disk space in bytes according to linux metrics. It must be equal (almost equal) to
// `used_index`. If it differs more than in 1%, then it means that there are lot of unknown files.
// If this disk is used exclusively for Raid, then it may mean that some blobs are lost from
// database and repairing is required.
// Format: bytes (bytes)
func (s *RaidDiskConfigStatsImpl) SetUsed(v Bytes) RaidDiskConfigStats {
	if s == nil {
		return nil
	}
	s.UsedValue = &v
	return s
}

// Used disk space in bytes according to internal database index.
// Format: bytes (bytes)
func (s RaidDiskConfigStatsImpl) UsedIndex() *Bytes {
	return s.UsedIndexValue
}

// Used disk space in bytes according to internal database index.
// Format: bytes (bytes)
func (s *RaidDiskConfigStatsImpl) SetUsedIndex(v Bytes) RaidDiskConfigStats {
	if s == nil {
		return nil
	}
	s.UsedIndexValue = &v
	return s
}

// NewRaidDiskErrors creates a new RaidDiskErrors instance
func NewRaidDiskErrors() RaidDiskErrors {
	return &RaidDiskErrorsImpl{}
}

// Total number of connection timeout errors
// Example: 1
func (s RaidDiskErrorsImpl) ConnectionTimeout() *int {
	return s.ConnectionTimeoutValue
}

// Total number of connection timeout errors
// Example: 1
func (s *RaidDiskErrorsImpl) SetConnectionTimeout(v int) RaidDiskErrors {
	if s == nil {
		return nil
	}
	s.ConnectionTimeoutValue = &v
	return s
}

// Total number of permission denied errors
// Example: 1
func (s RaidDiskErrorsImpl) Eacces() *int {
	return s.EaccesValue
}

// Total number of permission denied errors
// Example: 1
func (s *RaidDiskErrorsImpl) SetEacces(v int) RaidDiskErrors {
	if s == nil {
		return nil
	}
	s.EaccesValue = &v
	return s
}

// Total number of temporarily unavailable errors
// Example: 1
func (s RaidDiskErrorsImpl) Eagain() *int {
	return s.EagainValue
}

// Total number of temporarily unavailable errors
// Example: 1
func (s *RaidDiskErrorsImpl) SetEagain(v int) RaidDiskErrors {
	if s == nil {
		return nil
	}
	s.EagainValue = &v
	return s
}

// Total number of file busy errors
// Example: 1
func (s RaidDiskErrorsImpl) Ebusy() *int {
	return s.EbusyValue
}

// Total number of file busy errors
// Example: 1
func (s *RaidDiskErrorsImpl) SetEbusy(v int) RaidDiskErrors {
	if s == nil {
		return nil
	}
	s.EbusyValue = &v
	return s
}

// Total number of connection refused errors
// Example: 1
func (s RaidDiskErrorsImpl) Econnrefused() *int {
	return s.EconnrefusedValue
}

// Total number of connection refused errors
// Example: 1
func (s *RaidDiskErrorsImpl) SetEconnrefused(v int) RaidDiskErrors {
	if s == nil {
		return nil
	}
	s.EconnrefusedValue = &v
	return s
}

// Total number of disk quota exceeded errors
// Example: 1
func (s RaidDiskErrorsImpl) Edquot() *int {
	return s.EdquotValue
}

// Total number of disk quota exceeded errors
// Example: 1
func (s *RaidDiskErrorsImpl) SetEdquot(v int) RaidDiskErrors {
	if s == nil {
		return nil
	}
	s.EdquotValue = &v
	return s
}

// Total number of too many open files errors
// Example: 1
func (s RaidDiskErrorsImpl) Emfile() *int {
	return s.EmfileValue
}

// Total number of too many open files errors
// Example: 1
func (s *RaidDiskErrorsImpl) SetEmfile(v int) RaidDiskErrors {
	if s == nil {
		return nil
	}
	s.EmfileValue = &v
	return s
}

// Total number of no such device errors
// Example: 1
func (s RaidDiskErrorsImpl) Enodev() *int {
	return s.EnodevValue
}

// Total number of no such device errors
// Example: 1
func (s *RaidDiskErrorsImpl) SetEnodev(v int) RaidDiskErrors {
	if s == nil {
		return nil
	}
	s.EnodevValue = &v
	return s
}

// Total number of no such file or directory errors
// Example: 1
func (s RaidDiskErrorsImpl) Enoent() *int {
	return s.EnoentValue
}

// Total number of no such file or directory errors
// Example: 1
func (s *RaidDiskErrorsImpl) SetEnoent(v int) RaidDiskErrors {
	if s == nil {
		return nil
	}
	s.EnoentValue = &v
	return s
}

// Total number of no space left on device errors
// Example: 1
func (s RaidDiskErrorsImpl) Enospc() *int {
	return s.EnospcValue
}

// Total number of no space left on device errors
// Example: 1
func (s *RaidDiskErrorsImpl) SetEnospc(v int) RaidDiskErrors {
	if s == nil {
		return nil
	}
	s.EnospcValue = &v
	return s
}

// Total number of read-only file system errors
// Example: 1
func (s RaidDiskErrorsImpl) Erofs() *int {
	return s.ErofsValue
}

// Total number of read-only file system errors
// Example: 1
func (s *RaidDiskErrorsImpl) SetErofs(v int) RaidDiskErrors {
	if s == nil {
		return nil
	}
	s.ErofsValue = &v
	return s
}

// Total number of non-existing domain errors
// Example: 1
func (s RaidDiskErrorsImpl) Nxdomain() *int {
	return s.NxdomainValue
}

// Total number of non-existing domain errors
// Example: 1
func (s *RaidDiskErrorsImpl) SetNxdomain(v int) RaidDiskErrors {
	if s == nil {
		return nil
	}
	s.NxdomainValue = &v
	return s
}

// Total number of other errors
// Example: 1
func (s RaidDiskErrorsImpl) Other() *int {
	return s.OtherValue
}

// Total number of other errors
// Example: 1
func (s *RaidDiskErrorsImpl) SetOther(v int) RaidDiskErrors {
	if s == nil {
		return nil
	}
	s.OtherValue = &v
	return s
}

// Total number of SSL errors
// Example: 1
func (s RaidDiskErrorsImpl) SslError() *int {
	return s.SslErrorValue
}

// Total number of SSL errors
// Example: 1
func (s *RaidDiskErrorsImpl) SetSslError(v int) RaidDiskErrors {
	if s == nil {
		return nil
	}
	s.SslErrorValue = &v
	return s
}

// NewRaidDiskStats creates a new RaidDiskStats instance
func NewRaidDiskStats() RaidDiskStats {
	return &RaidDiskStatsImpl{}
}

// Errors of using the disk.
func (s RaidDiskStatsImpl) Errors() RaidDiskErrors {
	return s.ErrorsValue
}

// Errors of using the disk.
func (s *RaidDiskStatsImpl) SetErrors(v RaidDiskErrors) RaidDiskStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*RaidDiskErrorsImpl); ok {
		s.ErrorsValue = impl
	}
	return s
}

// Disk I/O utilization percentage from `/proc/devstat`.
// Format: percent (percent)
func (s RaidDiskStatsImpl) IoUsage() *Percent {
	return s.IoUsageValue
}

// Disk I/O utilization percentage from `/proc/devstat`.
// Format: percent (percent)
func (s *RaidDiskStatsImpl) SetIoUsage(v Percent) RaidDiskStats {
	if s == nil {
		return nil
	}
	s.IoUsageValue = &v
	return s
}

// The estimated migration end time, in UTC seconds.
// Format: utc (Unix timestamp in seconds)
func (s RaidDiskStatsImpl) MigrationEta() *Utc {
	return s.MigrationEtaValue
}

// The estimated migration end time, in UTC seconds.
// Format: utc (Unix timestamp in seconds)
func (s *RaidDiskStatsImpl) SetMigrationEta(v Utc) RaidDiskStats {
	if s == nil {
		return nil
	}
	s.MigrationEtaValue = &v
	return s
}

// The speed of copying the last blob, in bytes per second.
// Format: speed (speed)
func (s RaidDiskStatsImpl) MigrationSpeed() *Speed {
	return s.MigrationSpeedValue
}

// The speed of copying the last blob, in bytes per second.
// Format: speed (speed)
func (s *RaidDiskStatsImpl) SetMigrationSpeed(v Speed) RaidDiskStats {
	if s == nil {
		return nil
	}
	s.MigrationSpeedValue = &v
	return s
}

// The time when the values of `migration_speed` and `migration_eta` were last updated.
// Format: utc (Unix timestamp in seconds)
func (s RaidDiskStatsImpl) MigrationUpdated() *Utc {
	return s.MigrationUpdatedValue
}

// The time when the values of `migration_speed` and `migration_eta` were last updated.
// Format: utc (Unix timestamp in seconds)
func (s *RaidDiskStatsImpl) SetMigrationUpdated(v Utc) RaidDiskStats {
	if s == nil {
		return nil
	}
	s.MigrationUpdatedValue = &v
	return s
}

// The mode of using the disk.
// Example: keep
func (s RaidDiskStatsImpl) Mode() *RaidDiskMode {
	return s.ModeValue
}

// The mode of using the disk.
// Example: keep
func (s *RaidDiskStatsImpl) SetMode(v RaidDiskMode) RaidDiskStats {
	if s == nil {
		return nil
	}
	s.ModeValue = &v
	return s
}

// Whether the disk is mounted correctly.
func (s RaidDiskStatsImpl) Mounted() *bool {
	return s.MountedValue
}

// Whether the disk is mounted correctly.
func (s *RaidDiskStatsImpl) SetMounted(v bool) RaidDiskStats {
	if s == nil {
		return nil
	}
	s.MountedValue = &v
	return s
}

// NewRproxyConfig creates a new RproxyConfig instance
func NewRproxyConfig() RproxyConfig {
	return &RproxyConfigImpl{}
}

// Path to authorization backend on the endpoint to check if the Agents are allowed to connect.
func (s RproxyConfigImpl) EndpointAuth() *string {
	return s.EndpointAuthValue
}

// Path to authorization backend on the endpoint to check if the Agents are allowed to connect.
func (s *RproxyConfigImpl) SetEndpointAuth(v string) RproxyConfig {
	if s == nil {
		return nil
	}
	s.EndpointAuthValue = &v
	return s
}

// Configuration of port handlers.
func (s RproxyConfigImpl) ForwardPorts() map[string]ForwardPortsConfig {
	if s.ForwardPortsValue == nil {
		return nil
	}
	result := make(map[string]ForwardPortsConfig)
	for k, val := range s.ForwardPortsValue {
		result[k] = val
	}
	return result
}

// Configuration of port handlers.
func (s *RproxyConfigImpl) SetForwardPorts(v map[string]ForwardPortsConfig) RproxyConfig {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make(map[string]*ForwardPortsConfigImpl)
		for k, val := range v {
			if valImpl, ok := val.(*ForwardPortsConfigImpl); ok {
				impl[k] = valImpl
			}
		}
		s.ForwardPortsValue = impl
	}
	return s
}

// The streamer ID key.
func (s RproxyConfigImpl) StreampointKey() string {
	return s.StreampointKeyValue
}

// The streamer ID key.
func (s *RproxyConfigImpl) SetStreampointKey(v string) RproxyConfig {
	if s == nil {
		return nil
	}
	s.StreampointKeyValue = v
	return s
}

// NewServerConfigBase creates a new ServerConfigBase instance
func NewServerConfigBase() ServerConfigBase {
	return &ServerConfigBaseImpl{}
}

// The cluster key to unite several servers with the same key into a cluster.
// Example: xS6i6Q3DCc5nEvnu
func (s ServerConfigBaseImpl) ClusterKey() *string {
	return s.ClusterKeyValue
}

// The cluster key to unite several servers with the same key into a cluster.
// Example: xS6i6Q3DCc5nEvnu
func (s *ServerConfigBaseImpl) SetClusterKey(v string) ServerConfigBase {
	if s == nil {
		return nil
	}
	s.ClusterKeyValue = &v
	return s
}

// The configuration of server domain name and aliases
func (s ServerConfigBaseImpl) ServerNames() []ServerNameConfig {
	if s.ServerNamesValue == nil {
		return nil
	}
	result := make([]ServerNameConfig, len(s.ServerNamesValue))
	for i, item := range s.ServerNamesValue {
		result[i] = item
	}
	return result
}

// The configuration of server domain name and aliases
func (s *ServerConfigBaseImpl) SetServerNames(v []ServerNameConfig) ServerConfigBase {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*ServerNameConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*ServerNameConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.ServerNamesValue = impl
	}
	return s
}

// NewServerConfigFull creates a new ServerConfigFull instance
func NewServerConfigFull() ServerConfigFull {
	return &ServerConfigFullImpl{}
}

// The configuration of event notifications
func (s ServerConfigFullImpl) EventSinks() []EventSinkConfig {
	if s.EventSinksValue == nil {
		return nil
	}
	result := make([]EventSinkConfig, len(s.EventSinksValue))
	for i, item := range s.EventSinksValue {
		result[i] = item
	}
	return result
}

// The configuration of event notifications
func (s *ServerConfigFullImpl) SetEventSinks(v []EventSinkConfig) ServerConfigFull {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*EventSinkConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*EventSinkConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.EventSinksValue = impl
	}
	return s
}

// List of HTTP prefixes that can be handled via call to remote http server
func (s ServerConfigFullImpl) HTTPProxies() []HTTPProxyConfig {
	if s.HTTPProxiesValue == nil {
		return nil
	}
	result := make([]HTTPProxyConfig, len(s.HTTPProxiesValue))
	for i, item := range s.HTTPProxiesValue {
		result[i] = item
	}
	return result
}

// List of HTTP prefixes that can be handled via call to remote http server
func (s *ServerConfigFullImpl) SetHTTPProxies(v []HTTPProxyConfig) ServerConfigFull {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*HTTPProxyConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*HTTPProxyConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.HTTPProxiesValue = impl
	}
	return s
}

// The configuration of the port forwarding.
func (s ServerConfigFullImpl) Rproxy() RproxyConfig {
	return s.RproxyValue
}

// The configuration of the port forwarding.
func (s *ServerConfigFullImpl) SetRproxy(v RproxyConfig) ServerConfigFull {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*RproxyConfigImpl); ok {
		s.RproxyValue = impl
	}
	return s
}

// NewServerNameConfig creates a new ServerNameConfig instance
func NewServerNameConfig() ServerNameConfig {
	return &ServerNameConfigImpl{}
}

// List of domain aliases, used together with the primary name to issue ssl certs
// Example: [s1.streamer.local s2.streamer.local]
func (s ServerNameConfigImpl) Aliases() []string {
	return s.AliasesValue
}

// List of domain aliases, used together with the primary name to issue ssl certs
// Example: [s1.streamer.local s2.streamer.local]
func (s *ServerNameConfigImpl) SetAliases(v []string) ServerNameConfig {
	if s == nil {
		return nil
	}
	s.AliasesValue = v
	return s
}

// Domain names to issue ssl certificates for
// Example: streamer.local
func (s ServerNameConfigImpl) Domain() string {
	return s.DomainValue
}

// Domain names to issue ssl certificates for
// Example: streamer.local
func (s *ServerNameConfigImpl) SetDomain(v string) ServerNameConfig {
	if s == nil {
		return nil
	}
	s.DomainValue = v
	return s
}

// NewServerStarted creates a new ServerStarted instance
func NewServerStarted() ServerStarted {
	return &ServerStartedImpl{}
}

// Server started successfully.
func (s ServerStartedImpl) Event() string {
	return s.EventValue
}

// Server started successfully.
func (s *ServerStartedImpl) SetEvent(v string) ServerStarted {
	if s == nil {
		return nil
	}
	s.EventValue = v
	return s
}

// Event identifier.
func (s ServerStartedImpl) EventID() *int {
	return s.EventIDValue
}

// Event identifier.
func (s *ServerStartedImpl) SetEventID(v int) ServerStarted {
	if s == nil {
		return nil
	}
	s.EventIDValue = &v
	return s
}

// The ID of the started instance.
func (s ServerStartedImpl) InstanceID() *string {
	return s.InstanceIDValue
}

// The ID of the started instance.
func (s *ServerStartedImpl) SetInstanceID(v string) ServerStarted {
	if s == nil {
		return nil
	}
	s.InstanceIDValue = &v
	return s
}

func (s ServerStartedImpl) PreviousState() *PreviousServerState {
	return s.PreviousStateValue
}

func (s *ServerStartedImpl) SetPreviousState(v PreviousServerState) ServerStarted {
	if s == nil {
		return nil
	}
	s.PreviousStateValue = &v
	return s
}

// Originator of event.
// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
// is configured as HTTP/HTTPS url.
// Example: flussonic.host
func (s ServerStartedImpl) Server() *string {
	return s.ServerValue
}

// Originator of event.
// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
// is configured as HTTP/HTTPS url.
// Example: flussonic.host
func (s *ServerStartedImpl) SetServer(v string) ServerStarted {
	if s == nil {
		return nil
	}
	s.ServerValue = &v
	return s
}

// Unique identifier of the operation.
// You can use this field to search for events related to same operation.
// Value of this field is taken from the `X-Trace-Id` header.
// If `X-Trace-Id` header is not set, it will be generated automatically.
// Service will use the value of this field to make outgoing requests.
// Format: uuid (uuid)
// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
func (s ServerStartedImpl) TraceID() *UUID {
	return s.TraceIDValue
}

// Unique identifier of the operation.
// You can use this field to search for events related to same operation.
// Value of this field is taken from the `X-Trace-Id` header.
// If `X-Trace-Id` header is not set, it will be generated automatically.
// Service will use the value of this field to make outgoing requests.
// Format: uuid (uuid)
// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
func (s *ServerStartedImpl) SetTraceID(v UUID) ServerStarted {
	if s == nil {
		return nil
	}
	s.TraceIDValue = &v
	return s
}

// The time of the event registration on the server.
// Format: utc_ms (Unix timestamp in milliseconds)
func (s ServerStartedImpl) UtcMs() *UtcMs {
	return s.UtcMsValue
}

// The time of the event registration on the server.
// Format: utc_ms (Unix timestamp in milliseconds)
func (s *ServerStartedImpl) SetUtcMs(v UtcMs) ServerStarted {
	if s == nil {
		return nil
	}
	s.UtcMsValue = &v
	return s
}

// Version of Service.
func (s ServerStartedImpl) Version() *string {
	return s.VersionValue
}

// Version of Service.
func (s *ServerStartedImpl) SetVersion(v string) ServerStarted {
	if s == nil {
		return nil
	}
	s.VersionValue = &v
	return s
}

// NewServerStarting creates a new ServerStarting instance
func NewServerStarting() ServerStarting {
	return &ServerStartingImpl{}
}

// Server started booting.
func (s ServerStartingImpl) Event() string {
	return s.EventValue
}

// Server started booting.
func (s *ServerStartingImpl) SetEvent(v string) ServerStarting {
	if s == nil {
		return nil
	}
	s.EventValue = v
	return s
}

// Event identifier.
func (s ServerStartingImpl) EventID() *int {
	return s.EventIDValue
}

// Event identifier.
func (s *ServerStartingImpl) SetEventID(v int) ServerStarting {
	if s == nil {
		return nil
	}
	s.EventIDValue = &v
	return s
}

// Full version of service with the build number.
func (s ServerStartingImpl) FullVersion() *string {
	return s.FullVersionValue
}

// Full version of service with the build number.
func (s *ServerStartingImpl) SetFullVersion(v string) ServerStarting {
	if s == nil {
		return nil
	}
	s.FullVersionValue = &v
	return s
}

// Originator of event.
// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
// is configured as HTTP/HTTPS url.
// Example: flussonic.host
func (s ServerStartingImpl) Server() *string {
	return s.ServerValue
}

// Originator of event.
// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
// is configured as HTTP/HTTPS url.
// Example: flussonic.host
func (s *ServerStartingImpl) SetServer(v string) ServerStarting {
	if s == nil {
		return nil
	}
	s.ServerValue = &v
	return s
}

// Unique identifier of the operation.
// You can use this field to search for events related to same operation.
// Value of this field is taken from the `X-Trace-Id` header.
// If `X-Trace-Id` header is not set, it will be generated automatically.
// Service will use the value of this field to make outgoing requests.
// Format: uuid (uuid)
// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
func (s ServerStartingImpl) TraceID() *UUID {
	return s.TraceIDValue
}

// Unique identifier of the operation.
// You can use this field to search for events related to same operation.
// Value of this field is taken from the `X-Trace-Id` header.
// If `X-Trace-Id` header is not set, it will be generated automatically.
// Service will use the value of this field to make outgoing requests.
// Format: uuid (uuid)
// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
func (s *ServerStartingImpl) SetTraceID(v UUID) ServerStarting {
	if s == nil {
		return nil
	}
	s.TraceIDValue = &v
	return s
}

// The time of the event registration on the server.
// Format: utc_ms (Unix timestamp in milliseconds)
func (s ServerStartingImpl) UtcMs() *UtcMs {
	return s.UtcMsValue
}

// The time of the event registration on the server.
// Format: utc_ms (Unix timestamp in milliseconds)
func (s *ServerStartingImpl) SetUtcMs(v UtcMs) ServerStarting {
	if s == nil {
		return nil
	}
	s.UtcMsValue = &v
	return s
}

// Version of service.
func (s ServerStartingImpl) Version() *string {
	return s.VersionValue
}

// Version of service.
func (s *ServerStartingImpl) SetVersion(v string) ServerStarting {
	if s == nil {
		return nil
	}
	s.VersionValue = &v
	return s
}

// NewServerStatsNetwork creates a new ServerStatsNetwork instance
func NewServerStatsNetwork() ServerStatsNetwork {
	return &ServerStatsNetworkImpl{}
}

// Current incoming speed (bitrate) of the data transmission over the network.
// Format: speed (speed)
// Example: 400300
func (s ServerStatsNetworkImpl) InputKbit() *Speed {
	return s.InputKbitValue
}

// Current incoming speed (bitrate) of the data transmission over the network.
// Format: speed (speed)
// Example: 400300
func (s *ServerStatsNetworkImpl) SetInputKbit(v Speed) ServerStatsNetwork {
	if s == nil {
		return nil
	}
	s.InputKbitValue = &v
	return s
}

// The number of streams that are ready to be served to the clients.
// Example: 27
func (s ServerStatsNetworkImpl) OnlineStreams() *int {
	return s.OnlineStreamsValue
}

// The number of streams that are ready to be served to the clients.
// Example: 27
func (s *ServerStatsNetworkImpl) SetOnlineStreams(v int) ServerStatsNetwork {
	if s == nil {
		return nil
	}
	s.OnlineStreamsValue = &v
	return s
}

// The number of opened files.
// Example: 5
func (s ServerStatsNetworkImpl) OpenedFiles() *int {
	return s.OpenedFilesValue
}

// The number of opened files.
// Example: 5
func (s *ServerStatsNetworkImpl) SetOpenedFiles(v int) ServerStatsNetwork {
	if s == nil {
		return nil
	}
	s.OpenedFilesValue = &v
	return s
}

// Current outgoing speed (bitrate) of the data transmission over the network.
// Format: speed (speed)
// Example: 500400
func (s ServerStatsNetworkImpl) OutputKbit() *Speed {
	return s.OutputKbitValue
}

// Current outgoing speed (bitrate) of the data transmission over the network.
// Format: speed (speed)
// Example: 500400
func (s *ServerStatsNetworkImpl) SetOutputKbit(v Speed) ServerStatsNetwork {
	if s == nil {
		return nil
	}
	s.OutputKbitValue = &v
	return s
}

// The number of clients receiving the streams from the server at the moment of request.
// Example: 2040
func (s ServerStatsNetworkImpl) TotalClients() *int {
	return s.TotalClientsValue
}

// The number of clients receiving the streams from the server at the moment of request.
// Example: 2040
func (s *ServerStatsNetworkImpl) SetTotalClients(v int) ServerStatsNetwork {
	if s == nil {
		return nil
	}
	s.TotalClientsValue = &v
	return s
}

// The number of streams created on the server.
// Example: 45
func (s ServerStatsNetworkImpl) TotalStreams() *int {
	return s.TotalStreamsValue
}

// The number of streams created on the server.
// Example: 45
func (s *ServerStatsNetworkImpl) SetTotalStreams(v int) ServerStatsNetwork {
	if s == nil {
		return nil
	}
	s.TotalStreamsValue = &v
	return s
}

// NewServerStatsStreamer creates a new ServerStatsStreamer instance
func NewServerStatsStreamer() ServerStatsStreamer {
	return &ServerStatsStreamerImpl{}
}

// Outbound bandwidth usage (load balancing in `usage` mode is based on this value).
// Format: percent (percent)
// Example: 67
func (s ServerStatsStreamerImpl) BandwidthUsage() *Percent {
	return s.BandwidthUsageValue
}

// Outbound bandwidth usage (load balancing in `usage` mode is based on this value).
// Format: percent (percent)
// Example: 67
func (s *ServerStatsStreamerImpl) SetBandwidthUsage(v Percent) ServerStatsStreamer {
	if s == nil {
		return nil
	}
	s.BandwidthUsageValue = &v
	return s
}

// Information about errors in the config file.
func (s ServerStatsStreamerImpl) ConfigError() ConfigErrorStatus {
	return s.ConfigErrorValue
}

// Information about errors in the config file.
func (s *ServerStatsStreamerImpl) SetConfigError(v ConfigErrorStatus) ServerStatsStreamer {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ConfigErrorStatusImpl); ok {
		s.ConfigErrorValue = impl
	}
	return s
}

// Information about current external config status
func (s ServerStatsStreamerImpl) ConfigExternalStatus() ConfigExternalErrorStatus {
	return s.ConfigExternalStatusValue
}

// Information about current external config status
func (s *ServerStatsStreamerImpl) SetConfigExternalStatus(v ConfigExternalErrorStatus) ServerStatsStreamer {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ConfigExternalErrorStatusImpl); ok {
		s.ConfigExternalStatusValue = impl
	}
	return s
}

// Current runtime version of config. We do not declare exact structure, but we promise
// that it will be always comparable and increasing (if server has proper NTP configuration, of course).
// Right now it is a tuple of server start time and incrementing version of config.
// Example: [1.636709231e+09 4]
func (s ServerStatsStreamerImpl) ConfigVersion() []int {
	return s.ConfigVersionValue
}

// Current runtime version of config. We do not declare exact structure, but we promise
// that it will be always comparable and increasing (if server has proper NTP configuration, of course).
// Right now it is a tuple of server start time and incrementing version of config.
// Example: [1.636709231e+09 4]
func (s *ServerStatsStreamerImpl) SetConfigVersion(v []int) ServerStatsStreamer {
	if s == nil {
		return nil
	}
	s.ConfigVersionValue = v
	return s
}

// CPU usage on the server.
// Format: percent (percent)
// Example: 48
func (s ServerStatsStreamerImpl) CpuUsage() *Percent {
	return s.CpuUsageValue
}

// CPU usage on the server.
// Format: percent (percent)
// Example: 48
func (s *ServerStatsStreamerImpl) SetCpuUsage(v Percent) ServerStatsStreamer {
	if s == nil {
		return nil
	}
	s.CpuUsageValue = &v
	return s
}

// Hostname of your server. Please, use FQDN, do not leave your Linux misconfigured.
// Example: openapi.flussonic.com
func (s ServerStatsStreamerImpl) Hostname() *string {
	return s.HostnameValue
}

// Hostname of your server. Please, use FQDN, do not leave your Linux misconfigured.
// Example: openapi.flussonic.com
func (s *ServerStatsStreamerImpl) SetHostname(v string) ServerStatsStreamer {
	if s == nil {
		return nil
	}
	s.HostnameValue = &v
	return s
}

// Unique runtime ID of this instance. Updated with the restart.
// Format: uuid (uuid)
// Example: 61893b15-75b2-4fcb-b4cf-ae1dd0858ea2
func (s ServerStatsStreamerImpl) ID() *UUID {
	return s.IDValue
}

// Unique runtime ID of this instance. Updated with the restart.
// Format: uuid (uuid)
// Example: 61893b15-75b2-4fcb-b4cf-ae1dd0858ea2
func (s *ServerStatsStreamerImpl) SetID(v UUID) ServerStatsStreamer {
	if s == nil {
		return nil
	}
	s.IDValue = &v
	return s
}

// The flag shows if Flussonic runs on Flussonic Coder.
func (s ServerStatsStreamerImpl) IsChassis() *bool {
	return s.IsChassisValue
}

// The flag shows if Flussonic runs on Flussonic Coder.
func (s *ServerStatsStreamerImpl) SetIsChassis(v bool) ServerStatsStreamer {
	if s == nil {
		return nil
	}
	s.IsChassisValue = &v
	return s
}

// The code of the license applied on the server.
// Example: uO8v12HJhNXVj5gM
func (s ServerStatsStreamerImpl) LicenseTxt() *string {
	return s.LicenseTxtValue
}

// The code of the license applied on the server.
// Example: uO8v12HJhNXVj5gM
func (s *ServerStatsStreamerImpl) SetLicenseTxt(v string) ServerStatsStreamer {
	if s == nil {
		return nil
	}
	s.LicenseTxtValue = &v
	return s
}

// The license type.
func (s ServerStatsStreamerImpl) LicenseType() *LicenseType {
	return s.LicenseTypeValue
}

// The license type.
func (s *ServerStatsStreamerImpl) SetLicenseType(v LicenseType) ServerStatsStreamer {
	if s == nil {
		return nil
	}
	s.LicenseTypeValue = &v
	return s
}

// Memory usage on the server.
// Format: percent (percent)
// Example: 27
func (s ServerStatsStreamerImpl) MemoryUsage() *Percent {
	return s.MemoryUsageValue
}

// Memory usage on the server.
// Format: percent (percent)
// Example: 27
func (s *ServerStatsStreamerImpl) SetMemoryUsage(v Percent) ServerStatsStreamer {
	if s == nil {
		return nil
	}
	s.MemoryUsageValue = &v
	return s
}

// Notification about a newer version in the repository.
// Format: server_version (server_version)
// Example: 22.01
func (s ServerStatsStreamerImpl) NextVersion() *ServerVersion {
	return s.NextVersionValue
}

// Notification about a newer version in the repository.
// Format: server_version (server_version)
// Example: 22.01
func (s *ServerStatsStreamerImpl) SetNextVersion(v ServerVersion) ServerStatsStreamer {
	if s == nil {
		return nil
	}
	s.NextVersionValue = &v
	return s
}

// The list of disk partitions on the server.
func (s ServerStatsStreamerImpl) Partitions() []PartitionStats {
	if s.PartitionsValue == nil {
		return nil
	}
	result := make([]PartitionStats, len(s.PartitionsValue))
	for i, item := range s.PartitionsValue {
		result[i] = item
	}
	return result
}

// The list of disk partitions on the server.
func (s *ServerStatsStreamerImpl) SetPartitions(v []PartitionStats) ServerStatsStreamer {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*PartitionStatsImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*PartitionStatsImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.PartitionsValue = impl
	}
	return s
}

// Shows if rproxy is configured.
func (s ServerStatsStreamerImpl) Rproxy() *bool {
	return s.RproxyValue
}

// Shows if rproxy is configured.
func (s *ServerStatsStreamerImpl) SetRproxy(v bool) ServerStatsStreamer {
	if s == nil {
		return nil
	}
	s.RproxyValue = &v
	return s
}

// Shows if rproxy is running.
func (s ServerStatsStreamerImpl) RproxyRunning() *bool {
	return s.RproxyRunningValue
}

// Shows if rproxy is running.
func (s *ServerStatsStreamerImpl) SetRproxyRunning(v bool) ServerStatsStreamer {
	if s == nil {
		return nil
	}
	s.RproxyRunningValue = &v
	return s
}

// Erlang scheduler load.
// Format: percent (percent)
// Example: 40
func (s ServerStatsStreamerImpl) SchedulerLoad() *Percent {
	return s.SchedulerLoadValue
}

// Erlang scheduler load.
// Format: percent (percent)
// Example: 40
func (s *ServerStatsStreamerImpl) SetSchedulerLoad(v Percent) ServerStatsStreamer {
	if s == nil {
		return nil
	}
	s.SchedulerLoadValue = &v
	return s
}

// *Flussonic* will always try to start even if there are severe errors that do not
// allow functioning.
// `starting` status means you should wait for some time (not more than
// a minute).
// `running` status means all configuration was loaded. However, the status does not provide
// an information about your streams and the quality of provided service.
// All other statuses mean there are some severe problems on the server
// that cannot be repaired by Flussonic itself.
func (s ServerStatsStreamerImpl) StreamerStatus() *ServerStatsStreamerStatus {
	return s.StreamerStatusValue
}

// *Flussonic* will always try to start even if there are severe errors that do not
// allow functioning.
// `starting` status means you should wait for some time (not more than
// a minute).
// `running` status means all configuration was loaded. However, the status does not provide
// an information about your streams and the quality of provided service.
// All other statuses mean there are some severe problems on the server
// that cannot be repaired by Flussonic itself.
func (s *ServerStatsStreamerImpl) SetStreamerStatus(v ServerStatsStreamerStatus) ServerStatsStreamer {
	if s == nil {
		return nil
	}
	s.StreamerStatusValue = &v
	return s
}

// Human-readable format of errors and alerts that need to be fixed.
// Provided by some *Flussonic* subsystems.
func (s ServerStatsStreamerImpl) TextAlerts() map[string]string {
	return s.TextAlertsValue
}

// Human-readable format of errors and alerts that need to be fixed.
// Provided by some *Flussonic* subsystems.
func (s *ServerStatsStreamerImpl) SetTextAlerts(v map[string]string) ServerStatsStreamer {
	if s == nil {
		return nil
	}
	s.TextAlertsValue = v
	return s
}

// Deprecated field. Will be deleted at 22.03
// Total server bandwidth.
// Format: speed (speed)
func (s ServerStatsStreamerImpl) TotalBandwidth() *Speed {
	return s.TotalBandwidthValue
}

// Deprecated field. Will be deleted at 22.03
// Total server bandwidth.
// Format: speed (speed)
func (s *ServerStatsStreamerImpl) SetTotalBandwidth(v Speed) ServerStatsStreamer {
	if s == nil {
		return nil
	}
	s.TotalBandwidthValue = &v
	return s
}

// Shows if the server's CPU can be used for transcoding
// (i.e. if the `flussonic-transcoder` package is installed on the server).
func (s ServerStatsStreamerImpl) Transcoder() *bool {
	return s.TranscoderValue
}

// Shows if the server's CPU can be used for transcoding
// (i.e. if the `flussonic-transcoder` package is installed on the server).
func (s *ServerStatsStreamerImpl) SetTranscoder(v bool) ServerStatsStreamer {
	if s == nil {
		return nil
	}
	s.TranscoderValue = &v
	return s
}

// Statistics on the devices used for transcoding.
func (s ServerStatsStreamerImpl) TranscoderDevices() []TranscoderDeviceStats {
	if s.TranscoderDevicesValue == nil {
		return nil
	}
	result := make([]TranscoderDeviceStats, len(s.TranscoderDevicesValue))
	for i, item := range s.TranscoderDevicesValue {
		result[i] = item
	}
	return result
}

// Statistics on the devices used for transcoding.
func (s *ServerStatsStreamerImpl) SetTranscoderDevices(v []TranscoderDeviceStats) ServerStatsStreamer {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*TranscoderDeviceStatsImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*TranscoderDeviceStatsImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.TranscoderDevicesValue = impl
	}
	return s
}

// The server uptime.
// Format: seconds (seconds)
// Example: 4.325502e+06
func (s ServerStatsStreamerImpl) Uptime() *Seconds {
	return s.UptimeValue
}

// The server uptime.
// Format: seconds (seconds)
// Example: 4.325502e+06
func (s *ServerStatsStreamerImpl) SetUptime(v Seconds) ServerStatsStreamer {
	if s == nil {
		return nil
	}
	s.UptimeValue = &v
	return s
}

// Shows if Flussonic Watcher is enabled in the license.
func (s ServerStatsStreamerImpl) Vsaas() *bool {
	return s.VsaasValue
}

// Shows if Flussonic Watcher is enabled in the license.
func (s *ServerStatsStreamerImpl) SetVsaas(v bool) ServerStatsStreamer {
	if s == nil {
		return nil
	}
	s.VsaasValue = &v
	return s
}

// Shows if Watcher branding is enabled in the license.
func (s ServerStatsStreamerImpl) VsaasBranding() *bool {
	return s.VsaasBrandingValue
}

// Shows if Watcher branding is enabled in the license.
func (s *ServerStatsStreamerImpl) SetVsaasBranding(v bool) ServerStatsStreamer {
	if s == nil {
		return nil
	}
	s.VsaasBrandingValue = &v
	return s
}

// Shows if Watcher is currently running.
func (s ServerStatsStreamerImpl) VsaasRunning() *bool {
	return s.VsaasRunningValue
}

// Shows if Watcher is currently running.
func (s *ServerStatsStreamerImpl) SetVsaasRunning(v bool) ServerStatsStreamer {
	if s == nil {
		return nil
	}
	s.VsaasRunningValue = &v
	return s
}

// NewServerStatsWhoami creates a new ServerStatsWhoami instance
func NewServerStatsWhoami() ServerStatsWhoami {
	return &ServerStatsWhoamiImpl{}
}

// Build version
func (s ServerStatsWhoamiImpl) Build() *int {
	return s.BuildValue
}

// Build version
func (s *ServerStatsWhoamiImpl) SetBuild(v int) ServerStatsWhoami {
	if s == nil {
		return nil
	}
	s.BuildValue = &v
	return s
}

// Current response time
// Format: utc_ms (Unix timestamp in milliseconds)
func (s ServerStatsWhoamiImpl) Now() *UtcMs {
	return s.NowValue
}

// Current response time
// Format: utc_ms (Unix timestamp in milliseconds)
func (s *ServerStatsWhoamiImpl) SetNow(v UtcMs) ServerStatsWhoami {
	if s == nil {
		return nil
	}
	s.NowValue = &v
	return s
}

// Package version of the server. Might be simple a number of release like 21.11 or longer if you have a rolling release installed.
// Format: server_version (server_version)
// Example: 23.04
func (s ServerStatsWhoamiImpl) ServerVersion() *ServerVersion {
	return s.ServerVersionValue
}

// Package version of the server. Might be simple a number of release like 21.11 or longer if you have a rolling release installed.
// Format: server_version (server_version)
// Example: 23.04
func (s *ServerStatsWhoamiImpl) SetServerVersion(v ServerVersion) ServerStatsWhoami {
	if s == nil {
		return nil
	}
	s.ServerVersionValue = &v
	return s
}

// Boot time of this instance.
// Format: utc (Unix timestamp in seconds)
// Example: 1.639337825e+09
func (s ServerStatsWhoamiImpl) StartedAt() *Utc {
	return s.StartedAtValue
}

// Boot time of this instance.
// Format: utc (Unix timestamp in seconds)
// Example: 1.639337825e+09
func (s *ServerStatsWhoamiImpl) SetStartedAt(v Utc) ServerStatsWhoami {
	if s == nil {
		return nil
	}
	s.StartedAtValue = &v
	return s
}

// NewSrtConfig creates a new SrtConfig instance
func NewSrtConfig() SrtConfig {
	return &SrtConfigImpl{}
}

// Whether both connection parties must have the same password set (including empty, in other words, with no encryption).
// If the passwords do not match or only one side is unencrypted, the connection is rejected.
// The default value is `true`.
// Example: true
func (s SrtConfigImpl) Enforcedencryption() *bool {
	return s.EnforcedencryptionValue
}

// Whether both connection parties must have the same password set (including empty, in other words, with no encryption).
// If the passwords do not match or only one side is unencrypted, the connection is rejected.
// The default value is `true`.
// Example: true
func (s *SrtConfigImpl) SetEnforcedencryption(v bool) SrtConfig {
	if s == nil {
		return nil
	}
	s.EnforcedencryptionValue = &v
	return s
}

// The latency value for both directions of the socket.
// By default initial value latency is 0 when transmitting and 120ms when receiving video.
// Actual value established after connection handshake.
// Increased value helps tolerate network losses and delays.
// Format: milliseconds (milliseconds)
// Example: 150
func (s SrtConfigImpl) Latency() *Milliseconds {
	return s.LatencyValue
}

// The latency value for both directions of the socket.
// By default initial value latency is 0 when transmitting and 120ms when receiving video.
// Actual value established after connection handshake.
// Increased value helps tolerate network losses and delays.
// Format: milliseconds (milliseconds)
// Example: 150
func (s *SrtConfigImpl) SetLatency(v Milliseconds) SrtConfig {
	if s == nil {
		return nil
	}
	s.LatencyValue = &v
	return s
}

// The time, in seconds, that the socket waits for the unsent data before closing.
// The default value is 180.
// Format: seconds (seconds)
// Example: 15
func (s SrtConfigImpl) Linger() *Seconds {
	return s.LingerValue
}

// The time, in seconds, that the socket waits for the unsent data before closing.
// The default value is 180.
// Format: seconds (seconds)
// Example: 15
func (s *SrtConfigImpl) SetLinger(v Seconds) SrtConfig {
	if s == nil {
		return nil
	}
	s.LingerValue = &v
	return s
}

// The minimum SRT version that is required from the peer for SRT publication.
// Pattern: ^[0-9]+\.[0-9]+\.[0-9]+$
// Example: 1.1.0
func (s SrtConfigImpl) Minversion() *string {
	return s.MinversionValue
}

// The minimum SRT version that is required from the peer for SRT publication.
// Pattern: ^[0-9]+\.[0-9]+\.[0-9]+$
// Example: 1.1.0
func (s *SrtConfigImpl) SetMinversion(v string) SrtConfig {
	if s == nil {
		return nil
	}
	s.MinversionValue = &v
	return s
}

// The password for the encrypted transmission.
// Its length should be not less than 10 and not more than 79 characters.
// Unlike [password](https://flussonic.com/doc/api/reference/#tag/stream/operation/stream_save%7Cbody%7Cpassword),
// the passphrase is not transmitted openly but is used to encrypt the key that is transmitted by the Caller
// and decoded by Listener.
// Example: 9876543210
func (s SrtConfigImpl) Passphrase() *string {
	return s.PassphraseValue
}

// The password for the encrypted transmission.
// Its length should be not less than 10 and not more than 79 characters.
// Unlike [password](https://flussonic.com/doc/api/reference/#tag/stream/operation/stream_save%7Cbody%7Cpassword),
// the passphrase is not transmitted openly but is used to encrypt the key that is transmitted by the Caller
// and decoded by Listener.
// Example: 9876543210
func (s *SrtConfigImpl) SetPassphrase(v string) SrtConfig {
	if s == nil {
		return nil
	}
	s.PassphraseValue = &v
	return s
}

// Listening port or a `host:port` pair for the SRT configuration.
// Must be unique on the whole server.
// Example: 9050
func (s SrtConfigImpl) Port() *ListenSpec {
	return s.PortValue
}

// Listening port or a `host:port` pair for the SRT configuration.
// Must be unique on the whole server.
// Example: 9050
func (s *SrtConfigImpl) SetPort(v *ListenSpec) SrtConfig {
	if s == nil {
		return nil
	}
	s.PortValue = v
	return s
}

// A string of maximum 512 characters set on the socket before the connection.
// This string is a part of a callback that is sent by the caller and regisered by the listener.
// Based on this information the listener can accept or reject the connection, select the desired data stream, or set an appropriate passphrase for the connection.
// Its format is `#!::` optionally followed by the parameters:
// * `r=` - stream name
// * `m=` - mode expected for the connection: `publish` (if the caller wants to send the stream data) or `request` (if the caller wants to receive the stream).
// * `password=` - a password for the authorization in a publish session (not recommended, better use `passphrase` option instead)
// During SRT sessions the following parameters are automaticly added to streamid:
// * `s=` - the identifier of a session
// * `a=` - Flussonic version
// NOTE: you can specify a string in the format you need; to disable this extension, you need specify empty string.
// Example: #!::r=my-stream,m=publish
func (s SrtConfigImpl) Streamid() *string {
	return s.StreamidValue
}

// A string of maximum 512 characters set on the socket before the connection.
// This string is a part of a callback that is sent by the caller and regisered by the listener.
// Based on this information the listener can accept or reject the connection, select the desired data stream, or set an appropriate passphrase for the connection.
// Its format is `#!::` optionally followed by the parameters:
// * `r=` - stream name
// * `m=` - mode expected for the connection: `publish` (if the caller wants to send the stream data) or `request` (if the caller wants to receive the stream).
// * `password=` - a password for the authorization in a publish session (not recommended, better use `passphrase` option instead)
// During SRT sessions the following parameters are automaticly added to streamid:
// * `s=` - the identifier of a session
// * `a=` - Flussonic version
// NOTE: you can specify a string in the format you need; to disable this extension, you need specify empty string.
// Example: #!::r=my-stream,m=publish
func (s *SrtConfigImpl) SetStreamid(v string) SrtConfig {
	if s == nil {
		return nil
	}
	s.StreamidValue = &v
	return s
}

// Data transmission timeout in seconds.
// If set to `false` then data transmission time is unlimited. This is a defalut behavior.
// Example: 10
func (s SrtConfigImpl) Timeout() any {
	return s.TimeoutValue
}

// Data transmission timeout in seconds.
// If set to `false` then data transmission time is unlimited. This is a defalut behavior.
// Example: 10
func (s *SrtConfigImpl) SetTimeout(v any) SrtConfig {
	if s == nil {
		return nil
	}
	s.TimeoutValue = v
	return s
}

// Required SRT version.
// Pattern: ^[0-9]+\.[0-9]+\.[0-9]+$
// Example: 1.3.0
func (s SrtConfigImpl) Version() *string {
	return s.VersionValue
}

// Required SRT version.
// Pattern: ^[0-9]+\.[0-9]+\.[0-9]+$
// Example: 1.3.0
func (s *SrtConfigImpl) SetVersion(v string) SrtConfig {
	if s == nil {
		return nil
	}
	s.VersionValue = &v
	return s
}

// NewSrtConfigBase creates a new SrtConfigBase instance
func NewSrtConfigBase() SrtConfigBase {
	return &SrtConfigBaseImpl{}
}

// Whether both connection parties must have the same password set (including empty, in other words, with no encryption).
// If the passwords do not match or only one side is unencrypted, the connection is rejected.
// The default value is `true`.
// Example: true
func (s SrtConfigBaseImpl) Enforcedencryption() *bool {
	return s.EnforcedencryptionValue
}

// Whether both connection parties must have the same password set (including empty, in other words, with no encryption).
// If the passwords do not match or only one side is unencrypted, the connection is rejected.
// The default value is `true`.
// Example: true
func (s *SrtConfigBaseImpl) SetEnforcedencryption(v bool) SrtConfigBase {
	if s == nil {
		return nil
	}
	s.EnforcedencryptionValue = &v
	return s
}

// The latency value for both directions of the socket.
// By default initial value latency is 0 when transmitting and 120ms when receiving video.
// Actual value established after connection handshake.
// Increased value helps tolerate network losses and delays.
// Format: milliseconds (milliseconds)
// Example: 150
func (s SrtConfigBaseImpl) Latency() *Milliseconds {
	return s.LatencyValue
}

// The latency value for both directions of the socket.
// By default initial value latency is 0 when transmitting and 120ms when receiving video.
// Actual value established after connection handshake.
// Increased value helps tolerate network losses and delays.
// Format: milliseconds (milliseconds)
// Example: 150
func (s *SrtConfigBaseImpl) SetLatency(v Milliseconds) SrtConfigBase {
	if s == nil {
		return nil
	}
	s.LatencyValue = &v
	return s
}

// The time, in seconds, that the socket waits for the unsent data before closing.
// The default value is 180.
// Format: seconds (seconds)
// Example: 15
func (s SrtConfigBaseImpl) Linger() *Seconds {
	return s.LingerValue
}

// The time, in seconds, that the socket waits for the unsent data before closing.
// The default value is 180.
// Format: seconds (seconds)
// Example: 15
func (s *SrtConfigBaseImpl) SetLinger(v Seconds) SrtConfigBase {
	if s == nil {
		return nil
	}
	s.LingerValue = &v
	return s
}

// The minimum SRT version that is required from the peer for SRT publication.
// Pattern: ^[0-9]+\.[0-9]+\.[0-9]+$
// Example: 1.1.0
func (s SrtConfigBaseImpl) Minversion() *string {
	return s.MinversionValue
}

// The minimum SRT version that is required from the peer for SRT publication.
// Pattern: ^[0-9]+\.[0-9]+\.[0-9]+$
// Example: 1.1.0
func (s *SrtConfigBaseImpl) SetMinversion(v string) SrtConfigBase {
	if s == nil {
		return nil
	}
	s.MinversionValue = &v
	return s
}

// The password for the encrypted transmission.
// Its length should be not less than 10 and not more than 79 characters.
// Unlike [password](https://flussonic.com/doc/api/reference/#tag/stream/operation/stream_save%7Cbody%7Cpassword),
// the passphrase is not transmitted openly but is used to encrypt the key that is transmitted by the Caller
// and decoded by Listener.
// Example: 9876543210
func (s SrtConfigBaseImpl) Passphrase() *string {
	return s.PassphraseValue
}

// The password for the encrypted transmission.
// Its length should be not less than 10 and not more than 79 characters.
// Unlike [password](https://flussonic.com/doc/api/reference/#tag/stream/operation/stream_save%7Cbody%7Cpassword),
// the passphrase is not transmitted openly but is used to encrypt the key that is transmitted by the Caller
// and decoded by Listener.
// Example: 9876543210
func (s *SrtConfigBaseImpl) SetPassphrase(v string) SrtConfigBase {
	if s == nil {
		return nil
	}
	s.PassphraseValue = &v
	return s
}

// A string of maximum 512 characters set on the socket before the connection.
// This string is a part of a callback that is sent by the caller and regisered by the listener.
// Based on this information the listener can accept or reject the connection, select the desired data stream, or set an appropriate passphrase for the connection.
// Its format is `#!::` optionally followed by the parameters:
// * `r=` - stream name
// * `m=` - mode expected for the connection: `publish` (if the caller wants to send the stream data) or `request` (if the caller wants to receive the stream).
// * `password=` - a password for the authorization in a publish session (not recommended, better use `passphrase` option instead)
// During SRT sessions the following parameters are automaticly added to streamid:
// * `s=` - the identifier of a session
// * `a=` - Flussonic version
// NOTE: you can specify a string in the format you need; to disable this extension, you need specify empty string.
// Example: #!::r=my-stream,m=publish
func (s SrtConfigBaseImpl) Streamid() *string {
	return s.StreamidValue
}

// A string of maximum 512 characters set on the socket before the connection.
// This string is a part of a callback that is sent by the caller and regisered by the listener.
// Based on this information the listener can accept or reject the connection, select the desired data stream, or set an appropriate passphrase for the connection.
// Its format is `#!::` optionally followed by the parameters:
// * `r=` - stream name
// * `m=` - mode expected for the connection: `publish` (if the caller wants to send the stream data) or `request` (if the caller wants to receive the stream).
// * `password=` - a password for the authorization in a publish session (not recommended, better use `passphrase` option instead)
// During SRT sessions the following parameters are automaticly added to streamid:
// * `s=` - the identifier of a session
// * `a=` - Flussonic version
// NOTE: you can specify a string in the format you need; to disable this extension, you need specify empty string.
// Example: #!::r=my-stream,m=publish
func (s *SrtConfigBaseImpl) SetStreamid(v string) SrtConfigBase {
	if s == nil {
		return nil
	}
	s.StreamidValue = &v
	return s
}

// Required SRT version.
// Pattern: ^[0-9]+\.[0-9]+\.[0-9]+$
// Example: 1.3.0
func (s SrtConfigBaseImpl) Version() *string {
	return s.VersionValue
}

// Required SRT version.
// Pattern: ^[0-9]+\.[0-9]+\.[0-9]+$
// Example: 1.3.0
func (s *SrtConfigBaseImpl) SetVersion(v string) SrtConfigBase {
	if s == nil {
		return nil
	}
	s.VersionValue = &v
	return s
}

// NewStreamConfig creates a new StreamConfig instance
func NewStreamConfig() StreamConfig {
	return &StreamConfigImpl{}
}

// Whether to add an audio-only version of an HLS stream.
// Used to create App Store compliant HLS streams to deliver the content to Apple iOS devices.
// Example: true
func (s StreamConfigImpl) AddAudioOnly() *bool {
	return s.AddAudioOnlyValue
}

// Whether to add an audio-only version of an HLS stream.
// Used to create App Store compliant HLS streams to deliver the content to Apple iOS devices.
// Example: true
func (s *StreamConfigImpl) SetAddAudioOnly(v bool) StreamConfig {
	if s == nil {
		return nil
	}
	s.AddAudioOnlyValue = &v
	return s
}

// If a connected source does not send audio data within this timeout period (in seconds),
// the source connection is considered to be lost.
// This is a default configuration for a stream, can be modified for any input.
// Format: seconds (seconds)
// Example: 20
func (s StreamConfigImpl) AudioTimeout() *Seconds {
	return s.AudioTimeoutValue
}

// If a connected source does not send audio data within this timeout period (in seconds),
// the source connection is considered to be lost.
// This is a default configuration for a stream, can be modified for any input.
// Format: seconds (seconds)
// Example: 20
func (s *StreamConfigImpl) SetAudioTimeout(v Seconds) StreamConfig {
	if s == nil {
		return nil
	}
	s.AudioTimeoutValue = &v
	return s
}

// When all inputs are down, this can be used to show at least something to users.
// It is important to understand that backup video behaves differently, not as inputs.
// It is not a _last input_ in the list. After any input stops sending frames, timer starts.
// After `source_timeout` seconds backup starts working, while all other inputs are still trying to
// connect and start working.
// So backup and all inputs are working in parallel.
func (s StreamConfigImpl) Backup() BackupConfig {
	return s.BackupValue
}

// When all inputs are down, this can be used to show at least something to users.
// It is important to understand that backup video behaves differently, not as inputs.
// It is not a _last input_ in the list. After any input stops sending frames, timer starts.
// After `source_timeout` seconds backup starts working, while all other inputs are still trying to
// connect and start working.
// So backup and all inputs are working in parallel.
func (s *StreamConfigImpl) SetBackup(v BackupConfig) StreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*BackupConfigImpl); ok {
		s.BackupValue = impl
	}
	return s
}

// Chunk duration in LL-HLS manifest to be used for tunning latency.
// Format: milliseconds (milliseconds)
// Example: 200
func (s StreamConfigImpl) ChunkDuration() *Milliseconds {
	return s.ChunkDurationValue
}

// Chunk duration in LL-HLS manifest to be used for tunning latency.
// Format: milliseconds (milliseconds)
// Example: 200
func (s *StreamConfigImpl) SetChunkDuration(v Milliseconds) StreamConfig {
	if s == nil {
		return nil
	}
	s.ChunkDurationValue = &v
	return s
}

// Stream's lifetime after the last client was disconnected (can be expressed in *seconds* or set to `False`).
// Applicable to on-demand streams **only**.
// Example: 485
func (s StreamConfigImpl) ClientsTimeout() any {
	return s.ClientsTimeoutValue
}

// Stream's lifetime after the last client was disconnected (can be expressed in *seconds* or set to `False`).
// Applicable to on-demand streams **only**.
// Example: 485
func (s *StreamConfigImpl) SetClientsTimeout(v any) StreamConfig {
	if s == nil {
		return nil
	}
	s.ClientsTimeoutValue = v
	return s
}

// Human-readable description of the stream.
// Example: This is a test stream
func (s StreamConfigImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the stream.
// Example: This is a test stream
func (s *StreamConfigImpl) SetComment(v string) StreamConfig {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Part of the effective config from the configuration file.
func (s StreamConfigImpl) ConfigOnDisk() StreamConfigStripped {
	return s.ConfigOnDiskValue
}

// Part of the effective config from the configuration file.
func (s *StreamConfigImpl) SetConfigOnDisk(v StreamConfigStripped) StreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*StreamConfigStrippedImpl); ok {
		s.ConfigOnDiskValue = impl
	}
	return s
}

// Whether a stream is disabled. Disabled streams are inactive and do not run.
// Displayed only with the API calls.
// Example: false
func (s StreamConfigImpl) Disabled() *bool {
	return s.DisabledValue
}

// Whether a stream is disabled. Disabled streams are inactive and do not run.
// Displayed only with the API calls.
// Example: false
func (s *StreamConfigImpl) SetDisabled(v bool) StreamConfig {
	if s == nil {
		return nil
	}
	s.DisabledValue = &v
	return s
}

// Configuraton of Digital Rights Management system (DRM).
func (s StreamConfigImpl) Drm() DrmSpec {
	return s.DrmValue
}

// Configuraton of Digital Rights Management system (DRM).
func (s *StreamConfigImpl) SetDrm(v DrmSpec) StreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*DrmSpecImpl); ok {
		s.DrmValue = impl
	}
	return s
}

// This parameter allows to manage subtitles in an output stream.
// Example: replace
func (s StreamConfigImpl) Dvbocr() *StreamConfigInputDvbocr {
	return s.DvbocrValue
}

// This parameter allows to manage subtitles in an output stream.
// Example: replace
func (s *StreamConfigImpl) SetDvbocr(v StreamConfigInputDvbocr) StreamConfig {
	if s == nil {
		return nil
	}
	s.DvbocrValue = &v
	return s
}

// DVR configuraton.
func (s StreamConfigImpl) Dvr() StreamDvrSpec {
	return s.DvrValue
}

// DVR configuraton.
func (s *StreamConfigImpl) SetDvr(v StreamDvrSpec) StreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*StreamDvrSpecImpl); ok {
		s.DvrValue = impl
	}
	return s
}

// Whether to extract EPG from the input.
// Example: true
func (s StreamConfigImpl) EpgEnabled() *bool {
	return s.EpgEnabledValue
}

// Whether to extract EPG from the input.
// Example: true
func (s *StreamConfigImpl) SetEpgEnabled(v bool) StreamConfig {
	if s == nil {
		return nil
	}
	s.EpgEnabledValue = &v
	return s
}

// Whether to enable SCTE-35 ad insertion markers signaling in HLS manifest.
// Ad markers can be included in SCTE-35 (`scte35`), AWS (`aws`), EXT-X-DATERANGE (`rfc8216`) formats or not included (`false`).
// Example: scte35
func (s StreamConfigImpl) HlsScte35() *StreamConfigMediaHlsScte35 {
	return s.HlsScte35Value
}

// Whether to enable SCTE-35 ad insertion markers signaling in HLS manifest.
// Ad markers can be included in SCTE-35 (`scte35`), AWS (`aws`), EXT-X-DATERANGE (`rfc8216`) formats or not included (`false`).
// Example: scte35
func (s *StreamConfigImpl) SetHlsScte35(v StreamConfigMediaHlsScte35) StreamConfig {
	if s == nil {
		return nil
	}
	s.HlsScte35Value = &v
	return s
}

// Use this option for fine-grained control over each input track.
// You can select, rename, change name and title for each video, audio track.
func (s StreamConfigImpl) InputMediaInfo() InputMediaInfo {
	return s.InputMediaInfoValue
}

// Use this option for fine-grained control over each input track.
// You can select, rename, change name and title for each video, audio track.
func (s *StreamConfigImpl) SetInputMediaInfo(v InputMediaInfo) StreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputMediaInfoImpl); ok {
		s.InputMediaInfoValue = impl
	}
	return s
}

// List of stream inputs.
// ***Important:*** A stream without any inputs can receive video frames **only** if backup file is specified.
func (s StreamConfigImpl) Inputs() []StreamInput {
	if s.InputsValue == nil {
		return nil
	}
	result := make([]StreamInput, len(s.InputsValue))
	for i, item := range s.InputsValue {
		result[i] = item
	}
	return result
}

// List of stream inputs.
// ***Important:*** A stream without any inputs can receive video frames **only** if backup file is specified.
func (s *StreamConfigImpl) SetInputs(v []StreamInput) StreamConfig {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*StreamInputImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*StreamInputImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.InputsValue = impl
	}
	return s
}

// A key to sign jpeg_snapshot requests
func (s StreamConfigImpl) JpegSnapshotSignKey() *string {
	return s.JpegSnapshotSignKeyValue
}

// A key to sign jpeg_snapshot requests
func (s *StreamConfigImpl) SetJpegSnapshotSignKey(v string) StreamConfig {
	if s == nil {
		return nil
	}
	s.JpegSnapshotSignKeyValue = &v
	return s
}

// Stream labels in key value format.
// Key is a string in unix_name format (alphanumeric characters, underscores, hyphens and periods).
// See [Layouter schema](https://flussonic.com/doc/api/layouter/#tag/stream/operation/streams_list/response%7Cstreams%7Clabels)
// for more details.
func (s StreamConfigImpl) Labels() map[string]UnixName {
	return s.LabelsValue
}

// Stream labels in key value format.
// Key is a string in unix_name format (alphanumeric characters, underscores, hyphens and periods).
// See [Layouter schema](https://flussonic.com/doc/api/layouter/#tag/stream/operation/streams_list/response%7Cstreams%7Clabels)
// for more details.
func (s *StreamConfigImpl) SetLabels(v map[string]UnixName) StreamConfig {
	if s == nil {
		return nil
	}
	s.LabelsValue = v
	return s
}

// The maximum time that Media Server will set for attempts to reconnect to sources when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s StreamConfigImpl) MaxRetryTimeout() *Seconds {
	return s.MaxRetryTimeoutValue
}

// The maximum time that Media Server will set for attempts to reconnect to sources when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s *StreamConfigImpl) SetMaxRetryTimeout(v Seconds) StreamConfig {
	if s == nil {
		return nil
	}
	s.MaxRetryTimeoutValue = &v
	return s
}

// Deprecated field. Will be deleted at 23.12
// The param is deprecated and now used only for onvif_url and onvif_profile options.
func (s StreamConfigImpl) Meta() map[string]string {
	return s.MetaValue
}

// Deprecated field. Will be deleted at 23.12
// The param is deprecated and now used only for onvif_url and onvif_profile options.
func (s *StreamConfigImpl) SetMeta(v map[string]string) StreamConfig {
	if s == nil {
		return nil
	}
	s.MetaValue = v
	return s
}

// It allows to specify pack information about ac3 for outgoing MPEGTS-TS streams. The default value is `system_b`.
func (s StreamConfigImpl) MpegtsAc3() *OutputMpegtsAc3 {
	return s.MpegtsAc3Value
}

// It allows to specify pack information about ac3 for outgoing MPEGTS-TS streams. The default value is `system_b`.
func (s *StreamConfigImpl) SetMpegtsAc3(v OutputMpegtsAc3) StreamConfig {
	if s == nil {
		return nil
	}
	s.MpegtsAc3Value = &v
	return s
}

// This parameter sets PIDs values for outgoing MPEG-TS streams. PID contains information about the TS package content and can be decoded according to special service tables.
// It is possible to set PID values for PMT, SDT, video, and audio tracks. Tracks are numbered starting from one.
// The code `a1=123` sets a PID value for the first audio track. It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, `t0=100` sets PID=101 for the first track, 102 for the second, and so on. Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s StreamConfigImpl) MpegtsPids() OutputMpegtsPids {
	return s.MpegtsPidsValue
}

// This parameter sets PIDs values for outgoing MPEG-TS streams. PID contains information about the TS package content and can be decoded according to special service tables.
// It is possible to set PID values for PMT, SDT, video, and audio tracks. Tracks are numbered starting from one.
// The code `a1=123` sets a PID value for the first audio track. It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, `t0=100` sets PID=101 for the first track, 102 for the second, and so on. Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s *StreamConfigImpl) SetMpegtsPids(v OutputMpegtsPids) StreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*OutputMpegtsPidsImpl); ok {
		s.MpegtsPidsValue = impl
	}
	return s
}

// Globally unique stream name.
// Note that the name could not be changed after the stream is created.
// Format: media_name (media_name)
// Examples: Decklink-Stream, Dektec-Stream, hockey1, mylive/bunny, test_stream
func (s StreamConfigImpl) Name() MediaName {
	return s.NameValue
}

// Globally unique stream name.
// Note that the name could not be changed after the stream is created.
// Format: media_name (media_name)
// Examples: Decklink-Stream, Dektec-Stream, hockey1, mylive/bunny, test_stream
func (s *StreamConfigImpl) SetName(v MediaName) StreamConfig {
	if s == nil {
		return nil
	}
	s.NameValue = v
	return s
}

// Where the stream is initialized: config, user play/publication, or remote
// cluster server.
// Example: config
func (s StreamConfigImpl) NamedBy() *NamedBy {
	return s.NamedByValue
}

// Where the stream is initialized: config, user play/publication, or remote
// cluster server.
// Example: config
func (s *StreamConfigImpl) SetNamedBy(v NamedBy) StreamConfig {
	if s == nil {
		return nil
	}
	s.NamedByValue = &v
	return s
}

// Configuration of authorization backend for play sessions.
func (s StreamConfigImpl) OnPlay() AuthSpec {
	return s.OnPlayValue
}

// Configuration of authorization backend for play sessions.
func (s *StreamConfigImpl) SetOnPlay(v AuthSpec) StreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*AuthSpecImpl); ok {
		s.OnPlayValue = impl
	}
	return s
}

// Configuration of authorization backend for publish sessions.
func (s StreamConfigImpl) OnPublish() AuthSpec {
	return s.OnPublishValue
}

// Configuration of authorization backend for publish sessions.
func (s *StreamConfigImpl) SetOnPublish(v AuthSpec) StreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*AuthSpecImpl); ok {
		s.OnPublishValue = impl
	}
	return s
}

// This parameter sets playback HTTP headers for streams.
func (s StreamConfigImpl) PlaybackHeaders() []PlaybackHeaders {
	if s.PlaybackHeadersValue == nil {
		return nil
	}
	result := make([]PlaybackHeaders, len(s.PlaybackHeadersValue))
	for i, item := range s.PlaybackHeadersValue {
		result[i] = item
	}
	return result
}

// This parameter sets playback HTTP headers for streams.
func (s *StreamConfigImpl) SetPlaybackHeaders(v []PlaybackHeaders) StreamConfig {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*PlaybackHeadersImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*PlaybackHeadersImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.PlaybackHeadersValue = impl
	}
	return s
}

// Position of the stream in order of streams in the config file, if declared.
// Format: sort_index (sort_index)
// Example: 2
func (s StreamConfigImpl) Position() *SortIndex {
	return s.PositionValue
}

// Position of the stream in order of streams in the config file, if declared.
// Format: sort_index (sort_index)
// Example: 2
func (s *StreamConfigImpl) SetPosition(v SortIndex) StreamConfig {
	if s == nil {
		return nil
	}
	s.PositionValue = &v
	return s
}

// The time (in seconds) that Media Server reserves for preloading the data, i. e. *buffering*.
// Prepush is always defined through GoP, but this option provides you with a more flexible way
// to configure the buffer size, e. g. a 1-3 or 7-10 seconds time interval.
// The bigger the buffer size, the better the user experience is for the users
// with a bad internet connection. However, the latency also increases.
// If set to `False` to remove the latency, the stream's start time
// increases. To decrease it, reduce the GoP size and make the bitrate higher
// or the video quality lower.
// Example: false
func (s StreamConfigImpl) Prepush() any {
	return s.PrepushValue
}

// The time (in seconds) that Media Server reserves for preloading the data, i. e. *buffering*.
// Prepush is always defined through GoP, but this option provides you with a more flexible way
// to configure the buffer size, e. g. a 1-3 or 7-10 seconds time interval.
// The bigger the buffer size, the better the user experience is for the users
// with a bad internet connection. However, the latency also increases.
// If set to `False` to remove the latency, the stream's start time
// increases. To decrease it, reduce the GoP size and make the bitrate higher
// or the video quality lower.
// Example: false
func (s *StreamConfigImpl) SetPrepush(v any) StreamConfig {
	if s == nil {
		return nil
	}
	s.PrepushValue = v
	return s
}

// Configuration to allow/forbid playing the stream via various protocols.
// - If the `whitelist` option is set to 'true', the server allows a playback only for listed protocols;
// - If the `whitelist` option is set to 'false', the server forbids a playback for listed protocols;
// - Server allows a playback for all the protocols by default.
func (s StreamConfigImpl) Protocols() PlayProtocolsSpec {
	return s.ProtocolsValue
}

// Configuration to allow/forbid playing the stream via various protocols.
// - If the `whitelist` option is set to 'true', the server allows a playback only for listed protocols;
// - If the `whitelist` option is set to 'false', the server forbids a playback for listed protocols;
// - Server allows a playback for all the protocols by default.
func (s *StreamConfigImpl) SetProtocols(v PlayProtocolsSpec) StreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*PlayProtocolsSpecImpl); ok {
		s.ProtocolsValue = impl
	}
	return s
}

// Deprecated field. Will be deleted at 25.03
// Human-readable name of the content provider. Used, for example, for MPEG-TS.
// Deprecated, use `input_media_info.provider` instead
// Example: SportsTV
func (s StreamConfigImpl) Provider() *string {
	return s.ProviderValue
}

// Deprecated field. Will be deleted at 25.03
// Human-readable name of the content provider. Used, for example, for MPEG-TS.
// Deprecated, use `input_media_info.provider` instead
// Example: SportsTV
func (s *StreamConfigImpl) SetProvider(v string) StreamConfig {
	if s == nil {
		return nil
	}
	s.ProviderValue = &v
	return s
}

// A list of pushes. When a server initiates the connection and sends a stream
// to other server(s), it is called a `push`.
func (s StreamConfigImpl) Pushes() []StreamPush {
	if s.PushesValue == nil {
		return nil
	}
	result := make([]StreamPush, len(s.PushesValue))
	for i, item := range s.PushesValue {
		result[i] = item
	}
	return result
}

// A list of pushes. When a server initiates the connection and sends a stream
// to other server(s), it is called a `push`.
func (s *StreamConfigImpl) SetPushes(v []StreamPush) StreamConfig {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*StreamPushImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*StreamPushImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.PushesValue = impl
	}
	return s
}

// How often to re-check secondary inputs. If this option is not set than check is never performed.
// Format: seconds (seconds)
// Example: 120
func (s StreamConfigImpl) RecheckSecondaryInputsInterval() *Seconds {
	return s.RecheckSecondaryInputsIntervalValue
}

// How often to re-check secondary inputs. If this option is not set than check is never performed.
// Format: seconds (seconds)
// Example: 120
func (s *StreamConfigImpl) SetRecheckSecondaryInputsInterval(v Seconds) StreamConfig {
	if s == nil {
		return nil
	}
	s.RecheckSecondaryInputsIntervalValue = &v
	return s
}

// Number of attempts for the server to reconnect to a data source.
// Applicable to on-demand streams **only**. If not defined, server will constantly try to reconnect (unlimited number of retries).
// If the input does not become active after specified amount of attempts, stream shuts down till the next user request.
func (s StreamConfigImpl) RetryLimit() *int {
	return s.RetryLimitValue
}

// Number of attempts for the server to reconnect to a data source.
// Applicable to on-demand streams **only**. If not defined, server will constantly try to reconnect (unlimited number of retries).
// If the input does not become active after specified amount of attempts, stream shuts down till the next user request.
func (s *StreamConfigImpl) SetRetryLimit(v int) StreamConfig {
	if s == nil {
		return nil
	}
	s.RetryLimitValue = &v
	return s
}

// Number of segments stored in memory for the segment-based protocols, such as HLS and DASH.
// Added to HLS live manifest. Do not forget that one more segment is stored for stale clients
// that come too late, but the latest segment is not shown in the manifest.
// Example: 4
func (s StreamConfigImpl) SegmentCount() *int {
	return s.SegmentCountValue
}

// Number of segments stored in memory for the segment-based protocols, such as HLS and DASH.
// Added to HLS live manifest. Do not forget that one more segment is stored for stale clients
// that come too late, but the latest segment is not shown in the manifest.
// Example: 4
func (s *StreamConfigImpl) SetSegmentCount(v int) StreamConfig {
	if s == nil {
		return nil
	}
	s.SegmentCountValue = &v
	return s
}

// The time of the segment duration. Used for the protocols like HLS or DASH.
// The disk config offers this value in seconds.
// Example: 5000
func (s StreamConfigImpl) SegmentDuration() *Milliseconds {
	return s.SegmentDurationValue
}

// The time of the segment duration. Used for the protocols like HLS or DASH.
// The disk config offers this value in seconds.
// Example: 5000
func (s *StreamConfigImpl) SetSegmentDuration(v Milliseconds) StreamConfig {
	if s == nil {
		return nil
	}
	s.SegmentDurationValue = &v
	return s
}

// If a connected source does not send any data within this timeout period (in seconds),
// the source connection is considered to be lost.
// This is a default configuration for a stream, can be modified for any input.
// Example: 10
func (s StreamConfigImpl) SourceTimeout() any {
	return s.SourceTimeoutValue
}

// If a connected source does not send any data within this timeout period (in seconds),
// the source connection is considered to be lost.
// This is a default configuration for a stream, can be modified for any input.
// Example: 10
func (s *StreamConfigImpl) SetSourceTimeout(v any) StreamConfig {
	if s == nil {
		return nil
	}
	s.SourceTimeoutValue = v
	return s
}

// SRT2 publishing configuration for a stream.
func (s StreamConfigImpl) Srt2Publish() SrtConfig {
	return s.Srt2PublishValue
}

// SRT2 publishing configuration for a stream.
func (s *StreamConfigImpl) SetSrt2Publish(v SrtConfig) StreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*SrtConfigImpl); ok {
		s.Srt2PublishValue = impl
	}
	return s
}

// Deprecated field. Will be deleted at 24.06
// Stream name was resolved via `srt_port_resolve` call.
// See [endpoint](https://flussonic.com/doc/api/config-external/#tag/srt/operation/srt_port_resolve)
// and [listener](https://flussonic.com/doc/api/reference/#tag/config/operation/config_save%7Cbody%7Clisteners%7Csrt)
// for feature description.
// This parameter now lives in `stats` object.
// Example: false
func (s StreamConfigImpl) SrtPortResolve() *bool {
	return s.SrtPortResolveValue
}

// Deprecated field. Will be deleted at 24.06
// Stream name was resolved via `srt_port_resolve` call.
// See [endpoint](https://flussonic.com/doc/api/config-external/#tag/srt/operation/srt_port_resolve)
// and [listener](https://flussonic.com/doc/api/reference/#tag/config/operation/config_save%7Cbody%7Clisteners%7Csrt)
// for feature description.
// This parameter now lives in `stats` object.
// Example: false
func (s *StreamConfigImpl) SetSrtPortResolve(v bool) StreamConfig {
	if s == nil {
		return nil
	}
	s.SrtPortResolveValue = &v
	return s
}

// SRT publishing configuration for a stream.
func (s StreamConfigImpl) SrtPublish() SrtConfig {
	return s.SrtPublishValue
}

// SRT publishing configuration for a stream.
func (s *StreamConfigImpl) SetSrtPublish(v SrtConfig) StreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*SrtConfigImpl); ok {
		s.SrtPublishValue = impl
	}
	return s
}

// Whether a stream is `static` or not.
// If set to `True` the server will try to keep this stream running even if
// there are no viewers or errors encountered.
// Streamer restarts *all* `static` streams even if any internal errors occur
// and the `static` streams crash.
// Example: true
func (s StreamConfigImpl) Static() *bool {
	return s.StaticValue
}

// Whether a stream is `static` or not.
// If set to `True` the server will try to keep this stream running even if
// there are no viewers or errors encountered.
// Streamer restarts *all* `static` streams even if any internal errors occur
// and the `static` streams crash.
// Example: true
func (s *StreamConfigImpl) SetStatic(v bool) StreamConfig {
	if s == nil {
		return nil
	}
	s.StaticValue = &v
	return s
}

// Stream's metrics and other statistical information.
func (s StreamConfigImpl) Stats() StreamStats {
	return s.StatsValue
}

// Stream's metrics and other statistical information.
func (s *StreamConfigImpl) SetStats(v StreamStats) StreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*StreamStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// Template of the stream.
// Format: media_name (media_name)
// Example: sports-hd
func (s StreamConfigImpl) Template() *MediaName {
	return s.TemplateValue
}

// Template of the stream.
// Format: media_name (media_name)
// Example: sports-hd
func (s *StreamConfigImpl) SetTemplate(v MediaName) StreamConfig {
	if s == nil {
		return nil
	}
	s.TemplateValue = &v
	return s
}

// Configuration of thumbnails generator.
func (s StreamConfigImpl) Thumbnails() ThumbnailsSpec {
	return s.ThumbnailsValue
}

// Configuration of thumbnails generator.
func (s *StreamConfigImpl) SetThumbnails(v ThumbnailsSpec) StreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ThumbnailsSpecImpl); ok {
		s.ThumbnailsValue = impl
	}
	return s
}

// Human-readable title of the stream. Provided for SDT MPEG-TS table or
// SDP RTSP title parameter.
// Example: Hockey channel
func (s StreamConfigImpl) Title() *string {
	return s.TitleValue
}

// Human-readable title of the stream. Provided for SDT MPEG-TS table or
// SDP RTSP title parameter.
// Example: Hockey channel
func (s *StreamConfigImpl) SetTitle(v string) StreamConfig {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// Configuration of the transcoder settings.
// Examples: map[]
func (s StreamConfigImpl) Transcoder() TranscoderOpts {
	return s.TranscoderValue
}

// Configuration of the transcoder settings.
// Examples: map[]
func (s *StreamConfigImpl) SetTranscoder(v TranscoderOpts) StreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*TranscoderOptsImpl); ok {
		s.TranscoderValue = impl
	}
	return s
}

// Transport protocol for WebRTC.
func (s StreamConfigImpl) Transport() *WebrtcTransport {
	return s.TransportValue
}

// Transport protocol for WebRTC.
func (s *StreamConfigImpl) SetTransport(v WebrtcTransport) StreamConfig {
	if s == nil {
		return nil
	}
	s.TransportValue = &v
	return s
}

// A string starting the addresses of separate segments within a *segment-based* playlists (HLS or DASH).
// Each sub-playlist is stored on Media Server.
// If set to `false`, the configured value in a template will be disabled.
func (s StreamConfigImpl) URLPrefix() *URLPrefix {
	return s.URLPrefixValue
}

// A string starting the addresses of separate segments within a *segment-based* playlists (HLS or DASH).
// Each sub-playlist is stored on Media Server.
// If set to `false`, the configured value in a template will be disabled.
func (s *StreamConfigImpl) SetURLPrefix(v *URLPrefix) StreamConfig {
	if s == nil {
		return nil
	}
	s.URLPrefixValue = v
	return s
}

// If a connected source does not send video data within this timeout period (in seconds),
// the source connection is considered to be lost.
// This is a default configuration for a stream, can be modified for any input.
// Format: seconds (seconds)
// Example: 20
func (s StreamConfigImpl) VideoTimeout() *Seconds {
	return s.VideoTimeoutValue
}

// If a connected source does not send video data within this timeout period (in seconds),
// the source connection is considered to be lost.
// This is a default configuration for a stream, can be modified for any input.
// Format: seconds (seconds)
// Example: 20
func (s *StreamConfigImpl) SetVideoTimeout(v Seconds) StreamConfig {
	if s == nil {
		return nil
	}
	s.VideoTimeoutValue = &v
	return s
}

// Video analytics parameters.
func (s StreamConfigImpl) Vision() VisionSpec {
	return s.VisionValue
}

// Video analytics parameters.
func (s *StreamConfigImpl) SetVision(v VisionSpec) StreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionSpecImpl); ok {
		s.VisionValue = impl
	}
	return s
}

// WebRTC play configuration for a stream.
func (s StreamConfigImpl) WebrtcAbr() WebrtcAbrOpts {
	return s.WebrtcAbrValue
}

// WebRTC play configuration for a stream.
func (s *StreamConfigImpl) SetWebrtcAbr(v WebrtcAbrOpts) StreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*WebrtcAbrOptsImpl); ok {
		s.WebrtcAbrValue = impl
	}
	return s
}

// NewStreamConfigAdditional creates a new StreamConfigAdditional instance
func NewStreamConfigAdditional() StreamConfigAdditional {
	return &StreamConfigAdditionalImpl{}
}

// Part of the effective config from the configuration file.
func (s StreamConfigAdditionalImpl) ConfigOnDisk() StreamConfigStripped {
	return s.ConfigOnDiskValue
}

// Part of the effective config from the configuration file.
func (s *StreamConfigAdditionalImpl) SetConfigOnDisk(v StreamConfigStripped) StreamConfigAdditional {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*StreamConfigStrippedImpl); ok {
		s.ConfigOnDiskValue = impl
	}
	return s
}

// Stream's metrics and other statistical information.
func (s StreamConfigAdditionalImpl) Stats() StreamStats {
	return s.StatsValue
}

// Stream's metrics and other statistical information.
func (s *StreamConfigAdditionalImpl) SetStats(v StreamStats) StreamConfigAdditional {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*StreamStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// NewStreamConfigBase creates a new StreamConfigBase instance
func NewStreamConfigBase() StreamConfigBase {
	return &StreamConfigBaseImpl{}
}

// Whether a stream is disabled. Disabled streams are inactive and do not run.
// Displayed only with the API calls.
// Example: false
func (s StreamConfigBaseImpl) Disabled() *bool {
	return s.DisabledValue
}

// Whether a stream is disabled. Disabled streams are inactive and do not run.
// Displayed only with the API calls.
// Example: false
func (s *StreamConfigBaseImpl) SetDisabled(v bool) StreamConfigBase {
	if s == nil {
		return nil
	}
	s.DisabledValue = &v
	return s
}

// Whether a stream is `static` or not.
// If set to `True` the server will try to keep this stream running even if
// there are no viewers or errors encountered.
// Streamer restarts *all* `static` streams even if any internal errors occur
// and the `static` streams crash.
// Example: true
func (s StreamConfigBaseImpl) Static() *bool {
	return s.StaticValue
}

// Whether a stream is `static` or not.
// If set to `True` the server will try to keep this stream running even if
// there are no viewers or errors encountered.
// Streamer restarts *all* `static` streams even if any internal errors occur
// and the `static` streams crash.
// Example: true
func (s *StreamConfigBaseImpl) SetStatic(v bool) StreamConfigBase {
	if s == nil {
		return nil
	}
	s.StaticValue = &v
	return s
}

// NewStreamConfigDeprecated creates a new StreamConfigDeprecated instance
func NewStreamConfigDeprecated() StreamConfigDeprecated {
	return &StreamConfigDeprecatedImpl{}
}

// Transport protocol for WebRTC.
func (s StreamConfigDeprecatedImpl) Transport() *WebrtcTransport {
	return s.TransportValue
}

// Transport protocol for WebRTC.
func (s *StreamConfigDeprecatedImpl) SetTransport(v WebrtcTransport) StreamConfigDeprecated {
	if s == nil {
		return nil
	}
	s.TransportValue = &v
	return s
}

// NewStreamConfigInput creates a new StreamConfigInput instance
func NewStreamConfigInput() StreamConfigInput {
	return &StreamConfigInputImpl{}
}

// If a connected source does not send audio data within this timeout period (in seconds),
// the source connection is considered to be lost.
// This is a default configuration for a stream, can be modified for any input.
// Format: seconds (seconds)
// Example: 20
func (s StreamConfigInputImpl) AudioTimeout() *Seconds {
	return s.AudioTimeoutValue
}

// If a connected source does not send audio data within this timeout period (in seconds),
// the source connection is considered to be lost.
// This is a default configuration for a stream, can be modified for any input.
// Format: seconds (seconds)
// Example: 20
func (s *StreamConfigInputImpl) SetAudioTimeout(v Seconds) StreamConfigInput {
	if s == nil {
		return nil
	}
	s.AudioTimeoutValue = &v
	return s
}

// When all inputs are down, this can be used to show at least something to users.
// It is important to understand that backup video behaves differently, not as inputs.
// It is not a _last input_ in the list. After any input stops sending frames, timer starts.
// After `source_timeout` seconds backup starts working, while all other inputs are still trying to
// connect and start working.
// So backup and all inputs are working in parallel.
func (s StreamConfigInputImpl) Backup() BackupConfig {
	return s.BackupValue
}

// When all inputs are down, this can be used to show at least something to users.
// It is important to understand that backup video behaves differently, not as inputs.
// It is not a _last input_ in the list. After any input stops sending frames, timer starts.
// After `source_timeout` seconds backup starts working, while all other inputs are still trying to
// connect and start working.
// So backup and all inputs are working in parallel.
func (s *StreamConfigInputImpl) SetBackup(v BackupConfig) StreamConfigInput {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*BackupConfigImpl); ok {
		s.BackupValue = impl
	}
	return s
}

// This parameter allows to manage subtitles in an output stream.
// Example: replace
func (s StreamConfigInputImpl) Dvbocr() *StreamConfigInputDvbocr {
	return s.DvbocrValue
}

// This parameter allows to manage subtitles in an output stream.
// Example: replace
func (s *StreamConfigInputImpl) SetDvbocr(v StreamConfigInputDvbocr) StreamConfigInput {
	if s == nil {
		return nil
	}
	s.DvbocrValue = &v
	return s
}

// Whether to extract EPG from the input.
// Example: true
func (s StreamConfigInputImpl) EpgEnabled() *bool {
	return s.EpgEnabledValue
}

// Whether to extract EPG from the input.
// Example: true
func (s *StreamConfigInputImpl) SetEpgEnabled(v bool) StreamConfigInput {
	if s == nil {
		return nil
	}
	s.EpgEnabledValue = &v
	return s
}

// Use this option for fine-grained control over each input track.
// You can select, rename, change name and title for each video, audio track.
func (s StreamConfigInputImpl) InputMediaInfo() InputMediaInfo {
	return s.InputMediaInfoValue
}

// Use this option for fine-grained control over each input track.
// You can select, rename, change name and title for each video, audio track.
func (s *StreamConfigInputImpl) SetInputMediaInfo(v InputMediaInfo) StreamConfigInput {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputMediaInfoImpl); ok {
		s.InputMediaInfoValue = impl
	}
	return s
}

// List of stream inputs.
// ***Important:*** A stream without any inputs can receive video frames **only** if backup file is specified.
func (s StreamConfigInputImpl) Inputs() []StreamInput {
	if s.InputsValue == nil {
		return nil
	}
	result := make([]StreamInput, len(s.InputsValue))
	for i, item := range s.InputsValue {
		result[i] = item
	}
	return result
}

// List of stream inputs.
// ***Important:*** A stream without any inputs can receive video frames **only** if backup file is specified.
func (s *StreamConfigInputImpl) SetInputs(v []StreamInput) StreamConfigInput {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*StreamInputImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*StreamInputImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.InputsValue = impl
	}
	return s
}

// The maximum time that Media Server will set for attempts to reconnect to sources when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s StreamConfigInputImpl) MaxRetryTimeout() *Seconds {
	return s.MaxRetryTimeoutValue
}

// The maximum time that Media Server will set for attempts to reconnect to sources when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s *StreamConfigInputImpl) SetMaxRetryTimeout(v Seconds) StreamConfigInput {
	if s == nil {
		return nil
	}
	s.MaxRetryTimeoutValue = &v
	return s
}

// It allows to specify pack information about ac3 for outgoing MPEGTS-TS streams. The default value is `system_b`.
func (s StreamConfigInputImpl) MpegtsAc3() *OutputMpegtsAc3 {
	return s.MpegtsAc3Value
}

// It allows to specify pack information about ac3 for outgoing MPEGTS-TS streams. The default value is `system_b`.
func (s *StreamConfigInputImpl) SetMpegtsAc3(v OutputMpegtsAc3) StreamConfigInput {
	if s == nil {
		return nil
	}
	s.MpegtsAc3Value = &v
	return s
}

// Deprecated field. Will be deleted at 25.03
// Human-readable name of the content provider. Used, for example, for MPEG-TS.
// Deprecated, use `input_media_info.provider` instead
// Example: SportsTV
func (s StreamConfigInputImpl) Provider() *string {
	return s.ProviderValue
}

// Deprecated field. Will be deleted at 25.03
// Human-readable name of the content provider. Used, for example, for MPEG-TS.
// Deprecated, use `input_media_info.provider` instead
// Example: SportsTV
func (s *StreamConfigInputImpl) SetProvider(v string) StreamConfigInput {
	if s == nil {
		return nil
	}
	s.ProviderValue = &v
	return s
}

// If a connected source does not send any data within this timeout period (in seconds),
// the source connection is considered to be lost.
// This is a default configuration for a stream, can be modified for any input.
// Example: 10
func (s StreamConfigInputImpl) SourceTimeout() any {
	return s.SourceTimeoutValue
}

// If a connected source does not send any data within this timeout period (in seconds),
// the source connection is considered to be lost.
// This is a default configuration for a stream, can be modified for any input.
// Example: 10
func (s *StreamConfigInputImpl) SetSourceTimeout(v any) StreamConfigInput {
	if s == nil {
		return nil
	}
	s.SourceTimeoutValue = v
	return s
}

// If a connected source does not send video data within this timeout period (in seconds),
// the source connection is considered to be lost.
// This is a default configuration for a stream, can be modified for any input.
// Format: seconds (seconds)
// Example: 20
func (s StreamConfigInputImpl) VideoTimeout() *Seconds {
	return s.VideoTimeoutValue
}

// If a connected source does not send video data within this timeout period (in seconds),
// the source connection is considered to be lost.
// This is a default configuration for a stream, can be modified for any input.
// Format: seconds (seconds)
// Example: 20
func (s *StreamConfigInputImpl) SetVideoTimeout(v Seconds) StreamConfigInput {
	if s == nil {
		return nil
	}
	s.VideoTimeoutValue = &v
	return s
}

// NewStreamConfigMedia creates a new StreamConfigMedia instance
func NewStreamConfigMedia() StreamConfigMedia {
	return &StreamConfigMediaImpl{}
}

// Whether to add an audio-only version of an HLS stream.
// Used to create App Store compliant HLS streams to deliver the content to Apple iOS devices.
// Example: true
func (s StreamConfigMediaImpl) AddAudioOnly() *bool {
	return s.AddAudioOnlyValue
}

// Whether to add an audio-only version of an HLS stream.
// Used to create App Store compliant HLS streams to deliver the content to Apple iOS devices.
// Example: true
func (s *StreamConfigMediaImpl) SetAddAudioOnly(v bool) StreamConfigMedia {
	if s == nil {
		return nil
	}
	s.AddAudioOnlyValue = &v
	return s
}

// Chunk duration in LL-HLS manifest to be used for tunning latency.
// Format: milliseconds (milliseconds)
// Example: 200
func (s StreamConfigMediaImpl) ChunkDuration() *Milliseconds {
	return s.ChunkDurationValue
}

// Chunk duration in LL-HLS manifest to be used for tunning latency.
// Format: milliseconds (milliseconds)
// Example: 200
func (s *StreamConfigMediaImpl) SetChunkDuration(v Milliseconds) StreamConfigMedia {
	if s == nil {
		return nil
	}
	s.ChunkDurationValue = &v
	return s
}

// Stream's lifetime after the last client was disconnected (can be expressed in *seconds* or set to `False`).
// Applicable to on-demand streams **only**.
// Example: 485
func (s StreamConfigMediaImpl) ClientsTimeout() any {
	return s.ClientsTimeoutValue
}

// Stream's lifetime after the last client was disconnected (can be expressed in *seconds* or set to `False`).
// Applicable to on-demand streams **only**.
// Example: 485
func (s *StreamConfigMediaImpl) SetClientsTimeout(v any) StreamConfigMedia {
	if s == nil {
		return nil
	}
	s.ClientsTimeoutValue = v
	return s
}

// Configuraton of Digital Rights Management system (DRM).
func (s StreamConfigMediaImpl) Drm() DrmSpec {
	return s.DrmValue
}

// Configuraton of Digital Rights Management system (DRM).
func (s *StreamConfigMediaImpl) SetDrm(v DrmSpec) StreamConfigMedia {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*DrmSpecImpl); ok {
		s.DrmValue = impl
	}
	return s
}

// DVR configuraton.
func (s StreamConfigMediaImpl) Dvr() StreamDvrSpec {
	return s.DvrValue
}

// DVR configuraton.
func (s *StreamConfigMediaImpl) SetDvr(v StreamDvrSpec) StreamConfigMedia {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*StreamDvrSpecImpl); ok {
		s.DvrValue = impl
	}
	return s
}

// Whether to enable SCTE-35 ad insertion markers signaling in HLS manifest.
// Ad markers can be included in SCTE-35 (`scte35`), AWS (`aws`), EXT-X-DATERANGE (`rfc8216`) formats or not included (`false`).
// Example: scte35
func (s StreamConfigMediaImpl) HlsScte35() *StreamConfigMediaHlsScte35 {
	return s.HlsScte35Value
}

// Whether to enable SCTE-35 ad insertion markers signaling in HLS manifest.
// Ad markers can be included in SCTE-35 (`scte35`), AWS (`aws`), EXT-X-DATERANGE (`rfc8216`) formats or not included (`false`).
// Example: scte35
func (s *StreamConfigMediaImpl) SetHlsScte35(v StreamConfigMediaHlsScte35) StreamConfigMedia {
	if s == nil {
		return nil
	}
	s.HlsScte35Value = &v
	return s
}

// A key to sign jpeg_snapshot requests
func (s StreamConfigMediaImpl) JpegSnapshotSignKey() *string {
	return s.JpegSnapshotSignKeyValue
}

// A key to sign jpeg_snapshot requests
func (s *StreamConfigMediaImpl) SetJpegSnapshotSignKey(v string) StreamConfigMedia {
	if s == nil {
		return nil
	}
	s.JpegSnapshotSignKeyValue = &v
	return s
}

// Stream labels in key value format.
// Key is a string in unix_name format (alphanumeric characters, underscores, hyphens and periods).
// See [Layouter schema](https://flussonic.com/doc/api/layouter/#tag/stream/operation/streams_list/response%7Cstreams%7Clabels)
// for more details.
func (s StreamConfigMediaImpl) Labels() map[string]UnixName {
	return s.LabelsValue
}

// Stream labels in key value format.
// Key is a string in unix_name format (alphanumeric characters, underscores, hyphens and periods).
// See [Layouter schema](https://flussonic.com/doc/api/layouter/#tag/stream/operation/streams_list/response%7Cstreams%7Clabels)
// for more details.
func (s *StreamConfigMediaImpl) SetLabels(v map[string]UnixName) StreamConfigMedia {
	if s == nil {
		return nil
	}
	s.LabelsValue = v
	return s
}

// This parameter sets PIDs values for outgoing MPEG-TS streams. PID contains information about the TS package content and can be decoded according to special service tables.
// It is possible to set PID values for PMT, SDT, video, and audio tracks. Tracks are numbered starting from one.
// The code `a1=123` sets a PID value for the first audio track. It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, `t0=100` sets PID=101 for the first track, 102 for the second, and so on. Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s StreamConfigMediaImpl) MpegtsPids() OutputMpegtsPids {
	return s.MpegtsPidsValue
}

// This parameter sets PIDs values for outgoing MPEG-TS streams. PID contains information about the TS package content and can be decoded according to special service tables.
// It is possible to set PID values for PMT, SDT, video, and audio tracks. Tracks are numbered starting from one.
// The code `a1=123` sets a PID value for the first audio track. It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, `t0=100` sets PID=101 for the first track, 102 for the second, and so on. Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s *StreamConfigMediaImpl) SetMpegtsPids(v OutputMpegtsPids) StreamConfigMedia {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*OutputMpegtsPidsImpl); ok {
		s.MpegtsPidsValue = impl
	}
	return s
}

// Configuration of authorization backend for play sessions.
func (s StreamConfigMediaImpl) OnPlay() AuthSpec {
	return s.OnPlayValue
}

// Configuration of authorization backend for play sessions.
func (s *StreamConfigMediaImpl) SetOnPlay(v AuthSpec) StreamConfigMedia {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*AuthSpecImpl); ok {
		s.OnPlayValue = impl
	}
	return s
}

// Configuration of authorization backend for publish sessions.
func (s StreamConfigMediaImpl) OnPublish() AuthSpec {
	return s.OnPublishValue
}

// Configuration of authorization backend for publish sessions.
func (s *StreamConfigMediaImpl) SetOnPublish(v AuthSpec) StreamConfigMedia {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*AuthSpecImpl); ok {
		s.OnPublishValue = impl
	}
	return s
}

// This parameter sets playback HTTP headers for streams.
func (s StreamConfigMediaImpl) PlaybackHeaders() []PlaybackHeaders {
	if s.PlaybackHeadersValue == nil {
		return nil
	}
	result := make([]PlaybackHeaders, len(s.PlaybackHeadersValue))
	for i, item := range s.PlaybackHeadersValue {
		result[i] = item
	}
	return result
}

// This parameter sets playback HTTP headers for streams.
func (s *StreamConfigMediaImpl) SetPlaybackHeaders(v []PlaybackHeaders) StreamConfigMedia {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*PlaybackHeadersImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*PlaybackHeadersImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.PlaybackHeadersValue = impl
	}
	return s
}

// The time (in seconds) that Media Server reserves for preloading the data, i. e. *buffering*.
// Prepush is always defined through GoP, but this option provides you with a more flexible way
// to configure the buffer size, e. g. a 1-3 or 7-10 seconds time interval.
// The bigger the buffer size, the better the user experience is for the users
// with a bad internet connection. However, the latency also increases.
// If set to `False` to remove the latency, the stream's start time
// increases. To decrease it, reduce the GoP size and make the bitrate higher
// or the video quality lower.
// Example: false
func (s StreamConfigMediaImpl) Prepush() any {
	return s.PrepushValue
}

// The time (in seconds) that Media Server reserves for preloading the data, i. e. *buffering*.
// Prepush is always defined through GoP, but this option provides you with a more flexible way
// to configure the buffer size, e. g. a 1-3 or 7-10 seconds time interval.
// The bigger the buffer size, the better the user experience is for the users
// with a bad internet connection. However, the latency also increases.
// If set to `False` to remove the latency, the stream's start time
// increases. To decrease it, reduce the GoP size and make the bitrate higher
// or the video quality lower.
// Example: false
func (s *StreamConfigMediaImpl) SetPrepush(v any) StreamConfigMedia {
	if s == nil {
		return nil
	}
	s.PrepushValue = v
	return s
}

// Configuration to allow/forbid playing the stream via various protocols.
// - If the `whitelist` option is set to 'true', the server allows a playback only for listed protocols;
// - If the `whitelist` option is set to 'false', the server forbids a playback for listed protocols;
// - Server allows a playback for all the protocols by default.
func (s StreamConfigMediaImpl) Protocols() PlayProtocolsSpec {
	return s.ProtocolsValue
}

// Configuration to allow/forbid playing the stream via various protocols.
// - If the `whitelist` option is set to 'true', the server allows a playback only for listed protocols;
// - If the `whitelist` option is set to 'false', the server forbids a playback for listed protocols;
// - Server allows a playback for all the protocols by default.
func (s *StreamConfigMediaImpl) SetProtocols(v PlayProtocolsSpec) StreamConfigMedia {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*PlayProtocolsSpecImpl); ok {
		s.ProtocolsValue = impl
	}
	return s
}

// A list of pushes. When a server initiates the connection and sends a stream
// to other server(s), it is called a `push`.
func (s StreamConfigMediaImpl) Pushes() []StreamPush {
	if s.PushesValue == nil {
		return nil
	}
	result := make([]StreamPush, len(s.PushesValue))
	for i, item := range s.PushesValue {
		result[i] = item
	}
	return result
}

// A list of pushes. When a server initiates the connection and sends a stream
// to other server(s), it is called a `push`.
func (s *StreamConfigMediaImpl) SetPushes(v []StreamPush) StreamConfigMedia {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*StreamPushImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*StreamPushImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.PushesValue = impl
	}
	return s
}

// Number of attempts for the server to reconnect to a data source.
// Applicable to on-demand streams **only**. If not defined, server will constantly try to reconnect (unlimited number of retries).
// If the input does not become active after specified amount of attempts, stream shuts down till the next user request.
func (s StreamConfigMediaImpl) RetryLimit() *int {
	return s.RetryLimitValue
}

// Number of attempts for the server to reconnect to a data source.
// Applicable to on-demand streams **only**. If not defined, server will constantly try to reconnect (unlimited number of retries).
// If the input does not become active after specified amount of attempts, stream shuts down till the next user request.
func (s *StreamConfigMediaImpl) SetRetryLimit(v int) StreamConfigMedia {
	if s == nil {
		return nil
	}
	s.RetryLimitValue = &v
	return s
}

// Number of segments stored in memory for the segment-based protocols, such as HLS and DASH.
// Added to HLS live manifest. Do not forget that one more segment is stored for stale clients
// that come too late, but the latest segment is not shown in the manifest.
// Example: 4
func (s StreamConfigMediaImpl) SegmentCount() *int {
	return s.SegmentCountValue
}

// Number of segments stored in memory for the segment-based protocols, such as HLS and DASH.
// Added to HLS live manifest. Do not forget that one more segment is stored for stale clients
// that come too late, but the latest segment is not shown in the manifest.
// Example: 4
func (s *StreamConfigMediaImpl) SetSegmentCount(v int) StreamConfigMedia {
	if s == nil {
		return nil
	}
	s.SegmentCountValue = &v
	return s
}

// The time of the segment duration. Used for the protocols like HLS or DASH.
// The disk config offers this value in seconds.
// Example: 5000
func (s StreamConfigMediaImpl) SegmentDuration() *Milliseconds {
	return s.SegmentDurationValue
}

// The time of the segment duration. Used for the protocols like HLS or DASH.
// The disk config offers this value in seconds.
// Example: 5000
func (s *StreamConfigMediaImpl) SetSegmentDuration(v Milliseconds) StreamConfigMedia {
	if s == nil {
		return nil
	}
	s.SegmentDurationValue = &v
	return s
}

// Configuration of thumbnails generator.
func (s StreamConfigMediaImpl) Thumbnails() ThumbnailsSpec {
	return s.ThumbnailsValue
}

// Configuration of thumbnails generator.
func (s *StreamConfigMediaImpl) SetThumbnails(v ThumbnailsSpec) StreamConfigMedia {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ThumbnailsSpecImpl); ok {
		s.ThumbnailsValue = impl
	}
	return s
}

// Configuration of the transcoder settings.
// Examples: map[]
func (s StreamConfigMediaImpl) Transcoder() TranscoderOpts {
	return s.TranscoderValue
}

// Configuration of the transcoder settings.
// Examples: map[]
func (s *StreamConfigMediaImpl) SetTranscoder(v TranscoderOpts) StreamConfigMedia {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*TranscoderOptsImpl); ok {
		s.TranscoderValue = impl
	}
	return s
}

// A string starting the addresses of separate segments within a *segment-based* playlists (HLS or DASH).
// Each sub-playlist is stored on Media Server.
// If set to `false`, the configured value in a template will be disabled.
func (s StreamConfigMediaImpl) URLPrefix() *URLPrefix {
	return s.URLPrefixValue
}

// A string starting the addresses of separate segments within a *segment-based* playlists (HLS or DASH).
// Each sub-playlist is stored on Media Server.
// If set to `false`, the configured value in a template will be disabled.
func (s *StreamConfigMediaImpl) SetURLPrefix(v *URLPrefix) StreamConfigMedia {
	if s == nil {
		return nil
	}
	s.URLPrefixValue = v
	return s
}

// WebRTC play configuration for a stream.
func (s StreamConfigMediaImpl) WebrtcAbr() WebrtcAbrOpts {
	return s.WebrtcAbrValue
}

// WebRTC play configuration for a stream.
func (s *StreamConfigMediaImpl) SetWebrtcAbr(v WebrtcAbrOpts) StreamConfigMedia {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*WebrtcAbrOptsImpl); ok {
		s.WebrtcAbrValue = impl
	}
	return s
}

// NewStreamConfigOnpremises creates a new StreamConfigOnpremises instance
func NewStreamConfigOnpremises() StreamConfigOnpremises {
	return &StreamConfigOnpremisesImpl{}
}

// Deprecated field. Will be deleted at 23.12
// The param is deprecated and now used only for onvif_url and onvif_profile options.
func (s StreamConfigOnpremisesImpl) Meta() map[string]string {
	return s.MetaValue
}

// Deprecated field. Will be deleted at 23.12
// The param is deprecated and now used only for onvif_url and onvif_profile options.
func (s *StreamConfigOnpremisesImpl) SetMeta(v map[string]string) StreamConfigOnpremises {
	if s == nil {
		return nil
	}
	s.MetaValue = v
	return s
}

// Video analytics parameters.
func (s StreamConfigOnpremisesImpl) Vision() VisionSpec {
	return s.VisionValue
}

// Video analytics parameters.
func (s *StreamConfigOnpremisesImpl) SetVision(v VisionSpec) StreamConfigOnpremises {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionSpecImpl); ok {
		s.VisionValue = impl
	}
	return s
}

// NewStreamConfigSingleMedia creates a new StreamConfigSingleMedia instance
func NewStreamConfigSingleMedia() StreamConfigSingleMedia {
	return &StreamConfigSingleMediaImpl{}
}

// SRT2 publishing configuration for a stream.
func (s StreamConfigSingleMediaImpl) Srt2Publish() SrtConfig {
	return s.Srt2PublishValue
}

// SRT2 publishing configuration for a stream.
func (s *StreamConfigSingleMediaImpl) SetSrt2Publish(v SrtConfig) StreamConfigSingleMedia {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*SrtConfigImpl); ok {
		s.Srt2PublishValue = impl
	}
	return s
}

// SRT publishing configuration for a stream.
func (s StreamConfigSingleMediaImpl) SrtPublish() SrtConfig {
	return s.SrtPublishValue
}

// SRT publishing configuration for a stream.
func (s *StreamConfigSingleMediaImpl) SetSrtPublish(v SrtConfig) StreamConfigSingleMedia {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*SrtConfigImpl); ok {
		s.SrtPublishValue = impl
	}
	return s
}

// NewStreamConfigSpecific creates a new StreamConfigSpecific instance
func NewStreamConfigSpecific() StreamConfigSpecific {
	return &StreamConfigSpecificImpl{}
}

// Human-readable description of the stream.
// Example: This is a test stream
func (s StreamConfigSpecificImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the stream.
// Example: This is a test stream
func (s *StreamConfigSpecificImpl) SetComment(v string) StreamConfigSpecific {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Globally unique stream name.
// Note that the name could not be changed after the stream is created.
// Format: media_name (media_name)
// Examples: Decklink-Stream, Dektec-Stream, hockey1, mylive/bunny, test_stream
func (s StreamConfigSpecificImpl) Name() MediaName {
	return s.NameValue
}

// Globally unique stream name.
// Note that the name could not be changed after the stream is created.
// Format: media_name (media_name)
// Examples: Decklink-Stream, Dektec-Stream, hockey1, mylive/bunny, test_stream
func (s *StreamConfigSpecificImpl) SetName(v MediaName) StreamConfigSpecific {
	if s == nil {
		return nil
	}
	s.NameValue = v
	return s
}

// Where the stream is initialized: config, user play/publication, or remote
// cluster server.
// Example: config
func (s StreamConfigSpecificImpl) NamedBy() *NamedBy {
	return s.NamedByValue
}

// Where the stream is initialized: config, user play/publication, or remote
// cluster server.
// Example: config
func (s *StreamConfigSpecificImpl) SetNamedBy(v NamedBy) StreamConfigSpecific {
	if s == nil {
		return nil
	}
	s.NamedByValue = &v
	return s
}

// Position of the stream in order of streams in the config file, if declared.
// Format: sort_index (sort_index)
// Example: 2
func (s StreamConfigSpecificImpl) Position() *SortIndex {
	return s.PositionValue
}

// Position of the stream in order of streams in the config file, if declared.
// Format: sort_index (sort_index)
// Example: 2
func (s *StreamConfigSpecificImpl) SetPosition(v SortIndex) StreamConfigSpecific {
	if s == nil {
		return nil
	}
	s.PositionValue = &v
	return s
}

// How often to re-check secondary inputs. If this option is not set than check is never performed.
// Format: seconds (seconds)
// Example: 120
func (s StreamConfigSpecificImpl) RecheckSecondaryInputsInterval() *Seconds {
	return s.RecheckSecondaryInputsIntervalValue
}

// How often to re-check secondary inputs. If this option is not set than check is never performed.
// Format: seconds (seconds)
// Example: 120
func (s *StreamConfigSpecificImpl) SetRecheckSecondaryInputsInterval(v Seconds) StreamConfigSpecific {
	if s == nil {
		return nil
	}
	s.RecheckSecondaryInputsIntervalValue = &v
	return s
}

// Deprecated field. Will be deleted at 24.06
// Stream name was resolved via `srt_port_resolve` call.
// See [endpoint](https://flussonic.com/doc/api/config-external/#tag/srt/operation/srt_port_resolve)
// and [listener](https://flussonic.com/doc/api/reference/#tag/config/operation/config_save%7Cbody%7Clisteners%7Csrt)
// for feature description.
// This parameter now lives in `stats` object.
// Example: false
func (s StreamConfigSpecificImpl) SrtPortResolve() *bool {
	return s.SrtPortResolveValue
}

// Deprecated field. Will be deleted at 24.06
// Stream name was resolved via `srt_port_resolve` call.
// See [endpoint](https://flussonic.com/doc/api/config-external/#tag/srt/operation/srt_port_resolve)
// and [listener](https://flussonic.com/doc/api/reference/#tag/config/operation/config_save%7Cbody%7Clisteners%7Csrt)
// for feature description.
// This parameter now lives in `stats` object.
// Example: false
func (s *StreamConfigSpecificImpl) SetSrtPortResolve(v bool) StreamConfigSpecific {
	if s == nil {
		return nil
	}
	s.SrtPortResolveValue = &v
	return s
}

// Template of the stream.
// Format: media_name (media_name)
// Example: sports-hd
func (s StreamConfigSpecificImpl) Template() *MediaName {
	return s.TemplateValue
}

// Template of the stream.
// Format: media_name (media_name)
// Example: sports-hd
func (s *StreamConfigSpecificImpl) SetTemplate(v MediaName) StreamConfigSpecific {
	if s == nil {
		return nil
	}
	s.TemplateValue = &v
	return s
}

// Human-readable title of the stream. Provided for SDT MPEG-TS table or
// SDP RTSP title parameter.
// Example: Hockey channel
func (s StreamConfigSpecificImpl) Title() *string {
	return s.TitleValue
}

// Human-readable title of the stream. Provided for SDT MPEG-TS table or
// SDP RTSP title parameter.
// Example: Hockey channel
func (s *StreamConfigSpecificImpl) SetTitle(v string) StreamConfigSpecific {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// NewStreamConfigStripped creates a new StreamConfigStripped instance
func NewStreamConfigStripped() StreamConfigStripped {
	return &StreamConfigStrippedImpl{}
}

// Whether to add an audio-only version of an HLS stream.
// Used to create App Store compliant HLS streams to deliver the content to Apple iOS devices.
// Example: true
func (s StreamConfigStrippedImpl) AddAudioOnly() *bool {
	return s.AddAudioOnlyValue
}

// Whether to add an audio-only version of an HLS stream.
// Used to create App Store compliant HLS streams to deliver the content to Apple iOS devices.
// Example: true
func (s *StreamConfigStrippedImpl) SetAddAudioOnly(v bool) StreamConfigStripped {
	if s == nil {
		return nil
	}
	s.AddAudioOnlyValue = &v
	return s
}

// If a connected source does not send audio data within this timeout period (in seconds),
// the source connection is considered to be lost.
// This is a default configuration for a stream, can be modified for any input.
// Format: seconds (seconds)
// Example: 20
func (s StreamConfigStrippedImpl) AudioTimeout() *Seconds {
	return s.AudioTimeoutValue
}

// If a connected source does not send audio data within this timeout period (in seconds),
// the source connection is considered to be lost.
// This is a default configuration for a stream, can be modified for any input.
// Format: seconds (seconds)
// Example: 20
func (s *StreamConfigStrippedImpl) SetAudioTimeout(v Seconds) StreamConfigStripped {
	if s == nil {
		return nil
	}
	s.AudioTimeoutValue = &v
	return s
}

// When all inputs are down, this can be used to show at least something to users.
// It is important to understand that backup video behaves differently, not as inputs.
// It is not a _last input_ in the list. After any input stops sending frames, timer starts.
// After `source_timeout` seconds backup starts working, while all other inputs are still trying to
// connect and start working.
// So backup and all inputs are working in parallel.
func (s StreamConfigStrippedImpl) Backup() BackupConfig {
	return s.BackupValue
}

// When all inputs are down, this can be used to show at least something to users.
// It is important to understand that backup video behaves differently, not as inputs.
// It is not a _last input_ in the list. After any input stops sending frames, timer starts.
// After `source_timeout` seconds backup starts working, while all other inputs are still trying to
// connect and start working.
// So backup and all inputs are working in parallel.
func (s *StreamConfigStrippedImpl) SetBackup(v BackupConfig) StreamConfigStripped {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*BackupConfigImpl); ok {
		s.BackupValue = impl
	}
	return s
}

// Chunk duration in LL-HLS manifest to be used for tunning latency.
// Format: milliseconds (milliseconds)
// Example: 200
func (s StreamConfigStrippedImpl) ChunkDuration() *Milliseconds {
	return s.ChunkDurationValue
}

// Chunk duration in LL-HLS manifest to be used for tunning latency.
// Format: milliseconds (milliseconds)
// Example: 200
func (s *StreamConfigStrippedImpl) SetChunkDuration(v Milliseconds) StreamConfigStripped {
	if s == nil {
		return nil
	}
	s.ChunkDurationValue = &v
	return s
}

// Stream's lifetime after the last client was disconnected (can be expressed in *seconds* or set to `False`).
// Applicable to on-demand streams **only**.
// Example: 485
func (s StreamConfigStrippedImpl) ClientsTimeout() any {
	return s.ClientsTimeoutValue
}

// Stream's lifetime after the last client was disconnected (can be expressed in *seconds* or set to `False`).
// Applicable to on-demand streams **only**.
// Example: 485
func (s *StreamConfigStrippedImpl) SetClientsTimeout(v any) StreamConfigStripped {
	if s == nil {
		return nil
	}
	s.ClientsTimeoutValue = v
	return s
}

// Human-readable description of the stream.
// Example: This is a test stream
func (s StreamConfigStrippedImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the stream.
// Example: This is a test stream
func (s *StreamConfigStrippedImpl) SetComment(v string) StreamConfigStripped {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Whether a stream is disabled. Disabled streams are inactive and do not run.
// Displayed only with the API calls.
// Example: false
func (s StreamConfigStrippedImpl) Disabled() *bool {
	return s.DisabledValue
}

// Whether a stream is disabled. Disabled streams are inactive and do not run.
// Displayed only with the API calls.
// Example: false
func (s *StreamConfigStrippedImpl) SetDisabled(v bool) StreamConfigStripped {
	if s == nil {
		return nil
	}
	s.DisabledValue = &v
	return s
}

// Configuraton of Digital Rights Management system (DRM).
func (s StreamConfigStrippedImpl) Drm() DrmSpec {
	return s.DrmValue
}

// Configuraton of Digital Rights Management system (DRM).
func (s *StreamConfigStrippedImpl) SetDrm(v DrmSpec) StreamConfigStripped {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*DrmSpecImpl); ok {
		s.DrmValue = impl
	}
	return s
}

// This parameter allows to manage subtitles in an output stream.
// Example: replace
func (s StreamConfigStrippedImpl) Dvbocr() *StreamConfigInputDvbocr {
	return s.DvbocrValue
}

// This parameter allows to manage subtitles in an output stream.
// Example: replace
func (s *StreamConfigStrippedImpl) SetDvbocr(v StreamConfigInputDvbocr) StreamConfigStripped {
	if s == nil {
		return nil
	}
	s.DvbocrValue = &v
	return s
}

// DVR configuraton.
func (s StreamConfigStrippedImpl) Dvr() StreamDvrSpec {
	return s.DvrValue
}

// DVR configuraton.
func (s *StreamConfigStrippedImpl) SetDvr(v StreamDvrSpec) StreamConfigStripped {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*StreamDvrSpecImpl); ok {
		s.DvrValue = impl
	}
	return s
}

// Whether to extract EPG from the input.
// Example: true
func (s StreamConfigStrippedImpl) EpgEnabled() *bool {
	return s.EpgEnabledValue
}

// Whether to extract EPG from the input.
// Example: true
func (s *StreamConfigStrippedImpl) SetEpgEnabled(v bool) StreamConfigStripped {
	if s == nil {
		return nil
	}
	s.EpgEnabledValue = &v
	return s
}

// Whether to enable SCTE-35 ad insertion markers signaling in HLS manifest.
// Ad markers can be included in SCTE-35 (`scte35`), AWS (`aws`), EXT-X-DATERANGE (`rfc8216`) formats or not included (`false`).
// Example: scte35
func (s StreamConfigStrippedImpl) HlsScte35() *StreamConfigMediaHlsScte35 {
	return s.HlsScte35Value
}

// Whether to enable SCTE-35 ad insertion markers signaling in HLS manifest.
// Ad markers can be included in SCTE-35 (`scte35`), AWS (`aws`), EXT-X-DATERANGE (`rfc8216`) formats or not included (`false`).
// Example: scte35
func (s *StreamConfigStrippedImpl) SetHlsScte35(v StreamConfigMediaHlsScte35) StreamConfigStripped {
	if s == nil {
		return nil
	}
	s.HlsScte35Value = &v
	return s
}

// Use this option for fine-grained control over each input track.
// You can select, rename, change name and title for each video, audio track.
func (s StreamConfigStrippedImpl) InputMediaInfo() InputMediaInfo {
	return s.InputMediaInfoValue
}

// Use this option for fine-grained control over each input track.
// You can select, rename, change name and title for each video, audio track.
func (s *StreamConfigStrippedImpl) SetInputMediaInfo(v InputMediaInfo) StreamConfigStripped {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputMediaInfoImpl); ok {
		s.InputMediaInfoValue = impl
	}
	return s
}

// List of stream inputs.
// ***Important:*** A stream without any inputs can receive video frames **only** if backup file is specified.
func (s StreamConfigStrippedImpl) Inputs() []StreamInput {
	if s.InputsValue == nil {
		return nil
	}
	result := make([]StreamInput, len(s.InputsValue))
	for i, item := range s.InputsValue {
		result[i] = item
	}
	return result
}

// List of stream inputs.
// ***Important:*** A stream without any inputs can receive video frames **only** if backup file is specified.
func (s *StreamConfigStrippedImpl) SetInputs(v []StreamInput) StreamConfigStripped {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*StreamInputImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*StreamInputImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.InputsValue = impl
	}
	return s
}

// A key to sign jpeg_snapshot requests
func (s StreamConfigStrippedImpl) JpegSnapshotSignKey() *string {
	return s.JpegSnapshotSignKeyValue
}

// A key to sign jpeg_snapshot requests
func (s *StreamConfigStrippedImpl) SetJpegSnapshotSignKey(v string) StreamConfigStripped {
	if s == nil {
		return nil
	}
	s.JpegSnapshotSignKeyValue = &v
	return s
}

// Stream labels in key value format.
// Key is a string in unix_name format (alphanumeric characters, underscores, hyphens and periods).
// See [Layouter schema](https://flussonic.com/doc/api/layouter/#tag/stream/operation/streams_list/response%7Cstreams%7Clabels)
// for more details.
func (s StreamConfigStrippedImpl) Labels() map[string]UnixName {
	return s.LabelsValue
}

// Stream labels in key value format.
// Key is a string in unix_name format (alphanumeric characters, underscores, hyphens and periods).
// See [Layouter schema](https://flussonic.com/doc/api/layouter/#tag/stream/operation/streams_list/response%7Cstreams%7Clabels)
// for more details.
func (s *StreamConfigStrippedImpl) SetLabels(v map[string]UnixName) StreamConfigStripped {
	if s == nil {
		return nil
	}
	s.LabelsValue = v
	return s
}

// The maximum time that Media Server will set for attempts to reconnect to sources when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s StreamConfigStrippedImpl) MaxRetryTimeout() *Seconds {
	return s.MaxRetryTimeoutValue
}

// The maximum time that Media Server will set for attempts to reconnect to sources when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s *StreamConfigStrippedImpl) SetMaxRetryTimeout(v Seconds) StreamConfigStripped {
	if s == nil {
		return nil
	}
	s.MaxRetryTimeoutValue = &v
	return s
}

// Deprecated field. Will be deleted at 23.12
// The param is deprecated and now used only for onvif_url and onvif_profile options.
func (s StreamConfigStrippedImpl) Meta() map[string]string {
	return s.MetaValue
}

// Deprecated field. Will be deleted at 23.12
// The param is deprecated and now used only for onvif_url and onvif_profile options.
func (s *StreamConfigStrippedImpl) SetMeta(v map[string]string) StreamConfigStripped {
	if s == nil {
		return nil
	}
	s.MetaValue = v
	return s
}

// It allows to specify pack information about ac3 for outgoing MPEGTS-TS streams. The default value is `system_b`.
func (s StreamConfigStrippedImpl) MpegtsAc3() *OutputMpegtsAc3 {
	return s.MpegtsAc3Value
}

// It allows to specify pack information about ac3 for outgoing MPEGTS-TS streams. The default value is `system_b`.
func (s *StreamConfigStrippedImpl) SetMpegtsAc3(v OutputMpegtsAc3) StreamConfigStripped {
	if s == nil {
		return nil
	}
	s.MpegtsAc3Value = &v
	return s
}

// This parameter sets PIDs values for outgoing MPEG-TS streams. PID contains information about the TS package content and can be decoded according to special service tables.
// It is possible to set PID values for PMT, SDT, video, and audio tracks. Tracks are numbered starting from one.
// The code `a1=123` sets a PID value for the first audio track. It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, `t0=100` sets PID=101 for the first track, 102 for the second, and so on. Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s StreamConfigStrippedImpl) MpegtsPids() OutputMpegtsPids {
	return s.MpegtsPidsValue
}

// This parameter sets PIDs values for outgoing MPEG-TS streams. PID contains information about the TS package content and can be decoded according to special service tables.
// It is possible to set PID values for PMT, SDT, video, and audio tracks. Tracks are numbered starting from one.
// The code `a1=123` sets a PID value for the first audio track. It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, `t0=100` sets PID=101 for the first track, 102 for the second, and so on. Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s *StreamConfigStrippedImpl) SetMpegtsPids(v OutputMpegtsPids) StreamConfigStripped {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*OutputMpegtsPidsImpl); ok {
		s.MpegtsPidsValue = impl
	}
	return s
}

// Globally unique stream name.
// Note that the name could not be changed after the stream is created.
// Format: media_name (media_name)
// Examples: Decklink-Stream, Dektec-Stream, hockey1, mylive/bunny, test_stream
func (s StreamConfigStrippedImpl) Name() MediaName {
	return s.NameValue
}

// Globally unique stream name.
// Note that the name could not be changed after the stream is created.
// Format: media_name (media_name)
// Examples: Decklink-Stream, Dektec-Stream, hockey1, mylive/bunny, test_stream
func (s *StreamConfigStrippedImpl) SetName(v MediaName) StreamConfigStripped {
	if s == nil {
		return nil
	}
	s.NameValue = v
	return s
}

// Where the stream is initialized: config, user play/publication, or remote
// cluster server.
// Example: config
func (s StreamConfigStrippedImpl) NamedBy() *NamedBy {
	return s.NamedByValue
}

// Where the stream is initialized: config, user play/publication, or remote
// cluster server.
// Example: config
func (s *StreamConfigStrippedImpl) SetNamedBy(v NamedBy) StreamConfigStripped {
	if s == nil {
		return nil
	}
	s.NamedByValue = &v
	return s
}

// Configuration of authorization backend for play sessions.
func (s StreamConfigStrippedImpl) OnPlay() AuthSpec {
	return s.OnPlayValue
}

// Configuration of authorization backend for play sessions.
func (s *StreamConfigStrippedImpl) SetOnPlay(v AuthSpec) StreamConfigStripped {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*AuthSpecImpl); ok {
		s.OnPlayValue = impl
	}
	return s
}

// Configuration of authorization backend for publish sessions.
func (s StreamConfigStrippedImpl) OnPublish() AuthSpec {
	return s.OnPublishValue
}

// Configuration of authorization backend for publish sessions.
func (s *StreamConfigStrippedImpl) SetOnPublish(v AuthSpec) StreamConfigStripped {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*AuthSpecImpl); ok {
		s.OnPublishValue = impl
	}
	return s
}

// This parameter sets playback HTTP headers for streams.
func (s StreamConfigStrippedImpl) PlaybackHeaders() []PlaybackHeaders {
	if s.PlaybackHeadersValue == nil {
		return nil
	}
	result := make([]PlaybackHeaders, len(s.PlaybackHeadersValue))
	for i, item := range s.PlaybackHeadersValue {
		result[i] = item
	}
	return result
}

// This parameter sets playback HTTP headers for streams.
func (s *StreamConfigStrippedImpl) SetPlaybackHeaders(v []PlaybackHeaders) StreamConfigStripped {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*PlaybackHeadersImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*PlaybackHeadersImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.PlaybackHeadersValue = impl
	}
	return s
}

// Position of the stream in order of streams in the config file, if declared.
// Format: sort_index (sort_index)
// Example: 2
func (s StreamConfigStrippedImpl) Position() *SortIndex {
	return s.PositionValue
}

// Position of the stream in order of streams in the config file, if declared.
// Format: sort_index (sort_index)
// Example: 2
func (s *StreamConfigStrippedImpl) SetPosition(v SortIndex) StreamConfigStripped {
	if s == nil {
		return nil
	}
	s.PositionValue = &v
	return s
}

// The time (in seconds) that Media Server reserves for preloading the data, i. e. *buffering*.
// Prepush is always defined through GoP, but this option provides you with a more flexible way
// to configure the buffer size, e. g. a 1-3 or 7-10 seconds time interval.
// The bigger the buffer size, the better the user experience is for the users
// with a bad internet connection. However, the latency also increases.
// If set to `False` to remove the latency, the stream's start time
// increases. To decrease it, reduce the GoP size and make the bitrate higher
// or the video quality lower.
// Example: false
func (s StreamConfigStrippedImpl) Prepush() any {
	return s.PrepushValue
}

// The time (in seconds) that Media Server reserves for preloading the data, i. e. *buffering*.
// Prepush is always defined through GoP, but this option provides you with a more flexible way
// to configure the buffer size, e. g. a 1-3 or 7-10 seconds time interval.
// The bigger the buffer size, the better the user experience is for the users
// with a bad internet connection. However, the latency also increases.
// If set to `False` to remove the latency, the stream's start time
// increases. To decrease it, reduce the GoP size and make the bitrate higher
// or the video quality lower.
// Example: false
func (s *StreamConfigStrippedImpl) SetPrepush(v any) StreamConfigStripped {
	if s == nil {
		return nil
	}
	s.PrepushValue = v
	return s
}

// Configuration to allow/forbid playing the stream via various protocols.
// - If the `whitelist` option is set to 'true', the server allows a playback only for listed protocols;
// - If the `whitelist` option is set to 'false', the server forbids a playback for listed protocols;
// - Server allows a playback for all the protocols by default.
func (s StreamConfigStrippedImpl) Protocols() PlayProtocolsSpec {
	return s.ProtocolsValue
}

// Configuration to allow/forbid playing the stream via various protocols.
// - If the `whitelist` option is set to 'true', the server allows a playback only for listed protocols;
// - If the `whitelist` option is set to 'false', the server forbids a playback for listed protocols;
// - Server allows a playback for all the protocols by default.
func (s *StreamConfigStrippedImpl) SetProtocols(v PlayProtocolsSpec) StreamConfigStripped {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*PlayProtocolsSpecImpl); ok {
		s.ProtocolsValue = impl
	}
	return s
}

// Deprecated field. Will be deleted at 25.03
// Human-readable name of the content provider. Used, for example, for MPEG-TS.
// Deprecated, use `input_media_info.provider` instead
// Example: SportsTV
func (s StreamConfigStrippedImpl) Provider() *string {
	return s.ProviderValue
}

// Deprecated field. Will be deleted at 25.03
// Human-readable name of the content provider. Used, for example, for MPEG-TS.
// Deprecated, use `input_media_info.provider` instead
// Example: SportsTV
func (s *StreamConfigStrippedImpl) SetProvider(v string) StreamConfigStripped {
	if s == nil {
		return nil
	}
	s.ProviderValue = &v
	return s
}

// A list of pushes. When a server initiates the connection and sends a stream
// to other server(s), it is called a `push`.
func (s StreamConfigStrippedImpl) Pushes() []StreamPush {
	if s.PushesValue == nil {
		return nil
	}
	result := make([]StreamPush, len(s.PushesValue))
	for i, item := range s.PushesValue {
		result[i] = item
	}
	return result
}

// A list of pushes. When a server initiates the connection and sends a stream
// to other server(s), it is called a `push`.
func (s *StreamConfigStrippedImpl) SetPushes(v []StreamPush) StreamConfigStripped {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*StreamPushImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*StreamPushImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.PushesValue = impl
	}
	return s
}

// How often to re-check secondary inputs. If this option is not set than check is never performed.
// Format: seconds (seconds)
// Example: 120
func (s StreamConfigStrippedImpl) RecheckSecondaryInputsInterval() *Seconds {
	return s.RecheckSecondaryInputsIntervalValue
}

// How often to re-check secondary inputs. If this option is not set than check is never performed.
// Format: seconds (seconds)
// Example: 120
func (s *StreamConfigStrippedImpl) SetRecheckSecondaryInputsInterval(v Seconds) StreamConfigStripped {
	if s == nil {
		return nil
	}
	s.RecheckSecondaryInputsIntervalValue = &v
	return s
}

// Number of attempts for the server to reconnect to a data source.
// Applicable to on-demand streams **only**. If not defined, server will constantly try to reconnect (unlimited number of retries).
// If the input does not become active after specified amount of attempts, stream shuts down till the next user request.
func (s StreamConfigStrippedImpl) RetryLimit() *int {
	return s.RetryLimitValue
}

// Number of attempts for the server to reconnect to a data source.
// Applicable to on-demand streams **only**. If not defined, server will constantly try to reconnect (unlimited number of retries).
// If the input does not become active after specified amount of attempts, stream shuts down till the next user request.
func (s *StreamConfigStrippedImpl) SetRetryLimit(v int) StreamConfigStripped {
	if s == nil {
		return nil
	}
	s.RetryLimitValue = &v
	return s
}

// Number of segments stored in memory for the segment-based protocols, such as HLS and DASH.
// Added to HLS live manifest. Do not forget that one more segment is stored for stale clients
// that come too late, but the latest segment is not shown in the manifest.
// Example: 4
func (s StreamConfigStrippedImpl) SegmentCount() *int {
	return s.SegmentCountValue
}

// Number of segments stored in memory for the segment-based protocols, such as HLS and DASH.
// Added to HLS live manifest. Do not forget that one more segment is stored for stale clients
// that come too late, but the latest segment is not shown in the manifest.
// Example: 4
func (s *StreamConfigStrippedImpl) SetSegmentCount(v int) StreamConfigStripped {
	if s == nil {
		return nil
	}
	s.SegmentCountValue = &v
	return s
}

// The time of the segment duration. Used for the protocols like HLS or DASH.
// The disk config offers this value in seconds.
// Example: 5000
func (s StreamConfigStrippedImpl) SegmentDuration() *Milliseconds {
	return s.SegmentDurationValue
}

// The time of the segment duration. Used for the protocols like HLS or DASH.
// The disk config offers this value in seconds.
// Example: 5000
func (s *StreamConfigStrippedImpl) SetSegmentDuration(v Milliseconds) StreamConfigStripped {
	if s == nil {
		return nil
	}
	s.SegmentDurationValue = &v
	return s
}

// If a connected source does not send any data within this timeout period (in seconds),
// the source connection is considered to be lost.
// This is a default configuration for a stream, can be modified for any input.
// Example: 10
func (s StreamConfigStrippedImpl) SourceTimeout() any {
	return s.SourceTimeoutValue
}

// If a connected source does not send any data within this timeout period (in seconds),
// the source connection is considered to be lost.
// This is a default configuration for a stream, can be modified for any input.
// Example: 10
func (s *StreamConfigStrippedImpl) SetSourceTimeout(v any) StreamConfigStripped {
	if s == nil {
		return nil
	}
	s.SourceTimeoutValue = v
	return s
}

// SRT2 publishing configuration for a stream.
func (s StreamConfigStrippedImpl) Srt2Publish() SrtConfig {
	return s.Srt2PublishValue
}

// SRT2 publishing configuration for a stream.
func (s *StreamConfigStrippedImpl) SetSrt2Publish(v SrtConfig) StreamConfigStripped {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*SrtConfigImpl); ok {
		s.Srt2PublishValue = impl
	}
	return s
}

// Deprecated field. Will be deleted at 24.06
// Stream name was resolved via `srt_port_resolve` call.
// See [endpoint](https://flussonic.com/doc/api/config-external/#tag/srt/operation/srt_port_resolve)
// and [listener](https://flussonic.com/doc/api/reference/#tag/config/operation/config_save%7Cbody%7Clisteners%7Csrt)
// for feature description.
// This parameter now lives in `stats` object.
// Example: false
func (s StreamConfigStrippedImpl) SrtPortResolve() *bool {
	return s.SrtPortResolveValue
}

// Deprecated field. Will be deleted at 24.06
// Stream name was resolved via `srt_port_resolve` call.
// See [endpoint](https://flussonic.com/doc/api/config-external/#tag/srt/operation/srt_port_resolve)
// and [listener](https://flussonic.com/doc/api/reference/#tag/config/operation/config_save%7Cbody%7Clisteners%7Csrt)
// for feature description.
// This parameter now lives in `stats` object.
// Example: false
func (s *StreamConfigStrippedImpl) SetSrtPortResolve(v bool) StreamConfigStripped {
	if s == nil {
		return nil
	}
	s.SrtPortResolveValue = &v
	return s
}

// SRT publishing configuration for a stream.
func (s StreamConfigStrippedImpl) SrtPublish() SrtConfig {
	return s.SrtPublishValue
}

// SRT publishing configuration for a stream.
func (s *StreamConfigStrippedImpl) SetSrtPublish(v SrtConfig) StreamConfigStripped {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*SrtConfigImpl); ok {
		s.SrtPublishValue = impl
	}
	return s
}

// Whether a stream is `static` or not.
// If set to `True` the server will try to keep this stream running even if
// there are no viewers or errors encountered.
// Streamer restarts *all* `static` streams even if any internal errors occur
// and the `static` streams crash.
// Example: true
func (s StreamConfigStrippedImpl) Static() *bool {
	return s.StaticValue
}

// Whether a stream is `static` or not.
// If set to `True` the server will try to keep this stream running even if
// there are no viewers or errors encountered.
// Streamer restarts *all* `static` streams even if any internal errors occur
// and the `static` streams crash.
// Example: true
func (s *StreamConfigStrippedImpl) SetStatic(v bool) StreamConfigStripped {
	if s == nil {
		return nil
	}
	s.StaticValue = &v
	return s
}

// Template of the stream.
// Format: media_name (media_name)
// Example: sports-hd
func (s StreamConfigStrippedImpl) Template() *MediaName {
	return s.TemplateValue
}

// Template of the stream.
// Format: media_name (media_name)
// Example: sports-hd
func (s *StreamConfigStrippedImpl) SetTemplate(v MediaName) StreamConfigStripped {
	if s == nil {
		return nil
	}
	s.TemplateValue = &v
	return s
}

// Configuration of thumbnails generator.
func (s StreamConfigStrippedImpl) Thumbnails() ThumbnailsSpec {
	return s.ThumbnailsValue
}

// Configuration of thumbnails generator.
func (s *StreamConfigStrippedImpl) SetThumbnails(v ThumbnailsSpec) StreamConfigStripped {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ThumbnailsSpecImpl); ok {
		s.ThumbnailsValue = impl
	}
	return s
}

// Human-readable title of the stream. Provided for SDT MPEG-TS table or
// SDP RTSP title parameter.
// Example: Hockey channel
func (s StreamConfigStrippedImpl) Title() *string {
	return s.TitleValue
}

// Human-readable title of the stream. Provided for SDT MPEG-TS table or
// SDP RTSP title parameter.
// Example: Hockey channel
func (s *StreamConfigStrippedImpl) SetTitle(v string) StreamConfigStripped {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// Configuration of the transcoder settings.
// Examples: map[]
func (s StreamConfigStrippedImpl) Transcoder() TranscoderOpts {
	return s.TranscoderValue
}

// Configuration of the transcoder settings.
// Examples: map[]
func (s *StreamConfigStrippedImpl) SetTranscoder(v TranscoderOpts) StreamConfigStripped {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*TranscoderOptsImpl); ok {
		s.TranscoderValue = impl
	}
	return s
}

// Transport protocol for WebRTC.
func (s StreamConfigStrippedImpl) Transport() *WebrtcTransport {
	return s.TransportValue
}

// Transport protocol for WebRTC.
func (s *StreamConfigStrippedImpl) SetTransport(v WebrtcTransport) StreamConfigStripped {
	if s == nil {
		return nil
	}
	s.TransportValue = &v
	return s
}

// A string starting the addresses of separate segments within a *segment-based* playlists (HLS or DASH).
// Each sub-playlist is stored on Media Server.
// If set to `false`, the configured value in a template will be disabled.
func (s StreamConfigStrippedImpl) URLPrefix() *URLPrefix {
	return s.URLPrefixValue
}

// A string starting the addresses of separate segments within a *segment-based* playlists (HLS or DASH).
// Each sub-playlist is stored on Media Server.
// If set to `false`, the configured value in a template will be disabled.
func (s *StreamConfigStrippedImpl) SetURLPrefix(v *URLPrefix) StreamConfigStripped {
	if s == nil {
		return nil
	}
	s.URLPrefixValue = v
	return s
}

// If a connected source does not send video data within this timeout period (in seconds),
// the source connection is considered to be lost.
// This is a default configuration for a stream, can be modified for any input.
// Format: seconds (seconds)
// Example: 20
func (s StreamConfigStrippedImpl) VideoTimeout() *Seconds {
	return s.VideoTimeoutValue
}

// If a connected source does not send video data within this timeout period (in seconds),
// the source connection is considered to be lost.
// This is a default configuration for a stream, can be modified for any input.
// Format: seconds (seconds)
// Example: 20
func (s *StreamConfigStrippedImpl) SetVideoTimeout(v Seconds) StreamConfigStripped {
	if s == nil {
		return nil
	}
	s.VideoTimeoutValue = &v
	return s
}

// Video analytics parameters.
func (s StreamConfigStrippedImpl) Vision() VisionSpec {
	return s.VisionValue
}

// Video analytics parameters.
func (s *StreamConfigStrippedImpl) SetVision(v VisionSpec) StreamConfigStripped {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionSpecImpl); ok {
		s.VisionValue = impl
	}
	return s
}

// WebRTC play configuration for a stream.
func (s StreamConfigStrippedImpl) WebrtcAbr() WebrtcAbrOpts {
	return s.WebrtcAbrValue
}

// WebRTC play configuration for a stream.
func (s *StreamConfigStrippedImpl) SetWebrtcAbr(v WebrtcAbrOpts) StreamConfigStripped {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*WebrtcAbrOptsImpl); ok {
		s.WebrtcAbrValue = impl
	}
	return s
}

// NewStreamDvrSpec creates a new StreamDvrSpec instance
func NewStreamDvrSpec() StreamDvrSpec {
	return &StreamDvrSpecImpl{}
}

// Maximum disk consumption in percents. When this limit is reached,
// the oldest segment of the recording will be overridden by later data.
// It important to understand that this is not a "per-stream" option, this option means
// that cleaning of this stream will be triggered if overall disk usage reaches this number.
// If you have all streams with configuration 98% and one stream with 95%, it will be permanently
// empty.
// Format: percent (percent)
// Example: 98
func (s StreamDvrSpecImpl) DiskUsageLimit() *Percent {
	return s.DiskUsageLimitValue
}

// Maximum disk consumption in percents. When this limit is reached,
// the oldest segment of the recording will be overridden by later data.
// It important to understand that this is not a "per-stream" option, this option means
// that cleaning of this stream will be triggered if overall disk usage reaches this number.
// If you have all streams with configuration 98% and one stream with 95%, it will be permanently
// empty.
// Format: percent (percent)
// Example: 98
func (s *StreamDvrSpecImpl) SetDiskUsageLimit(v Percent) StreamDvrSpec {
	if s == nil {
		return nil
	}
	s.DiskUsageLimitValue = &v
	return s
}

// Additional archive depth in seconds for episodes. If set, episodes and their corresponding DVR record
// will be saved for `expiration + episodes_expiration` seconds.
// The archive clean-up within `[expiration, expiration+episodes_expiration]` seconds of the
// recording performed depending on [external_episodes_list](https://flussonic.com/doc/api/config-external/#tag/dvr/operation/external_episodes_list)
// response of `episodes_url`.
// Anything older than `expiration+episodes_expiration` seconds will
// be cleaned even if `episodes_url` does not respond.
// Format: seconds (seconds)
// Examples: 6.048e+06
func (s StreamDvrSpecImpl) EpisodesExpiration() *Seconds {
	return s.EpisodesExpirationValue
}

// Additional archive depth in seconds for episodes. If set, episodes and their corresponding DVR record
// will be saved for `expiration + episodes_expiration` seconds.
// The archive clean-up within `[expiration, expiration+episodes_expiration]` seconds of the
// recording performed depending on [external_episodes_list](https://flussonic.com/doc/api/config-external/#tag/dvr/operation/external_episodes_list)
// response of `episodes_url`.
// Anything older than `expiration+episodes_expiration` seconds will
// be cleaned even if `episodes_url` does not respond.
// Format: seconds (seconds)
// Examples: 6.048e+06
func (s *StreamDvrSpecImpl) SetEpisodesExpiration(v Seconds) StreamDvrSpec {
	if s == nil {
		return nil
	}
	s.EpisodesExpirationValue = &v
	return s
}

// External URL that will be triggered for fetching episodes list.
// Take a look at config_external API for method `external_episodes_list`.
// If the `episodes_url` not set or responds with any HTTP code other than `200` or `501` or does not respond within a timeout,
// the archive clean-up is only performed by `episodes_expiration` time while `expiration` and `storage_limit` are ignored until the `episodes_url` restores.
// If `episodes_url` is a blank string, then current config_external API endpoint will be used to request episodes.
// It is most common usage of this field.
// Examples: , http://central-host.local/config-external/episodes
func (s StreamDvrSpecImpl) EpisodesURL() *string {
	return s.EpisodesURLValue
}

// External URL that will be triggered for fetching episodes list.
// Take a look at config_external API for method `external_episodes_list`.
// If the `episodes_url` not set or responds with any HTTP code other than `200` or `501` or does not respond within a timeout,
// the archive clean-up is only performed by `episodes_expiration` time while `expiration` and `storage_limit` are ignored until the `episodes_url` restores.
// If `episodes_url` is a blank string, then current config_external API endpoint will be used to request episodes.
// It is most common usage of this field.
// Examples: , http://central-host.local/config-external/episodes
func (s *StreamDvrSpecImpl) SetEpisodesURL(v string) StreamDvrSpec {
	if s == nil {
		return nil
	}
	s.EpisodesURLValue = &v
	return s
}

// Archive depth - a period (in seconds) back from the current moment during which the
// contigious part of archive is stored.
// As time goes, the parts of the recording which are older than the archive depth are deleted.
// If you have option `episodes_expiration` enabled, then some parts of DVR that are
// locked by episode signalling mechanism may be kept more than this `expiration` depth.
// If `episodes_url` does not respond, the archive clean-up by `expiration` is not performed;
// only the archive with expired episodes (`episodes_expiration`) is cleaned up until the `episodes_url` restores.
// Format: seconds (seconds)
// Examples: 604800
func (s StreamDvrSpecImpl) Expiration() *Seconds {
	return s.ExpirationValue
}

// Archive depth - a period (in seconds) back from the current moment during which the
// contigious part of archive is stored.
// As time goes, the parts of the recording which are older than the archive depth are deleted.
// If you have option `episodes_expiration` enabled, then some parts of DVR that are
// locked by episode signalling mechanism may be kept more than this `expiration` depth.
// If `episodes_url` does not respond, the archive clean-up by `expiration` is not performed;
// only the archive with expired episodes (`episodes_expiration`) is cleaned up until the `episodes_url` restores.
// Format: seconds (seconds)
// Examples: 604800
func (s *StreamDvrSpecImpl) SetExpiration(v Seconds) StreamDvrSpec {
	if s == nil {
		return nil
	}
	s.ExpirationValue = &v
	return s
}

// How many servers will contain a copy of the DVR archive.
// You can find more information [here](https://flussonic.com/doc/api/layouter/#tag/stream/operation/streams_list/response%7Cstreams%7Cdvr%7Credundancy_factor)
// Example: 1
func (s StreamDvrSpecImpl) RedundancyFactor() *int {
	return s.RedundancyFactorValue
}

// How many servers will contain a copy of the DVR archive.
// You can find more information [here](https://flussonic.com/doc/api/layouter/#tag/stream/operation/streams_list/response%7Cstreams%7Cdvr%7Credundancy_factor)
// Example: 1
func (s *StreamDvrSpecImpl) SetRedundancyFactor(v int) StreamDvrSpec {
	if s == nil {
		return nil
	}
	s.RedundancyFactorValue = &v
	return s
}

// Stream can refer to the globally declared DVR. This option referres to a single DVR entry.
// Format: dvr_name (dvr_name)
// Example: localdvr0
func (s StreamDvrSpecImpl) Reference() *DvrName {
	return s.ReferenceValue
}

// Stream can refer to the globally declared DVR. This option referres to a single DVR entry.
// Format: dvr_name (dvr_name)
// Example: localdvr0
func (s *StreamDvrSpecImpl) SetReference(v DvrName) StreamDvrSpec {
	if s == nil {
		return nil
	}
	s.ReferenceValue = &v
	return s
}

// The address of the source from which Media server will read the archive. This address will not be used for capturing live video, it is strictly for data exchange on the availability of the archive and the transmission of segments.
func (s StreamDvrSpecImpl) Remotes() []DvrURL {
	return s.RemotesValue
}

// The address of the source from which Media server will read the archive. This address will not be used for capturing live video, it is strictly for data exchange on the availability of the archive and the transmission of segments.
func (s *StreamDvrSpecImpl) SetRemotes(v []DvrURL) StreamDvrSpec {
	if s == nil {
		return nil
	}
	s.RemotesValue = v
	return s
}

// One or several time intervals for recording by schedule.
// The beginning and the end of each interval are set in "hhmm" format (without leading zeros ) according to UTC standard.
// For example, `2330` is for 23:30, `800` - for 08:00. The interval can go over midnight, e.g. 22:00-1:30. In this case it is set as follows: `[2200,130]`.
// Scheduled recording can be useful for the channels with part-time broadcasting.
// It allows to save disk space significantly.
// Example: [[800 1600] [2200 130]]
func (s StreamDvrSpecImpl) Schedule() [][]int {
	return s.ScheduleValue
}

// One or several time intervals for recording by schedule.
// The beginning and the end of each interval are set in "hhmm" format (without leading zeros ) according to UTC standard.
// For example, `2330` is for 23:30, `800` - for 08:00. The interval can go over midnight, e.g. 22:00-1:30. In this case it is set as follows: `[2200,130]`.
// Scheduled recording can be useful for the channels with part-time broadcasting.
// It allows to save disk space significantly.
// Example: [[800 1600] [2200 130]]
func (s *StreamDvrSpecImpl) SetSchedule(v [][]int) StreamDvrSpec {
	if s == nil {
		return nil
	}
	s.ScheduleValue = v
	return s
}

// Maximum disk consumption in bytes. When this limit is reached,
// the oldest segment of the recording will be overridden by later data.
// This option affects both continuous recording and locked episodes (see `episodes_url`).
// If `episodes_url` does not respond, the archive clean-up by `storage_limit` is not performed
// to avoid deleting the recordings that should not be deleted.
// Format: bytes (bytes)
// Example: 4e+11
func (s StreamDvrSpecImpl) StorageLimit() *Bytes {
	return s.StorageLimitValue
}

// Maximum disk consumption in bytes. When this limit is reached,
// the oldest segment of the recording will be overridden by later data.
// This option affects both continuous recording and locked episodes (see `episodes_url`).
// If `episodes_url` does not respond, the archive clean-up by `storage_limit` is not performed
// to avoid deleting the recordings that should not be deleted.
// Format: bytes (bytes)
// Example: 4e+11
func (s *StreamDvrSpecImpl) SetStorageLimit(v Bytes) StreamDvrSpec {
	if s == nil {
		return nil
	}
	s.StorageLimitValue = &v
	return s
}

// NewStreamDvrSpecificSpec creates a new StreamDvrSpecificSpec instance
func NewStreamDvrSpecificSpec() StreamDvrSpecificSpec {
	return &StreamDvrSpecificSpecImpl{}
}

// How many servers will contain a copy of the DVR archive.
// You can find more information [here](https://flussonic.com/doc/api/layouter/#tag/stream/operation/streams_list/response%7Cstreams%7Cdvr%7Credundancy_factor)
// Example: 1
func (s StreamDvrSpecificSpecImpl) RedundancyFactor() *int {
	return s.RedundancyFactorValue
}

// How many servers will contain a copy of the DVR archive.
// You can find more information [here](https://flussonic.com/doc/api/layouter/#tag/stream/operation/streams_list/response%7Cstreams%7Cdvr%7Credundancy_factor)
// Example: 1
func (s *StreamDvrSpecificSpecImpl) SetRedundancyFactor(v int) StreamDvrSpecificSpec {
	if s == nil {
		return nil
	}
	s.RedundancyFactorValue = &v
	return s
}

// Stream can refer to the globally declared DVR. This option referres to a single DVR entry.
// Format: dvr_name (dvr_name)
// Example: localdvr0
func (s StreamDvrSpecificSpecImpl) Reference() *DvrName {
	return s.ReferenceValue
}

// Stream can refer to the globally declared DVR. This option referres to a single DVR entry.
// Format: dvr_name (dvr_name)
// Example: localdvr0
func (s *StreamDvrSpecificSpecImpl) SetReference(v DvrName) StreamDvrSpecificSpec {
	if s == nil {
		return nil
	}
	s.ReferenceValue = &v
	return s
}

// The address of the source from which Media server will read the archive. This address will not be used for capturing live video, it is strictly for data exchange on the availability of the archive and the transmission of segments.
func (s StreamDvrSpecificSpecImpl) Remotes() []DvrURL {
	return s.RemotesValue
}

// The address of the source from which Media server will read the archive. This address will not be used for capturing live video, it is strictly for data exchange on the availability of the archive and the transmission of segments.
func (s *StreamDvrSpecificSpecImpl) SetRemotes(v []DvrURL) StreamDvrSpecificSpec {
	if s == nil {
		return nil
	}
	s.RemotesValue = v
	return s
}

// NewStreamInput creates a new StreamInput instance
func NewStreamInput() StreamInput {
	return &StreamInputImpl{}
}

// Audio interface for capturing from the Decklink card.
// Usually, it is autodetected, but for some Decklink models you should specify it manually.
// Example: microphone
func (s StreamInputImpl) Ainput() any {
	return s.AinputValue
}

// Audio interface for capturing from the Decklink card.
// Usually, it is autodetected, but for some Decklink models you should specify it manually.
// Example: microphone
func (s *StreamInputImpl) SetAinput(v any) StreamInput {
	if s == nil {
		return nil
	}
	s.AinputValue = v
	return s
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s StreamInputImpl) AllowIf() *string {
	return s.AllowIfValue
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s *StreamInputImpl) SetAllowIf(v string) StreamInput {
	if s == nil {
		return nil
	}
	s.AllowIfValue = &v
	return s
}

// Synchronization mode for audio captured from the Decklink card.
func (s StreamInputImpl) Apts() *StreamInputDecklinkApts {
	return s.AptsValue
}

// Synchronization mode for audio captured from the Decklink card.
func (s *StreamInputImpl) SetApts(v *StreamInputDecklinkApts) StreamInput {
	if s == nil {
		return nil
	}
	s.AptsValue = v
	return s
}

// Deprecated field. Will be deleted at 23.09
// Moves audio timestamp forwards or backwards on a specified number of milliseconds.
// Format: milliseconds (milliseconds)
func (s StreamInputImpl) AudioAdd() *Milliseconds {
	return s.AudioAddValue
}

// Deprecated field. Will be deleted at 23.09
// Moves audio timestamp forwards or backwards on a specified number of milliseconds.
// Format: milliseconds (milliseconds)
func (s *StreamInputImpl) SetAudioAdd(v Milliseconds) StreamInput {
	if s == nil {
		return nil
	}
	s.AudioAddValue = &v
	return s
}

// H323 audio bitrate.
// Format: speed (speed)
func (s StreamInputImpl) AudioBitrate() *Speed {
	return s.AudioBitrateValue
}

// H323 audio bitrate.
// Format: speed (speed)
func (s *StreamInputImpl) SetAudioBitrate(v Speed) StreamInput {
	if s == nil {
		return nil
	}
	s.AudioBitrateValue = &v
	return s
}

// The audio device to capture audio from Stream Labs SDI cards.
// This parameter is specified for ALSA devices in the following format `interface:card,device`.
// Example: plughw:1,0
func (s StreamInputImpl) AudioDevice() *string {
	return s.AudioDeviceValue
}

// The audio device to capture audio from Stream Labs SDI cards.
// This parameter is specified for ALSA devices in the following format `interface:card,device`.
// Example: plughw:1,0
func (s *StreamInputImpl) SetAudioDevice(v string) StreamInput {
	if s == nil {
		return nil
	}
	s.AudioDeviceValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputImpl) AudioTimeout() *Seconds {
	return s.AudioTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputImpl) SetAudioTimeout(v Seconds) StreamInput {
	if s == nil {
		return nil
	}
	s.AudioTimeoutValue = &v
	return s
}

// Optional bind core
func (s StreamInputImpl) BindToCore() *int {
	return s.BindToCoreValue
}

// Optional bind core
func (s *StreamInputImpl) SetBindToCore(v int) StreamInput {
	if s == nil {
		return nil
	}
	s.BindToCoreValue = &v
	return s
}

// Bitrate of the audio.
// Format: speed (speed)
func (s StreamInputImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// Bitrate of the audio.
// Format: speed (speed)
func (s *StreamInputImpl) SetBitrate(v Speed) StreamInput {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// The rules for handling the closed captions.
func (s StreamInputImpl) ClosedCaptions() map[string]string {
	return s.ClosedCaptionsValue
}

// The rules for handling the closed captions.
func (s *StreamInputImpl) SetClosedCaptions(v map[string]string) StreamInput {
	if s == nil {
		return nil
	}
	s.ClosedCaptionsValue = v
	return s
}

// Human-readable description of the input.
// Example: This is a test input
func (s StreamInputImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the input.
// Example: This is a test input
func (s *StreamInputImpl) SetComment(v string) StreamInput {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// H323 connections.
func (s StreamInputImpl) Connections() *int {
	return s.ConnectionsValue
}

// H323 connections.
func (s *StreamInputImpl) SetConnections(v int) StreamInput {
	if s == nil {
		return nil
	}
	s.ConnectionsValue = &v
	return s
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s StreamInputImpl) DenyIf() *string {
	return s.DenyIfValue
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s *StreamInputImpl) SetDenyIf(v string) StreamInput {
	if s == nil {
		return nil
	}
	s.DenyIfValue = &v
	return s
}

// Whether both connection parties must have the same password set (including empty, in other words, with no encryption).
// If the passwords do not match or only one side is unencrypted, the connection is rejected.
// The default value is `true`.
// Example: true
func (s StreamInputImpl) Enforcedencryption() *bool {
	return s.EnforcedencryptionValue
}

// Whether both connection parties must have the same password set (including empty, in other words, with no encryption).
// If the passwords do not match or only one side is unencrypted, the connection is rejected.
// The default value is `true`.
// Example: true
func (s *StreamInputImpl) SetEnforcedencryption(v bool) StreamInput {
	if s == nil {
		return nil
	}
	s.EnforcedencryptionValue = &v
	return s
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s StreamInputImpl) FramesTimeout() *int {
	return s.FramesTimeoutValue
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s *StreamInputImpl) SetFramesTimeout(v int) StreamInput {
	if s == nil {
		return nil
	}
	s.FramesTimeoutValue = &v
	return s
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s StreamInputImpl) Headers() map[string]string {
	return s.HeadersValue
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s *StreamInputImpl) SetHeaders(v map[string]string) StreamInput {
	if s == nil {
		return nil
	}
	s.HeadersValue = v
	return s
}

// Must specify received pixel height
func (s StreamInputImpl) Height() *int {
	return s.HeightValue
}

// Must specify received pixel height
func (s *StreamInputImpl) SetHeight(v int) StreamInput {
	if s == nil {
		return nil
	}
	s.HeightValue = &v
	return s
}

// H323 input ID.
func (s StreamInputImpl) ID() *string {
	return s.IDValue
}

// H323 input ID.
func (s *StreamInputImpl) SetID(v string) StreamInput {
	if s == nil {
		return nil
	}
	s.IDValue = &v
	return s
}

// An array of MPEG-TS language descriptors in format `[{key: track, value: language}]`
func (s StreamInputImpl) Languages() map[string]string {
	return s.LanguagesValue
}

// An array of MPEG-TS language descriptors in format `[{key: track, value: language}]`
func (s *StreamInputImpl) SetLanguages(v map[string]string) StreamInput {
	if s == nil {
		return nil
	}
	s.LanguagesValue = v
	return s
}

// The latency value for both directions of the socket.
// By default initial value latency is 0 when transmitting and 120ms when receiving video.
// Actual value established after connection handshake.
// Increased value helps tolerate network losses and delays.
// Format: milliseconds (milliseconds)
// Example: 150
func (s StreamInputImpl) Latency() *Milliseconds {
	return s.LatencyValue
}

// The latency value for both directions of the socket.
// By default initial value latency is 0 when transmitting and 120ms when receiving video.
// Actual value established after connection handshake.
// Increased value helps tolerate network losses and delays.
// Format: milliseconds (milliseconds)
// Example: 150
func (s *StreamInputImpl) SetLatency(v Milliseconds) StreamInput {
	if s == nil {
		return nil
	}
	s.LatencyValue = &v
	return s
}

// The time, in seconds, that the socket waits for the unsent data before closing.
// The default value is 180.
// Format: seconds (seconds)
// Example: 15
func (s StreamInputImpl) Linger() *Seconds {
	return s.LingerValue
}

// The time, in seconds, that the socket waits for the unsent data before closing.
// The default value is 180.
// Format: seconds (seconds)
// Example: 15
func (s *StreamInputImpl) SetLinger(v Seconds) StreamInput {
	if s == nil {
		return nil
	}
	s.LingerValue = &v
	return s
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s StreamInputImpl) MaxRetryTimeout() *Seconds {
	return s.MaxRetryTimeoutValue
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s *StreamInputImpl) SetMaxRetryTimeout(v Seconds) StreamInput {
	if s == nil {
		return nil
	}
	s.MaxRetryTimeoutValue = &v
	return s
}

// The minimum SRT version that is required from the peer for SRT publication.
// Pattern: ^[0-9]+\.[0-9]+\.[0-9]+$
// Example: 1.1.0
func (s StreamInputImpl) Minversion() *string {
	return s.MinversionValue
}

// The minimum SRT version that is required from the peer for SRT publication.
// Pattern: ^[0-9]+\.[0-9]+\.[0-9]+$
// Example: 1.1.0
func (s *StreamInputImpl) SetMinversion(v string) StreamInput {
	if s == nil {
		return nil
	}
	s.MinversionValue = &v
	return s
}

// The mixing mode for the `mixer://` input type.
func (s StreamInputImpl) MixerStrategy() *StreamInputMixerMixerStrategy {
	return s.MixerStrategyValue
}

// The mixing mode for the `mixer://` input type.
func (s *StreamInputImpl) SetMixerStrategy(v StreamInputMixerMixerStrategy) StreamInput {
	if s == nil {
		return nil
	}
	s.MixerStrategyValue = &v
	return s
}

// Mode of the input stream captured from the Decklink card. It is composed of the size and FPS of the captured video.
// Usually, it is autodetected, but for some Decklink models you'll need to specify it manually.
// Example: 4d30
func (s StreamInputImpl) Mode() *string {
	return s.ModeValue
}

// Mode of the input stream captured from the Decklink card. It is composed of the size and FPS of the captured video.
// Usually, it is autodetected, but for some Decklink models you'll need to specify it manually.
// Example: 4d30
func (s *StreamInputImpl) SetMode(v string) StreamInput {
	if s == nil {
		return nil
	}
	s.ModeValue = &v
	return s
}

// Skip input start if the stream has no clients.
func (s StreamInputImpl) NoClientsReconnectDelay() *int {
	return s.NoClientsReconnectDelayValue
}

// Skip input start if the stream has no clients.
func (s *StreamInputImpl) SetNoClientsReconnectDelay(v int) StreamInput {
	if s == nil {
		return nil
	}
	s.NoClientsReconnectDelayValue = &v
	return s
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s StreamInputImpl) OutputAudio() *OutputAudio {
	return s.OutputAudioValue
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s *StreamInputImpl) SetOutputAudio(v OutputAudio) StreamInput {
	if s == nil {
		return nil
	}
	s.OutputAudioValue = &v
	return s
}

// URL of the web page from where the SWF file was loaded.
// This is an RTMP header (Referer) used for establishing connection.
// Format: url (url)
// Example: http://somehost/sample.html
func (s StreamInputImpl) Pageurl() *URL {
	return s.PageurlValue
}

// URL of the web page from where the SWF file was loaded.
// This is an RTMP header (Referer) used for establishing connection.
// Format: url (url)
// Example: http://somehost/sample.html
func (s *StreamInputImpl) SetPageurl(v URL) StreamInput {
	if s == nil {
		return nil
	}
	s.PageurlValue = &v
	return s
}

// The password for the encrypted transmission.
// Its length should be not less than 10 and not more than 79 characters.
// Unlike [password](https://flussonic.com/doc/api/reference/#tag/stream/operation/stream_save%7Cbody%7Cpassword),
// the passphrase is not transmitted openly but is used to encrypt the key that is transmitted by the Caller
// and decoded by Listener.
// Example: 9876543210
func (s StreamInputImpl) Passphrase() *string {
	return s.PassphraseValue
}

// The password for the encrypted transmission.
// Its length should be not less than 10 and not more than 79 characters.
// Unlike [password](https://flussonic.com/doc/api/reference/#tag/stream/operation/stream_save%7Cbody%7Cpassword),
// the passphrase is not transmitted openly but is used to encrypt the key that is transmitted by the Caller
// and decoded by Listener.
// Example: 9876543210
func (s *StreamInputImpl) SetPassphrase(v string) StreamInput {
	if s == nil {
		return nil
	}
	s.PassphraseValue = &v
	return s
}

// Choose a specific PID to ingest from an MPEG-TS stream.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Example: [211]
func (s StreamInputImpl) Pids() []int {
	return s.PidsValue
}

// Choose a specific PID to ingest from an MPEG-TS stream.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Example: [211]
func (s *StreamInputImpl) SetPids(v []int) StreamInput {
	if s == nil {
		return nil
	}
	s.PidsValue = v
	return s
}

// Preferred pixel format for captured video.
func (s StreamInputImpl) Pixel() any {
	return s.PixelValue
}

// Preferred pixel format for captured video.
func (s *StreamInputImpl) SetPixel(v any) StreamInput {
	if s == nil {
		return nil
	}
	s.PixelValue = v
	return s
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s StreamInputImpl) Priority() *int {
	return s.PriorityValue
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s *StreamInputImpl) SetPriority(v int) StreamInput {
	if s == nil {
		return nil
	}
	s.PriorityValue = &v
	return s
}

// Choose a program to ingest from an MPEG-TS stream.
// Example: [1]
func (s StreamInputImpl) Programs() []int {
	return s.ProgramsValue
}

// Choose a program to ingest from an MPEG-TS stream.
// Example: [1]
func (s *StreamInputImpl) SetPrograms(v []int) StreamInput {
	if s == nil {
		return nil
	}
	s.ProgramsValue = v
	return s
}

// Source for PTS for input stream.
func (s StreamInputImpl) PtsSource() *StreamInputDektecPtsSource {
	return s.PtsSourceValue
}

// Source for PTS for input stream.
func (s *StreamInputImpl) SetPtsSource(v StreamInputDektecPtsSource) StreamInput {
	if s == nil {
		return nil
	}
	s.PtsSourceValue = &v
	return s
}

// The ratio of the width of the display representation to the width of the pixel representation of video.
// This parameter is used for creating non-anamorphic video from anamorphic video.
// Example: 16:9
func (s StreamInputImpl) Sar() *string {
	return s.SarValue
}

// The ratio of the width of the display representation to the width of the pixel representation of video.
// This parameter is used for creating non-anamorphic video from anamorphic video.
// Example: 16:9
func (s *StreamInputImpl) SetSar(v string) StreamInput {
	if s == nil {
		return nil
	}
	s.SarValue = &v
	return s
}

// This option disables processing of SCTE-35 markers from an MPEG-TS input stream.
// Deprecated since 22.12.
// Available ways to disable processing of SCTE-35 markers:
// 1. pids option to select tracks without SCTE-35 markers
// 2. hls_scte35 option from stream_config_media for hls output
// 3. performing appropriate tuning pids in the transponder
// /This option disables processing of SCTE-35 markers from SRT input stream.
func (s StreamInputImpl) Scte35() *bool {
	return s.Scte35Value
}

// This option disables processing of SCTE-35 markers from an MPEG-TS input stream.
// Deprecated since 22.12.
// Available ways to disable processing of SCTE-35 markers:
// 1. pids option to select tracks without SCTE-35 markers
// 2. hls_scte35 option from stream_config_media for hls output
// 3. performing appropriate tuning pids in the transponder
// /This option disables processing of SCTE-35 markers from SRT input stream.
func (s *StreamInputImpl) SetScte35(v bool) StreamInput {
	if s == nil {
		return nil
	}
	s.Scte35Value = &v
	return s
}

// Size of shared memory buffer. Omit to make it auto
// Example: 1.024e+06
func (s StreamInputImpl) ShmemSize() *int {
	return s.ShmemSizeValue
}

// Size of shared memory buffer. Omit to make it auto
// Example: 1.024e+06
func (s *StreamInputImpl) SetShmemSize(v int) StreamInput {
	if s == nil {
		return nil
	}
	s.ShmemSizeValue = &v
	return s
}

// By default Flussonic will wait for at least 2-3 new segments before making stream available.
// This parameter allows to disable this protection. Use it at your own risk - with it enabled, old content might be repeated over and over.
func (s StreamInputImpl) SkipStalledCheck() *bool {
	return s.SkipStalledCheckValue
}

// By default Flussonic will wait for at least 2-3 new segments before making stream available.
// This parameter allows to disable this protection. Use it at your own risk - with it enabled, old content might be repeated over and over.
func (s *StreamInputImpl) SetSkipStalledCheck(v bool) StreamInput {
	if s == nil {
		return nil
	}
	s.SkipStalledCheckValue = &v
	return s
}

// Directory for shmem files
// Example: tmp
func (s StreamInputImpl) SocketDir() *string {
	return s.SocketDirValue
}

// Directory for shmem files
// Example: tmp
func (s *StreamInputImpl) SetSocketDir(v string) StreamInput {
	if s == nil {
		return nil
	}
	s.SocketDirValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s StreamInputImpl) SourceTimeout() any {
	return s.SourceTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s *StreamInputImpl) SetSourceTimeout(v any) StreamInput {
	if s == nil {
		return nil
	}
	s.SourceTimeoutValue = v
	return s
}

// Detailed runtime information about the input.
func (s StreamInputImpl) Stats() InputStats {
	return s.StatsValue
}

// Detailed runtime information about the input.
func (s *StreamInputImpl) SetStats(v InputStats) StreamInput {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// A string of maximum 512 characters set on the socket before the connection.
// This string is a part of a callback that is sent by the caller and regisered by the listener.
// Based on this information the listener can accept or reject the connection, select the desired data stream, or set an appropriate passphrase for the connection.
// Its format is `#!::` optionally followed by the parameters:
// * `r=` - stream name
// * `m=` - mode expected for the connection: `publish` (if the caller wants to send the stream data) or `request` (if the caller wants to receive the stream).
// * `password=` - a password for the authorization in a publish session (not recommended, better use `passphrase` option instead)
// During SRT sessions the following parameters are automaticly added to streamid:
// * `s=` - the identifier of a session
// * `a=` - Flussonic version
// NOTE: you can specify a string in the format you need; to disable this extension, you need specify empty string.
// Example: #!::r=my-stream,m=publish
func (s StreamInputImpl) Streamid() *string {
	return s.StreamidValue
}

// A string of maximum 512 characters set on the socket before the connection.
// This string is a part of a callback that is sent by the caller and regisered by the listener.
// Based on this information the listener can accept or reject the connection, select the desired data stream, or set an appropriate passphrase for the connection.
// Its format is `#!::` optionally followed by the parameters:
// * `r=` - stream name
// * `m=` - mode expected for the connection: `publish` (if the caller wants to send the stream data) or `request` (if the caller wants to receive the stream).
// * `password=` - a password for the authorization in a publish session (not recommended, better use `passphrase` option instead)
// During SRT sessions the following parameters are automaticly added to streamid:
// * `s=` - the identifier of a session
// * `a=` - Flussonic version
// NOTE: you can specify a string in the format you need; to disable this extension, you need specify empty string.
// Example: #!::r=my-stream,m=publish
func (s *StreamInputImpl) SetStreamid(v string) StreamInput {
	if s == nil {
		return nil
	}
	s.StreamidValue = &v
	return s
}

// Deprecated field. Will be deleted at 25.03
// This configuration is deprecated. Use `dvbocr` configuration field in stream.
// This parameter allows to manage subtitles in an output stream.
// Example: drop
func (s StreamInputImpl) Subtitles() any {
	return s.SubtitlesValue
}

// Deprecated field. Will be deleted at 25.03
// This configuration is deprecated. Use `dvbocr` configuration field in stream.
// This parameter allows to manage subtitles in an output stream.
// Example: drop
func (s *StreamInputImpl) SetSubtitles(v any) StreamInput {
	if s == nil {
		return nil
	}
	s.SubtitlesValue = v
	return s
}

// URL of the source SWF file making the connection by RTMP.
// Example: file://C:/FlvPlayer.swf
func (s StreamInputImpl) Swfurl() *string {
	return s.SwfurlValue
}

// URL of the source SWF file making the connection by RTMP.
// Example: file://C:/FlvPlayer.swf
func (s *StreamInputImpl) SetSwfurl(v string) StreamInput {
	if s == nil {
		return nil
	}
	s.SwfurlValue = &v
	return s
}

// This parameter is used for a mixer stream that uses other streams as its video and audio sources.
// If the parameter is set to `realtime`, audio frames will be played in sync with video frames:
// if the difference between timestamps of an audio frame and a corresponding video frame is more than 2 seconds,
// the audio frame will be played at the timestamp of the video frame.
// If this parameter is set to `dts`, no synchronization is performed.
// Example: dts
func (s StreamInputImpl) Sync() *string {
	return s.SyncValue
}

// This parameter is used for a mixer stream that uses other streams as its video and audio sources.
// If the parameter is set to `realtime`, audio frames will be played in sync with video frames:
// if the difference between timestamps of an audio frame and a corresponding video frame is more than 2 seconds,
// the audio frame will be played at the timestamp of the video frame.
// If this parameter is set to `dts`, no synchronization is performed.
// Example: dts
func (s *StreamInputImpl) SetSync(v string) StreamInput {
	if s == nil {
		return nil
	}
	s.SyncValue = &v
	return s
}

// URL of the remote Server for entering credentials.
// It has the following format: `protocol://servername:port/appName/appInstance`.
// Format: url (url)
// Example: rtmp://localhost:1935/testapp/instance1
func (s StreamInputImpl) Tcurl() *URL {
	return s.TcurlValue
}

// URL of the remote Server for entering credentials.
// It has the following format: `protocol://servername:port/appName/appInstance`.
// Format: url (url)
// Example: rtmp://localhost:1935/testapp/instance1
func (s *StreamInputImpl) SetTcurl(v URL) StreamInput {
	if s == nil {
		return nil
	}
	s.TcurlValue = &v
	return s
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s StreamInputImpl) Timeout() *int {
	return s.TimeoutValue
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s *StreamInputImpl) SetTimeout(v int) StreamInput {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// This information is necessary for adding into the PMT table to identify streams which carry teletext data in the resulting MPEG-TS stream.
func (s StreamInputImpl) TtxtDescriptors() []TtxtDescriptors {
	if s.TtxtDescriptorsValue == nil {
		return nil
	}
	result := make([]TtxtDescriptors, len(s.TtxtDescriptorsValue))
	for i, item := range s.TtxtDescriptorsValue {
		result[i] = item
	}
	return result
}

// This information is necessary for adding into the PMT table to identify streams which carry teletext data in the resulting MPEG-TS stream.
func (s *StreamInputImpl) SetTtxtDescriptors(v []TtxtDescriptors) StreamInput {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*TtxtDescriptorsImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*TtxtDescriptorsImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.TtxtDescriptorsValue = impl
	}
	return s
}

// URL to connect to the H323 source and get the stream.
// /URL to get a stream from HLS source.
// /URL to connect to the RTMP source and get the stream.
// RTMP uses a special URL consisting of at least two segments. *Flussonic* parses the URL and splits it into parts,
// using the first segment as an RTMP application name.
// /Artificial URL to connect to the SRT source and get the stream.
// SRT requires IP and port, so we create an artificial URL to specify the options to manage the data interchange.
// /URL for ingest and pass a stream "as is" without repackaging.
// /URL to make a mixer stream from other streams.
// /Special URL to make a mosaic stream.
// /URL to get a stream from m4f source.
// /URL to get a stream from m4s source.
// /URL to connect to RTP source and get the stream.
// /URL to connect to the SHOUTcast source and get the stream.
// /Special URL to play the archive record of a stream with a fixed delay.
// /URL to get a stream from playlist.
// /URL to connect to the source and get a copy of the original stream.
// /URL to connect to the SPTS source and get the stream.
// /URL to get a stream from MPTS source.
// /URL to connect to the Video4Linux source and get the stream.
// /URL to connect to the Decklink SDI source and get the stream.
// /URL to connect to the DekTec SDI source and get the stream.
// /URL to get a stream from NDI source. Usually NDI software display sources like `My PC (Camera1)`, convert it into `ndi://My PC/Camera1`.
// /SMPTE 2110 UDP multicast group
// /FRIP input. Can be a cmd if started from `-` or an existing socket.
func (s StreamInputImpl) URL() InputURL {
	return s.URLValue
}

// URL to connect to the H323 source and get the stream.
// /URL to get a stream from HLS source.
// /URL to connect to the RTMP source and get the stream.
// RTMP uses a special URL consisting of at least two segments. *Flussonic* parses the URL and splits it into parts,
// using the first segment as an RTMP application name.
// /Artificial URL to connect to the SRT source and get the stream.
// SRT requires IP and port, so we create an artificial URL to specify the options to manage the data interchange.
// /URL for ingest and pass a stream "as is" without repackaging.
// /URL to make a mixer stream from other streams.
// /Special URL to make a mosaic stream.
// /URL to get a stream from m4f source.
// /URL to get a stream from m4s source.
// /URL to connect to RTP source and get the stream.
// /URL to connect to the SHOUTcast source and get the stream.
// /Special URL to play the archive record of a stream with a fixed delay.
// /URL to get a stream from playlist.
// /URL to connect to the source and get a copy of the original stream.
// /URL to connect to the SPTS source and get the stream.
// /URL to get a stream from MPTS source.
// /URL to connect to the Video4Linux source and get the stream.
// /URL to connect to the Decklink SDI source and get the stream.
// /URL to connect to the DekTec SDI source and get the stream.
// /URL to get a stream from NDI source. Usually NDI software display sources like `My PC (Camera1)`, convert it into `ndi://My PC/Camera1`.
// /SMPTE 2110 UDP multicast group
// /FRIP input. Can be a cmd if started from `-` or an existing socket.
func (s *StreamInputImpl) SetURL(v InputURL) StreamInput {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// User agent. Can be modified if a protocol allows it.
func (s StreamInputImpl) UserAgent() *string {
	return s.UserAgentValue
}

// User agent. Can be modified if a protocol allows it.
func (s *StreamInputImpl) SetUserAgent(v string) StreamInput {
	if s == nil {
		return nil
	}
	s.UserAgentValue = &v
	return s
}

// This parameter allows logging the decoded data when reading teletext from VBI.
func (s StreamInputImpl) VbiDebug() *bool {
	return s.VbiDebugValue
}

// This parameter allows logging the decoded data when reading teletext from VBI.
func (s *StreamInputImpl) SetVbiDebug(v bool) StreamInput {
	if s == nil {
		return nil
	}
	s.VbiDebugValue = &v
	return s
}

// The VBI device to capture raw VBI data from Stream Labs SDI cards. VBI data can contain information about teletext or closed captions.
// It is actually a path to a VBI device file created on the disk by Video4Linux.
// Example: /dev/vbi
func (s StreamInputImpl) VbiDevice() *string {
	return s.VbiDeviceValue
}

// The VBI device to capture raw VBI data from Stream Labs SDI cards. VBI data can contain information about teletext or closed captions.
// It is actually a path to a VBI device file created on the disk by Video4Linux.
// Example: /dev/vbi
func (s *StreamInputImpl) SetVbiDevice(v string) StreamInput {
	if s == nil {
		return nil
	}
	s.VbiDeviceValue = &v
	return s
}

// This parameter is used for debugging when reading teletext from VBI.
// This is a threshold, in seconds, for turning on the decoder.
func (s StreamInputImpl) VbiThreshold() *int {
	return s.VbiThresholdValue
}

// This parameter is used for debugging when reading teletext from VBI.
// This is a threshold, in seconds, for turning on the decoder.
func (s *StreamInputImpl) SetVbiThreshold(v int) StreamInput {
	if s == nil {
		return nil
	}
	s.VbiThresholdValue = &v
	return s
}

// Required SRT version.
// Pattern: ^[0-9]+\.[0-9]+\.[0-9]+$
// Example: 1.3.0
func (s StreamInputImpl) Version() *string {
	return s.VersionValue
}

// Required SRT version.
// Pattern: ^[0-9]+\.[0-9]+\.[0-9]+$
// Example: 1.3.0
func (s *StreamInputImpl) SetVersion(v string) StreamInput {
	if s == nil {
		return nil
	}
	s.VersionValue = &v
	return s
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s StreamInputImpl) Via() *AgentURL {
	return s.ViaValue
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s *StreamInputImpl) SetVia(v AgentURL) StreamInput {
	if s == nil {
		return nil
	}
	s.ViaValue = &v
	return s
}

// H323 input bitrate.
// Format: speed (speed)
func (s StreamInputImpl) VideoBitrate() *Speed {
	return s.VideoBitrateValue
}

// H323 input bitrate.
// Format: speed (speed)
func (s *StreamInputImpl) SetVideoBitrate(v Speed) StreamInput {
	if s == nil {
		return nil
	}
	s.VideoBitrateValue = &v
	return s
}

// The video device to capture video from Stream Labs SDI cards.
// It is actually a path to a device file created on the disk by Video4Linux.
// Example: /dev/video0
func (s StreamInputImpl) VideoDevice() *string {
	return s.VideoDeviceValue
}

// The video device to capture video from Stream Labs SDI cards.
// It is actually a path to a device file created on the disk by Video4Linux.
// Example: /dev/video0
func (s *StreamInputImpl) SetVideoDevice(v string) StreamInput {
	if s == nil {
		return nil
	}
	s.VideoDeviceValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputImpl) VideoTimeout() *Seconds {
	return s.VideoTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputImpl) SetVideoTimeout(v Seconds) StreamInput {
	if s == nil {
		return nil
	}
	s.VideoTimeoutValue = &v
	return s
}

// Video interface for capturing from the Decklink card.
// Usually, it is autodetected, but for some Decklink models you should specify it manually.
// Example: hdmi
func (s StreamInputImpl) Vinput() any {
	return s.VinputValue
}

// Video interface for capturing from the Decklink card.
// Usually, it is autodetected, but for some Decklink models you should specify it manually.
// Example: hdmi
func (s *StreamInputImpl) SetVinput(v any) StreamInput {
	if s == nil {
		return nil
	}
	s.VinputValue = v
	return s
}

// Synchronization mode for video captured from the Decklink card.
func (s StreamInputImpl) Vpts() *StreamInputDecklinkVpts {
	return s.VptsValue
}

// Synchronization mode for video captured from the Decklink card.
func (s *StreamInputImpl) SetVpts(v *StreamInputDecklinkVpts) StreamInput {
	if s == nil {
		return nil
	}
	s.VptsValue = v
	return s
}

// Must specify received pixel width
func (s StreamInputImpl) Width() *int {
	return s.WidthValue
}

// Must specify received pixel width
func (s *StreamInputImpl) SetWidth(v int) StreamInput {
	if s == nil {
		return nil
	}
	s.WidthValue = &v
	return s
}

// NewStreamInputBase creates a new StreamInputBase instance
func NewStreamInputBase() StreamInputBase {
	return &StreamInputBaseImpl{}
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s StreamInputBaseImpl) AllowIf() *string {
	return s.AllowIfValue
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s *StreamInputBaseImpl) SetAllowIf(v string) StreamInputBase {
	if s == nil {
		return nil
	}
	s.AllowIfValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputBaseImpl) AudioTimeout() *Seconds {
	return s.AudioTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputBaseImpl) SetAudioTimeout(v Seconds) StreamInputBase {
	if s == nil {
		return nil
	}
	s.AudioTimeoutValue = &v
	return s
}

// Human-readable description of the input.
// Example: This is a test input
func (s StreamInputBaseImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the input.
// Example: This is a test input
func (s *StreamInputBaseImpl) SetComment(v string) StreamInputBase {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s StreamInputBaseImpl) DenyIf() *string {
	return s.DenyIfValue
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s *StreamInputBaseImpl) SetDenyIf(v string) StreamInputBase {
	if s == nil {
		return nil
	}
	s.DenyIfValue = &v
	return s
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s StreamInputBaseImpl) FramesTimeout() *int {
	return s.FramesTimeoutValue
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s *StreamInputBaseImpl) SetFramesTimeout(v int) StreamInputBase {
	if s == nil {
		return nil
	}
	s.FramesTimeoutValue = &v
	return s
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s StreamInputBaseImpl) Headers() map[string]string {
	return s.HeadersValue
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s *StreamInputBaseImpl) SetHeaders(v map[string]string) StreamInputBase {
	if s == nil {
		return nil
	}
	s.HeadersValue = v
	return s
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s StreamInputBaseImpl) MaxRetryTimeout() *Seconds {
	return s.MaxRetryTimeoutValue
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s *StreamInputBaseImpl) SetMaxRetryTimeout(v Seconds) StreamInputBase {
	if s == nil {
		return nil
	}
	s.MaxRetryTimeoutValue = &v
	return s
}

// Skip input start if the stream has no clients.
func (s StreamInputBaseImpl) NoClientsReconnectDelay() *int {
	return s.NoClientsReconnectDelayValue
}

// Skip input start if the stream has no clients.
func (s *StreamInputBaseImpl) SetNoClientsReconnectDelay(v int) StreamInputBase {
	if s == nil {
		return nil
	}
	s.NoClientsReconnectDelayValue = &v
	return s
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s StreamInputBaseImpl) OutputAudio() *OutputAudio {
	return s.OutputAudioValue
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s *StreamInputBaseImpl) SetOutputAudio(v OutputAudio) StreamInputBase {
	if s == nil {
		return nil
	}
	s.OutputAudioValue = &v
	return s
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s StreamInputBaseImpl) Priority() *int {
	return s.PriorityValue
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s *StreamInputBaseImpl) SetPriority(v int) StreamInputBase {
	if s == nil {
		return nil
	}
	s.PriorityValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s StreamInputBaseImpl) SourceTimeout() any {
	return s.SourceTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s *StreamInputBaseImpl) SetSourceTimeout(v any) StreamInputBase {
	if s == nil {
		return nil
	}
	s.SourceTimeoutValue = v
	return s
}

// Detailed runtime information about the input.
func (s StreamInputBaseImpl) Stats() InputStats {
	return s.StatsValue
}

// Detailed runtime information about the input.
func (s *StreamInputBaseImpl) SetStats(v InputStats) StreamInputBase {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s StreamInputBaseImpl) Timeout() *int {
	return s.TimeoutValue
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s *StreamInputBaseImpl) SetTimeout(v int) StreamInputBase {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// User agent. Can be modified if a protocol allows it.
func (s StreamInputBaseImpl) UserAgent() *string {
	return s.UserAgentValue
}

// User agent. Can be modified if a protocol allows it.
func (s *StreamInputBaseImpl) SetUserAgent(v string) StreamInputBase {
	if s == nil {
		return nil
	}
	s.UserAgentValue = &v
	return s
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s StreamInputBaseImpl) Via() *AgentURL {
	return s.ViaValue
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s *StreamInputBaseImpl) SetVia(v AgentURL) StreamInputBase {
	if s == nil {
		return nil
	}
	s.ViaValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputBaseImpl) VideoTimeout() *Seconds {
	return s.VideoTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputBaseImpl) SetVideoTimeout(v Seconds) StreamInputBase {
	if s == nil {
		return nil
	}
	s.VideoTimeoutValue = &v
	return s
}

// NewStreamInputCopy creates a new StreamInputCopy instance
func NewStreamInputCopy() StreamInputCopy {
	return &StreamInputCopyImpl{}
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s StreamInputCopyImpl) AllowIf() *string {
	return s.AllowIfValue
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s *StreamInputCopyImpl) SetAllowIf(v string) StreamInputCopy {
	if s == nil {
		return nil
	}
	s.AllowIfValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputCopyImpl) AudioTimeout() *Seconds {
	return s.AudioTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputCopyImpl) SetAudioTimeout(v Seconds) StreamInputCopy {
	if s == nil {
		return nil
	}
	s.AudioTimeoutValue = &v
	return s
}

// The rules for handling the closed captions.
func (s StreamInputCopyImpl) ClosedCaptions() map[string]string {
	return s.ClosedCaptionsValue
}

// The rules for handling the closed captions.
func (s *StreamInputCopyImpl) SetClosedCaptions(v map[string]string) StreamInputCopy {
	if s == nil {
		return nil
	}
	s.ClosedCaptionsValue = v
	return s
}

// Human-readable description of the input.
// Example: This is a test input
func (s StreamInputCopyImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the input.
// Example: This is a test input
func (s *StreamInputCopyImpl) SetComment(v string) StreamInputCopy {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s StreamInputCopyImpl) DenyIf() *string {
	return s.DenyIfValue
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s *StreamInputCopyImpl) SetDenyIf(v string) StreamInputCopy {
	if s == nil {
		return nil
	}
	s.DenyIfValue = &v
	return s
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s StreamInputCopyImpl) FramesTimeout() *int {
	return s.FramesTimeoutValue
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s *StreamInputCopyImpl) SetFramesTimeout(v int) StreamInputCopy {
	if s == nil {
		return nil
	}
	s.FramesTimeoutValue = &v
	return s
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s StreamInputCopyImpl) Headers() map[string]string {
	return s.HeadersValue
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s *StreamInputCopyImpl) SetHeaders(v map[string]string) StreamInputCopy {
	if s == nil {
		return nil
	}
	s.HeadersValue = v
	return s
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s StreamInputCopyImpl) MaxRetryTimeout() *Seconds {
	return s.MaxRetryTimeoutValue
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s *StreamInputCopyImpl) SetMaxRetryTimeout(v Seconds) StreamInputCopy {
	if s == nil {
		return nil
	}
	s.MaxRetryTimeoutValue = &v
	return s
}

// Skip input start if the stream has no clients.
func (s StreamInputCopyImpl) NoClientsReconnectDelay() *int {
	return s.NoClientsReconnectDelayValue
}

// Skip input start if the stream has no clients.
func (s *StreamInputCopyImpl) SetNoClientsReconnectDelay(v int) StreamInputCopy {
	if s == nil {
		return nil
	}
	s.NoClientsReconnectDelayValue = &v
	return s
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s StreamInputCopyImpl) OutputAudio() *OutputAudio {
	return s.OutputAudioValue
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s *StreamInputCopyImpl) SetOutputAudio(v OutputAudio) StreamInputCopy {
	if s == nil {
		return nil
	}
	s.OutputAudioValue = &v
	return s
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s StreamInputCopyImpl) Priority() *int {
	return s.PriorityValue
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s *StreamInputCopyImpl) SetPriority(v int) StreamInputCopy {
	if s == nil {
		return nil
	}
	s.PriorityValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s StreamInputCopyImpl) SourceTimeout() any {
	return s.SourceTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s *StreamInputCopyImpl) SetSourceTimeout(v any) StreamInputCopy {
	if s == nil {
		return nil
	}
	s.SourceTimeoutValue = v
	return s
}

// Detailed runtime information about the input.
func (s StreamInputCopyImpl) Stats() InputStats {
	return s.StatsValue
}

// Detailed runtime information about the input.
func (s *StreamInputCopyImpl) SetStats(v InputStats) StreamInputCopy {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s StreamInputCopyImpl) Timeout() *int {
	return s.TimeoutValue
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s *StreamInputCopyImpl) SetTimeout(v int) StreamInputCopy {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// URL to connect to the source and get a copy of the original stream.
// Format: input_url (input_url)
// Pattern: ^copy://.*$
// Example: copy://stream1
func (s StreamInputCopyImpl) URL() InputURL {
	return s.URLValue
}

// URL to connect to the source and get a copy of the original stream.
// Format: input_url (input_url)
// Pattern: ^copy://.*$
// Example: copy://stream1
func (s *StreamInputCopyImpl) SetURL(v InputURL) StreamInputCopy {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// User agent. Can be modified if a protocol allows it.
func (s StreamInputCopyImpl) UserAgent() *string {
	return s.UserAgentValue
}

// User agent. Can be modified if a protocol allows it.
func (s *StreamInputCopyImpl) SetUserAgent(v string) StreamInputCopy {
	if s == nil {
		return nil
	}
	s.UserAgentValue = &v
	return s
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s StreamInputCopyImpl) Via() *AgentURL {
	return s.ViaValue
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s *StreamInputCopyImpl) SetVia(v AgentURL) StreamInputCopy {
	if s == nil {
		return nil
	}
	s.ViaValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputCopyImpl) VideoTimeout() *Seconds {
	return s.VideoTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputCopyImpl) SetVideoTimeout(v Seconds) StreamInputCopy {
	if s == nil {
		return nil
	}
	s.VideoTimeoutValue = &v
	return s
}

// NewStreamInputDecklink creates a new StreamInputDecklink instance
func NewStreamInputDecklink() StreamInputDecklink {
	return &StreamInputDecklinkImpl{}
}

// Audio interface for capturing from the Decklink card.
// Usually, it is autodetected, but for some Decklink models you should specify it manually.
// Example: microphone
func (s StreamInputDecklinkImpl) Ainput() any {
	return s.AinputValue
}

// Audio interface for capturing from the Decklink card.
// Usually, it is autodetected, but for some Decklink models you should specify it manually.
// Example: microphone
func (s *StreamInputDecklinkImpl) SetAinput(v any) StreamInputDecklink {
	if s == nil {
		return nil
	}
	s.AinputValue = v
	return s
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s StreamInputDecklinkImpl) AllowIf() *string {
	return s.AllowIfValue
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s *StreamInputDecklinkImpl) SetAllowIf(v string) StreamInputDecklink {
	if s == nil {
		return nil
	}
	s.AllowIfValue = &v
	return s
}

// Synchronization mode for audio captured from the Decklink card.
func (s StreamInputDecklinkImpl) Apts() *StreamInputDecklinkApts {
	return s.AptsValue
}

// Synchronization mode for audio captured from the Decklink card.
func (s *StreamInputDecklinkImpl) SetApts(v *StreamInputDecklinkApts) StreamInputDecklink {
	if s == nil {
		return nil
	}
	s.AptsValue = v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputDecklinkImpl) AudioTimeout() *Seconds {
	return s.AudioTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputDecklinkImpl) SetAudioTimeout(v Seconds) StreamInputDecklink {
	if s == nil {
		return nil
	}
	s.AudioTimeoutValue = &v
	return s
}

// Human-readable description of the input.
// Example: This is a test input
func (s StreamInputDecklinkImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the input.
// Example: This is a test input
func (s *StreamInputDecklinkImpl) SetComment(v string) StreamInputDecklink {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s StreamInputDecklinkImpl) DenyIf() *string {
	return s.DenyIfValue
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s *StreamInputDecklinkImpl) SetDenyIf(v string) StreamInputDecklink {
	if s == nil {
		return nil
	}
	s.DenyIfValue = &v
	return s
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s StreamInputDecklinkImpl) FramesTimeout() *int {
	return s.FramesTimeoutValue
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s *StreamInputDecklinkImpl) SetFramesTimeout(v int) StreamInputDecklink {
	if s == nil {
		return nil
	}
	s.FramesTimeoutValue = &v
	return s
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s StreamInputDecklinkImpl) Headers() map[string]string {
	return s.HeadersValue
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s *StreamInputDecklinkImpl) SetHeaders(v map[string]string) StreamInputDecklink {
	if s == nil {
		return nil
	}
	s.HeadersValue = v
	return s
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s StreamInputDecklinkImpl) MaxRetryTimeout() *Seconds {
	return s.MaxRetryTimeoutValue
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s *StreamInputDecklinkImpl) SetMaxRetryTimeout(v Seconds) StreamInputDecklink {
	if s == nil {
		return nil
	}
	s.MaxRetryTimeoutValue = &v
	return s
}

// Mode of the input stream captured from the Decklink card. It is composed of the size and FPS of the captured video.
// Usually, it is autodetected, but for some Decklink models you'll need to specify it manually.
// Example: 4d30
func (s StreamInputDecklinkImpl) Mode() *string {
	return s.ModeValue
}

// Mode of the input stream captured from the Decklink card. It is composed of the size and FPS of the captured video.
// Usually, it is autodetected, but for some Decklink models you'll need to specify it manually.
// Example: 4d30
func (s *StreamInputDecklinkImpl) SetMode(v string) StreamInputDecklink {
	if s == nil {
		return nil
	}
	s.ModeValue = &v
	return s
}

// Skip input start if the stream has no clients.
func (s StreamInputDecklinkImpl) NoClientsReconnectDelay() *int {
	return s.NoClientsReconnectDelayValue
}

// Skip input start if the stream has no clients.
func (s *StreamInputDecklinkImpl) SetNoClientsReconnectDelay(v int) StreamInputDecklink {
	if s == nil {
		return nil
	}
	s.NoClientsReconnectDelayValue = &v
	return s
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s StreamInputDecklinkImpl) OutputAudio() *OutputAudio {
	return s.OutputAudioValue
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s *StreamInputDecklinkImpl) SetOutputAudio(v OutputAudio) StreamInputDecklink {
	if s == nil {
		return nil
	}
	s.OutputAudioValue = &v
	return s
}

// Preferred pixel format for captured video.
func (s StreamInputDecklinkImpl) Pixel() *StreamInputDecklinkPixel {
	return s.PixelValue
}

// Preferred pixel format for captured video.
func (s *StreamInputDecklinkImpl) SetPixel(v StreamInputDecklinkPixel) StreamInputDecklink {
	if s == nil {
		return nil
	}
	s.PixelValue = &v
	return s
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s StreamInputDecklinkImpl) Priority() *int {
	return s.PriorityValue
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s *StreamInputDecklinkImpl) SetPriority(v int) StreamInputDecklink {
	if s == nil {
		return nil
	}
	s.PriorityValue = &v
	return s
}

// The ratio of the width of the display representation to the width of the pixel representation of video.
// This parameter is used for creating non-anamorphic video from anamorphic video.
// Example: 16:9
func (s StreamInputDecklinkImpl) Sar() *string {
	return s.SarValue
}

// The ratio of the width of the display representation to the width of the pixel representation of video.
// This parameter is used for creating non-anamorphic video from anamorphic video.
// Example: 16:9
func (s *StreamInputDecklinkImpl) SetSar(v string) StreamInputDecklink {
	if s == nil {
		return nil
	}
	s.SarValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s StreamInputDecklinkImpl) SourceTimeout() any {
	return s.SourceTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s *StreamInputDecklinkImpl) SetSourceTimeout(v any) StreamInputDecklink {
	if s == nil {
		return nil
	}
	s.SourceTimeoutValue = v
	return s
}

// Detailed runtime information about the input.
func (s StreamInputDecklinkImpl) Stats() InputStats {
	return s.StatsValue
}

// Detailed runtime information about the input.
func (s *StreamInputDecklinkImpl) SetStats(v InputStats) StreamInputDecklink {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s StreamInputDecklinkImpl) Timeout() *int {
	return s.TimeoutValue
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s *StreamInputDecklinkImpl) SetTimeout(v int) StreamInputDecklink {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// This information is necessary for adding into the PMT table to identify streams which carry teletext data in the resulting MPEG-TS stream.
func (s StreamInputDecklinkImpl) TtxtDescriptors() []TtxtDescriptors {
	if s.TtxtDescriptorsValue == nil {
		return nil
	}
	result := make([]TtxtDescriptors, len(s.TtxtDescriptorsValue))
	for i, item := range s.TtxtDescriptorsValue {
		result[i] = item
	}
	return result
}

// This information is necessary for adding into the PMT table to identify streams which carry teletext data in the resulting MPEG-TS stream.
func (s *StreamInputDecklinkImpl) SetTtxtDescriptors(v []TtxtDescriptors) StreamInputDecklink {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*TtxtDescriptorsImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*TtxtDescriptorsImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.TtxtDescriptorsValue = impl
	}
	return s
}

// URL to connect to the Decklink SDI source and get the stream.
// Format: input_url (input_url)
// Pattern: ^decklink://.*$
// Example: decklink://0
func (s StreamInputDecklinkImpl) URL() InputURL {
	return s.URLValue
}

// URL to connect to the Decklink SDI source and get the stream.
// Format: input_url (input_url)
// Pattern: ^decklink://.*$
// Example: decklink://0
func (s *StreamInputDecklinkImpl) SetURL(v InputURL) StreamInputDecklink {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// User agent. Can be modified if a protocol allows it.
func (s StreamInputDecklinkImpl) UserAgent() *string {
	return s.UserAgentValue
}

// User agent. Can be modified if a protocol allows it.
func (s *StreamInputDecklinkImpl) SetUserAgent(v string) StreamInputDecklink {
	if s == nil {
		return nil
	}
	s.UserAgentValue = &v
	return s
}

// This parameter allows logging the decoded data when reading teletext from VBI.
func (s StreamInputDecklinkImpl) VbiDebug() *bool {
	return s.VbiDebugValue
}

// This parameter allows logging the decoded data when reading teletext from VBI.
func (s *StreamInputDecklinkImpl) SetVbiDebug(v bool) StreamInputDecklink {
	if s == nil {
		return nil
	}
	s.VbiDebugValue = &v
	return s
}

// This parameter is used for debugging when reading teletext from VBI.
// This is a threshold, in seconds, for turning on the decoder.
func (s StreamInputDecklinkImpl) VbiThreshold() *int {
	return s.VbiThresholdValue
}

// This parameter is used for debugging when reading teletext from VBI.
// This is a threshold, in seconds, for turning on the decoder.
func (s *StreamInputDecklinkImpl) SetVbiThreshold(v int) StreamInputDecklink {
	if s == nil {
		return nil
	}
	s.VbiThresholdValue = &v
	return s
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s StreamInputDecklinkImpl) Via() *AgentURL {
	return s.ViaValue
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s *StreamInputDecklinkImpl) SetVia(v AgentURL) StreamInputDecklink {
	if s == nil {
		return nil
	}
	s.ViaValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputDecklinkImpl) VideoTimeout() *Seconds {
	return s.VideoTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputDecklinkImpl) SetVideoTimeout(v Seconds) StreamInputDecklink {
	if s == nil {
		return nil
	}
	s.VideoTimeoutValue = &v
	return s
}

// Video interface for capturing from the Decklink card.
// Usually, it is autodetected, but for some Decklink models you should specify it manually.
// Example: hdmi
func (s StreamInputDecklinkImpl) Vinput() any {
	return s.VinputValue
}

// Video interface for capturing from the Decklink card.
// Usually, it is autodetected, but for some Decklink models you should specify it manually.
// Example: hdmi
func (s *StreamInputDecklinkImpl) SetVinput(v any) StreamInputDecklink {
	if s == nil {
		return nil
	}
	s.VinputValue = v
	return s
}

// Synchronization mode for video captured from the Decklink card.
func (s StreamInputDecklinkImpl) Vpts() *StreamInputDecklinkVpts {
	return s.VptsValue
}

// Synchronization mode for video captured from the Decklink card.
func (s *StreamInputDecklinkImpl) SetVpts(v *StreamInputDecklinkVpts) StreamInputDecklink {
	if s == nil {
		return nil
	}
	s.VptsValue = v
	return s
}

// NewStreamInputDektec creates a new StreamInputDektec instance
func NewStreamInputDektec() StreamInputDektec {
	return &StreamInputDektecImpl{}
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s StreamInputDektecImpl) AllowIf() *string {
	return s.AllowIfValue
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s *StreamInputDektecImpl) SetAllowIf(v string) StreamInputDektec {
	if s == nil {
		return nil
	}
	s.AllowIfValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputDektecImpl) AudioTimeout() *Seconds {
	return s.AudioTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputDektecImpl) SetAudioTimeout(v Seconds) StreamInputDektec {
	if s == nil {
		return nil
	}
	s.AudioTimeoutValue = &v
	return s
}

// Human-readable description of the input.
// Example: This is a test input
func (s StreamInputDektecImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the input.
// Example: This is a test input
func (s *StreamInputDektecImpl) SetComment(v string) StreamInputDektec {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s StreamInputDektecImpl) DenyIf() *string {
	return s.DenyIfValue
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s *StreamInputDektecImpl) SetDenyIf(v string) StreamInputDektec {
	if s == nil {
		return nil
	}
	s.DenyIfValue = &v
	return s
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s StreamInputDektecImpl) FramesTimeout() *int {
	return s.FramesTimeoutValue
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s *StreamInputDektecImpl) SetFramesTimeout(v int) StreamInputDektec {
	if s == nil {
		return nil
	}
	s.FramesTimeoutValue = &v
	return s
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s StreamInputDektecImpl) Headers() map[string]string {
	return s.HeadersValue
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s *StreamInputDektecImpl) SetHeaders(v map[string]string) StreamInputDektec {
	if s == nil {
		return nil
	}
	s.HeadersValue = v
	return s
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s StreamInputDektecImpl) MaxRetryTimeout() *Seconds {
	return s.MaxRetryTimeoutValue
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s *StreamInputDektecImpl) SetMaxRetryTimeout(v Seconds) StreamInputDektec {
	if s == nil {
		return nil
	}
	s.MaxRetryTimeoutValue = &v
	return s
}

// Skip input start if the stream has no clients.
func (s StreamInputDektecImpl) NoClientsReconnectDelay() *int {
	return s.NoClientsReconnectDelayValue
}

// Skip input start if the stream has no clients.
func (s *StreamInputDektecImpl) SetNoClientsReconnectDelay(v int) StreamInputDektec {
	if s == nil {
		return nil
	}
	s.NoClientsReconnectDelayValue = &v
	return s
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s StreamInputDektecImpl) OutputAudio() *OutputAudio {
	return s.OutputAudioValue
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s *StreamInputDektecImpl) SetOutputAudio(v OutputAudio) StreamInputDektec {
	if s == nil {
		return nil
	}
	s.OutputAudioValue = &v
	return s
}

// Preferred pixel format for captured video.
func (s StreamInputDektecImpl) Pixel() *StreamInputDektecPixel {
	return s.PixelValue
}

// Preferred pixel format for captured video.
func (s *StreamInputDektecImpl) SetPixel(v StreamInputDektecPixel) StreamInputDektec {
	if s == nil {
		return nil
	}
	s.PixelValue = &v
	return s
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s StreamInputDektecImpl) Priority() *int {
	return s.PriorityValue
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s *StreamInputDektecImpl) SetPriority(v int) StreamInputDektec {
	if s == nil {
		return nil
	}
	s.PriorityValue = &v
	return s
}

// Source for PTS for input stream.
func (s StreamInputDektecImpl) PtsSource() *StreamInputDektecPtsSource {
	return s.PtsSourceValue
}

// Source for PTS for input stream.
func (s *StreamInputDektecImpl) SetPtsSource(v StreamInputDektecPtsSource) StreamInputDektec {
	if s == nil {
		return nil
	}
	s.PtsSourceValue = &v
	return s
}

// The ratio of the width of the display representation to the width of the pixel representation of video.
// This parameter is used for creating non-anamorphic video from anamorphic video.
// Example: 16:9
func (s StreamInputDektecImpl) Sar() *string {
	return s.SarValue
}

// The ratio of the width of the display representation to the width of the pixel representation of video.
// This parameter is used for creating non-anamorphic video from anamorphic video.
// Example: 16:9
func (s *StreamInputDektecImpl) SetSar(v string) StreamInputDektec {
	if s == nil {
		return nil
	}
	s.SarValue = &v
	return s
}

// Deprecated field. Will be deleted at 23.09
// This option disables processing of SCTE-35 markers from an MPEG-TS input stream.
// Deprecated since 22.12.
// Available ways to disable processing of SCTE-35 markers:
// 1. pids option to select tracks without SCTE-35 markers
// 2. hls_scte35 option from stream_config_media for hls output
// 3. performing appropriate tuning pids in the transponder
// Example: true
func (s StreamInputDektecImpl) Scte35() *bool {
	return s.Scte35Value
}

// Deprecated field. Will be deleted at 23.09
// This option disables processing of SCTE-35 markers from an MPEG-TS input stream.
// Deprecated since 22.12.
// Available ways to disable processing of SCTE-35 markers:
// 1. pids option to select tracks without SCTE-35 markers
// 2. hls_scte35 option from stream_config_media for hls output
// 3. performing appropriate tuning pids in the transponder
// Example: true
func (s *StreamInputDektecImpl) SetScte35(v bool) StreamInputDektec {
	if s == nil {
		return nil
	}
	s.Scte35Value = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s StreamInputDektecImpl) SourceTimeout() any {
	return s.SourceTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s *StreamInputDektecImpl) SetSourceTimeout(v any) StreamInputDektec {
	if s == nil {
		return nil
	}
	s.SourceTimeoutValue = v
	return s
}

// Detailed runtime information about the input.
func (s StreamInputDektecImpl) Stats() InputStats {
	return s.StatsValue
}

// Detailed runtime information about the input.
func (s *StreamInputDektecImpl) SetStats(v InputStats) StreamInputDektec {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s StreamInputDektecImpl) Timeout() *int {
	return s.TimeoutValue
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s *StreamInputDektecImpl) SetTimeout(v int) StreamInputDektec {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// This information is necessary for adding into the PMT table to identify streams which carry teletext data in the resulting MPEG-TS stream.
func (s StreamInputDektecImpl) TtxtDescriptors() []TtxtDescriptors {
	if s.TtxtDescriptorsValue == nil {
		return nil
	}
	result := make([]TtxtDescriptors, len(s.TtxtDescriptorsValue))
	for i, item := range s.TtxtDescriptorsValue {
		result[i] = item
	}
	return result
}

// This information is necessary for adding into the PMT table to identify streams which carry teletext data in the resulting MPEG-TS stream.
func (s *StreamInputDektecImpl) SetTtxtDescriptors(v []TtxtDescriptors) StreamInputDektec {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*TtxtDescriptorsImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*TtxtDescriptorsImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.TtxtDescriptorsValue = impl
	}
	return s
}

// URL to connect to the DekTec SDI source and get the stream.
// Format: input_url (input_url)
// Pattern: ^dektec://.*$
// Example: dektec://2174220025:2
func (s StreamInputDektecImpl) URL() InputURL {
	return s.URLValue
}

// URL to connect to the DekTec SDI source and get the stream.
// Format: input_url (input_url)
// Pattern: ^dektec://.*$
// Example: dektec://2174220025:2
func (s *StreamInputDektecImpl) SetURL(v InputURL) StreamInputDektec {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// User agent. Can be modified if a protocol allows it.
func (s StreamInputDektecImpl) UserAgent() *string {
	return s.UserAgentValue
}

// User agent. Can be modified if a protocol allows it.
func (s *StreamInputDektecImpl) SetUserAgent(v string) StreamInputDektec {
	if s == nil {
		return nil
	}
	s.UserAgentValue = &v
	return s
}

// This parameter allows logging the decoded data when reading teletext from VBI.
func (s StreamInputDektecImpl) VbiDebug() *bool {
	return s.VbiDebugValue
}

// This parameter allows logging the decoded data when reading teletext from VBI.
func (s *StreamInputDektecImpl) SetVbiDebug(v bool) StreamInputDektec {
	if s == nil {
		return nil
	}
	s.VbiDebugValue = &v
	return s
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s StreamInputDektecImpl) Via() *AgentURL {
	return s.ViaValue
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s *StreamInputDektecImpl) SetVia(v AgentURL) StreamInputDektec {
	if s == nil {
		return nil
	}
	s.ViaValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputDektecImpl) VideoTimeout() *Seconds {
	return s.VideoTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputDektecImpl) SetVideoTimeout(v Seconds) StreamInputDektec {
	if s == nil {
		return nil
	}
	s.VideoTimeoutValue = &v
	return s
}

// NewStreamInputFake creates a new StreamInputFake instance
func NewStreamInputFake() StreamInputFake {
	return &StreamInputFakeImpl{}
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s StreamInputFakeImpl) AllowIf() *string {
	return s.AllowIfValue
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s *StreamInputFakeImpl) SetAllowIf(v string) StreamInputFake {
	if s == nil {
		return nil
	}
	s.AllowIfValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputFakeImpl) AudioTimeout() *Seconds {
	return s.AudioTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputFakeImpl) SetAudioTimeout(v Seconds) StreamInputFake {
	if s == nil {
		return nil
	}
	s.AudioTimeoutValue = &v
	return s
}

// Bitrate of an artificially created test video stream.
// Applicable to the `fake://fake` URL.
// Format: speed (speed)
func (s StreamInputFakeImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// Bitrate of an artificially created test video stream.
// Applicable to the `fake://fake` URL.
// Format: speed (speed)
func (s *StreamInputFakeImpl) SetBitrate(v Speed) StreamInputFake {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// Human-readable description of the input.
// Example: This is a test input
func (s StreamInputFakeImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the input.
// Example: This is a test input
func (s *StreamInputFakeImpl) SetComment(v string) StreamInputFake {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s StreamInputFakeImpl) DenyIf() *string {
	return s.DenyIfValue
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s *StreamInputFakeImpl) SetDenyIf(v string) StreamInputFake {
	if s == nil {
		return nil
	}
	s.DenyIfValue = &v
	return s
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s StreamInputFakeImpl) FramesTimeout() *int {
	return s.FramesTimeoutValue
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s *StreamInputFakeImpl) SetFramesTimeout(v int) StreamInputFake {
	if s == nil {
		return nil
	}
	s.FramesTimeoutValue = &v
	return s
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s StreamInputFakeImpl) Headers() map[string]string {
	return s.HeadersValue
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s *StreamInputFakeImpl) SetHeaders(v map[string]string) StreamInputFake {
	if s == nil {
		return nil
	}
	s.HeadersValue = v
	return s
}

// Height of an artificially created test video stream.
// Applicable to the `fake://fake` URL.
func (s StreamInputFakeImpl) Height() *int {
	return s.HeightValue
}

// Height of an artificially created test video stream.
// Applicable to the `fake://fake` URL.
func (s *StreamInputFakeImpl) SetHeight(v int) StreamInputFake {
	if s == nil {
		return nil
	}
	s.HeightValue = &v
	return s
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s StreamInputFakeImpl) MaxRetryTimeout() *Seconds {
	return s.MaxRetryTimeoutValue
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s *StreamInputFakeImpl) SetMaxRetryTimeout(v Seconds) StreamInputFake {
	if s == nil {
		return nil
	}
	s.MaxRetryTimeoutValue = &v
	return s
}

// Skip input start if the stream has no clients.
func (s StreamInputFakeImpl) NoClientsReconnectDelay() *int {
	return s.NoClientsReconnectDelayValue
}

// Skip input start if the stream has no clients.
func (s *StreamInputFakeImpl) SetNoClientsReconnectDelay(v int) StreamInputFake {
	if s == nil {
		return nil
	}
	s.NoClientsReconnectDelayValue = &v
	return s
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s StreamInputFakeImpl) OutputAudio() *OutputAudio {
	return s.OutputAudioValue
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s *StreamInputFakeImpl) SetOutputAudio(v OutputAudio) StreamInputFake {
	if s == nil {
		return nil
	}
	s.OutputAudioValue = &v
	return s
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s StreamInputFakeImpl) Priority() *int {
	return s.PriorityValue
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s *StreamInputFakeImpl) SetPriority(v int) StreamInputFake {
	if s == nil {
		return nil
	}
	s.PriorityValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s StreamInputFakeImpl) SourceTimeout() any {
	return s.SourceTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s *StreamInputFakeImpl) SetSourceTimeout(v any) StreamInputFake {
	if s == nil {
		return nil
	}
	s.SourceTimeoutValue = v
	return s
}

// Detailed runtime information about the input.
func (s StreamInputFakeImpl) Stats() InputStats {
	return s.StatsValue
}

// Detailed runtime information about the input.
func (s *StreamInputFakeImpl) SetStats(v InputStats) StreamInputFake {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s StreamInputFakeImpl) Timeout() *int {
	return s.TimeoutValue
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s *StreamInputFakeImpl) SetTimeout(v int) StreamInputFake {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// URL to get a demo stream.
// Format: input_url (input_url)
// Pattern: ^fake://.*$
// Example: fake://fake
func (s StreamInputFakeImpl) URL() InputURL {
	return s.URLValue
}

// URL to get a demo stream.
// Format: input_url (input_url)
// Pattern: ^fake://.*$
// Example: fake://fake
func (s *StreamInputFakeImpl) SetURL(v InputURL) StreamInputFake {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// User agent. Can be modified if a protocol allows it.
func (s StreamInputFakeImpl) UserAgent() *string {
	return s.UserAgentValue
}

// User agent. Can be modified if a protocol allows it.
func (s *StreamInputFakeImpl) SetUserAgent(v string) StreamInputFake {
	if s == nil {
		return nil
	}
	s.UserAgentValue = &v
	return s
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s StreamInputFakeImpl) Via() *AgentURL {
	return s.ViaValue
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s *StreamInputFakeImpl) SetVia(v AgentURL) StreamInputFake {
	if s == nil {
		return nil
	}
	s.ViaValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputFakeImpl) VideoTimeout() *Seconds {
	return s.VideoTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputFakeImpl) SetVideoTimeout(v Seconds) StreamInputFake {
	if s == nil {
		return nil
	}
	s.VideoTimeoutValue = &v
	return s
}

// Width of an artificially created test video stream.
// Applicable to the `fake://fake` URL.
func (s StreamInputFakeImpl) Width() *int {
	return s.WidthValue
}

// Width of an artificially created test video stream.
// Applicable to the `fake://fake` URL.
func (s *StreamInputFakeImpl) SetWidth(v int) StreamInputFake {
	if s == nil {
		return nil
	}
	s.WidthValue = &v
	return s
}

// NewStreamInputFile creates a new StreamInputFile instance
func NewStreamInputFile() StreamInputFile {
	return &StreamInputFileImpl{}
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s StreamInputFileImpl) AllowIf() *string {
	return s.AllowIfValue
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s *StreamInputFileImpl) SetAllowIf(v string) StreamInputFile {
	if s == nil {
		return nil
	}
	s.AllowIfValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputFileImpl) AudioTimeout() *Seconds {
	return s.AudioTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputFileImpl) SetAudioTimeout(v Seconds) StreamInputFile {
	if s == nil {
		return nil
	}
	s.AudioTimeoutValue = &v
	return s
}

// The rules for handling the closed captions.
func (s StreamInputFileImpl) ClosedCaptions() map[string]string {
	return s.ClosedCaptionsValue
}

// The rules for handling the closed captions.
func (s *StreamInputFileImpl) SetClosedCaptions(v map[string]string) StreamInputFile {
	if s == nil {
		return nil
	}
	s.ClosedCaptionsValue = v
	return s
}

// Human-readable description of the input.
// Example: This is a test input
func (s StreamInputFileImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the input.
// Example: This is a test input
func (s *StreamInputFileImpl) SetComment(v string) StreamInputFile {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s StreamInputFileImpl) DenyIf() *string {
	return s.DenyIfValue
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s *StreamInputFileImpl) SetDenyIf(v string) StreamInputFile {
	if s == nil {
		return nil
	}
	s.DenyIfValue = &v
	return s
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s StreamInputFileImpl) FramesTimeout() *int {
	return s.FramesTimeoutValue
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s *StreamInputFileImpl) SetFramesTimeout(v int) StreamInputFile {
	if s == nil {
		return nil
	}
	s.FramesTimeoutValue = &v
	return s
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s StreamInputFileImpl) Headers() map[string]string {
	return s.HeadersValue
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s *StreamInputFileImpl) SetHeaders(v map[string]string) StreamInputFile {
	if s == nil {
		return nil
	}
	s.HeadersValue = v
	return s
}

// An array of MPEG-TS language descriptors in format `[{key: track, value: language}]`
func (s StreamInputFileImpl) Languages() map[string]string {
	return s.LanguagesValue
}

// An array of MPEG-TS language descriptors in format `[{key: track, value: language}]`
func (s *StreamInputFileImpl) SetLanguages(v map[string]string) StreamInputFile {
	if s == nil {
		return nil
	}
	s.LanguagesValue = v
	return s
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s StreamInputFileImpl) MaxRetryTimeout() *Seconds {
	return s.MaxRetryTimeoutValue
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s *StreamInputFileImpl) SetMaxRetryTimeout(v Seconds) StreamInputFile {
	if s == nil {
		return nil
	}
	s.MaxRetryTimeoutValue = &v
	return s
}

// Skip input start if the stream has no clients.
func (s StreamInputFileImpl) NoClientsReconnectDelay() *int {
	return s.NoClientsReconnectDelayValue
}

// Skip input start if the stream has no clients.
func (s *StreamInputFileImpl) SetNoClientsReconnectDelay(v int) StreamInputFile {
	if s == nil {
		return nil
	}
	s.NoClientsReconnectDelayValue = &v
	return s
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s StreamInputFileImpl) OutputAudio() *OutputAudio {
	return s.OutputAudioValue
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s *StreamInputFileImpl) SetOutputAudio(v OutputAudio) StreamInputFile {
	if s == nil {
		return nil
	}
	s.OutputAudioValue = &v
	return s
}

// Choose a specific PID to ingest from an MPEG-TS stream.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Example: [211]
func (s StreamInputFileImpl) Pids() []int {
	return s.PidsValue
}

// Choose a specific PID to ingest from an MPEG-TS stream.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Example: [211]
func (s *StreamInputFileImpl) SetPids(v []int) StreamInputFile {
	if s == nil {
		return nil
	}
	s.PidsValue = v
	return s
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s StreamInputFileImpl) Priority() *int {
	return s.PriorityValue
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s *StreamInputFileImpl) SetPriority(v int) StreamInputFile {
	if s == nil {
		return nil
	}
	s.PriorityValue = &v
	return s
}

// Choose a program to ingest from an MPEG-TS stream.
// Example: [1]
func (s StreamInputFileImpl) Programs() []int {
	return s.ProgramsValue
}

// Choose a program to ingest from an MPEG-TS stream.
// Example: [1]
func (s *StreamInputFileImpl) SetPrograms(v []int) StreamInputFile {
	if s == nil {
		return nil
	}
	s.ProgramsValue = v
	return s
}

// Deprecated field. Will be deleted at 23.09
// This option disables processing of SCTE-35 markers from an MPEG-TS input stream.
// Deprecated since 22.12.
// Available ways to disable processing of SCTE-35 markers:
// 1. pids option to select tracks without SCTE-35 markers
// 2. hls_scte35 option from stream_config_media for hls output
// 3. performing appropriate tuning pids in the transponder
// Example: true
func (s StreamInputFileImpl) Scte35() *bool {
	return s.Scte35Value
}

// Deprecated field. Will be deleted at 23.09
// This option disables processing of SCTE-35 markers from an MPEG-TS input stream.
// Deprecated since 22.12.
// Available ways to disable processing of SCTE-35 markers:
// 1. pids option to select tracks without SCTE-35 markers
// 2. hls_scte35 option from stream_config_media for hls output
// 3. performing appropriate tuning pids in the transponder
// Example: true
func (s *StreamInputFileImpl) SetScte35(v bool) StreamInputFile {
	if s == nil {
		return nil
	}
	s.Scte35Value = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s StreamInputFileImpl) SourceTimeout() any {
	return s.SourceTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s *StreamInputFileImpl) SetSourceTimeout(v any) StreamInputFile {
	if s == nil {
		return nil
	}
	s.SourceTimeoutValue = v
	return s
}

// Detailed runtime information about the input.
func (s StreamInputFileImpl) Stats() InputStats {
	return s.StatsValue
}

// Detailed runtime information about the input.
func (s *StreamInputFileImpl) SetStats(v InputStats) StreamInputFile {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// Deprecated field. Will be deleted at 25.03
// This configuration is deprecated. Use `dvbocr` configuration field in stream.
// This parameter allows to manage subtitles in an output stream.
// Example: drop
func (s StreamInputFileImpl) Subtitles() *StreamInputMpegtsSpecificSubtitles {
	return s.SubtitlesValue
}

// Deprecated field. Will be deleted at 25.03
// This configuration is deprecated. Use `dvbocr` configuration field in stream.
// This parameter allows to manage subtitles in an output stream.
// Example: drop
func (s *StreamInputFileImpl) SetSubtitles(v StreamInputMpegtsSpecificSubtitles) StreamInputFile {
	if s == nil {
		return nil
	}
	s.SubtitlesValue = &v
	return s
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s StreamInputFileImpl) Timeout() *int {
	return s.TimeoutValue
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s *StreamInputFileImpl) SetTimeout(v int) StreamInputFile {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// URL to get a stream from file.
// Format: input_url (input_url)
// Pattern: ^file://.*$
// Example: file://vod/bunny.mp4
func (s StreamInputFileImpl) URL() InputURL {
	return s.URLValue
}

// URL to get a stream from file.
// Format: input_url (input_url)
// Pattern: ^file://.*$
// Example: file://vod/bunny.mp4
func (s *StreamInputFileImpl) SetURL(v InputURL) StreamInputFile {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// User agent. Can be modified if a protocol allows it.
func (s StreamInputFileImpl) UserAgent() *string {
	return s.UserAgentValue
}

// User agent. Can be modified if a protocol allows it.
func (s *StreamInputFileImpl) SetUserAgent(v string) StreamInputFile {
	if s == nil {
		return nil
	}
	s.UserAgentValue = &v
	return s
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s StreamInputFileImpl) Via() *AgentURL {
	return s.ViaValue
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s *StreamInputFileImpl) SetVia(v AgentURL) StreamInputFile {
	if s == nil {
		return nil
	}
	s.ViaValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputFileImpl) VideoTimeout() *Seconds {
	return s.VideoTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputFileImpl) SetVideoTimeout(v Seconds) StreamInputFile {
	if s == nil {
		return nil
	}
	s.VideoTimeoutValue = &v
	return s
}

// NewStreamInputFrip creates a new StreamInputFrip instance
func NewStreamInputFrip() StreamInputFrip {
	return &StreamInputFripImpl{}
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s StreamInputFripImpl) AllowIf() *string {
	return s.AllowIfValue
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s *StreamInputFripImpl) SetAllowIf(v string) StreamInputFrip {
	if s == nil {
		return nil
	}
	s.AllowIfValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputFripImpl) AudioTimeout() *Seconds {
	return s.AudioTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputFripImpl) SetAudioTimeout(v Seconds) StreamInputFrip {
	if s == nil {
		return nil
	}
	s.AudioTimeoutValue = &v
	return s
}

// Human-readable description of the input.
// Example: This is a test input
func (s StreamInputFripImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the input.
// Example: This is a test input
func (s *StreamInputFripImpl) SetComment(v string) StreamInputFrip {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s StreamInputFripImpl) DenyIf() *string {
	return s.DenyIfValue
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s *StreamInputFripImpl) SetDenyIf(v string) StreamInputFrip {
	if s == nil {
		return nil
	}
	s.DenyIfValue = &v
	return s
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s StreamInputFripImpl) FramesTimeout() *int {
	return s.FramesTimeoutValue
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s *StreamInputFripImpl) SetFramesTimeout(v int) StreamInputFrip {
	if s == nil {
		return nil
	}
	s.FramesTimeoutValue = &v
	return s
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s StreamInputFripImpl) Headers() map[string]string {
	return s.HeadersValue
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s *StreamInputFripImpl) SetHeaders(v map[string]string) StreamInputFrip {
	if s == nil {
		return nil
	}
	s.HeadersValue = v
	return s
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s StreamInputFripImpl) MaxRetryTimeout() *Seconds {
	return s.MaxRetryTimeoutValue
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s *StreamInputFripImpl) SetMaxRetryTimeout(v Seconds) StreamInputFrip {
	if s == nil {
		return nil
	}
	s.MaxRetryTimeoutValue = &v
	return s
}

// Skip input start if the stream has no clients.
func (s StreamInputFripImpl) NoClientsReconnectDelay() *int {
	return s.NoClientsReconnectDelayValue
}

// Skip input start if the stream has no clients.
func (s *StreamInputFripImpl) SetNoClientsReconnectDelay(v int) StreamInputFrip {
	if s == nil {
		return nil
	}
	s.NoClientsReconnectDelayValue = &v
	return s
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s StreamInputFripImpl) OutputAudio() *OutputAudio {
	return s.OutputAudioValue
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s *StreamInputFripImpl) SetOutputAudio(v OutputAudio) StreamInputFrip {
	if s == nil {
		return nil
	}
	s.OutputAudioValue = &v
	return s
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s StreamInputFripImpl) Priority() *int {
	return s.PriorityValue
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s *StreamInputFripImpl) SetPriority(v int) StreamInputFrip {
	if s == nil {
		return nil
	}
	s.PriorityValue = &v
	return s
}

// Size of shared memory buffer. Omit to make it auto
// Example: 1.024e+06
func (s StreamInputFripImpl) ShmemSize() *int {
	return s.ShmemSizeValue
}

// Size of shared memory buffer. Omit to make it auto
// Example: 1.024e+06
func (s *StreamInputFripImpl) SetShmemSize(v int) StreamInputFrip {
	if s == nil {
		return nil
	}
	s.ShmemSizeValue = &v
	return s
}

// Directory for shmem files
// Example: tmp
func (s StreamInputFripImpl) SocketDir() *string {
	return s.SocketDirValue
}

// Directory for shmem files
// Example: tmp
func (s *StreamInputFripImpl) SetSocketDir(v string) StreamInputFrip {
	if s == nil {
		return nil
	}
	s.SocketDirValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s StreamInputFripImpl) SourceTimeout() any {
	return s.SourceTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s *StreamInputFripImpl) SetSourceTimeout(v any) StreamInputFrip {
	if s == nil {
		return nil
	}
	s.SourceTimeoutValue = v
	return s
}

// Detailed runtime information about the input.
func (s StreamInputFripImpl) Stats() InputStats {
	return s.StatsValue
}

// Detailed runtime information about the input.
func (s *StreamInputFripImpl) SetStats(v InputStats) StreamInputFrip {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s StreamInputFripImpl) Timeout() *int {
	return s.TimeoutValue
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s *StreamInputFripImpl) SetTimeout(v int) StreamInputFrip {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// FRIP input. Can be a cmd if started from `-` or an existing socket.
// Format: input_url (input_url)
// Pattern: ^frip://.*$
// Examples: frip://-contrib/devel/simulator.erl, frip://hostname/Source1
func (s StreamInputFripImpl) URL() InputURL {
	return s.URLValue
}

// FRIP input. Can be a cmd if started from `-` or an existing socket.
// Format: input_url (input_url)
// Pattern: ^frip://.*$
// Examples: frip://-contrib/devel/simulator.erl, frip://hostname/Source1
func (s *StreamInputFripImpl) SetURL(v InputURL) StreamInputFrip {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// User agent. Can be modified if a protocol allows it.
func (s StreamInputFripImpl) UserAgent() *string {
	return s.UserAgentValue
}

// User agent. Can be modified if a protocol allows it.
func (s *StreamInputFripImpl) SetUserAgent(v string) StreamInputFrip {
	if s == nil {
		return nil
	}
	s.UserAgentValue = &v
	return s
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s StreamInputFripImpl) Via() *AgentURL {
	return s.ViaValue
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s *StreamInputFripImpl) SetVia(v AgentURL) StreamInputFrip {
	if s == nil {
		return nil
	}
	s.ViaValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputFripImpl) VideoTimeout() *Seconds {
	return s.VideoTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputFripImpl) SetVideoTimeout(v Seconds) StreamInputFrip {
	if s == nil {
		return nil
	}
	s.VideoTimeoutValue = &v
	return s
}

// NewStreamInputH323 creates a new StreamInputH323 instance
func NewStreamInputH323() StreamInputH323 {
	return &StreamInputH323Impl{}
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s StreamInputH323Impl) AllowIf() *string {
	return s.AllowIfValue
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s *StreamInputH323Impl) SetAllowIf(v string) StreamInputH323 {
	if s == nil {
		return nil
	}
	s.AllowIfValue = &v
	return s
}

// H323 audio bitrate.
// Format: speed (speed)
func (s StreamInputH323Impl) AudioBitrate() *Speed {
	return s.AudioBitrateValue
}

// H323 audio bitrate.
// Format: speed (speed)
func (s *StreamInputH323Impl) SetAudioBitrate(v Speed) StreamInputH323 {
	if s == nil {
		return nil
	}
	s.AudioBitrateValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputH323Impl) AudioTimeout() *Seconds {
	return s.AudioTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputH323Impl) SetAudioTimeout(v Seconds) StreamInputH323 {
	if s == nil {
		return nil
	}
	s.AudioTimeoutValue = &v
	return s
}

// Human-readable description of the input.
// Example: This is a test input
func (s StreamInputH323Impl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the input.
// Example: This is a test input
func (s *StreamInputH323Impl) SetComment(v string) StreamInputH323 {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// H323 connections.
func (s StreamInputH323Impl) Connections() *int {
	return s.ConnectionsValue
}

// H323 connections.
func (s *StreamInputH323Impl) SetConnections(v int) StreamInputH323 {
	if s == nil {
		return nil
	}
	s.ConnectionsValue = &v
	return s
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s StreamInputH323Impl) DenyIf() *string {
	return s.DenyIfValue
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s *StreamInputH323Impl) SetDenyIf(v string) StreamInputH323 {
	if s == nil {
		return nil
	}
	s.DenyIfValue = &v
	return s
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s StreamInputH323Impl) FramesTimeout() *int {
	return s.FramesTimeoutValue
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s *StreamInputH323Impl) SetFramesTimeout(v int) StreamInputH323 {
	if s == nil {
		return nil
	}
	s.FramesTimeoutValue = &v
	return s
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s StreamInputH323Impl) Headers() map[string]string {
	return s.HeadersValue
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s *StreamInputH323Impl) SetHeaders(v map[string]string) StreamInputH323 {
	if s == nil {
		return nil
	}
	s.HeadersValue = v
	return s
}

// H323 input ID.
func (s StreamInputH323Impl) ID() *string {
	return s.IDValue
}

// H323 input ID.
func (s *StreamInputH323Impl) SetID(v string) StreamInputH323 {
	if s == nil {
		return nil
	}
	s.IDValue = &v
	return s
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s StreamInputH323Impl) MaxRetryTimeout() *Seconds {
	return s.MaxRetryTimeoutValue
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s *StreamInputH323Impl) SetMaxRetryTimeout(v Seconds) StreamInputH323 {
	if s == nil {
		return nil
	}
	s.MaxRetryTimeoutValue = &v
	return s
}

// Skip input start if the stream has no clients.
func (s StreamInputH323Impl) NoClientsReconnectDelay() *int {
	return s.NoClientsReconnectDelayValue
}

// Skip input start if the stream has no clients.
func (s *StreamInputH323Impl) SetNoClientsReconnectDelay(v int) StreamInputH323 {
	if s == nil {
		return nil
	}
	s.NoClientsReconnectDelayValue = &v
	return s
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s StreamInputH323Impl) OutputAudio() *OutputAudio {
	return s.OutputAudioValue
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s *StreamInputH323Impl) SetOutputAudio(v OutputAudio) StreamInputH323 {
	if s == nil {
		return nil
	}
	s.OutputAudioValue = &v
	return s
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s StreamInputH323Impl) Priority() *int {
	return s.PriorityValue
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s *StreamInputH323Impl) SetPriority(v int) StreamInputH323 {
	if s == nil {
		return nil
	}
	s.PriorityValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s StreamInputH323Impl) SourceTimeout() any {
	return s.SourceTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s *StreamInputH323Impl) SetSourceTimeout(v any) StreamInputH323 {
	if s == nil {
		return nil
	}
	s.SourceTimeoutValue = v
	return s
}

// Detailed runtime information about the input.
func (s StreamInputH323Impl) Stats() InputStats {
	return s.StatsValue
}

// Detailed runtime information about the input.
func (s *StreamInputH323Impl) SetStats(v InputStats) StreamInputH323 {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s StreamInputH323Impl) Timeout() *int {
	return s.TimeoutValue
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s *StreamInputH323Impl) SetTimeout(v int) StreamInputH323 {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// URL to connect to the H323 source and get the stream.
// Format: input_url (input_url)
// Pattern: ^h323://.*$
// Example: h323://192.168.100.150
func (s StreamInputH323Impl) URL() InputURL {
	return s.URLValue
}

// URL to connect to the H323 source and get the stream.
// Format: input_url (input_url)
// Pattern: ^h323://.*$
// Example: h323://192.168.100.150
func (s *StreamInputH323Impl) SetURL(v InputURL) StreamInputH323 {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// User agent. Can be modified if a protocol allows it.
func (s StreamInputH323Impl) UserAgent() *string {
	return s.UserAgentValue
}

// User agent. Can be modified if a protocol allows it.
func (s *StreamInputH323Impl) SetUserAgent(v string) StreamInputH323 {
	if s == nil {
		return nil
	}
	s.UserAgentValue = &v
	return s
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s StreamInputH323Impl) Via() *AgentURL {
	return s.ViaValue
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s *StreamInputH323Impl) SetVia(v AgentURL) StreamInputH323 {
	if s == nil {
		return nil
	}
	s.ViaValue = &v
	return s
}

// H323 input bitrate.
// Format: speed (speed)
func (s StreamInputH323Impl) VideoBitrate() *Speed {
	return s.VideoBitrateValue
}

// H323 input bitrate.
// Format: speed (speed)
func (s *StreamInputH323Impl) SetVideoBitrate(v Speed) StreamInputH323 {
	if s == nil {
		return nil
	}
	s.VideoBitrateValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputH323Impl) VideoTimeout() *Seconds {
	return s.VideoTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputH323Impl) SetVideoTimeout(v Seconds) StreamInputH323 {
	if s == nil {
		return nil
	}
	s.VideoTimeoutValue = &v
	return s
}

// NewStreamInputHls creates a new StreamInputHls instance
func NewStreamInputHls() StreamInputHls {
	return &StreamInputHlsImpl{}
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s StreamInputHlsImpl) AllowIf() *string {
	return s.AllowIfValue
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s *StreamInputHlsImpl) SetAllowIf(v string) StreamInputHls {
	if s == nil {
		return nil
	}
	s.AllowIfValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputHlsImpl) AudioTimeout() *Seconds {
	return s.AudioTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputHlsImpl) SetAudioTimeout(v Seconds) StreamInputHls {
	if s == nil {
		return nil
	}
	s.AudioTimeoutValue = &v
	return s
}

// The rules for handling the closed captions.
func (s StreamInputHlsImpl) ClosedCaptions() map[string]string {
	return s.ClosedCaptionsValue
}

// The rules for handling the closed captions.
func (s *StreamInputHlsImpl) SetClosedCaptions(v map[string]string) StreamInputHls {
	if s == nil {
		return nil
	}
	s.ClosedCaptionsValue = v
	return s
}

// Human-readable description of the input.
// Example: This is a test input
func (s StreamInputHlsImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the input.
// Example: This is a test input
func (s *StreamInputHlsImpl) SetComment(v string) StreamInputHls {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s StreamInputHlsImpl) DenyIf() *string {
	return s.DenyIfValue
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s *StreamInputHlsImpl) SetDenyIf(v string) StreamInputHls {
	if s == nil {
		return nil
	}
	s.DenyIfValue = &v
	return s
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s StreamInputHlsImpl) FramesTimeout() *int {
	return s.FramesTimeoutValue
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s *StreamInputHlsImpl) SetFramesTimeout(v int) StreamInputHls {
	if s == nil {
		return nil
	}
	s.FramesTimeoutValue = &v
	return s
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s StreamInputHlsImpl) Headers() map[string]string {
	return s.HeadersValue
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s *StreamInputHlsImpl) SetHeaders(v map[string]string) StreamInputHls {
	if s == nil {
		return nil
	}
	s.HeadersValue = v
	return s
}

// An array of MPEG-TS language descriptors in format `[{key: track, value: language}]`
func (s StreamInputHlsImpl) Languages() map[string]string {
	return s.LanguagesValue
}

// An array of MPEG-TS language descriptors in format `[{key: track, value: language}]`
func (s *StreamInputHlsImpl) SetLanguages(v map[string]string) StreamInputHls {
	if s == nil {
		return nil
	}
	s.LanguagesValue = v
	return s
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s StreamInputHlsImpl) MaxRetryTimeout() *Seconds {
	return s.MaxRetryTimeoutValue
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s *StreamInputHlsImpl) SetMaxRetryTimeout(v Seconds) StreamInputHls {
	if s == nil {
		return nil
	}
	s.MaxRetryTimeoutValue = &v
	return s
}

// Skip input start if the stream has no clients.
func (s StreamInputHlsImpl) NoClientsReconnectDelay() *int {
	return s.NoClientsReconnectDelayValue
}

// Skip input start if the stream has no clients.
func (s *StreamInputHlsImpl) SetNoClientsReconnectDelay(v int) StreamInputHls {
	if s == nil {
		return nil
	}
	s.NoClientsReconnectDelayValue = &v
	return s
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s StreamInputHlsImpl) OutputAudio() *OutputAudio {
	return s.OutputAudioValue
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s *StreamInputHlsImpl) SetOutputAudio(v OutputAudio) StreamInputHls {
	if s == nil {
		return nil
	}
	s.OutputAudioValue = &v
	return s
}

// Choose a specific PID to ingest from an MPEG-TS stream.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Example: [211]
func (s StreamInputHlsImpl) Pids() []int {
	return s.PidsValue
}

// Choose a specific PID to ingest from an MPEG-TS stream.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Example: [211]
func (s *StreamInputHlsImpl) SetPids(v []int) StreamInputHls {
	if s == nil {
		return nil
	}
	s.PidsValue = v
	return s
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s StreamInputHlsImpl) Priority() *int {
	return s.PriorityValue
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s *StreamInputHlsImpl) SetPriority(v int) StreamInputHls {
	if s == nil {
		return nil
	}
	s.PriorityValue = &v
	return s
}

// Choose a program to ingest from an MPEG-TS stream.
// Example: [1]
func (s StreamInputHlsImpl) Programs() []int {
	return s.ProgramsValue
}

// Choose a program to ingest from an MPEG-TS stream.
// Example: [1]
func (s *StreamInputHlsImpl) SetPrograms(v []int) StreamInputHls {
	if s == nil {
		return nil
	}
	s.ProgramsValue = v
	return s
}

// Deprecated field. Will be deleted at 23.09
// This option disables processing of SCTE-35 markers from an MPEG-TS input stream.
// Deprecated since 22.12.
// Available ways to disable processing of SCTE-35 markers:
// 1. pids option to select tracks without SCTE-35 markers
// 2. hls_scte35 option from stream_config_media for hls output
// 3. performing appropriate tuning pids in the transponder
// Example: true
func (s StreamInputHlsImpl) Scte35() *bool {
	return s.Scte35Value
}

// Deprecated field. Will be deleted at 23.09
// This option disables processing of SCTE-35 markers from an MPEG-TS input stream.
// Deprecated since 22.12.
// Available ways to disable processing of SCTE-35 markers:
// 1. pids option to select tracks without SCTE-35 markers
// 2. hls_scte35 option from stream_config_media for hls output
// 3. performing appropriate tuning pids in the transponder
// Example: true
func (s *StreamInputHlsImpl) SetScte35(v bool) StreamInputHls {
	if s == nil {
		return nil
	}
	s.Scte35Value = &v
	return s
}

// By default Flussonic will wait for at least 2-3 new segments before making stream available.
// This parameter allows to disable this protection. Use it at your own risk - with it enabled, old content might be repeated over and over.
func (s StreamInputHlsImpl) SkipStalledCheck() *bool {
	return s.SkipStalledCheckValue
}

// By default Flussonic will wait for at least 2-3 new segments before making stream available.
// This parameter allows to disable this protection. Use it at your own risk - with it enabled, old content might be repeated over and over.
func (s *StreamInputHlsImpl) SetSkipStalledCheck(v bool) StreamInputHls {
	if s == nil {
		return nil
	}
	s.SkipStalledCheckValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s StreamInputHlsImpl) SourceTimeout() any {
	return s.SourceTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s *StreamInputHlsImpl) SetSourceTimeout(v any) StreamInputHls {
	if s == nil {
		return nil
	}
	s.SourceTimeoutValue = v
	return s
}

// Detailed runtime information about the input.
func (s StreamInputHlsImpl) Stats() InputStats {
	return s.StatsValue
}

// Detailed runtime information about the input.
func (s *StreamInputHlsImpl) SetStats(v InputStats) StreamInputHls {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// Deprecated field. Will be deleted at 25.03
// This configuration is deprecated. Use `dvbocr` configuration field in stream.
// This parameter allows to manage subtitles in an output stream.
// Example: drop
func (s StreamInputHlsImpl) Subtitles() *StreamInputMpegtsSpecificSubtitles {
	return s.SubtitlesValue
}

// Deprecated field. Will be deleted at 25.03
// This configuration is deprecated. Use `dvbocr` configuration field in stream.
// This parameter allows to manage subtitles in an output stream.
// Example: drop
func (s *StreamInputHlsImpl) SetSubtitles(v StreamInputMpegtsSpecificSubtitles) StreamInputHls {
	if s == nil {
		return nil
	}
	s.SubtitlesValue = &v
	return s
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s StreamInputHlsImpl) Timeout() *int {
	return s.TimeoutValue
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s *StreamInputHlsImpl) SetTimeout(v int) StreamInputHls {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// URL to get a stream from HLS source.
// Format: input_url (input_url)
// Pattern: ^(hls|hlss|hls2|hlss2)://.*$|^(http|https)://.*\.m3u8((#|\?).*)?$
// Examples: hls2://remote.host.com/example/video.m3u8, hls://remote.host.com/example/index.m3u8, hls://remote.host.com/example/video.m3u8, hlss2://remote.host.com/example/video.m3u8, hlss://remote.host.com/example/video.m3u8, http://remote.host.com/index.m3u8, https://remote.host.com/index.m3u8
func (s StreamInputHlsImpl) URL() InputURL {
	return s.URLValue
}

// URL to get a stream from HLS source.
// Format: input_url (input_url)
// Pattern: ^(hls|hlss|hls2|hlss2)://.*$|^(http|https)://.*\.m3u8((#|\?).*)?$
// Examples: hls2://remote.host.com/example/video.m3u8, hls://remote.host.com/example/index.m3u8, hls://remote.host.com/example/video.m3u8, hlss2://remote.host.com/example/video.m3u8, hlss://remote.host.com/example/video.m3u8, http://remote.host.com/index.m3u8, https://remote.host.com/index.m3u8
func (s *StreamInputHlsImpl) SetURL(v InputURL) StreamInputHls {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// User agent. Can be modified if a protocol allows it.
func (s StreamInputHlsImpl) UserAgent() *string {
	return s.UserAgentValue
}

// User agent. Can be modified if a protocol allows it.
func (s *StreamInputHlsImpl) SetUserAgent(v string) StreamInputHls {
	if s == nil {
		return nil
	}
	s.UserAgentValue = &v
	return s
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s StreamInputHlsImpl) Via() *AgentURL {
	return s.ViaValue
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s *StreamInputHlsImpl) SetVia(v AgentURL) StreamInputHls {
	if s == nil {
		return nil
	}
	s.ViaValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputHlsImpl) VideoTimeout() *Seconds {
	return s.VideoTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputHlsImpl) SetVideoTimeout(v Seconds) StreamInputHls {
	if s == nil {
		return nil
	}
	s.VideoTimeoutValue = &v
	return s
}

// NewStreamInputM4f creates a new StreamInputM4f instance
func NewStreamInputM4f() StreamInputM4f {
	return &StreamInputM4fImpl{}
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s StreamInputM4fImpl) AllowIf() *string {
	return s.AllowIfValue
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s *StreamInputM4fImpl) SetAllowIf(v string) StreamInputM4f {
	if s == nil {
		return nil
	}
	s.AllowIfValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputM4fImpl) AudioTimeout() *Seconds {
	return s.AudioTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputM4fImpl) SetAudioTimeout(v Seconds) StreamInputM4f {
	if s == nil {
		return nil
	}
	s.AudioTimeoutValue = &v
	return s
}

// The rules for handling the closed captions.
func (s StreamInputM4fImpl) ClosedCaptions() map[string]string {
	return s.ClosedCaptionsValue
}

// The rules for handling the closed captions.
func (s *StreamInputM4fImpl) SetClosedCaptions(v map[string]string) StreamInputM4f {
	if s == nil {
		return nil
	}
	s.ClosedCaptionsValue = v
	return s
}

// Human-readable description of the input.
// Example: This is a test input
func (s StreamInputM4fImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the input.
// Example: This is a test input
func (s *StreamInputM4fImpl) SetComment(v string) StreamInputM4f {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s StreamInputM4fImpl) DenyIf() *string {
	return s.DenyIfValue
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s *StreamInputM4fImpl) SetDenyIf(v string) StreamInputM4f {
	if s == nil {
		return nil
	}
	s.DenyIfValue = &v
	return s
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s StreamInputM4fImpl) FramesTimeout() *int {
	return s.FramesTimeoutValue
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s *StreamInputM4fImpl) SetFramesTimeout(v int) StreamInputM4f {
	if s == nil {
		return nil
	}
	s.FramesTimeoutValue = &v
	return s
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s StreamInputM4fImpl) Headers() map[string]string {
	return s.HeadersValue
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s *StreamInputM4fImpl) SetHeaders(v map[string]string) StreamInputM4f {
	if s == nil {
		return nil
	}
	s.HeadersValue = v
	return s
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s StreamInputM4fImpl) MaxRetryTimeout() *Seconds {
	return s.MaxRetryTimeoutValue
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s *StreamInputM4fImpl) SetMaxRetryTimeout(v Seconds) StreamInputM4f {
	if s == nil {
		return nil
	}
	s.MaxRetryTimeoutValue = &v
	return s
}

// Skip input start if the stream has no clients.
func (s StreamInputM4fImpl) NoClientsReconnectDelay() *int {
	return s.NoClientsReconnectDelayValue
}

// Skip input start if the stream has no clients.
func (s *StreamInputM4fImpl) SetNoClientsReconnectDelay(v int) StreamInputM4f {
	if s == nil {
		return nil
	}
	s.NoClientsReconnectDelayValue = &v
	return s
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s StreamInputM4fImpl) OutputAudio() *OutputAudio {
	return s.OutputAudioValue
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s *StreamInputM4fImpl) SetOutputAudio(v OutputAudio) StreamInputM4f {
	if s == nil {
		return nil
	}
	s.OutputAudioValue = &v
	return s
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s StreamInputM4fImpl) Priority() *int {
	return s.PriorityValue
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s *StreamInputM4fImpl) SetPriority(v int) StreamInputM4f {
	if s == nil {
		return nil
	}
	s.PriorityValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s StreamInputM4fImpl) SourceTimeout() any {
	return s.SourceTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s *StreamInputM4fImpl) SetSourceTimeout(v any) StreamInputM4f {
	if s == nil {
		return nil
	}
	s.SourceTimeoutValue = v
	return s
}

// Detailed runtime information about the input.
func (s StreamInputM4fImpl) Stats() InputStats {
	return s.StatsValue
}

// Detailed runtime information about the input.
func (s *StreamInputM4fImpl) SetStats(v InputStats) StreamInputM4f {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s StreamInputM4fImpl) Timeout() *int {
	return s.TimeoutValue
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s *StreamInputM4fImpl) SetTimeout(v int) StreamInputM4f {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// URL to get a stream from m4f source.
// Format: input_url (input_url)
// Pattern: ^(m4f|m4fs)://.*$
// Examples: m4f://remote.host.com/example, m4fs://remote.host.com/example
func (s StreamInputM4fImpl) URL() InputURL {
	return s.URLValue
}

// URL to get a stream from m4f source.
// Format: input_url (input_url)
// Pattern: ^(m4f|m4fs)://.*$
// Examples: m4f://remote.host.com/example, m4fs://remote.host.com/example
func (s *StreamInputM4fImpl) SetURL(v InputURL) StreamInputM4f {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// User agent. Can be modified if a protocol allows it.
func (s StreamInputM4fImpl) UserAgent() *string {
	return s.UserAgentValue
}

// User agent. Can be modified if a protocol allows it.
func (s *StreamInputM4fImpl) SetUserAgent(v string) StreamInputM4f {
	if s == nil {
		return nil
	}
	s.UserAgentValue = &v
	return s
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s StreamInputM4fImpl) Via() *AgentURL {
	return s.ViaValue
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s *StreamInputM4fImpl) SetVia(v AgentURL) StreamInputM4f {
	if s == nil {
		return nil
	}
	s.ViaValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputM4fImpl) VideoTimeout() *Seconds {
	return s.VideoTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputM4fImpl) SetVideoTimeout(v Seconds) StreamInputM4f {
	if s == nil {
		return nil
	}
	s.VideoTimeoutValue = &v
	return s
}

// NewStreamInputM4s creates a new StreamInputM4s instance
func NewStreamInputM4s() StreamInputM4s {
	return &StreamInputM4sImpl{}
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s StreamInputM4sImpl) AllowIf() *string {
	return s.AllowIfValue
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s *StreamInputM4sImpl) SetAllowIf(v string) StreamInputM4s {
	if s == nil {
		return nil
	}
	s.AllowIfValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputM4sImpl) AudioTimeout() *Seconds {
	return s.AudioTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputM4sImpl) SetAudioTimeout(v Seconds) StreamInputM4s {
	if s == nil {
		return nil
	}
	s.AudioTimeoutValue = &v
	return s
}

// The rules for handling the closed captions.
func (s StreamInputM4sImpl) ClosedCaptions() map[string]string {
	return s.ClosedCaptionsValue
}

// The rules for handling the closed captions.
func (s *StreamInputM4sImpl) SetClosedCaptions(v map[string]string) StreamInputM4s {
	if s == nil {
		return nil
	}
	s.ClosedCaptionsValue = v
	return s
}

// Human-readable description of the input.
// Example: This is a test input
func (s StreamInputM4sImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the input.
// Example: This is a test input
func (s *StreamInputM4sImpl) SetComment(v string) StreamInputM4s {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s StreamInputM4sImpl) DenyIf() *string {
	return s.DenyIfValue
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s *StreamInputM4sImpl) SetDenyIf(v string) StreamInputM4s {
	if s == nil {
		return nil
	}
	s.DenyIfValue = &v
	return s
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s StreamInputM4sImpl) FramesTimeout() *int {
	return s.FramesTimeoutValue
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s *StreamInputM4sImpl) SetFramesTimeout(v int) StreamInputM4s {
	if s == nil {
		return nil
	}
	s.FramesTimeoutValue = &v
	return s
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s StreamInputM4sImpl) Headers() map[string]string {
	return s.HeadersValue
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s *StreamInputM4sImpl) SetHeaders(v map[string]string) StreamInputM4s {
	if s == nil {
		return nil
	}
	s.HeadersValue = v
	return s
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s StreamInputM4sImpl) MaxRetryTimeout() *Seconds {
	return s.MaxRetryTimeoutValue
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s *StreamInputM4sImpl) SetMaxRetryTimeout(v Seconds) StreamInputM4s {
	if s == nil {
		return nil
	}
	s.MaxRetryTimeoutValue = &v
	return s
}

// Skip input start if the stream has no clients.
func (s StreamInputM4sImpl) NoClientsReconnectDelay() *int {
	return s.NoClientsReconnectDelayValue
}

// Skip input start if the stream has no clients.
func (s *StreamInputM4sImpl) SetNoClientsReconnectDelay(v int) StreamInputM4s {
	if s == nil {
		return nil
	}
	s.NoClientsReconnectDelayValue = &v
	return s
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s StreamInputM4sImpl) OutputAudio() *OutputAudio {
	return s.OutputAudioValue
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s *StreamInputM4sImpl) SetOutputAudio(v OutputAudio) StreamInputM4s {
	if s == nil {
		return nil
	}
	s.OutputAudioValue = &v
	return s
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s StreamInputM4sImpl) Priority() *int {
	return s.PriorityValue
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s *StreamInputM4sImpl) SetPriority(v int) StreamInputM4s {
	if s == nil {
		return nil
	}
	s.PriorityValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s StreamInputM4sImpl) SourceTimeout() any {
	return s.SourceTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s *StreamInputM4sImpl) SetSourceTimeout(v any) StreamInputM4s {
	if s == nil {
		return nil
	}
	s.SourceTimeoutValue = v
	return s
}

// Detailed runtime information about the input.
func (s StreamInputM4sImpl) Stats() InputStats {
	return s.StatsValue
}

// Detailed runtime information about the input.
func (s *StreamInputM4sImpl) SetStats(v InputStats) StreamInputM4s {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s StreamInputM4sImpl) Timeout() *int {
	return s.TimeoutValue
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s *StreamInputM4sImpl) SetTimeout(v int) StreamInputM4s {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// URL to get a stream from m4s source.
// Format: input_url (input_url)
// Pattern: ^(m4s|m4ss)://.*$
// Examples: m4s://remote.host.com/example, m4ss://remote.host.com/example
func (s StreamInputM4sImpl) URL() InputURL {
	return s.URLValue
}

// URL to get a stream from m4s source.
// Format: input_url (input_url)
// Pattern: ^(m4s|m4ss)://.*$
// Examples: m4s://remote.host.com/example, m4ss://remote.host.com/example
func (s *StreamInputM4sImpl) SetURL(v InputURL) StreamInputM4s {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// User agent. Can be modified if a protocol allows it.
func (s StreamInputM4sImpl) UserAgent() *string {
	return s.UserAgentValue
}

// User agent. Can be modified if a protocol allows it.
func (s *StreamInputM4sImpl) SetUserAgent(v string) StreamInputM4s {
	if s == nil {
		return nil
	}
	s.UserAgentValue = &v
	return s
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s StreamInputM4sImpl) Via() *AgentURL {
	return s.ViaValue
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s *StreamInputM4sImpl) SetVia(v AgentURL) StreamInputM4s {
	if s == nil {
		return nil
	}
	s.ViaValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputM4sImpl) VideoTimeout() *Seconds {
	return s.VideoTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputM4sImpl) SetVideoTimeout(v Seconds) StreamInputM4s {
	if s == nil {
		return nil
	}
	s.VideoTimeoutValue = &v
	return s
}

// NewStreamInputMixer creates a new StreamInputMixer instance
func NewStreamInputMixer() StreamInputMixer {
	return &StreamInputMixerImpl{}
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s StreamInputMixerImpl) AllowIf() *string {
	return s.AllowIfValue
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s *StreamInputMixerImpl) SetAllowIf(v string) StreamInputMixer {
	if s == nil {
		return nil
	}
	s.AllowIfValue = &v
	return s
}

// Deprecated field. Will be deleted at 23.09
// Moves audio timestamp forwards or backwards on a specified number of milliseconds.
// Format: milliseconds (milliseconds)
func (s StreamInputMixerImpl) AudioAdd() *Milliseconds {
	return s.AudioAddValue
}

// Deprecated field. Will be deleted at 23.09
// Moves audio timestamp forwards or backwards on a specified number of milliseconds.
// Format: milliseconds (milliseconds)
func (s *StreamInputMixerImpl) SetAudioAdd(v Milliseconds) StreamInputMixer {
	if s == nil {
		return nil
	}
	s.AudioAddValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputMixerImpl) AudioTimeout() *Seconds {
	return s.AudioTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputMixerImpl) SetAudioTimeout(v Seconds) StreamInputMixer {
	if s == nil {
		return nil
	}
	s.AudioTimeoutValue = &v
	return s
}

// Human-readable description of the input.
// Example: This is a test input
func (s StreamInputMixerImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the input.
// Example: This is a test input
func (s *StreamInputMixerImpl) SetComment(v string) StreamInputMixer {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s StreamInputMixerImpl) DenyIf() *string {
	return s.DenyIfValue
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s *StreamInputMixerImpl) SetDenyIf(v string) StreamInputMixer {
	if s == nil {
		return nil
	}
	s.DenyIfValue = &v
	return s
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s StreamInputMixerImpl) FramesTimeout() *int {
	return s.FramesTimeoutValue
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s *StreamInputMixerImpl) SetFramesTimeout(v int) StreamInputMixer {
	if s == nil {
		return nil
	}
	s.FramesTimeoutValue = &v
	return s
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s StreamInputMixerImpl) Headers() map[string]string {
	return s.HeadersValue
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s *StreamInputMixerImpl) SetHeaders(v map[string]string) StreamInputMixer {
	if s == nil {
		return nil
	}
	s.HeadersValue = v
	return s
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s StreamInputMixerImpl) MaxRetryTimeout() *Seconds {
	return s.MaxRetryTimeoutValue
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s *StreamInputMixerImpl) SetMaxRetryTimeout(v Seconds) StreamInputMixer {
	if s == nil {
		return nil
	}
	s.MaxRetryTimeoutValue = &v
	return s
}

// The mixing mode for the `mixer://` input type.
func (s StreamInputMixerImpl) MixerStrategy() *StreamInputMixerMixerStrategy {
	return s.MixerStrategyValue
}

// The mixing mode for the `mixer://` input type.
func (s *StreamInputMixerImpl) SetMixerStrategy(v StreamInputMixerMixerStrategy) StreamInputMixer {
	if s == nil {
		return nil
	}
	s.MixerStrategyValue = &v
	return s
}

// Skip input start if the stream has no clients.
func (s StreamInputMixerImpl) NoClientsReconnectDelay() *int {
	return s.NoClientsReconnectDelayValue
}

// Skip input start if the stream has no clients.
func (s *StreamInputMixerImpl) SetNoClientsReconnectDelay(v int) StreamInputMixer {
	if s == nil {
		return nil
	}
	s.NoClientsReconnectDelayValue = &v
	return s
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s StreamInputMixerImpl) OutputAudio() *OutputAudio {
	return s.OutputAudioValue
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s *StreamInputMixerImpl) SetOutputAudio(v OutputAudio) StreamInputMixer {
	if s == nil {
		return nil
	}
	s.OutputAudioValue = &v
	return s
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s StreamInputMixerImpl) Priority() *int {
	return s.PriorityValue
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s *StreamInputMixerImpl) SetPriority(v int) StreamInputMixer {
	if s == nil {
		return nil
	}
	s.PriorityValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s StreamInputMixerImpl) SourceTimeout() any {
	return s.SourceTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s *StreamInputMixerImpl) SetSourceTimeout(v any) StreamInputMixer {
	if s == nil {
		return nil
	}
	s.SourceTimeoutValue = v
	return s
}

// Detailed runtime information about the input.
func (s StreamInputMixerImpl) Stats() InputStats {
	return s.StatsValue
}

// Detailed runtime information about the input.
func (s *StreamInputMixerImpl) SetStats(v InputStats) StreamInputMixer {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// This parameter is used for a mixer stream that uses other streams as its video and audio sources.
// If the parameter is set to `realtime`, audio frames will be played in sync with video frames:
// if the difference between timestamps of an audio frame and a corresponding video frame is more than 2 seconds,
// the audio frame will be played at the timestamp of the video frame.
// If this parameter is set to `dts`, no synchronization is performed.
// Example: dts
func (s StreamInputMixerImpl) Sync() *string {
	return s.SyncValue
}

// This parameter is used for a mixer stream that uses other streams as its video and audio sources.
// If the parameter is set to `realtime`, audio frames will be played in sync with video frames:
// if the difference between timestamps of an audio frame and a corresponding video frame is more than 2 seconds,
// the audio frame will be played at the timestamp of the video frame.
// If this parameter is set to `dts`, no synchronization is performed.
// Example: dts
func (s *StreamInputMixerImpl) SetSync(v string) StreamInputMixer {
	if s == nil {
		return nil
	}
	s.SyncValue = &v
	return s
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s StreamInputMixerImpl) Timeout() *int {
	return s.TimeoutValue
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s *StreamInputMixerImpl) SetTimeout(v int) StreamInputMixer {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// URL to make a mixer stream from other streams.
// Format: input_url (input_url)
// Pattern: ^mixer://.*$
// Example: mixer://stream1,stream2
func (s StreamInputMixerImpl) URL() InputURL {
	return s.URLValue
}

// URL to make a mixer stream from other streams.
// Format: input_url (input_url)
// Pattern: ^mixer://.*$
// Example: mixer://stream1,stream2
func (s *StreamInputMixerImpl) SetURL(v InputURL) StreamInputMixer {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// User agent. Can be modified if a protocol allows it.
func (s StreamInputMixerImpl) UserAgent() *string {
	return s.UserAgentValue
}

// User agent. Can be modified if a protocol allows it.
func (s *StreamInputMixerImpl) SetUserAgent(v string) StreamInputMixer {
	if s == nil {
		return nil
	}
	s.UserAgentValue = &v
	return s
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s StreamInputMixerImpl) Via() *AgentURL {
	return s.ViaValue
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s *StreamInputMixerImpl) SetVia(v AgentURL) StreamInputMixer {
	if s == nil {
		return nil
	}
	s.ViaValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputMixerImpl) VideoTimeout() *Seconds {
	return s.VideoTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputMixerImpl) SetVideoTimeout(v Seconds) StreamInputMixer {
	if s == nil {
		return nil
	}
	s.VideoTimeoutValue = &v
	return s
}

// NewStreamInputMosaic creates a new StreamInputMosaic instance
func NewStreamInputMosaic() StreamInputMosaic {
	return &StreamInputMosaicImpl{}
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s StreamInputMosaicImpl) AllowIf() *string {
	return s.AllowIfValue
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s *StreamInputMosaicImpl) SetAllowIf(v string) StreamInputMosaic {
	if s == nil {
		return nil
	}
	s.AllowIfValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputMosaicImpl) AudioTimeout() *Seconds {
	return s.AudioTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputMosaicImpl) SetAudioTimeout(v Seconds) StreamInputMosaic {
	if s == nil {
		return nil
	}
	s.AudioTimeoutValue = &v
	return s
}

// Bitrate of the audio.
// Format: speed (speed)
func (s StreamInputMosaicImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// Bitrate of the audio.
// Format: speed (speed)
func (s *StreamInputMosaicImpl) SetBitrate(v Speed) StreamInputMosaic {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// Human-readable description of the input.
// Example: This is a test input
func (s StreamInputMosaicImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the input.
// Example: This is a test input
func (s *StreamInputMosaicImpl) SetComment(v string) StreamInputMosaic {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s StreamInputMosaicImpl) DenyIf() *string {
	return s.DenyIfValue
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s *StreamInputMosaicImpl) SetDenyIf(v string) StreamInputMosaic {
	if s == nil {
		return nil
	}
	s.DenyIfValue = &v
	return s
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s StreamInputMosaicImpl) FramesTimeout() *int {
	return s.FramesTimeoutValue
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s *StreamInputMosaicImpl) SetFramesTimeout(v int) StreamInputMosaic {
	if s == nil {
		return nil
	}
	s.FramesTimeoutValue = &v
	return s
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s StreamInputMosaicImpl) Headers() map[string]string {
	return s.HeadersValue
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s *StreamInputMosaicImpl) SetHeaders(v map[string]string) StreamInputMosaic {
	if s == nil {
		return nil
	}
	s.HeadersValue = v
	return s
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s StreamInputMosaicImpl) MaxRetryTimeout() *Seconds {
	return s.MaxRetryTimeoutValue
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s *StreamInputMosaicImpl) SetMaxRetryTimeout(v Seconds) StreamInputMosaic {
	if s == nil {
		return nil
	}
	s.MaxRetryTimeoutValue = &v
	return s
}

// Skip input start if the stream has no clients.
func (s StreamInputMosaicImpl) NoClientsReconnectDelay() *int {
	return s.NoClientsReconnectDelayValue
}

// Skip input start if the stream has no clients.
func (s *StreamInputMosaicImpl) SetNoClientsReconnectDelay(v int) StreamInputMosaic {
	if s == nil {
		return nil
	}
	s.NoClientsReconnectDelayValue = &v
	return s
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s StreamInputMosaicImpl) OutputAudio() *OutputAudio {
	return s.OutputAudioValue
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s *StreamInputMosaicImpl) SetOutputAudio(v OutputAudio) StreamInputMosaic {
	if s == nil {
		return nil
	}
	s.OutputAudioValue = &v
	return s
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s StreamInputMosaicImpl) Priority() *int {
	return s.PriorityValue
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s *StreamInputMosaicImpl) SetPriority(v int) StreamInputMosaic {
	if s == nil {
		return nil
	}
	s.PriorityValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s StreamInputMosaicImpl) SourceTimeout() any {
	return s.SourceTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s *StreamInputMosaicImpl) SetSourceTimeout(v any) StreamInputMosaic {
	if s == nil {
		return nil
	}
	s.SourceTimeoutValue = v
	return s
}

// Detailed runtime information about the input.
func (s StreamInputMosaicImpl) Stats() InputStats {
	return s.StatsValue
}

// Detailed runtime information about the input.
func (s *StreamInputMosaicImpl) SetStats(v InputStats) StreamInputMosaic {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s StreamInputMosaicImpl) Timeout() *int {
	return s.TimeoutValue
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s *StreamInputMosaicImpl) SetTimeout(v int) StreamInputMosaic {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// Special URL to make a mosaic stream.
// Format: input_url (input_url)
// Pattern: ^(mosaic|mosaic2)://.*$
// Examples: mosaic2://, mosaic://cam1,cam2,cam3,cam4?fps=20&preset=ultrafast&bitrate=1024k&size=340x240&mosaic_size=16
func (s StreamInputMosaicImpl) URL() InputURL {
	return s.URLValue
}

// Special URL to make a mosaic stream.
// Format: input_url (input_url)
// Pattern: ^(mosaic|mosaic2)://.*$
// Examples: mosaic2://, mosaic://cam1,cam2,cam3,cam4?fps=20&preset=ultrafast&bitrate=1024k&size=340x240&mosaic_size=16
func (s *StreamInputMosaicImpl) SetURL(v InputURL) StreamInputMosaic {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// User agent. Can be modified if a protocol allows it.
func (s StreamInputMosaicImpl) UserAgent() *string {
	return s.UserAgentValue
}

// User agent. Can be modified if a protocol allows it.
func (s *StreamInputMosaicImpl) SetUserAgent(v string) StreamInputMosaic {
	if s == nil {
		return nil
	}
	s.UserAgentValue = &v
	return s
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s StreamInputMosaicImpl) Via() *AgentURL {
	return s.ViaValue
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s *StreamInputMosaicImpl) SetVia(v AgentURL) StreamInputMosaic {
	if s == nil {
		return nil
	}
	s.ViaValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputMosaicImpl) VideoTimeout() *Seconds {
	return s.VideoTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputMosaicImpl) SetVideoTimeout(v Seconds) StreamInputMosaic {
	if s == nil {
		return nil
	}
	s.VideoTimeoutValue = &v
	return s
}

// NewStreamInputMpegtsSpecific creates a new StreamInputMpegtsSpecific instance
func NewStreamInputMpegtsSpecific() StreamInputMpegtsSpecific {
	return &StreamInputMpegtsSpecificImpl{}
}

// The rules for handling the closed captions.
func (s StreamInputMpegtsSpecificImpl) ClosedCaptions() map[string]string {
	return s.ClosedCaptionsValue
}

// The rules for handling the closed captions.
func (s *StreamInputMpegtsSpecificImpl) SetClosedCaptions(v map[string]string) StreamInputMpegtsSpecific {
	if s == nil {
		return nil
	}
	s.ClosedCaptionsValue = v
	return s
}

// An array of MPEG-TS language descriptors in format `[{key: track, value: language}]`
func (s StreamInputMpegtsSpecificImpl) Languages() map[string]string {
	return s.LanguagesValue
}

// An array of MPEG-TS language descriptors in format `[{key: track, value: language}]`
func (s *StreamInputMpegtsSpecificImpl) SetLanguages(v map[string]string) StreamInputMpegtsSpecific {
	if s == nil {
		return nil
	}
	s.LanguagesValue = v
	return s
}

// Choose a specific PID to ingest from an MPEG-TS stream.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Example: [211]
func (s StreamInputMpegtsSpecificImpl) Pids() []int {
	return s.PidsValue
}

// Choose a specific PID to ingest from an MPEG-TS stream.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Example: [211]
func (s *StreamInputMpegtsSpecificImpl) SetPids(v []int) StreamInputMpegtsSpecific {
	if s == nil {
		return nil
	}
	s.PidsValue = v
	return s
}

// Choose a program to ingest from an MPEG-TS stream.
// Example: [1]
func (s StreamInputMpegtsSpecificImpl) Programs() []int {
	return s.ProgramsValue
}

// Choose a program to ingest from an MPEG-TS stream.
// Example: [1]
func (s *StreamInputMpegtsSpecificImpl) SetPrograms(v []int) StreamInputMpegtsSpecific {
	if s == nil {
		return nil
	}
	s.ProgramsValue = v
	return s
}

// Deprecated field. Will be deleted at 23.09
// This option disables processing of SCTE-35 markers from an MPEG-TS input stream.
// Deprecated since 22.12.
// Available ways to disable processing of SCTE-35 markers:
// 1. pids option to select tracks without SCTE-35 markers
// 2. hls_scte35 option from stream_config_media for hls output
// 3. performing appropriate tuning pids in the transponder
// Example: true
func (s StreamInputMpegtsSpecificImpl) Scte35() *bool {
	return s.Scte35Value
}

// Deprecated field. Will be deleted at 23.09
// This option disables processing of SCTE-35 markers from an MPEG-TS input stream.
// Deprecated since 22.12.
// Available ways to disable processing of SCTE-35 markers:
// 1. pids option to select tracks without SCTE-35 markers
// 2. hls_scte35 option from stream_config_media for hls output
// 3. performing appropriate tuning pids in the transponder
// Example: true
func (s *StreamInputMpegtsSpecificImpl) SetScte35(v bool) StreamInputMpegtsSpecific {
	if s == nil {
		return nil
	}
	s.Scte35Value = &v
	return s
}

// Deprecated field. Will be deleted at 25.03
// This configuration is deprecated. Use `dvbocr` configuration field in stream.
// This parameter allows to manage subtitles in an output stream.
// Example: drop
func (s StreamInputMpegtsSpecificImpl) Subtitles() *StreamInputMpegtsSpecificSubtitles {
	return s.SubtitlesValue
}

// Deprecated field. Will be deleted at 25.03
// This configuration is deprecated. Use `dvbocr` configuration field in stream.
// This parameter allows to manage subtitles in an output stream.
// Example: drop
func (s *StreamInputMpegtsSpecificImpl) SetSubtitles(v StreamInputMpegtsSpecificSubtitles) StreamInputMpegtsSpecific {
	if s == nil {
		return nil
	}
	s.SubtitlesValue = &v
	return s
}

// NewStreamInputMpts creates a new StreamInputMpts instance
func NewStreamInputMpts() StreamInputMpts {
	return &StreamInputMptsImpl{}
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s StreamInputMptsImpl) AllowIf() *string {
	return s.AllowIfValue
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s *StreamInputMptsImpl) SetAllowIf(v string) StreamInputMpts {
	if s == nil {
		return nil
	}
	s.AllowIfValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputMptsImpl) AudioTimeout() *Seconds {
	return s.AudioTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputMptsImpl) SetAudioTimeout(v Seconds) StreamInputMpts {
	if s == nil {
		return nil
	}
	s.AudioTimeoutValue = &v
	return s
}

// The rules for handling the closed captions.
func (s StreamInputMptsImpl) ClosedCaptions() map[string]string {
	return s.ClosedCaptionsValue
}

// The rules for handling the closed captions.
func (s *StreamInputMptsImpl) SetClosedCaptions(v map[string]string) StreamInputMpts {
	if s == nil {
		return nil
	}
	s.ClosedCaptionsValue = v
	return s
}

// Human-readable description of the input.
// Example: This is a test input
func (s StreamInputMptsImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the input.
// Example: This is a test input
func (s *StreamInputMptsImpl) SetComment(v string) StreamInputMpts {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s StreamInputMptsImpl) DenyIf() *string {
	return s.DenyIfValue
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s *StreamInputMptsImpl) SetDenyIf(v string) StreamInputMpts {
	if s == nil {
		return nil
	}
	s.DenyIfValue = &v
	return s
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s StreamInputMptsImpl) FramesTimeout() *int {
	return s.FramesTimeoutValue
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s *StreamInputMptsImpl) SetFramesTimeout(v int) StreamInputMpts {
	if s == nil {
		return nil
	}
	s.FramesTimeoutValue = &v
	return s
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s StreamInputMptsImpl) Headers() map[string]string {
	return s.HeadersValue
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s *StreamInputMptsImpl) SetHeaders(v map[string]string) StreamInputMpts {
	if s == nil {
		return nil
	}
	s.HeadersValue = v
	return s
}

// An array of MPEG-TS language descriptors in format `[{key: track, value: language}]`
func (s StreamInputMptsImpl) Languages() map[string]string {
	return s.LanguagesValue
}

// An array of MPEG-TS language descriptors in format `[{key: track, value: language}]`
func (s *StreamInputMptsImpl) SetLanguages(v map[string]string) StreamInputMpts {
	if s == nil {
		return nil
	}
	s.LanguagesValue = v
	return s
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s StreamInputMptsImpl) MaxRetryTimeout() *Seconds {
	return s.MaxRetryTimeoutValue
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s *StreamInputMptsImpl) SetMaxRetryTimeout(v Seconds) StreamInputMpts {
	if s == nil {
		return nil
	}
	s.MaxRetryTimeoutValue = &v
	return s
}

// Skip input start if the stream has no clients.
func (s StreamInputMptsImpl) NoClientsReconnectDelay() *int {
	return s.NoClientsReconnectDelayValue
}

// Skip input start if the stream has no clients.
func (s *StreamInputMptsImpl) SetNoClientsReconnectDelay(v int) StreamInputMpts {
	if s == nil {
		return nil
	}
	s.NoClientsReconnectDelayValue = &v
	return s
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s StreamInputMptsImpl) OutputAudio() *OutputAudio {
	return s.OutputAudioValue
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s *StreamInputMptsImpl) SetOutputAudio(v OutputAudio) StreamInputMpts {
	if s == nil {
		return nil
	}
	s.OutputAudioValue = &v
	return s
}

// Choose a specific PID to ingest from an MPEG-TS stream.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Example: [211]
func (s StreamInputMptsImpl) Pids() []int {
	return s.PidsValue
}

// Choose a specific PID to ingest from an MPEG-TS stream.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Example: [211]
func (s *StreamInputMptsImpl) SetPids(v []int) StreamInputMpts {
	if s == nil {
		return nil
	}
	s.PidsValue = v
	return s
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s StreamInputMptsImpl) Priority() *int {
	return s.PriorityValue
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s *StreamInputMptsImpl) SetPriority(v int) StreamInputMpts {
	if s == nil {
		return nil
	}
	s.PriorityValue = &v
	return s
}

// Choose a program to ingest from an MPEG-TS stream.
// Example: [1]
func (s StreamInputMptsImpl) Programs() []int {
	return s.ProgramsValue
}

// Choose a program to ingest from an MPEG-TS stream.
// Example: [1]
func (s *StreamInputMptsImpl) SetPrograms(v []int) StreamInputMpts {
	if s == nil {
		return nil
	}
	s.ProgramsValue = v
	return s
}

// Deprecated field. Will be deleted at 23.09
// This option disables processing of SCTE-35 markers from an MPEG-TS input stream.
// Deprecated since 22.12.
// Available ways to disable processing of SCTE-35 markers:
// 1. pids option to select tracks without SCTE-35 markers
// 2. hls_scte35 option from stream_config_media for hls output
// 3. performing appropriate tuning pids in the transponder
// Example: true
func (s StreamInputMptsImpl) Scte35() *bool {
	return s.Scte35Value
}

// Deprecated field. Will be deleted at 23.09
// This option disables processing of SCTE-35 markers from an MPEG-TS input stream.
// Deprecated since 22.12.
// Available ways to disable processing of SCTE-35 markers:
// 1. pids option to select tracks without SCTE-35 markers
// 2. hls_scte35 option from stream_config_media for hls output
// 3. performing appropriate tuning pids in the transponder
// Example: true
func (s *StreamInputMptsImpl) SetScte35(v bool) StreamInputMpts {
	if s == nil {
		return nil
	}
	s.Scte35Value = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s StreamInputMptsImpl) SourceTimeout() any {
	return s.SourceTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s *StreamInputMptsImpl) SetSourceTimeout(v any) StreamInputMpts {
	if s == nil {
		return nil
	}
	s.SourceTimeoutValue = v
	return s
}

// Detailed runtime information about the input.
func (s StreamInputMptsImpl) Stats() InputStats {
	return s.StatsValue
}

// Detailed runtime information about the input.
func (s *StreamInputMptsImpl) SetStats(v InputStats) StreamInputMpts {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// Deprecated field. Will be deleted at 25.03
// This configuration is deprecated. Use `dvbocr` configuration field in stream.
// This parameter allows to manage subtitles in an output stream.
// Example: drop
func (s StreamInputMptsImpl) Subtitles() *StreamInputMpegtsSpecificSubtitles {
	return s.SubtitlesValue
}

// Deprecated field. Will be deleted at 25.03
// This configuration is deprecated. Use `dvbocr` configuration field in stream.
// This parameter allows to manage subtitles in an output stream.
// Example: drop
func (s *StreamInputMptsImpl) SetSubtitles(v StreamInputMpegtsSpecificSubtitles) StreamInputMpts {
	if s == nil {
		return nil
	}
	s.SubtitlesValue = &v
	return s
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s StreamInputMptsImpl) Timeout() *int {
	return s.TimeoutValue
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s *StreamInputMptsImpl) SetTimeout(v int) StreamInputMpts {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// URL to get a stream from MPTS source.
// Format: input_url (input_url)
// Pattern: ^(mpts-udp|mpts-http|mpts-https|mpts-dvb|dvb)://.*$
// Examples: dvb://asi_10?program=15, mpts-dvb://asi_10?program=15, mpts-http://239.0.0.1:1234, mpts-https://239.0.0.1:1234, mpts-udp://239.0.0.1:1234
func (s StreamInputMptsImpl) URL() InputURL {
	return s.URLValue
}

// URL to get a stream from MPTS source.
// Format: input_url (input_url)
// Pattern: ^(mpts-udp|mpts-http|mpts-https|mpts-dvb|dvb)://.*$
// Examples: dvb://asi_10?program=15, mpts-dvb://asi_10?program=15, mpts-http://239.0.0.1:1234, mpts-https://239.0.0.1:1234, mpts-udp://239.0.0.1:1234
func (s *StreamInputMptsImpl) SetURL(v InputURL) StreamInputMpts {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// User agent. Can be modified if a protocol allows it.
func (s StreamInputMptsImpl) UserAgent() *string {
	return s.UserAgentValue
}

// User agent. Can be modified if a protocol allows it.
func (s *StreamInputMptsImpl) SetUserAgent(v string) StreamInputMpts {
	if s == nil {
		return nil
	}
	s.UserAgentValue = &v
	return s
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s StreamInputMptsImpl) Via() *AgentURL {
	return s.ViaValue
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s *StreamInputMptsImpl) SetVia(v AgentURL) StreamInputMpts {
	if s == nil {
		return nil
	}
	s.ViaValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputMptsImpl) VideoTimeout() *Seconds {
	return s.VideoTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputMptsImpl) SetVideoTimeout(v Seconds) StreamInputMpts {
	if s == nil {
		return nil
	}
	s.VideoTimeoutValue = &v
	return s
}

// NewStreamInputNdi creates a new StreamInputNdi instance
func NewStreamInputNdi() StreamInputNdi {
	return &StreamInputNdiImpl{}
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s StreamInputNdiImpl) AllowIf() *string {
	return s.AllowIfValue
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s *StreamInputNdiImpl) SetAllowIf(v string) StreamInputNdi {
	if s == nil {
		return nil
	}
	s.AllowIfValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputNdiImpl) AudioTimeout() *Seconds {
	return s.AudioTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputNdiImpl) SetAudioTimeout(v Seconds) StreamInputNdi {
	if s == nil {
		return nil
	}
	s.AudioTimeoutValue = &v
	return s
}

// Human-readable description of the input.
// Example: This is a test input
func (s StreamInputNdiImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the input.
// Example: This is a test input
func (s *StreamInputNdiImpl) SetComment(v string) StreamInputNdi {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s StreamInputNdiImpl) DenyIf() *string {
	return s.DenyIfValue
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s *StreamInputNdiImpl) SetDenyIf(v string) StreamInputNdi {
	if s == nil {
		return nil
	}
	s.DenyIfValue = &v
	return s
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s StreamInputNdiImpl) FramesTimeout() *int {
	return s.FramesTimeoutValue
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s *StreamInputNdiImpl) SetFramesTimeout(v int) StreamInputNdi {
	if s == nil {
		return nil
	}
	s.FramesTimeoutValue = &v
	return s
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s StreamInputNdiImpl) Headers() map[string]string {
	return s.HeadersValue
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s *StreamInputNdiImpl) SetHeaders(v map[string]string) StreamInputNdi {
	if s == nil {
		return nil
	}
	s.HeadersValue = v
	return s
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s StreamInputNdiImpl) MaxRetryTimeout() *Seconds {
	return s.MaxRetryTimeoutValue
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s *StreamInputNdiImpl) SetMaxRetryTimeout(v Seconds) StreamInputNdi {
	if s == nil {
		return nil
	}
	s.MaxRetryTimeoutValue = &v
	return s
}

// Skip input start if the stream has no clients.
func (s StreamInputNdiImpl) NoClientsReconnectDelay() *int {
	return s.NoClientsReconnectDelayValue
}

// Skip input start if the stream has no clients.
func (s *StreamInputNdiImpl) SetNoClientsReconnectDelay(v int) StreamInputNdi {
	if s == nil {
		return nil
	}
	s.NoClientsReconnectDelayValue = &v
	return s
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s StreamInputNdiImpl) OutputAudio() *OutputAudio {
	return s.OutputAudioValue
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s *StreamInputNdiImpl) SetOutputAudio(v OutputAudio) StreamInputNdi {
	if s == nil {
		return nil
	}
	s.OutputAudioValue = &v
	return s
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s StreamInputNdiImpl) Priority() *int {
	return s.PriorityValue
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s *StreamInputNdiImpl) SetPriority(v int) StreamInputNdi {
	if s == nil {
		return nil
	}
	s.PriorityValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s StreamInputNdiImpl) SourceTimeout() any {
	return s.SourceTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s *StreamInputNdiImpl) SetSourceTimeout(v any) StreamInputNdi {
	if s == nil {
		return nil
	}
	s.SourceTimeoutValue = v
	return s
}

// Detailed runtime information about the input.
func (s StreamInputNdiImpl) Stats() InputStats {
	return s.StatsValue
}

// Detailed runtime information about the input.
func (s *StreamInputNdiImpl) SetStats(v InputStats) StreamInputNdi {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s StreamInputNdiImpl) Timeout() *int {
	return s.TimeoutValue
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s *StreamInputNdiImpl) SetTimeout(v int) StreamInputNdi {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// URL to get a stream from NDI source. Usually NDI software display sources like `My PC (Camera1)`, convert it into `ndi://My PC/Camera1`.
// Format: input_url (input_url)
// Pattern: ^ndi://.*$
// Example: ndi://hostname/Source1
func (s StreamInputNdiImpl) URL() InputURL {
	return s.URLValue
}

// URL to get a stream from NDI source. Usually NDI software display sources like `My PC (Camera1)`, convert it into `ndi://My PC/Camera1`.
// Format: input_url (input_url)
// Pattern: ^ndi://.*$
// Example: ndi://hostname/Source1
func (s *StreamInputNdiImpl) SetURL(v InputURL) StreamInputNdi {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// User agent. Can be modified if a protocol allows it.
func (s StreamInputNdiImpl) UserAgent() *string {
	return s.UserAgentValue
}

// User agent. Can be modified if a protocol allows it.
func (s *StreamInputNdiImpl) SetUserAgent(v string) StreamInputNdi {
	if s == nil {
		return nil
	}
	s.UserAgentValue = &v
	return s
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s StreamInputNdiImpl) Via() *AgentURL {
	return s.ViaValue
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s *StreamInputNdiImpl) SetVia(v AgentURL) StreamInputNdi {
	if s == nil {
		return nil
	}
	s.ViaValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputNdiImpl) VideoTimeout() *Seconds {
	return s.VideoTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputNdiImpl) SetVideoTimeout(v Seconds) StreamInputNdi {
	if s == nil {
		return nil
	}
	s.VideoTimeoutValue = &v
	return s
}

// NewStreamInputPlaylist creates a new StreamInputPlaylist instance
func NewStreamInputPlaylist() StreamInputPlaylist {
	return &StreamInputPlaylistImpl{}
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s StreamInputPlaylistImpl) AllowIf() *string {
	return s.AllowIfValue
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s *StreamInputPlaylistImpl) SetAllowIf(v string) StreamInputPlaylist {
	if s == nil {
		return nil
	}
	s.AllowIfValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputPlaylistImpl) AudioTimeout() *Seconds {
	return s.AudioTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputPlaylistImpl) SetAudioTimeout(v Seconds) StreamInputPlaylist {
	if s == nil {
		return nil
	}
	s.AudioTimeoutValue = &v
	return s
}

// Human-readable description of the input.
// Example: This is a test input
func (s StreamInputPlaylistImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the input.
// Example: This is a test input
func (s *StreamInputPlaylistImpl) SetComment(v string) StreamInputPlaylist {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s StreamInputPlaylistImpl) DenyIf() *string {
	return s.DenyIfValue
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s *StreamInputPlaylistImpl) SetDenyIf(v string) StreamInputPlaylist {
	if s == nil {
		return nil
	}
	s.DenyIfValue = &v
	return s
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s StreamInputPlaylistImpl) FramesTimeout() *int {
	return s.FramesTimeoutValue
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s *StreamInputPlaylistImpl) SetFramesTimeout(v int) StreamInputPlaylist {
	if s == nil {
		return nil
	}
	s.FramesTimeoutValue = &v
	return s
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s StreamInputPlaylistImpl) Headers() map[string]string {
	return s.HeadersValue
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s *StreamInputPlaylistImpl) SetHeaders(v map[string]string) StreamInputPlaylist {
	if s == nil {
		return nil
	}
	s.HeadersValue = v
	return s
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s StreamInputPlaylistImpl) MaxRetryTimeout() *Seconds {
	return s.MaxRetryTimeoutValue
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s *StreamInputPlaylistImpl) SetMaxRetryTimeout(v Seconds) StreamInputPlaylist {
	if s == nil {
		return nil
	}
	s.MaxRetryTimeoutValue = &v
	return s
}

// Skip input start if the stream has no clients.
func (s StreamInputPlaylistImpl) NoClientsReconnectDelay() *int {
	return s.NoClientsReconnectDelayValue
}

// Skip input start if the stream has no clients.
func (s *StreamInputPlaylistImpl) SetNoClientsReconnectDelay(v int) StreamInputPlaylist {
	if s == nil {
		return nil
	}
	s.NoClientsReconnectDelayValue = &v
	return s
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s StreamInputPlaylistImpl) OutputAudio() *OutputAudio {
	return s.OutputAudioValue
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s *StreamInputPlaylistImpl) SetOutputAudio(v OutputAudio) StreamInputPlaylist {
	if s == nil {
		return nil
	}
	s.OutputAudioValue = &v
	return s
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s StreamInputPlaylistImpl) Priority() *int {
	return s.PriorityValue
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s *StreamInputPlaylistImpl) SetPriority(v int) StreamInputPlaylist {
	if s == nil {
		return nil
	}
	s.PriorityValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s StreamInputPlaylistImpl) SourceTimeout() any {
	return s.SourceTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s *StreamInputPlaylistImpl) SetSourceTimeout(v any) StreamInputPlaylist {
	if s == nil {
		return nil
	}
	s.SourceTimeoutValue = v
	return s
}

// Detailed runtime information about the input.
func (s StreamInputPlaylistImpl) Stats() InputStats {
	return s.StatsValue
}

// Detailed runtime information about the input.
func (s *StreamInputPlaylistImpl) SetStats(v InputStats) StreamInputPlaylist {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s StreamInputPlaylistImpl) Timeout() *int {
	return s.TimeoutValue
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s *StreamInputPlaylistImpl) SetTimeout(v int) StreamInputPlaylist {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// URL to get a stream from playlist.
// Format: input_url (input_url)
// Pattern: ^playlist://.*$
// Example: playlist://remote.host.com/example.m3u8
func (s StreamInputPlaylistImpl) URL() InputURL {
	return s.URLValue
}

// URL to get a stream from playlist.
// Format: input_url (input_url)
// Pattern: ^playlist://.*$
// Example: playlist://remote.host.com/example.m3u8
func (s *StreamInputPlaylistImpl) SetURL(v InputURL) StreamInputPlaylist {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// User agent. Can be modified if a protocol allows it.
func (s StreamInputPlaylistImpl) UserAgent() *string {
	return s.UserAgentValue
}

// User agent. Can be modified if a protocol allows it.
func (s *StreamInputPlaylistImpl) SetUserAgent(v string) StreamInputPlaylist {
	if s == nil {
		return nil
	}
	s.UserAgentValue = &v
	return s
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s StreamInputPlaylistImpl) Via() *AgentURL {
	return s.ViaValue
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s *StreamInputPlaylistImpl) SetVia(v AgentURL) StreamInputPlaylist {
	if s == nil {
		return nil
	}
	s.ViaValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputPlaylistImpl) VideoTimeout() *Seconds {
	return s.VideoTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputPlaylistImpl) SetVideoTimeout(v Seconds) StreamInputPlaylist {
	if s == nil {
		return nil
	}
	s.VideoTimeoutValue = &v
	return s
}

// NewStreamInputPublish creates a new StreamInputPublish instance
func NewStreamInputPublish() StreamInputPublish {
	return &StreamInputPublishImpl{}
}

// The correction between the target bitrate (Receiver Estimated Maximum Bitrate, calculated in Flussonic) and browser bitrate, in kbit/s.
// Flussonic sends the target bitrate to the browser from which the publication is carried out so that the browser adjusts the bitrate of the publication by this value.
// The default value is 300 kbit/s.
// Example: 200
func (s StreamInputPublishImpl) AbrCorrection() *int {
	return s.AbrCorrectionValue
}

// The correction between the target bitrate (Receiver Estimated Maximum Bitrate, calculated in Flussonic) and browser bitrate, in kbit/s.
// Flussonic sends the target bitrate to the browser from which the publication is carried out so that the browser adjusts the bitrate of the publication by this value.
// The default value is 300 kbit/s.
// Example: 200
func (s *StreamInputPublishImpl) SetAbrCorrection(v int) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.AbrCorrectionValue = &v
	return s
}

// The number of cycles of bitrate auto-adjustment.
// After the specified number of auto-adjustment cycles passes, Flussonic considers the bitrate to be optimal, and it is no longer analyzed.
// By default, `abr_cycles`=5.
// If `abr_cycles`=0, the adjustment process takes place all the time while the publication lasts.
// Example: 3
func (s StreamInputPublishImpl) AbrCycles() *int {
	return s.AbrCyclesValue
}

// The number of cycles of bitrate auto-adjustment.
// After the specified number of auto-adjustment cycles passes, Flussonic considers the bitrate to be optimal, and it is no longer analyzed.
// By default, `abr_cycles`=5.
// If `abr_cycles`=0, the adjustment process takes place all the time while the publication lasts.
// Example: 3
func (s *StreamInputPublishImpl) SetAbrCycles(v int) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.AbrCyclesValue = &v
	return s
}

// Whether adaptive bitrate process is logged.
// Example: 1
func (s StreamInputPublishImpl) AbrDebug() *int {
	return s.AbrDebugValue
}

// Whether adaptive bitrate process is logged.
// Example: 1
func (s *StreamInputPublishImpl) SetAbrDebug(v int) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.AbrDebugValue = &v
	return s
}

// The lower limit of packet loss. When it is reached, Flussonic raises the bitrate.
// That is, if packet loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup` percent.
// Example: 2
func (s StreamInputPublishImpl) AbrLossLower() *float64 {
	return s.AbrLossLowerValue
}

// The lower limit of packet loss. When it is reached, Flussonic raises the bitrate.
// That is, if packet loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup` percent.
// Example: 2
func (s *StreamInputPublishImpl) SetAbrLossLower(v float64) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.AbrLossLowerValue = &v
	return s
}

// The upper limit of packet loss. When it is reached, Flussonic reduces the bitrate.
// That is, if packet loss is greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.
// Example: 10
func (s StreamInputPublishImpl) AbrLossUpper() *float64 {
	return s.AbrLossUpperValue
}

// The upper limit of packet loss. When it is reached, Flussonic reduces the bitrate.
// That is, if packet loss is greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.
// Example: 10
func (s *StreamInputPublishImpl) SetAbrLossUpper(v float64) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.AbrLossUpperValue = &v
	return s
}

// Maximum bitrate for adjustment process, in kbit/s.
// Flussonic will keep the publication bitrate equal or below of the specified value.
// Example: 1000
func (s StreamInputPublishImpl) AbrMaxBitrate() *int {
	return s.AbrMaxBitrateValue
}

// Maximum bitrate for adjustment process, in kbit/s.
// Flussonic will keep the publication bitrate equal or below of the specified value.
// Example: 1000
func (s *StreamInputPublishImpl) SetAbrMaxBitrate(v int) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.AbrMaxBitrateValue = &v
	return s
}

// The algorithm for determining the need to change the bitrate of the published stream and for calculating the target bitrate.
// Two options are possible:
// * `abr_mode=0` - This mode takes into account the packet losses, target bitrate, browser bitrate and the number of auto-adjustment cycles.
// * `abr_mode=1` - This mode considers only packet losses and target bitrate.
// Example: 1
func (s StreamInputPublishImpl) AbrMode() *int {
	return s.AbrModeValue
}

// The algorithm for determining the need to change the bitrate of the published stream and for calculating the target bitrate.
// Two options are possible:
// * `abr_mode=0` - This mode takes into account the packet losses, target bitrate, browser bitrate and the number of auto-adjustment cycles.
// * `abr_mode=1` - This mode considers only packet losses and target bitrate.
// Example: 1
func (s *StreamInputPublishImpl) SetAbrMode(v int) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.AbrModeValue = &v
	return s
}

// A step of reducing the bitrate to the minimum.
// If packet losses are greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.
func (s StreamInputPublishImpl) AbrStepdown() *float64 {
	return s.AbrStepdownValue
}

// A step of reducing the bitrate to the minimum.
// If packet losses are greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.
func (s *StreamInputPublishImpl) SetAbrStepdown(v float64) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.AbrStepdownValue = &v
	return s
}

// Increment step for raising the bitrate to the maximum, in percent. The default step is 30%.
// If the loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup percent`.
func (s StreamInputPublishImpl) AbrStepup() *int {
	return s.AbrStepupValue
}

// Increment step for raising the bitrate to the maximum, in percent. The default step is 30%.
// If the loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup percent`.
func (s *StreamInputPublishImpl) SetAbrStepup(v int) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.AbrStepupValue = &v
	return s
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s StreamInputPublishImpl) AllowIf() *string {
	return s.AllowIfValue
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s *StreamInputPublishImpl) SetAllowIf(v string) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.AllowIfValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputPublishImpl) AudioTimeout() *Seconds {
	return s.AudioTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputPublishImpl) SetAudioTimeout(v Seconds) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.AudioTimeoutValue = &v
	return s
}

// Human-readable description of the input.
// Example: This is a test input
func (s StreamInputPublishImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the input.
// Example: This is a test input
func (s *StreamInputPublishImpl) SetComment(v string) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s StreamInputPublishImpl) DenyIf() *string {
	return s.DenyIfValue
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s *StreamInputPublishImpl) SetDenyIf(v string) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.DenyIfValue = &v
	return s
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s StreamInputPublishImpl) FramesTimeout() *int {
	return s.FramesTimeoutValue
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s *StreamInputPublishImpl) SetFramesTimeout(v int) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.FramesTimeoutValue = &v
	return s
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s StreamInputPublishImpl) Headers() map[string]string {
	return s.HeadersValue
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s *StreamInputPublishImpl) SetHeaders(v map[string]string) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.HeadersValue = v
	return s
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s StreamInputPublishImpl) MaxRetryTimeout() *Seconds {
	return s.MaxRetryTimeoutValue
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s *StreamInputPublishImpl) SetMaxRetryTimeout(v Seconds) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.MaxRetryTimeoutValue = &v
	return s
}

// The minimum bitrate threshold, in kbit/s. The default value is 100 kbit/s.
// Example: 150
func (s StreamInputPublishImpl) MinBitrate() *int {
	return s.MinBitrateValue
}

// The minimum bitrate threshold, in kbit/s. The default value is 100 kbit/s.
// Example: 150
func (s *StreamInputPublishImpl) SetMinBitrate(v int) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.MinBitrateValue = &v
	return s
}

// Skip input start if the stream has no clients.
func (s StreamInputPublishImpl) NoClientsReconnectDelay() *int {
	return s.NoClientsReconnectDelayValue
}

// Skip input start if the stream has no clients.
func (s *StreamInputPublishImpl) SetNoClientsReconnectDelay(v int) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.NoClientsReconnectDelayValue = &v
	return s
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s StreamInputPublishImpl) OutputAudio() *OutputAudio {
	return s.OutputAudioValue
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s *StreamInputPublishImpl) SetOutputAudio(v OutputAudio) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.OutputAudioValue = &v
	return s
}

// Deprecated field. Will be deleted at 24.11
// Choose one of the listed video codecs at the start of the publication via WebRTC.
// Example: av1
func (s StreamInputPublishImpl) PreferCodec() *WebrtcPreferVideoCodec {
	return s.PreferCodecValue
}

// Deprecated field. Will be deleted at 24.11
// Choose one of the listed video codecs at the start of the publication via WebRTC.
// Example: av1
func (s *StreamInputPublishImpl) SetPreferCodec(v WebrtcPreferVideoCodec) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.PreferCodecValue = &v
	return s
}

// Prefer one of the listed video codecs at the start of the publication via WebRTC.
// Example: av1
func (s StreamInputPublishImpl) PreferVideoCodec() *WebrtcPreferVideoCodec {
	return s.PreferVideoCodecValue
}

// Prefer one of the listed video codecs at the start of the publication via WebRTC.
// Example: av1
func (s *StreamInputPublishImpl) SetPreferVideoCodec(v WebrtcPreferVideoCodec) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.PreferVideoCodecValue = &v
	return s
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s StreamInputPublishImpl) Priority() *int {
	return s.PriorityValue
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s *StreamInputPublishImpl) SetPriority(v int) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.PriorityValue = &v
	return s
}

// This option disables processing of SCTE-35 markers from SRT input stream.
// Example: true
func (s StreamInputPublishImpl) Scte35() *bool {
	return s.Scte35Value
}

// This option disables processing of SCTE-35 markers from SRT input stream.
// Example: true
func (s *StreamInputPublishImpl) SetScte35(v bool) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.Scte35Value = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s StreamInputPublishImpl) SourceTimeout() any {
	return s.SourceTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s *StreamInputPublishImpl) SetSourceTimeout(v any) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.SourceTimeoutValue = v
	return s
}

// Detailed runtime information about the input.
func (s StreamInputPublishImpl) Stats() InputStats {
	return s.StatsValue
}

// Detailed runtime information about the input.
func (s *StreamInputPublishImpl) SetStats(v InputStats) StreamInputPublish {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// Deprecated field. Will be deleted at 25.03
// This configuration is deprecated. Use `dvbocr` configuration field in stream.
// This parameter allows to manage subtitles in an output stream.
// Example: drop
func (s StreamInputPublishImpl) Subtitles() *StreamInputSrtPublishSpecificSubtitles {
	return s.SubtitlesValue
}

// Deprecated field. Will be deleted at 25.03
// This configuration is deprecated. Use `dvbocr` configuration field in stream.
// This parameter allows to manage subtitles in an output stream.
// Example: drop
func (s *StreamInputPublishImpl) SetSubtitles(v StreamInputSrtPublishSpecificSubtitles) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.SubtitlesValue = &v
	return s
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s StreamInputPublishImpl) Timeout() *int {
	return s.TimeoutValue
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s *StreamInputPublishImpl) SetTimeout(v int) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// Choose the prefered transport of the publication via WebRTC: UDP or TCP.
// Example: udp
func (s StreamInputPublishImpl) Transport() *WebrtcTransport {
	return s.TransportValue
}

// Choose the prefered transport of the publication via WebRTC: UDP or TCP.
// Example: udp
func (s *StreamInputPublishImpl) SetTransport(v WebrtcTransport) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.TransportValue = &v
	return s
}

// The publish:// URL used to indicate where this stream started in publish mode.
// You can publish videos to Flussonic using the following URLs:
// __RTSP__: rtsp://FLUSSONIC-IP/stream_name
// __HTTP MPEG-TS__: http://FLUSSONIC-IP/stream_name/mpegts
// __RTMP__: rtmp://flussonic-ip/published or rtmp://flussonic-ip/static/published
// __WebRTC__: http://FLUSSONIC-IP/stream_name/whip
// __SRT__: srt://FLUSSONIC-IP:SRT_PORT?streamid=#!::r=STREAM_NAME,m=publish
// Format: input_url (input_url)
// Pattern: ^publish://.*$
// Example: publish://
func (s StreamInputPublishImpl) URL() InputURL {
	return s.URLValue
}

// The publish:// URL used to indicate where this stream started in publish mode.
// You can publish videos to Flussonic using the following URLs:
// __RTSP__: rtsp://FLUSSONIC-IP/stream_name
// __HTTP MPEG-TS__: http://FLUSSONIC-IP/stream_name/mpegts
// __RTMP__: rtmp://flussonic-ip/published or rtmp://flussonic-ip/static/published
// __WebRTC__: http://FLUSSONIC-IP/stream_name/whip
// __SRT__: srt://FLUSSONIC-IP:SRT_PORT?streamid=#!::r=STREAM_NAME,m=publish
// Format: input_url (input_url)
// Pattern: ^publish://.*$
// Example: publish://
func (s *StreamInputPublishImpl) SetURL(v InputURL) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// User agent. Can be modified if a protocol allows it.
func (s StreamInputPublishImpl) UserAgent() *string {
	return s.UserAgentValue
}

// User agent. Can be modified if a protocol allows it.
func (s *StreamInputPublishImpl) SetUserAgent(v string) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.UserAgentValue = &v
	return s
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s StreamInputPublishImpl) Via() *AgentURL {
	return s.ViaValue
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s *StreamInputPublishImpl) SetVia(v AgentURL) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.ViaValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputPublishImpl) VideoTimeout() *Seconds {
	return s.VideoTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputPublishImpl) SetVideoTimeout(v Seconds) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.VideoTimeoutValue = &v
	return s
}

// Whether the adaptive bitrate mechanism is used for WebRTC publications.
// Example: true
func (s StreamInputPublishImpl) WebrtcAbr() *bool {
	return s.WebrtcAbrValue
}

// Whether the adaptive bitrate mechanism is used for WebRTC publications.
// Example: true
func (s *StreamInputPublishImpl) SetWebrtcAbr(v bool) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.WebrtcAbrValue = &v
	return s
}

// NewStreamInputRTP creates a new StreamInputRTP instance
func NewStreamInputRTP() StreamInputRTP {
	return &StreamInputRTPImpl{}
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s StreamInputRTPImpl) AllowIf() *string {
	return s.AllowIfValue
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s *StreamInputRTPImpl) SetAllowIf(v string) StreamInputRTP {
	if s == nil {
		return nil
	}
	s.AllowIfValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputRTPImpl) AudioTimeout() *Seconds {
	return s.AudioTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputRTPImpl) SetAudioTimeout(v Seconds) StreamInputRTP {
	if s == nil {
		return nil
	}
	s.AudioTimeoutValue = &v
	return s
}

// Human-readable description of the input.
// Example: This is a test input
func (s StreamInputRTPImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the input.
// Example: This is a test input
func (s *StreamInputRTPImpl) SetComment(v string) StreamInputRTP {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s StreamInputRTPImpl) DenyIf() *string {
	return s.DenyIfValue
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s *StreamInputRTPImpl) SetDenyIf(v string) StreamInputRTP {
	if s == nil {
		return nil
	}
	s.DenyIfValue = &v
	return s
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s StreamInputRTPImpl) FramesTimeout() *int {
	return s.FramesTimeoutValue
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s *StreamInputRTPImpl) SetFramesTimeout(v int) StreamInputRTP {
	if s == nil {
		return nil
	}
	s.FramesTimeoutValue = &v
	return s
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s StreamInputRTPImpl) Headers() map[string]string {
	return s.HeadersValue
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s *StreamInputRTPImpl) SetHeaders(v map[string]string) StreamInputRTP {
	if s == nil {
		return nil
	}
	s.HeadersValue = v
	return s
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s StreamInputRTPImpl) MaxRetryTimeout() *Seconds {
	return s.MaxRetryTimeoutValue
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s *StreamInputRTPImpl) SetMaxRetryTimeout(v Seconds) StreamInputRTP {
	if s == nil {
		return nil
	}
	s.MaxRetryTimeoutValue = &v
	return s
}

// Skip input start if the stream has no clients.
func (s StreamInputRTPImpl) NoClientsReconnectDelay() *int {
	return s.NoClientsReconnectDelayValue
}

// Skip input start if the stream has no clients.
func (s *StreamInputRTPImpl) SetNoClientsReconnectDelay(v int) StreamInputRTP {
	if s == nil {
		return nil
	}
	s.NoClientsReconnectDelayValue = &v
	return s
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s StreamInputRTPImpl) OutputAudio() *OutputAudio {
	return s.OutputAudioValue
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s *StreamInputRTPImpl) SetOutputAudio(v OutputAudio) StreamInputRTP {
	if s == nil {
		return nil
	}
	s.OutputAudioValue = &v
	return s
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s StreamInputRTPImpl) Priority() *int {
	return s.PriorityValue
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s *StreamInputRTPImpl) SetPriority(v int) StreamInputRTP {
	if s == nil {
		return nil
	}
	s.PriorityValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s StreamInputRTPImpl) SourceTimeout() any {
	return s.SourceTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s *StreamInputRTPImpl) SetSourceTimeout(v any) StreamInputRTP {
	if s == nil {
		return nil
	}
	s.SourceTimeoutValue = v
	return s
}

// Detailed runtime information about the input.
func (s StreamInputRTPImpl) Stats() InputStats {
	return s.StatsValue
}

// Detailed runtime information about the input.
func (s *StreamInputRTPImpl) SetStats(v InputStats) StreamInputRTP {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s StreamInputRTPImpl) Timeout() *int {
	return s.TimeoutValue
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s *StreamInputRTPImpl) SetTimeout(v int) StreamInputRTP {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// URL to connect to RTP source and get the stream.
// Format: input_url (input_url)
// Pattern: ^rtp://.*$
// Example: rtp://remote.host.com
func (s StreamInputRTPImpl) URL() InputURL {
	return s.URLValue
}

// URL to connect to RTP source and get the stream.
// Format: input_url (input_url)
// Pattern: ^rtp://.*$
// Example: rtp://remote.host.com
func (s *StreamInputRTPImpl) SetURL(v InputURL) StreamInputRTP {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// User agent. Can be modified if a protocol allows it.
func (s StreamInputRTPImpl) UserAgent() *string {
	return s.UserAgentValue
}

// User agent. Can be modified if a protocol allows it.
func (s *StreamInputRTPImpl) SetUserAgent(v string) StreamInputRTP {
	if s == nil {
		return nil
	}
	s.UserAgentValue = &v
	return s
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s StreamInputRTPImpl) Via() *AgentURL {
	return s.ViaValue
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s *StreamInputRTPImpl) SetVia(v AgentURL) StreamInputRTP {
	if s == nil {
		return nil
	}
	s.ViaValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputRTPImpl) VideoTimeout() *Seconds {
	return s.VideoTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputRTPImpl) SetVideoTimeout(v Seconds) StreamInputRTP {
	if s == nil {
		return nil
	}
	s.VideoTimeoutValue = &v
	return s
}

// NewStreamInputRtmp creates a new StreamInputRtmp instance
func NewStreamInputRtmp() StreamInputRtmp {
	return &StreamInputRtmpImpl{}
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s StreamInputRtmpImpl) AllowIf() *string {
	return s.AllowIfValue
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s *StreamInputRtmpImpl) SetAllowIf(v string) StreamInputRtmp {
	if s == nil {
		return nil
	}
	s.AllowIfValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputRtmpImpl) AudioTimeout() *Seconds {
	return s.AudioTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputRtmpImpl) SetAudioTimeout(v Seconds) StreamInputRtmp {
	if s == nil {
		return nil
	}
	s.AudioTimeoutValue = &v
	return s
}

// Human-readable description of the input.
// Example: This is a test input
func (s StreamInputRtmpImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the input.
// Example: This is a test input
func (s *StreamInputRtmpImpl) SetComment(v string) StreamInputRtmp {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s StreamInputRtmpImpl) DenyIf() *string {
	return s.DenyIfValue
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s *StreamInputRtmpImpl) SetDenyIf(v string) StreamInputRtmp {
	if s == nil {
		return nil
	}
	s.DenyIfValue = &v
	return s
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s StreamInputRtmpImpl) FramesTimeout() *int {
	return s.FramesTimeoutValue
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s *StreamInputRtmpImpl) SetFramesTimeout(v int) StreamInputRtmp {
	if s == nil {
		return nil
	}
	s.FramesTimeoutValue = &v
	return s
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s StreamInputRtmpImpl) Headers() map[string]string {
	return s.HeadersValue
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s *StreamInputRtmpImpl) SetHeaders(v map[string]string) StreamInputRtmp {
	if s == nil {
		return nil
	}
	s.HeadersValue = v
	return s
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s StreamInputRtmpImpl) MaxRetryTimeout() *Seconds {
	return s.MaxRetryTimeoutValue
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s *StreamInputRtmpImpl) SetMaxRetryTimeout(v Seconds) StreamInputRtmp {
	if s == nil {
		return nil
	}
	s.MaxRetryTimeoutValue = &v
	return s
}

// Skip input start if the stream has no clients.
func (s StreamInputRtmpImpl) NoClientsReconnectDelay() *int {
	return s.NoClientsReconnectDelayValue
}

// Skip input start if the stream has no clients.
func (s *StreamInputRtmpImpl) SetNoClientsReconnectDelay(v int) StreamInputRtmp {
	if s == nil {
		return nil
	}
	s.NoClientsReconnectDelayValue = &v
	return s
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s StreamInputRtmpImpl) OutputAudio() *OutputAudio {
	return s.OutputAudioValue
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s *StreamInputRtmpImpl) SetOutputAudio(v OutputAudio) StreamInputRtmp {
	if s == nil {
		return nil
	}
	s.OutputAudioValue = &v
	return s
}

// URL of the web page from where the SWF file was loaded.
// This is an RTMP header (Referer) used for establishing connection.
// Format: url (url)
// Example: http://somehost/sample.html
func (s StreamInputRtmpImpl) Pageurl() *URL {
	return s.PageurlValue
}

// URL of the web page from where the SWF file was loaded.
// This is an RTMP header (Referer) used for establishing connection.
// Format: url (url)
// Example: http://somehost/sample.html
func (s *StreamInputRtmpImpl) SetPageurl(v URL) StreamInputRtmp {
	if s == nil {
		return nil
	}
	s.PageurlValue = &v
	return s
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s StreamInputRtmpImpl) Priority() *int {
	return s.PriorityValue
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s *StreamInputRtmpImpl) SetPriority(v int) StreamInputRtmp {
	if s == nil {
		return nil
	}
	s.PriorityValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s StreamInputRtmpImpl) SourceTimeout() any {
	return s.SourceTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s *StreamInputRtmpImpl) SetSourceTimeout(v any) StreamInputRtmp {
	if s == nil {
		return nil
	}
	s.SourceTimeoutValue = v
	return s
}

// Detailed runtime information about the input.
func (s StreamInputRtmpImpl) Stats() InputStats {
	return s.StatsValue
}

// Detailed runtime information about the input.
func (s *StreamInputRtmpImpl) SetStats(v InputStats) StreamInputRtmp {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// URL of the source SWF file making the connection by RTMP.
// Example: file://C:/FlvPlayer.swf
func (s StreamInputRtmpImpl) Swfurl() *string {
	return s.SwfurlValue
}

// URL of the source SWF file making the connection by RTMP.
// Example: file://C:/FlvPlayer.swf
func (s *StreamInputRtmpImpl) SetSwfurl(v string) StreamInputRtmp {
	if s == nil {
		return nil
	}
	s.SwfurlValue = &v
	return s
}

// URL of the remote Server for entering credentials.
// It has the following format: `protocol://servername:port/appName/appInstance`.
// Format: url (url)
// Example: rtmp://localhost:1935/testapp/instance1
func (s StreamInputRtmpImpl) Tcurl() *URL {
	return s.TcurlValue
}

// URL of the remote Server for entering credentials.
// It has the following format: `protocol://servername:port/appName/appInstance`.
// Format: url (url)
// Example: rtmp://localhost:1935/testapp/instance1
func (s *StreamInputRtmpImpl) SetTcurl(v URL) StreamInputRtmp {
	if s == nil {
		return nil
	}
	s.TcurlValue = &v
	return s
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s StreamInputRtmpImpl) Timeout() *int {
	return s.TimeoutValue
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s *StreamInputRtmpImpl) SetTimeout(v int) StreamInputRtmp {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// URL to connect to the RTMP source and get the stream.
// RTMP uses a special URL consisting of at least two segments. *Flussonic* parses the URL and splits it into parts,
// using the first segment as an RTMP application name.
// Format: input_url (input_url)
// Pattern: ^(rtmp|rtmps)://.*$
// Examples: rtmp://remote.host.com/static/example, rtmps://remote.host.com/static/example
func (s StreamInputRtmpImpl) URL() InputURL {
	return s.URLValue
}

// URL to connect to the RTMP source and get the stream.
// RTMP uses a special URL consisting of at least two segments. *Flussonic* parses the URL and splits it into parts,
// using the first segment as an RTMP application name.
// Format: input_url (input_url)
// Pattern: ^(rtmp|rtmps)://.*$
// Examples: rtmp://remote.host.com/static/example, rtmps://remote.host.com/static/example
func (s *StreamInputRtmpImpl) SetURL(v InputURL) StreamInputRtmp {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// User agent. Can be modified if a protocol allows it.
func (s StreamInputRtmpImpl) UserAgent() *string {
	return s.UserAgentValue
}

// User agent. Can be modified if a protocol allows it.
func (s *StreamInputRtmpImpl) SetUserAgent(v string) StreamInputRtmp {
	if s == nil {
		return nil
	}
	s.UserAgentValue = &v
	return s
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s StreamInputRtmpImpl) Via() *AgentURL {
	return s.ViaValue
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s *StreamInputRtmpImpl) SetVia(v AgentURL) StreamInputRtmp {
	if s == nil {
		return nil
	}
	s.ViaValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputRtmpImpl) VideoTimeout() *Seconds {
	return s.VideoTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputRtmpImpl) SetVideoTimeout(v Seconds) StreamInputRtmp {
	if s == nil {
		return nil
	}
	s.VideoTimeoutValue = &v
	return s
}

// NewStreamInputRtsp creates a new StreamInputRtsp instance
func NewStreamInputRtsp() StreamInputRtsp {
	return &StreamInputRtspImpl{}
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s StreamInputRtspImpl) AllowIf() *string {
	return s.AllowIfValue
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s *StreamInputRtspImpl) SetAllowIf(v string) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.AllowIfValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputRtspImpl) AudioTimeout() *Seconds {
	return s.AudioTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputRtspImpl) SetAudioTimeout(v Seconds) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.AudioTimeoutValue = &v
	return s
}

// Human-readable description of the input.
// Example: This is a test input
func (s StreamInputRtspImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the input.
// Example: This is a test input
func (s *StreamInputRtspImpl) SetComment(v string) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s StreamInputRtspImpl) DenyIf() *string {
	return s.DenyIfValue
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s *StreamInputRtspImpl) SetDenyIf(v string) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.DenyIfValue = &v
	return s
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s StreamInputRtspImpl) FramesTimeout() *int {
	return s.FramesTimeoutValue
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s *StreamInputRtspImpl) SetFramesTimeout(v int) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.FramesTimeoutValue = &v
	return s
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s StreamInputRtspImpl) Headers() map[string]string {
	return s.HeadersValue
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s *StreamInputRtspImpl) SetHeaders(v map[string]string) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.HeadersValue = v
	return s
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s StreamInputRtspImpl) MaxRetryTimeout() *Seconds {
	return s.MaxRetryTimeoutValue
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s *StreamInputRtspImpl) SetMaxRetryTimeout(v Seconds) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.MaxRetryTimeoutValue = &v
	return s
}

// Skip input start if the stream has no clients.
func (s StreamInputRtspImpl) NoClientsReconnectDelay() *int {
	return s.NoClientsReconnectDelayValue
}

// Skip input start if the stream has no clients.
func (s *StreamInputRtspImpl) SetNoClientsReconnectDelay(v int) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.NoClientsReconnectDelayValue = &v
	return s
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s StreamInputRtspImpl) OutputAudio() *OutputAudio {
	return s.OutputAudioValue
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s *StreamInputRtspImpl) SetOutputAudio(v OutputAudio) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.OutputAudioValue = &v
	return s
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s StreamInputRtspImpl) Priority() *int {
	return s.PriorityValue
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s *StreamInputRtspImpl) SetPriority(v int) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.PriorityValue = &v
	return s
}

// Whether to force UDP to capture a video from RTSP cameras.
func (s StreamInputRtspImpl) RTP() *string {
	return s.RTPValue
}

// Whether to force UDP to capture a video from RTSP cameras.
func (s *StreamInputRtspImpl) SetRTP(v string) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.RTPValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s StreamInputRtspImpl) SourceTimeout() any {
	return s.SourceTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s *StreamInputRtspImpl) SetSourceTimeout(v any) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.SourceTimeoutValue = v
	return s
}

// Detailed runtime information about the input.
func (s StreamInputRtspImpl) Stats() InputStats {
	return s.StatsValue
}

// Detailed runtime information about the input.
func (s *StreamInputRtspImpl) SetStats(v InputStats) StreamInputRtsp {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s StreamInputRtspImpl) Timeout() *int {
	return s.TimeoutValue
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s *StreamInputRtspImpl) SetTimeout(v int) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// URL to connect to the RTSP source and get the stream.
// Format: input_url (input_url)
// Pattern: ^(rtsp|rtsps|rtsp-udp|rtsp2)://.*$
// Examples: rtsp-udp://remote.host.com/example, rtsp2://remote.host.com/example, rtsp://remote.host.com/example, rtsps://remote.host.com/example
func (s StreamInputRtspImpl) URL() InputURL {
	return s.URLValue
}

// URL to connect to the RTSP source and get the stream.
// Format: input_url (input_url)
// Pattern: ^(rtsp|rtsps|rtsp-udp|rtsp2)://.*$
// Examples: rtsp-udp://remote.host.com/example, rtsp2://remote.host.com/example, rtsp://remote.host.com/example, rtsps://remote.host.com/example
func (s *StreamInputRtspImpl) SetURL(v InputURL) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// User agent. Can be modified if a protocol allows it.
func (s StreamInputRtspImpl) UserAgent() *string {
	return s.UserAgentValue
}

// User agent. Can be modified if a protocol allows it.
func (s *StreamInputRtspImpl) SetUserAgent(v string) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.UserAgentValue = &v
	return s
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s StreamInputRtspImpl) Via() *AgentURL {
	return s.ViaValue
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s *StreamInputRtspImpl) SetVia(v AgentURL) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.ViaValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputRtspImpl) VideoTimeout() *Seconds {
	return s.VideoTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputRtspImpl) SetVideoTimeout(v Seconds) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.VideoTimeoutValue = &v
	return s
}

// Whether to wait for the full RTP time synchronization before the processing of frames from the RTSP camera.
func (s StreamInputRtspImpl) WaitRtcp() *bool {
	return s.WaitRtcpValue
}

// Whether to wait for the full RTP time synchronization before the processing of frames from the RTSP camera.
func (s *StreamInputRtspImpl) SetWaitRtcp(v bool) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.WaitRtcpValue = &v
	return s
}

// NewStreamInputShoutcast creates a new StreamInputShoutcast instance
func NewStreamInputShoutcast() StreamInputShoutcast {
	return &StreamInputShoutcastImpl{}
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s StreamInputShoutcastImpl) AllowIf() *string {
	return s.AllowIfValue
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s *StreamInputShoutcastImpl) SetAllowIf(v string) StreamInputShoutcast {
	if s == nil {
		return nil
	}
	s.AllowIfValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputShoutcastImpl) AudioTimeout() *Seconds {
	return s.AudioTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputShoutcastImpl) SetAudioTimeout(v Seconds) StreamInputShoutcast {
	if s == nil {
		return nil
	}
	s.AudioTimeoutValue = &v
	return s
}

// Human-readable description of the input.
// Example: This is a test input
func (s StreamInputShoutcastImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the input.
// Example: This is a test input
func (s *StreamInputShoutcastImpl) SetComment(v string) StreamInputShoutcast {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s StreamInputShoutcastImpl) DenyIf() *string {
	return s.DenyIfValue
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s *StreamInputShoutcastImpl) SetDenyIf(v string) StreamInputShoutcast {
	if s == nil {
		return nil
	}
	s.DenyIfValue = &v
	return s
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s StreamInputShoutcastImpl) FramesTimeout() *int {
	return s.FramesTimeoutValue
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s *StreamInputShoutcastImpl) SetFramesTimeout(v int) StreamInputShoutcast {
	if s == nil {
		return nil
	}
	s.FramesTimeoutValue = &v
	return s
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s StreamInputShoutcastImpl) Headers() map[string]string {
	return s.HeadersValue
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s *StreamInputShoutcastImpl) SetHeaders(v map[string]string) StreamInputShoutcast {
	if s == nil {
		return nil
	}
	s.HeadersValue = v
	return s
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s StreamInputShoutcastImpl) MaxRetryTimeout() *Seconds {
	return s.MaxRetryTimeoutValue
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s *StreamInputShoutcastImpl) SetMaxRetryTimeout(v Seconds) StreamInputShoutcast {
	if s == nil {
		return nil
	}
	s.MaxRetryTimeoutValue = &v
	return s
}

// Skip input start if the stream has no clients.
func (s StreamInputShoutcastImpl) NoClientsReconnectDelay() *int {
	return s.NoClientsReconnectDelayValue
}

// Skip input start if the stream has no clients.
func (s *StreamInputShoutcastImpl) SetNoClientsReconnectDelay(v int) StreamInputShoutcast {
	if s == nil {
		return nil
	}
	s.NoClientsReconnectDelayValue = &v
	return s
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s StreamInputShoutcastImpl) OutputAudio() *OutputAudio {
	return s.OutputAudioValue
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s *StreamInputShoutcastImpl) SetOutputAudio(v OutputAudio) StreamInputShoutcast {
	if s == nil {
		return nil
	}
	s.OutputAudioValue = &v
	return s
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s StreamInputShoutcastImpl) Priority() *int {
	return s.PriorityValue
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s *StreamInputShoutcastImpl) SetPriority(v int) StreamInputShoutcast {
	if s == nil {
		return nil
	}
	s.PriorityValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s StreamInputShoutcastImpl) SourceTimeout() any {
	return s.SourceTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s *StreamInputShoutcastImpl) SetSourceTimeout(v any) StreamInputShoutcast {
	if s == nil {
		return nil
	}
	s.SourceTimeoutValue = v
	return s
}

// Detailed runtime information about the input.
func (s StreamInputShoutcastImpl) Stats() InputStats {
	return s.StatsValue
}

// Detailed runtime information about the input.
func (s *StreamInputShoutcastImpl) SetStats(v InputStats) StreamInputShoutcast {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s StreamInputShoutcastImpl) Timeout() *int {
	return s.TimeoutValue
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s *StreamInputShoutcastImpl) SetTimeout(v int) StreamInputShoutcast {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// URL to connect to the SHOUTcast source and get the stream.
// Format: input_url (input_url)
// Pattern: ^(shoutcast|shoutcasts)://.*$
// Examples: shoutcast://remote.host.com/example/shoutcast, shoutcasts://remote.host.com/example/shoutcast
func (s StreamInputShoutcastImpl) URL() InputURL {
	return s.URLValue
}

// URL to connect to the SHOUTcast source and get the stream.
// Format: input_url (input_url)
// Pattern: ^(shoutcast|shoutcasts)://.*$
// Examples: shoutcast://remote.host.com/example/shoutcast, shoutcasts://remote.host.com/example/shoutcast
func (s *StreamInputShoutcastImpl) SetURL(v InputURL) StreamInputShoutcast {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// User agent. Can be modified if a protocol allows it.
func (s StreamInputShoutcastImpl) UserAgent() *string {
	return s.UserAgentValue
}

// User agent. Can be modified if a protocol allows it.
func (s *StreamInputShoutcastImpl) SetUserAgent(v string) StreamInputShoutcast {
	if s == nil {
		return nil
	}
	s.UserAgentValue = &v
	return s
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s StreamInputShoutcastImpl) Via() *AgentURL {
	return s.ViaValue
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s *StreamInputShoutcastImpl) SetVia(v AgentURL) StreamInputShoutcast {
	if s == nil {
		return nil
	}
	s.ViaValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputShoutcastImpl) VideoTimeout() *Seconds {
	return s.VideoTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputShoutcastImpl) SetVideoTimeout(v Seconds) StreamInputShoutcast {
	if s == nil {
		return nil
	}
	s.VideoTimeoutValue = &v
	return s
}

// NewStreamInputSpts creates a new StreamInputSpts instance
func NewStreamInputSpts() StreamInputSpts {
	return &StreamInputSptsImpl{}
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s StreamInputSptsImpl) AllowIf() *string {
	return s.AllowIfValue
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s *StreamInputSptsImpl) SetAllowIf(v string) StreamInputSpts {
	if s == nil {
		return nil
	}
	s.AllowIfValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputSptsImpl) AudioTimeout() *Seconds {
	return s.AudioTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputSptsImpl) SetAudioTimeout(v Seconds) StreamInputSpts {
	if s == nil {
		return nil
	}
	s.AudioTimeoutValue = &v
	return s
}

// The rules for handling the closed captions.
func (s StreamInputSptsImpl) ClosedCaptions() map[string]string {
	return s.ClosedCaptionsValue
}

// The rules for handling the closed captions.
func (s *StreamInputSptsImpl) SetClosedCaptions(v map[string]string) StreamInputSpts {
	if s == nil {
		return nil
	}
	s.ClosedCaptionsValue = v
	return s
}

// Human-readable description of the input.
// Example: This is a test input
func (s StreamInputSptsImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the input.
// Example: This is a test input
func (s *StreamInputSptsImpl) SetComment(v string) StreamInputSpts {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s StreamInputSptsImpl) DenyIf() *string {
	return s.DenyIfValue
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s *StreamInputSptsImpl) SetDenyIf(v string) StreamInputSpts {
	if s == nil {
		return nil
	}
	s.DenyIfValue = &v
	return s
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s StreamInputSptsImpl) FramesTimeout() *int {
	return s.FramesTimeoutValue
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s *StreamInputSptsImpl) SetFramesTimeout(v int) StreamInputSpts {
	if s == nil {
		return nil
	}
	s.FramesTimeoutValue = &v
	return s
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s StreamInputSptsImpl) Headers() map[string]string {
	return s.HeadersValue
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s *StreamInputSptsImpl) SetHeaders(v map[string]string) StreamInputSpts {
	if s == nil {
		return nil
	}
	s.HeadersValue = v
	return s
}

// An array of MPEG-TS language descriptors in format `[{key: track, value: language}]`
func (s StreamInputSptsImpl) Languages() map[string]string {
	return s.LanguagesValue
}

// An array of MPEG-TS language descriptors in format `[{key: track, value: language}]`
func (s *StreamInputSptsImpl) SetLanguages(v map[string]string) StreamInputSpts {
	if s == nil {
		return nil
	}
	s.LanguagesValue = v
	return s
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s StreamInputSptsImpl) MaxRetryTimeout() *Seconds {
	return s.MaxRetryTimeoutValue
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s *StreamInputSptsImpl) SetMaxRetryTimeout(v Seconds) StreamInputSpts {
	if s == nil {
		return nil
	}
	s.MaxRetryTimeoutValue = &v
	return s
}

// Skip input start if the stream has no clients.
func (s StreamInputSptsImpl) NoClientsReconnectDelay() *int {
	return s.NoClientsReconnectDelayValue
}

// Skip input start if the stream has no clients.
func (s *StreamInputSptsImpl) SetNoClientsReconnectDelay(v int) StreamInputSpts {
	if s == nil {
		return nil
	}
	s.NoClientsReconnectDelayValue = &v
	return s
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s StreamInputSptsImpl) OutputAudio() *OutputAudio {
	return s.OutputAudioValue
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s *StreamInputSptsImpl) SetOutputAudio(v OutputAudio) StreamInputSpts {
	if s == nil {
		return nil
	}
	s.OutputAudioValue = &v
	return s
}

// Choose a specific PID to ingest from an MPEG-TS stream.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Example: [211]
func (s StreamInputSptsImpl) Pids() []int {
	return s.PidsValue
}

// Choose a specific PID to ingest from an MPEG-TS stream.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Example: [211]
func (s *StreamInputSptsImpl) SetPids(v []int) StreamInputSpts {
	if s == nil {
		return nil
	}
	s.PidsValue = v
	return s
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s StreamInputSptsImpl) Priority() *int {
	return s.PriorityValue
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s *StreamInputSptsImpl) SetPriority(v int) StreamInputSpts {
	if s == nil {
		return nil
	}
	s.PriorityValue = &v
	return s
}

// Choose a program to ingest from an MPEG-TS stream.
// Example: [1]
func (s StreamInputSptsImpl) Programs() []int {
	return s.ProgramsValue
}

// Choose a program to ingest from an MPEG-TS stream.
// Example: [1]
func (s *StreamInputSptsImpl) SetPrograms(v []int) StreamInputSpts {
	if s == nil {
		return nil
	}
	s.ProgramsValue = v
	return s
}

// Deprecated field. Will be deleted at 23.09
// This option disables processing of SCTE-35 markers from an MPEG-TS input stream.
// Deprecated since 22.12.
// Available ways to disable processing of SCTE-35 markers:
// 1. pids option to select tracks without SCTE-35 markers
// 2. hls_scte35 option from stream_config_media for hls output
// 3. performing appropriate tuning pids in the transponder
// Example: true
func (s StreamInputSptsImpl) Scte35() *bool {
	return s.Scte35Value
}

// Deprecated field. Will be deleted at 23.09
// This option disables processing of SCTE-35 markers from an MPEG-TS input stream.
// Deprecated since 22.12.
// Available ways to disable processing of SCTE-35 markers:
// 1. pids option to select tracks without SCTE-35 markers
// 2. hls_scte35 option from stream_config_media for hls output
// 3. performing appropriate tuning pids in the transponder
// Example: true
func (s *StreamInputSptsImpl) SetScte35(v bool) StreamInputSpts {
	if s == nil {
		return nil
	}
	s.Scte35Value = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s StreamInputSptsImpl) SourceTimeout() any {
	return s.SourceTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s *StreamInputSptsImpl) SetSourceTimeout(v any) StreamInputSpts {
	if s == nil {
		return nil
	}
	s.SourceTimeoutValue = v
	return s
}

// Detailed runtime information about the input.
func (s StreamInputSptsImpl) Stats() InputStats {
	return s.StatsValue
}

// Detailed runtime information about the input.
func (s *StreamInputSptsImpl) SetStats(v InputStats) StreamInputSpts {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// Deprecated field. Will be deleted at 25.03
// This configuration is deprecated. Use `dvbocr` configuration field in stream.
// This parameter allows to manage subtitles in an output stream.
// Example: drop
func (s StreamInputSptsImpl) Subtitles() *StreamInputMpegtsSpecificSubtitles {
	return s.SubtitlesValue
}

// Deprecated field. Will be deleted at 25.03
// This configuration is deprecated. Use `dvbocr` configuration field in stream.
// This parameter allows to manage subtitles in an output stream.
// Example: drop
func (s *StreamInputSptsImpl) SetSubtitles(v StreamInputMpegtsSpecificSubtitles) StreamInputSpts {
	if s == nil {
		return nil
	}
	s.SubtitlesValue = &v
	return s
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s StreamInputSptsImpl) Timeout() *int {
	return s.TimeoutValue
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s *StreamInputSptsImpl) SetTimeout(v int) StreamInputSpts {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// URL to connect to the SPTS source and get the stream.
// Format: input_url (input_url)
// Pattern: ^(udp|udp1|udp2|udp3)://.*$
// Examples: udp1://239.0.0.1:1234, udp2://239.0.0.1:1234, udp3://239.0.0.1:1234, udp://239.0.0.1:1234
func (s StreamInputSptsImpl) URL() InputURL {
	return s.URLValue
}

// URL to connect to the SPTS source and get the stream.
// Format: input_url (input_url)
// Pattern: ^(udp|udp1|udp2|udp3)://.*$
// Examples: udp1://239.0.0.1:1234, udp2://239.0.0.1:1234, udp3://239.0.0.1:1234, udp://239.0.0.1:1234
func (s *StreamInputSptsImpl) SetURL(v InputURL) StreamInputSpts {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// User agent. Can be modified if a protocol allows it.
func (s StreamInputSptsImpl) UserAgent() *string {
	return s.UserAgentValue
}

// User agent. Can be modified if a protocol allows it.
func (s *StreamInputSptsImpl) SetUserAgent(v string) StreamInputSpts {
	if s == nil {
		return nil
	}
	s.UserAgentValue = &v
	return s
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s StreamInputSptsImpl) Via() *AgentURL {
	return s.ViaValue
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s *StreamInputSptsImpl) SetVia(v AgentURL) StreamInputSpts {
	if s == nil {
		return nil
	}
	s.ViaValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputSptsImpl) VideoTimeout() *Seconds {
	return s.VideoTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputSptsImpl) SetVideoTimeout(v Seconds) StreamInputSpts {
	if s == nil {
		return nil
	}
	s.VideoTimeoutValue = &v
	return s
}

// NewStreamInputSrt creates a new StreamInputSrt instance
func NewStreamInputSrt() StreamInputSrt {
	return &StreamInputSrtImpl{}
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s StreamInputSrtImpl) AllowIf() *string {
	return s.AllowIfValue
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s *StreamInputSrtImpl) SetAllowIf(v string) StreamInputSrt {
	if s == nil {
		return nil
	}
	s.AllowIfValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputSrtImpl) AudioTimeout() *Seconds {
	return s.AudioTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputSrtImpl) SetAudioTimeout(v Seconds) StreamInputSrt {
	if s == nil {
		return nil
	}
	s.AudioTimeoutValue = &v
	return s
}

// The rules for handling the closed captions.
func (s StreamInputSrtImpl) ClosedCaptions() map[string]string {
	return s.ClosedCaptionsValue
}

// The rules for handling the closed captions.
func (s *StreamInputSrtImpl) SetClosedCaptions(v map[string]string) StreamInputSrt {
	if s == nil {
		return nil
	}
	s.ClosedCaptionsValue = v
	return s
}

// Human-readable description of the input.
// Example: This is a test input
func (s StreamInputSrtImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the input.
// Example: This is a test input
func (s *StreamInputSrtImpl) SetComment(v string) StreamInputSrt {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s StreamInputSrtImpl) DenyIf() *string {
	return s.DenyIfValue
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s *StreamInputSrtImpl) SetDenyIf(v string) StreamInputSrt {
	if s == nil {
		return nil
	}
	s.DenyIfValue = &v
	return s
}

// Whether both connection parties must have the same password set (including empty, in other words, with no encryption).
// If the passwords do not match or only one side is unencrypted, the connection is rejected.
// The default value is `true`.
// Example: true
func (s StreamInputSrtImpl) Enforcedencryption() *bool {
	return s.EnforcedencryptionValue
}

// Whether both connection parties must have the same password set (including empty, in other words, with no encryption).
// If the passwords do not match or only one side is unencrypted, the connection is rejected.
// The default value is `true`.
// Example: true
func (s *StreamInputSrtImpl) SetEnforcedencryption(v bool) StreamInputSrt {
	if s == nil {
		return nil
	}
	s.EnforcedencryptionValue = &v
	return s
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s StreamInputSrtImpl) FramesTimeout() *int {
	return s.FramesTimeoutValue
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s *StreamInputSrtImpl) SetFramesTimeout(v int) StreamInputSrt {
	if s == nil {
		return nil
	}
	s.FramesTimeoutValue = &v
	return s
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s StreamInputSrtImpl) Headers() map[string]string {
	return s.HeadersValue
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s *StreamInputSrtImpl) SetHeaders(v map[string]string) StreamInputSrt {
	if s == nil {
		return nil
	}
	s.HeadersValue = v
	return s
}

// The latency value for both directions of the socket.
// By default initial value latency is 0 when transmitting and 120ms when receiving video.
// Actual value established after connection handshake.
// Increased value helps tolerate network losses and delays.
// Format: milliseconds (milliseconds)
// Example: 150
func (s StreamInputSrtImpl) Latency() *Milliseconds {
	return s.LatencyValue
}

// The latency value for both directions of the socket.
// By default initial value latency is 0 when transmitting and 120ms when receiving video.
// Actual value established after connection handshake.
// Increased value helps tolerate network losses and delays.
// Format: milliseconds (milliseconds)
// Example: 150
func (s *StreamInputSrtImpl) SetLatency(v Milliseconds) StreamInputSrt {
	if s == nil {
		return nil
	}
	s.LatencyValue = &v
	return s
}

// The time, in seconds, that the socket waits for the unsent data before closing.
// The default value is 180.
// Format: seconds (seconds)
// Example: 15
func (s StreamInputSrtImpl) Linger() *Seconds {
	return s.LingerValue
}

// The time, in seconds, that the socket waits for the unsent data before closing.
// The default value is 180.
// Format: seconds (seconds)
// Example: 15
func (s *StreamInputSrtImpl) SetLinger(v Seconds) StreamInputSrt {
	if s == nil {
		return nil
	}
	s.LingerValue = &v
	return s
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s StreamInputSrtImpl) MaxRetryTimeout() *Seconds {
	return s.MaxRetryTimeoutValue
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s *StreamInputSrtImpl) SetMaxRetryTimeout(v Seconds) StreamInputSrt {
	if s == nil {
		return nil
	}
	s.MaxRetryTimeoutValue = &v
	return s
}

// The minimum SRT version that is required from the peer for SRT publication.
// Pattern: ^[0-9]+\.[0-9]+\.[0-9]+$
// Example: 1.1.0
func (s StreamInputSrtImpl) Minversion() *string {
	return s.MinversionValue
}

// The minimum SRT version that is required from the peer for SRT publication.
// Pattern: ^[0-9]+\.[0-9]+\.[0-9]+$
// Example: 1.1.0
func (s *StreamInputSrtImpl) SetMinversion(v string) StreamInputSrt {
	if s == nil {
		return nil
	}
	s.MinversionValue = &v
	return s
}

// Skip input start if the stream has no clients.
func (s StreamInputSrtImpl) NoClientsReconnectDelay() *int {
	return s.NoClientsReconnectDelayValue
}

// Skip input start if the stream has no clients.
func (s *StreamInputSrtImpl) SetNoClientsReconnectDelay(v int) StreamInputSrt {
	if s == nil {
		return nil
	}
	s.NoClientsReconnectDelayValue = &v
	return s
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s StreamInputSrtImpl) OutputAudio() *OutputAudio {
	return s.OutputAudioValue
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s *StreamInputSrtImpl) SetOutputAudio(v OutputAudio) StreamInputSrt {
	if s == nil {
		return nil
	}
	s.OutputAudioValue = &v
	return s
}

// The password for the encrypted transmission.
// Its length should be not less than 10 and not more than 79 characters.
// Unlike [password](https://flussonic.com/doc/api/reference/#tag/stream/operation/stream_save%7Cbody%7Cpassword),
// the passphrase is not transmitted openly but is used to encrypt the key that is transmitted by the Caller
// and decoded by Listener.
// Example: 9876543210
func (s StreamInputSrtImpl) Passphrase() *string {
	return s.PassphraseValue
}

// The password for the encrypted transmission.
// Its length should be not less than 10 and not more than 79 characters.
// Unlike [password](https://flussonic.com/doc/api/reference/#tag/stream/operation/stream_save%7Cbody%7Cpassword),
// the passphrase is not transmitted openly but is used to encrypt the key that is transmitted by the Caller
// and decoded by Listener.
// Example: 9876543210
func (s *StreamInputSrtImpl) SetPassphrase(v string) StreamInputSrt {
	if s == nil {
		return nil
	}
	s.PassphraseValue = &v
	return s
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s StreamInputSrtImpl) Priority() *int {
	return s.PriorityValue
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s *StreamInputSrtImpl) SetPriority(v int) StreamInputSrt {
	if s == nil {
		return nil
	}
	s.PriorityValue = &v
	return s
}

// This option disables processing of SCTE-35 markers from SRT input stream.
// Example: true
func (s StreamInputSrtImpl) Scte35() *bool {
	return s.Scte35Value
}

// This option disables processing of SCTE-35 markers from SRT input stream.
// Example: true
func (s *StreamInputSrtImpl) SetScte35(v bool) StreamInputSrt {
	if s == nil {
		return nil
	}
	s.Scte35Value = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s StreamInputSrtImpl) SourceTimeout() any {
	return s.SourceTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s *StreamInputSrtImpl) SetSourceTimeout(v any) StreamInputSrt {
	if s == nil {
		return nil
	}
	s.SourceTimeoutValue = v
	return s
}

// Detailed runtime information about the input.
func (s StreamInputSrtImpl) Stats() InputStats {
	return s.StatsValue
}

// Detailed runtime information about the input.
func (s *StreamInputSrtImpl) SetStats(v InputStats) StreamInputSrt {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// A string of maximum 512 characters set on the socket before the connection.
// This string is a part of a callback that is sent by the caller and regisered by the listener.
// Based on this information the listener can accept or reject the connection, select the desired data stream, or set an appropriate passphrase for the connection.
// Its format is `#!::` optionally followed by the parameters:
// * `r=` - stream name
// * `m=` - mode expected for the connection: `publish` (if the caller wants to send the stream data) or `request` (if the caller wants to receive the stream).
// * `password=` - a password for the authorization in a publish session (not recommended, better use `passphrase` option instead)
// During SRT sessions the following parameters are automaticly added to streamid:
// * `s=` - the identifier of a session
// * `a=` - Flussonic version
// NOTE: you can specify a string in the format you need; to disable this extension, you need specify empty string.
// Example: #!::r=my-stream,m=publish
func (s StreamInputSrtImpl) Streamid() *string {
	return s.StreamidValue
}

// A string of maximum 512 characters set on the socket before the connection.
// This string is a part of a callback that is sent by the caller and regisered by the listener.
// Based on this information the listener can accept or reject the connection, select the desired data stream, or set an appropriate passphrase for the connection.
// Its format is `#!::` optionally followed by the parameters:
// * `r=` - stream name
// * `m=` - mode expected for the connection: `publish` (if the caller wants to send the stream data) or `request` (if the caller wants to receive the stream).
// * `password=` - a password for the authorization in a publish session (not recommended, better use `passphrase` option instead)
// During SRT sessions the following parameters are automaticly added to streamid:
// * `s=` - the identifier of a session
// * `a=` - Flussonic version
// NOTE: you can specify a string in the format you need; to disable this extension, you need specify empty string.
// Example: #!::r=my-stream,m=publish
func (s *StreamInputSrtImpl) SetStreamid(v string) StreamInputSrt {
	if s == nil {
		return nil
	}
	s.StreamidValue = &v
	return s
}

// Deprecated field. Will be deleted at 25.03
// This configuration is deprecated. Use `dvbocr` configuration field in stream.
// This parameter allows to manage subtitles in an output stream.
// Example: drop
func (s StreamInputSrtImpl) Subtitles() *StreamInputSrtPublishSpecificSubtitles {
	return s.SubtitlesValue
}

// Deprecated field. Will be deleted at 25.03
// This configuration is deprecated. Use `dvbocr` configuration field in stream.
// This parameter allows to manage subtitles in an output stream.
// Example: drop
func (s *StreamInputSrtImpl) SetSubtitles(v StreamInputSrtPublishSpecificSubtitles) StreamInputSrt {
	if s == nil {
		return nil
	}
	s.SubtitlesValue = &v
	return s
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s StreamInputSrtImpl) Timeout() *int {
	return s.TimeoutValue
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s *StreamInputSrtImpl) SetTimeout(v int) StreamInputSrt {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// Artificial URL to connect to the SRT source and get the stream.
// SRT requires IP and port, so we create an artificial URL to specify the options to manage the data interchange.
// Format: input_url (input_url)
// Pattern: ^(srt|srt1|srt2)://.*$
// Examples: srt1://remote.host.com:1234?bind_ip=10.77.0.100, srt2://remote.host.com:1234?bind_ip=10.77.0.100, srt://remote.host.com:1234?bind_ip=10.77.0.100
func (s StreamInputSrtImpl) URL() InputURL {
	return s.URLValue
}

// Artificial URL to connect to the SRT source and get the stream.
// SRT requires IP and port, so we create an artificial URL to specify the options to manage the data interchange.
// Format: input_url (input_url)
// Pattern: ^(srt|srt1|srt2)://.*$
// Examples: srt1://remote.host.com:1234?bind_ip=10.77.0.100, srt2://remote.host.com:1234?bind_ip=10.77.0.100, srt://remote.host.com:1234?bind_ip=10.77.0.100
func (s *StreamInputSrtImpl) SetURL(v InputURL) StreamInputSrt {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// User agent. Can be modified if a protocol allows it.
func (s StreamInputSrtImpl) UserAgent() *string {
	return s.UserAgentValue
}

// User agent. Can be modified if a protocol allows it.
func (s *StreamInputSrtImpl) SetUserAgent(v string) StreamInputSrt {
	if s == nil {
		return nil
	}
	s.UserAgentValue = &v
	return s
}

// Required SRT version.
// Pattern: ^[0-9]+\.[0-9]+\.[0-9]+$
// Example: 1.3.0
func (s StreamInputSrtImpl) Version() *string {
	return s.VersionValue
}

// Required SRT version.
// Pattern: ^[0-9]+\.[0-9]+\.[0-9]+$
// Example: 1.3.0
func (s *StreamInputSrtImpl) SetVersion(v string) StreamInputSrt {
	if s == nil {
		return nil
	}
	s.VersionValue = &v
	return s
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s StreamInputSrtImpl) Via() *AgentURL {
	return s.ViaValue
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s *StreamInputSrtImpl) SetVia(v AgentURL) StreamInputSrt {
	if s == nil {
		return nil
	}
	s.ViaValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputSrtImpl) VideoTimeout() *Seconds {
	return s.VideoTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputSrtImpl) SetVideoTimeout(v Seconds) StreamInputSrt {
	if s == nil {
		return nil
	}
	s.VideoTimeoutValue = &v
	return s
}

// NewStreamInputSrtPublishSpecific creates a new StreamInputSrtPublishSpecific instance
func NewStreamInputSrtPublishSpecific() StreamInputSrtPublishSpecific {
	return &StreamInputSrtPublishSpecificImpl{}
}

// This option disables processing of SCTE-35 markers from SRT input stream.
// Example: true
func (s StreamInputSrtPublishSpecificImpl) Scte35() *bool {
	return s.Scte35Value
}

// This option disables processing of SCTE-35 markers from SRT input stream.
// Example: true
func (s *StreamInputSrtPublishSpecificImpl) SetScte35(v bool) StreamInputSrtPublishSpecific {
	if s == nil {
		return nil
	}
	s.Scte35Value = &v
	return s
}

// Deprecated field. Will be deleted at 25.03
// This configuration is deprecated. Use `dvbocr` configuration field in stream.
// This parameter allows to manage subtitles in an output stream.
// Example: drop
func (s StreamInputSrtPublishSpecificImpl) Subtitles() *StreamInputSrtPublishSpecificSubtitles {
	return s.SubtitlesValue
}

// Deprecated field. Will be deleted at 25.03
// This configuration is deprecated. Use `dvbocr` configuration field in stream.
// This parameter allows to manage subtitles in an output stream.
// Example: drop
func (s *StreamInputSrtPublishSpecificImpl) SetSubtitles(v StreamInputSrtPublishSpecificSubtitles) StreamInputSrtPublishSpecific {
	if s == nil {
		return nil
	}
	s.SubtitlesValue = &v
	return s
}

// NewStreamInputSt2110 creates a new StreamInputSt2110 instance
func NewStreamInputSt2110() StreamInputSt2110 {
	return &StreamInputSt2110Impl{}
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s StreamInputSt2110Impl) AllowIf() *string {
	return s.AllowIfValue
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s *StreamInputSt2110Impl) SetAllowIf(v string) StreamInputSt2110 {
	if s == nil {
		return nil
	}
	s.AllowIfValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputSt2110Impl) AudioTimeout() *Seconds {
	return s.AudioTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputSt2110Impl) SetAudioTimeout(v Seconds) StreamInputSt2110 {
	if s == nil {
		return nil
	}
	s.AudioTimeoutValue = &v
	return s
}

// Optional bind core
func (s StreamInputSt2110Impl) BindToCore() *int {
	return s.BindToCoreValue
}

// Optional bind core
func (s *StreamInputSt2110Impl) SetBindToCore(v int) StreamInputSt2110 {
	if s == nil {
		return nil
	}
	s.BindToCoreValue = &v
	return s
}

// Human-readable description of the input.
// Example: This is a test input
func (s StreamInputSt2110Impl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the input.
// Example: This is a test input
func (s *StreamInputSt2110Impl) SetComment(v string) StreamInputSt2110 {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s StreamInputSt2110Impl) DenyIf() *string {
	return s.DenyIfValue
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s *StreamInputSt2110Impl) SetDenyIf(v string) StreamInputSt2110 {
	if s == nil {
		return nil
	}
	s.DenyIfValue = &v
	return s
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s StreamInputSt2110Impl) FramesTimeout() *int {
	return s.FramesTimeoutValue
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s *StreamInputSt2110Impl) SetFramesTimeout(v int) StreamInputSt2110 {
	if s == nil {
		return nil
	}
	s.FramesTimeoutValue = &v
	return s
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s StreamInputSt2110Impl) Headers() map[string]string {
	return s.HeadersValue
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s *StreamInputSt2110Impl) SetHeaders(v map[string]string) StreamInputSt2110 {
	if s == nil {
		return nil
	}
	s.HeadersValue = v
	return s
}

// Must specify received pixel height
func (s StreamInputSt2110Impl) Height() *int {
	return s.HeightValue
}

// Must specify received pixel height
func (s *StreamInputSt2110Impl) SetHeight(v int) StreamInputSt2110 {
	if s == nil {
		return nil
	}
	s.HeightValue = &v
	return s
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s StreamInputSt2110Impl) MaxRetryTimeout() *Seconds {
	return s.MaxRetryTimeoutValue
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s *StreamInputSt2110Impl) SetMaxRetryTimeout(v Seconds) StreamInputSt2110 {
	if s == nil {
		return nil
	}
	s.MaxRetryTimeoutValue = &v
	return s
}

// Skip input start if the stream has no clients.
func (s StreamInputSt2110Impl) NoClientsReconnectDelay() *int {
	return s.NoClientsReconnectDelayValue
}

// Skip input start if the stream has no clients.
func (s *StreamInputSt2110Impl) SetNoClientsReconnectDelay(v int) StreamInputSt2110 {
	if s == nil {
		return nil
	}
	s.NoClientsReconnectDelayValue = &v
	return s
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s StreamInputSt2110Impl) OutputAudio() *OutputAudio {
	return s.OutputAudioValue
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s *StreamInputSt2110Impl) SetOutputAudio(v OutputAudio) StreamInputSt2110 {
	if s == nil {
		return nil
	}
	s.OutputAudioValue = &v
	return s
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s StreamInputSt2110Impl) Priority() *int {
	return s.PriorityValue
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s *StreamInputSt2110Impl) SetPriority(v int) StreamInputSt2110 {
	if s == nil {
		return nil
	}
	s.PriorityValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s StreamInputSt2110Impl) SourceTimeout() any {
	return s.SourceTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s *StreamInputSt2110Impl) SetSourceTimeout(v any) StreamInputSt2110 {
	if s == nil {
		return nil
	}
	s.SourceTimeoutValue = v
	return s
}

// Detailed runtime information about the input.
func (s StreamInputSt2110Impl) Stats() InputStats {
	return s.StatsValue
}

// Detailed runtime information about the input.
func (s *StreamInputSt2110Impl) SetStats(v InputStats) StreamInputSt2110 {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s StreamInputSt2110Impl) Timeout() *int {
	return s.TimeoutValue
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s *StreamInputSt2110Impl) SetTimeout(v int) StreamInputSt2110 {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// SMPTE 2110 UDP multicast group
// Format: input_url (input_url)
// Pattern: ^st2110://.*$
// Examples: st2110://239.0.0.1:1234, st2110://239.0.0.1:1234/192.168.20.24, st2110://eth0@239.0.0.1:1234
func (s StreamInputSt2110Impl) URL() InputURL {
	return s.URLValue
}

// SMPTE 2110 UDP multicast group
// Format: input_url (input_url)
// Pattern: ^st2110://.*$
// Examples: st2110://239.0.0.1:1234, st2110://239.0.0.1:1234/192.168.20.24, st2110://eth0@239.0.0.1:1234
func (s *StreamInputSt2110Impl) SetURL(v InputURL) StreamInputSt2110 {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// User agent. Can be modified if a protocol allows it.
func (s StreamInputSt2110Impl) UserAgent() *string {
	return s.UserAgentValue
}

// User agent. Can be modified if a protocol allows it.
func (s *StreamInputSt2110Impl) SetUserAgent(v string) StreamInputSt2110 {
	if s == nil {
		return nil
	}
	s.UserAgentValue = &v
	return s
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s StreamInputSt2110Impl) Via() *AgentURL {
	return s.ViaValue
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s *StreamInputSt2110Impl) SetVia(v AgentURL) StreamInputSt2110 {
	if s == nil {
		return nil
	}
	s.ViaValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputSt2110Impl) VideoTimeout() *Seconds {
	return s.VideoTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputSt2110Impl) SetVideoTimeout(v Seconds) StreamInputSt2110 {
	if s == nil {
		return nil
	}
	s.VideoTimeoutValue = &v
	return s
}

// Must specify received pixel width
func (s StreamInputSt2110Impl) Width() *int {
	return s.WidthValue
}

// Must specify received pixel width
func (s *StreamInputSt2110Impl) SetWidth(v int) StreamInputSt2110 {
	if s == nil {
		return nil
	}
	s.WidthValue = &v
	return s
}

// NewStreamInputTimeshift creates a new StreamInputTimeshift instance
func NewStreamInputTimeshift() StreamInputTimeshift {
	return &StreamInputTimeshiftImpl{}
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s StreamInputTimeshiftImpl) AllowIf() *string {
	return s.AllowIfValue
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s *StreamInputTimeshiftImpl) SetAllowIf(v string) StreamInputTimeshift {
	if s == nil {
		return nil
	}
	s.AllowIfValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputTimeshiftImpl) AudioTimeout() *Seconds {
	return s.AudioTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputTimeshiftImpl) SetAudioTimeout(v Seconds) StreamInputTimeshift {
	if s == nil {
		return nil
	}
	s.AudioTimeoutValue = &v
	return s
}

// Human-readable description of the input.
// Example: This is a test input
func (s StreamInputTimeshiftImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the input.
// Example: This is a test input
func (s *StreamInputTimeshiftImpl) SetComment(v string) StreamInputTimeshift {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s StreamInputTimeshiftImpl) DenyIf() *string {
	return s.DenyIfValue
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s *StreamInputTimeshiftImpl) SetDenyIf(v string) StreamInputTimeshift {
	if s == nil {
		return nil
	}
	s.DenyIfValue = &v
	return s
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s StreamInputTimeshiftImpl) FramesTimeout() *int {
	return s.FramesTimeoutValue
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s *StreamInputTimeshiftImpl) SetFramesTimeout(v int) StreamInputTimeshift {
	if s == nil {
		return nil
	}
	s.FramesTimeoutValue = &v
	return s
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s StreamInputTimeshiftImpl) Headers() map[string]string {
	return s.HeadersValue
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s *StreamInputTimeshiftImpl) SetHeaders(v map[string]string) StreamInputTimeshift {
	if s == nil {
		return nil
	}
	s.HeadersValue = v
	return s
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s StreamInputTimeshiftImpl) MaxRetryTimeout() *Seconds {
	return s.MaxRetryTimeoutValue
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s *StreamInputTimeshiftImpl) SetMaxRetryTimeout(v Seconds) StreamInputTimeshift {
	if s == nil {
		return nil
	}
	s.MaxRetryTimeoutValue = &v
	return s
}

// Skip input start if the stream has no clients.
func (s StreamInputTimeshiftImpl) NoClientsReconnectDelay() *int {
	return s.NoClientsReconnectDelayValue
}

// Skip input start if the stream has no clients.
func (s *StreamInputTimeshiftImpl) SetNoClientsReconnectDelay(v int) StreamInputTimeshift {
	if s == nil {
		return nil
	}
	s.NoClientsReconnectDelayValue = &v
	return s
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s StreamInputTimeshiftImpl) OutputAudio() *OutputAudio {
	return s.OutputAudioValue
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s *StreamInputTimeshiftImpl) SetOutputAudio(v OutputAudio) StreamInputTimeshift {
	if s == nil {
		return nil
	}
	s.OutputAudioValue = &v
	return s
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s StreamInputTimeshiftImpl) Priority() *int {
	return s.PriorityValue
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s *StreamInputTimeshiftImpl) SetPriority(v int) StreamInputTimeshift {
	if s == nil {
		return nil
	}
	s.PriorityValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s StreamInputTimeshiftImpl) SourceTimeout() any {
	return s.SourceTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s *StreamInputTimeshiftImpl) SetSourceTimeout(v any) StreamInputTimeshift {
	if s == nil {
		return nil
	}
	s.SourceTimeoutValue = v
	return s
}

// Detailed runtime information about the input.
func (s StreamInputTimeshiftImpl) Stats() InputStats {
	return s.StatsValue
}

// Detailed runtime information about the input.
func (s *StreamInputTimeshiftImpl) SetStats(v InputStats) StreamInputTimeshift {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s StreamInputTimeshiftImpl) Timeout() *int {
	return s.TimeoutValue
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s *StreamInputTimeshiftImpl) SetTimeout(v int) StreamInputTimeshift {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// Special URL to play the archive record of a stream with a fixed delay.
// Format: input_url (input_url)
// Pattern: ^timeshift://.*$
// Examples: timeshift://channel/7200
func (s StreamInputTimeshiftImpl) URL() InputURL {
	return s.URLValue
}

// Special URL to play the archive record of a stream with a fixed delay.
// Format: input_url (input_url)
// Pattern: ^timeshift://.*$
// Examples: timeshift://channel/7200
func (s *StreamInputTimeshiftImpl) SetURL(v InputURL) StreamInputTimeshift {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// User agent. Can be modified if a protocol allows it.
func (s StreamInputTimeshiftImpl) UserAgent() *string {
	return s.UserAgentValue
}

// User agent. Can be modified if a protocol allows it.
func (s *StreamInputTimeshiftImpl) SetUserAgent(v string) StreamInputTimeshift {
	if s == nil {
		return nil
	}
	s.UserAgentValue = &v
	return s
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s StreamInputTimeshiftImpl) Via() *AgentURL {
	return s.ViaValue
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s *StreamInputTimeshiftImpl) SetVia(v AgentURL) StreamInputTimeshift {
	if s == nil {
		return nil
	}
	s.ViaValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputTimeshiftImpl) VideoTimeout() *Seconds {
	return s.VideoTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputTimeshiftImpl) SetVideoTimeout(v Seconds) StreamInputTimeshift {
	if s == nil {
		return nil
	}
	s.VideoTimeoutValue = &v
	return s
}

// NewStreamInputTshttp creates a new StreamInputTshttp instance
func NewStreamInputTshttp() StreamInputTshttp {
	return &StreamInputTshttpImpl{}
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s StreamInputTshttpImpl) AllowIf() *string {
	return s.AllowIfValue
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s *StreamInputTshttpImpl) SetAllowIf(v string) StreamInputTshttp {
	if s == nil {
		return nil
	}
	s.AllowIfValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputTshttpImpl) AudioTimeout() *Seconds {
	return s.AudioTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputTshttpImpl) SetAudioTimeout(v Seconds) StreamInputTshttp {
	if s == nil {
		return nil
	}
	s.AudioTimeoutValue = &v
	return s
}

// The rules for handling the closed captions.
func (s StreamInputTshttpImpl) ClosedCaptions() map[string]string {
	return s.ClosedCaptionsValue
}

// The rules for handling the closed captions.
func (s *StreamInputTshttpImpl) SetClosedCaptions(v map[string]string) StreamInputTshttp {
	if s == nil {
		return nil
	}
	s.ClosedCaptionsValue = v
	return s
}

// Human-readable description of the input.
// Example: This is a test input
func (s StreamInputTshttpImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the input.
// Example: This is a test input
func (s *StreamInputTshttpImpl) SetComment(v string) StreamInputTshttp {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s StreamInputTshttpImpl) DenyIf() *string {
	return s.DenyIfValue
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s *StreamInputTshttpImpl) SetDenyIf(v string) StreamInputTshttp {
	if s == nil {
		return nil
	}
	s.DenyIfValue = &v
	return s
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s StreamInputTshttpImpl) FramesTimeout() *int {
	return s.FramesTimeoutValue
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s *StreamInputTshttpImpl) SetFramesTimeout(v int) StreamInputTshttp {
	if s == nil {
		return nil
	}
	s.FramesTimeoutValue = &v
	return s
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s StreamInputTshttpImpl) Headers() map[string]string {
	return s.HeadersValue
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s *StreamInputTshttpImpl) SetHeaders(v map[string]string) StreamInputTshttp {
	if s == nil {
		return nil
	}
	s.HeadersValue = v
	return s
}

// An array of MPEG-TS language descriptors in format `[{key: track, value: language}]`
func (s StreamInputTshttpImpl) Languages() map[string]string {
	return s.LanguagesValue
}

// An array of MPEG-TS language descriptors in format `[{key: track, value: language}]`
func (s *StreamInputTshttpImpl) SetLanguages(v map[string]string) StreamInputTshttp {
	if s == nil {
		return nil
	}
	s.LanguagesValue = v
	return s
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s StreamInputTshttpImpl) MaxRetryTimeout() *Seconds {
	return s.MaxRetryTimeoutValue
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s *StreamInputTshttpImpl) SetMaxRetryTimeout(v Seconds) StreamInputTshttp {
	if s == nil {
		return nil
	}
	s.MaxRetryTimeoutValue = &v
	return s
}

// Skip input start if the stream has no clients.
func (s StreamInputTshttpImpl) NoClientsReconnectDelay() *int {
	return s.NoClientsReconnectDelayValue
}

// Skip input start if the stream has no clients.
func (s *StreamInputTshttpImpl) SetNoClientsReconnectDelay(v int) StreamInputTshttp {
	if s == nil {
		return nil
	}
	s.NoClientsReconnectDelayValue = &v
	return s
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s StreamInputTshttpImpl) OutputAudio() *OutputAudio {
	return s.OutputAudioValue
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s *StreamInputTshttpImpl) SetOutputAudio(v OutputAudio) StreamInputTshttp {
	if s == nil {
		return nil
	}
	s.OutputAudioValue = &v
	return s
}

// Choose a specific PID to ingest from an MPEG-TS stream.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Example: [211]
func (s StreamInputTshttpImpl) Pids() []int {
	return s.PidsValue
}

// Choose a specific PID to ingest from an MPEG-TS stream.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Example: [211]
func (s *StreamInputTshttpImpl) SetPids(v []int) StreamInputTshttp {
	if s == nil {
		return nil
	}
	s.PidsValue = v
	return s
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s StreamInputTshttpImpl) Priority() *int {
	return s.PriorityValue
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s *StreamInputTshttpImpl) SetPriority(v int) StreamInputTshttp {
	if s == nil {
		return nil
	}
	s.PriorityValue = &v
	return s
}

// Choose a program to ingest from an MPEG-TS stream.
// Example: [1]
func (s StreamInputTshttpImpl) Programs() []int {
	return s.ProgramsValue
}

// Choose a program to ingest from an MPEG-TS stream.
// Example: [1]
func (s *StreamInputTshttpImpl) SetPrograms(v []int) StreamInputTshttp {
	if s == nil {
		return nil
	}
	s.ProgramsValue = v
	return s
}

// Deprecated field. Will be deleted at 23.09
// This option disables processing of SCTE-35 markers from an MPEG-TS input stream.
// Deprecated since 22.12.
// Available ways to disable processing of SCTE-35 markers:
// 1. pids option to select tracks without SCTE-35 markers
// 2. hls_scte35 option from stream_config_media for hls output
// 3. performing appropriate tuning pids in the transponder
// Example: true
func (s StreamInputTshttpImpl) Scte35() *bool {
	return s.Scte35Value
}

// Deprecated field. Will be deleted at 23.09
// This option disables processing of SCTE-35 markers from an MPEG-TS input stream.
// Deprecated since 22.12.
// Available ways to disable processing of SCTE-35 markers:
// 1. pids option to select tracks without SCTE-35 markers
// 2. hls_scte35 option from stream_config_media for hls output
// 3. performing appropriate tuning pids in the transponder
// Example: true
func (s *StreamInputTshttpImpl) SetScte35(v bool) StreamInputTshttp {
	if s == nil {
		return nil
	}
	s.Scte35Value = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s StreamInputTshttpImpl) SourceTimeout() any {
	return s.SourceTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s *StreamInputTshttpImpl) SetSourceTimeout(v any) StreamInputTshttp {
	if s == nil {
		return nil
	}
	s.SourceTimeoutValue = v
	return s
}

// Detailed runtime information about the input.
func (s StreamInputTshttpImpl) Stats() InputStats {
	return s.StatsValue
}

// Detailed runtime information about the input.
func (s *StreamInputTshttpImpl) SetStats(v InputStats) StreamInputTshttp {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// Deprecated field. Will be deleted at 25.03
// This configuration is deprecated. Use `dvbocr` configuration field in stream.
// This parameter allows to manage subtitles in an output stream.
// Example: drop
func (s StreamInputTshttpImpl) Subtitles() *StreamInputMpegtsSpecificSubtitles {
	return s.SubtitlesValue
}

// Deprecated field. Will be deleted at 25.03
// This configuration is deprecated. Use `dvbocr` configuration field in stream.
// This parameter allows to manage subtitles in an output stream.
// Example: drop
func (s *StreamInputTshttpImpl) SetSubtitles(v StreamInputMpegtsSpecificSubtitles) StreamInputTshttp {
	if s == nil {
		return nil
	}
	s.SubtitlesValue = &v
	return s
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s StreamInputTshttpImpl) Timeout() *int {
	return s.TimeoutValue
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s *StreamInputTshttpImpl) SetTimeout(v int) StreamInputTshttp {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// URL for ingest and pass a stream "as is" without repackaging.
// Format: input_url (input_url)
// Pattern: ^(tshttp|tshttps)://.*$|^(http|https)://.*(\.ts|/mpegts)$
// Examples: http://remote.host.com/example.ts, http://remote.host.com/mpegts, https://remote.host.com/example.ts, https://remote.host.com/mpegts, tshttp://ADMIN:PASSWORD@FLUSSONIC_IP/flussonic/api/dvbts/a0, tshttps://127.0.0.1:8080
func (s StreamInputTshttpImpl) URL() InputURL {
	return s.URLValue
}

// URL for ingest and pass a stream "as is" without repackaging.
// Format: input_url (input_url)
// Pattern: ^(tshttp|tshttps)://.*$|^(http|https)://.*(\.ts|/mpegts)$
// Examples: http://remote.host.com/example.ts, http://remote.host.com/mpegts, https://remote.host.com/example.ts, https://remote.host.com/mpegts, tshttp://ADMIN:PASSWORD@FLUSSONIC_IP/flussonic/api/dvbts/a0, tshttps://127.0.0.1:8080
func (s *StreamInputTshttpImpl) SetURL(v InputURL) StreamInputTshttp {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// User agent. Can be modified if a protocol allows it.
func (s StreamInputTshttpImpl) UserAgent() *string {
	return s.UserAgentValue
}

// User agent. Can be modified if a protocol allows it.
func (s *StreamInputTshttpImpl) SetUserAgent(v string) StreamInputTshttp {
	if s == nil {
		return nil
	}
	s.UserAgentValue = &v
	return s
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s StreamInputTshttpImpl) Via() *AgentURL {
	return s.ViaValue
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s *StreamInputTshttpImpl) SetVia(v AgentURL) StreamInputTshttp {
	if s == nil {
		return nil
	}
	s.ViaValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputTshttpImpl) VideoTimeout() *Seconds {
	return s.VideoTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputTshttpImpl) SetVideoTimeout(v Seconds) StreamInputTshttp {
	if s == nil {
		return nil
	}
	s.VideoTimeoutValue = &v
	return s
}

// NewStreamInputV4l creates a new StreamInputV4l instance
func NewStreamInputV4l() StreamInputV4l {
	return &StreamInputV4lImpl{}
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s StreamInputV4lImpl) AllowIf() *string {
	return s.AllowIfValue
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s *StreamInputV4lImpl) SetAllowIf(v string) StreamInputV4l {
	if s == nil {
		return nil
	}
	s.AllowIfValue = &v
	return s
}

// The audio device to capture audio from Stream Labs SDI cards.
// This parameter is specified for ALSA devices in the following format `interface:card,device`.
// Example: plughw:1,0
func (s StreamInputV4lImpl) AudioDevice() *string {
	return s.AudioDeviceValue
}

// The audio device to capture audio from Stream Labs SDI cards.
// This parameter is specified for ALSA devices in the following format `interface:card,device`.
// Example: plughw:1,0
func (s *StreamInputV4lImpl) SetAudioDevice(v string) StreamInputV4l {
	if s == nil {
		return nil
	}
	s.AudioDeviceValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputV4lImpl) AudioTimeout() *Seconds {
	return s.AudioTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputV4lImpl) SetAudioTimeout(v Seconds) StreamInputV4l {
	if s == nil {
		return nil
	}
	s.AudioTimeoutValue = &v
	return s
}

// Human-readable description of the input.
// Example: This is a test input
func (s StreamInputV4lImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the input.
// Example: This is a test input
func (s *StreamInputV4lImpl) SetComment(v string) StreamInputV4l {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s StreamInputV4lImpl) DenyIf() *string {
	return s.DenyIfValue
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s *StreamInputV4lImpl) SetDenyIf(v string) StreamInputV4l {
	if s == nil {
		return nil
	}
	s.DenyIfValue = &v
	return s
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s StreamInputV4lImpl) FramesTimeout() *int {
	return s.FramesTimeoutValue
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s *StreamInputV4lImpl) SetFramesTimeout(v int) StreamInputV4l {
	if s == nil {
		return nil
	}
	s.FramesTimeoutValue = &v
	return s
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s StreamInputV4lImpl) Headers() map[string]string {
	return s.HeadersValue
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s *StreamInputV4lImpl) SetHeaders(v map[string]string) StreamInputV4l {
	if s == nil {
		return nil
	}
	s.HeadersValue = v
	return s
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s StreamInputV4lImpl) MaxRetryTimeout() *Seconds {
	return s.MaxRetryTimeoutValue
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s *StreamInputV4lImpl) SetMaxRetryTimeout(v Seconds) StreamInputV4l {
	if s == nil {
		return nil
	}
	s.MaxRetryTimeoutValue = &v
	return s
}

// Skip input start if the stream has no clients.
func (s StreamInputV4lImpl) NoClientsReconnectDelay() *int {
	return s.NoClientsReconnectDelayValue
}

// Skip input start if the stream has no clients.
func (s *StreamInputV4lImpl) SetNoClientsReconnectDelay(v int) StreamInputV4l {
	if s == nil {
		return nil
	}
	s.NoClientsReconnectDelayValue = &v
	return s
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s StreamInputV4lImpl) OutputAudio() *OutputAudio {
	return s.OutputAudioValue
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s *StreamInputV4lImpl) SetOutputAudio(v OutputAudio) StreamInputV4l {
	if s == nil {
		return nil
	}
	s.OutputAudioValue = &v
	return s
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s StreamInputV4lImpl) Priority() *int {
	return s.PriorityValue
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s *StreamInputV4lImpl) SetPriority(v int) StreamInputV4l {
	if s == nil {
		return nil
	}
	s.PriorityValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s StreamInputV4lImpl) SourceTimeout() any {
	return s.SourceTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s *StreamInputV4lImpl) SetSourceTimeout(v any) StreamInputV4l {
	if s == nil {
		return nil
	}
	s.SourceTimeoutValue = v
	return s
}

// Detailed runtime information about the input.
func (s StreamInputV4lImpl) Stats() InputStats {
	return s.StatsValue
}

// Detailed runtime information about the input.
func (s *StreamInputV4lImpl) SetStats(v InputStats) StreamInputV4l {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s StreamInputV4lImpl) Timeout() *int {
	return s.TimeoutValue
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s *StreamInputV4lImpl) SetTimeout(v int) StreamInputV4l {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// This information is necessary for adding into the PMT table to identify streams which carry teletext data in the resulting MPEG-TS stream.
func (s StreamInputV4lImpl) TtxtDescriptors() []TtxtDescriptors {
	if s.TtxtDescriptorsValue == nil {
		return nil
	}
	result := make([]TtxtDescriptors, len(s.TtxtDescriptorsValue))
	for i, item := range s.TtxtDescriptorsValue {
		result[i] = item
	}
	return result
}

// This information is necessary for adding into the PMT table to identify streams which carry teletext data in the resulting MPEG-TS stream.
func (s *StreamInputV4lImpl) SetTtxtDescriptors(v []TtxtDescriptors) StreamInputV4l {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*TtxtDescriptorsImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*TtxtDescriptorsImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.TtxtDescriptorsValue = impl
	}
	return s
}

// URL to connect to the Video4Linux source and get the stream.
// Format: input_url (input_url)
// Pattern: ^(v4l|v4l2)://.*$
// Examples: v4l2://, v4l://
func (s StreamInputV4lImpl) URL() InputURL {
	return s.URLValue
}

// URL to connect to the Video4Linux source and get the stream.
// Format: input_url (input_url)
// Pattern: ^(v4l|v4l2)://.*$
// Examples: v4l2://, v4l://
func (s *StreamInputV4lImpl) SetURL(v InputURL) StreamInputV4l {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// User agent. Can be modified if a protocol allows it.
func (s StreamInputV4lImpl) UserAgent() *string {
	return s.UserAgentValue
}

// User agent. Can be modified if a protocol allows it.
func (s *StreamInputV4lImpl) SetUserAgent(v string) StreamInputV4l {
	if s == nil {
		return nil
	}
	s.UserAgentValue = &v
	return s
}

// This parameter allows logging the decoded data when reading teletext from VBI.
func (s StreamInputV4lImpl) VbiDebug() *bool {
	return s.VbiDebugValue
}

// This parameter allows logging the decoded data when reading teletext from VBI.
func (s *StreamInputV4lImpl) SetVbiDebug(v bool) StreamInputV4l {
	if s == nil {
		return nil
	}
	s.VbiDebugValue = &v
	return s
}

// The VBI device to capture raw VBI data from Stream Labs SDI cards. VBI data can contain information about teletext or closed captions.
// It is actually a path to a VBI device file created on the disk by Video4Linux.
// Example: /dev/vbi
func (s StreamInputV4lImpl) VbiDevice() *string {
	return s.VbiDeviceValue
}

// The VBI device to capture raw VBI data from Stream Labs SDI cards. VBI data can contain information about teletext or closed captions.
// It is actually a path to a VBI device file created on the disk by Video4Linux.
// Example: /dev/vbi
func (s *StreamInputV4lImpl) SetVbiDevice(v string) StreamInputV4l {
	if s == nil {
		return nil
	}
	s.VbiDeviceValue = &v
	return s
}

// This parameter is used for debugging when reading teletext from VBI.
// This is a threshold, in seconds, for turning on the decoder.
func (s StreamInputV4lImpl) VbiThreshold() *int {
	return s.VbiThresholdValue
}

// This parameter is used for debugging when reading teletext from VBI.
// This is a threshold, in seconds, for turning on the decoder.
func (s *StreamInputV4lImpl) SetVbiThreshold(v int) StreamInputV4l {
	if s == nil {
		return nil
	}
	s.VbiThresholdValue = &v
	return s
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s StreamInputV4lImpl) Via() *AgentURL {
	return s.ViaValue
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s *StreamInputV4lImpl) SetVia(v AgentURL) StreamInputV4l {
	if s == nil {
		return nil
	}
	s.ViaValue = &v
	return s
}

// The video device to capture video from Stream Labs SDI cards.
// It is actually a path to a device file created on the disk by Video4Linux.
// Example: /dev/video0
func (s StreamInputV4lImpl) VideoDevice() *string {
	return s.VideoDeviceValue
}

// The video device to capture video from Stream Labs SDI cards.
// It is actually a path to a device file created on the disk by Video4Linux.
// Example: /dev/video0
func (s *StreamInputV4lImpl) SetVideoDevice(v string) StreamInputV4l {
	if s == nil {
		return nil
	}
	s.VideoDeviceValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputV4lImpl) VideoTimeout() *Seconds {
	return s.VideoTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputV4lImpl) SetVideoTimeout(v Seconds) StreamInputV4l {
	if s == nil {
		return nil
	}
	s.VideoTimeoutValue = &v
	return s
}

// NewStreamInputWebrtcPublishSpecific creates a new StreamInputWebrtcPublishSpecific instance
func NewStreamInputWebrtcPublishSpecific() StreamInputWebrtcPublishSpecific {
	return &StreamInputWebrtcPublishSpecificImpl{}
}

// The correction between the target bitrate (Receiver Estimated Maximum Bitrate, calculated in Flussonic) and browser bitrate, in kbit/s.
// Flussonic sends the target bitrate to the browser from which the publication is carried out so that the browser adjusts the bitrate of the publication by this value.
// The default value is 300 kbit/s.
// Example: 200
func (s StreamInputWebrtcPublishSpecificImpl) AbrCorrection() *int {
	return s.AbrCorrectionValue
}

// The correction between the target bitrate (Receiver Estimated Maximum Bitrate, calculated in Flussonic) and browser bitrate, in kbit/s.
// Flussonic sends the target bitrate to the browser from which the publication is carried out so that the browser adjusts the bitrate of the publication by this value.
// The default value is 300 kbit/s.
// Example: 200
func (s *StreamInputWebrtcPublishSpecificImpl) SetAbrCorrection(v int) StreamInputWebrtcPublishSpecific {
	if s == nil {
		return nil
	}
	s.AbrCorrectionValue = &v
	return s
}

// The number of cycles of bitrate auto-adjustment.
// After the specified number of auto-adjustment cycles passes, Flussonic considers the bitrate to be optimal, and it is no longer analyzed.
// By default, `abr_cycles`=5.
// If `abr_cycles`=0, the adjustment process takes place all the time while the publication lasts.
// Example: 3
func (s StreamInputWebrtcPublishSpecificImpl) AbrCycles() *int {
	return s.AbrCyclesValue
}

// The number of cycles of bitrate auto-adjustment.
// After the specified number of auto-adjustment cycles passes, Flussonic considers the bitrate to be optimal, and it is no longer analyzed.
// By default, `abr_cycles`=5.
// If `abr_cycles`=0, the adjustment process takes place all the time while the publication lasts.
// Example: 3
func (s *StreamInputWebrtcPublishSpecificImpl) SetAbrCycles(v int) StreamInputWebrtcPublishSpecific {
	if s == nil {
		return nil
	}
	s.AbrCyclesValue = &v
	return s
}

// Whether adaptive bitrate process is logged.
// Example: 1
func (s StreamInputWebrtcPublishSpecificImpl) AbrDebug() *int {
	return s.AbrDebugValue
}

// Whether adaptive bitrate process is logged.
// Example: 1
func (s *StreamInputWebrtcPublishSpecificImpl) SetAbrDebug(v int) StreamInputWebrtcPublishSpecific {
	if s == nil {
		return nil
	}
	s.AbrDebugValue = &v
	return s
}

// The lower limit of packet loss. When it is reached, Flussonic raises the bitrate.
// That is, if packet loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup` percent.
// Example: 2
func (s StreamInputWebrtcPublishSpecificImpl) AbrLossLower() *float64 {
	return s.AbrLossLowerValue
}

// The lower limit of packet loss. When it is reached, Flussonic raises the bitrate.
// That is, if packet loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup` percent.
// Example: 2
func (s *StreamInputWebrtcPublishSpecificImpl) SetAbrLossLower(v float64) StreamInputWebrtcPublishSpecific {
	if s == nil {
		return nil
	}
	s.AbrLossLowerValue = &v
	return s
}

// The upper limit of packet loss. When it is reached, Flussonic reduces the bitrate.
// That is, if packet loss is greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.
// Example: 10
func (s StreamInputWebrtcPublishSpecificImpl) AbrLossUpper() *float64 {
	return s.AbrLossUpperValue
}

// The upper limit of packet loss. When it is reached, Flussonic reduces the bitrate.
// That is, if packet loss is greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.
// Example: 10
func (s *StreamInputWebrtcPublishSpecificImpl) SetAbrLossUpper(v float64) StreamInputWebrtcPublishSpecific {
	if s == nil {
		return nil
	}
	s.AbrLossUpperValue = &v
	return s
}

// Maximum bitrate for adjustment process, in kbit/s.
// Flussonic will keep the publication bitrate equal or below of the specified value.
// Example: 1000
func (s StreamInputWebrtcPublishSpecificImpl) AbrMaxBitrate() *int {
	return s.AbrMaxBitrateValue
}

// Maximum bitrate for adjustment process, in kbit/s.
// Flussonic will keep the publication bitrate equal or below of the specified value.
// Example: 1000
func (s *StreamInputWebrtcPublishSpecificImpl) SetAbrMaxBitrate(v int) StreamInputWebrtcPublishSpecific {
	if s == nil {
		return nil
	}
	s.AbrMaxBitrateValue = &v
	return s
}

// The algorithm for determining the need to change the bitrate of the published stream and for calculating the target bitrate.
// Two options are possible:
// * `abr_mode=0` - This mode takes into account the packet losses, target bitrate, browser bitrate and the number of auto-adjustment cycles.
// * `abr_mode=1` - This mode considers only packet losses and target bitrate.
// Example: 1
func (s StreamInputWebrtcPublishSpecificImpl) AbrMode() *int {
	return s.AbrModeValue
}

// The algorithm for determining the need to change the bitrate of the published stream and for calculating the target bitrate.
// Two options are possible:
// * `abr_mode=0` - This mode takes into account the packet losses, target bitrate, browser bitrate and the number of auto-adjustment cycles.
// * `abr_mode=1` - This mode considers only packet losses and target bitrate.
// Example: 1
func (s *StreamInputWebrtcPublishSpecificImpl) SetAbrMode(v int) StreamInputWebrtcPublishSpecific {
	if s == nil {
		return nil
	}
	s.AbrModeValue = &v
	return s
}

// A step of reducing the bitrate to the minimum.
// If packet losses are greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.
func (s StreamInputWebrtcPublishSpecificImpl) AbrStepdown() *float64 {
	return s.AbrStepdownValue
}

// A step of reducing the bitrate to the minimum.
// If packet losses are greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.
func (s *StreamInputWebrtcPublishSpecificImpl) SetAbrStepdown(v float64) StreamInputWebrtcPublishSpecific {
	if s == nil {
		return nil
	}
	s.AbrStepdownValue = &v
	return s
}

// Increment step for raising the bitrate to the maximum, in percent. The default step is 30%.
// If the loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup percent`.
func (s StreamInputWebrtcPublishSpecificImpl) AbrStepup() *int {
	return s.AbrStepupValue
}

// Increment step for raising the bitrate to the maximum, in percent. The default step is 30%.
// If the loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup percent`.
func (s *StreamInputWebrtcPublishSpecificImpl) SetAbrStepup(v int) StreamInputWebrtcPublishSpecific {
	if s == nil {
		return nil
	}
	s.AbrStepupValue = &v
	return s
}

// The minimum bitrate threshold, in kbit/s. The default value is 100 kbit/s.
// Example: 150
func (s StreamInputWebrtcPublishSpecificImpl) MinBitrate() *int {
	return s.MinBitrateValue
}

// The minimum bitrate threshold, in kbit/s. The default value is 100 kbit/s.
// Example: 150
func (s *StreamInputWebrtcPublishSpecificImpl) SetMinBitrate(v int) StreamInputWebrtcPublishSpecific {
	if s == nil {
		return nil
	}
	s.MinBitrateValue = &v
	return s
}

// Deprecated field. Will be deleted at 24.11
// Choose one of the listed video codecs at the start of the publication via WebRTC.
// Example: av1
func (s StreamInputWebrtcPublishSpecificImpl) PreferCodec() *WebrtcPreferVideoCodec {
	return s.PreferCodecValue
}

// Deprecated field. Will be deleted at 24.11
// Choose one of the listed video codecs at the start of the publication via WebRTC.
// Example: av1
func (s *StreamInputWebrtcPublishSpecificImpl) SetPreferCodec(v WebrtcPreferVideoCodec) StreamInputWebrtcPublishSpecific {
	if s == nil {
		return nil
	}
	s.PreferCodecValue = &v
	return s
}

// Prefer one of the listed video codecs at the start of the publication via WebRTC.
// Example: av1
func (s StreamInputWebrtcPublishSpecificImpl) PreferVideoCodec() *WebrtcPreferVideoCodec {
	return s.PreferVideoCodecValue
}

// Prefer one of the listed video codecs at the start of the publication via WebRTC.
// Example: av1
func (s *StreamInputWebrtcPublishSpecificImpl) SetPreferVideoCodec(v WebrtcPreferVideoCodec) StreamInputWebrtcPublishSpecific {
	if s == nil {
		return nil
	}
	s.PreferVideoCodecValue = &v
	return s
}

// Choose the prefered transport of the publication via WebRTC: UDP or TCP.
// Example: udp
func (s StreamInputWebrtcPublishSpecificImpl) Transport() *WebrtcTransport {
	return s.TransportValue
}

// Choose the prefered transport of the publication via WebRTC: UDP or TCP.
// Example: udp
func (s *StreamInputWebrtcPublishSpecificImpl) SetTransport(v WebrtcTransport) StreamInputWebrtcPublishSpecific {
	if s == nil {
		return nil
	}
	s.TransportValue = &v
	return s
}

// Whether the adaptive bitrate mechanism is used for WebRTC publications.
// Example: true
func (s StreamInputWebrtcPublishSpecificImpl) WebrtcAbr() *bool {
	return s.WebrtcAbrValue
}

// Whether the adaptive bitrate mechanism is used for WebRTC publications.
// Example: true
func (s *StreamInputWebrtcPublishSpecificImpl) SetWebrtcAbr(v bool) StreamInputWebrtcPublishSpecific {
	if s == nil {
		return nil
	}
	s.WebrtcAbrValue = &v
	return s
}

// NewStreamPush creates a new StreamPush instance
func NewStreamPush() StreamPush {
	return &StreamPushImpl{}
}

// The bitrate of the whole stream.
// Format: speed (speed)
// Example: 3200
func (s StreamPushImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// The bitrate of the whole stream.
// Format: speed (speed)
// Example: 3200
func (s *StreamPushImpl) SetBitrate(v Speed) StreamPush {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// Human-readable description of the pusher.
// Example: This is a test push
func (s StreamPushImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the pusher.
// Example: This is a test push
func (s *StreamPushImpl) SetComment(v string) StreamPush {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Connection timeout, in seconds. Equals to 0 by default.
// Format: seconds (seconds)
// Example: 2
func (s StreamPushImpl) ConnectTimeout() *Seconds {
	return s.ConnectTimeoutValue
}

// Connection timeout, in seconds. Equals to 0 by default.
// Format: seconds (seconds)
// Example: 2
func (s *StreamPushImpl) SetConnectTimeout(v Seconds) StreamPush {
	if s == nil {
		return nil
	}
	s.ConnectTimeoutValue = &v
	return s
}

// Activate deinterlacing, i.e., converting an interlaced image to a progressive image.
// It is necessary for comfortable viewing of legacy TV video on PC/mobile devices.
func (s StreamPushImpl) Deinterlace() *bool {
	return s.DeinterlaceValue
}

// Activate deinterlacing, i.e., converting an interlaced image to a progressive image.
// It is necessary for comfortable viewing of legacy TV video on PC/mobile devices.
func (s *StreamPushImpl) SetDeinterlace(v bool) StreamPush {
	if s == nil {
		return nil
	}
	s.DeinterlaceValue = &v
	return s
}

// Disable pushing the stream.
// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
// In this way, the URL and other settings of a disabled stream remain in Flussonic.
func (s StreamPushImpl) Disabled() *bool {
	return s.DisabledValue
}

// Disable pushing the stream.
// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
// In this way, the URL and other settings of a disabled stream remain in Flussonic.
func (s *StreamPushImpl) SetDisabled(v bool) StreamPush {
	if s == nil {
		return nil
	}
	s.DisabledValue = &v
	return s
}

// Defines a number of threads in a decoder.
// One thread uses one core.
// The default value equals 4, but you can set it equal to the number of cores of your CPU.
func (s StreamPushImpl) Dthreads() *int {
	return s.DthreadsValue
}

// Defines a number of threads in a decoder.
// One thread uses one core.
// The default value equals 4, but you can set it equal to the number of cores of your CPU.
func (s *StreamPushImpl) SetDthreads(v int) StreamPush {
	if s == nil {
		return nil
	}
	s.DthreadsValue = &v
	return s
}

// Whether both connection parties must have the same password set (including empty, in other words, with no encryption).
// If the passwords do not match or only one side is unencrypted, the connection is rejected.
// The default value is `true`.
// Example: true
func (s StreamPushImpl) Enforcedencryption() *bool {
	return s.EnforcedencryptionValue
}

// Whether both connection parties must have the same password set (including empty, in other words, with no encryption).
// If the passwords do not match or only one side is unencrypted, the connection is rejected.
// The default value is `true`.
// Example: true
func (s *StreamPushImpl) SetEnforcedencryption(v bool) StreamPush {
	if s == nil {
		return nil
	}
	s.EnforcedencryptionValue = &v
	return s
}

// Enable clock-lock feature (if supported). See also genlock_status property in pusher stats.
func (s StreamPushImpl) Genlock() *bool {
	return s.GenlockValue
}

// Enable clock-lock feature (if supported). See also genlock_status property in pusher stats.
func (s *StreamPushImpl) SetGenlock(v bool) StreamPush {
	if s == nil {
		return nil
	}
	s.GenlockValue = &v
	return s
}

// The latency value for both directions of the socket.
// By default initial value latency is 0 when transmitting and 120ms when receiving video.
// Actual value established after connection handshake.
// Increased value helps tolerate network losses and delays.
// Format: milliseconds (milliseconds)
// Example: 150
func (s StreamPushImpl) Latency() *Milliseconds {
	return s.LatencyValue
}

// The latency value for both directions of the socket.
// By default initial value latency is 0 when transmitting and 120ms when receiving video.
// Actual value established after connection handshake.
// Increased value helps tolerate network losses and delays.
// Format: milliseconds (milliseconds)
// Example: 150
func (s *StreamPushImpl) SetLatency(v Milliseconds) StreamPush {
	if s == nil {
		return nil
	}
	s.LatencyValue = &v
	return s
}

// The time, in seconds, that the socket waits for the unsent data before closing.
// The default value is 180.
// Format: seconds (seconds)
// Example: 15
func (s StreamPushImpl) Linger() *Seconds {
	return s.LingerValue
}

// The time, in seconds, that the socket waits for the unsent data before closing.
// The default value is 180.
// Format: seconds (seconds)
// Example: 15
func (s *StreamPushImpl) SetLinger(v Seconds) StreamPush {
	if s == nil {
		return nil
	}
	s.LingerValue = &v
	return s
}

// The minimum SRT version that is required from the peer for SRT publication.
// Pattern: ^[0-9]+\.[0-9]+\.[0-9]+$
// Example: 1.1.0
func (s StreamPushImpl) Minversion() *string {
	return s.MinversionValue
}

// The minimum SRT version that is required from the peer for SRT publication.
// Pattern: ^[0-9]+\.[0-9]+\.[0-9]+$
// Example: 1.1.0
func (s *StreamPushImpl) SetMinversion(v string) StreamPush {
	if s == nil {
		return nil
	}
	s.MinversionValue = &v
	return s
}

// It allows to specify pack information about ac3 for outgoing MPEGTS-TS streams. The default value is `system_b`.
func (s StreamPushImpl) MpegtsAc3() *OutputMpegtsAc3 {
	return s.MpegtsAc3Value
}

// It allows to specify pack information about ac3 for outgoing MPEGTS-TS streams. The default value is `system_b`.
func (s *StreamPushImpl) SetMpegtsAc3(v OutputMpegtsAc3) StreamPush {
	if s == nil {
		return nil
	}
	s.MpegtsAc3Value = &v
	return s
}

// Whether to capture multicast back to the *Flussonic* host.
// This option allows you to ingest the sent stream on the sending host by *Flussonic* or other application.
// Set to `True` for a UDP MPEG-TS push.
// Example: true
func (s StreamPushImpl) MulticastLoop() *bool {
	return s.MulticastLoopValue
}

// Whether to capture multicast back to the *Flussonic* host.
// This option allows you to ingest the sent stream on the sending host by *Flussonic* or other application.
// Set to `True` for a UDP MPEG-TS push.
// Example: true
func (s *StreamPushImpl) SetMulticastLoop(v bool) StreamPush {
	if s == nil {
		return nil
	}
	s.MulticastLoopValue = &v
	return s
}

// The password for the encrypted transmission.
// Its length should be not less than 10 and not more than 79 characters.
// Unlike [password](https://flussonic.com/doc/api/reference/#tag/stream/operation/stream_save%7Cbody%7Cpassword),
// the passphrase is not transmitted openly but is used to encrypt the key that is transmitted by the Caller
// and decoded by Listener.
// Example: 9876543210
func (s StreamPushImpl) Passphrase() *string {
	return s.PassphraseValue
}

// The password for the encrypted transmission.
// Its length should be not less than 10 and not more than 79 characters.
// Unlike [password](https://flussonic.com/doc/api/reference/#tag/stream/operation/stream_save%7Cbody%7Cpassword),
// the passphrase is not transmitted openly but is used to encrypt the key that is transmitted by the Caller
// and decoded by Listener.
// Example: 9876543210
func (s *StreamPushImpl) SetPassphrase(v string) StreamPush {
	if s == nil {
		return nil
	}
	s.PassphraseValue = &v
	return s
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// It is possible to set PID values for PMT, STD and video and audio tracks.
func (s StreamPushImpl) Pids() OutputMpegtsPids {
	return s.PidsValue
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// It is possible to set PID values for PMT, STD and video and audio tracks.
func (s *StreamPushImpl) SetPids(v OutputMpegtsPids) StreamPush {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*OutputMpegtsPidsImpl); ok {
		s.PidsValue = impl
	}
	return s
}

// Adjusting genlock timing pixel offset.
func (s StreamPushImpl) PixelOffset() *int {
	return s.PixelOffsetValue
}

// Adjusting genlock timing pixel offset.
func (s *StreamPushImpl) SetPixelOffset(v int) StreamPush {
	if s == nil {
		return nil
	}
	s.PixelOffsetValue = &v
	return s
}

// Program number in the outgoing MPEG-TS stream. A program may represent a television channel.
func (s StreamPushImpl) Pnr() *int {
	return s.PnrValue
}

// Program number in the outgoing MPEG-TS stream. A program may represent a television channel.
func (s *StreamPushImpl) SetPnr(v int) StreamPush {
	if s == nil {
		return nil
	}
	s.PnrValue = &v
	return s
}

// Provider name. Used to fill in the field service provider within SDT MPEG-TS table.
// Example: My provider name
func (s StreamPushImpl) Provider() *string {
	return s.ProviderValue
}

// Provider name. Used to fill in the field service provider within SDT MPEG-TS table.
// Example: My provider name
func (s *StreamPushImpl) SetProvider(v string) StreamPush {
	if s == nil {
		return nil
	}
	s.ProviderValue = &v
	return s
}

// The maximum number of times *Flussonic* retries to push the stream.
func (s StreamPushImpl) RetryLimit() *int {
	return s.RetryLimitValue
}

// The maximum number of times *Flussonic* retries to push the stream.
func (s *StreamPushImpl) SetRetryLimit(v int) StreamPush {
	if s == nil {
		return nil
	}
	s.RetryLimitValue = &v
	return s
}

// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
// It is an interval in seconds, 5 seconds by default.
// You can increase this value to reduce server load.
// Format: seconds (seconds)
// Example: 7
func (s StreamPushImpl) RetryTimeout() *Seconds {
	return s.RetryTimeoutValue
}

// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
// It is an interval in seconds, 5 seconds by default.
// You can increase this value to reduce server load.
// Format: seconds (seconds)
// Example: 7
func (s *StreamPushImpl) SetRetryTimeout(v Seconds) StreamPush {
	if s == nil {
		return nil
	}
	s.RetryTimeoutValue = &v
	return s
}

// Defines a scaling algorithm.
// You can choose only one algorithm at a time.
// If a pushing stream has the same video resolution as an ingest stream, the `fast_bilinear` algorithm is used by default.
// If a video resolution of a pushing stream does not equal the video resolution of an ingest stream, the bicubic algorithm is used by default.
// If the algorithm is specified explicitly, it applies to all the formats.
func (s StreamPushImpl) Scale() *ScaleAlgorithm {
	return s.ScaleValue
}

// Defines a scaling algorithm.
// You can choose only one algorithm at a time.
// If a pushing stream has the same video resolution as an ingest stream, the `fast_bilinear` algorithm is used by default.
// If a video resolution of a pushing stream does not equal the video resolution of an ingest stream, the bicubic algorithm is used by default.
// If the algorithm is specified explicitly, it applies to all the formats.
func (s *StreamPushImpl) SetScale(v ScaleAlgorithm) StreamPush {
	if s == nil {
		return nil
	}
	s.ScaleValue = &v
	return s
}

// Service name. Used to fill in the field service name within SDT MPEG-TS table.
// Example: My service name
func (s StreamPushImpl) Service() *string {
	return s.ServiceValue
}

// Service name. Used to fill in the field service name within SDT MPEG-TS table.
// Example: My service name
func (s *StreamPushImpl) SetService(v string) StreamPush {
	if s == nil {
		return nil
	}
	s.ServiceValue = &v
	return s
}

// Monitoring multicast group and stop pushing if another publisher presented
func (s StreamPushImpl) Standby() *bool {
	return s.StandbyValue
}

// Monitoring multicast group and stop pushing if another publisher presented
func (s *StreamPushImpl) SetStandby(v bool) StreamPush {
	if s == nil {
		return nil
	}
	s.StandbyValue = &v
	return s
}

// Detailed runtime information about the push.
func (s StreamPushImpl) Stats() PushCounters {
	return s.StatsValue
}

// Detailed runtime information about the push.
func (s *StreamPushImpl) SetStats(v PushCounters) StreamPush {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*PushCountersImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// A string of maximum 512 characters set on the socket before the connection.
// This string is a part of a callback that is sent by the caller and regisered by the listener.
// Based on this information the listener can accept or reject the connection, select the desired data stream, or set an appropriate passphrase for the connection.
// Its format is `#!::` optionally followed by the parameters:
// * `r=` - stream name
// * `m=` - mode expected for the connection: `publish` (if the caller wants to send the stream data) or `request` (if the caller wants to receive the stream).
// * `password=` - a password for the authorization in a publish session (not recommended, better use `passphrase` option instead)
// During SRT sessions the following parameters are automaticly added to streamid:
// * `s=` - the identifier of a session
// * `a=` - Flussonic version
// NOTE: you can specify a string in the format you need; to disable this extension, you need specify empty string.
// Example: #!::r=my-stream,m=publish
func (s StreamPushImpl) Streamid() *string {
	return s.StreamidValue
}

// A string of maximum 512 characters set on the socket before the connection.
// This string is a part of a callback that is sent by the caller and regisered by the listener.
// Based on this information the listener can accept or reject the connection, select the desired data stream, or set an appropriate passphrase for the connection.
// Its format is `#!::` optionally followed by the parameters:
// * `r=` - stream name
// * `m=` - mode expected for the connection: `publish` (if the caller wants to send the stream data) or `request` (if the caller wants to receive the stream).
// * `password=` - a password for the authorization in a publish session (not recommended, better use `passphrase` option instead)
// During SRT sessions the following parameters are automaticly added to streamid:
// * `s=` - the identifier of a session
// * `a=` - Flussonic version
// NOTE: you can specify a string in the format you need; to disable this extension, you need specify empty string.
// Example: #!::r=my-stream,m=publish
func (s *StreamPushImpl) SetStreamid(v string) StreamPush {
	if s == nil {
		return nil
	}
	s.StreamidValue = &v
	return s
}

// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
// Format: seconds (seconds)
// Example: 10
func (s StreamPushImpl) Timeout() *Seconds {
	return s.TimeoutValue
}

// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
// Format: seconds (seconds)
// Example: 10
func (s *StreamPushImpl) SetTimeout(v Seconds) StreamPush {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// UDP URL of multicast group
// /Another Flussonic URL where to push video to.
// /Flussonic stream URL where to push to.
// /Specify Blackmagic Decklink SDI card as a destination for this stream.
// You need to specify exact number of output, refer to decklink manual to find
// enumeration rules.
// /Select which Dektec SDI card to use as a sink for this stream.
// Dektec url is combined of card serial # and number of output port on this card.
// Output ports on a card are numbered starting from 1.
// Serial numbers are uniq for each produced card. Take a look at admin UI or use
// native dektec tools to find the serial number.
// /Select which Dektec ASI card to use as a sink for this stream.
// Dektec url is combined of card serial # and number of output port on this card.
// Output ports on a card are numbered starting from 1.
// Serial numbers are uniq for each produced card. Take a look at admin UI or use
// native dektec tools to find the serial number.
// Mention that ASI is a MPEG-TS transport
// /Content will be similar to multicast MPEG-TS, but endless HTTP POST will be used to upload content.
// /It is possible to publish HLS to a CDN. Segments will be uploaded together with manifests.
// /SRT URL where to push video.
// /The URL allows you to set the name of the NDI source being created.
func (s StreamPushImpl) URL() InputURL {
	return s.URLValue
}

// UDP URL of multicast group
// /Another Flussonic URL where to push video to.
// /Flussonic stream URL where to push to.
// /Specify Blackmagic Decklink SDI card as a destination for this stream.
// You need to specify exact number of output, refer to decklink manual to find
// enumeration rules.
// /Select which Dektec SDI card to use as a sink for this stream.
// Dektec url is combined of card serial # and number of output port on this card.
// Output ports on a card are numbered starting from 1.
// Serial numbers are uniq for each produced card. Take a look at admin UI or use
// native dektec tools to find the serial number.
// /Select which Dektec ASI card to use as a sink for this stream.
// Dektec url is combined of card serial # and number of output port on this card.
// Output ports on a card are numbered starting from 1.
// Serial numbers are uniq for each produced card. Take a look at admin UI or use
// native dektec tools to find the serial number.
// Mention that ASI is a MPEG-TS transport
// /Content will be similar to multicast MPEG-TS, but endless HTTP POST will be used to upload content.
// /It is possible to publish HLS to a CDN. Segments will be uploaded together with manifests.
// /SRT URL where to push video.
// /The URL allows you to set the name of the NDI source being created.
func (s *StreamPushImpl) SetURL(v InputURL) StreamPush {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// Average bitrate per second that you can send of a video track, including all the headers and encapsulation in the transport stream.
// So, for example, the value of vb=2720 approximately corresponds to the bitrate 2600 specified in the transcoder settings.
// Format: speed (speed)
// Example: 2720
func (s StreamPushImpl) Vb() *Speed {
	return s.VbValue
}

// Average bitrate per second that you can send of a video track, including all the headers and encapsulation in the transport stream.
// So, for example, the value of vb=2720 approximately corresponds to the bitrate 2600 specified in the transcoder settings.
// Format: speed (speed)
// Example: 2720
func (s *StreamPushImpl) SetVb(v Speed) StreamPush {
	if s == nil {
		return nil
	}
	s.VbValue = &v
	return s
}

// Lines of VBI (vertical blanking interval) of an output analog stream that will contain teletext.
// It is used for passing teletext from MPEG-TS to analog streams.
func (s StreamPushImpl) VbiLines() []VbiLines {
	if s.VbiLinesValue == nil {
		return nil
	}
	result := make([]VbiLines, len(s.VbiLinesValue))
	for i, item := range s.VbiLinesValue {
		result[i] = item
	}
	return result
}

// Lines of VBI (vertical blanking interval) of an output analog stream that will contain teletext.
// It is used for passing teletext from MPEG-TS to analog streams.
func (s *StreamPushImpl) SetVbiLines(v []VbiLines) StreamPush {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*VbiLinesImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*VbiLinesImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.VbiLinesValue = impl
	}
	return s
}

// Required SRT version.
// Pattern: ^[0-9]+\.[0-9]+\.[0-9]+$
// Example: 1.3.0
func (s StreamPushImpl) Version() *string {
	return s.VersionValue
}

// Required SRT version.
// Pattern: ^[0-9]+\.[0-9]+\.[0-9]+$
// Example: 1.3.0
func (s *StreamPushImpl) SetVersion(v string) StreamPush {
	if s == nil {
		return nil
	}
	s.VersionValue = &v
	return s
}

// Specify SDI/HDMI output format
func (s StreamPushImpl) VideoFormat() *string {
	return s.VideoFormatValue
}

// Specify SDI/HDMI output format
func (s *StreamPushImpl) SetVideoFormat(v string) StreamPush {
	if s == nil {
		return nil
	}
	s.VideoFormatValue = &v
	return s
}

// Audio volume coefficient.
// The output audio volume is given by the relation: `output_volume = volume * input_volume`.
// The maximum volume value is 1.0 (default value).
// Example: 0.5
func (s StreamPushImpl) Volume() *float64 {
	return s.VolumeValue
}

// Audio volume coefficient.
// The output audio volume is given by the relation: `output_volume = volume * input_volume`.
// The maximum volume value is 1.0 (default value).
// Example: 0.5
func (s *StreamPushImpl) SetVolume(v float64) StreamPush {
	if s == nil {
		return nil
	}
	s.VolumeValue = &v
	return s
}

// NewStreamPushBase creates a new StreamPushBase instance
func NewStreamPushBase() StreamPushBase {
	return &StreamPushBaseImpl{}
}

// Human-readable description of the pusher.
// Example: This is a test push
func (s StreamPushBaseImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the pusher.
// Example: This is a test push
func (s *StreamPushBaseImpl) SetComment(v string) StreamPushBase {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Connection timeout, in seconds. Equals to 0 by default.
// Format: seconds (seconds)
// Example: 2
func (s StreamPushBaseImpl) ConnectTimeout() *Seconds {
	return s.ConnectTimeoutValue
}

// Connection timeout, in seconds. Equals to 0 by default.
// Format: seconds (seconds)
// Example: 2
func (s *StreamPushBaseImpl) SetConnectTimeout(v Seconds) StreamPushBase {
	if s == nil {
		return nil
	}
	s.ConnectTimeoutValue = &v
	return s
}

// Disable pushing the stream.
// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
// In this way, the URL and other settings of a disabled stream remain in Flussonic.
func (s StreamPushBaseImpl) Disabled() *bool {
	return s.DisabledValue
}

// Disable pushing the stream.
// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
// In this way, the URL and other settings of a disabled stream remain in Flussonic.
func (s *StreamPushBaseImpl) SetDisabled(v bool) StreamPushBase {
	if s == nil {
		return nil
	}
	s.DisabledValue = &v
	return s
}

// The maximum number of times *Flussonic* retries to push the stream.
func (s StreamPushBaseImpl) RetryLimit() *int {
	return s.RetryLimitValue
}

// The maximum number of times *Flussonic* retries to push the stream.
func (s *StreamPushBaseImpl) SetRetryLimit(v int) StreamPushBase {
	if s == nil {
		return nil
	}
	s.RetryLimitValue = &v
	return s
}

// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
// It is an interval in seconds, 5 seconds by default.
// You can increase this value to reduce server load.
// Format: seconds (seconds)
// Example: 7
func (s StreamPushBaseImpl) RetryTimeout() *Seconds {
	return s.RetryTimeoutValue
}

// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
// It is an interval in seconds, 5 seconds by default.
// You can increase this value to reduce server load.
// Format: seconds (seconds)
// Example: 7
func (s *StreamPushBaseImpl) SetRetryTimeout(v Seconds) StreamPushBase {
	if s == nil {
		return nil
	}
	s.RetryTimeoutValue = &v
	return s
}

// Detailed runtime information about the push.
func (s StreamPushBaseImpl) Stats() PushCounters {
	return s.StatsValue
}

// Detailed runtime information about the push.
func (s *StreamPushBaseImpl) SetStats(v PushCounters) StreamPushBase {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*PushCountersImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
// Format: seconds (seconds)
// Example: 10
func (s StreamPushBaseImpl) Timeout() *Seconds {
	return s.TimeoutValue
}

// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
// Format: seconds (seconds)
// Example: 10
func (s *StreamPushBaseImpl) SetTimeout(v Seconds) StreamPushBase {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// NewStreamPushDecklink creates a new StreamPushDecklink instance
func NewStreamPushDecklink() StreamPushDecklink {
	return &StreamPushDecklinkImpl{}
}

// Human-readable description of the pusher.
// Example: This is a test push
func (s StreamPushDecklinkImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the pusher.
// Example: This is a test push
func (s *StreamPushDecklinkImpl) SetComment(v string) StreamPushDecklink {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Connection timeout, in seconds. Equals to 0 by default.
// Format: seconds (seconds)
// Example: 2
func (s StreamPushDecklinkImpl) ConnectTimeout() *Seconds {
	return s.ConnectTimeoutValue
}

// Connection timeout, in seconds. Equals to 0 by default.
// Format: seconds (seconds)
// Example: 2
func (s *StreamPushDecklinkImpl) SetConnectTimeout(v Seconds) StreamPushDecklink {
	if s == nil {
		return nil
	}
	s.ConnectTimeoutValue = &v
	return s
}

// Activate deinterlacing, i.e., converting an interlaced image to a progressive image.
// It is necessary for comfortable viewing of legacy TV video on PC/mobile devices.
func (s StreamPushDecklinkImpl) Deinterlace() *bool {
	return s.DeinterlaceValue
}

// Activate deinterlacing, i.e., converting an interlaced image to a progressive image.
// It is necessary for comfortable viewing of legacy TV video on PC/mobile devices.
func (s *StreamPushDecklinkImpl) SetDeinterlace(v bool) StreamPushDecklink {
	if s == nil {
		return nil
	}
	s.DeinterlaceValue = &v
	return s
}

// Disable pushing the stream.
// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
// In this way, the URL and other settings of a disabled stream remain in Flussonic.
func (s StreamPushDecklinkImpl) Disabled() *bool {
	return s.DisabledValue
}

// Disable pushing the stream.
// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
// In this way, the URL and other settings of a disabled stream remain in Flussonic.
func (s *StreamPushDecklinkImpl) SetDisabled(v bool) StreamPushDecklink {
	if s == nil {
		return nil
	}
	s.DisabledValue = &v
	return s
}

// Defines a number of threads in a decoder.
// One thread uses one core.
// The default value equals 4, but you can set it equal to the number of cores of your CPU.
func (s StreamPushDecklinkImpl) Dthreads() *int {
	return s.DthreadsValue
}

// Defines a number of threads in a decoder.
// One thread uses one core.
// The default value equals 4, but you can set it equal to the number of cores of your CPU.
func (s *StreamPushDecklinkImpl) SetDthreads(v int) StreamPushDecklink {
	if s == nil {
		return nil
	}
	s.DthreadsValue = &v
	return s
}

// The maximum number of times *Flussonic* retries to push the stream.
func (s StreamPushDecklinkImpl) RetryLimit() *int {
	return s.RetryLimitValue
}

// The maximum number of times *Flussonic* retries to push the stream.
func (s *StreamPushDecklinkImpl) SetRetryLimit(v int) StreamPushDecklink {
	if s == nil {
		return nil
	}
	s.RetryLimitValue = &v
	return s
}

// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
// It is an interval in seconds, 5 seconds by default.
// You can increase this value to reduce server load.
// Format: seconds (seconds)
// Example: 7
func (s StreamPushDecklinkImpl) RetryTimeout() *Seconds {
	return s.RetryTimeoutValue
}

// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
// It is an interval in seconds, 5 seconds by default.
// You can increase this value to reduce server load.
// Format: seconds (seconds)
// Example: 7
func (s *StreamPushDecklinkImpl) SetRetryTimeout(v Seconds) StreamPushDecklink {
	if s == nil {
		return nil
	}
	s.RetryTimeoutValue = &v
	return s
}

// Defines a scaling algorithm.
// You can choose only one algorithm at a time.
// If a pushing stream has the same video resolution as an ingest stream, the `fast_bilinear` algorithm is used by default.
// If a video resolution of a pushing stream does not equal the video resolution of an ingest stream, the bicubic algorithm is used by default.
// If the algorithm is specified explicitly, it applies to all the formats.
func (s StreamPushDecklinkImpl) Scale() *ScaleAlgorithm {
	return s.ScaleValue
}

// Defines a scaling algorithm.
// You can choose only one algorithm at a time.
// If a pushing stream has the same video resolution as an ingest stream, the `fast_bilinear` algorithm is used by default.
// If a video resolution of a pushing stream does not equal the video resolution of an ingest stream, the bicubic algorithm is used by default.
// If the algorithm is specified explicitly, it applies to all the formats.
func (s *StreamPushDecklinkImpl) SetScale(v ScaleAlgorithm) StreamPushDecklink {
	if s == nil {
		return nil
	}
	s.ScaleValue = &v
	return s
}

// Detailed runtime information about the push.
func (s StreamPushDecklinkImpl) Stats() PushCounters {
	return s.StatsValue
}

// Detailed runtime information about the push.
func (s *StreamPushDecklinkImpl) SetStats(v PushCounters) StreamPushDecklink {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*PushCountersImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
// Format: seconds (seconds)
// Example: 10
func (s StreamPushDecklinkImpl) Timeout() *Seconds {
	return s.TimeoutValue
}

// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
// Format: seconds (seconds)
// Example: 10
func (s *StreamPushDecklinkImpl) SetTimeout(v Seconds) StreamPushDecklink {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// Specify Blackmagic Decklink SDI card as a destination for this stream.
// You need to specify exact number of output, refer to decklink manual to find
// enumeration rules.
// Format: input_url (input_url)
// Pattern: ^decklink://[0-9]+$
// Examples: decklink://0
func (s StreamPushDecklinkImpl) URL() InputURL {
	return s.URLValue
}

// Specify Blackmagic Decklink SDI card as a destination for this stream.
// You need to specify exact number of output, refer to decklink manual to find
// enumeration rules.
// Format: input_url (input_url)
// Pattern: ^decklink://[0-9]+$
// Examples: decklink://0
func (s *StreamPushDecklinkImpl) SetURL(v InputURL) StreamPushDecklink {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// Lines of VBI (vertical blanking interval) of an output analog stream that will contain teletext.
// It is used for passing teletext from MPEG-TS to analog streams.
func (s StreamPushDecklinkImpl) VbiLines() []VbiLines {
	if s.VbiLinesValue == nil {
		return nil
	}
	result := make([]VbiLines, len(s.VbiLinesValue))
	for i, item := range s.VbiLinesValue {
		result[i] = item
	}
	return result
}

// Lines of VBI (vertical blanking interval) of an output analog stream that will contain teletext.
// It is used for passing teletext from MPEG-TS to analog streams.
func (s *StreamPushDecklinkImpl) SetVbiLines(v []VbiLines) StreamPushDecklink {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*VbiLinesImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*VbiLinesImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.VbiLinesValue = impl
	}
	return s
}

// Specify SDI/HDMI output format
func (s StreamPushDecklinkImpl) VideoFormat() *string {
	return s.VideoFormatValue
}

// Specify SDI/HDMI output format
func (s *StreamPushDecklinkImpl) SetVideoFormat(v string) StreamPushDecklink {
	if s == nil {
		return nil
	}
	s.VideoFormatValue = &v
	return s
}

// Audio volume coefficient.
// The output audio volume is given by the relation: `output_volume = volume * input_volume`.
// The maximum volume value is 1.0 (default value).
// Example: 0.5
func (s StreamPushDecklinkImpl) Volume() *float64 {
	return s.VolumeValue
}

// Audio volume coefficient.
// The output audio volume is given by the relation: `output_volume = volume * input_volume`.
// The maximum volume value is 1.0 (default value).
// Example: 0.5
func (s *StreamPushDecklinkImpl) SetVolume(v float64) StreamPushDecklink {
	if s == nil {
		return nil
	}
	s.VolumeValue = &v
	return s
}

// NewStreamPushDektec creates a new StreamPushDektec instance
func NewStreamPushDektec() StreamPushDektec {
	return &StreamPushDektecImpl{}
}

// Human-readable description of the pusher.
// Example: This is a test push
func (s StreamPushDektecImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the pusher.
// Example: This is a test push
func (s *StreamPushDektecImpl) SetComment(v string) StreamPushDektec {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Connection timeout, in seconds. Equals to 0 by default.
// Format: seconds (seconds)
// Example: 2
func (s StreamPushDektecImpl) ConnectTimeout() *Seconds {
	return s.ConnectTimeoutValue
}

// Connection timeout, in seconds. Equals to 0 by default.
// Format: seconds (seconds)
// Example: 2
func (s *StreamPushDektecImpl) SetConnectTimeout(v Seconds) StreamPushDektec {
	if s == nil {
		return nil
	}
	s.ConnectTimeoutValue = &v
	return s
}

// Activate deinterlacing, i.e., converting an interlaced image to a progressive image.
// It is necessary for comfortable viewing of legacy TV video on PC/mobile devices.
func (s StreamPushDektecImpl) Deinterlace() *bool {
	return s.DeinterlaceValue
}

// Activate deinterlacing, i.e., converting an interlaced image to a progressive image.
// It is necessary for comfortable viewing of legacy TV video on PC/mobile devices.
func (s *StreamPushDektecImpl) SetDeinterlace(v bool) StreamPushDektec {
	if s == nil {
		return nil
	}
	s.DeinterlaceValue = &v
	return s
}

// Disable pushing the stream.
// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
// In this way, the URL and other settings of a disabled stream remain in Flussonic.
func (s StreamPushDektecImpl) Disabled() *bool {
	return s.DisabledValue
}

// Disable pushing the stream.
// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
// In this way, the URL and other settings of a disabled stream remain in Flussonic.
func (s *StreamPushDektecImpl) SetDisabled(v bool) StreamPushDektec {
	if s == nil {
		return nil
	}
	s.DisabledValue = &v
	return s
}

// Defines a number of threads in a decoder.
// One thread uses one core.
// The default value equals 4, but you can set it equal to the number of cores of your CPU.
func (s StreamPushDektecImpl) Dthreads() *int {
	return s.DthreadsValue
}

// Defines a number of threads in a decoder.
// One thread uses one core.
// The default value equals 4, but you can set it equal to the number of cores of your CPU.
func (s *StreamPushDektecImpl) SetDthreads(v int) StreamPushDektec {
	if s == nil {
		return nil
	}
	s.DthreadsValue = &v
	return s
}

// Enable clock-lock feature (if supported). See also genlock_status property in pusher stats.
func (s StreamPushDektecImpl) Genlock() *bool {
	return s.GenlockValue
}

// Enable clock-lock feature (if supported). See also genlock_status property in pusher stats.
func (s *StreamPushDektecImpl) SetGenlock(v bool) StreamPushDektec {
	if s == nil {
		return nil
	}
	s.GenlockValue = &v
	return s
}

// Adjusting genlock timing pixel offset.
func (s StreamPushDektecImpl) PixelOffset() *int {
	return s.PixelOffsetValue
}

// Adjusting genlock timing pixel offset.
func (s *StreamPushDektecImpl) SetPixelOffset(v int) StreamPushDektec {
	if s == nil {
		return nil
	}
	s.PixelOffsetValue = &v
	return s
}

// The maximum number of times *Flussonic* retries to push the stream.
func (s StreamPushDektecImpl) RetryLimit() *int {
	return s.RetryLimitValue
}

// The maximum number of times *Flussonic* retries to push the stream.
func (s *StreamPushDektecImpl) SetRetryLimit(v int) StreamPushDektec {
	if s == nil {
		return nil
	}
	s.RetryLimitValue = &v
	return s
}

// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
// It is an interval in seconds, 5 seconds by default.
// You can increase this value to reduce server load.
// Format: seconds (seconds)
// Example: 7
func (s StreamPushDektecImpl) RetryTimeout() *Seconds {
	return s.RetryTimeoutValue
}

// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
// It is an interval in seconds, 5 seconds by default.
// You can increase this value to reduce server load.
// Format: seconds (seconds)
// Example: 7
func (s *StreamPushDektecImpl) SetRetryTimeout(v Seconds) StreamPushDektec {
	if s == nil {
		return nil
	}
	s.RetryTimeoutValue = &v
	return s
}

// Defines a scaling algorithm.
// You can choose only one algorithm at a time.
// If a pushing stream has the same video resolution as an ingest stream, the `fast_bilinear` algorithm is used by default.
// If a video resolution of a pushing stream does not equal the video resolution of an ingest stream, the bicubic algorithm is used by default.
// If the algorithm is specified explicitly, it applies to all the formats.
func (s StreamPushDektecImpl) Scale() *ScaleAlgorithm {
	return s.ScaleValue
}

// Defines a scaling algorithm.
// You can choose only one algorithm at a time.
// If a pushing stream has the same video resolution as an ingest stream, the `fast_bilinear` algorithm is used by default.
// If a video resolution of a pushing stream does not equal the video resolution of an ingest stream, the bicubic algorithm is used by default.
// If the algorithm is specified explicitly, it applies to all the formats.
func (s *StreamPushDektecImpl) SetScale(v ScaleAlgorithm) StreamPushDektec {
	if s == nil {
		return nil
	}
	s.ScaleValue = &v
	return s
}

// Detailed runtime information about the push.
func (s StreamPushDektecImpl) Stats() PushCounters {
	return s.StatsValue
}

// Detailed runtime information about the push.
func (s *StreamPushDektecImpl) SetStats(v PushCounters) StreamPushDektec {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*PushCountersImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
// Format: seconds (seconds)
// Example: 10
func (s StreamPushDektecImpl) Timeout() *Seconds {
	return s.TimeoutValue
}

// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
// Format: seconds (seconds)
// Example: 10
func (s *StreamPushDektecImpl) SetTimeout(v Seconds) StreamPushDektec {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// Select which Dektec SDI card to use as a sink for this stream.
// Dektec url is combined of card serial # and number of output port on this card.
// Output ports on a card are numbered starting from 1.
// Serial numbers are uniq for each produced card. Take a look at admin UI or use
// native dektec tools to find the serial number.
// Format: input_url (input_url)
// Pattern: ^dektec://[0-9]+:[0-9]+$
// Examples: dektec://2174223350:1
func (s StreamPushDektecImpl) URL() InputURL {
	return s.URLValue
}

// Select which Dektec SDI card to use as a sink for this stream.
// Dektec url is combined of card serial # and number of output port on this card.
// Output ports on a card are numbered starting from 1.
// Serial numbers are uniq for each produced card. Take a look at admin UI or use
// native dektec tools to find the serial number.
// Format: input_url (input_url)
// Pattern: ^dektec://[0-9]+:[0-9]+$
// Examples: dektec://2174223350:1
func (s *StreamPushDektecImpl) SetURL(v InputURL) StreamPushDektec {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// Lines of VBI (vertical blanking interval) of an output analog stream that will contain teletext.
// It is used for passing teletext from MPEG-TS to analog streams.
func (s StreamPushDektecImpl) VbiLines() []VbiLines {
	if s.VbiLinesValue == nil {
		return nil
	}
	result := make([]VbiLines, len(s.VbiLinesValue))
	for i, item := range s.VbiLinesValue {
		result[i] = item
	}
	return result
}

// Lines of VBI (vertical blanking interval) of an output analog stream that will contain teletext.
// It is used for passing teletext from MPEG-TS to analog streams.
func (s *StreamPushDektecImpl) SetVbiLines(v []VbiLines) StreamPushDektec {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*VbiLinesImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*VbiLinesImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.VbiLinesValue = impl
	}
	return s
}

// Specify SDI/HDMI output format
func (s StreamPushDektecImpl) VideoFormat() *string {
	return s.VideoFormatValue
}

// Specify SDI/HDMI output format
func (s *StreamPushDektecImpl) SetVideoFormat(v string) StreamPushDektec {
	if s == nil {
		return nil
	}
	s.VideoFormatValue = &v
	return s
}

// Audio volume coefficient.
// The output audio volume is given by the relation: `output_volume = volume * input_volume`.
// The maximum volume value is 1.0 (default value).
// Example: 0.5
func (s StreamPushDektecImpl) Volume() *float64 {
	return s.VolumeValue
}

// Audio volume coefficient.
// The output audio volume is given by the relation: `output_volume = volume * input_volume`.
// The maximum volume value is 1.0 (default value).
// Example: 0.5
func (s *StreamPushDektecImpl) SetVolume(v float64) StreamPushDektec {
	if s == nil {
		return nil
	}
	s.VolumeValue = &v
	return s
}

// NewStreamPushDektecAsi creates a new StreamPushDektecAsi instance
func NewStreamPushDektecAsi() StreamPushDektecAsi {
	return &StreamPushDektecAsiImpl{}
}

// The bitrate of the whole stream.
// Format: speed (speed)
// Example: 3200
func (s StreamPushDektecAsiImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// The bitrate of the whole stream.
// Format: speed (speed)
// Example: 3200
func (s *StreamPushDektecAsiImpl) SetBitrate(v Speed) StreamPushDektecAsi {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// Human-readable description of the pusher.
// Example: This is a test push
func (s StreamPushDektecAsiImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the pusher.
// Example: This is a test push
func (s *StreamPushDektecAsiImpl) SetComment(v string) StreamPushDektecAsi {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Connection timeout, in seconds. Equals to 0 by default.
// Format: seconds (seconds)
// Example: 2
func (s StreamPushDektecAsiImpl) ConnectTimeout() *Seconds {
	return s.ConnectTimeoutValue
}

// Connection timeout, in seconds. Equals to 0 by default.
// Format: seconds (seconds)
// Example: 2
func (s *StreamPushDektecAsiImpl) SetConnectTimeout(v Seconds) StreamPushDektecAsi {
	if s == nil {
		return nil
	}
	s.ConnectTimeoutValue = &v
	return s
}

// Disable pushing the stream.
// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
// In this way, the URL and other settings of a disabled stream remain in Flussonic.
func (s StreamPushDektecAsiImpl) Disabled() *bool {
	return s.DisabledValue
}

// Disable pushing the stream.
// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
// In this way, the URL and other settings of a disabled stream remain in Flussonic.
func (s *StreamPushDektecAsiImpl) SetDisabled(v bool) StreamPushDektecAsi {
	if s == nil {
		return nil
	}
	s.DisabledValue = &v
	return s
}

// It allows to specify pack information about ac3 for outgoing MPEGTS-TS streams. The default value is `system_b`.
func (s StreamPushDektecAsiImpl) MpegtsAc3() *OutputMpegtsAc3 {
	return s.MpegtsAc3Value
}

// It allows to specify pack information about ac3 for outgoing MPEGTS-TS streams. The default value is `system_b`.
func (s *StreamPushDektecAsiImpl) SetMpegtsAc3(v OutputMpegtsAc3) StreamPushDektecAsi {
	if s == nil {
		return nil
	}
	s.MpegtsAc3Value = &v
	return s
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// It is possible to set PID values for PMT, STD and video and audio tracks.
func (s StreamPushDektecAsiImpl) Pids() OutputMpegtsPids {
	return s.PidsValue
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// It is possible to set PID values for PMT, STD and video and audio tracks.
func (s *StreamPushDektecAsiImpl) SetPids(v OutputMpegtsPids) StreamPushDektecAsi {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*OutputMpegtsPidsImpl); ok {
		s.PidsValue = impl
	}
	return s
}

// Program number in the outgoing MPEG-TS stream. A program may represent a television channel.
func (s StreamPushDektecAsiImpl) Pnr() *int {
	return s.PnrValue
}

// Program number in the outgoing MPEG-TS stream. A program may represent a television channel.
func (s *StreamPushDektecAsiImpl) SetPnr(v int) StreamPushDektecAsi {
	if s == nil {
		return nil
	}
	s.PnrValue = &v
	return s
}

// Provider name. Used to fill in the field service provider within SDT MPEG-TS table.
// Example: My provider name
func (s StreamPushDektecAsiImpl) Provider() *string {
	return s.ProviderValue
}

// Provider name. Used to fill in the field service provider within SDT MPEG-TS table.
// Example: My provider name
func (s *StreamPushDektecAsiImpl) SetProvider(v string) StreamPushDektecAsi {
	if s == nil {
		return nil
	}
	s.ProviderValue = &v
	return s
}

// The maximum number of times *Flussonic* retries to push the stream.
func (s StreamPushDektecAsiImpl) RetryLimit() *int {
	return s.RetryLimitValue
}

// The maximum number of times *Flussonic* retries to push the stream.
func (s *StreamPushDektecAsiImpl) SetRetryLimit(v int) StreamPushDektecAsi {
	if s == nil {
		return nil
	}
	s.RetryLimitValue = &v
	return s
}

// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
// It is an interval in seconds, 5 seconds by default.
// You can increase this value to reduce server load.
// Format: seconds (seconds)
// Example: 7
func (s StreamPushDektecAsiImpl) RetryTimeout() *Seconds {
	return s.RetryTimeoutValue
}

// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
// It is an interval in seconds, 5 seconds by default.
// You can increase this value to reduce server load.
// Format: seconds (seconds)
// Example: 7
func (s *StreamPushDektecAsiImpl) SetRetryTimeout(v Seconds) StreamPushDektecAsi {
	if s == nil {
		return nil
	}
	s.RetryTimeoutValue = &v
	return s
}

// Service name. Used to fill in the field service name within SDT MPEG-TS table.
// Example: My service name
func (s StreamPushDektecAsiImpl) Service() *string {
	return s.ServiceValue
}

// Service name. Used to fill in the field service name within SDT MPEG-TS table.
// Example: My service name
func (s *StreamPushDektecAsiImpl) SetService(v string) StreamPushDektecAsi {
	if s == nil {
		return nil
	}
	s.ServiceValue = &v
	return s
}

// Detailed runtime information about the push.
func (s StreamPushDektecAsiImpl) Stats() PushCounters {
	return s.StatsValue
}

// Detailed runtime information about the push.
func (s *StreamPushDektecAsiImpl) SetStats(v PushCounters) StreamPushDektecAsi {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*PushCountersImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
// Format: seconds (seconds)
// Example: 10
func (s StreamPushDektecAsiImpl) Timeout() *Seconds {
	return s.TimeoutValue
}

// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
// Format: seconds (seconds)
// Example: 10
func (s *StreamPushDektecAsiImpl) SetTimeout(v Seconds) StreamPushDektecAsi {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// Select which Dektec ASI card to use as a sink for this stream.
// Dektec url is combined of card serial # and number of output port on this card.
// Output ports on a card are numbered starting from 1.
// Serial numbers are uniq for each produced card. Take a look at admin UI or use
// native dektec tools to find the serial number.
// Mention that ASI is a MPEG-TS transport
// Format: input_url (input_url)
// Pattern: ^dektec-asi://.*$
// Examples: dektec-asi://
func (s StreamPushDektecAsiImpl) URL() InputURL {
	return s.URLValue
}

// Select which Dektec ASI card to use as a sink for this stream.
// Dektec url is combined of card serial # and number of output port on this card.
// Output ports on a card are numbered starting from 1.
// Serial numbers are uniq for each produced card. Take a look at admin UI or use
// native dektec tools to find the serial number.
// Mention that ASI is a MPEG-TS transport
// Format: input_url (input_url)
// Pattern: ^dektec-asi://.*$
// Examples: dektec-asi://
func (s *StreamPushDektecAsiImpl) SetURL(v InputURL) StreamPushDektecAsi {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// Average bitrate per second that you can send of a video track, including all the headers and encapsulation in the transport stream.
// So, for example, the value of vb=2720 approximately corresponds to the bitrate 2600 specified in the transcoder settings.
// Format: speed (speed)
// Example: 2720
func (s StreamPushDektecAsiImpl) Vb() *Speed {
	return s.VbValue
}

// Average bitrate per second that you can send of a video track, including all the headers and encapsulation in the transport stream.
// So, for example, the value of vb=2720 approximately corresponds to the bitrate 2600 specified in the transcoder settings.
// Format: speed (speed)
// Example: 2720
func (s *StreamPushDektecAsiImpl) SetVb(v Speed) StreamPushDektecAsi {
	if s == nil {
		return nil
	}
	s.VbValue = &v
	return s
}

// NewStreamPushHls creates a new StreamPushHls instance
func NewStreamPushHls() StreamPushHls {
	return &StreamPushHlsImpl{}
}

// Human-readable description of the pusher.
// Example: This is a test push
func (s StreamPushHlsImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the pusher.
// Example: This is a test push
func (s *StreamPushHlsImpl) SetComment(v string) StreamPushHls {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Connection timeout, in seconds. Equals to 0 by default.
// Format: seconds (seconds)
// Example: 2
func (s StreamPushHlsImpl) ConnectTimeout() *Seconds {
	return s.ConnectTimeoutValue
}

// Connection timeout, in seconds. Equals to 0 by default.
// Format: seconds (seconds)
// Example: 2
func (s *StreamPushHlsImpl) SetConnectTimeout(v Seconds) StreamPushHls {
	if s == nil {
		return nil
	}
	s.ConnectTimeoutValue = &v
	return s
}

// Disable pushing the stream.
// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
// In this way, the URL and other settings of a disabled stream remain in Flussonic.
func (s StreamPushHlsImpl) Disabled() *bool {
	return s.DisabledValue
}

// Disable pushing the stream.
// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
// In this way, the URL and other settings of a disabled stream remain in Flussonic.
func (s *StreamPushHlsImpl) SetDisabled(v bool) StreamPushHls {
	if s == nil {
		return nil
	}
	s.DisabledValue = &v
	return s
}

// The maximum number of times *Flussonic* retries to push the stream.
func (s StreamPushHlsImpl) RetryLimit() *int {
	return s.RetryLimitValue
}

// The maximum number of times *Flussonic* retries to push the stream.
func (s *StreamPushHlsImpl) SetRetryLimit(v int) StreamPushHls {
	if s == nil {
		return nil
	}
	s.RetryLimitValue = &v
	return s
}

// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
// It is an interval in seconds, 5 seconds by default.
// You can increase this value to reduce server load.
// Format: seconds (seconds)
// Example: 7
func (s StreamPushHlsImpl) RetryTimeout() *Seconds {
	return s.RetryTimeoutValue
}

// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
// It is an interval in seconds, 5 seconds by default.
// You can increase this value to reduce server load.
// Format: seconds (seconds)
// Example: 7
func (s *StreamPushHlsImpl) SetRetryTimeout(v Seconds) StreamPushHls {
	if s == nil {
		return nil
	}
	s.RetryTimeoutValue = &v
	return s
}

// Detailed runtime information about the push.
func (s StreamPushHlsImpl) Stats() PushCounters {
	return s.StatsValue
}

// Detailed runtime information about the push.
func (s *StreamPushHlsImpl) SetStats(v PushCounters) StreamPushHls {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*PushCountersImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
// Format: seconds (seconds)
// Example: 10
func (s StreamPushHlsImpl) Timeout() *Seconds {
	return s.TimeoutValue
}

// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
// Format: seconds (seconds)
// Example: 10
func (s *StreamPushHlsImpl) SetTimeout(v Seconds) StreamPushHls {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// It is possible to publish HLS to a CDN. Segments will be uploaded together with manifests.
// Format: input_url (input_url)
// Pattern: ^hlss?://.*$
// Examples: hls://your-server.com/app/stream1
func (s StreamPushHlsImpl) URL() InputURL {
	return s.URLValue
}

// It is possible to publish HLS to a CDN. Segments will be uploaded together with manifests.
// Format: input_url (input_url)
// Pattern: ^hlss?://.*$
// Examples: hls://your-server.com/app/stream1
func (s *StreamPushHlsImpl) SetURL(v InputURL) StreamPushHls {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// NewStreamPushM4f creates a new StreamPushM4f instance
func NewStreamPushM4f() StreamPushM4f {
	return &StreamPushM4fImpl{}
}

// Human-readable description of the pusher.
// Example: This is a test push
func (s StreamPushM4fImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the pusher.
// Example: This is a test push
func (s *StreamPushM4fImpl) SetComment(v string) StreamPushM4f {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Connection timeout, in seconds. Equals to 0 by default.
// Format: seconds (seconds)
// Example: 2
func (s StreamPushM4fImpl) ConnectTimeout() *Seconds {
	return s.ConnectTimeoutValue
}

// Connection timeout, in seconds. Equals to 0 by default.
// Format: seconds (seconds)
// Example: 2
func (s *StreamPushM4fImpl) SetConnectTimeout(v Seconds) StreamPushM4f {
	if s == nil {
		return nil
	}
	s.ConnectTimeoutValue = &v
	return s
}

// Disable pushing the stream.
// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
// In this way, the URL and other settings of a disabled stream remain in Flussonic.
func (s StreamPushM4fImpl) Disabled() *bool {
	return s.DisabledValue
}

// Disable pushing the stream.
// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
// In this way, the URL and other settings of a disabled stream remain in Flussonic.
func (s *StreamPushM4fImpl) SetDisabled(v bool) StreamPushM4f {
	if s == nil {
		return nil
	}
	s.DisabledValue = &v
	return s
}

// The maximum number of times *Flussonic* retries to push the stream.
func (s StreamPushM4fImpl) RetryLimit() *int {
	return s.RetryLimitValue
}

// The maximum number of times *Flussonic* retries to push the stream.
func (s *StreamPushM4fImpl) SetRetryLimit(v int) StreamPushM4f {
	if s == nil {
		return nil
	}
	s.RetryLimitValue = &v
	return s
}

// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
// It is an interval in seconds, 5 seconds by default.
// You can increase this value to reduce server load.
// Format: seconds (seconds)
// Example: 7
func (s StreamPushM4fImpl) RetryTimeout() *Seconds {
	return s.RetryTimeoutValue
}

// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
// It is an interval in seconds, 5 seconds by default.
// You can increase this value to reduce server load.
// Format: seconds (seconds)
// Example: 7
func (s *StreamPushM4fImpl) SetRetryTimeout(v Seconds) StreamPushM4f {
	if s == nil {
		return nil
	}
	s.RetryTimeoutValue = &v
	return s
}

// Detailed runtime information about the push.
func (s StreamPushM4fImpl) Stats() PushCounters {
	return s.StatsValue
}

// Detailed runtime information about the push.
func (s *StreamPushM4fImpl) SetStats(v PushCounters) StreamPushM4f {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*PushCountersImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
// Format: seconds (seconds)
// Example: 10
func (s StreamPushM4fImpl) Timeout() *Seconds {
	return s.TimeoutValue
}

// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
// Format: seconds (seconds)
// Example: 10
func (s *StreamPushM4fImpl) SetTimeout(v Seconds) StreamPushM4f {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// Another Flussonic URL where to push video to.
// Format: input_url (input_url)
// Pattern: ^m4fs?://.*$
// Examples: m4f://your-server.com/app/stream1
func (s StreamPushM4fImpl) URL() InputURL {
	return s.URLValue
}

// Another Flussonic URL where to push video to.
// Format: input_url (input_url)
// Pattern: ^m4fs?://.*$
// Examples: m4f://your-server.com/app/stream1
func (s *StreamPushM4fImpl) SetURL(v InputURL) StreamPushM4f {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// NewStreamPushM4s creates a new StreamPushM4s instance
func NewStreamPushM4s() StreamPushM4s {
	return &StreamPushM4sImpl{}
}

// Human-readable description of the pusher.
// Example: This is a test push
func (s StreamPushM4sImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the pusher.
// Example: This is a test push
func (s *StreamPushM4sImpl) SetComment(v string) StreamPushM4s {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Connection timeout, in seconds. Equals to 0 by default.
// Format: seconds (seconds)
// Example: 2
func (s StreamPushM4sImpl) ConnectTimeout() *Seconds {
	return s.ConnectTimeoutValue
}

// Connection timeout, in seconds. Equals to 0 by default.
// Format: seconds (seconds)
// Example: 2
func (s *StreamPushM4sImpl) SetConnectTimeout(v Seconds) StreamPushM4s {
	if s == nil {
		return nil
	}
	s.ConnectTimeoutValue = &v
	return s
}

// Disable pushing the stream.
// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
// In this way, the URL and other settings of a disabled stream remain in Flussonic.
func (s StreamPushM4sImpl) Disabled() *bool {
	return s.DisabledValue
}

// Disable pushing the stream.
// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
// In this way, the URL and other settings of a disabled stream remain in Flussonic.
func (s *StreamPushM4sImpl) SetDisabled(v bool) StreamPushM4s {
	if s == nil {
		return nil
	}
	s.DisabledValue = &v
	return s
}

// The maximum number of times *Flussonic* retries to push the stream.
func (s StreamPushM4sImpl) RetryLimit() *int {
	return s.RetryLimitValue
}

// The maximum number of times *Flussonic* retries to push the stream.
func (s *StreamPushM4sImpl) SetRetryLimit(v int) StreamPushM4s {
	if s == nil {
		return nil
	}
	s.RetryLimitValue = &v
	return s
}

// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
// It is an interval in seconds, 5 seconds by default.
// You can increase this value to reduce server load.
// Format: seconds (seconds)
// Example: 7
func (s StreamPushM4sImpl) RetryTimeout() *Seconds {
	return s.RetryTimeoutValue
}

// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
// It is an interval in seconds, 5 seconds by default.
// You can increase this value to reduce server load.
// Format: seconds (seconds)
// Example: 7
func (s *StreamPushM4sImpl) SetRetryTimeout(v Seconds) StreamPushM4s {
	if s == nil {
		return nil
	}
	s.RetryTimeoutValue = &v
	return s
}

// Detailed runtime information about the push.
func (s StreamPushM4sImpl) Stats() PushCounters {
	return s.StatsValue
}

// Detailed runtime information about the push.
func (s *StreamPushM4sImpl) SetStats(v PushCounters) StreamPushM4s {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*PushCountersImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
// Format: seconds (seconds)
// Example: 10
func (s StreamPushM4sImpl) Timeout() *Seconds {
	return s.TimeoutValue
}

// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
// Format: seconds (seconds)
// Example: 10
func (s *StreamPushM4sImpl) SetTimeout(v Seconds) StreamPushM4s {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// Flussonic stream URL where to push to.
// Format: input_url (input_url)
// Pattern: ^m4ss?://.*$
// Examples: m4s://your-server.com/app/stream1
func (s StreamPushM4sImpl) URL() InputURL {
	return s.URLValue
}

// Flussonic stream URL where to push to.
// Format: input_url (input_url)
// Pattern: ^m4ss?://.*$
// Examples: m4s://your-server.com/app/stream1
func (s *StreamPushM4sImpl) SetURL(v InputURL) StreamPushM4s {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// NewStreamPushMpegtsBase creates a new StreamPushMpegtsBase instance
func NewStreamPushMpegtsBase() StreamPushMpegtsBase {
	return &StreamPushMpegtsBaseImpl{}
}

// The bitrate of the whole stream.
// Format: speed (speed)
// Example: 3200
func (s StreamPushMpegtsBaseImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// The bitrate of the whole stream.
// Format: speed (speed)
// Example: 3200
func (s *StreamPushMpegtsBaseImpl) SetBitrate(v Speed) StreamPushMpegtsBase {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// It allows to specify pack information about ac3 for outgoing MPEGTS-TS streams. The default value is `system_b`.
func (s StreamPushMpegtsBaseImpl) MpegtsAc3() *OutputMpegtsAc3 {
	return s.MpegtsAc3Value
}

// It allows to specify pack information about ac3 for outgoing MPEGTS-TS streams. The default value is `system_b`.
func (s *StreamPushMpegtsBaseImpl) SetMpegtsAc3(v OutputMpegtsAc3) StreamPushMpegtsBase {
	if s == nil {
		return nil
	}
	s.MpegtsAc3Value = &v
	return s
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// It is possible to set PID values for PMT, STD and video and audio tracks.
func (s StreamPushMpegtsBaseImpl) Pids() OutputMpegtsPids {
	return s.PidsValue
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// It is possible to set PID values for PMT, STD and video and audio tracks.
func (s *StreamPushMpegtsBaseImpl) SetPids(v OutputMpegtsPids) StreamPushMpegtsBase {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*OutputMpegtsPidsImpl); ok {
		s.PidsValue = impl
	}
	return s
}

// Program number in the outgoing MPEG-TS stream. A program may represent a television channel.
func (s StreamPushMpegtsBaseImpl) Pnr() *int {
	return s.PnrValue
}

// Program number in the outgoing MPEG-TS stream. A program may represent a television channel.
func (s *StreamPushMpegtsBaseImpl) SetPnr(v int) StreamPushMpegtsBase {
	if s == nil {
		return nil
	}
	s.PnrValue = &v
	return s
}

// Provider name. Used to fill in the field service provider within SDT MPEG-TS table.
// Example: My provider name
func (s StreamPushMpegtsBaseImpl) Provider() *string {
	return s.ProviderValue
}

// Provider name. Used to fill in the field service provider within SDT MPEG-TS table.
// Example: My provider name
func (s *StreamPushMpegtsBaseImpl) SetProvider(v string) StreamPushMpegtsBase {
	if s == nil {
		return nil
	}
	s.ProviderValue = &v
	return s
}

// Service name. Used to fill in the field service name within SDT MPEG-TS table.
// Example: My service name
func (s StreamPushMpegtsBaseImpl) Service() *string {
	return s.ServiceValue
}

// Service name. Used to fill in the field service name within SDT MPEG-TS table.
// Example: My service name
func (s *StreamPushMpegtsBaseImpl) SetService(v string) StreamPushMpegtsBase {
	if s == nil {
		return nil
	}
	s.ServiceValue = &v
	return s
}

// Average bitrate per second that you can send of a video track, including all the headers and encapsulation in the transport stream.
// So, for example, the value of vb=2720 approximately corresponds to the bitrate 2600 specified in the transcoder settings.
// Format: speed (speed)
// Example: 2720
func (s StreamPushMpegtsBaseImpl) Vb() *Speed {
	return s.VbValue
}

// Average bitrate per second that you can send of a video track, including all the headers and encapsulation in the transport stream.
// So, for example, the value of vb=2720 approximately corresponds to the bitrate 2600 specified in the transcoder settings.
// Format: speed (speed)
// Example: 2720
func (s *StreamPushMpegtsBaseImpl) SetVb(v Speed) StreamPushMpegtsBase {
	if s == nil {
		return nil
	}
	s.VbValue = &v
	return s
}

// NewStreamPushNdi creates a new StreamPushNdi instance
func NewStreamPushNdi() StreamPushNdi {
	return &StreamPushNdiImpl{}
}

// Human-readable description of the pusher.
// Example: This is a test push
func (s StreamPushNdiImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the pusher.
// Example: This is a test push
func (s *StreamPushNdiImpl) SetComment(v string) StreamPushNdi {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Connection timeout, in seconds. Equals to 0 by default.
// Format: seconds (seconds)
// Example: 2
func (s StreamPushNdiImpl) ConnectTimeout() *Seconds {
	return s.ConnectTimeoutValue
}

// Connection timeout, in seconds. Equals to 0 by default.
// Format: seconds (seconds)
// Example: 2
func (s *StreamPushNdiImpl) SetConnectTimeout(v Seconds) StreamPushNdi {
	if s == nil {
		return nil
	}
	s.ConnectTimeoutValue = &v
	return s
}

// Disable pushing the stream.
// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
// In this way, the URL and other settings of a disabled stream remain in Flussonic.
func (s StreamPushNdiImpl) Disabled() *bool {
	return s.DisabledValue
}

// Disable pushing the stream.
// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
// In this way, the URL and other settings of a disabled stream remain in Flussonic.
func (s *StreamPushNdiImpl) SetDisabled(v bool) StreamPushNdi {
	if s == nil {
		return nil
	}
	s.DisabledValue = &v
	return s
}

// The maximum number of times *Flussonic* retries to push the stream.
func (s StreamPushNdiImpl) RetryLimit() *int {
	return s.RetryLimitValue
}

// The maximum number of times *Flussonic* retries to push the stream.
func (s *StreamPushNdiImpl) SetRetryLimit(v int) StreamPushNdi {
	if s == nil {
		return nil
	}
	s.RetryLimitValue = &v
	return s
}

// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
// It is an interval in seconds, 5 seconds by default.
// You can increase this value to reduce server load.
// Format: seconds (seconds)
// Example: 7
func (s StreamPushNdiImpl) RetryTimeout() *Seconds {
	return s.RetryTimeoutValue
}

// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
// It is an interval in seconds, 5 seconds by default.
// You can increase this value to reduce server load.
// Format: seconds (seconds)
// Example: 7
func (s *StreamPushNdiImpl) SetRetryTimeout(v Seconds) StreamPushNdi {
	if s == nil {
		return nil
	}
	s.RetryTimeoutValue = &v
	return s
}

// Detailed runtime information about the push.
func (s StreamPushNdiImpl) Stats() PushCounters {
	return s.StatsValue
}

// Detailed runtime information about the push.
func (s *StreamPushNdiImpl) SetStats(v PushCounters) StreamPushNdi {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*PushCountersImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
// Format: seconds (seconds)
// Example: 10
func (s StreamPushNdiImpl) Timeout() *Seconds {
	return s.TimeoutValue
}

// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
// Format: seconds (seconds)
// Example: 10
func (s *StreamPushNdiImpl) SetTimeout(v Seconds) StreamPushNdi {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// The URL allows you to set the name of the NDI source being created.
// Format: input_url (input_url)
// Pattern: ^ndi://.*$
// Examples: ndi://source_name
func (s StreamPushNdiImpl) URL() InputURL {
	return s.URLValue
}

// The URL allows you to set the name of the NDI source being created.
// Format: input_url (input_url)
// Pattern: ^ndi://.*$
// Examples: ndi://source_name
func (s *StreamPushNdiImpl) SetURL(v InputURL) StreamPushNdi {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// NewStreamPushRtmp creates a new StreamPushRtmp instance
func NewStreamPushRtmp() StreamPushRtmp {
	return &StreamPushRtmpImpl{}
}

// Human-readable description of the pusher.
// Example: This is a test push
func (s StreamPushRtmpImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the pusher.
// Example: This is a test push
func (s *StreamPushRtmpImpl) SetComment(v string) StreamPushRtmp {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Connection timeout, in seconds. Equals to 0 by default.
// Format: seconds (seconds)
// Example: 2
func (s StreamPushRtmpImpl) ConnectTimeout() *Seconds {
	return s.ConnectTimeoutValue
}

// Connection timeout, in seconds. Equals to 0 by default.
// Format: seconds (seconds)
// Example: 2
func (s *StreamPushRtmpImpl) SetConnectTimeout(v Seconds) StreamPushRtmp {
	if s == nil {
		return nil
	}
	s.ConnectTimeoutValue = &v
	return s
}

// Disable pushing the stream.
// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
// In this way, the URL and other settings of a disabled stream remain in Flussonic.
func (s StreamPushRtmpImpl) Disabled() *bool {
	return s.DisabledValue
}

// Disable pushing the stream.
// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
// In this way, the URL and other settings of a disabled stream remain in Flussonic.
func (s *StreamPushRtmpImpl) SetDisabled(v bool) StreamPushRtmp {
	if s == nil {
		return nil
	}
	s.DisabledValue = &v
	return s
}

// Service public domain name.
// The value will be sent within notify message with command name 'onMetaData'
// Metadata also will contain the name `Streamer`, streamer version, the type and version of the operating system.
// Metadata will be sent as map with associated map key `yt_project`.
// String template is `Streamer #{streamer_version} #{encoder} #{os_type} #{os_version} #{domain}`.
// Example of the resulting string is `{"yt_project" : "Streamer 25.01 Lavf56.40.101 unix-linux 6.1.0 officialdomain.com"}`.
// Example: officialdomain.com
func (s StreamPushRtmpImpl) Domain() *string {
	return s.DomainValue
}

// Service public domain name.
// The value will be sent within notify message with command name 'onMetaData'
// Metadata also will contain the name `Streamer`, streamer version, the type and version of the operating system.
// Metadata will be sent as map with associated map key `yt_project`.
// String template is `Streamer #{streamer_version} #{encoder} #{os_type} #{os_version} #{domain}`.
// Example of the resulting string is `{"yt_project" : "Streamer 25.01 Lavf56.40.101 unix-linux 6.1.0 officialdomain.com"}`.
// Example: officialdomain.com
func (s *StreamPushRtmpImpl) SetDomain(v string) StreamPushRtmp {
	if s == nil {
		return nil
	}
	s.DomainValue = &v
	return s
}

// The name of the encoder used by the pusher. Can also be used as a device name.
// The value will be sent within notify message with command name 'onMetaData' and within FlashVer string (see above).
// Example: Lavf57
func (s StreamPushRtmpImpl) Encoder() *string {
	return s.EncoderValue
}

// The name of the encoder used by the pusher. Can also be used as a device name.
// The value will be sent within notify message with command name 'onMetaData' and within FlashVer string (see above).
// Example: Lavf57
func (s *StreamPushRtmpImpl) SetEncoder(v string) StreamPushRtmp {
	if s == nil {
		return nil
	}
	s.EncoderValue = &v
	return s
}

// The maximum number of times *Flussonic* retries to push the stream.
func (s StreamPushRtmpImpl) RetryLimit() *int {
	return s.RetryLimitValue
}

// The maximum number of times *Flussonic* retries to push the stream.
func (s *StreamPushRtmpImpl) SetRetryLimit(v int) StreamPushRtmp {
	if s == nil {
		return nil
	}
	s.RetryLimitValue = &v
	return s
}

// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
// It is an interval in seconds, 5 seconds by default.
// You can increase this value to reduce server load.
// Format: seconds (seconds)
// Example: 7
func (s StreamPushRtmpImpl) RetryTimeout() *Seconds {
	return s.RetryTimeoutValue
}

// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
// It is an interval in seconds, 5 seconds by default.
// You can increase this value to reduce server load.
// Format: seconds (seconds)
// Example: 7
func (s *StreamPushRtmpImpl) SetRetryTimeout(v Seconds) StreamPushRtmp {
	if s == nil {
		return nil
	}
	s.RetryTimeoutValue = &v
	return s
}

// The name of the service.
// The value will be sent within FlashVer string when establishing a connection.
// String template is `FMLE/3.0 (compatible; #{encoder}; Streamer #{streamer_version}; #{service}`.
// Example of the resulting FlashVer string is `FMLE/3.0 (compatible; Lavf56.40.101; Streamer 25.01; My service)`.
// Example: My service
func (s StreamPushRtmpImpl) Service() *string {
	return s.ServiceValue
}

// The name of the service.
// The value will be sent within FlashVer string when establishing a connection.
// String template is `FMLE/3.0 (compatible; #{encoder}; Streamer #{streamer_version}; #{service}`.
// Example of the resulting FlashVer string is `FMLE/3.0 (compatible; Lavf56.40.101; Streamer 25.01; My service)`.
// Example: My service
func (s *StreamPushRtmpImpl) SetService(v string) StreamPushRtmp {
	if s == nil {
		return nil
	}
	s.ServiceValue = &v
	return s
}

// Detailed runtime information about the push.
func (s StreamPushRtmpImpl) Stats() PushCounters {
	return s.StatsValue
}

// Detailed runtime information about the push.
func (s *StreamPushRtmpImpl) SetStats(v PushCounters) StreamPushRtmp {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*PushCountersImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
// Format: seconds (seconds)
// Example: 10
func (s StreamPushRtmpImpl) Timeout() *Seconds {
	return s.TimeoutValue
}

// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
// Format: seconds (seconds)
// Example: 10
func (s *StreamPushRtmpImpl) SetTimeout(v Seconds) StreamPushRtmp {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// RTMP URL where to push.
// You can publish to RTMP servers. Usually it is a social network streaming.
// Format: input_url (input_url)
// Pattern: ^rtmps?://.*$
// Examples: rtmp://your-server.com/app/stream1
func (s StreamPushRtmpImpl) URL() InputURL {
	return s.URLValue
}

// RTMP URL where to push.
// You can publish to RTMP servers. Usually it is a social network streaming.
// Format: input_url (input_url)
// Pattern: ^rtmps?://.*$
// Examples: rtmp://your-server.com/app/stream1
func (s *StreamPushRtmpImpl) SetURL(v InputURL) StreamPushRtmp {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// NewStreamPushSdiBase creates a new StreamPushSdiBase instance
func NewStreamPushSdiBase() StreamPushSdiBase {
	return &StreamPushSdiBaseImpl{}
}

// Activate deinterlacing, i.e., converting an interlaced image to a progressive image.
// It is necessary for comfortable viewing of legacy TV video on PC/mobile devices.
func (s StreamPushSdiBaseImpl) Deinterlace() *bool {
	return s.DeinterlaceValue
}

// Activate deinterlacing, i.e., converting an interlaced image to a progressive image.
// It is necessary for comfortable viewing of legacy TV video on PC/mobile devices.
func (s *StreamPushSdiBaseImpl) SetDeinterlace(v bool) StreamPushSdiBase {
	if s == nil {
		return nil
	}
	s.DeinterlaceValue = &v
	return s
}

// Defines a number of threads in a decoder.
// One thread uses one core.
// The default value equals 4, but you can set it equal to the number of cores of your CPU.
func (s StreamPushSdiBaseImpl) Dthreads() *int {
	return s.DthreadsValue
}

// Defines a number of threads in a decoder.
// One thread uses one core.
// The default value equals 4, but you can set it equal to the number of cores of your CPU.
func (s *StreamPushSdiBaseImpl) SetDthreads(v int) StreamPushSdiBase {
	if s == nil {
		return nil
	}
	s.DthreadsValue = &v
	return s
}

// Defines a scaling algorithm.
// You can choose only one algorithm at a time.
// If a pushing stream has the same video resolution as an ingest stream, the `fast_bilinear` algorithm is used by default.
// If a video resolution of a pushing stream does not equal the video resolution of an ingest stream, the bicubic algorithm is used by default.
// If the algorithm is specified explicitly, it applies to all the formats.
func (s StreamPushSdiBaseImpl) Scale() *ScaleAlgorithm {
	return s.ScaleValue
}

// Defines a scaling algorithm.
// You can choose only one algorithm at a time.
// If a pushing stream has the same video resolution as an ingest stream, the `fast_bilinear` algorithm is used by default.
// If a video resolution of a pushing stream does not equal the video resolution of an ingest stream, the bicubic algorithm is used by default.
// If the algorithm is specified explicitly, it applies to all the formats.
func (s *StreamPushSdiBaseImpl) SetScale(v ScaleAlgorithm) StreamPushSdiBase {
	if s == nil {
		return nil
	}
	s.ScaleValue = &v
	return s
}

// Lines of VBI (vertical blanking interval) of an output analog stream that will contain teletext.
// It is used for passing teletext from MPEG-TS to analog streams.
func (s StreamPushSdiBaseImpl) VbiLines() []VbiLines {
	if s.VbiLinesValue == nil {
		return nil
	}
	result := make([]VbiLines, len(s.VbiLinesValue))
	for i, item := range s.VbiLinesValue {
		result[i] = item
	}
	return result
}

// Lines of VBI (vertical blanking interval) of an output analog stream that will contain teletext.
// It is used for passing teletext from MPEG-TS to analog streams.
func (s *StreamPushSdiBaseImpl) SetVbiLines(v []VbiLines) StreamPushSdiBase {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*VbiLinesImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*VbiLinesImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.VbiLinesValue = impl
	}
	return s
}

// Specify SDI/HDMI output format
func (s StreamPushSdiBaseImpl) VideoFormat() *string {
	return s.VideoFormatValue
}

// Specify SDI/HDMI output format
func (s *StreamPushSdiBaseImpl) SetVideoFormat(v string) StreamPushSdiBase {
	if s == nil {
		return nil
	}
	s.VideoFormatValue = &v
	return s
}

// Audio volume coefficient.
// The output audio volume is given by the relation: `output_volume = volume * input_volume`.
// The maximum volume value is 1.0 (default value).
// Example: 0.5
func (s StreamPushSdiBaseImpl) Volume() *float64 {
	return s.VolumeValue
}

// Audio volume coefficient.
// The output audio volume is given by the relation: `output_volume = volume * input_volume`.
// The maximum volume value is 1.0 (default value).
// Example: 0.5
func (s *StreamPushSdiBaseImpl) SetVolume(v float64) StreamPushSdiBase {
	if s == nil {
		return nil
	}
	s.VolumeValue = &v
	return s
}

// NewStreamPushSrt creates a new StreamPushSrt instance
func NewStreamPushSrt() StreamPushSrt {
	return &StreamPushSrtImpl{}
}

// The bitrate of the whole stream.
// Format: speed (speed)
// Example: 3200
func (s StreamPushSrtImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// The bitrate of the whole stream.
// Format: speed (speed)
// Example: 3200
func (s *StreamPushSrtImpl) SetBitrate(v Speed) StreamPushSrt {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// Human-readable description of the pusher.
// Example: This is a test push
func (s StreamPushSrtImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the pusher.
// Example: This is a test push
func (s *StreamPushSrtImpl) SetComment(v string) StreamPushSrt {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Connection timeout, in seconds. Equals to 0 by default.
// Format: seconds (seconds)
// Example: 2
func (s StreamPushSrtImpl) ConnectTimeout() *Seconds {
	return s.ConnectTimeoutValue
}

// Connection timeout, in seconds. Equals to 0 by default.
// Format: seconds (seconds)
// Example: 2
func (s *StreamPushSrtImpl) SetConnectTimeout(v Seconds) StreamPushSrt {
	if s == nil {
		return nil
	}
	s.ConnectTimeoutValue = &v
	return s
}

// Disable pushing the stream.
// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
// In this way, the URL and other settings of a disabled stream remain in Flussonic.
func (s StreamPushSrtImpl) Disabled() *bool {
	return s.DisabledValue
}

// Disable pushing the stream.
// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
// In this way, the URL and other settings of a disabled stream remain in Flussonic.
func (s *StreamPushSrtImpl) SetDisabled(v bool) StreamPushSrt {
	if s == nil {
		return nil
	}
	s.DisabledValue = &v
	return s
}

// Whether both connection parties must have the same password set (including empty, in other words, with no encryption).
// If the passwords do not match or only one side is unencrypted, the connection is rejected.
// The default value is `true`.
// Example: true
func (s StreamPushSrtImpl) Enforcedencryption() *bool {
	return s.EnforcedencryptionValue
}

// Whether both connection parties must have the same password set (including empty, in other words, with no encryption).
// If the passwords do not match or only one side is unencrypted, the connection is rejected.
// The default value is `true`.
// Example: true
func (s *StreamPushSrtImpl) SetEnforcedencryption(v bool) StreamPushSrt {
	if s == nil {
		return nil
	}
	s.EnforcedencryptionValue = &v
	return s
}

// The latency value for both directions of the socket.
// By default initial value latency is 0 when transmitting and 120ms when receiving video.
// Actual value established after connection handshake.
// Increased value helps tolerate network losses and delays.
// Format: milliseconds (milliseconds)
// Example: 150
func (s StreamPushSrtImpl) Latency() *Milliseconds {
	return s.LatencyValue
}

// The latency value for both directions of the socket.
// By default initial value latency is 0 when transmitting and 120ms when receiving video.
// Actual value established after connection handshake.
// Increased value helps tolerate network losses and delays.
// Format: milliseconds (milliseconds)
// Example: 150
func (s *StreamPushSrtImpl) SetLatency(v Milliseconds) StreamPushSrt {
	if s == nil {
		return nil
	}
	s.LatencyValue = &v
	return s
}

// The time, in seconds, that the socket waits for the unsent data before closing.
// The default value is 180.
// Format: seconds (seconds)
// Example: 15
func (s StreamPushSrtImpl) Linger() *Seconds {
	return s.LingerValue
}

// The time, in seconds, that the socket waits for the unsent data before closing.
// The default value is 180.
// Format: seconds (seconds)
// Example: 15
func (s *StreamPushSrtImpl) SetLinger(v Seconds) StreamPushSrt {
	if s == nil {
		return nil
	}
	s.LingerValue = &v
	return s
}

// The minimum SRT version that is required from the peer for SRT publication.
// Pattern: ^[0-9]+\.[0-9]+\.[0-9]+$
// Example: 1.1.0
func (s StreamPushSrtImpl) Minversion() *string {
	return s.MinversionValue
}

// The minimum SRT version that is required from the peer for SRT publication.
// Pattern: ^[0-9]+\.[0-9]+\.[0-9]+$
// Example: 1.1.0
func (s *StreamPushSrtImpl) SetMinversion(v string) StreamPushSrt {
	if s == nil {
		return nil
	}
	s.MinversionValue = &v
	return s
}

// It allows to specify pack information about ac3 for outgoing MPEGTS-TS streams. The default value is `system_b`.
func (s StreamPushSrtImpl) MpegtsAc3() *OutputMpegtsAc3 {
	return s.MpegtsAc3Value
}

// It allows to specify pack information about ac3 for outgoing MPEGTS-TS streams. The default value is `system_b`.
func (s *StreamPushSrtImpl) SetMpegtsAc3(v OutputMpegtsAc3) StreamPushSrt {
	if s == nil {
		return nil
	}
	s.MpegtsAc3Value = &v
	return s
}

// Whether to capture multicast back to the *Flussonic* host.
// This option allows you to ingest the sent stream on the sending host by *Flussonic* or other application.
// Set to `True` for a UDP MPEG-TS push.
// Example: true
func (s StreamPushSrtImpl) MulticastLoop() *bool {
	return s.MulticastLoopValue
}

// Whether to capture multicast back to the *Flussonic* host.
// This option allows you to ingest the sent stream on the sending host by *Flussonic* or other application.
// Set to `True` for a UDP MPEG-TS push.
// Example: true
func (s *StreamPushSrtImpl) SetMulticastLoop(v bool) StreamPushSrt {
	if s == nil {
		return nil
	}
	s.MulticastLoopValue = &v
	return s
}

// The password for the encrypted transmission.
// Its length should be not less than 10 and not more than 79 characters.
// Unlike [password](https://flussonic.com/doc/api/reference/#tag/stream/operation/stream_save%7Cbody%7Cpassword),
// the passphrase is not transmitted openly but is used to encrypt the key that is transmitted by the Caller
// and decoded by Listener.
// Example: 9876543210
func (s StreamPushSrtImpl) Passphrase() *string {
	return s.PassphraseValue
}

// The password for the encrypted transmission.
// Its length should be not less than 10 and not more than 79 characters.
// Unlike [password](https://flussonic.com/doc/api/reference/#tag/stream/operation/stream_save%7Cbody%7Cpassword),
// the passphrase is not transmitted openly but is used to encrypt the key that is transmitted by the Caller
// and decoded by Listener.
// Example: 9876543210
func (s *StreamPushSrtImpl) SetPassphrase(v string) StreamPushSrt {
	if s == nil {
		return nil
	}
	s.PassphraseValue = &v
	return s
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// It is possible to set PID values for PMT, STD and video and audio tracks.
func (s StreamPushSrtImpl) Pids() OutputMpegtsPids {
	return s.PidsValue
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// It is possible to set PID values for PMT, STD and video and audio tracks.
func (s *StreamPushSrtImpl) SetPids(v OutputMpegtsPids) StreamPushSrt {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*OutputMpegtsPidsImpl); ok {
		s.PidsValue = impl
	}
	return s
}

// Program number in the outgoing MPEG-TS stream. A program may represent a television channel.
func (s StreamPushSrtImpl) Pnr() *int {
	return s.PnrValue
}

// Program number in the outgoing MPEG-TS stream. A program may represent a television channel.
func (s *StreamPushSrtImpl) SetPnr(v int) StreamPushSrt {
	if s == nil {
		return nil
	}
	s.PnrValue = &v
	return s
}

// Provider name. Used to fill in the field service provider within SDT MPEG-TS table.
// Example: My provider name
func (s StreamPushSrtImpl) Provider() *string {
	return s.ProviderValue
}

// Provider name. Used to fill in the field service provider within SDT MPEG-TS table.
// Example: My provider name
func (s *StreamPushSrtImpl) SetProvider(v string) StreamPushSrt {
	if s == nil {
		return nil
	}
	s.ProviderValue = &v
	return s
}

// The maximum number of times *Flussonic* retries to push the stream.
func (s StreamPushSrtImpl) RetryLimit() *int {
	return s.RetryLimitValue
}

// The maximum number of times *Flussonic* retries to push the stream.
func (s *StreamPushSrtImpl) SetRetryLimit(v int) StreamPushSrt {
	if s == nil {
		return nil
	}
	s.RetryLimitValue = &v
	return s
}

// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
// It is an interval in seconds, 5 seconds by default.
// You can increase this value to reduce server load.
// Format: seconds (seconds)
// Example: 7
func (s StreamPushSrtImpl) RetryTimeout() *Seconds {
	return s.RetryTimeoutValue
}

// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
// It is an interval in seconds, 5 seconds by default.
// You can increase this value to reduce server load.
// Format: seconds (seconds)
// Example: 7
func (s *StreamPushSrtImpl) SetRetryTimeout(v Seconds) StreamPushSrt {
	if s == nil {
		return nil
	}
	s.RetryTimeoutValue = &v
	return s
}

// Service name. Used to fill in the field service name within SDT MPEG-TS table.
// Example: My service name
func (s StreamPushSrtImpl) Service() *string {
	return s.ServiceValue
}

// Service name. Used to fill in the field service name within SDT MPEG-TS table.
// Example: My service name
func (s *StreamPushSrtImpl) SetService(v string) StreamPushSrt {
	if s == nil {
		return nil
	}
	s.ServiceValue = &v
	return s
}

// Monitoring multicast group and stop pushing if another publisher presented
func (s StreamPushSrtImpl) Standby() *bool {
	return s.StandbyValue
}

// Monitoring multicast group and stop pushing if another publisher presented
func (s *StreamPushSrtImpl) SetStandby(v bool) StreamPushSrt {
	if s == nil {
		return nil
	}
	s.StandbyValue = &v
	return s
}

// Detailed runtime information about the push.
func (s StreamPushSrtImpl) Stats() PushCounters {
	return s.StatsValue
}

// Detailed runtime information about the push.
func (s *StreamPushSrtImpl) SetStats(v PushCounters) StreamPushSrt {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*PushCountersImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// A string of maximum 512 characters set on the socket before the connection.
// This string is a part of a callback that is sent by the caller and regisered by the listener.
// Based on this information the listener can accept or reject the connection, select the desired data stream, or set an appropriate passphrase for the connection.
// Its format is `#!::` optionally followed by the parameters:
// * `r=` - stream name
// * `m=` - mode expected for the connection: `publish` (if the caller wants to send the stream data) or `request` (if the caller wants to receive the stream).
// * `password=` - a password for the authorization in a publish session (not recommended, better use `passphrase` option instead)
// During SRT sessions the following parameters are automaticly added to streamid:
// * `s=` - the identifier of a session
// * `a=` - Flussonic version
// NOTE: you can specify a string in the format you need; to disable this extension, you need specify empty string.
// Example: #!::r=my-stream,m=publish
func (s StreamPushSrtImpl) Streamid() *string {
	return s.StreamidValue
}

// A string of maximum 512 characters set on the socket before the connection.
// This string is a part of a callback that is sent by the caller and regisered by the listener.
// Based on this information the listener can accept or reject the connection, select the desired data stream, or set an appropriate passphrase for the connection.
// Its format is `#!::` optionally followed by the parameters:
// * `r=` - stream name
// * `m=` - mode expected for the connection: `publish` (if the caller wants to send the stream data) or `request` (if the caller wants to receive the stream).
// * `password=` - a password for the authorization in a publish session (not recommended, better use `passphrase` option instead)
// During SRT sessions the following parameters are automaticly added to streamid:
// * `s=` - the identifier of a session
// * `a=` - Flussonic version
// NOTE: you can specify a string in the format you need; to disable this extension, you need specify empty string.
// Example: #!::r=my-stream,m=publish
func (s *StreamPushSrtImpl) SetStreamid(v string) StreamPushSrt {
	if s == nil {
		return nil
	}
	s.StreamidValue = &v
	return s
}

// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
// Format: seconds (seconds)
// Example: 10
func (s StreamPushSrtImpl) Timeout() *Seconds {
	return s.TimeoutValue
}

// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
// Format: seconds (seconds)
// Example: 10
func (s *StreamPushSrtImpl) SetTimeout(v Seconds) StreamPushSrt {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// SRT URL where to push video.
// Format: input_url (input_url)
// Pattern: ^srt[12]?://[^:]+:[0-9]+.*$
// Examples: srt://my-server.com:8994
func (s StreamPushSrtImpl) URL() InputURL {
	return s.URLValue
}

// SRT URL where to push video.
// Format: input_url (input_url)
// Pattern: ^srt[12]?://[^:]+:[0-9]+.*$
// Examples: srt://my-server.com:8994
func (s *StreamPushSrtImpl) SetURL(v InputURL) StreamPushSrt {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// Average bitrate per second that you can send of a video track, including all the headers and encapsulation in the transport stream.
// So, for example, the value of vb=2720 approximately corresponds to the bitrate 2600 specified in the transcoder settings.
// Format: speed (speed)
// Example: 2720
func (s StreamPushSrtImpl) Vb() *Speed {
	return s.VbValue
}

// Average bitrate per second that you can send of a video track, including all the headers and encapsulation in the transport stream.
// So, for example, the value of vb=2720 approximately corresponds to the bitrate 2600 specified in the transcoder settings.
// Format: speed (speed)
// Example: 2720
func (s *StreamPushSrtImpl) SetVb(v Speed) StreamPushSrt {
	if s == nil {
		return nil
	}
	s.VbValue = &v
	return s
}

// Required SRT version.
// Pattern: ^[0-9]+\.[0-9]+\.[0-9]+$
// Example: 1.3.0
func (s StreamPushSrtImpl) Version() *string {
	return s.VersionValue
}

// Required SRT version.
// Pattern: ^[0-9]+\.[0-9]+\.[0-9]+$
// Example: 1.3.0
func (s *StreamPushSrtImpl) SetVersion(v string) StreamPushSrt {
	if s == nil {
		return nil
	}
	s.VersionValue = &v
	return s
}

// NewStreamPushSt2110 creates a new StreamPushSt2110 instance
func NewStreamPushSt2110() StreamPushSt2110 {
	return &StreamPushSt2110Impl{}
}

// Human-readable description of the pusher.
// Example: This is a test push
func (s StreamPushSt2110Impl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the pusher.
// Example: This is a test push
func (s *StreamPushSt2110Impl) SetComment(v string) StreamPushSt2110 {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Connection timeout, in seconds. Equals to 0 by default.
// Format: seconds (seconds)
// Example: 2
func (s StreamPushSt2110Impl) ConnectTimeout() *Seconds {
	return s.ConnectTimeoutValue
}

// Connection timeout, in seconds. Equals to 0 by default.
// Format: seconds (seconds)
// Example: 2
func (s *StreamPushSt2110Impl) SetConnectTimeout(v Seconds) StreamPushSt2110 {
	if s == nil {
		return nil
	}
	s.ConnectTimeoutValue = &v
	return s
}

// Disable pushing the stream.
// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
// In this way, the URL and other settings of a disabled stream remain in Flussonic.
func (s StreamPushSt2110Impl) Disabled() *bool {
	return s.DisabledValue
}

// Disable pushing the stream.
// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
// In this way, the URL and other settings of a disabled stream remain in Flussonic.
func (s *StreamPushSt2110Impl) SetDisabled(v bool) StreamPushSt2110 {
	if s == nil {
		return nil
	}
	s.DisabledValue = &v
	return s
}

// The maximum number of times *Flussonic* retries to push the stream.
func (s StreamPushSt2110Impl) RetryLimit() *int {
	return s.RetryLimitValue
}

// The maximum number of times *Flussonic* retries to push the stream.
func (s *StreamPushSt2110Impl) SetRetryLimit(v int) StreamPushSt2110 {
	if s == nil {
		return nil
	}
	s.RetryLimitValue = &v
	return s
}

// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
// It is an interval in seconds, 5 seconds by default.
// You can increase this value to reduce server load.
// Format: seconds (seconds)
// Example: 7
func (s StreamPushSt2110Impl) RetryTimeout() *Seconds {
	return s.RetryTimeoutValue
}

// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
// It is an interval in seconds, 5 seconds by default.
// You can increase this value to reduce server load.
// Format: seconds (seconds)
// Example: 7
func (s *StreamPushSt2110Impl) SetRetryTimeout(v Seconds) StreamPushSt2110 {
	if s == nil {
		return nil
	}
	s.RetryTimeoutValue = &v
	return s
}

// Detailed runtime information about the push.
func (s StreamPushSt2110Impl) Stats() PushCounters {
	return s.StatsValue
}

// Detailed runtime information about the push.
func (s *StreamPushSt2110Impl) SetStats(v PushCounters) StreamPushSt2110 {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*PushCountersImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
// Format: seconds (seconds)
// Example: 10
func (s StreamPushSt2110Impl) Timeout() *Seconds {
	return s.TimeoutValue
}

// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
// Format: seconds (seconds)
// Example: 10
func (s *StreamPushSt2110Impl) SetTimeout(v Seconds) StreamPushSt2110 {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// UDP URL of multicast group
// Format: input_url (input_url)
// Pattern: ^st2110?://([^@]+\@)?[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+:[0-9]+.*$
// Examples: st2110://239.0.0.1:1234, st2110://239.0.0.1:1234/192.168.20.24, st2110://eth0@239.0.0.1:1234
func (s StreamPushSt2110Impl) URL() InputURL {
	return s.URLValue
}

// UDP URL of multicast group
// Format: input_url (input_url)
// Pattern: ^st2110?://([^@]+\@)?[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+:[0-9]+.*$
// Examples: st2110://239.0.0.1:1234, st2110://239.0.0.1:1234/192.168.20.24, st2110://eth0@239.0.0.1:1234
func (s *StreamPushSt2110Impl) SetURL(v InputURL) StreamPushSt2110 {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// NewStreamPushTshttp creates a new StreamPushTshttp instance
func NewStreamPushTshttp() StreamPushTshttp {
	return &StreamPushTshttpImpl{}
}

// The bitrate of the whole stream.
// Format: speed (speed)
// Example: 3200
func (s StreamPushTshttpImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// The bitrate of the whole stream.
// Format: speed (speed)
// Example: 3200
func (s *StreamPushTshttpImpl) SetBitrate(v Speed) StreamPushTshttp {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// Human-readable description of the pusher.
// Example: This is a test push
func (s StreamPushTshttpImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the pusher.
// Example: This is a test push
func (s *StreamPushTshttpImpl) SetComment(v string) StreamPushTshttp {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Connection timeout, in seconds. Equals to 0 by default.
// Format: seconds (seconds)
// Example: 2
func (s StreamPushTshttpImpl) ConnectTimeout() *Seconds {
	return s.ConnectTimeoutValue
}

// Connection timeout, in seconds. Equals to 0 by default.
// Format: seconds (seconds)
// Example: 2
func (s *StreamPushTshttpImpl) SetConnectTimeout(v Seconds) StreamPushTshttp {
	if s == nil {
		return nil
	}
	s.ConnectTimeoutValue = &v
	return s
}

// Disable pushing the stream.
// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
// In this way, the URL and other settings of a disabled stream remain in Flussonic.
func (s StreamPushTshttpImpl) Disabled() *bool {
	return s.DisabledValue
}

// Disable pushing the stream.
// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
// In this way, the URL and other settings of a disabled stream remain in Flussonic.
func (s *StreamPushTshttpImpl) SetDisabled(v bool) StreamPushTshttp {
	if s == nil {
		return nil
	}
	s.DisabledValue = &v
	return s
}

// It allows to specify pack information about ac3 for outgoing MPEGTS-TS streams. The default value is `system_b`.
func (s StreamPushTshttpImpl) MpegtsAc3() *OutputMpegtsAc3 {
	return s.MpegtsAc3Value
}

// It allows to specify pack information about ac3 for outgoing MPEGTS-TS streams. The default value is `system_b`.
func (s *StreamPushTshttpImpl) SetMpegtsAc3(v OutputMpegtsAc3) StreamPushTshttp {
	if s == nil {
		return nil
	}
	s.MpegtsAc3Value = &v
	return s
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// It is possible to set PID values for PMT, STD and video and audio tracks.
func (s StreamPushTshttpImpl) Pids() OutputMpegtsPids {
	return s.PidsValue
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// It is possible to set PID values for PMT, STD and video and audio tracks.
func (s *StreamPushTshttpImpl) SetPids(v OutputMpegtsPids) StreamPushTshttp {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*OutputMpegtsPidsImpl); ok {
		s.PidsValue = impl
	}
	return s
}

// Program number in the outgoing MPEG-TS stream. A program may represent a television channel.
func (s StreamPushTshttpImpl) Pnr() *int {
	return s.PnrValue
}

// Program number in the outgoing MPEG-TS stream. A program may represent a television channel.
func (s *StreamPushTshttpImpl) SetPnr(v int) StreamPushTshttp {
	if s == nil {
		return nil
	}
	s.PnrValue = &v
	return s
}

// Provider name. Used to fill in the field service provider within SDT MPEG-TS table.
// Example: My provider name
func (s StreamPushTshttpImpl) Provider() *string {
	return s.ProviderValue
}

// Provider name. Used to fill in the field service provider within SDT MPEG-TS table.
// Example: My provider name
func (s *StreamPushTshttpImpl) SetProvider(v string) StreamPushTshttp {
	if s == nil {
		return nil
	}
	s.ProviderValue = &v
	return s
}

// The maximum number of times *Flussonic* retries to push the stream.
func (s StreamPushTshttpImpl) RetryLimit() *int {
	return s.RetryLimitValue
}

// The maximum number of times *Flussonic* retries to push the stream.
func (s *StreamPushTshttpImpl) SetRetryLimit(v int) StreamPushTshttp {
	if s == nil {
		return nil
	}
	s.RetryLimitValue = &v
	return s
}

// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
// It is an interval in seconds, 5 seconds by default.
// You can increase this value to reduce server load.
// Format: seconds (seconds)
// Example: 7
func (s StreamPushTshttpImpl) RetryTimeout() *Seconds {
	return s.RetryTimeoutValue
}

// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
// It is an interval in seconds, 5 seconds by default.
// You can increase this value to reduce server load.
// Format: seconds (seconds)
// Example: 7
func (s *StreamPushTshttpImpl) SetRetryTimeout(v Seconds) StreamPushTshttp {
	if s == nil {
		return nil
	}
	s.RetryTimeoutValue = &v
	return s
}

// Service name. Used to fill in the field service name within SDT MPEG-TS table.
// Example: My service name
func (s StreamPushTshttpImpl) Service() *string {
	return s.ServiceValue
}

// Service name. Used to fill in the field service name within SDT MPEG-TS table.
// Example: My service name
func (s *StreamPushTshttpImpl) SetService(v string) StreamPushTshttp {
	if s == nil {
		return nil
	}
	s.ServiceValue = &v
	return s
}

// Detailed runtime information about the push.
func (s StreamPushTshttpImpl) Stats() PushCounters {
	return s.StatsValue
}

// Detailed runtime information about the push.
func (s *StreamPushTshttpImpl) SetStats(v PushCounters) StreamPushTshttp {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*PushCountersImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
// Format: seconds (seconds)
// Example: 10
func (s StreamPushTshttpImpl) Timeout() *Seconds {
	return s.TimeoutValue
}

// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
// Format: seconds (seconds)
// Example: 10
func (s *StreamPushTshttpImpl) SetTimeout(v Seconds) StreamPushTshttp {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// Content will be similar to multicast MPEG-TS, but endless HTTP POST will be used to upload content.
// Format: input_url (input_url)
// Pattern: ^tshttps?://.*$
// Examples: tshttp://your-server.com/app/stream1, tshttps://your-server.com/app/stream1
func (s StreamPushTshttpImpl) URL() InputURL {
	return s.URLValue
}

// Content will be similar to multicast MPEG-TS, but endless HTTP POST will be used to upload content.
// Format: input_url (input_url)
// Pattern: ^tshttps?://.*$
// Examples: tshttp://your-server.com/app/stream1, tshttps://your-server.com/app/stream1
func (s *StreamPushTshttpImpl) SetURL(v InputURL) StreamPushTshttp {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// Average bitrate per second that you can send of a video track, including all the headers and encapsulation in the transport stream.
// So, for example, the value of vb=2720 approximately corresponds to the bitrate 2600 specified in the transcoder settings.
// Format: speed (speed)
// Example: 2720
func (s StreamPushTshttpImpl) Vb() *Speed {
	return s.VbValue
}

// Average bitrate per second that you can send of a video track, including all the headers and encapsulation in the transport stream.
// So, for example, the value of vb=2720 approximately corresponds to the bitrate 2600 specified in the transcoder settings.
// Format: speed (speed)
// Example: 2720
func (s *StreamPushTshttpImpl) SetVb(v Speed) StreamPushTshttp {
	if s == nil {
		return nil
	}
	s.VbValue = &v
	return s
}

// NewStreamPushUDP creates a new StreamPushUDP instance
func NewStreamPushUDP() StreamPushUDP {
	return &StreamPushUDPImpl{}
}

// The bitrate of the whole stream.
// Format: speed (speed)
// Example: 3200
func (s StreamPushUDPImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// The bitrate of the whole stream.
// Format: speed (speed)
// Example: 3200
func (s *StreamPushUDPImpl) SetBitrate(v Speed) StreamPushUDP {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// Human-readable description of the pusher.
// Example: This is a test push
func (s StreamPushUDPImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the pusher.
// Example: This is a test push
func (s *StreamPushUDPImpl) SetComment(v string) StreamPushUDP {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Connection timeout, in seconds. Equals to 0 by default.
// Format: seconds (seconds)
// Example: 2
func (s StreamPushUDPImpl) ConnectTimeout() *Seconds {
	return s.ConnectTimeoutValue
}

// Connection timeout, in seconds. Equals to 0 by default.
// Format: seconds (seconds)
// Example: 2
func (s *StreamPushUDPImpl) SetConnectTimeout(v Seconds) StreamPushUDP {
	if s == nil {
		return nil
	}
	s.ConnectTimeoutValue = &v
	return s
}

// Disable pushing the stream.
// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
// In this way, the URL and other settings of a disabled stream remain in Flussonic.
func (s StreamPushUDPImpl) Disabled() *bool {
	return s.DisabledValue
}

// Disable pushing the stream.
// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
// In this way, the URL and other settings of a disabled stream remain in Flussonic.
func (s *StreamPushUDPImpl) SetDisabled(v bool) StreamPushUDP {
	if s == nil {
		return nil
	}
	s.DisabledValue = &v
	return s
}

// It allows to specify pack information about ac3 for outgoing MPEGTS-TS streams. The default value is `system_b`.
func (s StreamPushUDPImpl) MpegtsAc3() *OutputMpegtsAc3 {
	return s.MpegtsAc3Value
}

// It allows to specify pack information about ac3 for outgoing MPEGTS-TS streams. The default value is `system_b`.
func (s *StreamPushUDPImpl) SetMpegtsAc3(v OutputMpegtsAc3) StreamPushUDP {
	if s == nil {
		return nil
	}
	s.MpegtsAc3Value = &v
	return s
}

// Whether to capture multicast back to the *Flussonic* host.
// This option allows you to ingest the sent stream on the sending host by *Flussonic* or other application.
// Set to `True` for a UDP MPEG-TS push.
// Example: true
func (s StreamPushUDPImpl) MulticastLoop() *bool {
	return s.MulticastLoopValue
}

// Whether to capture multicast back to the *Flussonic* host.
// This option allows you to ingest the sent stream on the sending host by *Flussonic* or other application.
// Set to `True` for a UDP MPEG-TS push.
// Example: true
func (s *StreamPushUDPImpl) SetMulticastLoop(v bool) StreamPushUDP {
	if s == nil {
		return nil
	}
	s.MulticastLoopValue = &v
	return s
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// It is possible to set PID values for PMT, STD and video and audio tracks.
func (s StreamPushUDPImpl) Pids() OutputMpegtsPids {
	return s.PidsValue
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// It is possible to set PID values for PMT, STD and video and audio tracks.
func (s *StreamPushUDPImpl) SetPids(v OutputMpegtsPids) StreamPushUDP {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*OutputMpegtsPidsImpl); ok {
		s.PidsValue = impl
	}
	return s
}

// Program number in the outgoing MPEG-TS stream. A program may represent a television channel.
func (s StreamPushUDPImpl) Pnr() *int {
	return s.PnrValue
}

// Program number in the outgoing MPEG-TS stream. A program may represent a television channel.
func (s *StreamPushUDPImpl) SetPnr(v int) StreamPushUDP {
	if s == nil {
		return nil
	}
	s.PnrValue = &v
	return s
}

// Provider name. Used to fill in the field service provider within SDT MPEG-TS table.
// Example: My provider name
func (s StreamPushUDPImpl) Provider() *string {
	return s.ProviderValue
}

// Provider name. Used to fill in the field service provider within SDT MPEG-TS table.
// Example: My provider name
func (s *StreamPushUDPImpl) SetProvider(v string) StreamPushUDP {
	if s == nil {
		return nil
	}
	s.ProviderValue = &v
	return s
}

// The maximum number of times *Flussonic* retries to push the stream.
func (s StreamPushUDPImpl) RetryLimit() *int {
	return s.RetryLimitValue
}

// The maximum number of times *Flussonic* retries to push the stream.
func (s *StreamPushUDPImpl) SetRetryLimit(v int) StreamPushUDP {
	if s == nil {
		return nil
	}
	s.RetryLimitValue = &v
	return s
}

// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
// It is an interval in seconds, 5 seconds by default.
// You can increase this value to reduce server load.
// Format: seconds (seconds)
// Example: 7
func (s StreamPushUDPImpl) RetryTimeout() *Seconds {
	return s.RetryTimeoutValue
}

// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
// It is an interval in seconds, 5 seconds by default.
// You can increase this value to reduce server load.
// Format: seconds (seconds)
// Example: 7
func (s *StreamPushUDPImpl) SetRetryTimeout(v Seconds) StreamPushUDP {
	if s == nil {
		return nil
	}
	s.RetryTimeoutValue = &v
	return s
}

// Service name. Used to fill in the field service name within SDT MPEG-TS table.
// Example: My service name
func (s StreamPushUDPImpl) Service() *string {
	return s.ServiceValue
}

// Service name. Used to fill in the field service name within SDT MPEG-TS table.
// Example: My service name
func (s *StreamPushUDPImpl) SetService(v string) StreamPushUDP {
	if s == nil {
		return nil
	}
	s.ServiceValue = &v
	return s
}

// Monitoring multicast group and stop pushing if another publisher presented
func (s StreamPushUDPImpl) Standby() *bool {
	return s.StandbyValue
}

// Monitoring multicast group and stop pushing if another publisher presented
func (s *StreamPushUDPImpl) SetStandby(v bool) StreamPushUDP {
	if s == nil {
		return nil
	}
	s.StandbyValue = &v
	return s
}

// Detailed runtime information about the push.
func (s StreamPushUDPImpl) Stats() PushCounters {
	return s.StatsValue
}

// Detailed runtime information about the push.
func (s *StreamPushUDPImpl) SetStats(v PushCounters) StreamPushUDP {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*PushCountersImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
// Format: seconds (seconds)
// Example: 10
func (s StreamPushUDPImpl) Timeout() *Seconds {
	return s.TimeoutValue
}

// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
// Format: seconds (seconds)
// Example: 10
func (s *StreamPushUDPImpl) SetTimeout(v Seconds) StreamPushUDP {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// UDP URL of multicast group
// Format: input_url (input_url)
// Pattern: ^udp[12]?://([^@]+\@)?[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+:[0-9]+.*$
// Examples: udp://239.0.0.1:1234, udp://239.0.0.1:1234/192.168.20.24, udp://eth0@239.0.0.1:1234
func (s StreamPushUDPImpl) URL() InputURL {
	return s.URLValue
}

// UDP URL of multicast group
// Format: input_url (input_url)
// Pattern: ^udp[12]?://([^@]+\@)?[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+:[0-9]+.*$
// Examples: udp://239.0.0.1:1234, udp://239.0.0.1:1234/192.168.20.24, udp://eth0@239.0.0.1:1234
func (s *StreamPushUDPImpl) SetURL(v InputURL) StreamPushUDP {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// Average bitrate per second that you can send of a video track, including all the headers and encapsulation in the transport stream.
// So, for example, the value of vb=2720 approximately corresponds to the bitrate 2600 specified in the transcoder settings.
// Format: speed (speed)
// Example: 2720
func (s StreamPushUDPImpl) Vb() *Speed {
	return s.VbValue
}

// Average bitrate per second that you can send of a video track, including all the headers and encapsulation in the transport stream.
// So, for example, the value of vb=2720 approximately corresponds to the bitrate 2600 specified in the transcoder settings.
// Format: speed (speed)
// Example: 2720
func (s *StreamPushUDPImpl) SetVb(v Speed) StreamPushUDP {
	if s == nil {
		return nil
	}
	s.VbValue = &v
	return s
}

// NewStreamPushUDPBase creates a new StreamPushUDPBase instance
func NewStreamPushUDPBase() StreamPushUDPBase {
	return &StreamPushUDPBaseImpl{}
}

// Whether to capture multicast back to the *Flussonic* host.
// This option allows you to ingest the sent stream on the sending host by *Flussonic* or other application.
// Set to `True` for a UDP MPEG-TS push.
// Example: true
func (s StreamPushUDPBaseImpl) MulticastLoop() *bool {
	return s.MulticastLoopValue
}

// Whether to capture multicast back to the *Flussonic* host.
// This option allows you to ingest the sent stream on the sending host by *Flussonic* or other application.
// Set to `True` for a UDP MPEG-TS push.
// Example: true
func (s *StreamPushUDPBaseImpl) SetMulticastLoop(v bool) StreamPushUDPBase {
	if s == nil {
		return nil
	}
	s.MulticastLoopValue = &v
	return s
}

// Monitoring multicast group and stop pushing if another publisher presented
func (s StreamPushUDPBaseImpl) Standby() *bool {
	return s.StandbyValue
}

// Monitoring multicast group and stop pushing if another publisher presented
func (s *StreamPushUDPBaseImpl) SetStandby(v bool) StreamPushUDPBase {
	if s == nil {
		return nil
	}
	s.StandbyValue = &v
	return s
}

// NewStreamStats creates a new StreamStats instance
func NewStreamStats() StreamStats {
	return &StreamStatsImpl{}
}

// The status of the Agent serving the stream.
func (s StreamStatsImpl) AgentStatus() *string {
	return s.AgentStatusValue
}

// The status of the Agent serving the stream.
func (s *StreamStatsImpl) SetAgentStatus(v string) StreamStats {
	if s == nil {
		return nil
	}
	s.AgentStatusValue = &v
	return s
}

// Becomes `false` when `ts_delay` > 12000 (= 12 seconds)
// Example: true
func (s StreamStatsImpl) Alive() *bool {
	return s.AliveValue
}

// Becomes `false` when `ts_delay` > 12000 (= 12 seconds)
// Example: true
func (s *StreamStatsImpl) SetAlive(v bool) StreamStats {
	if s == nil {
		return nil
	}
	s.AliveValue = &v
	return s
}

// Stream bitrate.
// Format: speed (speed)
// Example: 186
func (s StreamStatsImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// Stream bitrate.
// Format: speed (speed)
// Example: 186
func (s *StreamStatsImpl) SetBitrate(v Speed) StreamStats {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// The amount of stream data sent to the clients.
// Format: bytes (bytes)
// Example: 0
func (s StreamStatsImpl) BytesOut() *Bytes {
	return s.BytesOutValue
}

// The amount of stream data sent to the clients.
// Format: bytes (bytes)
// Example: 0
func (s *StreamStatsImpl) SetBytesOut(v Bytes) StreamStats {
	if s == nil {
		return nil
	}
	s.BytesOutValue = &v
	return s
}

// The identifier of the Agent that is currently serving the stream.
// Format: agent_id (agent_id)
func (s StreamStatsImpl) CurrentAgentID() *AgentID {
	return s.CurrentAgentIDValue
}

// The identifier of the Agent that is currently serving the stream.
// Format: agent_id (agent_id)
func (s *StreamStatsImpl) SetCurrentAgentID(v AgentID) StreamStats {
	if s == nil {
		return nil
	}
	s.CurrentAgentIDValue = &v
	return s
}

// The information about the recorded DVR archive.
func (s StreamStatsImpl) DvrInfo() DvrInfo {
	return s.DvrInfoValue
}

// The information about the recorded DVR archive.
func (s *StreamStatsImpl) SetDvrInfo(v DvrInfo) StreamStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*DvrInfoImpl); ok {
		s.DvrInfoValue = impl
	}
	return s
}

// The ratio of the total duration of episodes to the total observation time.
// A value between 0 and 1 indicating the proportion of time occupied by episodes.
// For example, 0.75 means that 75% of the time (or 2700 seconds out of 3600) is covered by episodes.
// Format: float (float)
// Example: 0.001
func (s StreamStatsImpl) EpisodesDensity() *Float {
	return s.EpisodesDensityValue
}

// The ratio of the total duration of episodes to the total observation time.
// A value between 0 and 1 indicating the proportion of time occupied by episodes.
// For example, 0.75 means that 75% of the time (or 2700 seconds out of 3600) is covered by episodes.
// Format: float (float)
// Example: 0.001
func (s *StreamStatsImpl) SetEpisodesDensity(v Float) StreamStats {
	if s == nil {
		return nil
	}
	s.EpisodesDensityValue = &v
	return s
}

// The time when the last time frame was sent to the stream output (in UTC).
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.636383841974e+12
func (s StreamStatsImpl) LastDtsAt() *UtcMs {
	return s.LastDtsAtValue
}

// The time when the last time frame was sent to the stream output (in UTC).
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.636383841974e+12
func (s *StreamStatsImpl) SetLastDtsAt(v UtcMs) StreamStats {
	if s == nil {
		return nil
	}
	s.LastDtsAtValue = &v
	return s
}

// The last time when the stream was running.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.737975543123e+12
func (s StreamStatsImpl) LastRunningAt() *UtcMs {
	return s.LastRunningAtValue
}

// The last time when the stream was running.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.737975543123e+12
func (s *StreamStatsImpl) SetLastRunningAt(v UtcMs) StreamStats {
	if s == nil {
		return nil
	}
	s.LastRunningAtValue = &v
	return s
}

// The time period in seconds during which the stream is being captured.
// Can be calculated from `opened_at`
// Format: milliseconds (milliseconds)
// Example: 71977
func (s StreamStatsImpl) Lifetime() *Milliseconds {
	return s.LifetimeValue
}

// The time period in seconds during which the stream is being captured.
// Can be calculated from `opened_at`
// Format: milliseconds (milliseconds)
// Example: 71977
func (s *StreamStatsImpl) SetLifetime(v Milliseconds) StreamStats {
	if s == nil {
		return nil
	}
	s.LifetimeValue = &v
	return s
}

// Technical information about the output media content.
func (s StreamStatsImpl) MediaInfo() MediaInfo {
	return s.MediaInfoValue
}

// Technical information about the output media content.
func (s *StreamStatsImpl) SetMediaInfo(v MediaInfo) StreamStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*MediaInfoImpl); ok {
		s.MediaInfoValue = impl
	}
	return s
}

// Deprecated field. Will be deleted at 25.04
// The number of clients receiving the stream.
// Use play.play_opened_sessions instead
// Format: client_count (client_count)
// Example: 3
func (s StreamStatsImpl) OnlineClients() *ClientCount {
	return s.OnlineClientsValue
}

// Deprecated field. Will be deleted at 25.04
// The number of clients receiving the stream.
// Use play.play_opened_sessions instead
// Format: client_count (client_count)
// Example: 3
func (s *StreamStatsImpl) SetOnlineClients(v ClientCount) StreamStats {
	if s == nil {
		return nil
	}
	s.OnlineClientsValue = &v
	return s
}

// List of servers hostnames where the stream is running on.
// Example: [streamer1.example.com]
func (s StreamStatsImpl) RunningOn() []ServerName {
	return s.RunningOnValue
}

// List of servers hostnames where the stream is running on.
// Example: [streamer1.example.com]
func (s *StreamStatsImpl) SetRunningOn(v []ServerName) StreamStats {
	if s == nil {
		return nil
	}
	s.RunningOnValue = v
	return s
}

// Indicates the status of the stream.
func (s StreamStatsImpl) Status() *StreamStatus {
	return s.StatusValue
}

// Indicates the status of the stream.
func (s *StreamStatsImpl) SetStatus(v StreamStatus) StreamStats {
	if s == nil {
		return nil
	}
	s.StatusValue = &v
	return s
}

// HTTP(s) URL that can be used for streaming API of this stream
func (s StreamStatsImpl) StreamingEndpoint() *string {
	return s.StreamingEndpointValue
}

// HTTP(s) URL that can be used for streaming API of this stream
func (s *StreamStatsImpl) SetStreamingEndpoint(v string) StreamStats {
	if s == nil {
		return nil
	}
	s.StreamingEndpointValue = &v
	return s
}

// The time period during which no frames were received from the stream's input.
// Format: ticks (ticks)
// Example: 1284
func (s StreamStatsImpl) TSDelay() *Ticks {
	return s.TSDelayValue
}

// The time period during which no frames were received from the stream's input.
// Format: ticks (ticks)
// Example: 1284
func (s *StreamStatsImpl) SetTSDelay(v Ticks) StreamStats {
	if s == nil {
		return nil
	}
	s.TSDelayValue = &v
	return s
}

// NewStreamerConfig creates a new StreamerConfig instance
func NewStreamerConfig() StreamerConfig {
	return &StreamerConfigImpl{}
}

// The URL for provisioning of configuration from the managing server to the streamer.
// This URL does not have to be public but must be accessible from the managing server.
// The API URL can also be used as Public and/or Private payload URL if they are not set.
// When used as Public payload URL, the API URL shall be public to allow playback from this streamer.
// Format: url (url)
// Example: http://streamer.local:8080
func (s StreamerConfigImpl) APIURL() *URL {
	return s.APIURLValue
}

// The URL for provisioning of configuration from the managing server to the streamer.
// This URL does not have to be public but must be accessible from the managing server.
// The API URL can also be used as Public and/or Private payload URL if they are not set.
// When used as Public payload URL, the API URL shall be public to allow playback from this streamer.
// Format: url (url)
// Example: http://streamer.local:8080
func (s *StreamerConfigImpl) SetAPIURL(v URL) StreamerConfig {
	if s == nil {
		return nil
	}
	s.APIURLValue = &v
	return s
}

// Maximal number of streams.
// Example: 5
func (s StreamerConfigImpl) ChannelLimit() *int {
	return s.ChannelLimitValue
}

// Maximal number of streams.
// Example: 5
func (s *StreamerConfigImpl) SetChannelLimit(v int) StreamerConfig {
	if s == nil {
		return nil
	}
	s.ChannelLimitValue = &v
	return s
}

// The key for authorization for inter-Flussonic connections.
// All cluster peers should have the same cluster key.
// Example: xS6i6Q3DCc5nEvnu
func (s StreamerConfigImpl) ClusterKey() *string {
	return s.ClusterKeyValue
}

// The key for authorization for inter-Flussonic connections.
// All cluster peers should have the same cluster key.
// Example: xS6i6Q3DCc5nEvnu
func (s *StreamerConfigImpl) SetClusterKey(v string) StreamerConfig {
	if s == nil {
		return nil
	}
	s.ClusterKeyValue = &v
	return s
}

// Flussonic Media Server configuration which will be provided to Streamer
func (s StreamerConfigImpl) Config() CentralStreamerNodeConfig {
	return s.ConfigValue
}

// Flussonic Media Server configuration which will be provided to Streamer
func (s *StreamerConfigImpl) SetConfig(v CentralStreamerNodeConfig) StreamerConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*CentralStreamerNodeConfigImpl); ok {
		s.ConfigValue = impl
	}
	return s
}

// CPU limit in percents.
// Format: percent (percent)
// Example: 10
func (s StreamerConfigImpl) CpuLimit() *Percent {
	return s.CpuLimitValue
}

// CPU limit in percents.
// Format: percent (percent)
// Example: 10
func (s *StreamerConfigImpl) SetCpuLimit(v Percent) StreamerConfig {
	if s == nil {
		return nil
	}
	s.CpuLimitValue = &v
	return s
}

// The configuration of the DVRs
func (s StreamerConfigImpl) Dvrs() []DvrConfig {
	if s.DvrsValue == nil {
		return nil
	}
	result := make([]DvrConfig, len(s.DvrsValue))
	for i, item := range s.DvrsValue {
		result[i] = item
	}
	return result
}

// The configuration of the DVRs
func (s *StreamerConfigImpl) SetDvrs(v []DvrConfig) StreamerConfig {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*DvrConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*DvrConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.DvrsValue = impl
	}
	return s
}

// How often the peer will try to get the data from the remote server via internal API.
// Format: milliseconds (milliseconds)
// Example: 1000
func (s StreamerConfigImpl) FetchTimeout() *Milliseconds {
	return s.FetchTimeoutValue
}

// How often the peer will try to get the data from the remote server via internal API.
// Format: milliseconds (milliseconds)
// Example: 1000
func (s *StreamerConfigImpl) SetFetchTimeout(v Milliseconds) StreamerConfig {
	if s == nil {
		return nil
	}
	s.FetchTimeoutValue = &v
	return s
}

// Streamer's identifier in the cluster.
// The managing server may try using this hostname to access the streamer
// if API URL is not specified.
// Format: server_name (server_name)
// Example: peer.example.com
func (s StreamerConfigImpl) Hostname() *ServerName {
	return s.HostnameValue
}

// Streamer's identifier in the cluster.
// The managing server may try using this hostname to access the streamer
// if API URL is not specified.
// Format: server_name (server_name)
// Example: peer.example.com
func (s *StreamerConfigImpl) SetHostname(v ServerName) StreamerConfig {
	if s == nil {
		return nil
	}
	s.HostnameValue = &v
	return s
}

// Flag indicating the Streamer's ability to act as a restreamer.
// See [dynamic_streams_list](https://flussonic.com/doc/api/config-external/#tag/stream/operation/dynamic_streams_list)
// operation for more info
func (s StreamerConfigImpl) IsRestreamer() *bool {
	return s.IsRestreamerValue
}

// Flag indicating the Streamer's ability to act as a restreamer.
// See [dynamic_streams_list](https://flussonic.com/doc/api/config-external/#tag/stream/operation/dynamic_streams_list)
// operation for more info
func (s *StreamerConfigImpl) SetIsRestreamer(v bool) StreamerConfig {
	if s == nil {
		return nil
	}
	s.IsRestreamerValue = &v
	return s
}

func (s StreamerConfigImpl) Labels() map[string]UnixName {
	return s.LabelsValue
}

func (s *StreamerConfigImpl) SetLabels(v map[string]UnixName) StreamerConfig {
	if s == nil {
		return nil
	}
	s.LabelsValue = v
	return s
}

// Deprecated field. Will be deleted at 23.09
// Maximal output bitrate of the peer.
// Format: speed (speed)
func (s StreamerConfigImpl) MaxBitrate() *Speed {
	return s.MaxBitrateValue
}

// Deprecated field. Will be deleted at 23.09
// Maximal output bitrate of the peer.
// Format: speed (speed)
func (s *StreamerConfigImpl) SetMaxBitrate(v Speed) StreamerConfig {
	if s == nil {
		return nil
	}
	s.MaxBitrateValue = &v
	return s
}

// Streamer's logical namespace, used for interacting with streams of the same namespace. By default, a streamer has no assigned namespace. In this default state, it can interact with streams that also have no assigned namespace. If a namespace is explicitly set, the streamer will only interact with streams possessing that specific namespace.
// For example, the layouter will distribute streams only to streamers with the same namespace. The `dynamic_streams_list` endpoint will operate exclusively within a single namespace.
// ***Use case:***
// Namespaces provide strict, system-wide resource isolation, fundamentally separating streams and streamers into independent segments. This ensures no interaction, archive access, inference processing, or layout operations occur between different namespaces.
// Unlike labels, which offer flexible, attribute-based layout control within a namespace, namespaces define an absolute boundary: resources from one namespace cannot interact with resources from another.
// ***Important:***
// A namespace can only be assigned when the streamer is created and cannot be changed afterwards.
// Format: unix_name (Contains only alphanumeric characters (a-z, A-Z, 0-9), underscores (_), hyphens (-) and periods (.).)
// Pattern: ^[a-zA-Z0-9_.-]+$
// Example: example
func (s StreamerConfigImpl) Namespace() *UnixName {
	return s.NamespaceValue
}

// Streamer's logical namespace, used for interacting with streams of the same namespace. By default, a streamer has no assigned namespace. In this default state, it can interact with streams that also have no assigned namespace. If a namespace is explicitly set, the streamer will only interact with streams possessing that specific namespace.
// For example, the layouter will distribute streams only to streamers with the same namespace. The `dynamic_streams_list` endpoint will operate exclusively within a single namespace.
// ***Use case:***
// Namespaces provide strict, system-wide resource isolation, fundamentally separating streams and streamers into independent segments. This ensures no interaction, archive access, inference processing, or layout operations occur between different namespaces.
// Unlike labels, which offer flexible, attribute-based layout control within a namespace, namespaces define an absolute boundary: resources from one namespace cannot interact with resources from another.
// ***Important:***
// A namespace can only be assigned when the streamer is created and cannot be changed afterwards.
// Format: unix_name (Contains only alphanumeric characters (a-z, A-Z, 0-9), underscores (_), hyphens (-) and periods (.).)
// Pattern: ^[a-zA-Z0-9_.-]+$
// Example: example
func (s *StreamerConfigImpl) SetNamespace(v UnixName) StreamerConfig {
	if s == nil {
		return nil
	}
	s.NamespaceValue = &v
	return s
}

// The internal address for communication in a local network (by default, it is equal to API URL).
// Format: url (url)
// Example: http://streamer.local
func (s StreamerConfigImpl) PrivatePayloadURL() *URL {
	return s.PrivatePayloadURLValue
}

// The internal address for communication in a local network (by default, it is equal to API URL).
// Format: url (url)
// Example: http://streamer.local
func (s *StreamerConfigImpl) SetPrivatePayloadURL(v URL) StreamerConfig {
	if s == nil {
		return nil
	}
	s.PrivatePayloadURLValue = &v
	return s
}

// The public address that is exposed to clients. It can also contain a port number.
// The client will be redirected to this URL and port when requesting for the stream captured on the peer
// even if other `http` port is set in the peer's own config.
// Format: url (url)
// Example: http://public.example.com
func (s StreamerConfigImpl) PublicPayloadURL() *URL {
	return s.PublicPayloadURLValue
}

// The public address that is exposed to clients. It can also contain a port number.
// The client will be redirected to this URL and port when requesting for the stream captured on the peer
// even if other `http` port is set in the peer's own config.
// Format: url (url)
// Example: http://public.example.com
func (s *StreamerConfigImpl) SetPublicPayloadURL(v URL) StreamerConfig {
	if s == nil {
		return nil
	}
	s.PublicPayloadURLValue = &v
	return s
}

// Role of node
func (s StreamerConfigImpl) Role() *CentralNodeRoleRole {
	return s.RoleValue
}

// Role of node
func (s *StreamerConfigImpl) SetRole(v CentralNodeRoleRole) StreamerConfig {
	if s == nil {
		return nil
	}
	s.RoleValue = &v
	return s
}

// The time after which deleted streams on this server are considered to be inactive
// and cannot be used in the `cluster_ingest` mechanism.
// Format: milliseconds (milliseconds)
// Example: 1000
func (s StreamerConfigImpl) StaleTimeout() *Milliseconds {
	return s.StaleTimeoutValue
}

// The time after which deleted streams on this server are considered to be inactive
// and cannot be used in the `cluster_ingest` mechanism.
// Format: milliseconds (milliseconds)
// Example: 1000
func (s *StreamerConfigImpl) SetStaleTimeout(v Milliseconds) StreamerConfig {
	if s == nil {
		return nil
	}
	s.StaleTimeoutValue = &v
	return s
}

// Statistics on peers in the cluster.
func (s StreamerConfigImpl) Stats() PeerStats {
	return s.StatsValue
}

// Statistics on peers in the cluster.
func (s *StreamerConfigImpl) SetStats(v PeerStats) StreamerConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*PeerStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// Server network bandwidth limit in kbit.
// This value is used to calculate the current network load status.
// Format: speed (speed)
// Example: 1024
func (s StreamerConfigImpl) TotalBandwidth() *Speed {
	return s.TotalBandwidthValue
}

// Server network bandwidth limit in kbit.
// This value is used to calculate the current network load status.
// Format: speed (speed)
// Example: 1024
func (s *StreamerConfigImpl) SetTotalBandwidth(v Speed) StreamerConfig {
	if s == nil {
		return nil
	}
	s.TotalBandwidthValue = &v
	return s
}

// NewStreamersList creates a new StreamersList instance
func NewStreamersList() StreamersList {
	return &StreamersListImpl{}
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s StreamersListImpl) EstimatedCount() *int {
	return s.EstimatedCountValue
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s *StreamersListImpl) SetEstimatedCount(v int) StreamersList {
	if s == nil {
		return nil
	}
	s.EstimatedCountValue = &v
	return s
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s StreamersListImpl) Next() *string {
	return s.NextValue
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s *StreamersListImpl) SetNext(v string) StreamersList {
	if s == nil {
		return nil
	}
	s.NextValue = &v
	return s
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s StreamersListImpl) Prev() *string {
	return s.PrevValue
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s *StreamersListImpl) SetPrev(v string) StreamersList {
	if s == nil {
		return nil
	}
	s.PrevValue = &v
	return s
}

// The list of streamers fetched according to the query parameters.
func (s StreamersListImpl) Streamers() []StreamerConfig {
	if s.StreamersValue == nil {
		return nil
	}
	result := make([]StreamerConfig, len(s.StreamersValue))
	for i, item := range s.StreamersValue {
		result[i] = item
	}
	return result
}

// The list of streamers fetched according to the query parameters.
func (s *StreamersListImpl) SetStreamers(v []StreamerConfig) StreamersList {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*StreamerConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*StreamerConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.StreamersValue = impl
	}
	return s
}

// An object with a list of different timings measured during this API call.
func (s StreamersListImpl) Timing() any {
	return s.TimingValue
}

// An object with a list of different timings measured during this API call.
func (s *StreamersListImpl) SetTiming(v any) StreamersList {
	if s == nil {
		return nil
	}
	s.TimingValue = v
	return s
}

// Collection returns the collection items from StreamersList
func (s StreamersListImpl) Collection() []StreamerConfig {
	return s.Streamers()
}

// NewStreamsList creates a new StreamsList instance
func NewStreamsList() StreamsList {
	return &StreamsListImpl{}
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s StreamsListImpl) EstimatedCount() *int {
	return s.EstimatedCountValue
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s *StreamsListImpl) SetEstimatedCount(v int) StreamsList {
	if s == nil {
		return nil
	}
	s.EstimatedCountValue = &v
	return s
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s StreamsListImpl) Next() *string {
	return s.NextValue
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s *StreamsListImpl) SetNext(v string) StreamsList {
	if s == nil {
		return nil
	}
	s.NextValue = &v
	return s
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s StreamsListImpl) Prev() *string {
	return s.PrevValue
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s *StreamsListImpl) SetPrev(v string) StreamsList {
	if s == nil {
		return nil
	}
	s.PrevValue = &v
	return s
}

// List of fetched streams according to the query parameters.
func (s StreamsListImpl) Streams() []StreamConfig {
	if s.StreamsValue == nil {
		return nil
	}
	result := make([]StreamConfig, len(s.StreamsValue))
	for i, item := range s.StreamsValue {
		result[i] = item
	}
	return result
}

// List of fetched streams according to the query parameters.
func (s *StreamsListImpl) SetStreams(v []StreamConfig) StreamsList {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*StreamConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*StreamConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.StreamsValue = impl
	}
	return s
}

// An object with a list of different timings measured during this API call.
func (s StreamsListImpl) Timing() any {
	return s.TimingValue
}

// An object with a list of different timings measured during this API call.
func (s *StreamsListImpl) SetTiming(v any) StreamsList {
	if s == nil {
		return nil
	}
	s.TimingValue = v
	return s
}

// Time of last configuration updated in ms.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.727274724e+12
func (s StreamsListImpl) UpdatedAt() *UtcMs {
	return s.UpdatedAtValue
}

// Time of last configuration updated in ms.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.727274724e+12
func (s *StreamsListImpl) SetUpdatedAt(v UtcMs) StreamsList {
	if s == nil {
		return nil
	}
	s.UpdatedAtValue = &v
	return s
}

// Collection returns the collection items from StreamsList
func (s StreamsListImpl) Collection() []StreamConfig {
	return s.Streams()
}

// NewTcAudioAac creates a new TcAudioAac instance
func NewTcAudioAac() TcAudioAac {
	return &TcAudioAacImpl{}
}

// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
// If it is just an integer or a float, the output audio volume is calculated by this formula:
// `output_volume = avol * input_volume`
// If specified in decibels (dB), the output audio volume is calculated as follows:
// `output_volume = input_volume +/- avol`
// depending whether it is a positive (+9dB) or a negative value (-6dB).
// By default it equals to 1 (the input audio volume).
// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
// Example: -6dB
func (s TcAudioAacImpl) Avol() *string {
	return s.AvolValue
}

// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
// If it is just an integer or a float, the output audio volume is calculated by this formula:
// `output_volume = avol * input_volume`
// If specified in decibels (dB), the output audio volume is calculated as follows:
// `output_volume = input_volume +/- avol`
// depending whether it is a positive (+9dB) or a negative value (-6dB).
// By default it equals to 1 (the input audio volume).
// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
// Example: -6dB
func (s *TcAudioAacImpl) SetAvol(v string) TcAudioAac {
	if s == nil {
		return nil
	}
	s.AvolValue = &v
	return s
}

// Audio bitrate. The allowed values are:
// * `copy` - the bitrate or the original stream is copied to the outgoing stream.
// * a full number of bits (e.g., 64000) or a short form of the number with `k` (e.g., 64k).
// Example: 64000
func (s TcAudioAacImpl) Bitrate() *TcBitrate {
	return s.BitrateValue
}

// Audio bitrate. The allowed values are:
// * `copy` - the bitrate or the original stream is copied to the outgoing stream.
// * a full number of bits (e.g., 64000) or a short form of the number with `k` (e.g., 64k).
// Example: 64000
func (s *TcAudioAacImpl) SetBitrate(v *TcBitrate) TcAudioAac {
	if s == nil {
		return nil
	}
	s.BitrateValue = v
	return s
}

// The number of audio channels in an output stream.
// Example: 2
func (s TcAudioAacImpl) Channels() *TiAudioAacSpecChannels {
	return s.ChannelsValue
}

// The number of audio channels in an output stream.
// Example: 2
func (s *TcAudioAacImpl) SetChannels(v TiAudioAacSpecChannels) TcAudioAac {
	if s == nil {
		return nil
	}
	s.ChannelsValue = &v
	return s
}

// Audio codec (the AAC codec is used by default).
// Example: opus
func (s TcAudioAacImpl) Codec() *string {
	return s.CodecValue
}

// Audio codec (the AAC codec is used by default).
// Example: opus
func (s *TcAudioAacImpl) SetCodec(v string) TcAudioAac {
	if s == nil {
		return nil
	}
	s.CodecValue = &v
	return s
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// The allowed values are:
// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
// Example: 48000
func (s TcAudioAacImpl) SampleRate() *TiAudioAacSpecSampleRate {
	return s.SampleRateValue
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// The allowed values are:
// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
// Example: 48000
func (s *TcAudioAacImpl) SetSampleRate(v TiAudioAacSpecSampleRate) TcAudioAac {
	if s == nil {
		return nil
	}
	s.SampleRateValue = &v
	return s
}

// This option allows to split each audio track with multiple channels into several mono tracks.
func (s TcAudioAacImpl) SplitChannels() *bool {
	return s.SplitChannelsValue
}

// This option allows to split each audio track with multiple channels into several mono tracks.
func (s *TcAudioAacImpl) SetSplitChannels(v bool) TcAudioAac {
	if s == nil {
		return nil
	}
	s.SplitChannelsValue = &v
	return s
}

// NewTcAudioAc3 creates a new TcAudioAc3 instance
func NewTcAudioAc3() TcAudioAc3 {
	return &TcAudioAc3Impl{}
}

// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
// If it is just an integer or a float, the output audio volume is calculated by this formula:
// `output_volume = avol * input_volume`
// If specified in decibels (dB), the output audio volume is calculated as follows:
// `output_volume = input_volume +/- avol`
// depending whether it is a positive (+9dB) or a negative value (-6dB).
// By default it equals to 1 (the input audio volume).
// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
// Example: -6dB
func (s TcAudioAc3Impl) Avol() *string {
	return s.AvolValue
}

// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
// If it is just an integer or a float, the output audio volume is calculated by this formula:
// `output_volume = avol * input_volume`
// If specified in decibels (dB), the output audio volume is calculated as follows:
// `output_volume = input_volume +/- avol`
// depending whether it is a positive (+9dB) or a negative value (-6dB).
// By default it equals to 1 (the input audio volume).
// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
// Example: -6dB
func (s *TcAudioAc3Impl) SetAvol(v string) TcAudioAc3 {
	if s == nil {
		return nil
	}
	s.AvolValue = &v
	return s
}

// Audio bitrate. The allowed values are:
// * `copy` - the bitrate or the original stream is copied to the outgoing stream.
// * a full number of bits (e.g., 64000) or a short form of the number with `k` (e.g., 64k).
// Example: 64000
func (s TcAudioAc3Impl) Bitrate() *TcBitrate {
	return s.BitrateValue
}

// Audio bitrate. The allowed values are:
// * `copy` - the bitrate or the original stream is copied to the outgoing stream.
// * a full number of bits (e.g., 64000) or a short form of the number with `k` (e.g., 64k).
// Example: 64000
func (s *TcAudioAc3Impl) SetBitrate(v *TcBitrate) TcAudioAc3 {
	if s == nil {
		return nil
	}
	s.BitrateValue = v
	return s
}

// The number of audio channels in an output stream.
// Example: 2
func (s TcAudioAc3Impl) Channels() *TiAudioAc3SpecChannels {
	return s.ChannelsValue
}

// The number of audio channels in an output stream.
// Example: 2
func (s *TcAudioAc3Impl) SetChannels(v TiAudioAc3SpecChannels) TcAudioAc3 {
	if s == nil {
		return nil
	}
	s.ChannelsValue = &v
	return s
}

// Audio codec (the AAC codec is used by default).
// Example: opus
func (s TcAudioAc3Impl) Codec() *string {
	return s.CodecValue
}

// Audio codec (the AAC codec is used by default).
// Example: opus
func (s *TcAudioAc3Impl) SetCodec(v string) TcAudioAc3 {
	if s == nil {
		return nil
	}
	s.CodecValue = &v
	return s
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// The allowed values are:
// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
// Example: 48000
func (s TcAudioAc3Impl) SampleRate() *TiAudioAc3SpecSampleRate {
	return s.SampleRateValue
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// The allowed values are:
// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
// Example: 48000
func (s *TcAudioAc3Impl) SetSampleRate(v TiAudioAc3SpecSampleRate) TcAudioAc3 {
	if s == nil {
		return nil
	}
	s.SampleRateValue = &v
	return s
}

// This option allows to split each audio track with multiple channels into several mono tracks.
func (s TcAudioAc3Impl) SplitChannels() *bool {
	return s.SplitChannelsValue
}

// This option allows to split each audio track with multiple channels into several mono tracks.
func (s *TcAudioAc3Impl) SetSplitChannels(v bool) TcAudioAc3 {
	if s == nil {
		return nil
	}
	s.SplitChannelsValue = &v
	return s
}

// NewTcAudioBase creates a new TcAudioBase instance
func NewTcAudioBase() TcAudioBase {
	return &TcAudioBaseImpl{}
}

// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
// If it is just an integer or a float, the output audio volume is calculated by this formula:
// `output_volume = avol * input_volume`
// If specified in decibels (dB), the output audio volume is calculated as follows:
// `output_volume = input_volume +/- avol`
// depending whether it is a positive (+9dB) or a negative value (-6dB).
// By default it equals to 1 (the input audio volume).
// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
// Example: -6dB
func (s TcAudioBaseImpl) Avol() *string {
	return s.AvolValue
}

// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
// If it is just an integer or a float, the output audio volume is calculated by this formula:
// `output_volume = avol * input_volume`
// If specified in decibels (dB), the output audio volume is calculated as follows:
// `output_volume = input_volume +/- avol`
// depending whether it is a positive (+9dB) or a negative value (-6dB).
// By default it equals to 1 (the input audio volume).
// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
// Example: -6dB
func (s *TcAudioBaseImpl) SetAvol(v string) TcAudioBase {
	if s == nil {
		return nil
	}
	s.AvolValue = &v
	return s
}

// Audio bitrate. The allowed values are:
// * `copy` - the bitrate or the original stream is copied to the outgoing stream.
// * a full number of bits (e.g., 64000) or a short form of the number with `k` (e.g., 64k).
// Example: 64000
func (s TcAudioBaseImpl) Bitrate() *TcBitrate {
	return s.BitrateValue
}

// Audio bitrate. The allowed values are:
// * `copy` - the bitrate or the original stream is copied to the outgoing stream.
// * a full number of bits (e.g., 64000) or a short form of the number with `k` (e.g., 64k).
// Example: 64000
func (s *TcAudioBaseImpl) SetBitrate(v *TcBitrate) TcAudioBase {
	if s == nil {
		return nil
	}
	s.BitrateValue = v
	return s
}

// Audio codec (the AAC codec is used by default).
// Example: opus
func (s TcAudioBaseImpl) Codec() *string {
	return s.CodecValue
}

// Audio codec (the AAC codec is used by default).
// Example: opus
func (s *TcAudioBaseImpl) SetCodec(v string) TcAudioBase {
	if s == nil {
		return nil
	}
	s.CodecValue = &v
	return s
}

// This option allows to split each audio track with multiple channels into several mono tracks.
func (s TcAudioBaseImpl) SplitChannels() *bool {
	return s.SplitChannelsValue
}

// This option allows to split each audio track with multiple channels into several mono tracks.
func (s *TcAudioBaseImpl) SetSplitChannels(v bool) TcAudioBase {
	if s == nil {
		return nil
	}
	s.SplitChannelsValue = &v
	return s
}

// NewTcAudioMp2a creates a new TcAudioMp2a instance
func NewTcAudioMp2a() TcAudioMp2a {
	return &TcAudioMp2aImpl{}
}

// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
// If it is just an integer or a float, the output audio volume is calculated by this formula:
// `output_volume = avol * input_volume`
// If specified in decibels (dB), the output audio volume is calculated as follows:
// `output_volume = input_volume +/- avol`
// depending whether it is a positive (+9dB) or a negative value (-6dB).
// By default it equals to 1 (the input audio volume).
// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
// Example: -6dB
func (s TcAudioMp2aImpl) Avol() *string {
	return s.AvolValue
}

// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
// If it is just an integer or a float, the output audio volume is calculated by this formula:
// `output_volume = avol * input_volume`
// If specified in decibels (dB), the output audio volume is calculated as follows:
// `output_volume = input_volume +/- avol`
// depending whether it is a positive (+9dB) or a negative value (-6dB).
// By default it equals to 1 (the input audio volume).
// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
// Example: -6dB
func (s *TcAudioMp2aImpl) SetAvol(v string) TcAudioMp2a {
	if s == nil {
		return nil
	}
	s.AvolValue = &v
	return s
}

// Audio bitrate. The allowed values are:
// * `copy` - the bitrate or the original stream is copied to the outgoing stream.
// * a full number of bits (e.g., 64000) or a short form of the number with `k` (e.g., 64k).
// Example: 64000
func (s TcAudioMp2aImpl) Bitrate() *TcBitrate {
	return s.BitrateValue
}

// Audio bitrate. The allowed values are:
// * `copy` - the bitrate or the original stream is copied to the outgoing stream.
// * a full number of bits (e.g., 64000) or a short form of the number with `k` (e.g., 64k).
// Example: 64000
func (s *TcAudioMp2aImpl) SetBitrate(v *TcBitrate) TcAudioMp2a {
	if s == nil {
		return nil
	}
	s.BitrateValue = v
	return s
}

// The number of audio channels in an output stream.
// Example: 2
func (s TcAudioMp2aImpl) Channels() *TiAudioMp2aSpecChannels {
	return s.ChannelsValue
}

// The number of audio channels in an output stream.
// Example: 2
func (s *TcAudioMp2aImpl) SetChannels(v TiAudioMp2aSpecChannels) TcAudioMp2a {
	if s == nil {
		return nil
	}
	s.ChannelsValue = &v
	return s
}

// Audio codec (the AAC codec is used by default).
// Example: opus
func (s TcAudioMp2aImpl) Codec() *string {
	return s.CodecValue
}

// Audio codec (the AAC codec is used by default).
// Example: opus
func (s *TcAudioMp2aImpl) SetCodec(v string) TcAudioMp2a {
	if s == nil {
		return nil
	}
	s.CodecValue = &v
	return s
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// The allowed values are:
// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
// Example: 48000
func (s TcAudioMp2aImpl) SampleRate() *TiAudioMp2aSpecSampleRate {
	return s.SampleRateValue
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// The allowed values are:
// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
// Example: 48000
func (s *TcAudioMp2aImpl) SetSampleRate(v TiAudioMp2aSpecSampleRate) TcAudioMp2a {
	if s == nil {
		return nil
	}
	s.SampleRateValue = &v
	return s
}

// This option allows to split each audio track with multiple channels into several mono tracks.
func (s TcAudioMp2aImpl) SplitChannels() *bool {
	return s.SplitChannelsValue
}

// This option allows to split each audio track with multiple channels into several mono tracks.
func (s *TcAudioMp2aImpl) SetSplitChannels(v bool) TcAudioMp2a {
	if s == nil {
		return nil
	}
	s.SplitChannelsValue = &v
	return s
}

// NewTcAudioMp3 creates a new TcAudioMp3 instance
func NewTcAudioMp3() TcAudioMp3 {
	return &TcAudioMp3Impl{}
}

// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
// If it is just an integer or a float, the output audio volume is calculated by this formula:
// `output_volume = avol * input_volume`
// If specified in decibels (dB), the output audio volume is calculated as follows:
// `output_volume = input_volume +/- avol`
// depending whether it is a positive (+9dB) or a negative value (-6dB).
// By default it equals to 1 (the input audio volume).
// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
// Example: -6dB
func (s TcAudioMp3Impl) Avol() *string {
	return s.AvolValue
}

// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
// If it is just an integer or a float, the output audio volume is calculated by this formula:
// `output_volume = avol * input_volume`
// If specified in decibels (dB), the output audio volume is calculated as follows:
// `output_volume = input_volume +/- avol`
// depending whether it is a positive (+9dB) or a negative value (-6dB).
// By default it equals to 1 (the input audio volume).
// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
// Example: -6dB
func (s *TcAudioMp3Impl) SetAvol(v string) TcAudioMp3 {
	if s == nil {
		return nil
	}
	s.AvolValue = &v
	return s
}

// Audio bitrate. The allowed values are:
// * `copy` - the bitrate or the original stream is copied to the outgoing stream.
// * a full number of bits (e.g., 64000) or a short form of the number with `k` (e.g., 64k).
// Example: 64000
func (s TcAudioMp3Impl) Bitrate() *TcBitrate {
	return s.BitrateValue
}

// Audio bitrate. The allowed values are:
// * `copy` - the bitrate or the original stream is copied to the outgoing stream.
// * a full number of bits (e.g., 64000) or a short form of the number with `k` (e.g., 64k).
// Example: 64000
func (s *TcAudioMp3Impl) SetBitrate(v *TcBitrate) TcAudioMp3 {
	if s == nil {
		return nil
	}
	s.BitrateValue = v
	return s
}

// The number of audio channels in an output stream.
// Example: 2
func (s TcAudioMp3Impl) Channels() *TiAudioMp3SpecChannels {
	return s.ChannelsValue
}

// The number of audio channels in an output stream.
// Example: 2
func (s *TcAudioMp3Impl) SetChannels(v TiAudioMp3SpecChannels) TcAudioMp3 {
	if s == nil {
		return nil
	}
	s.ChannelsValue = &v
	return s
}

// Audio codec (the AAC codec is used by default).
// Example: opus
func (s TcAudioMp3Impl) Codec() *string {
	return s.CodecValue
}

// Audio codec (the AAC codec is used by default).
// Example: opus
func (s *TcAudioMp3Impl) SetCodec(v string) TcAudioMp3 {
	if s == nil {
		return nil
	}
	s.CodecValue = &v
	return s
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// The allowed values are:
// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
// Example: 8000
func (s TcAudioMp3Impl) SampleRate() *TiAudioMp3SpecSampleRate {
	return s.SampleRateValue
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// The allowed values are:
// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
// Example: 8000
func (s *TcAudioMp3Impl) SetSampleRate(v TiAudioMp3SpecSampleRate) TcAudioMp3 {
	if s == nil {
		return nil
	}
	s.SampleRateValue = &v
	return s
}

// This option allows to split each audio track with multiple channels into several mono tracks.
func (s TcAudioMp3Impl) SplitChannels() *bool {
	return s.SplitChannelsValue
}

// This option allows to split each audio track with multiple channels into several mono tracks.
func (s *TcAudioMp3Impl) SetSplitChannels(v bool) TcAudioMp3 {
	if s == nil {
		return nil
	}
	s.SplitChannelsValue = &v
	return s
}

// NewTcAudioOpts creates a new TcAudioOpts instance
func NewTcAudioOpts() TcAudioOpts {
	return &TcAudioOptsImpl{}
}

// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
// If it is just an integer or a float, the output audio volume is calculated by this formula:
// `output_volume = avol * input_volume`
// If specified in decibels (dB), the output audio volume is calculated as follows:
// `output_volume = input_volume +/- avol`
// depending whether it is a positive (+9dB) or a negative value (-6dB).
// By default it equals to 1 (the input audio volume).
// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
// Example: -6dB
func (s TcAudioOptsImpl) Avol() *string {
	return s.AvolValue
}

// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
// If it is just an integer or a float, the output audio volume is calculated by this formula:
// `output_volume = avol * input_volume`
// If specified in decibels (dB), the output audio volume is calculated as follows:
// `output_volume = input_volume +/- avol`
// depending whether it is a positive (+9dB) or a negative value (-6dB).
// By default it equals to 1 (the input audio volume).
// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
// Example: -6dB
func (s *TcAudioOptsImpl) SetAvol(v string) TcAudioOpts {
	if s == nil {
		return nil
	}
	s.AvolValue = &v
	return s
}

// Audio bitrate. The allowed values are:
// * `copy` - the bitrate or the original stream is copied to the outgoing stream.
// * a full number of bits (e.g., 64000) or a short form of the number with `k` (e.g., 64k).
// Example: 64000
func (s TcAudioOptsImpl) Bitrate() *TcBitrate {
	return s.BitrateValue
}

// Audio bitrate. The allowed values are:
// * `copy` - the bitrate or the original stream is copied to the outgoing stream.
// * a full number of bits (e.g., 64000) or a short form of the number with `k` (e.g., 64k).
// Example: 64000
func (s *TcAudioOptsImpl) SetBitrate(v *TcBitrate) TcAudioOpts {
	if s == nil {
		return nil
	}
	s.BitrateValue = v
	return s
}

// The number of audio channels in an output stream.
// Example: 2
func (s TcAudioOptsImpl) Channels() any {
	return s.ChannelsValue
}

// The number of audio channels in an output stream.
// Example: 2
func (s *TcAudioOptsImpl) SetChannels(v any) TcAudioOpts {
	if s == nil {
		return nil
	}
	s.ChannelsValue = v
	return s
}

// Audio codec (the AAC codec is used by default).
// Example: opus
func (s TcAudioOptsImpl) Codec() *string {
	return s.CodecValue
}

// Audio codec (the AAC codec is used by default).
// Example: opus
func (s *TcAudioOptsImpl) SetCodec(v string) TcAudioOpts {
	if s == nil {
		return nil
	}
	s.CodecValue = &v
	return s
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// The allowed values are:
// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
// /Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
func (s TcAudioOptsImpl) SampleRate() any {
	return s.SampleRateValue
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// The allowed values are:
// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
// /Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
func (s *TcAudioOptsImpl) SetSampleRate(v any) TcAudioOpts {
	if s == nil {
		return nil
	}
	s.SampleRateValue = v
	return s
}

// This option allows to split each audio track with multiple channels into several mono tracks.
func (s TcAudioOptsImpl) SplitChannels() *bool {
	return s.SplitChannelsValue
}

// This option allows to split each audio track with multiple channels into several mono tracks.
func (s *TcAudioOptsImpl) SetSplitChannels(v bool) TcAudioOpts {
	if s == nil {
		return nil
	}
	s.SplitChannelsValue = &v
	return s
}

// NewTcAudioOpus creates a new TcAudioOpus instance
func NewTcAudioOpus() TcAudioOpus {
	return &TcAudioOpusImpl{}
}

// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
// If it is just an integer or a float, the output audio volume is calculated by this formula:
// `output_volume = avol * input_volume`
// If specified in decibels (dB), the output audio volume is calculated as follows:
// `output_volume = input_volume +/- avol`
// depending whether it is a positive (+9dB) or a negative value (-6dB).
// By default it equals to 1 (the input audio volume).
// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
// Example: -6dB
func (s TcAudioOpusImpl) Avol() *string {
	return s.AvolValue
}

// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
// If it is just an integer or a float, the output audio volume is calculated by this formula:
// `output_volume = avol * input_volume`
// If specified in decibels (dB), the output audio volume is calculated as follows:
// `output_volume = input_volume +/- avol`
// depending whether it is a positive (+9dB) or a negative value (-6dB).
// By default it equals to 1 (the input audio volume).
// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
// Example: -6dB
func (s *TcAudioOpusImpl) SetAvol(v string) TcAudioOpus {
	if s == nil {
		return nil
	}
	s.AvolValue = &v
	return s
}

// Audio bitrate. The allowed values are:
// * `copy` - the bitrate or the original stream is copied to the outgoing stream.
// * a full number of bits (e.g., 64000) or a short form of the number with `k` (e.g., 64k).
// Example: 64000
func (s TcAudioOpusImpl) Bitrate() *TcBitrate {
	return s.BitrateValue
}

// Audio bitrate. The allowed values are:
// * `copy` - the bitrate or the original stream is copied to the outgoing stream.
// * a full number of bits (e.g., 64000) or a short form of the number with `k` (e.g., 64k).
// Example: 64000
func (s *TcAudioOpusImpl) SetBitrate(v *TcBitrate) TcAudioOpus {
	if s == nil {
		return nil
	}
	s.BitrateValue = v
	return s
}

// The number of audio channels in an output stream.
// Example: 2
func (s TcAudioOpusImpl) Channels() *TiAudioOpusSpecChannels {
	return s.ChannelsValue
}

// The number of audio channels in an output stream.
// Example: 2
func (s *TcAudioOpusImpl) SetChannels(v TiAudioOpusSpecChannels) TcAudioOpus {
	if s == nil {
		return nil
	}
	s.ChannelsValue = &v
	return s
}

// Audio codec (the AAC codec is used by default).
// Example: opus
func (s TcAudioOpusImpl) Codec() *string {
	return s.CodecValue
}

// Audio codec (the AAC codec is used by default).
// Example: opus
func (s *TcAudioOpusImpl) SetCodec(v string) TcAudioOpus {
	if s == nil {
		return nil
	}
	s.CodecValue = &v
	return s
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// The allowed values are:
// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
// Example: 48000
func (s TcAudioOpusImpl) SampleRate() *TiAudioOpusSpecSampleRate {
	return s.SampleRateValue
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// The allowed values are:
// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
// Example: 48000
func (s *TcAudioOpusImpl) SetSampleRate(v TiAudioOpusSpecSampleRate) TcAudioOpus {
	if s == nil {
		return nil
	}
	s.SampleRateValue = &v
	return s
}

// This option allows to split each audio track with multiple channels into several mono tracks.
func (s TcAudioOpusImpl) SplitChannels() *bool {
	return s.SplitChannelsValue
}

// This option allows to split each audio track with multiple channels into several mono tracks.
func (s *TcAudioOpusImpl) SetSplitChannels(v bool) TcAudioOpus {
	if s == nil {
		return nil
	}
	s.SplitChannelsValue = &v
	return s
}

// NewTcAudioPcm creates a new TcAudioPcm instance
func NewTcAudioPcm() TcAudioPcm {
	return &TcAudioPcmImpl{}
}

// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
// If it is just an integer or a float, the output audio volume is calculated by this formula:
// `output_volume = avol * input_volume`
// If specified in decibels (dB), the output audio volume is calculated as follows:
// `output_volume = input_volume +/- avol`
// depending whether it is a positive (+9dB) or a negative value (-6dB).
// By default it equals to 1 (the input audio volume).
// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
// Example: -6dB
func (s TcAudioPcmImpl) Avol() *string {
	return s.AvolValue
}

// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
// If it is just an integer or a float, the output audio volume is calculated by this formula:
// `output_volume = avol * input_volume`
// If specified in decibels (dB), the output audio volume is calculated as follows:
// `output_volume = input_volume +/- avol`
// depending whether it is a positive (+9dB) or a negative value (-6dB).
// By default it equals to 1 (the input audio volume).
// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
// Example: -6dB
func (s *TcAudioPcmImpl) SetAvol(v string) TcAudioPcm {
	if s == nil {
		return nil
	}
	s.AvolValue = &v
	return s
}

// Audio bitrate. The allowed values are:
// * `copy` - the bitrate or the original stream is copied to the outgoing stream.
// * a full number of bits (e.g., 64000) or a short form of the number with `k` (e.g., 64k).
// Example: 64000
func (s TcAudioPcmImpl) Bitrate() *TcBitrate {
	return s.BitrateValue
}

// Audio bitrate. The allowed values are:
// * `copy` - the bitrate or the original stream is copied to the outgoing stream.
// * a full number of bits (e.g., 64000) or a short form of the number with `k` (e.g., 64k).
// Example: 64000
func (s *TcAudioPcmImpl) SetBitrate(v *TcBitrate) TcAudioPcm {
	if s == nil {
		return nil
	}
	s.BitrateValue = v
	return s
}

// The number of audio channels in an output stream.
// Example: 1
func (s TcAudioPcmImpl) Channels() *int {
	return s.ChannelsValue
}

// The number of audio channels in an output stream.
// Example: 1
func (s *TcAudioPcmImpl) SetChannels(v int) TcAudioPcm {
	if s == nil {
		return nil
	}
	s.ChannelsValue = &v
	return s
}

// Audio codec (the AAC codec is used by default).
// Example: opus
func (s TcAudioPcmImpl) Codec() *string {
	return s.CodecValue
}

// Audio codec (the AAC codec is used by default).
// Example: opus
func (s *TcAudioPcmImpl) SetCodec(v string) TcAudioPcm {
	if s == nil {
		return nil
	}
	s.CodecValue = &v
	return s
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// Example: 8000
func (s TcAudioPcmImpl) SampleRate() *int {
	return s.SampleRateValue
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// Example: 8000
func (s *TcAudioPcmImpl) SetSampleRate(v int) TcAudioPcm {
	if s == nil {
		return nil
	}
	s.SampleRateValue = &v
	return s
}

// This option allows to split each audio track with multiple channels into several mono tracks.
func (s TcAudioPcmImpl) SplitChannels() *bool {
	return s.SplitChannelsValue
}

// This option allows to split each audio track with multiple channels into several mono tracks.
func (s *TcAudioPcmImpl) SetSplitChannels(v bool) TcAudioPcm {
	if s == nil {
		return nil
	}
	s.SplitChannelsValue = &v
	return s
}

// NewTcAudioPcma creates a new TcAudioPcma instance
func NewTcAudioPcma() TcAudioPcma {
	return &TcAudioPcmaImpl{}
}

// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
// If it is just an integer or a float, the output audio volume is calculated by this formula:
// `output_volume = avol * input_volume`
// If specified in decibels (dB), the output audio volume is calculated as follows:
// `output_volume = input_volume +/- avol`
// depending whether it is a positive (+9dB) or a negative value (-6dB).
// By default it equals to 1 (the input audio volume).
// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
// Example: -6dB
func (s TcAudioPcmaImpl) Avol() *string {
	return s.AvolValue
}

// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
// If it is just an integer or a float, the output audio volume is calculated by this formula:
// `output_volume = avol * input_volume`
// If specified in decibels (dB), the output audio volume is calculated as follows:
// `output_volume = input_volume +/- avol`
// depending whether it is a positive (+9dB) or a negative value (-6dB).
// By default it equals to 1 (the input audio volume).
// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
// Example: -6dB
func (s *TcAudioPcmaImpl) SetAvol(v string) TcAudioPcma {
	if s == nil {
		return nil
	}
	s.AvolValue = &v
	return s
}

// Audio bitrate. The allowed values are:
// * `copy` - the bitrate or the original stream is copied to the outgoing stream.
// * a full number of bits (e.g., 64000) or a short form of the number with `k` (e.g., 64k).
// Example: 64000
func (s TcAudioPcmaImpl) Bitrate() *TcBitrate {
	return s.BitrateValue
}

// Audio bitrate. The allowed values are:
// * `copy` - the bitrate or the original stream is copied to the outgoing stream.
// * a full number of bits (e.g., 64000) or a short form of the number with `k` (e.g., 64k).
// Example: 64000
func (s *TcAudioPcmaImpl) SetBitrate(v *TcBitrate) TcAudioPcma {
	if s == nil {
		return nil
	}
	s.BitrateValue = v
	return s
}

// The number of audio channels in an output stream.
// Example: 1
func (s TcAudioPcmaImpl) Channels() *TiAudioPcmaSpecChannels {
	return s.ChannelsValue
}

// The number of audio channels in an output stream.
// Example: 1
func (s *TcAudioPcmaImpl) SetChannels(v TiAudioPcmaSpecChannels) TcAudioPcma {
	if s == nil {
		return nil
	}
	s.ChannelsValue = &v
	return s
}

// Audio codec (the AAC codec is used by default).
// Example: opus
func (s TcAudioPcmaImpl) Codec() *string {
	return s.CodecValue
}

// Audio codec (the AAC codec is used by default).
// Example: opus
func (s *TcAudioPcmaImpl) SetCodec(v string) TcAudioPcma {
	if s == nil {
		return nil
	}
	s.CodecValue = &v
	return s
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// The allowed values are:
// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
// Example: 8000
func (s TcAudioPcmaImpl) SampleRate() *TiAudioPcmaSpecSampleRate {
	return s.SampleRateValue
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// The allowed values are:
// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
// Example: 8000
func (s *TcAudioPcmaImpl) SetSampleRate(v TiAudioPcmaSpecSampleRate) TcAudioPcma {
	if s == nil {
		return nil
	}
	s.SampleRateValue = &v
	return s
}

// This option allows to split each audio track with multiple channels into several mono tracks.
func (s TcAudioPcmaImpl) SplitChannels() *bool {
	return s.SplitChannelsValue
}

// This option allows to split each audio track with multiple channels into several mono tracks.
func (s *TcAudioPcmaImpl) SetSplitChannels(v bool) TcAudioPcma {
	if s == nil {
		return nil
	}
	s.SplitChannelsValue = &v
	return s
}

// NewTcBurn creates a new TcBurn instance
func NewTcBurn() TcBurn {
	return &TcBurnImpl{}
}

// Configuration of burn-in text to video frames.
func (s TcBurnImpl) Text() TcLabel {
	return s.TextValue
}

// Configuration of burn-in text to video frames.
func (s *TcBurnImpl) SetText(v TcLabel) TcBurn {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*TcLabelImpl); ok {
		s.TextValue = impl
	}
	return s
}

// Configuration of burn-in timestamp to video frames.
func (s TcBurnImpl) Time() TcLabel {
	return s.TimeValue
}

// Configuration of burn-in timestamp to video frames.
func (s *TcBurnImpl) SetTime(v TcLabel) TcBurn {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*TcLabelImpl); ok {
		s.TimeValue = impl
	}
	return s
}

// NewTcCrop creates a new TcCrop instance
func NewTcCrop() TcCrop {
	return &TcCropImpl{}
}

// The height of the output video.
func (s TcCropImpl) Height() int {
	return s.HeightValue
}

// The height of the output video.
func (s *TcCropImpl) SetHeight(v int) TcCrop {
	if s == nil {
		return nil
	}
	s.HeightValue = v
	return s
}

// The `x` coordinate of the upper-left corner of the output video withing the input video.
func (s TcCropImpl) Left() int {
	return s.LeftValue
}

// The `x` coordinate of the upper-left corner of the output video withing the input video.
func (s *TcCropImpl) SetLeft(v int) TcCrop {
	if s == nil {
		return nil
	}
	s.LeftValue = v
	return s
}

// The `y` coordinate of the upper-left corner of the output video withing the input video.
func (s TcCropImpl) Top() int {
	return s.TopValue
}

// The `y` coordinate of the upper-left corner of the output video withing the input video.
func (s *TcCropImpl) SetTop(v int) TcCrop {
	if s == nil {
		return nil
	}
	s.TopValue = v
	return s
}

// The width of the output video.
func (s TcCropImpl) Width() int {
	return s.WidthValue
}

// The width of the output video.
func (s *TcCropImpl) SetWidth(v int) TcCrop {
	if s == nil {
		return nil
	}
	s.WidthValue = v
	return s
}

// NewTcDecoder creates a new TcDecoder instance
func NewTcDecoder() TcDecoder {
	return &TcDecoderImpl{}
}

// Video cropping options.
func (s TcDecoderImpl) Crop() TcCrop {
	return s.CropValue
}

// Video cropping options.
func (s *TcDecoderImpl) SetCrop(v TcCrop) TcDecoder {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*TcCropImpl); ok {
		s.CropValue = impl
	}
	return s
}

// Activate deinterlacing, i.e., converting an interlaced image to a progressive image.
// It is necessary for comfortable viewing of legacy TV video on PC/mobile devices.
// Example: true
func (s TcDecoderImpl) Deinterlace() *DeinterlaceSettings {
	return s.DeinterlaceValue
}

// Activate deinterlacing, i.e., converting an interlaced image to a progressive image.
// It is necessary for comfortable viewing of legacy TV video on PC/mobile devices.
// Example: true
func (s *TcDecoderImpl) SetDeinterlace(v *DeinterlaceSettings) TcDecoder {
	if s == nil {
		return nil
	}
	s.DeinterlaceValue = v
	return s
}

// This parameter is used when encoding with Nvidia NVENC.
// You can remove duplicate frames that were produced after deinterlacing, preventing increased bitrate, by one of two methods.
// Example: frame
func (s TcDecoderImpl) DeinterlaceRate() *TcDecoderDeinterlaceRate {
	return s.DeinterlaceRateValue
}

// This parameter is used when encoding with Nvidia NVENC.
// You can remove duplicate frames that were produced after deinterlacing, preventing increased bitrate, by one of two methods.
// Example: frame
func (s *TcDecoderImpl) SetDeinterlaceRate(v TcDecoderDeinterlaceRate) TcDecoder {
	if s == nil {
		return nil
	}
	s.DeinterlaceRateValue = &v
	return s
}

// This parameter is applicable for NVIDIA Jetson transcoder only.
// This is the number of frames after wich the decoder skips a frame and, thus, allows to save the resources. For example:
// * 1 - sip each frame
// * 2 - skip each second frame
// * 3 - skip each third frame, etc.
// This option can be useful for streams with high FPS (e.g., 60) as it allows to increase the bandwidth.
// Example: 3
func (s TcDecoderImpl) DropFrameInterval() *int {
	return s.DropFrameIntervalValue
}

// This parameter is applicable for NVIDIA Jetson transcoder only.
// This is the number of frames after wich the decoder skips a frame and, thus, allows to save the resources. For example:
// * 1 - sip each frame
// * 2 - skip each second frame
// * 3 - skip each third frame, etc.
// This option can be useful for streams with high FPS (e.g., 60) as it allows to increase the bandwidth.
// Example: 3
func (s *TcDecoderImpl) SetDropFrameInterval(v int) TcDecoder {
	if s == nil {
		return nil
	}
	s.DropFrameIntervalValue = &v
	return s
}

// Switch off the decoded picture buffer. Works for the streams with 1 reference frame.
// The default value is `false`.
// Example: false
func (s TcDecoderImpl) NoDpb() *bool {
	return s.NoDpbValue
}

// Switch off the decoded picture buffer. Works for the streams with 1 reference frame.
// The default value is `false`.
// Example: false
func (s *TcDecoderImpl) SetNoDpb(v bool) TcDecoder {
	if s == nil {
		return nil
	}
	s.NoDpbValue = &v
	return s
}

// The required pixel format according to a color model.
func (s TcDecoderImpl) PixFmt() *FrameVideoPixFmt {
	return s.PixFmtValue
}

// The required pixel format according to a color model.
func (s *TcDecoderImpl) SetPixFmt(v FrameVideoPixFmt) TcDecoder {
	if s == nil {
		return nil
	}
	s.PixFmtValue = &v
	return s
}

// Allow receiving incomplete frames from the input buffer.
// If it is set to `true`, the decoder can start decoding before the complete frame is received.
// Example: false
func (s TcDecoderImpl) StreamingFrame() *bool {
	return s.StreamingFrameValue
}

// Allow receiving incomplete frames from the input buffer.
// If it is set to `true`, the decoder can start decoding before the complete frame is received.
// Example: false
func (s *TcDecoderImpl) SetStreamingFrame(v bool) TcDecoder {
	if s == nil {
		return nil
	}
	s.StreamingFrameValue = &v
	return s
}

// NewTcGlobal creates a new TcGlobal instance
func NewTcGlobal() TcGlobal {
	return &TcGlobalImpl{}
}

// Configuration of text, timestamp or subtitles burn-in to video frames.
func (s TcGlobalImpl) Burn() TcBurn {
	return s.BurnValue
}

// Configuration of text, timestamp or subtitles burn-in to video frames.
func (s *TcGlobalImpl) SetBurn(v TcBurn) TcGlobal {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*TcBurnImpl); ok {
		s.BurnValue = impl
	}
	return s
}

// Identifier of hardware device to be used for transcoding a stream.
func (s TcGlobalImpl) Deviceid() *TcDeviceid {
	return s.DeviceidValue
}

// Identifier of hardware device to be used for transcoding a stream.
func (s *TcGlobalImpl) SetDeviceid(v *TcDeviceid) TcGlobal {
	if s == nil {
		return nil
	}
	s.DeviceidValue = v
	return s
}

// If this parameter is se to `true` (by default), the transcoder runs in a separate process from Flussonic.
// If it is set to `false`, the transcoder will run in the same process as Flussonic.
// This mode speeds up encoding, especially when encoding audio or when using an Nvidia device.
// However, a transcoder error may cause Flussonic to crash.
func (s TcGlobalImpl) External() *bool {
	return s.ExternalValue
}

// If this parameter is se to `true` (by default), the transcoder runs in a separate process from Flussonic.
// If it is set to `false`, the transcoder will run in the same process as Flussonic.
// This mode speeds up encoding, especially when encoding audio or when using an Nvidia device.
// However, a transcoder error may cause Flussonic to crash.
func (s *TcGlobalImpl) SetExternal(v bool) TcGlobal {
	if s == nil {
		return nil
	}
	s.ExternalValue = &v
	return s
}

// GOP (group of pictures) size (in frames) to be applied for any video track in the stream.
// The encoder will create all GOPs of an exactly identical size - as specified in this option.
// May be overridden for a track.
// Example: 150
func (s TcGlobalImpl) Gop() *int {
	return s.GopValue
}

// GOP (group of pictures) size (in frames) to be applied for any video track in the stream.
// The encoder will create all GOPs of an exactly identical size - as specified in this option.
// May be overridden for a track.
// Example: 150
func (s *TcGlobalImpl) SetGop(v int) TcGlobal {
	if s == nil {
		return nil
	}
	s.GopValue = &v
	return s
}

// Transcoder hardware device type to be used for transcoding a stream.
func (s TcGlobalImpl) Hw() *TranscoderDevice {
	return s.HwValue
}

// Transcoder hardware device type to be used for transcoding a stream.
func (s *TcGlobalImpl) SetHw(v TranscoderDevice) TcGlobal {
	if s == nil {
		return nil
	}
	s.HwValue = &v
	return s
}

// What use is the stream intended for.
// Specifying this option applies useful defaults in conformance with standards
func (s TcGlobalImpl) Target() *TranscoderTarget {
	return s.TargetValue
}

// What use is the stream intended for.
// Specifying this option applies useful defaults in conformance with standards
func (s *TcGlobalImpl) SetTarget(v TranscoderTarget) TcGlobal {
	if s == nil {
		return nil
	}
	s.TargetValue = &v
	return s
}

// NewTcLabel creates a new TcLabel instance
func NewTcLabel() TcLabel {
	return &TcLabelImpl{}
}

// Parameters of the box around the text, timestamp, or subtitles.
func (s TcLabelImpl) Box() TcLabelBox {
	return s.BoxValue
}

// Parameters of the box around the text, timestamp, or subtitles.
func (s *TcLabelImpl) SetBox(v TcLabelBox) TcLabel {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*TcLabelBoxImpl); ok {
		s.BoxValue = impl
	}
	return s
}

// Font to be used for text, timestamp, or subtitles burn-in to video frames.
func (s TcLabelImpl) Font() TcLabelFont {
	return s.FontValue
}

// Font to be used for text, timestamp, or subtitles burn-in to video frames.
func (s *TcLabelImpl) SetFont(v TcLabelFont) TcLabel {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*TcLabelFontImpl); ok {
		s.FontValue = impl
	}
	return s
}

// Position to burn text.
func (s TcLabelImpl) Position() *TcLabelPosition {
	return s.PositionValue
}

// Position to burn text.
func (s *TcLabelImpl) SetPosition(v TcLabelPosition) TcLabel {
	if s == nil {
		return nil
	}
	s.PositionValue = &v
	return s
}

// Text, time, or subtitles to burn-in to video frames.
// * For text - it is the text
// * For subtitles - it is the subtitles track, e.g., `t1`.
// * For time - it is the time in one of the formats:
// ** `%T` - the time in 24-hour notation (`%H:%M:%S`).
// ** `%F` - equivalent to `%Y-%m-%d` (the ISO 8601 date format).
func (s TcLabelImpl) Text() *string {
	return s.TextValue
}

// Text, time, or subtitles to burn-in to video frames.
// * For text - it is the text
// * For subtitles - it is the subtitles track, e.g., `t1`.
// * For time - it is the time in one of the formats:
// ** `%T` - the time in 24-hour notation (`%H:%M:%S`).
// ** `%F` - equivalent to `%Y-%m-%d` (the ISO 8601 date format).
func (s *TcLabelImpl) SetText(v string) TcLabel {
	if s == nil {
		return nil
	}
	s.TextValue = &v
	return s
}

// The offset of the text, timestamp, or subtitles position, in pixel, to the right or left to the center of the screen.
func (s TcLabelImpl) X() *int {
	return s.XValue
}

// The offset of the text, timestamp, or subtitles position, in pixel, to the right or left to the center of the screen.
func (s *TcLabelImpl) SetX(v int) TcLabel {
	if s == nil {
		return nil
	}
	s.XValue = &v
	return s
}

// The offset of the text, timestamp, or subtitles position, in pixel, up or down to the center of the screen.
func (s TcLabelImpl) Y() *int {
	return s.YValue
}

// The offset of the text, timestamp, or subtitles position, in pixel, up or down to the center of the screen.
func (s *TcLabelImpl) SetY(v int) TcLabel {
	if s == nil {
		return nil
	}
	s.YValue = &v
	return s
}

// NewTcLabelBox creates a new TcLabelBox instance
func NewTcLabelBox() TcLabelBox {
	return &TcLabelBoxImpl{}
}

// Box opacity (use values from 0.1 to 1.0, 0.0 - completely transparent, 1.0 - completely opaque).
// Example: 0
func (s TcLabelBoxImpl) Alpha() *float64 {
	return s.AlphaValue
}

// Box opacity (use values from 0.1 to 1.0, 0.0 - completely transparent, 1.0 - completely opaque).
// Example: 0
func (s *TcLabelBoxImpl) SetAlpha(v float64) TcLabelBox {
	if s == nil {
		return nil
	}
	s.AlphaValue = &v
	return s
}

// The width, in pixel, of the border to be drawn around the text, timestamp, or subtitles.
// Example: 10
func (s TcLabelBoxImpl) Borderw() *int {
	return s.BorderwValue
}

// The width, in pixel, of the border to be drawn around the text, timestamp, or subtitles.
// Example: 10
func (s *TcLabelBoxImpl) SetBorderw(v int) TcLabelBox {
	if s == nil {
		return nil
	}
	s.BorderwValue = &v
	return s
}

// Box color.
func (s TcLabelBoxImpl) Color() *string {
	return s.ColorValue
}

// Box color.
func (s *TcLabelBoxImpl) SetColor(v string) TcLabelBox {
	if s == nil {
		return nil
	}
	s.ColorValue = &v
	return s
}

// NewTcLabelFont creates a new TcLabelFont instance
func NewTcLabelFont() TcLabelFont {
	return &TcLabelFontImpl{}
}

// Font opacity (use values from 0.1 to 1.0, 0.0 - completely transparent, 1.0 - completely opaque).
// Example: 1
func (s TcLabelFontImpl) Alpha() *float64 {
	return s.AlphaValue
}

// Font opacity (use values from 0.1 to 1.0, 0.0 - completely transparent, 1.0 - completely opaque).
// Example: 1
func (s *TcLabelFontImpl) SetAlpha(v float64) TcLabelFont {
	if s == nil {
		return nil
	}
	s.AlphaValue = &v
	return s
}

// Font color.
func (s TcLabelFontImpl) Color() *string {
	return s.ColorValue
}

// Font color.
func (s *TcLabelFontImpl) SetColor(v string) TcLabelFont {
	if s == nil {
		return nil
	}
	s.ColorValue = &v
	return s
}

// The subpath to the `.ttf` font file in the `font` subdirectory of the `/etc/flussonic/` directory.
// This means you can place the font file like `/etc/flussonic/font/SomeFont.ttf`.
// If the font file specified is missing in `/etc/flussonic/font/`, the default `FiraCode-Regular.ttf` font will be used, which is included in Flussonic.
// You can also specify the full path to a font file. Make sure you put the font file in the directory you specified.
// Example: /usr/share/fonts/truetype/freefont/FONT_NAME.ttf
func (s TcLabelFontImpl) File() *string {
	return s.FileValue
}

// The subpath to the `.ttf` font file in the `font` subdirectory of the `/etc/flussonic/` directory.
// This means you can place the font file like `/etc/flussonic/font/SomeFont.ttf`.
// If the font file specified is missing in `/etc/flussonic/font/`, the default `FiraCode-Regular.ttf` font will be used, which is included in Flussonic.
// You can also specify the full path to a font file. Make sure you put the font file in the directory you specified.
// Example: /usr/share/fonts/truetype/freefont/FONT_NAME.ttf
func (s *TcLabelFontImpl) SetFile(v string) TcLabelFont {
	if s == nil {
		return nil
	}
	s.FileValue = &v
	return s
}

// The font size in pixel.
// Example: 24
func (s TcLabelFontImpl) Size() *int {
	return s.SizeValue
}

// The font size in pixel.
// Example: 24
func (s *TcLabelFontImpl) SetSize(v int) TcLabelFont {
	if s == nil {
		return nil
	}
	s.SizeValue = &v
	return s
}

// NewTcLogo creates a new TcLogo instance
func NewTcLogo() TcLogo {
	return &TcLogoImpl{}
}

// Path to the logo image.
// Pattern: ^.+\.png$
// Example: @chan.png
func (s TcLogoImpl) Path() *string {
	return s.PathValue
}

// Path to the logo image.
// Pattern: ^.+\.png$
// Example: @chan.png
func (s *TcLogoImpl) SetPath(v string) TcLogo {
	if s == nil {
		return nil
	}
	s.PathValue = &v
	return s
}

// Position to place the logo.
// Example: tl
func (s TcLogoImpl) Position() *TcLogoPosition {
	return s.PositionValue
}

// Position to place the logo.
// Example: tl
func (s *TcLogoImpl) SetPosition(v TcLogoPosition) TcLogo {
	if s == nil {
		return nil
	}
	s.PositionValue = &v
	return s
}

// The offset of the logo position, in pixel, to the right or left to the center of the screen.
// Example: 10
func (s TcLogoImpl) X() *int {
	return s.XValue
}

// The offset of the logo position, in pixel, to the right or left to the center of the screen.
// Example: 10
func (s *TcLogoImpl) SetX(v int) TcLogo {
	if s == nil {
		return nil
	}
	s.XValue = &v
	return s
}

// The offset of the logo position, in pixel, up or down to the center of the screen.
// Example: 10
func (s TcLogoImpl) Y() *int {
	return s.YValue
}

// The offset of the logo position, in pixel, up or down to the center of the screen.
// Example: 10
func (s *TcLogoImpl) SetY(v int) TcLogo {
	if s == nil {
		return nil
	}
	s.YValue = &v
	return s
}

// NewTcQpRange creates a new TcQpRange instance
func NewTcQpRange() TcQpRange {
	return &TcQpRangeImpl{}
}

// Maximal quantization parameter for B-frames.
func (s TcQpRangeImpl) Qpmaxb() *int {
	return s.QpmaxbValue
}

// Maximal quantization parameter for B-frames.
func (s *TcQpRangeImpl) SetQpmaxb(v int) TcQpRange {
	if s == nil {
		return nil
	}
	s.QpmaxbValue = &v
	return s
}

// Maximal quantization parameter for I-frames.
func (s TcQpRangeImpl) Qpmaxi() *int {
	return s.QpmaxiValue
}

// Maximal quantization parameter for I-frames.
func (s *TcQpRangeImpl) SetQpmaxi(v int) TcQpRange {
	if s == nil {
		return nil
	}
	s.QpmaxiValue = &v
	return s
}

// Maximal quantization parameter for P-frames.
func (s TcQpRangeImpl) Qpmaxp() *int {
	return s.QpmaxpValue
}

// Maximal quantization parameter for P-frames.
func (s *TcQpRangeImpl) SetQpmaxp(v int) TcQpRange {
	if s == nil {
		return nil
	}
	s.QpmaxpValue = &v
	return s
}

// Minimal quantization parameter for B-frames.
func (s TcQpRangeImpl) Qpminb() *int {
	return s.QpminbValue
}

// Minimal quantization parameter for B-frames.
func (s *TcQpRangeImpl) SetQpminb(v int) TcQpRange {
	if s == nil {
		return nil
	}
	s.QpminbValue = &v
	return s
}

// Minimal quantization parameter for I-frames.
func (s TcQpRangeImpl) Qpmini() *int {
	return s.QpminiValue
}

// Minimal quantization parameter for I-frames.
func (s *TcQpRangeImpl) SetQpmini(v int) TcQpRange {
	if s == nil {
		return nil
	}
	s.QpminiValue = &v
	return s
}

// Minimal quantization parameter for P-frames.
func (s TcQpRangeImpl) Qpminp() *int {
	return s.QpminpValue
}

// Minimal quantization parameter for P-frames.
func (s *TcQpRangeImpl) SetQpminp(v int) TcQpRange {
	if s == nil {
		return nil
	}
	s.QpminpValue = &v
	return s
}

// NewTcSar creates a new TcSar instance
func NewTcSar() TcSar {
	return &TcSarImpl{}
}

// The first number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
func (s TcSarImpl) X() *int {
	return s.XValue
}

// The first number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
func (s *TcSarImpl) SetX(v int) TcSar {
	if s == nil {
		return nil
	}
	s.XValue = &v
	return s
}

// The second number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
func (s TcSarImpl) Y() *int {
	return s.YValue
}

// The second number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
func (s *TcSarImpl) SetY(v int) TcSar {
	if s == nil {
		return nil
	}
	s.YValue = &v
	return s
}

// NewTcSize creates a new TcSize instance
func NewTcSize() TcSize {
	return &TcSizeImpl{}
}

// The color of the area in the player that is not occupied by the video after resizing.
// It is used only with the 'fit' strategy.
func (s TcSizeImpl) Background() *string {
	return s.BackgroundValue
}

// The color of the area in the player that is not occupied by the video after resizing.
// It is used only with the 'fit' strategy.
func (s *TcSizeImpl) SetBackground(v string) TcSize {
	if s == nil {
		return nil
	}
	s.BackgroundValue = &v
	return s
}

// The picture height in pixels on the display where it will be played by a player.
// If you need to insert a web-player into a web page, use this value for choosing the player size.
// A value of -1 means that the width will be used to calculate the actual height with maintaining the aspect ratio.
// Only one of width or height may have value -1.
// Zero value (0) is not allowed.
func (s TcSizeImpl) Height() *int {
	return s.HeightValue
}

// The picture height in pixels on the display where it will be played by a player.
// If you need to insert a web-player into a web page, use this value for choosing the player size.
// A value of -1 means that the width will be used to calculate the actual height with maintaining the aspect ratio.
// Only one of width or height may have value -1.
// Zero value (0) is not allowed.
func (s *TcSizeImpl) SetHeight(v int) TcSize {
	if s == nil {
		return nil
	}
	s.HeightValue = &v
	return s
}

// The algorithm of the picture resizing: crop, scale, or fit.
// Example: crop
func (s TcSizeImpl) Strategy() *TcSizeStrategy {
	return s.StrategyValue
}

// The algorithm of the picture resizing: crop, scale, or fit.
// Example: crop
func (s *TcSizeImpl) SetStrategy(v TcSizeStrategy) TcSize {
	if s == nil {
		return nil
	}
	s.StrategyValue = &v
	return s
}

// The picture width in pixels on the display where it will be played by a player.
// If you need to insert a web-player into a web page, use this value for choosing the player size.
// A value of -1 means that the heigth will be used to calculate the actual width with maintaining the aspect ratio.
// Only one of width or height may have value -1.
// Zero value (0) is not allowed.
func (s TcSizeImpl) Width() *int {
	return s.WidthValue
}

// The picture width in pixels on the display where it will be played by a player.
// If you need to insert a web-player into a web page, use this value for choosing the player size.
// A value of -1 means that the heigth will be used to calculate the actual width with maintaining the aspect ratio.
// Only one of width or height may have value -1.
// Zero value (0) is not allowed.
func (s *TcSizeImpl) SetWidth(v int) TcSize {
	if s == nil {
		return nil
	}
	s.WidthValue = &v
	return s
}

// NewTcVideoOpts creates a new TcVideoOpts instance
func NewTcVideoOpts() TcVideoOpts {
	return &TcVideoOptsImpl{}
}

// The configuration of a logo added to the video track after the video was resized as specified in the `size` option.
// This prevents the logo picture from stretching that might occur when the `logo` option is used.
// You will need to prepare and specify a separate file with a logo for each size of the resulting video track.
func (s TcVideoOptsImpl) Alogo() TcLogo {
	return s.AlogoValue
}

// The configuration of a logo added to the video track after the video was resized as specified in the `size` option.
// This prevents the logo picture from stretching that might occur when the `logo` option is used.
// You will need to prepare and specify a separate file with a logo for each size of the resulting video track.
func (s *TcVideoOptsImpl) SetAlogo(v TcLogo) TcVideoOpts {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*TcLogoImpl); ok {
		s.AlogoValue = impl
	}
	return s
}

// Number of B-frames in a GOP. B-frames contain links to keyframes and P-frames before and after themselves.
// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
// When set to 0, this option disables b-frames. This may be necessary, for example, when broadcasting to RTSP.
// Example: 3
func (s TcVideoOptsImpl) Bframes() *int {
	return s.BframesValue
}

// Number of B-frames in a GOP. B-frames contain links to keyframes and P-frames before and after themselves.
// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
// When set to 0, this option disables b-frames. This may be necessary, for example, when broadcasting to RTSP.
// Example: 3
func (s *TcVideoOptsImpl) SetBframes(v int) TcVideoOpts {
	if s == nil {
		return nil
	}
	s.BframesValue = &v
	return s
}

// The bitrate of a video track.
// Example: 1e+06
func (s TcVideoOptsImpl) Bitrate() *TcBitrate {
	return s.BitrateValue
}

// The bitrate of a video track.
// Example: 1e+06
func (s *TcVideoOptsImpl) SetBitrate(v *TcBitrate) TcVideoOpts {
	if s == nil {
		return nil
	}
	s.BitrateValue = v
	return s
}

// Configuration of burn-in text, timestamp, or subtitles to video frames.
func (s TcVideoOptsImpl) Burn() TcBurn {
	return s.BurnValue
}

// Configuration of burn-in text, timestamp, or subtitles to video frames.
func (s *TcVideoOptsImpl) SetBurn(v TcBurn) TcVideoOpts {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*TcBurnImpl); ok {
		s.BurnValue = impl
	}
	return s
}

// The video codec.
func (s TcVideoOptsImpl) Codec() *TcVideoOptsCodec {
	return s.CodecValue
}

// The video codec.
func (s *TcVideoOptsImpl) SetCodec(v TcVideoOptsCodec) TcVideoOpts {
	if s == nil {
		return nil
	}
	s.CodecValue = &v
	return s
}

// Some additional options.
func (s TcVideoOptsImpl) Extra() map[string]string {
	return s.ExtraValue
}

// Some additional options.
func (s *TcVideoOptsImpl) SetExtra(v map[string]string) TcVideoOpts {
	if s == nil {
		return nil
	}
	s.ExtraValue = v
	return s
}

// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
// Higher frame rates capture more images per second, which makes for smoother video.
// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
func (s TcVideoOptsImpl) FPS() *TcFPS {
	return s.FPSValue
}

// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
// Higher frame rates capture more images per second, which makes for smoother video.
// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
func (s *TcVideoOptsImpl) SetFPS(v *TcFPS) TcVideoOpts {
	if s == nil {
		return nil
	}
	s.FPSValue = v
	return s
}

// Sets the number of frames in a GOP.
// The encoder will create all GOPs of an exactly identical size - as specified in this option.
// Example: 150
func (s TcVideoOptsImpl) Gop() *int {
	return s.GopValue
}

// Sets the number of frames in a GOP.
// The encoder will create all GOPs of an exactly identical size - as specified in this option.
// Example: 150
func (s *TcVideoOptsImpl) SetGop(v int) TcVideoOpts {
	if s == nil {
		return nil
	}
	s.GopValue = &v
	return s
}

// This parameter is used to get an interlaced stream from a progressive one.
// The allowed values are `true` (interlaced video), `false` (progressive video), or one of the methods for producing interlaced video supported for the selected type of transcoder.
func (s TcVideoOptsImpl) Interlace() *InterlaceSettings {
	return s.InterlaceValue
}

// This parameter is used to get an interlaced stream from a progressive one.
// The allowed values are `true` (interlaced video), `false` (progressive video), or one of the methods for producing interlaced video supported for the selected type of transcoder.
func (s *TcVideoOptsImpl) SetInterlace(v *InterlaceSettings) TcVideoOpts {
	if s == nil {
		return nil
	}
	s.InterlaceValue = v
	return s
}

// A set of constraints that indicate a degree of required decoder performance.
// This parameter is used for compatibility with old devices.
func (s TcVideoOptsImpl) Level() any {
	return s.LevelValue
}

// A set of constraints that indicate a degree of required decoder performance.
// This parameter is used for compatibility with old devices.
func (s *TcVideoOptsImpl) SetLevel(v any) TcVideoOpts {
	if s == nil {
		return nil
	}
	s.LevelValue = v
	return s
}

// The configuration of a logo "burned" into the video track.
// The transcoder adds the logo before the video is resized as specified in the `size` option.
// This means that the logo can be visibly stretched if the size was changed significantly.
func (s TcVideoOptsImpl) Logo() TcLogo {
	return s.LogoValue
}

// The configuration of a logo "burned" into the video track.
// The transcoder adds the logo before the video is resized as specified in the `size` option.
// This means that the logo can be visibly stretched if the size was changed significantly.
func (s *TcVideoOptsImpl) SetLogo(v TcLogo) TcVideoOpts {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*TcLogoImpl); ok {
		s.LogoValue = impl
	}
	return s
}

// Whether open GOP is used. Open GOP contains P-frames that refer to the frames before the keyframe.
// It allows to decrease bitrate to 5-7%, but can result in breaking the picture.
func (s TcVideoOptsImpl) OpenGop() *bool {
	return s.OpenGopValue
}

// Whether open GOP is used. Open GOP contains P-frames that refer to the frames before the keyframe.
// It allows to decrease bitrate to 5-7%, but can result in breaking the picture.
func (s *TcVideoOptsImpl) SetOpenGop(v bool) TcVideoOpts {
	if s == nil {
		return nil
	}
	s.OpenGopValue = &v
	return s
}

// A set of values that determine a certain encoding speed, which influences a compression ratio.
// A slower preset will provide better compression (compression is quality per file size).
// Example: medium
func (s TcVideoOptsImpl) Preset() *TcPreset {
	return s.PresetValue
}

// A set of values that determine a certain encoding speed, which influences a compression ratio.
// A slower preset will provide better compression (compression is quality per file size).
// Example: medium
func (s *TcVideoOptsImpl) SetPreset(v TcPreset) TcVideoOpts {
	if s == nil {
		return nil
	}
	s.PresetValue = &v
	return s
}

// Limits the output to a specific H.264 profile.
func (s TcVideoOptsImpl) Profile() *TcProfile {
	return s.ProfileValue
}

// Limits the output to a specific H.264 profile.
func (s *TcVideoOptsImpl) SetProfile(v TcProfile) TcVideoOpts {
	if s == nil {
		return nil
	}
	s.ProfileValue = &v
	return s
}

// The ranges of the quantization parameter for different types of frames in a GOP.
// Quantization is an algorithm used for video compression. It is based on fragmentation of video frames.
// Increasing this parameter allows to improve the compression but may lower the picture quality.
// Usually, these ranges are defined automatically by the transcoder, but for some types of transcoders it makes sense to set them manually.
func (s TcVideoOptsImpl) QpRange() TcQpRange {
	return s.QpRangeValue
}

// The ranges of the quantization parameter for different types of frames in a GOP.
// Quantization is an algorithm used for video compression. It is based on fragmentation of video frames.
// Increasing this parameter allows to improve the compression but may lower the picture quality.
// Usually, these ranges are defined automatically by the transcoder, but for some types of transcoders it makes sense to set them manually.
func (s *TcVideoOptsImpl) SetQpRange(v TcQpRange) TcVideoOpts {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*TcQpRangeImpl); ok {
		s.QpRangeValue = impl
	}
	return s
}

// A method for creating output video with constant bitrate suitable for broadcasting to television networks.
func (s TcVideoOptsImpl) RcMethod() *RcMethod {
	return s.RcMethodValue
}

// A method for creating output video with constant bitrate suitable for broadcasting to television networks.
func (s *TcVideoOptsImpl) SetRcMethod(v RcMethod) TcVideoOpts {
	if s == nil {
		return nil
	}
	s.RcMethodValue = &v
	return s
}

// The number of reference frames in a GOP.
// Reference frames are frames of a compressed video that are used to define other frames (P-frames and B-frames).
func (s TcVideoOptsImpl) Refs() *int {
	return s.RefsValue
}

// The number of reference frames in a GOP.
// Reference frames are frames of a compressed video that are used to define other frames (P-frames and B-frames).
func (s *TcVideoOptsImpl) SetRefs(v int) TcVideoOpts {
	if s == nil {
		return nil
	}
	s.RefsValue = &v
	return s
}

// The mode to be used for resizing video tracks. It is one of the computing platforms for Flussonic Coder:
// * vic -  Video Image Converter, specific for Jetson Nvidia
// * cuda - CUDA (or Compute Unified Device Architecture)
func (s TcVideoOptsImpl) ResizeMode() *TranscoderResizeMode {
	return s.ResizeModeValue
}

// The mode to be used for resizing video tracks. It is one of the computing platforms for Flussonic Coder:
// * vic -  Video Image Converter, specific for Jetson Nvidia
// * cuda - CUDA (or Compute Unified Device Architecture)
func (s *TcVideoOptsImpl) SetResizeMode(v TranscoderResizeMode) TcVideoOpts {
	if s == nil {
		return nil
	}
	s.ResizeModeValue = &v
	return s
}

// Target aspect ratio.
func (s TcVideoOptsImpl) Sar() TcSar {
	return s.SarValue
}

// Target aspect ratio.
func (s *TcVideoOptsImpl) SetSar(v TcSar) TcVideoOpts {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*TcSarImpl); ok {
		s.SarValue = impl
	}
	return s
}

// Target size of the image and the strategy to achieve it.
func (s TcVideoOptsImpl) Size() TcSize {
	return s.SizeValue
}

// Target size of the image and the strategy to achieve it.
func (s *TcVideoOptsImpl) SetSize(v TcSize) TcVideoOpts {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*TcSizeImpl); ok {
		s.SizeValue = impl
	}
	return s
}

// Drop some frames in dynamic scenes when the transcoder does not have time to code all frames.
// The allowed values are:
// * `15` - drop 1 from 5
// * `13` - drop 1 from 3
// * `12` - drop 1 from 2
// * `23` - drop 2 from 3
// * `0` - do not drop frames
func (s TcVideoOptsImpl) TemporalTradeoff() *int {
	return s.TemporalTradeoffValue
}

// Drop some frames in dynamic scenes when the transcoder does not have time to code all frames.
// The allowed values are:
// * `15` - drop 1 from 5
// * `13` - drop 1 from 3
// * `12` - drop 1 from 2
// * `23` - drop 2 from 3
// * `0` - do not drop frames
func (s *TcVideoOptsImpl) SetTemporalTradeoff(v int) TcVideoOpts {
	if s == nil {
		return nil
	}
	s.TemporalTradeoffValue = &v
	return s
}

// Number of threads used by the encoder when transcoding with CPU (it is not used for other types of transcoder).
// This parameter allows to increase performance by adding new threads. By default, it is autodetected.
func (s TcVideoOptsImpl) Threads() *int {
	return s.ThreadsValue
}

// Number of threads used by the encoder when transcoding with CPU (it is not used for other types of transcoder).
// This parameter allows to increase performance by adding new threads. By default, it is autodetected.
func (s *TcVideoOptsImpl) SetThreads(v int) TcVideoOpts {
	if s == nil {
		return nil
	}
	s.ThreadsValue = &v
	return s
}

// Number of a video track.
// Example: 1
func (s TcVideoOptsImpl) Track() int {
	return s.TrackValue
}

// Number of a video track.
// Example: 1
func (s *TcVideoOptsImpl) SetTrack(v int) TcVideoOpts {
	if s == nil {
		return nil
	}
	s.TrackValue = v
	return s
}

// Virtual buffer size, it bits. The default value is `gop / fps * bitrate`.
func (s TcVideoOptsImpl) VbvBufsize() *int {
	return s.VbvBufsizeValue
}

// Virtual buffer size, it bits. The default value is `gop / fps * bitrate`.
func (s *TcVideoOptsImpl) SetVbvBufsize(v int) TcVideoOpts {
	if s == nil {
		return nil
	}
	s.VbvBufsizeValue = &v
	return s
}

// NewThumbnailsSizeSpec creates a new ThumbnailsSizeSpec instance
func NewThumbnailsSizeSpec() ThumbnailsSizeSpec {
	return &ThumbnailsSizeSpecImpl{}
}

// The thumbnail height.
func (s ThumbnailsSizeSpecImpl) Height() *int {
	return s.HeightValue
}

// The thumbnail height.
func (s *ThumbnailsSizeSpecImpl) SetHeight(v int) ThumbnailsSizeSpec {
	if s == nil {
		return nil
	}
	s.HeightValue = &v
	return s
}

// The thumbnail width.
func (s ThumbnailsSizeSpecImpl) Width() *int {
	return s.WidthValue
}

// The thumbnail width.
func (s *ThumbnailsSizeSpecImpl) SetWidth(v int) ThumbnailsSizeSpec {
	if s == nil {
		return nil
	}
	s.WidthValue = &v
	return s
}

// NewThumbnailsSpec creates a new ThumbnailsSpec instance
func NewThumbnailsSpec() ThumbnailsSpec {
	return &ThumbnailsSpecImpl{}
}

// Whether to generate thumbnails from the video stream.
func (s ThumbnailsSpecImpl) Enabled() any {
	return s.EnabledValue
}

// Whether to generate thumbnails from the video stream.
func (s *ThumbnailsSpecImpl) SetEnabled(v any) ThumbnailsSpec {
	if s == nil {
		return nil
	}
	s.EnabledValue = v
	return s
}

// What sizes will be used for thumbnails generation.
func (s ThumbnailsSpecImpl) Sizes() []ThumbnailsSizeSpec {
	if s.SizesValue == nil {
		return nil
	}
	result := make([]ThumbnailsSizeSpec, len(s.SizesValue))
	for i, item := range s.SizesValue {
		result[i] = item
	}
	return result
}

// What sizes will be used for thumbnails generation.
func (s *ThumbnailsSpecImpl) SetSizes(v []ThumbnailsSizeSpec) ThumbnailsSpec {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*ThumbnailsSizeSpecImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*ThumbnailsSizeSpecImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.SizesValue = impl
	}
	return s
}

// *Flussonic* takes a thumbnail from the specified URL on each keyframe.
// May reduce CPU usage on IP cameras.
// Example: http://10.115.23.45/isapi/thumbnail.jpg
func (s ThumbnailsSpecImpl) URL() *string {
	return s.URLValue
}

// *Flussonic* takes a thumbnail from the specified URL on each keyframe.
// May reduce CPU usage on IP cameras.
// Example: http://10.115.23.45/isapi/thumbnail.jpg
func (s *ThumbnailsSpecImpl) SetURL(v string) ThumbnailsSpec {
	if s == nil {
		return nil
	}
	s.URLValue = &v
	return s
}

// NewTiAudioAac creates a new TiAudioAac instance
func NewTiAudioAac() TiAudioAac {
	return &TiAudioAacImpl{}
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s TiAudioAacImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s *TiAudioAacImpl) SetBitrate(v Speed) TiAudioAac {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// The number of audio channels in an output stream.
// Example: 2
func (s TiAudioAacImpl) Channels() *TiAudioAacSpecChannels {
	return s.ChannelsValue
}

// The number of audio channels in an output stream.
// Example: 2
func (s *TiAudioAacImpl) SetChannels(v TiAudioAacSpecChannels) TiAudioAac {
	if s == nil {
		return nil
	}
	s.ChannelsValue = &v
	return s
}

// Audio codec (the AAC codec is used by default).
// Example: opus
func (s TiAudioAacImpl) Codec() *string {
	return s.CodecValue
}

// Audio codec (the AAC codec is used by default).
// Example: opus
func (s *TiAudioAacImpl) SetCodec(v string) TiAudioAac {
	if s == nil {
		return nil
	}
	s.CodecValue = &v
	return s
}

// Content of the track (audio, video, or text).
func (s TiAudioAacImpl) Content() FrameContent {
	return s.ContentValue
}

// Content of the track (audio, video, or text).
func (s *TiAudioAacImpl) SetContent(v FrameContent) TiAudioAac {
	if s == nil {
		return nil
	}
	s.ContentValue = v
	return s
}

// Input audio track to be transcoded.
// Example: 1
func (s TiAudioAacImpl) InputTrack() *int {
	return s.InputTrackValue
}

// Input audio track to be transcoded.
// Example: 1
func (s *TiAudioAacImpl) SetInputTrack(v int) TiAudioAac {
	if s == nil {
		return nil
	}
	s.InputTrackValue = &v
	return s
}

// Language value of the track, if applicable.
// Example: eng
func (s TiAudioAacImpl) Language() *string {
	return s.LanguageValue
}

// Language value of the track, if applicable.
// Example: eng
func (s *TiAudioAacImpl) SetLanguage(v string) TiAudioAac {
	if s == nil {
		return nil
	}
	s.LanguageValue = &v
	return s
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s TiAudioAacImpl) Pid() *int {
	return s.PidValue
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s *TiAudioAacImpl) SetPid(v int) TiAudioAac {
	if s == nil {
		return nil
	}
	s.PidValue = &v
	return s
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// The allowed values are:
// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
// Example: 48000
func (s TiAudioAacImpl) SampleRate() *TiAudioAacSpecSampleRate {
	return s.SampleRateValue
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// The allowed values are:
// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
// Example: 48000
func (s *TiAudioAacImpl) SetSampleRate(v TiAudioAacSpecSampleRate) TiAudioAac {
	if s == nil {
		return nil
	}
	s.SampleRateValue = &v
	return s
}

// This option allows to split each audio track with multiple channels into several mono tracks.
func (s TiAudioAacImpl) SplitChannels() *bool {
	return s.SplitChannelsValue
}

// This option allows to split each audio track with multiple channels into several mono tracks.
func (s *TiAudioAacImpl) SetSplitChannels(v bool) TiAudioAac {
	if s == nil {
		return nil
	}
	s.SplitChannelsValue = &v
	return s
}

// Human-readable localized title of the track.
// Example: Video1
func (s TiAudioAacImpl) Title() *string {
	return s.TitleValue
}

// Human-readable localized title of the track.
// Example: Video1
func (s *TiAudioAacImpl) SetTitle(v string) TiAudioAac {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
// If it is just an integer or a float, the output audio volume is calculated by this formula:
// `output_volume = volume * input_volume`
// If specified in decibels (dB), the output audio volume is calculated as follows:
// `output_volume = input_volume +/- volume`
// depending whether it is a positive (+9dB) or a negative value (-6dB).
// By default it equals to 1 (the input audio volume).
// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
// Example: -6dB
func (s TiAudioAacImpl) Volume() *string {
	return s.VolumeValue
}

// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
// If it is just an integer or a float, the output audio volume is calculated by this formula:
// `output_volume = volume * input_volume`
// If specified in decibels (dB), the output audio volume is calculated as follows:
// `output_volume = input_volume +/- volume`
// depending whether it is a positive (+9dB) or a negative value (-6dB).
// By default it equals to 1 (the input audio volume).
// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
// Example: -6dB
func (s *TiAudioAacImpl) SetVolume(v string) TiAudioAac {
	if s == nil {
		return nil
	}
	s.VolumeValue = &v
	return s
}

// NewTiAudioAacSpec creates a new TiAudioAacSpec instance
func NewTiAudioAacSpec() TiAudioAacSpec {
	return &TiAudioAacSpecImpl{}
}

// The number of audio channels in an output stream.
// Example: 2
func (s TiAudioAacSpecImpl) Channels() *TiAudioAacSpecChannels {
	return s.ChannelsValue
}

// The number of audio channels in an output stream.
// Example: 2
func (s *TiAudioAacSpecImpl) SetChannels(v TiAudioAacSpecChannels) TiAudioAacSpec {
	if s == nil {
		return nil
	}
	s.ChannelsValue = &v
	return s
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// The allowed values are:
// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
// Example: 48000
func (s TiAudioAacSpecImpl) SampleRate() *TiAudioAacSpecSampleRate {
	return s.SampleRateValue
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// The allowed values are:
// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
// Example: 48000
func (s *TiAudioAacSpecImpl) SetSampleRate(v TiAudioAacSpecSampleRate) TiAudioAacSpec {
	if s == nil {
		return nil
	}
	s.SampleRateValue = &v
	return s
}

// NewTiAudioAc3 creates a new TiAudioAc3 instance
func NewTiAudioAc3() TiAudioAc3 {
	return &TiAudioAc3Impl{}
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s TiAudioAc3Impl) Bitrate() *Speed {
	return s.BitrateValue
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s *TiAudioAc3Impl) SetBitrate(v Speed) TiAudioAc3 {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// The number of audio channels in an output stream.
// Example: 2
func (s TiAudioAc3Impl) Channels() *TiAudioAc3SpecChannels {
	return s.ChannelsValue
}

// The number of audio channels in an output stream.
// Example: 2
func (s *TiAudioAc3Impl) SetChannels(v TiAudioAc3SpecChannels) TiAudioAc3 {
	if s == nil {
		return nil
	}
	s.ChannelsValue = &v
	return s
}

// Audio codec (the AAC codec is used by default).
// Example: opus
func (s TiAudioAc3Impl) Codec() *string {
	return s.CodecValue
}

// Audio codec (the AAC codec is used by default).
// Example: opus
func (s *TiAudioAc3Impl) SetCodec(v string) TiAudioAc3 {
	if s == nil {
		return nil
	}
	s.CodecValue = &v
	return s
}

// Content of the track (audio, video, or text).
func (s TiAudioAc3Impl) Content() FrameContent {
	return s.ContentValue
}

// Content of the track (audio, video, or text).
func (s *TiAudioAc3Impl) SetContent(v FrameContent) TiAudioAc3 {
	if s == nil {
		return nil
	}
	s.ContentValue = v
	return s
}

// Input audio track to be transcoded.
// Example: 1
func (s TiAudioAc3Impl) InputTrack() *int {
	return s.InputTrackValue
}

// Input audio track to be transcoded.
// Example: 1
func (s *TiAudioAc3Impl) SetInputTrack(v int) TiAudioAc3 {
	if s == nil {
		return nil
	}
	s.InputTrackValue = &v
	return s
}

// Language value of the track, if applicable.
// Example: eng
func (s TiAudioAc3Impl) Language() *string {
	return s.LanguageValue
}

// Language value of the track, if applicable.
// Example: eng
func (s *TiAudioAc3Impl) SetLanguage(v string) TiAudioAc3 {
	if s == nil {
		return nil
	}
	s.LanguageValue = &v
	return s
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s TiAudioAc3Impl) Pid() *int {
	return s.PidValue
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s *TiAudioAc3Impl) SetPid(v int) TiAudioAc3 {
	if s == nil {
		return nil
	}
	s.PidValue = &v
	return s
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// The allowed values are:
// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
// Example: 48000
func (s TiAudioAc3Impl) SampleRate() *TiAudioAc3SpecSampleRate {
	return s.SampleRateValue
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// The allowed values are:
// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
// Example: 48000
func (s *TiAudioAc3Impl) SetSampleRate(v TiAudioAc3SpecSampleRate) TiAudioAc3 {
	if s == nil {
		return nil
	}
	s.SampleRateValue = &v
	return s
}

// This option allows to split each audio track with multiple channels into several mono tracks.
func (s TiAudioAc3Impl) SplitChannels() *bool {
	return s.SplitChannelsValue
}

// This option allows to split each audio track with multiple channels into several mono tracks.
func (s *TiAudioAc3Impl) SetSplitChannels(v bool) TiAudioAc3 {
	if s == nil {
		return nil
	}
	s.SplitChannelsValue = &v
	return s
}

// Human-readable localized title of the track.
// Example: Video1
func (s TiAudioAc3Impl) Title() *string {
	return s.TitleValue
}

// Human-readable localized title of the track.
// Example: Video1
func (s *TiAudioAc3Impl) SetTitle(v string) TiAudioAc3 {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
// If it is just an integer or a float, the output audio volume is calculated by this formula:
// `output_volume = volume * input_volume`
// If specified in decibels (dB), the output audio volume is calculated as follows:
// `output_volume = input_volume +/- volume`
// depending whether it is a positive (+9dB) or a negative value (-6dB).
// By default it equals to 1 (the input audio volume).
// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
// Example: -6dB
func (s TiAudioAc3Impl) Volume() *string {
	return s.VolumeValue
}

// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
// If it is just an integer or a float, the output audio volume is calculated by this formula:
// `output_volume = volume * input_volume`
// If specified in decibels (dB), the output audio volume is calculated as follows:
// `output_volume = input_volume +/- volume`
// depending whether it is a positive (+9dB) or a negative value (-6dB).
// By default it equals to 1 (the input audio volume).
// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
// Example: -6dB
func (s *TiAudioAc3Impl) SetVolume(v string) TiAudioAc3 {
	if s == nil {
		return nil
	}
	s.VolumeValue = &v
	return s
}

// NewTiAudioAc3Spec creates a new TiAudioAc3Spec instance
func NewTiAudioAc3Spec() TiAudioAc3Spec {
	return &TiAudioAc3SpecImpl{}
}

// The number of audio channels in an output stream.
// Example: 2
func (s TiAudioAc3SpecImpl) Channels() *TiAudioAc3SpecChannels {
	return s.ChannelsValue
}

// The number of audio channels in an output stream.
// Example: 2
func (s *TiAudioAc3SpecImpl) SetChannels(v TiAudioAc3SpecChannels) TiAudioAc3Spec {
	if s == nil {
		return nil
	}
	s.ChannelsValue = &v
	return s
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// The allowed values are:
// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
// Example: 48000
func (s TiAudioAc3SpecImpl) SampleRate() *TiAudioAc3SpecSampleRate {
	return s.SampleRateValue
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// The allowed values are:
// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
// Example: 48000
func (s *TiAudioAc3SpecImpl) SetSampleRate(v TiAudioAc3SpecSampleRate) TiAudioAc3Spec {
	if s == nil {
		return nil
	}
	s.SampleRateValue = &v
	return s
}

// NewTiAudioMp2a creates a new TiAudioMp2a instance
func NewTiAudioMp2a() TiAudioMp2a {
	return &TiAudioMp2aImpl{}
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s TiAudioMp2aImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s *TiAudioMp2aImpl) SetBitrate(v Speed) TiAudioMp2a {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// The number of audio channels in an output stream.
// Example: 2
func (s TiAudioMp2aImpl) Channels() *TiAudioMp2aSpecChannels {
	return s.ChannelsValue
}

// The number of audio channels in an output stream.
// Example: 2
func (s *TiAudioMp2aImpl) SetChannels(v TiAudioMp2aSpecChannels) TiAudioMp2a {
	if s == nil {
		return nil
	}
	s.ChannelsValue = &v
	return s
}

// Audio codec (the AAC codec is used by default).
// Example: opus
func (s TiAudioMp2aImpl) Codec() *string {
	return s.CodecValue
}

// Audio codec (the AAC codec is used by default).
// Example: opus
func (s *TiAudioMp2aImpl) SetCodec(v string) TiAudioMp2a {
	if s == nil {
		return nil
	}
	s.CodecValue = &v
	return s
}

// Content of the track (audio, video, or text).
func (s TiAudioMp2aImpl) Content() FrameContent {
	return s.ContentValue
}

// Content of the track (audio, video, or text).
func (s *TiAudioMp2aImpl) SetContent(v FrameContent) TiAudioMp2a {
	if s == nil {
		return nil
	}
	s.ContentValue = v
	return s
}

// Input audio track to be transcoded.
// Example: 1
func (s TiAudioMp2aImpl) InputTrack() *int {
	return s.InputTrackValue
}

// Input audio track to be transcoded.
// Example: 1
func (s *TiAudioMp2aImpl) SetInputTrack(v int) TiAudioMp2a {
	if s == nil {
		return nil
	}
	s.InputTrackValue = &v
	return s
}

// Language value of the track, if applicable.
// Example: eng
func (s TiAudioMp2aImpl) Language() *string {
	return s.LanguageValue
}

// Language value of the track, if applicable.
// Example: eng
func (s *TiAudioMp2aImpl) SetLanguage(v string) TiAudioMp2a {
	if s == nil {
		return nil
	}
	s.LanguageValue = &v
	return s
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s TiAudioMp2aImpl) Pid() *int {
	return s.PidValue
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s *TiAudioMp2aImpl) SetPid(v int) TiAudioMp2a {
	if s == nil {
		return nil
	}
	s.PidValue = &v
	return s
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// The allowed values are:
// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
// Example: 48000
func (s TiAudioMp2aImpl) SampleRate() *TiAudioMp2aSpecSampleRate {
	return s.SampleRateValue
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// The allowed values are:
// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
// Example: 48000
func (s *TiAudioMp2aImpl) SetSampleRate(v TiAudioMp2aSpecSampleRate) TiAudioMp2a {
	if s == nil {
		return nil
	}
	s.SampleRateValue = &v
	return s
}

// This option allows to split each audio track with multiple channels into several mono tracks.
func (s TiAudioMp2aImpl) SplitChannels() *bool {
	return s.SplitChannelsValue
}

// This option allows to split each audio track with multiple channels into several mono tracks.
func (s *TiAudioMp2aImpl) SetSplitChannels(v bool) TiAudioMp2a {
	if s == nil {
		return nil
	}
	s.SplitChannelsValue = &v
	return s
}

// Human-readable localized title of the track.
// Example: Video1
func (s TiAudioMp2aImpl) Title() *string {
	return s.TitleValue
}

// Human-readable localized title of the track.
// Example: Video1
func (s *TiAudioMp2aImpl) SetTitle(v string) TiAudioMp2a {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
// If it is just an integer or a float, the output audio volume is calculated by this formula:
// `output_volume = volume * input_volume`
// If specified in decibels (dB), the output audio volume is calculated as follows:
// `output_volume = input_volume +/- volume`
// depending whether it is a positive (+9dB) or a negative value (-6dB).
// By default it equals to 1 (the input audio volume).
// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
// Example: -6dB
func (s TiAudioMp2aImpl) Volume() *string {
	return s.VolumeValue
}

// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
// If it is just an integer or a float, the output audio volume is calculated by this formula:
// `output_volume = volume * input_volume`
// If specified in decibels (dB), the output audio volume is calculated as follows:
// `output_volume = input_volume +/- volume`
// depending whether it is a positive (+9dB) or a negative value (-6dB).
// By default it equals to 1 (the input audio volume).
// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
// Example: -6dB
func (s *TiAudioMp2aImpl) SetVolume(v string) TiAudioMp2a {
	if s == nil {
		return nil
	}
	s.VolumeValue = &v
	return s
}

// NewTiAudioMp2aSpec creates a new TiAudioMp2aSpec instance
func NewTiAudioMp2aSpec() TiAudioMp2aSpec {
	return &TiAudioMp2aSpecImpl{}
}

// The number of audio channels in an output stream.
// Example: 2
func (s TiAudioMp2aSpecImpl) Channels() *TiAudioMp2aSpecChannels {
	return s.ChannelsValue
}

// The number of audio channels in an output stream.
// Example: 2
func (s *TiAudioMp2aSpecImpl) SetChannels(v TiAudioMp2aSpecChannels) TiAudioMp2aSpec {
	if s == nil {
		return nil
	}
	s.ChannelsValue = &v
	return s
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// The allowed values are:
// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
// Example: 48000
func (s TiAudioMp2aSpecImpl) SampleRate() *TiAudioMp2aSpecSampleRate {
	return s.SampleRateValue
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// The allowed values are:
// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
// Example: 48000
func (s *TiAudioMp2aSpecImpl) SetSampleRate(v TiAudioMp2aSpecSampleRate) TiAudioMp2aSpec {
	if s == nil {
		return nil
	}
	s.SampleRateValue = &v
	return s
}

// NewTiAudioMp3 creates a new TiAudioMp3 instance
func NewTiAudioMp3() TiAudioMp3 {
	return &TiAudioMp3Impl{}
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s TiAudioMp3Impl) Bitrate() *Speed {
	return s.BitrateValue
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s *TiAudioMp3Impl) SetBitrate(v Speed) TiAudioMp3 {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// The number of audio channels in an output stream.
// Example: 2
func (s TiAudioMp3Impl) Channels() *TiAudioMp3SpecChannels {
	return s.ChannelsValue
}

// The number of audio channels in an output stream.
// Example: 2
func (s *TiAudioMp3Impl) SetChannels(v TiAudioMp3SpecChannels) TiAudioMp3 {
	if s == nil {
		return nil
	}
	s.ChannelsValue = &v
	return s
}

// Audio codec (the AAC codec is used by default).
// Example: opus
func (s TiAudioMp3Impl) Codec() *string {
	return s.CodecValue
}

// Audio codec (the AAC codec is used by default).
// Example: opus
func (s *TiAudioMp3Impl) SetCodec(v string) TiAudioMp3 {
	if s == nil {
		return nil
	}
	s.CodecValue = &v
	return s
}

// Content of the track (audio, video, or text).
func (s TiAudioMp3Impl) Content() FrameContent {
	return s.ContentValue
}

// Content of the track (audio, video, or text).
func (s *TiAudioMp3Impl) SetContent(v FrameContent) TiAudioMp3 {
	if s == nil {
		return nil
	}
	s.ContentValue = v
	return s
}

// Input audio track to be transcoded.
// Example: 1
func (s TiAudioMp3Impl) InputTrack() *int {
	return s.InputTrackValue
}

// Input audio track to be transcoded.
// Example: 1
func (s *TiAudioMp3Impl) SetInputTrack(v int) TiAudioMp3 {
	if s == nil {
		return nil
	}
	s.InputTrackValue = &v
	return s
}

// Language value of the track, if applicable.
// Example: eng
func (s TiAudioMp3Impl) Language() *string {
	return s.LanguageValue
}

// Language value of the track, if applicable.
// Example: eng
func (s *TiAudioMp3Impl) SetLanguage(v string) TiAudioMp3 {
	if s == nil {
		return nil
	}
	s.LanguageValue = &v
	return s
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s TiAudioMp3Impl) Pid() *int {
	return s.PidValue
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s *TiAudioMp3Impl) SetPid(v int) TiAudioMp3 {
	if s == nil {
		return nil
	}
	s.PidValue = &v
	return s
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// The allowed values are:
// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
// Example: 8000
func (s TiAudioMp3Impl) SampleRate() *TiAudioMp3SpecSampleRate {
	return s.SampleRateValue
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// The allowed values are:
// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
// Example: 8000
func (s *TiAudioMp3Impl) SetSampleRate(v TiAudioMp3SpecSampleRate) TiAudioMp3 {
	if s == nil {
		return nil
	}
	s.SampleRateValue = &v
	return s
}

// This option allows to split each audio track with multiple channels into several mono tracks.
func (s TiAudioMp3Impl) SplitChannels() *bool {
	return s.SplitChannelsValue
}

// This option allows to split each audio track with multiple channels into several mono tracks.
func (s *TiAudioMp3Impl) SetSplitChannels(v bool) TiAudioMp3 {
	if s == nil {
		return nil
	}
	s.SplitChannelsValue = &v
	return s
}

// Human-readable localized title of the track.
// Example: Video1
func (s TiAudioMp3Impl) Title() *string {
	return s.TitleValue
}

// Human-readable localized title of the track.
// Example: Video1
func (s *TiAudioMp3Impl) SetTitle(v string) TiAudioMp3 {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
// If it is just an integer or a float, the output audio volume is calculated by this formula:
// `output_volume = volume * input_volume`
// If specified in decibels (dB), the output audio volume is calculated as follows:
// `output_volume = input_volume +/- volume`
// depending whether it is a positive (+9dB) or a negative value (-6dB).
// By default it equals to 1 (the input audio volume).
// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
// Example: -6dB
func (s TiAudioMp3Impl) Volume() *string {
	return s.VolumeValue
}

// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
// If it is just an integer or a float, the output audio volume is calculated by this formula:
// `output_volume = volume * input_volume`
// If specified in decibels (dB), the output audio volume is calculated as follows:
// `output_volume = input_volume +/- volume`
// depending whether it is a positive (+9dB) or a negative value (-6dB).
// By default it equals to 1 (the input audio volume).
// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
// Example: -6dB
func (s *TiAudioMp3Impl) SetVolume(v string) TiAudioMp3 {
	if s == nil {
		return nil
	}
	s.VolumeValue = &v
	return s
}

// NewTiAudioMp3Spec creates a new TiAudioMp3Spec instance
func NewTiAudioMp3Spec() TiAudioMp3Spec {
	return &TiAudioMp3SpecImpl{}
}

// The number of audio channels in an output stream.
// Example: 2
func (s TiAudioMp3SpecImpl) Channels() *TiAudioMp3SpecChannels {
	return s.ChannelsValue
}

// The number of audio channels in an output stream.
// Example: 2
func (s *TiAudioMp3SpecImpl) SetChannels(v TiAudioMp3SpecChannels) TiAudioMp3Spec {
	if s == nil {
		return nil
	}
	s.ChannelsValue = &v
	return s
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// The allowed values are:
// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
// Example: 8000
func (s TiAudioMp3SpecImpl) SampleRate() *TiAudioMp3SpecSampleRate {
	return s.SampleRateValue
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// The allowed values are:
// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
// Example: 8000
func (s *TiAudioMp3SpecImpl) SetSampleRate(v TiAudioMp3SpecSampleRate) TiAudioMp3Spec {
	if s == nil {
		return nil
	}
	s.SampleRateValue = &v
	return s
}

// NewTiAudioOpus creates a new TiAudioOpus instance
func NewTiAudioOpus() TiAudioOpus {
	return &TiAudioOpusImpl{}
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s TiAudioOpusImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s *TiAudioOpusImpl) SetBitrate(v Speed) TiAudioOpus {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// The number of audio channels in an output stream.
// Example: 2
func (s TiAudioOpusImpl) Channels() *TiAudioOpusSpecChannels {
	return s.ChannelsValue
}

// The number of audio channels in an output stream.
// Example: 2
func (s *TiAudioOpusImpl) SetChannels(v TiAudioOpusSpecChannels) TiAudioOpus {
	if s == nil {
		return nil
	}
	s.ChannelsValue = &v
	return s
}

// Audio codec (the AAC codec is used by default).
// Example: opus
func (s TiAudioOpusImpl) Codec() *string {
	return s.CodecValue
}

// Audio codec (the AAC codec is used by default).
// Example: opus
func (s *TiAudioOpusImpl) SetCodec(v string) TiAudioOpus {
	if s == nil {
		return nil
	}
	s.CodecValue = &v
	return s
}

// Content of the track (audio, video, or text).
func (s TiAudioOpusImpl) Content() FrameContent {
	return s.ContentValue
}

// Content of the track (audio, video, or text).
func (s *TiAudioOpusImpl) SetContent(v FrameContent) TiAudioOpus {
	if s == nil {
		return nil
	}
	s.ContentValue = v
	return s
}

// Input audio track to be transcoded.
// Example: 1
func (s TiAudioOpusImpl) InputTrack() *int {
	return s.InputTrackValue
}

// Input audio track to be transcoded.
// Example: 1
func (s *TiAudioOpusImpl) SetInputTrack(v int) TiAudioOpus {
	if s == nil {
		return nil
	}
	s.InputTrackValue = &v
	return s
}

// Language value of the track, if applicable.
// Example: eng
func (s TiAudioOpusImpl) Language() *string {
	return s.LanguageValue
}

// Language value of the track, if applicable.
// Example: eng
func (s *TiAudioOpusImpl) SetLanguage(v string) TiAudioOpus {
	if s == nil {
		return nil
	}
	s.LanguageValue = &v
	return s
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s TiAudioOpusImpl) Pid() *int {
	return s.PidValue
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s *TiAudioOpusImpl) SetPid(v int) TiAudioOpus {
	if s == nil {
		return nil
	}
	s.PidValue = &v
	return s
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// The allowed values are:
// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
// Example: 48000
func (s TiAudioOpusImpl) SampleRate() *TiAudioOpusSpecSampleRate {
	return s.SampleRateValue
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// The allowed values are:
// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
// Example: 48000
func (s *TiAudioOpusImpl) SetSampleRate(v TiAudioOpusSpecSampleRate) TiAudioOpus {
	if s == nil {
		return nil
	}
	s.SampleRateValue = &v
	return s
}

// This option allows to split each audio track with multiple channels into several mono tracks.
func (s TiAudioOpusImpl) SplitChannels() *bool {
	return s.SplitChannelsValue
}

// This option allows to split each audio track with multiple channels into several mono tracks.
func (s *TiAudioOpusImpl) SetSplitChannels(v bool) TiAudioOpus {
	if s == nil {
		return nil
	}
	s.SplitChannelsValue = &v
	return s
}

// Human-readable localized title of the track.
// Example: Video1
func (s TiAudioOpusImpl) Title() *string {
	return s.TitleValue
}

// Human-readable localized title of the track.
// Example: Video1
func (s *TiAudioOpusImpl) SetTitle(v string) TiAudioOpus {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
// If it is just an integer or a float, the output audio volume is calculated by this formula:
// `output_volume = volume * input_volume`
// If specified in decibels (dB), the output audio volume is calculated as follows:
// `output_volume = input_volume +/- volume`
// depending whether it is a positive (+9dB) or a negative value (-6dB).
// By default it equals to 1 (the input audio volume).
// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
// Example: -6dB
func (s TiAudioOpusImpl) Volume() *string {
	return s.VolumeValue
}

// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
// If it is just an integer or a float, the output audio volume is calculated by this formula:
// `output_volume = volume * input_volume`
// If specified in decibels (dB), the output audio volume is calculated as follows:
// `output_volume = input_volume +/- volume`
// depending whether it is a positive (+9dB) or a negative value (-6dB).
// By default it equals to 1 (the input audio volume).
// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
// Example: -6dB
func (s *TiAudioOpusImpl) SetVolume(v string) TiAudioOpus {
	if s == nil {
		return nil
	}
	s.VolumeValue = &v
	return s
}

// NewTiAudioOpusSpec creates a new TiAudioOpusSpec instance
func NewTiAudioOpusSpec() TiAudioOpusSpec {
	return &TiAudioOpusSpecImpl{}
}

// The number of audio channels in an output stream.
// Example: 2
func (s TiAudioOpusSpecImpl) Channels() *TiAudioOpusSpecChannels {
	return s.ChannelsValue
}

// The number of audio channels in an output stream.
// Example: 2
func (s *TiAudioOpusSpecImpl) SetChannels(v TiAudioOpusSpecChannels) TiAudioOpusSpec {
	if s == nil {
		return nil
	}
	s.ChannelsValue = &v
	return s
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// The allowed values are:
// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
// Example: 48000
func (s TiAudioOpusSpecImpl) SampleRate() *TiAudioOpusSpecSampleRate {
	return s.SampleRateValue
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// The allowed values are:
// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
// Example: 48000
func (s *TiAudioOpusSpecImpl) SetSampleRate(v TiAudioOpusSpecSampleRate) TiAudioOpusSpec {
	if s == nil {
		return nil
	}
	s.SampleRateValue = &v
	return s
}

// NewTiAudioPcm creates a new TiAudioPcm instance
func NewTiAudioPcm() TiAudioPcm {
	return &TiAudioPcmImpl{}
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s TiAudioPcmImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s *TiAudioPcmImpl) SetBitrate(v Speed) TiAudioPcm {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// The number of audio channels in an output stream.
// Example: 1
func (s TiAudioPcmImpl) Channels() *int {
	return s.ChannelsValue
}

// The number of audio channels in an output stream.
// Example: 1
func (s *TiAudioPcmImpl) SetChannels(v int) TiAudioPcm {
	if s == nil {
		return nil
	}
	s.ChannelsValue = &v
	return s
}

// Audio codec (the AAC codec is used by default).
// Example: opus
func (s TiAudioPcmImpl) Codec() *string {
	return s.CodecValue
}

// Audio codec (the AAC codec is used by default).
// Example: opus
func (s *TiAudioPcmImpl) SetCodec(v string) TiAudioPcm {
	if s == nil {
		return nil
	}
	s.CodecValue = &v
	return s
}

// Content of the track (audio, video, or text).
func (s TiAudioPcmImpl) Content() FrameContent {
	return s.ContentValue
}

// Content of the track (audio, video, or text).
func (s *TiAudioPcmImpl) SetContent(v FrameContent) TiAudioPcm {
	if s == nil {
		return nil
	}
	s.ContentValue = v
	return s
}

// Input audio track to be transcoded.
// Example: 1
func (s TiAudioPcmImpl) InputTrack() *int {
	return s.InputTrackValue
}

// Input audio track to be transcoded.
// Example: 1
func (s *TiAudioPcmImpl) SetInputTrack(v int) TiAudioPcm {
	if s == nil {
		return nil
	}
	s.InputTrackValue = &v
	return s
}

// Language value of the track, if applicable.
// Example: eng
func (s TiAudioPcmImpl) Language() *string {
	return s.LanguageValue
}

// Language value of the track, if applicable.
// Example: eng
func (s *TiAudioPcmImpl) SetLanguage(v string) TiAudioPcm {
	if s == nil {
		return nil
	}
	s.LanguageValue = &v
	return s
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s TiAudioPcmImpl) Pid() *int {
	return s.PidValue
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s *TiAudioPcmImpl) SetPid(v int) TiAudioPcm {
	if s == nil {
		return nil
	}
	s.PidValue = &v
	return s
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// Example: 8000
func (s TiAudioPcmImpl) SampleRate() *int {
	return s.SampleRateValue
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// Example: 8000
func (s *TiAudioPcmImpl) SetSampleRate(v int) TiAudioPcm {
	if s == nil {
		return nil
	}
	s.SampleRateValue = &v
	return s
}

// This option allows to split each audio track with multiple channels into several mono tracks.
func (s TiAudioPcmImpl) SplitChannels() *bool {
	return s.SplitChannelsValue
}

// This option allows to split each audio track with multiple channels into several mono tracks.
func (s *TiAudioPcmImpl) SetSplitChannels(v bool) TiAudioPcm {
	if s == nil {
		return nil
	}
	s.SplitChannelsValue = &v
	return s
}

// Human-readable localized title of the track.
// Example: Video1
func (s TiAudioPcmImpl) Title() *string {
	return s.TitleValue
}

// Human-readable localized title of the track.
// Example: Video1
func (s *TiAudioPcmImpl) SetTitle(v string) TiAudioPcm {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
// If it is just an integer or a float, the output audio volume is calculated by this formula:
// `output_volume = volume * input_volume`
// If specified in decibels (dB), the output audio volume is calculated as follows:
// `output_volume = input_volume +/- volume`
// depending whether it is a positive (+9dB) or a negative value (-6dB).
// By default it equals to 1 (the input audio volume).
// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
// Example: -6dB
func (s TiAudioPcmImpl) Volume() *string {
	return s.VolumeValue
}

// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
// If it is just an integer or a float, the output audio volume is calculated by this formula:
// `output_volume = volume * input_volume`
// If specified in decibels (dB), the output audio volume is calculated as follows:
// `output_volume = input_volume +/- volume`
// depending whether it is a positive (+9dB) or a negative value (-6dB).
// By default it equals to 1 (the input audio volume).
// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
// Example: -6dB
func (s *TiAudioPcmImpl) SetVolume(v string) TiAudioPcm {
	if s == nil {
		return nil
	}
	s.VolumeValue = &v
	return s
}

// NewTiAudioPcmSpec creates a new TiAudioPcmSpec instance
func NewTiAudioPcmSpec() TiAudioPcmSpec {
	return &TiAudioPcmSpecImpl{}
}

// The number of audio channels in an output stream.
// Example: 1
func (s TiAudioPcmSpecImpl) Channels() *int {
	return s.ChannelsValue
}

// The number of audio channels in an output stream.
// Example: 1
func (s *TiAudioPcmSpecImpl) SetChannels(v int) TiAudioPcmSpec {
	if s == nil {
		return nil
	}
	s.ChannelsValue = &v
	return s
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// Example: 8000
func (s TiAudioPcmSpecImpl) SampleRate() *int {
	return s.SampleRateValue
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// Example: 8000
func (s *TiAudioPcmSpecImpl) SetSampleRate(v int) TiAudioPcmSpec {
	if s == nil {
		return nil
	}
	s.SampleRateValue = &v
	return s
}

// NewTiAudioPcma creates a new TiAudioPcma instance
func NewTiAudioPcma() TiAudioPcma {
	return &TiAudioPcmaImpl{}
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s TiAudioPcmaImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s *TiAudioPcmaImpl) SetBitrate(v Speed) TiAudioPcma {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// The number of audio channels in an output stream.
// Example: 1
func (s TiAudioPcmaImpl) Channels() *TiAudioPcmaSpecChannels {
	return s.ChannelsValue
}

// The number of audio channels in an output stream.
// Example: 1
func (s *TiAudioPcmaImpl) SetChannels(v TiAudioPcmaSpecChannels) TiAudioPcma {
	if s == nil {
		return nil
	}
	s.ChannelsValue = &v
	return s
}

// Audio codec (the AAC codec is used by default).
// Example: opus
func (s TiAudioPcmaImpl) Codec() *string {
	return s.CodecValue
}

// Audio codec (the AAC codec is used by default).
// Example: opus
func (s *TiAudioPcmaImpl) SetCodec(v string) TiAudioPcma {
	if s == nil {
		return nil
	}
	s.CodecValue = &v
	return s
}

// Content of the track (audio, video, or text).
func (s TiAudioPcmaImpl) Content() FrameContent {
	return s.ContentValue
}

// Content of the track (audio, video, or text).
func (s *TiAudioPcmaImpl) SetContent(v FrameContent) TiAudioPcma {
	if s == nil {
		return nil
	}
	s.ContentValue = v
	return s
}

// Input audio track to be transcoded.
// Example: 1
func (s TiAudioPcmaImpl) InputTrack() *int {
	return s.InputTrackValue
}

// Input audio track to be transcoded.
// Example: 1
func (s *TiAudioPcmaImpl) SetInputTrack(v int) TiAudioPcma {
	if s == nil {
		return nil
	}
	s.InputTrackValue = &v
	return s
}

// Language value of the track, if applicable.
// Example: eng
func (s TiAudioPcmaImpl) Language() *string {
	return s.LanguageValue
}

// Language value of the track, if applicable.
// Example: eng
func (s *TiAudioPcmaImpl) SetLanguage(v string) TiAudioPcma {
	if s == nil {
		return nil
	}
	s.LanguageValue = &v
	return s
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s TiAudioPcmaImpl) Pid() *int {
	return s.PidValue
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s *TiAudioPcmaImpl) SetPid(v int) TiAudioPcma {
	if s == nil {
		return nil
	}
	s.PidValue = &v
	return s
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// The allowed values are:
// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
// Example: 8000
func (s TiAudioPcmaImpl) SampleRate() *TiAudioPcmaSpecSampleRate {
	return s.SampleRateValue
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// The allowed values are:
// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
// Example: 8000
func (s *TiAudioPcmaImpl) SetSampleRate(v TiAudioPcmaSpecSampleRate) TiAudioPcma {
	if s == nil {
		return nil
	}
	s.SampleRateValue = &v
	return s
}

// This option allows to split each audio track with multiple channels into several mono tracks.
func (s TiAudioPcmaImpl) SplitChannels() *bool {
	return s.SplitChannelsValue
}

// This option allows to split each audio track with multiple channels into several mono tracks.
func (s *TiAudioPcmaImpl) SetSplitChannels(v bool) TiAudioPcma {
	if s == nil {
		return nil
	}
	s.SplitChannelsValue = &v
	return s
}

// Human-readable localized title of the track.
// Example: Video1
func (s TiAudioPcmaImpl) Title() *string {
	return s.TitleValue
}

// Human-readable localized title of the track.
// Example: Video1
func (s *TiAudioPcmaImpl) SetTitle(v string) TiAudioPcma {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
// If it is just an integer or a float, the output audio volume is calculated by this formula:
// `output_volume = volume * input_volume`
// If specified in decibels (dB), the output audio volume is calculated as follows:
// `output_volume = input_volume +/- volume`
// depending whether it is a positive (+9dB) or a negative value (-6dB).
// By default it equals to 1 (the input audio volume).
// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
// Example: -6dB
func (s TiAudioPcmaImpl) Volume() *string {
	return s.VolumeValue
}

// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
// If it is just an integer or a float, the output audio volume is calculated by this formula:
// `output_volume = volume * input_volume`
// If specified in decibels (dB), the output audio volume is calculated as follows:
// `output_volume = input_volume +/- volume`
// depending whether it is a positive (+9dB) or a negative value (-6dB).
// By default it equals to 1 (the input audio volume).
// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
// Example: -6dB
func (s *TiAudioPcmaImpl) SetVolume(v string) TiAudioPcma {
	if s == nil {
		return nil
	}
	s.VolumeValue = &v
	return s
}

// NewTiAudioPcmaSpec creates a new TiAudioPcmaSpec instance
func NewTiAudioPcmaSpec() TiAudioPcmaSpec {
	return &TiAudioPcmaSpecImpl{}
}

// The number of audio channels in an output stream.
// Example: 1
func (s TiAudioPcmaSpecImpl) Channels() *TiAudioPcmaSpecChannels {
	return s.ChannelsValue
}

// The number of audio channels in an output stream.
// Example: 1
func (s *TiAudioPcmaSpecImpl) SetChannels(v TiAudioPcmaSpecChannels) TiAudioPcmaSpec {
	if s == nil {
		return nil
	}
	s.ChannelsValue = &v
	return s
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// The allowed values are:
// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
// Example: 8000
func (s TiAudioPcmaSpecImpl) SampleRate() *TiAudioPcmaSpecSampleRate {
	return s.SampleRateValue
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// The allowed values are:
// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
// Example: 8000
func (s *TiAudioPcmaSpecImpl) SetSampleRate(v TiAudioPcmaSpecSampleRate) TiAudioPcmaSpec {
	if s == nil {
		return nil
	}
	s.SampleRateValue = &v
	return s
}

// NewTrackInfo creates a new TrackInfo instance
func NewTrackInfo() TrackInfo {
	return &TrackInfoImpl{}
}

// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
// The higher FPS is, the smoother the video playback is.
// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
func (s TrackInfoImpl) AvgFPS() *float64 {
	return s.AvgFPSValue
}

// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
// The higher FPS is, the smoother the video playback is.
// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
func (s *TrackInfoImpl) SetAvgFPS(v float64) TrackInfo {
	if s == nil {
		return nil
	}
	s.AvgFPSValue = &v
	return s
}

// Average GOP size (expressed in number of frames) of the last 1000-2000 frames.
// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
// If this value is floating, this means that your transcoder is working in flexible GOP size mode and some players may have problems.
// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
// Example: 25
func (s TrackInfoImpl) AvgGop() *int {
	return s.AvgGopValue
}

// Average GOP size (expressed in number of frames) of the last 1000-2000 frames.
// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
// If this value is floating, this means that your transcoder is working in flexible GOP size mode and some players may have problems.
// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
// Example: 25
func (s *TrackInfoImpl) SetAvgGop(v int) TrackInfo {
	if s == nil {
		return nil
	}
	s.AvgGopValue = &v
	return s
}

// Bandwidth necessary to transfer this track.
// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
// Format: speed (speed)
// Example: 2600
func (s TrackInfoImpl) Bandwidth() *Speed {
	return s.BandwidthValue
}

// Bandwidth necessary to transfer this track.
// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
// Format: speed (speed)
// Example: 2600
func (s *TrackInfoImpl) SetBandwidth(v Speed) TrackInfo {
	if s == nil {
		return nil
	}
	s.BandwidthValue = &v
	return s
}

// Average number of B-frames in a GOP. B-frames contain links to keyframes and P-frames before and after themselves.
// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
// Example: 3
func (s TrackInfoImpl) Bframes() *int {
	return s.BframesValue
}

// Average number of B-frames in a GOP. B-frames contain links to keyframes and P-frames before and after themselves.
// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
// Example: 3
func (s *TrackInfoImpl) SetBframes(v int) TrackInfo {
	if s == nil {
		return nil
	}
	s.BframesValue = &v
	return s
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s TrackInfoImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s *TrackInfoImpl) SetBitrate(v Speed) TrackInfo {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// The number of audio channels.
// Example: 2
func (s TrackInfoImpl) Channels() *int {
	return s.ChannelsValue
}

// The number of audio channels.
// Example: 2
func (s *TrackInfoImpl) SetChannels(v int) TrackInfo {
	if s == nil {
		return nil
	}
	s.ChannelsValue = &v
	return s
}

// Parameters of closed captions.
func (s TrackInfoImpl) ClosedCaptions() []ClosedCaptions {
	if s.ClosedCaptionsValue == nil {
		return nil
	}
	result := make([]ClosedCaptions, len(s.ClosedCaptionsValue))
	for i, item := range s.ClosedCaptionsValue {
		result[i] = item
	}
	return result
}

// Parameters of closed captions.
func (s *TrackInfoImpl) SetClosedCaptions(v []ClosedCaptions) TrackInfo {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*ClosedCaptionsImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*ClosedCaptionsImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.ClosedCaptionsValue = impl
	}
	return s
}

// Codec of the track. Different codecs do **not** get the same track.
// Example: h264
func (s TrackInfoImpl) Codec() *FrameCodec {
	return s.CodecValue
}

// Codec of the track. Different codecs do **not** get the same track.
// Example: h264
func (s *TrackInfoImpl) SetCodec(v FrameCodec) TrackInfo {
	if s == nil {
		return nil
	}
	s.CodecValue = &v
	return s
}

// Content of the track (audio, video, or text).
func (s TrackInfoImpl) Content() FrameContent {
	return s.ContentValue
}

// Content of the track (audio, video, or text).
func (s *TrackInfoImpl) SetContent(v FrameContent) TrackInfo {
	if s == nil {
		return nil
	}
	s.ContentValue = v
	return s
}

// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
// Higher frame rates capture more images per second, which makes for smoother video.
// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
func (s TrackInfoImpl) FPS() *float64 {
	return s.FPSValue
}

// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
// Higher frame rates capture more images per second, which makes for smoother video.
// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
func (s *TrackInfoImpl) SetFPS(v float64) TrackInfo {
	if s == nil {
		return nil
	}
	s.FPSValue = &v
	return s
}

// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
// However, sometimes (when the connection is broken) video breakups are possible.
// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
// This situation is considered as a frame gap and is handled differently across different protocols.
// Format: ticks (ticks)
func (s TrackInfoImpl) FrameDuration() *Ticks {
	return s.FrameDurationValue
}

// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
// However, sometimes (when the connection is broken) video breakups are possible.
// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
// This situation is considered as a frame gap and is handled differently across different protocols.
// Format: ticks (ticks)
func (s *TrackInfoImpl) SetFrameDuration(v Ticks) TrackInfo {
	if s == nil {
		return nil
	}
	s.FrameDurationValue = &v
	return s
}

// The number of frames in a group of pictures (GOP).
// The encoder will create all GOPs of an exactly identical size - as specified in this option.
// A bigger GOP can be good for video compression but it can result in big zap-time (the duration of time between changing a channel and displaying a new channel.)
func (s TrackInfoImpl) GopSize() *int {
	return s.GopSizeValue
}

// The number of frames in a group of pictures (GOP).
// The encoder will create all GOPs of an exactly identical size - as specified in this option.
// A bigger GOP can be good for video compression but it can result in big zap-time (the duration of time between changing a channel and displaying a new channel.)
func (s *TrackInfoImpl) SetGopSize(v int) TrackInfo {
	if s == nil {
		return nil
	}
	s.GopSizeValue = &v
	return s
}

// The picture height in pixels on the display where it will be played by a player.
// If you need to insert a web-player into a web page, use this value for choosing the player size.
// Format: pixels (pixels)
func (s TrackInfoImpl) Height() *Pixels {
	return s.HeightValue
}

// The picture height in pixels on the display where it will be played by a player.
// If you need to insert a web-player into a web page, use this value for choosing the player size.
// Format: pixels (pixels)
func (s *TrackInfoImpl) SetHeight(v Pixels) TrackInfo {
	if s == nil {
		return nil
	}
	s.HeightValue = &v
	return s
}

// Indicates if progressive scanning method is used for all frames of the track
func (s TrackInfoImpl) IsProgressive() *bool {
	return s.IsProgressiveValue
}

// Indicates if progressive scanning method is used for all frames of the track
func (s *TrackInfoImpl) SetIsProgressive(v bool) TrackInfo {
	if s == nil {
		return nil
	}
	s.IsProgressiveValue = &v
	return s
}

// Language value of the track, if applicable.
// Example: eng
func (s TrackInfoImpl) Language() *string {
	return s.LanguageValue
}

// Language value of the track, if applicable.
// Example: eng
func (s *TrackInfoImpl) SetLanguage(v string) TrackInfo {
	if s == nil {
		return nil
	}
	s.LanguageValue = &v
	return s
}

// Last GOP size (expressed in number of frames).
// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
// If this value is floating, this means that your transcoder is working in a flexible GOP size mode and some players may have problems.
// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
// Example: 28
func (s TrackInfoImpl) LastGop() *int {
	return s.LastGopValue
}

// Last GOP size (expressed in number of frames).
// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
// If this value is floating, this means that your transcoder is working in a flexible GOP size mode and some players may have problems.
// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
// Example: 28
func (s *TrackInfoImpl) SetLastGop(v int) TrackInfo {
	if s == nil {
		return nil
	}
	s.LastGopValue = &v
	return s
}

// The size of the length field for H264 bitstream without start codes.
func (s TrackInfoImpl) LengthSize() *int {
	return s.LengthSizeValue
}

// The size of the length field for H264 bitstream without start codes.
func (s *TrackInfoImpl) SetLengthSize(v int) TrackInfo {
	if s == nil {
		return nil
	}
	s.LengthSizeValue = &v
	return s
}

// A set of constraints that indicate a degree of required decoder performance.
// This parameter is used for compatibility with old devices.
func (s TrackInfoImpl) Level() *string {
	return s.LevelValue
}

// A set of constraints that indicate a degree of required decoder performance.
// This parameter is used for compatibility with old devices.
func (s *TrackInfoImpl) SetLevel(v string) TrackInfo {
	if s == nil {
		return nil
	}
	s.LevelValue = &v
	return s
}

// The number of I-frames to be used for encoding.
func (s TrackInfoImpl) NumRefsFrames() *int {
	return s.NumRefsFramesValue
}

// The number of I-frames to be used for encoding.
func (s *TrackInfoImpl) SetNumRefsFrames(v int) TrackInfo {
	if s == nil {
		return nil
	}
	s.NumRefsFramesValue = &v
	return s
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s TrackInfoImpl) Pid() *int {
	return s.PidValue
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s *TrackInfoImpl) SetPid(v int) TrackInfo {
	if s == nil {
		return nil
	}
	s.PidValue = &v
	return s
}

// The color model of the video.
func (s TrackInfoImpl) PixFmt() *FrameVideoPixFmt {
	return s.PixFmtValue
}

// The color model of the video.
func (s *TrackInfoImpl) SetPixFmt(v FrameVideoPixFmt) TrackInfo {
	if s == nil {
		return nil
	}
	s.PixFmtValue = &v
	return s
}

// The picture width in pixels of the original video before transcoding.
// Format: pixels (pixels)
func (s TrackInfoImpl) PixelHeight() *Pixels {
	return s.PixelHeightValue
}

// The picture width in pixels of the original video before transcoding.
// Format: pixels (pixels)
func (s *TrackInfoImpl) SetPixelHeight(v Pixels) TrackInfo {
	if s == nil {
		return nil
	}
	s.PixelHeightValue = &v
	return s
}

// The picture width in pixels of the original video before transcoding.
// Format: pixels (pixels)
func (s TrackInfoImpl) PixelWidth() *Pixels {
	return s.PixelWidthValue
}

// The picture width in pixels of the original video before transcoding.
// Format: pixels (pixels)
func (s *TrackInfoImpl) SetPixelWidth(v Pixels) TrackInfo {
	if s == nil {
		return nil
	}
	s.PixelWidthValue = &v
	return s
}

// A specific codec-dependent profile of the output video.
// The profile allows to assume if the track can be played on a particular device.
func (s TrackInfoImpl) Profile() *string {
	return s.ProfileValue
}

// A specific codec-dependent profile of the output video.
// The profile allows to assume if the track can be played on a particular device.
func (s *TrackInfoImpl) SetProfile(v string) TrackInfo {
	if s == nil {
		return nil
	}
	s.ProfileValue = &v
	return s
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// Example: 8000
func (s TrackInfoImpl) SampleRate() *int {
	return s.SampleRateValue
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// Example: 8000
func (s *TrackInfoImpl) SetSampleRate(v int) TrackInfo {
	if s == nil {
		return nil
	}
	s.SampleRateValue = &v
	return s
}

// The second number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
// SAR is used for creating non-anamorphic video from anamorphic video.
func (s TrackInfoImpl) SarHeight() *int {
	return s.SarHeightValue
}

// The second number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
// SAR is used for creating non-anamorphic video from anamorphic video.
func (s *TrackInfoImpl) SetSarHeight(v int) TrackInfo {
	if s == nil {
		return nil
	}
	s.SarHeightValue = &v
	return s
}

// The first number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
// SAR is used for creating non-anamorphic video from anamorphic video.
func (s TrackInfoImpl) SarWidth() *int {
	return s.SarWidthValue
}

// The first number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
// SAR is used for creating non-anamorphic video from anamorphic video.
func (s *TrackInfoImpl) SetSarWidth(v int) TrackInfo {
	if s == nil {
		return nil
	}
	s.SarWidthValue = &v
	return s
}

// Human-readable localized title of the track.
// Example: Video1
func (s TrackInfoImpl) Title() *string {
	return s.TitleValue
}

// Human-readable localized title of the track.
// Example: Video1
func (s *TrackInfoImpl) SetTitle(v string) TrackInfo {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// Track identifier assigned by Flussonic.
// Example: v1
func (s TrackInfoImpl) TrackID() any {
	return s.TrackIDValue
}

// Track identifier assigned by Flussonic.
// Example: v1
func (s *TrackInfoImpl) SetTrackID(v any) TrackInfo {
	if s == nil {
		return nil
	}
	s.TrackIDValue = v
	return s
}

// The picture width in pixels on the display where it will be played by a player.
// If you need to insert a web-player into a web page, use this value for choosing the player size.
// Format: pixels (pixels)
func (s TrackInfoImpl) Width() *Pixels {
	return s.WidthValue
}

// The picture width in pixels on the display where it will be played by a player.
// If you need to insert a web-player into a web page, use this value for choosing the player size.
// Format: pixels (pixels)
func (s *TrackInfoImpl) SetWidth(v Pixels) TrackInfo {
	if s == nil {
		return nil
	}
	s.WidthValue = &v
	return s
}

// NewTrackInfoApplication creates a new TrackInfoApplication instance
func NewTrackInfoApplication() TrackInfoApplication {
	return &TrackInfoApplicationImpl{}
}

// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
// The higher FPS is, the smoother the video playback is.
// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
func (s TrackInfoApplicationImpl) AvgFPS() *float64 {
	return s.AvgFPSValue
}

// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
// The higher FPS is, the smoother the video playback is.
// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
func (s *TrackInfoApplicationImpl) SetAvgFPS(v float64) TrackInfoApplication {
	if s == nil {
		return nil
	}
	s.AvgFPSValue = &v
	return s
}

// Bandwidth necessary to transfer this track.
// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
// Format: speed (speed)
// Example: 2600
func (s TrackInfoApplicationImpl) Bandwidth() *Speed {
	return s.BandwidthValue
}

// Bandwidth necessary to transfer this track.
// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
// Format: speed (speed)
// Example: 2600
func (s *TrackInfoApplicationImpl) SetBandwidth(v Speed) TrackInfoApplication {
	if s == nil {
		return nil
	}
	s.BandwidthValue = &v
	return s
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s TrackInfoApplicationImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s *TrackInfoApplicationImpl) SetBitrate(v Speed) TrackInfoApplication {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// Codec of the track. Different codecs do **not** get the same track.
// Example: h264
func (s TrackInfoApplicationImpl) Codec() *FrameCodec {
	return s.CodecValue
}

// Codec of the track. Different codecs do **not** get the same track.
// Example: h264
func (s *TrackInfoApplicationImpl) SetCodec(v FrameCodec) TrackInfoApplication {
	if s == nil {
		return nil
	}
	s.CodecValue = &v
	return s
}

// Content of the track (audio, video, or text).
func (s TrackInfoApplicationImpl) Content() FrameContent {
	return s.ContentValue
}

// Content of the track (audio, video, or text).
func (s *TrackInfoApplicationImpl) SetContent(v FrameContent) TrackInfoApplication {
	if s == nil {
		return nil
	}
	s.ContentValue = v
	return s
}

// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
// However, sometimes (when the connection is broken) video breakups are possible.
// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
// This situation is considered as a frame gap and is handled differently across different protocols.
// Format: ticks (ticks)
func (s TrackInfoApplicationImpl) FrameDuration() *Ticks {
	return s.FrameDurationValue
}

// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
// However, sometimes (when the connection is broken) video breakups are possible.
// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
// This situation is considered as a frame gap and is handled differently across different protocols.
// Format: ticks (ticks)
func (s *TrackInfoApplicationImpl) SetFrameDuration(v Ticks) TrackInfoApplication {
	if s == nil {
		return nil
	}
	s.FrameDurationValue = &v
	return s
}

// Language value of the track, if applicable.
// Example: eng
func (s TrackInfoApplicationImpl) Language() *string {
	return s.LanguageValue
}

// Language value of the track, if applicable.
// Example: eng
func (s *TrackInfoApplicationImpl) SetLanguage(v string) TrackInfoApplication {
	if s == nil {
		return nil
	}
	s.LanguageValue = &v
	return s
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s TrackInfoApplicationImpl) Pid() *int {
	return s.PidValue
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s *TrackInfoApplicationImpl) SetPid(v int) TrackInfoApplication {
	if s == nil {
		return nil
	}
	s.PidValue = &v
	return s
}

// Human-readable localized title of the track.
// Example: Video1
func (s TrackInfoApplicationImpl) Title() *string {
	return s.TitleValue
}

// Human-readable localized title of the track.
// Example: Video1
func (s *TrackInfoApplicationImpl) SetTitle(v string) TrackInfoApplication {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// Track identifier assigned by Flussonic.
// Example: v1
func (s TrackInfoApplicationImpl) TrackID() any {
	return s.TrackIDValue
}

// Track identifier assigned by Flussonic.
// Example: v1
func (s *TrackInfoApplicationImpl) SetTrackID(v any) TrackInfoApplication {
	if s == nil {
		return nil
	}
	s.TrackIDValue = v
	return s
}

// NewTrackInfoApplicationSpecific creates a new TrackInfoApplicationSpecific instance
func NewTrackInfoApplicationSpecific() TrackInfoApplicationSpecific {
	return &TrackInfoApplicationSpecificImpl{}
}

// Language value of the track, if applicable.
// Example: eng
func (s TrackInfoApplicationSpecificImpl) Language() *string {
	return s.LanguageValue
}

// Language value of the track, if applicable.
// Example: eng
func (s *TrackInfoApplicationSpecificImpl) SetLanguage(v string) TrackInfoApplicationSpecific {
	if s == nil {
		return nil
	}
	s.LanguageValue = &v
	return s
}

// NewTrackInfoAudio creates a new TrackInfoAudio instance
func NewTrackInfoAudio() TrackInfoAudio {
	return &TrackInfoAudioImpl{}
}

// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
// The higher FPS is, the smoother the video playback is.
// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
func (s TrackInfoAudioImpl) AvgFPS() *float64 {
	return s.AvgFPSValue
}

// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
// The higher FPS is, the smoother the video playback is.
// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
func (s *TrackInfoAudioImpl) SetAvgFPS(v float64) TrackInfoAudio {
	if s == nil {
		return nil
	}
	s.AvgFPSValue = &v
	return s
}

// Bandwidth necessary to transfer this track.
// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
// Format: speed (speed)
// Example: 2600
func (s TrackInfoAudioImpl) Bandwidth() *Speed {
	return s.BandwidthValue
}

// Bandwidth necessary to transfer this track.
// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
// Format: speed (speed)
// Example: 2600
func (s *TrackInfoAudioImpl) SetBandwidth(v Speed) TrackInfoAudio {
	if s == nil {
		return nil
	}
	s.BandwidthValue = &v
	return s
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s TrackInfoAudioImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s *TrackInfoAudioImpl) SetBitrate(v Speed) TrackInfoAudio {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// The number of audio channels.
// Example: 2
func (s TrackInfoAudioImpl) Channels() *int {
	return s.ChannelsValue
}

// The number of audio channels.
// Example: 2
func (s *TrackInfoAudioImpl) SetChannels(v int) TrackInfoAudio {
	if s == nil {
		return nil
	}
	s.ChannelsValue = &v
	return s
}

// Codec of the track. Different codecs do **not** get the same track.
// Example: h264
func (s TrackInfoAudioImpl) Codec() *FrameCodec {
	return s.CodecValue
}

// Codec of the track. Different codecs do **not** get the same track.
// Example: h264
func (s *TrackInfoAudioImpl) SetCodec(v FrameCodec) TrackInfoAudio {
	if s == nil {
		return nil
	}
	s.CodecValue = &v
	return s
}

// Content of the track (audio, video, or text).
func (s TrackInfoAudioImpl) Content() FrameContent {
	return s.ContentValue
}

// Content of the track (audio, video, or text).
func (s *TrackInfoAudioImpl) SetContent(v FrameContent) TrackInfoAudio {
	if s == nil {
		return nil
	}
	s.ContentValue = v
	return s
}

// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
// However, sometimes (when the connection is broken) video breakups are possible.
// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
// This situation is considered as a frame gap and is handled differently across different protocols.
// Format: ticks (ticks)
func (s TrackInfoAudioImpl) FrameDuration() *Ticks {
	return s.FrameDurationValue
}

// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
// However, sometimes (when the connection is broken) video breakups are possible.
// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
// This situation is considered as a frame gap and is handled differently across different protocols.
// Format: ticks (ticks)
func (s *TrackInfoAudioImpl) SetFrameDuration(v Ticks) TrackInfoAudio {
	if s == nil {
		return nil
	}
	s.FrameDurationValue = &v
	return s
}

// Language value of the track, if applicable.
// Example: eng
func (s TrackInfoAudioImpl) Language() *string {
	return s.LanguageValue
}

// Language value of the track, if applicable.
// Example: eng
func (s *TrackInfoAudioImpl) SetLanguage(v string) TrackInfoAudio {
	if s == nil {
		return nil
	}
	s.LanguageValue = &v
	return s
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s TrackInfoAudioImpl) Pid() *int {
	return s.PidValue
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s *TrackInfoAudioImpl) SetPid(v int) TrackInfoAudio {
	if s == nil {
		return nil
	}
	s.PidValue = &v
	return s
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// Example: 8000
func (s TrackInfoAudioImpl) SampleRate() *int {
	return s.SampleRateValue
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// Example: 8000
func (s *TrackInfoAudioImpl) SetSampleRate(v int) TrackInfoAudio {
	if s == nil {
		return nil
	}
	s.SampleRateValue = &v
	return s
}

// Human-readable localized title of the track.
// Example: Video1
func (s TrackInfoAudioImpl) Title() *string {
	return s.TitleValue
}

// Human-readable localized title of the track.
// Example: Video1
func (s *TrackInfoAudioImpl) SetTitle(v string) TrackInfoAudio {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// Track identifier assigned by Flussonic.
// Example: v1
func (s TrackInfoAudioImpl) TrackID() any {
	return s.TrackIDValue
}

// Track identifier assigned by Flussonic.
// Example: v1
func (s *TrackInfoAudioImpl) SetTrackID(v any) TrackInfoAudio {
	if s == nil {
		return nil
	}
	s.TrackIDValue = v
	return s
}

// NewTrackInfoAudioSpecific creates a new TrackInfoAudioSpecific instance
func NewTrackInfoAudioSpecific() TrackInfoAudioSpecific {
	return &TrackInfoAudioSpecificImpl{}
}

// The number of audio channels.
// Example: 2
func (s TrackInfoAudioSpecificImpl) Channels() *int {
	return s.ChannelsValue
}

// The number of audio channels.
// Example: 2
func (s *TrackInfoAudioSpecificImpl) SetChannels(v int) TrackInfoAudioSpecific {
	if s == nil {
		return nil
	}
	s.ChannelsValue = &v
	return s
}

// Language value of the track, if applicable.
// Example: eng
func (s TrackInfoAudioSpecificImpl) Language() *string {
	return s.LanguageValue
}

// Language value of the track, if applicable.
// Example: eng
func (s *TrackInfoAudioSpecificImpl) SetLanguage(v string) TrackInfoAudioSpecific {
	if s == nil {
		return nil
	}
	s.LanguageValue = &v
	return s
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// Example: 8000
func (s TrackInfoAudioSpecificImpl) SampleRate() *int {
	return s.SampleRateValue
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// Example: 8000
func (s *TrackInfoAudioSpecificImpl) SetSampleRate(v int) TrackInfoAudioSpecific {
	if s == nil {
		return nil
	}
	s.SampleRateValue = &v
	return s
}

// NewTrackInfoBase creates a new TrackInfoBase instance
func NewTrackInfoBase() TrackInfoBase {
	return &TrackInfoBaseImpl{}
}

// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
// The higher FPS is, the smoother the video playback is.
// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
func (s TrackInfoBaseImpl) AvgFPS() *float64 {
	return s.AvgFPSValue
}

// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
// The higher FPS is, the smoother the video playback is.
// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
func (s *TrackInfoBaseImpl) SetAvgFPS(v float64) TrackInfoBase {
	if s == nil {
		return nil
	}
	s.AvgFPSValue = &v
	return s
}

// Bandwidth necessary to transfer this track.
// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
// Format: speed (speed)
// Example: 2600
func (s TrackInfoBaseImpl) Bandwidth() *Speed {
	return s.BandwidthValue
}

// Bandwidth necessary to transfer this track.
// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
// Format: speed (speed)
// Example: 2600
func (s *TrackInfoBaseImpl) SetBandwidth(v Speed) TrackInfoBase {
	if s == nil {
		return nil
	}
	s.BandwidthValue = &v
	return s
}

// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
// However, sometimes (when the connection is broken) video breakups are possible.
// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
// This situation is considered as a frame gap and is handled differently across different protocols.
// Format: ticks (ticks)
func (s TrackInfoBaseImpl) FrameDuration() *Ticks {
	return s.FrameDurationValue
}

// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
// However, sometimes (when the connection is broken) video breakups are possible.
// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
// This situation is considered as a frame gap and is handled differently across different protocols.
// Format: ticks (ticks)
func (s *TrackInfoBaseImpl) SetFrameDuration(v Ticks) TrackInfoBase {
	if s == nil {
		return nil
	}
	s.FrameDurationValue = &v
	return s
}

// Track identifier assigned by Flussonic.
// Example: v1
func (s TrackInfoBaseImpl) TrackID() any {
	return s.TrackIDValue
}

// Track identifier assigned by Flussonic.
// Example: v1
func (s *TrackInfoBaseImpl) SetTrackID(v any) TrackInfoBase {
	if s == nil {
		return nil
	}
	s.TrackIDValue = v
	return s
}

// NewTrackInfoBaseConfigurable creates a new TrackInfoBaseConfigurable instance
func NewTrackInfoBaseConfigurable() TrackInfoBaseConfigurable {
	return &TrackInfoBaseConfigurableImpl{}
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s TrackInfoBaseConfigurableImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s *TrackInfoBaseConfigurableImpl) SetBitrate(v Speed) TrackInfoBaseConfigurable {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// Content of the track (audio, video, or text).
func (s TrackInfoBaseConfigurableImpl) Content() FrameContent {
	return s.ContentValue
}

// Content of the track (audio, video, or text).
func (s *TrackInfoBaseConfigurableImpl) SetContent(v FrameContent) TrackInfoBaseConfigurable {
	if s == nil {
		return nil
	}
	s.ContentValue = v
	return s
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s TrackInfoBaseConfigurableImpl) Pid() *int {
	return s.PidValue
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s *TrackInfoBaseConfigurableImpl) SetPid(v int) TrackInfoBaseConfigurable {
	if s == nil {
		return nil
	}
	s.PidValue = &v
	return s
}

// Human-readable localized title of the track.
// Example: Video1
func (s TrackInfoBaseConfigurableImpl) Title() *string {
	return s.TitleValue
}

// Human-readable localized title of the track.
// Example: Video1
func (s *TrackInfoBaseConfigurableImpl) SetTitle(v string) TrackInfoBaseConfigurable {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// NewTrackInfoFull creates a new TrackInfoFull instance
func NewTrackInfoFull() TrackInfoFull {
	return &TrackInfoFullImpl{}
}

// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
// The higher FPS is, the smoother the video playback is.
// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
func (s TrackInfoFullImpl) AvgFPS() *float64 {
	return s.AvgFPSValue
}

// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
// The higher FPS is, the smoother the video playback is.
// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
func (s *TrackInfoFullImpl) SetAvgFPS(v float64) TrackInfoFull {
	if s == nil {
		return nil
	}
	s.AvgFPSValue = &v
	return s
}

// Average GOP size (expressed in number of frames) of the last 1000-2000 frames.
// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
// If this value is floating, this means that your transcoder is working in flexible GOP size mode and some players may have problems.
// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
// Example: 25
func (s TrackInfoFullImpl) AvgGop() *int {
	return s.AvgGopValue
}

// Average GOP size (expressed in number of frames) of the last 1000-2000 frames.
// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
// If this value is floating, this means that your transcoder is working in flexible GOP size mode and some players may have problems.
// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
// Example: 25
func (s *TrackInfoFullImpl) SetAvgGop(v int) TrackInfoFull {
	if s == nil {
		return nil
	}
	s.AvgGopValue = &v
	return s
}

// Bandwidth necessary to transfer this track.
// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
// Format: speed (speed)
// Example: 2600
func (s TrackInfoFullImpl) Bandwidth() *Speed {
	return s.BandwidthValue
}

// Bandwidth necessary to transfer this track.
// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
// Format: speed (speed)
// Example: 2600
func (s *TrackInfoFullImpl) SetBandwidth(v Speed) TrackInfoFull {
	if s == nil {
		return nil
	}
	s.BandwidthValue = &v
	return s
}

// Average number of B-frames in a GOP. B-frames contain links to keyframes and P-frames before and after themselves.
// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
// Example: 3
func (s TrackInfoFullImpl) Bframes() *int {
	return s.BframesValue
}

// Average number of B-frames in a GOP. B-frames contain links to keyframes and P-frames before and after themselves.
// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
// Example: 3
func (s *TrackInfoFullImpl) SetBframes(v int) TrackInfoFull {
	if s == nil {
		return nil
	}
	s.BframesValue = &v
	return s
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s TrackInfoFullImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s *TrackInfoFullImpl) SetBitrate(v Speed) TrackInfoFull {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// The number of audio channels.
// Example: 2
func (s TrackInfoFullImpl) Channels() *int {
	return s.ChannelsValue
}

// The number of audio channels.
// Example: 2
func (s *TrackInfoFullImpl) SetChannels(v int) TrackInfoFull {
	if s == nil {
		return nil
	}
	s.ChannelsValue = &v
	return s
}

// Parameters of closed captions.
func (s TrackInfoFullImpl) ClosedCaptions() []ClosedCaptions {
	if s.ClosedCaptionsValue == nil {
		return nil
	}
	result := make([]ClosedCaptions, len(s.ClosedCaptionsValue))
	for i, item := range s.ClosedCaptionsValue {
		result[i] = item
	}
	return result
}

// Parameters of closed captions.
func (s *TrackInfoFullImpl) SetClosedCaptions(v []ClosedCaptions) TrackInfoFull {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*ClosedCaptionsImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*ClosedCaptionsImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.ClosedCaptionsValue = impl
	}
	return s
}

// Codec of the track. Different codecs do **not** get the same track.
// Example: h264
func (s TrackInfoFullImpl) Codec() *FrameCodec {
	return s.CodecValue
}

// Codec of the track. Different codecs do **not** get the same track.
// Example: h264
func (s *TrackInfoFullImpl) SetCodec(v FrameCodec) TrackInfoFull {
	if s == nil {
		return nil
	}
	s.CodecValue = &v
	return s
}

// Content of the track (audio, video, or text).
func (s TrackInfoFullImpl) Content() FrameContent {
	return s.ContentValue
}

// Content of the track (audio, video, or text).
func (s *TrackInfoFullImpl) SetContent(v FrameContent) TrackInfoFull {
	if s == nil {
		return nil
	}
	s.ContentValue = v
	return s
}

// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
// Higher frame rates capture more images per second, which makes for smoother video.
// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
func (s TrackInfoFullImpl) FPS() *float64 {
	return s.FPSValue
}

// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
// Higher frame rates capture more images per second, which makes for smoother video.
// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
func (s *TrackInfoFullImpl) SetFPS(v float64) TrackInfoFull {
	if s == nil {
		return nil
	}
	s.FPSValue = &v
	return s
}

// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
// However, sometimes (when the connection is broken) video breakups are possible.
// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
// This situation is considered as a frame gap and is handled differently across different protocols.
// Format: ticks (ticks)
func (s TrackInfoFullImpl) FrameDuration() *Ticks {
	return s.FrameDurationValue
}

// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
// However, sometimes (when the connection is broken) video breakups are possible.
// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
// This situation is considered as a frame gap and is handled differently across different protocols.
// Format: ticks (ticks)
func (s *TrackInfoFullImpl) SetFrameDuration(v Ticks) TrackInfoFull {
	if s == nil {
		return nil
	}
	s.FrameDurationValue = &v
	return s
}

// The number of frames in a group of pictures (GOP).
// The encoder will create all GOPs of an exactly identical size - as specified in this option.
// A bigger GOP can be good for video compression but it can result in big zap-time (the duration of time between changing a channel and displaying a new channel.)
func (s TrackInfoFullImpl) GopSize() *int {
	return s.GopSizeValue
}

// The number of frames in a group of pictures (GOP).
// The encoder will create all GOPs of an exactly identical size - as specified in this option.
// A bigger GOP can be good for video compression but it can result in big zap-time (the duration of time between changing a channel and displaying a new channel.)
func (s *TrackInfoFullImpl) SetGopSize(v int) TrackInfoFull {
	if s == nil {
		return nil
	}
	s.GopSizeValue = &v
	return s
}

// The picture height in pixels on the display where it will be played by a player.
// If you need to insert a web-player into a web page, use this value for choosing the player size.
// Format: pixels (pixels)
func (s TrackInfoFullImpl) Height() *Pixels {
	return s.HeightValue
}

// The picture height in pixels on the display where it will be played by a player.
// If you need to insert a web-player into a web page, use this value for choosing the player size.
// Format: pixels (pixels)
func (s *TrackInfoFullImpl) SetHeight(v Pixels) TrackInfoFull {
	if s == nil {
		return nil
	}
	s.HeightValue = &v
	return s
}

// Indicates if progressive scanning method is used for all frames of the track
func (s TrackInfoFullImpl) IsProgressive() *bool {
	return s.IsProgressiveValue
}

// Indicates if progressive scanning method is used for all frames of the track
func (s *TrackInfoFullImpl) SetIsProgressive(v bool) TrackInfoFull {
	if s == nil {
		return nil
	}
	s.IsProgressiveValue = &v
	return s
}

// Language value of the track, if applicable.
// Example: eng
func (s TrackInfoFullImpl) Language() *string {
	return s.LanguageValue
}

// Language value of the track, if applicable.
// Example: eng
func (s *TrackInfoFullImpl) SetLanguage(v string) TrackInfoFull {
	if s == nil {
		return nil
	}
	s.LanguageValue = &v
	return s
}

// Last GOP size (expressed in number of frames).
// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
// If this value is floating, this means that your transcoder is working in a flexible GOP size mode and some players may have problems.
// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
// Example: 28
func (s TrackInfoFullImpl) LastGop() *int {
	return s.LastGopValue
}

// Last GOP size (expressed in number of frames).
// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
// If this value is floating, this means that your transcoder is working in a flexible GOP size mode and some players may have problems.
// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
// Example: 28
func (s *TrackInfoFullImpl) SetLastGop(v int) TrackInfoFull {
	if s == nil {
		return nil
	}
	s.LastGopValue = &v
	return s
}

// The size of the length field for H264 bitstream without start codes.
func (s TrackInfoFullImpl) LengthSize() *int {
	return s.LengthSizeValue
}

// The size of the length field for H264 bitstream without start codes.
func (s *TrackInfoFullImpl) SetLengthSize(v int) TrackInfoFull {
	if s == nil {
		return nil
	}
	s.LengthSizeValue = &v
	return s
}

// A set of constraints that indicate a degree of required decoder performance.
// This parameter is used for compatibility with old devices.
func (s TrackInfoFullImpl) Level() *string {
	return s.LevelValue
}

// A set of constraints that indicate a degree of required decoder performance.
// This parameter is used for compatibility with old devices.
func (s *TrackInfoFullImpl) SetLevel(v string) TrackInfoFull {
	if s == nil {
		return nil
	}
	s.LevelValue = &v
	return s
}

// The number of I-frames to be used for encoding.
func (s TrackInfoFullImpl) NumRefsFrames() *int {
	return s.NumRefsFramesValue
}

// The number of I-frames to be used for encoding.
func (s *TrackInfoFullImpl) SetNumRefsFrames(v int) TrackInfoFull {
	if s == nil {
		return nil
	}
	s.NumRefsFramesValue = &v
	return s
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s TrackInfoFullImpl) Pid() *int {
	return s.PidValue
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s *TrackInfoFullImpl) SetPid(v int) TrackInfoFull {
	if s == nil {
		return nil
	}
	s.PidValue = &v
	return s
}

// The color model of the video.
func (s TrackInfoFullImpl) PixFmt() *FrameVideoPixFmt {
	return s.PixFmtValue
}

// The color model of the video.
func (s *TrackInfoFullImpl) SetPixFmt(v FrameVideoPixFmt) TrackInfoFull {
	if s == nil {
		return nil
	}
	s.PixFmtValue = &v
	return s
}

// The picture width in pixels of the original video before transcoding.
// Format: pixels (pixels)
func (s TrackInfoFullImpl) PixelHeight() *Pixels {
	return s.PixelHeightValue
}

// The picture width in pixels of the original video before transcoding.
// Format: pixels (pixels)
func (s *TrackInfoFullImpl) SetPixelHeight(v Pixels) TrackInfoFull {
	if s == nil {
		return nil
	}
	s.PixelHeightValue = &v
	return s
}

// The picture width in pixels of the original video before transcoding.
// Format: pixels (pixels)
func (s TrackInfoFullImpl) PixelWidth() *Pixels {
	return s.PixelWidthValue
}

// The picture width in pixels of the original video before transcoding.
// Format: pixels (pixels)
func (s *TrackInfoFullImpl) SetPixelWidth(v Pixels) TrackInfoFull {
	if s == nil {
		return nil
	}
	s.PixelWidthValue = &v
	return s
}

// A specific codec-dependent profile of the output video.
// The profile allows to assume if the track can be played on a particular device.
func (s TrackInfoFullImpl) Profile() *string {
	return s.ProfileValue
}

// A specific codec-dependent profile of the output video.
// The profile allows to assume if the track can be played on a particular device.
func (s *TrackInfoFullImpl) SetProfile(v string) TrackInfoFull {
	if s == nil {
		return nil
	}
	s.ProfileValue = &v
	return s
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// Example: 8000
func (s TrackInfoFullImpl) SampleRate() *int {
	return s.SampleRateValue
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// Example: 8000
func (s *TrackInfoFullImpl) SetSampleRate(v int) TrackInfoFull {
	if s == nil {
		return nil
	}
	s.SampleRateValue = &v
	return s
}

// The second number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
// SAR is used for creating non-anamorphic video from anamorphic video.
func (s TrackInfoFullImpl) SarHeight() *int {
	return s.SarHeightValue
}

// The second number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
// SAR is used for creating non-anamorphic video from anamorphic video.
func (s *TrackInfoFullImpl) SetSarHeight(v int) TrackInfoFull {
	if s == nil {
		return nil
	}
	s.SarHeightValue = &v
	return s
}

// The first number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
// SAR is used for creating non-anamorphic video from anamorphic video.
func (s TrackInfoFullImpl) SarWidth() *int {
	return s.SarWidthValue
}

// The first number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
// SAR is used for creating non-anamorphic video from anamorphic video.
func (s *TrackInfoFullImpl) SetSarWidth(v int) TrackInfoFull {
	if s == nil {
		return nil
	}
	s.SarWidthValue = &v
	return s
}

// Human-readable localized title of the track.
// Example: Video1
func (s TrackInfoFullImpl) Title() *string {
	return s.TitleValue
}

// Human-readable localized title of the track.
// Example: Video1
func (s *TrackInfoFullImpl) SetTitle(v string) TrackInfoFull {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// Track identifier assigned by Flussonic.
// Example: v1
func (s TrackInfoFullImpl) TrackID() any {
	return s.TrackIDValue
}

// Track identifier assigned by Flussonic.
// Example: v1
func (s *TrackInfoFullImpl) SetTrackID(v any) TrackInfoFull {
	if s == nil {
		return nil
	}
	s.TrackIDValue = v
	return s
}

// The picture width in pixels on the display where it will be played by a player.
// If you need to insert a web-player into a web page, use this value for choosing the player size.
// Format: pixels (pixels)
func (s TrackInfoFullImpl) Width() *Pixels {
	return s.WidthValue
}

// The picture width in pixels on the display where it will be played by a player.
// If you need to insert a web-player into a web page, use this value for choosing the player size.
// Format: pixels (pixels)
func (s *TrackInfoFullImpl) SetWidth(v Pixels) TrackInfoFull {
	if s == nil {
		return nil
	}
	s.WidthValue = &v
	return s
}

// NewTrackInfoMetadata creates a new TrackInfoMetadata instance
func NewTrackInfoMetadata() TrackInfoMetadata {
	return &TrackInfoMetadataImpl{}
}

// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
// The higher FPS is, the smoother the video playback is.
// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
func (s TrackInfoMetadataImpl) AvgFPS() *float64 {
	return s.AvgFPSValue
}

// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
// The higher FPS is, the smoother the video playback is.
// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
func (s *TrackInfoMetadataImpl) SetAvgFPS(v float64) TrackInfoMetadata {
	if s == nil {
		return nil
	}
	s.AvgFPSValue = &v
	return s
}

// Bandwidth necessary to transfer this track.
// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
// Format: speed (speed)
// Example: 2600
func (s TrackInfoMetadataImpl) Bandwidth() *Speed {
	return s.BandwidthValue
}

// Bandwidth necessary to transfer this track.
// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
// Format: speed (speed)
// Example: 2600
func (s *TrackInfoMetadataImpl) SetBandwidth(v Speed) TrackInfoMetadata {
	if s == nil {
		return nil
	}
	s.BandwidthValue = &v
	return s
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s TrackInfoMetadataImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s *TrackInfoMetadataImpl) SetBitrate(v Speed) TrackInfoMetadata {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// Codec of the track. Different codecs do **not** get the same track.
// Example: h264
func (s TrackInfoMetadataImpl) Codec() *FrameCodec {
	return s.CodecValue
}

// Codec of the track. Different codecs do **not** get the same track.
// Example: h264
func (s *TrackInfoMetadataImpl) SetCodec(v FrameCodec) TrackInfoMetadata {
	if s == nil {
		return nil
	}
	s.CodecValue = &v
	return s
}

// Content of the track (audio, video, or text).
func (s TrackInfoMetadataImpl) Content() FrameContent {
	return s.ContentValue
}

// Content of the track (audio, video, or text).
func (s *TrackInfoMetadataImpl) SetContent(v FrameContent) TrackInfoMetadata {
	if s == nil {
		return nil
	}
	s.ContentValue = v
	return s
}

// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
// However, sometimes (when the connection is broken) video breakups are possible.
// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
// This situation is considered as a frame gap and is handled differently across different protocols.
// Format: ticks (ticks)
func (s TrackInfoMetadataImpl) FrameDuration() *Ticks {
	return s.FrameDurationValue
}

// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
// However, sometimes (when the connection is broken) video breakups are possible.
// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
// This situation is considered as a frame gap and is handled differently across different protocols.
// Format: ticks (ticks)
func (s *TrackInfoMetadataImpl) SetFrameDuration(v Ticks) TrackInfoMetadata {
	if s == nil {
		return nil
	}
	s.FrameDurationValue = &v
	return s
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s TrackInfoMetadataImpl) Pid() *int {
	return s.PidValue
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s *TrackInfoMetadataImpl) SetPid(v int) TrackInfoMetadata {
	if s == nil {
		return nil
	}
	s.PidValue = &v
	return s
}

// Human-readable localized title of the track.
// Example: Video1
func (s TrackInfoMetadataImpl) Title() *string {
	return s.TitleValue
}

// Human-readable localized title of the track.
// Example: Video1
func (s *TrackInfoMetadataImpl) SetTitle(v string) TrackInfoMetadata {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// Track identifier assigned by Flussonic.
// Example: v1
func (s TrackInfoMetadataImpl) TrackID() any {
	return s.TrackIDValue
}

// Track identifier assigned by Flussonic.
// Example: v1
func (s *TrackInfoMetadataImpl) SetTrackID(v any) TrackInfoMetadata {
	if s == nil {
		return nil
	}
	s.TrackIDValue = v
	return s
}

// NewTrackInfoText creates a new TrackInfoText instance
func NewTrackInfoText() TrackInfoText {
	return &TrackInfoTextImpl{}
}

// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
// The higher FPS is, the smoother the video playback is.
// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
func (s TrackInfoTextImpl) AvgFPS() *float64 {
	return s.AvgFPSValue
}

// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
// The higher FPS is, the smoother the video playback is.
// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
func (s *TrackInfoTextImpl) SetAvgFPS(v float64) TrackInfoText {
	if s == nil {
		return nil
	}
	s.AvgFPSValue = &v
	return s
}

// Bandwidth necessary to transfer this track.
// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
// Format: speed (speed)
// Example: 2600
func (s TrackInfoTextImpl) Bandwidth() *Speed {
	return s.BandwidthValue
}

// Bandwidth necessary to transfer this track.
// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
// Format: speed (speed)
// Example: 2600
func (s *TrackInfoTextImpl) SetBandwidth(v Speed) TrackInfoText {
	if s == nil {
		return nil
	}
	s.BandwidthValue = &v
	return s
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s TrackInfoTextImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s *TrackInfoTextImpl) SetBitrate(v Speed) TrackInfoText {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// Codec of the track. Different codecs do **not** get the same track.
// Example: h264
func (s TrackInfoTextImpl) Codec() *FrameCodec {
	return s.CodecValue
}

// Codec of the track. Different codecs do **not** get the same track.
// Example: h264
func (s *TrackInfoTextImpl) SetCodec(v FrameCodec) TrackInfoText {
	if s == nil {
		return nil
	}
	s.CodecValue = &v
	return s
}

// Content of the track (audio, video, or text).
func (s TrackInfoTextImpl) Content() FrameContent {
	return s.ContentValue
}

// Content of the track (audio, video, or text).
func (s *TrackInfoTextImpl) SetContent(v FrameContent) TrackInfoText {
	if s == nil {
		return nil
	}
	s.ContentValue = v
	return s
}

// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
// However, sometimes (when the connection is broken) video breakups are possible.
// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
// This situation is considered as a frame gap and is handled differently across different protocols.
// Format: ticks (ticks)
func (s TrackInfoTextImpl) FrameDuration() *Ticks {
	return s.FrameDurationValue
}

// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
// However, sometimes (when the connection is broken) video breakups are possible.
// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
// This situation is considered as a frame gap and is handled differently across different protocols.
// Format: ticks (ticks)
func (s *TrackInfoTextImpl) SetFrameDuration(v Ticks) TrackInfoText {
	if s == nil {
		return nil
	}
	s.FrameDurationValue = &v
	return s
}

// Language value of the track, if applicable.
// Example: eng
func (s TrackInfoTextImpl) Language() *string {
	return s.LanguageValue
}

// Language value of the track, if applicable.
// Example: eng
func (s *TrackInfoTextImpl) SetLanguage(v string) TrackInfoText {
	if s == nil {
		return nil
	}
	s.LanguageValue = &v
	return s
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s TrackInfoTextImpl) Pid() *int {
	return s.PidValue
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s *TrackInfoTextImpl) SetPid(v int) TrackInfoText {
	if s == nil {
		return nil
	}
	s.PidValue = &v
	return s
}

// Human-readable localized title of the track.
// Example: Video1
func (s TrackInfoTextImpl) Title() *string {
	return s.TitleValue
}

// Human-readable localized title of the track.
// Example: Video1
func (s *TrackInfoTextImpl) SetTitle(v string) TrackInfoText {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// Track identifier assigned by Flussonic.
// Example: v1
func (s TrackInfoTextImpl) TrackID() any {
	return s.TrackIDValue
}

// Track identifier assigned by Flussonic.
// Example: v1
func (s *TrackInfoTextImpl) SetTrackID(v any) TrackInfoText {
	if s == nil {
		return nil
	}
	s.TrackIDValue = v
	return s
}

// NewTrackInfoTextSpecific creates a new TrackInfoTextSpecific instance
func NewTrackInfoTextSpecific() TrackInfoTextSpecific {
	return &TrackInfoTextSpecificImpl{}
}

// Language value of the track, if applicable.
// Example: eng
func (s TrackInfoTextSpecificImpl) Language() *string {
	return s.LanguageValue
}

// Language value of the track, if applicable.
// Example: eng
func (s *TrackInfoTextSpecificImpl) SetLanguage(v string) TrackInfoTextSpecific {
	if s == nil {
		return nil
	}
	s.LanguageValue = &v
	return s
}

// NewTrackInfoVideo creates a new TrackInfoVideo instance
func NewTrackInfoVideo() TrackInfoVideo {
	return &TrackInfoVideoImpl{}
}

// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
// The higher FPS is, the smoother the video playback is.
// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
func (s TrackInfoVideoImpl) AvgFPS() *float64 {
	return s.AvgFPSValue
}

// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
// The higher FPS is, the smoother the video playback is.
// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
func (s *TrackInfoVideoImpl) SetAvgFPS(v float64) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.AvgFPSValue = &v
	return s
}

// Average GOP size (expressed in number of frames) of the last 1000-2000 frames.
// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
// If this value is floating, this means that your transcoder is working in flexible GOP size mode and some players may have problems.
// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
// Example: 25
func (s TrackInfoVideoImpl) AvgGop() *int {
	return s.AvgGopValue
}

// Average GOP size (expressed in number of frames) of the last 1000-2000 frames.
// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
// If this value is floating, this means that your transcoder is working in flexible GOP size mode and some players may have problems.
// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
// Example: 25
func (s *TrackInfoVideoImpl) SetAvgGop(v int) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.AvgGopValue = &v
	return s
}

// Bandwidth necessary to transfer this track.
// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
// Format: speed (speed)
// Example: 2600
func (s TrackInfoVideoImpl) Bandwidth() *Speed {
	return s.BandwidthValue
}

// Bandwidth necessary to transfer this track.
// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
// Format: speed (speed)
// Example: 2600
func (s *TrackInfoVideoImpl) SetBandwidth(v Speed) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.BandwidthValue = &v
	return s
}

// Average number of B-frames in a GOP. B-frames contain links to keyframes and P-frames before and after themselves.
// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
// Example: 3
func (s TrackInfoVideoImpl) Bframes() *int {
	return s.BframesValue
}

// Average number of B-frames in a GOP. B-frames contain links to keyframes and P-frames before and after themselves.
// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
// Example: 3
func (s *TrackInfoVideoImpl) SetBframes(v int) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.BframesValue = &v
	return s
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s TrackInfoVideoImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s *TrackInfoVideoImpl) SetBitrate(v Speed) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// Parameters of closed captions.
func (s TrackInfoVideoImpl) ClosedCaptions() []ClosedCaptions {
	if s.ClosedCaptionsValue == nil {
		return nil
	}
	result := make([]ClosedCaptions, len(s.ClosedCaptionsValue))
	for i, item := range s.ClosedCaptionsValue {
		result[i] = item
	}
	return result
}

// Parameters of closed captions.
func (s *TrackInfoVideoImpl) SetClosedCaptions(v []ClosedCaptions) TrackInfoVideo {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*ClosedCaptionsImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*ClosedCaptionsImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.ClosedCaptionsValue = impl
	}
	return s
}

// Codec of the track. Different codecs do **not** get the same track.
// Example: h264
func (s TrackInfoVideoImpl) Codec() *FrameCodec {
	return s.CodecValue
}

// Codec of the track. Different codecs do **not** get the same track.
// Example: h264
func (s *TrackInfoVideoImpl) SetCodec(v FrameCodec) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.CodecValue = &v
	return s
}

// Content of the track (audio, video, or text).
func (s TrackInfoVideoImpl) Content() FrameContent {
	return s.ContentValue
}

// Content of the track (audio, video, or text).
func (s *TrackInfoVideoImpl) SetContent(v FrameContent) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.ContentValue = v
	return s
}

// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
// Higher frame rates capture more images per second, which makes for smoother video.
// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
func (s TrackInfoVideoImpl) FPS() *float64 {
	return s.FPSValue
}

// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
// Higher frame rates capture more images per second, which makes for smoother video.
// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
func (s *TrackInfoVideoImpl) SetFPS(v float64) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.FPSValue = &v
	return s
}

// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
// However, sometimes (when the connection is broken) video breakups are possible.
// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
// This situation is considered as a frame gap and is handled differently across different protocols.
// Format: ticks (ticks)
func (s TrackInfoVideoImpl) FrameDuration() *Ticks {
	return s.FrameDurationValue
}

// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
// However, sometimes (when the connection is broken) video breakups are possible.
// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
// This situation is considered as a frame gap and is handled differently across different protocols.
// Format: ticks (ticks)
func (s *TrackInfoVideoImpl) SetFrameDuration(v Ticks) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.FrameDurationValue = &v
	return s
}

// The number of frames in a group of pictures (GOP).
// The encoder will create all GOPs of an exactly identical size - as specified in this option.
// A bigger GOP can be good for video compression but it can result in big zap-time (the duration of time between changing a channel and displaying a new channel.)
func (s TrackInfoVideoImpl) GopSize() *int {
	return s.GopSizeValue
}

// The number of frames in a group of pictures (GOP).
// The encoder will create all GOPs of an exactly identical size - as specified in this option.
// A bigger GOP can be good for video compression but it can result in big zap-time (the duration of time between changing a channel and displaying a new channel.)
func (s *TrackInfoVideoImpl) SetGopSize(v int) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.GopSizeValue = &v
	return s
}

// The picture height in pixels on the display where it will be played by a player.
// If you need to insert a web-player into a web page, use this value for choosing the player size.
// Format: pixels (pixels)
func (s TrackInfoVideoImpl) Height() *Pixels {
	return s.HeightValue
}

// The picture height in pixels on the display where it will be played by a player.
// If you need to insert a web-player into a web page, use this value for choosing the player size.
// Format: pixels (pixels)
func (s *TrackInfoVideoImpl) SetHeight(v Pixels) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.HeightValue = &v
	return s
}

// Indicates if progressive scanning method is used for all frames of the track
func (s TrackInfoVideoImpl) IsProgressive() *bool {
	return s.IsProgressiveValue
}

// Indicates if progressive scanning method is used for all frames of the track
func (s *TrackInfoVideoImpl) SetIsProgressive(v bool) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.IsProgressiveValue = &v
	return s
}

// Last GOP size (expressed in number of frames).
// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
// If this value is floating, this means that your transcoder is working in a flexible GOP size mode and some players may have problems.
// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
// Example: 28
func (s TrackInfoVideoImpl) LastGop() *int {
	return s.LastGopValue
}

// Last GOP size (expressed in number of frames).
// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
// If this value is floating, this means that your transcoder is working in a flexible GOP size mode and some players may have problems.
// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
// Example: 28
func (s *TrackInfoVideoImpl) SetLastGop(v int) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.LastGopValue = &v
	return s
}

// The size of the length field for H264 bitstream without start codes.
func (s TrackInfoVideoImpl) LengthSize() *int {
	return s.LengthSizeValue
}

// The size of the length field for H264 bitstream without start codes.
func (s *TrackInfoVideoImpl) SetLengthSize(v int) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.LengthSizeValue = &v
	return s
}

// A set of constraints that indicate a degree of required decoder performance.
// This parameter is used for compatibility with old devices.
func (s TrackInfoVideoImpl) Level() *string {
	return s.LevelValue
}

// A set of constraints that indicate a degree of required decoder performance.
// This parameter is used for compatibility with old devices.
func (s *TrackInfoVideoImpl) SetLevel(v string) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.LevelValue = &v
	return s
}

// The number of I-frames to be used for encoding.
func (s TrackInfoVideoImpl) NumRefsFrames() *int {
	return s.NumRefsFramesValue
}

// The number of I-frames to be used for encoding.
func (s *TrackInfoVideoImpl) SetNumRefsFrames(v int) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.NumRefsFramesValue = &v
	return s
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s TrackInfoVideoImpl) Pid() *int {
	return s.PidValue
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s *TrackInfoVideoImpl) SetPid(v int) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.PidValue = &v
	return s
}

// The color model of the video.
func (s TrackInfoVideoImpl) PixFmt() *FrameVideoPixFmt {
	return s.PixFmtValue
}

// The color model of the video.
func (s *TrackInfoVideoImpl) SetPixFmt(v FrameVideoPixFmt) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.PixFmtValue = &v
	return s
}

// The picture width in pixels of the original video before transcoding.
// Format: pixels (pixels)
func (s TrackInfoVideoImpl) PixelHeight() *Pixels {
	return s.PixelHeightValue
}

// The picture width in pixels of the original video before transcoding.
// Format: pixels (pixels)
func (s *TrackInfoVideoImpl) SetPixelHeight(v Pixels) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.PixelHeightValue = &v
	return s
}

// The picture width in pixels of the original video before transcoding.
// Format: pixels (pixels)
func (s TrackInfoVideoImpl) PixelWidth() *Pixels {
	return s.PixelWidthValue
}

// The picture width in pixels of the original video before transcoding.
// Format: pixels (pixels)
func (s *TrackInfoVideoImpl) SetPixelWidth(v Pixels) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.PixelWidthValue = &v
	return s
}

// A specific codec-dependent profile of the output video.
// The profile allows to assume if the track can be played on a particular device.
func (s TrackInfoVideoImpl) Profile() *string {
	return s.ProfileValue
}

// A specific codec-dependent profile of the output video.
// The profile allows to assume if the track can be played on a particular device.
func (s *TrackInfoVideoImpl) SetProfile(v string) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.ProfileValue = &v
	return s
}

// The second number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
// SAR is used for creating non-anamorphic video from anamorphic video.
func (s TrackInfoVideoImpl) SarHeight() *int {
	return s.SarHeightValue
}

// The second number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
// SAR is used for creating non-anamorphic video from anamorphic video.
func (s *TrackInfoVideoImpl) SetSarHeight(v int) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.SarHeightValue = &v
	return s
}

// The first number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
// SAR is used for creating non-anamorphic video from anamorphic video.
func (s TrackInfoVideoImpl) SarWidth() *int {
	return s.SarWidthValue
}

// The first number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
// SAR is used for creating non-anamorphic video from anamorphic video.
func (s *TrackInfoVideoImpl) SetSarWidth(v int) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.SarWidthValue = &v
	return s
}

// Human-readable localized title of the track.
// Example: Video1
func (s TrackInfoVideoImpl) Title() *string {
	return s.TitleValue
}

// Human-readable localized title of the track.
// Example: Video1
func (s *TrackInfoVideoImpl) SetTitle(v string) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// Track identifier assigned by Flussonic.
// Example: v1
func (s TrackInfoVideoImpl) TrackID() any {
	return s.TrackIDValue
}

// Track identifier assigned by Flussonic.
// Example: v1
func (s *TrackInfoVideoImpl) SetTrackID(v any) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.TrackIDValue = v
	return s
}

// The picture width in pixels on the display where it will be played by a player.
// If you need to insert a web-player into a web page, use this value for choosing the player size.
// Format: pixels (pixels)
func (s TrackInfoVideoImpl) Width() *Pixels {
	return s.WidthValue
}

// The picture width in pixels on the display where it will be played by a player.
// If you need to insert a web-player into a web page, use this value for choosing the player size.
// Format: pixels (pixels)
func (s *TrackInfoVideoImpl) SetWidth(v Pixels) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.WidthValue = &v
	return s
}

// NewTrackInfoVideoConfigurable creates a new TrackInfoVideoConfigurable instance
func NewTrackInfoVideoConfigurable() TrackInfoVideoConfigurable {
	return &TrackInfoVideoConfigurableImpl{}
}

// Average number of B-frames in a GOP. B-frames contain links to keyframes and P-frames before and after themselves.
// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
// Example: 3
func (s TrackInfoVideoConfigurableImpl) Bframes() *int {
	return s.BframesValue
}

// Average number of B-frames in a GOP. B-frames contain links to keyframes and P-frames before and after themselves.
// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
// Example: 3
func (s *TrackInfoVideoConfigurableImpl) SetBframes(v int) TrackInfoVideoConfigurable {
	if s == nil {
		return nil
	}
	s.BframesValue = &v
	return s
}

// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
// Higher frame rates capture more images per second, which makes for smoother video.
// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
func (s TrackInfoVideoConfigurableImpl) FPS() *float64 {
	return s.FPSValue
}

// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
// Higher frame rates capture more images per second, which makes for smoother video.
// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
func (s *TrackInfoVideoConfigurableImpl) SetFPS(v float64) TrackInfoVideoConfigurable {
	if s == nil {
		return nil
	}
	s.FPSValue = &v
	return s
}

// The number of frames in a group of pictures (GOP).
// The encoder will create all GOPs of an exactly identical size - as specified in this option.
// A bigger GOP can be good for video compression but it can result in big zap-time (the duration of time between changing a channel and displaying a new channel.)
func (s TrackInfoVideoConfigurableImpl) GopSize() *int {
	return s.GopSizeValue
}

// The number of frames in a group of pictures (GOP).
// The encoder will create all GOPs of an exactly identical size - as specified in this option.
// A bigger GOP can be good for video compression but it can result in big zap-time (the duration of time between changing a channel and displaying a new channel.)
func (s *TrackInfoVideoConfigurableImpl) SetGopSize(v int) TrackInfoVideoConfigurable {
	if s == nil {
		return nil
	}
	s.GopSizeValue = &v
	return s
}

// The picture height in pixels on the display where it will be played by a player.
// If you need to insert a web-player into a web page, use this value for choosing the player size.
// Format: pixels (pixels)
func (s TrackInfoVideoConfigurableImpl) Height() *Pixels {
	return s.HeightValue
}

// The picture height in pixels on the display where it will be played by a player.
// If you need to insert a web-player into a web page, use this value for choosing the player size.
// Format: pixels (pixels)
func (s *TrackInfoVideoConfigurableImpl) SetHeight(v Pixels) TrackInfoVideoConfigurable {
	if s == nil {
		return nil
	}
	s.HeightValue = &v
	return s
}

// A set of constraints that indicate a degree of required decoder performance.
// This parameter is used for compatibility with old devices.
func (s TrackInfoVideoConfigurableImpl) Level() *string {
	return s.LevelValue
}

// A set of constraints that indicate a degree of required decoder performance.
// This parameter is used for compatibility with old devices.
func (s *TrackInfoVideoConfigurableImpl) SetLevel(v string) TrackInfoVideoConfigurable {
	if s == nil {
		return nil
	}
	s.LevelValue = &v
	return s
}

// The number of I-frames to be used for encoding.
func (s TrackInfoVideoConfigurableImpl) NumRefsFrames() *int {
	return s.NumRefsFramesValue
}

// The number of I-frames to be used for encoding.
func (s *TrackInfoVideoConfigurableImpl) SetNumRefsFrames(v int) TrackInfoVideoConfigurable {
	if s == nil {
		return nil
	}
	s.NumRefsFramesValue = &v
	return s
}

// The color model of the video.
func (s TrackInfoVideoConfigurableImpl) PixFmt() *FrameVideoPixFmt {
	return s.PixFmtValue
}

// The color model of the video.
func (s *TrackInfoVideoConfigurableImpl) SetPixFmt(v FrameVideoPixFmt) TrackInfoVideoConfigurable {
	if s == nil {
		return nil
	}
	s.PixFmtValue = &v
	return s
}

// The picture width in pixels of the original video before transcoding.
// Format: pixels (pixels)
func (s TrackInfoVideoConfigurableImpl) PixelHeight() *Pixels {
	return s.PixelHeightValue
}

// The picture width in pixels of the original video before transcoding.
// Format: pixels (pixels)
func (s *TrackInfoVideoConfigurableImpl) SetPixelHeight(v Pixels) TrackInfoVideoConfigurable {
	if s == nil {
		return nil
	}
	s.PixelHeightValue = &v
	return s
}

// The picture width in pixels of the original video before transcoding.
// Format: pixels (pixels)
func (s TrackInfoVideoConfigurableImpl) PixelWidth() *Pixels {
	return s.PixelWidthValue
}

// The picture width in pixels of the original video before transcoding.
// Format: pixels (pixels)
func (s *TrackInfoVideoConfigurableImpl) SetPixelWidth(v Pixels) TrackInfoVideoConfigurable {
	if s == nil {
		return nil
	}
	s.PixelWidthValue = &v
	return s
}

// A specific codec-dependent profile of the output video.
// The profile allows to assume if the track can be played on a particular device.
func (s TrackInfoVideoConfigurableImpl) Profile() *string {
	return s.ProfileValue
}

// A specific codec-dependent profile of the output video.
// The profile allows to assume if the track can be played on a particular device.
func (s *TrackInfoVideoConfigurableImpl) SetProfile(v string) TrackInfoVideoConfigurable {
	if s == nil {
		return nil
	}
	s.ProfileValue = &v
	return s
}

// The second number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
// SAR is used for creating non-anamorphic video from anamorphic video.
func (s TrackInfoVideoConfigurableImpl) SarHeight() *int {
	return s.SarHeightValue
}

// The second number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
// SAR is used for creating non-anamorphic video from anamorphic video.
func (s *TrackInfoVideoConfigurableImpl) SetSarHeight(v int) TrackInfoVideoConfigurable {
	if s == nil {
		return nil
	}
	s.SarHeightValue = &v
	return s
}

// The first number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
// SAR is used for creating non-anamorphic video from anamorphic video.
func (s TrackInfoVideoConfigurableImpl) SarWidth() *int {
	return s.SarWidthValue
}

// The first number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
// SAR is used for creating non-anamorphic video from anamorphic video.
func (s *TrackInfoVideoConfigurableImpl) SetSarWidth(v int) TrackInfoVideoConfigurable {
	if s == nil {
		return nil
	}
	s.SarWidthValue = &v
	return s
}

// The picture width in pixels on the display where it will be played by a player.
// If you need to insert a web-player into a web page, use this value for choosing the player size.
// Format: pixels (pixels)
func (s TrackInfoVideoConfigurableImpl) Width() *Pixels {
	return s.WidthValue
}

// The picture width in pixels on the display where it will be played by a player.
// If you need to insert a web-player into a web page, use this value for choosing the player size.
// Format: pixels (pixels)
func (s *TrackInfoVideoConfigurableImpl) SetWidth(v Pixels) TrackInfoVideoConfigurable {
	if s == nil {
		return nil
	}
	s.WidthValue = &v
	return s
}

// NewTrackInfoVideoSpecific creates a new TrackInfoVideoSpecific instance
func NewTrackInfoVideoSpecific() TrackInfoVideoSpecific {
	return &TrackInfoVideoSpecificImpl{}
}

// Average GOP size (expressed in number of frames) of the last 1000-2000 frames.
// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
// If this value is floating, this means that your transcoder is working in flexible GOP size mode and some players may have problems.
// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
// Example: 25
func (s TrackInfoVideoSpecificImpl) AvgGop() *int {
	return s.AvgGopValue
}

// Average GOP size (expressed in number of frames) of the last 1000-2000 frames.
// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
// If this value is floating, this means that your transcoder is working in flexible GOP size mode and some players may have problems.
// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
// Example: 25
func (s *TrackInfoVideoSpecificImpl) SetAvgGop(v int) TrackInfoVideoSpecific {
	if s == nil {
		return nil
	}
	s.AvgGopValue = &v
	return s
}

// Parameters of closed captions.
func (s TrackInfoVideoSpecificImpl) ClosedCaptions() []ClosedCaptions {
	if s.ClosedCaptionsValue == nil {
		return nil
	}
	result := make([]ClosedCaptions, len(s.ClosedCaptionsValue))
	for i, item := range s.ClosedCaptionsValue {
		result[i] = item
	}
	return result
}

// Parameters of closed captions.
func (s *TrackInfoVideoSpecificImpl) SetClosedCaptions(v []ClosedCaptions) TrackInfoVideoSpecific {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*ClosedCaptionsImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*ClosedCaptionsImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.ClosedCaptionsValue = impl
	}
	return s
}

// Indicates if progressive scanning method is used for all frames of the track
func (s TrackInfoVideoSpecificImpl) IsProgressive() *bool {
	return s.IsProgressiveValue
}

// Indicates if progressive scanning method is used for all frames of the track
func (s *TrackInfoVideoSpecificImpl) SetIsProgressive(v bool) TrackInfoVideoSpecific {
	if s == nil {
		return nil
	}
	s.IsProgressiveValue = &v
	return s
}

// Last GOP size (expressed in number of frames).
// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
// If this value is floating, this means that your transcoder is working in a flexible GOP size mode and some players may have problems.
// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
// Example: 28
func (s TrackInfoVideoSpecificImpl) LastGop() *int {
	return s.LastGopValue
}

// Last GOP size (expressed in number of frames).
// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
// If this value is floating, this means that your transcoder is working in a flexible GOP size mode and some players may have problems.
// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
// Example: 28
func (s *TrackInfoVideoSpecificImpl) SetLastGop(v int) TrackInfoVideoSpecific {
	if s == nil {
		return nil
	}
	s.LastGopValue = &v
	return s
}

// The size of the length field for H264 bitstream without start codes.
func (s TrackInfoVideoSpecificImpl) LengthSize() *int {
	return s.LengthSizeValue
}

// The size of the length field for H264 bitstream without start codes.
func (s *TrackInfoVideoSpecificImpl) SetLengthSize(v int) TrackInfoVideoSpecific {
	if s == nil {
		return nil
	}
	s.LengthSizeValue = &v
	return s
}

// NewTranscoderDeviceStats creates a new TranscoderDeviceStats instance
func NewTranscoderDeviceStats() TranscoderDeviceStats {
	return &TranscoderDeviceStatsImpl{}
}

// Shows if the device can make an interlaced stream from a progressive one.
func (s TranscoderDeviceStatsImpl) CanInterlace() *bool {
	return s.CanInterlaceValue
}

// Shows if the device can make an interlaced stream from a progressive one.
func (s *TranscoderDeviceStatsImpl) SetCanInterlace(v bool) TranscoderDeviceStats {
	if s == nil {
		return nil
	}
	s.CanInterlaceValue = &v
	return s
}

// Shows if the transcoder with this device can run in the same process as Flussonic Media Server.
func (s TranscoderDeviceStatsImpl) CanInternal() *bool {
	return s.CanInternalValue
}

// Shows if the transcoder with this device can run in the same process as Flussonic Media Server.
func (s *TranscoderDeviceStatsImpl) SetCanInternal(v bool) TranscoderDeviceStats {
	if s == nil {
		return nil
	}
	s.CanInternalValue = &v
	return s
}

// Shows if the device can put a logo on the image.
func (s TranscoderDeviceStatsImpl) CanLogo() *bool {
	return s.CanLogoValue
}

// Shows if the device can put a logo on the image.
func (s *TranscoderDeviceStatsImpl) SetCanLogo(v bool) TranscoderDeviceStats {
	if s == nil {
		return nil
	}
	s.CanLogoValue = &v
	return s
}

// GPU decoder load percentage.
func (s TranscoderDeviceStatsImpl) GpuDec() *int {
	return s.GpuDecValue
}

// GPU decoder load percentage.
func (s *TranscoderDeviceStatsImpl) SetGpuDec(v int) TranscoderDeviceStats {
	if s == nil {
		return nil
	}
	s.GpuDecValue = &v
	return s
}

// GPU encoder load percentage.
func (s TranscoderDeviceStatsImpl) GpuEnc() *int {
	return s.GpuEncValue
}

// GPU encoder load percentage.
func (s *TranscoderDeviceStatsImpl) SetGpuEnc(v int) TranscoderDeviceStats {
	if s == nil {
		return nil
	}
	s.GpuEncValue = &v
	return s
}

// GPU shared memory amount.
func (s TranscoderDeviceStatsImpl) GpuSm() *int {
	return s.GpuSmValue
}

// GPU shared memory amount.
func (s *TranscoderDeviceStatsImpl) SetGpuSm(v int) TranscoderDeviceStats {
	if s == nil {
		return nil
	}
	s.GpuSmValue = &v
	return s
}

// GPU temperature, C.
func (s TranscoderDeviceStatsImpl) GpuTemp() *int {
	return s.GpuTempValue
}

// GPU temperature, C.
func (s *TranscoderDeviceStatsImpl) SetGpuTemp(v int) TranscoderDeviceStats {
	if s == nil {
		return nil
	}
	s.GpuTempValue = &v
	return s
}

// The ID of the device used for transcoding.
// In PUT requests, you can use `auto` for Flussonic to set the ID itself.
// In the response to GET requests, the `id` will always be a number.
func (s TranscoderDeviceStatsImpl) ID() *TcDeviceid {
	return s.IDValue
}

// The ID of the device used for transcoding.
// In PUT requests, you can use `auto` for Flussonic to set the ID itself.
// In the response to GET requests, the `id` will always be a number.
func (s *TranscoderDeviceStatsImpl) SetID(v *TcDeviceid) TranscoderDeviceStats {
	if s == nil {
		return nil
	}
	s.IDValue = v
	return s
}

// Free RAM.
func (s TranscoderDeviceStatsImpl) Memfree() *int {
	return s.MemfreeValue
}

// Free RAM.
func (s *TranscoderDeviceStatsImpl) SetMemfree(v int) TranscoderDeviceStats {
	if s == nil {
		return nil
	}
	s.MemfreeValue = &v
	return s
}

// Total RAM on the device.
func (s TranscoderDeviceStatsImpl) Memtotal() *int {
	return s.MemtotalValue
}

// Total RAM on the device.
func (s *TranscoderDeviceStatsImpl) SetMemtotal(v int) TranscoderDeviceStats {
	if s == nil {
		return nil
	}
	s.MemtotalValue = &v
	return s
}

// Utilized RAM.
func (s TranscoderDeviceStatsImpl) Memused() *int {
	return s.MemusedValue
}

// Utilized RAM.
func (s *TranscoderDeviceStatsImpl) SetMemused(v int) TranscoderDeviceStats {
	if s == nil {
		return nil
	}
	s.MemusedValue = &v
	return s
}

// The name of the transcoder device.
func (s TranscoderDeviceStatsImpl) Name() *string {
	return s.NameValue
}

// The name of the transcoder device.
func (s *TranscoderDeviceStatsImpl) SetName(v string) TranscoderDeviceStats {
	if s == nil {
		return nil
	}
	s.NameValue = &v
	return s
}

// The ability of the device to be reconfigured online, i.e. without complete restart of the transcoder.
// `full` means that both decoder and encoder can be reconfigured online.
// `encoder` means that only encoder can be reconfigured online.
// `decoder` means that only decoder can be reconfigured online.
// `false` means that online reconfiguration is not supported.
func (s TranscoderDeviceStatsImpl) ReconfigSupport() *TcReconfigSupport {
	return s.ReconfigSupportValue
}

// The ability of the device to be reconfigured online, i.e. without complete restart of the transcoder.
// `full` means that both decoder and encoder can be reconfigured online.
// `encoder` means that only encoder can be reconfigured online.
// `decoder` means that only decoder can be reconfigured online.
// `false` means that online reconfiguration is not supported.
func (s *TranscoderDeviceStatsImpl) SetReconfigSupport(v *TcReconfigSupport) TranscoderDeviceStats {
	if s == nil {
		return nil
	}
	s.ReconfigSupportValue = v
	return s
}

// The type of the device used for transcoding.
// Example: cpu
func (s TranscoderDeviceStatsImpl) Type() *TranscoderDevice {
	return s.TypeValue
}

// The type of the device used for transcoding.
// Example: cpu
func (s *TranscoderDeviceStatsImpl) SetType(v TranscoderDevice) TranscoderDeviceStats {
	if s == nil {
		return nil
	}
	s.TypeValue = &v
	return s
}

// NewTranscoderOpts creates a new TranscoderOpts instance
func NewTranscoderOpts() TranscoderOpts {
	return &TranscoderOptsImpl{}
}

// Deprecated field. Will be deleted at 23.09
// List of audio tracks the stream audio track will be transcoded into.
func (s TranscoderOptsImpl) Audio() TcAudioOpts {
	return s.AudioValue
}

// Deprecated field. Will be deleted at 23.09
// List of audio tracks the stream audio track will be transcoded into.
func (s *TranscoderOptsImpl) SetAudio(v TcAudioOpts) TranscoderOpts {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*TcAudioOptsImpl); ok {
		s.AudioValue = impl
	}
	return s
}

// Decoder settings to be used for transcoding.
func (s TranscoderOptsImpl) Decoder() TcDecoder {
	return s.DecoderValue
}

// Decoder settings to be used for transcoding.
func (s *TranscoderOptsImpl) SetDecoder(v TcDecoder) TranscoderOpts {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*TcDecoderImpl); ok {
		s.DecoderValue = impl
	}
	return s
}

// Transcoder settings to be used for transcoding.
func (s TranscoderOptsImpl) Global() TcGlobal {
	return s.GlobalValue
}

// Transcoder settings to be used for transcoding.
func (s *TranscoderOptsImpl) SetGlobal(v TcGlobal) TranscoderOpts {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*TcGlobalImpl); ok {
		s.GlobalValue = impl
	}
	return s
}

// Info on the tracks. In the case of iris-hal, the first video track must be
// high-resolution track, second one (if present) must be lower-resolution
func (s TranscoderOptsImpl) Tracks() []TranscoderTrackInfo {
	if s.TracksValue == nil {
		return nil
	}
	result := make([]TranscoderTrackInfo, len(s.TracksValue))
	for i, item := range s.TracksValue {
		result[i] = item
	}
	return result
}

// Info on the tracks. In the case of iris-hal, the first video track must be
// high-resolution track, second one (if present) must be lower-resolution
func (s *TranscoderOptsImpl) SetTracks(v []TranscoderTrackInfo) TranscoderOpts {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*TranscoderTrackInfoImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*TranscoderTrackInfoImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.TracksValue = impl
	}
	return s
}

// Deprecated field. Will be deleted at 24.08
// List of video tracks the stream video track will be transcoded into.
func (s TranscoderOptsImpl) Video() []TcVideoOpts {
	if s.VideoValue == nil {
		return nil
	}
	result := make([]TcVideoOpts, len(s.VideoValue))
	for i, item := range s.VideoValue {
		result[i] = item
	}
	return result
}

// Deprecated field. Will be deleted at 24.08
// List of video tracks the stream video track will be transcoded into.
func (s *TranscoderOptsImpl) SetVideo(v []TcVideoOpts) TranscoderOpts {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*TcVideoOptsImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*TcVideoOptsImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.VideoValue = impl
	}
	return s
}

// NewTranscoderTrackInfo creates a new TranscoderTrackInfo instance
func NewTranscoderTrackInfo() TranscoderTrackInfo {
	return &TranscoderTrackInfoImpl{}
}

// The configuration of a logo added to the video track after the video was resized as specified in the `size` option.
// This prevents the logo picture from stretching that might occur when the `logo` option is used.
// You will need to prepare and specify a separate file with a logo for each size of the resulting video track.
func (s TranscoderTrackInfoImpl) Alogo() TcLogo {
	return s.AlogoValue
}

// The configuration of a logo added to the video track after the video was resized as specified in the `size` option.
// This prevents the logo picture from stretching that might occur when the `logo` option is used.
// You will need to prepare and specify a separate file with a logo for each size of the resulting video track.
func (s *TranscoderTrackInfoImpl) SetAlogo(v TcLogo) TranscoderTrackInfo {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*TcLogoImpl); ok {
		s.AlogoValue = impl
	}
	return s
}

// Number of B-frames between I and P-frames. B-frames contain links to keyframes and P-frames before and after themselves.
// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
// When set to 0, this option disables b-frames. This may be necessary, for example, when broadcasting to RTSP.
// Example: 3
func (s TranscoderTrackInfoImpl) Bframes() *int {
	return s.BframesValue
}

// Number of B-frames between I and P-frames. B-frames contain links to keyframes and P-frames before and after themselves.
// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
// When set to 0, this option disables b-frames. This may be necessary, for example, when broadcasting to RTSP.
// Example: 3
func (s *TranscoderTrackInfoImpl) SetBframes(v int) TranscoderTrackInfo {
	if s == nil {
		return nil
	}
	s.BframesValue = &v
	return s
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s TranscoderTrackInfoImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s *TranscoderTrackInfoImpl) SetBitrate(v Speed) TranscoderTrackInfo {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// Configuration of burn-in text, timestamp, or subtitles to video frames.
func (s TranscoderTrackInfoImpl) Burn() TcBurn {
	return s.BurnValue
}

// Configuration of burn-in text, timestamp, or subtitles to video frames.
func (s *TranscoderTrackInfoImpl) SetBurn(v TcBurn) TranscoderTrackInfo {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*TcBurnImpl); ok {
		s.BurnValue = impl
	}
	return s
}

// Codec of the track. Different codecs do **not** get the same track.
// Example: h264
func (s TranscoderTrackInfoImpl) Codec() *FrameCodec {
	return s.CodecValue
}

// Codec of the track. Different codecs do **not** get the same track.
// Example: h264
func (s *TranscoderTrackInfoImpl) SetCodec(v FrameCodec) TranscoderTrackInfo {
	if s == nil {
		return nil
	}
	s.CodecValue = &v
	return s
}

// Content of the track (audio, video, or text).
func (s TranscoderTrackInfoImpl) Content() FrameContent {
	return s.ContentValue
}

// Content of the track (audio, video, or text).
func (s *TranscoderTrackInfoImpl) SetContent(v FrameContent) TranscoderTrackInfo {
	if s == nil {
		return nil
	}
	s.ContentValue = v
	return s
}

// Some additional options.
func (s TranscoderTrackInfoImpl) Extra() map[string]string {
	return s.ExtraValue
}

// Some additional options.
func (s *TranscoderTrackInfoImpl) SetExtra(v map[string]string) TranscoderTrackInfo {
	if s == nil {
		return nil
	}
	s.ExtraValue = v
	return s
}

// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
// Higher frame rates capture more images per second, which makes for smoother video.
// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
func (s TranscoderTrackInfoImpl) FPS() *TcFPS {
	return s.FPSValue
}

// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
// Higher frame rates capture more images per second, which makes for smoother video.
// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
func (s *TranscoderTrackInfoImpl) SetFPS(v *TcFPS) TranscoderTrackInfo {
	if s == nil {
		return nil
	}
	s.FPSValue = v
	return s
}

// Sets the number of frames in a GOP.
// The encoder will create all GOPs of an exactly identical size - as specified in this option.
// Example: 150
func (s TranscoderTrackInfoImpl) Gop() *int {
	return s.GopValue
}

// Sets the number of frames in a GOP.
// The encoder will create all GOPs of an exactly identical size - as specified in this option.
// Example: 150
func (s *TranscoderTrackInfoImpl) SetGop(v int) TranscoderTrackInfo {
	if s == nil {
		return nil
	}
	s.GopValue = &v
	return s
}

// This parameter is used to get an interlaced stream from a progressive one.
// The allowed values are `true` (interlaced video), `false` (progressive video), or one of the methods for producing interlaced video supported for the selected type of transcoder.
func (s TranscoderTrackInfoImpl) Interlace() *InterlaceSettings {
	return s.InterlaceValue
}

// This parameter is used to get an interlaced stream from a progressive one.
// The allowed values are `true` (interlaced video), `false` (progressive video), or one of the methods for producing interlaced video supported for the selected type of transcoder.
func (s *TranscoderTrackInfoImpl) SetInterlace(v *InterlaceSettings) TranscoderTrackInfo {
	if s == nil {
		return nil
	}
	s.InterlaceValue = v
	return s
}

// A set of constraints that indicate a degree of required decoder performance.
// This parameter is used for compatibility with old devices.
func (s TranscoderTrackInfoImpl) Level() any {
	return s.LevelValue
}

// A set of constraints that indicate a degree of required decoder performance.
// This parameter is used for compatibility with old devices.
func (s *TranscoderTrackInfoImpl) SetLevel(v any) TranscoderTrackInfo {
	if s == nil {
		return nil
	}
	s.LevelValue = v
	return s
}

// The configuration of a logo "burned" into the video track.
// The transcoder adds the logo before the video is resized as specified in the `size` option.
// This means that the logo can be visibly stretched if the size was changed significantly.
func (s TranscoderTrackInfoImpl) Logo() TcLogo {
	return s.LogoValue
}

// The configuration of a logo "burned" into the video track.
// The transcoder adds the logo before the video is resized as specified in the `size` option.
// This means that the logo can be visibly stretched if the size was changed significantly.
func (s *TranscoderTrackInfoImpl) SetLogo(v TcLogo) TranscoderTrackInfo {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*TcLogoImpl); ok {
		s.LogoValue = impl
	}
	return s
}

// Whether open GOP is used. Open GOP contains P-frames that refer to the frames before the keyframe.
// It allows to decrease bitrate to 5-7%, but can result in breaking the picture.
// Do not enable this option if the track will be played over segment-based protocols (HLS, DASH, etc.) because
// absence of keyframes or IDR frames in the same segment with P-frames may prevent playback.
// [Read more about tracks, GOP and segments](https://flussonic.com/doc/live-stream-internals/).
func (s TranscoderTrackInfoImpl) OpenGop() *bool {
	return s.OpenGopValue
}

// Whether open GOP is used. Open GOP contains P-frames that refer to the frames before the keyframe.
// It allows to decrease bitrate to 5-7%, but can result in breaking the picture.
// Do not enable this option if the track will be played over segment-based protocols (HLS, DASH, etc.) because
// absence of keyframes or IDR frames in the same segment with P-frames may prevent playback.
// [Read more about tracks, GOP and segments](https://flussonic.com/doc/live-stream-internals/).
func (s *TranscoderTrackInfoImpl) SetOpenGop(v bool) TranscoderTrackInfo {
	if s == nil {
		return nil
	}
	s.OpenGopValue = &v
	return s
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s TranscoderTrackInfoImpl) Pid() *int {
	return s.PidValue
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s *TranscoderTrackInfoImpl) SetPid(v int) TranscoderTrackInfo {
	if s == nil {
		return nil
	}
	s.PidValue = &v
	return s
}

// A set of values that determine a certain encoding speed, which influences a compression ratio.
// A slower preset will provide better compression (compression is quality per file size).
// Example: medium
func (s TranscoderTrackInfoImpl) Preset() *TcPreset {
	return s.PresetValue
}

// A set of values that determine a certain encoding speed, which influences a compression ratio.
// A slower preset will provide better compression (compression is quality per file size).
// Example: medium
func (s *TranscoderTrackInfoImpl) SetPreset(v TcPreset) TranscoderTrackInfo {
	if s == nil {
		return nil
	}
	s.PresetValue = &v
	return s
}

// Limits the output to a specific H.264 profile.
func (s TranscoderTrackInfoImpl) Profile() *TcProfile {
	return s.ProfileValue
}

// Limits the output to a specific H.264 profile.
func (s *TranscoderTrackInfoImpl) SetProfile(v TcProfile) TranscoderTrackInfo {
	if s == nil {
		return nil
	}
	s.ProfileValue = &v
	return s
}

// The ranges of the quantization parameter for different types of frames in a GOP.
// Quantization is an algorithm used for video compression. It is based on fragmentation of video frames.
// Increasing this parameter allows to improve the compression but may lower the picture quality.
// Usually, these ranges are defined automatically by the transcoder, but for some types of transcoders it makes sense to set them manually.
func (s TranscoderTrackInfoImpl) QpRange() TcQpRange {
	return s.QpRangeValue
}

// The ranges of the quantization parameter for different types of frames in a GOP.
// Quantization is an algorithm used for video compression. It is based on fragmentation of video frames.
// Increasing this parameter allows to improve the compression but may lower the picture quality.
// Usually, these ranges are defined automatically by the transcoder, but for some types of transcoders it makes sense to set them manually.
func (s *TranscoderTrackInfoImpl) SetQpRange(v TcQpRange) TranscoderTrackInfo {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*TcQpRangeImpl); ok {
		s.QpRangeValue = impl
	}
	return s
}

// A method for creating output video with constant bitrate suitable for broadcasting to television networks.
func (s TranscoderTrackInfoImpl) RcMethod() *RcMethod {
	return s.RcMethodValue
}

// A method for creating output video with constant bitrate suitable for broadcasting to television networks.
func (s *TranscoderTrackInfoImpl) SetRcMethod(v RcMethod) TranscoderTrackInfo {
	if s == nil {
		return nil
	}
	s.RcMethodValue = &v
	return s
}

// The number of reference frames in a GOP.
// Reference frames are frames of a compressed video that are used to define other frames (P-frames and B-frames).
func (s TranscoderTrackInfoImpl) Refs() *int {
	return s.RefsValue
}

// The number of reference frames in a GOP.
// Reference frames are frames of a compressed video that are used to define other frames (P-frames and B-frames).
func (s *TranscoderTrackInfoImpl) SetRefs(v int) TranscoderTrackInfo {
	if s == nil {
		return nil
	}
	s.RefsValue = &v
	return s
}

// The mode to be used for resizing video tracks. It is one of the computing platforms for Flussonic Coder:
// * vic -  Video Image Converter, specific for Jetson Nvidia
// * cuda - CUDA (or Compute Unified Device Architecture)
func (s TranscoderTrackInfoImpl) ResizeMode() *TranscoderResizeMode {
	return s.ResizeModeValue
}

// The mode to be used for resizing video tracks. It is one of the computing platforms for Flussonic Coder:
// * vic -  Video Image Converter, specific for Jetson Nvidia
// * cuda - CUDA (or Compute Unified Device Architecture)
func (s *TranscoderTrackInfoImpl) SetResizeMode(v TranscoderResizeMode) TranscoderTrackInfo {
	if s == nil {
		return nil
	}
	s.ResizeModeValue = &v
	return s
}

// Target aspect ratio.
func (s TranscoderTrackInfoImpl) Sar() TcSar {
	return s.SarValue
}

// Target aspect ratio.
func (s *TranscoderTrackInfoImpl) SetSar(v TcSar) TranscoderTrackInfo {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*TcSarImpl); ok {
		s.SarValue = impl
	}
	return s
}

// Target size of the image and the strategy to achieve it.
func (s TranscoderTrackInfoImpl) Size() TcSize {
	return s.SizeValue
}

// Target size of the image and the strategy to achieve it.
func (s *TranscoderTrackInfoImpl) SetSize(v TcSize) TranscoderTrackInfo {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*TcSizeImpl); ok {
		s.SizeValue = impl
	}
	return s
}

// Drop some frames in dynamic scenes when the transcoder does not have time to code all frames.
// The allowed values are:
// * `15` - drop 1 from 5
// * `13` - drop 1 from 3
// * `12` - drop 1 from 2
// * `23` - drop 2 from 3
// * `0` - do not drop frames
func (s TranscoderTrackInfoImpl) TemporalTradeoff() *int {
	return s.TemporalTradeoffValue
}

// Drop some frames in dynamic scenes when the transcoder does not have time to code all frames.
// The allowed values are:
// * `15` - drop 1 from 5
// * `13` - drop 1 from 3
// * `12` - drop 1 from 2
// * `23` - drop 2 from 3
// * `0` - do not drop frames
func (s *TranscoderTrackInfoImpl) SetTemporalTradeoff(v int) TranscoderTrackInfo {
	if s == nil {
		return nil
	}
	s.TemporalTradeoffValue = &v
	return s
}

// Number of threads used by the encoder when transcoding with CPU (it is not used for other types of transcoder).
// This parameter allows to increase performance by adding new threads. By default, it is autodetected.
func (s TranscoderTrackInfoImpl) Threads() *int {
	return s.ThreadsValue
}

// Number of threads used by the encoder when transcoding with CPU (it is not used for other types of transcoder).
// This parameter allows to increase performance by adding new threads. By default, it is autodetected.
func (s *TranscoderTrackInfoImpl) SetThreads(v int) TranscoderTrackInfo {
	if s == nil {
		return nil
	}
	s.ThreadsValue = &v
	return s
}

// Human-readable localized title of the track.
// Example: Video1
func (s TranscoderTrackInfoImpl) Title() *string {
	return s.TitleValue
}

// Human-readable localized title of the track.
// Example: Video1
func (s *TranscoderTrackInfoImpl) SetTitle(v string) TranscoderTrackInfo {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// Virtual buffer size, it bits. The default value is `gop / fps * bitrate`.
func (s TranscoderTrackInfoImpl) VbvBufsize() *int {
	return s.VbvBufsizeValue
}

// Virtual buffer size, it bits. The default value is `gop / fps * bitrate`.
func (s *TranscoderTrackInfoImpl) SetVbvBufsize(v int) TranscoderTrackInfo {
	if s == nil {
		return nil
	}
	s.VbvBufsizeValue = &v
	return s
}

// NewTranscoderTrackInfoAudio creates a new TranscoderTrackInfoAudio instance
func NewTranscoderTrackInfoAudio() TranscoderTrackInfoAudio {
	return &TranscoderTrackInfoAudioImpl{}
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s TranscoderTrackInfoAudioImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s *TranscoderTrackInfoAudioImpl) SetBitrate(v Speed) TranscoderTrackInfoAudio {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// The number of audio channels in an output stream.
// Example: 2
func (s TranscoderTrackInfoAudioImpl) Channels() any {
	return s.ChannelsValue
}

// The number of audio channels in an output stream.
// Example: 2
func (s *TranscoderTrackInfoAudioImpl) SetChannels(v any) TranscoderTrackInfoAudio {
	if s == nil {
		return nil
	}
	s.ChannelsValue = v
	return s
}

// Audio codec (the AAC codec is used by default).
// Example: opus
func (s TranscoderTrackInfoAudioImpl) Codec() *string {
	return s.CodecValue
}

// Audio codec (the AAC codec is used by default).
// Example: opus
func (s *TranscoderTrackInfoAudioImpl) SetCodec(v string) TranscoderTrackInfoAudio {
	if s == nil {
		return nil
	}
	s.CodecValue = &v
	return s
}

// Content of the track (audio, video, or text).
func (s TranscoderTrackInfoAudioImpl) Content() FrameContent {
	return s.ContentValue
}

// Content of the track (audio, video, or text).
func (s *TranscoderTrackInfoAudioImpl) SetContent(v FrameContent) TranscoderTrackInfoAudio {
	if s == nil {
		return nil
	}
	s.ContentValue = v
	return s
}

// Input audio track to be transcoded.
// Example: 1
func (s TranscoderTrackInfoAudioImpl) InputTrack() *int {
	return s.InputTrackValue
}

// Input audio track to be transcoded.
// Example: 1
func (s *TranscoderTrackInfoAudioImpl) SetInputTrack(v int) TranscoderTrackInfoAudio {
	if s == nil {
		return nil
	}
	s.InputTrackValue = &v
	return s
}

// Language value of the track, if applicable.
// Example: eng
func (s TranscoderTrackInfoAudioImpl) Language() *string {
	return s.LanguageValue
}

// Language value of the track, if applicable.
// Example: eng
func (s *TranscoderTrackInfoAudioImpl) SetLanguage(v string) TranscoderTrackInfoAudio {
	if s == nil {
		return nil
	}
	s.LanguageValue = &v
	return s
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s TranscoderTrackInfoAudioImpl) Pid() *int {
	return s.PidValue
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s *TranscoderTrackInfoAudioImpl) SetPid(v int) TranscoderTrackInfoAudio {
	if s == nil {
		return nil
	}
	s.PidValue = &v
	return s
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// The allowed values are:
// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
// /Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
func (s TranscoderTrackInfoAudioImpl) SampleRate() any {
	return s.SampleRateValue
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// The allowed values are:
// `0` - to copy input sample rate, a number (input audio is resampled with equalization)
// /Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
func (s *TranscoderTrackInfoAudioImpl) SetSampleRate(v any) TranscoderTrackInfoAudio {
	if s == nil {
		return nil
	}
	s.SampleRateValue = v
	return s
}

// This option allows to split each audio track with multiple channels into several mono tracks.
func (s TranscoderTrackInfoAudioImpl) SplitChannels() *bool {
	return s.SplitChannelsValue
}

// This option allows to split each audio track with multiple channels into several mono tracks.
func (s *TranscoderTrackInfoAudioImpl) SetSplitChannels(v bool) TranscoderTrackInfoAudio {
	if s == nil {
		return nil
	}
	s.SplitChannelsValue = &v
	return s
}

// Human-readable localized title of the track.
// Example: Video1
func (s TranscoderTrackInfoAudioImpl) Title() *string {
	return s.TitleValue
}

// Human-readable localized title of the track.
// Example: Video1
func (s *TranscoderTrackInfoAudioImpl) SetTitle(v string) TranscoderTrackInfoAudio {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
// If it is just an integer or a float, the output audio volume is calculated by this formula:
// `output_volume = volume * input_volume`
// If specified in decibels (dB), the output audio volume is calculated as follows:
// `output_volume = input_volume +/- volume`
// depending whether it is a positive (+9dB) or a negative value (-6dB).
// By default it equals to 1 (the input audio volume).
// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
// Example: -6dB
func (s TranscoderTrackInfoAudioImpl) Volume() *string {
	return s.VolumeValue
}

// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
// If it is just an integer or a float, the output audio volume is calculated by this formula:
// `output_volume = volume * input_volume`
// If specified in decibels (dB), the output audio volume is calculated as follows:
// `output_volume = input_volume +/- volume`
// depending whether it is a positive (+9dB) or a negative value (-6dB).
// By default it equals to 1 (the input audio volume).
// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
// Example: -6dB
func (s *TranscoderTrackInfoAudioImpl) SetVolume(v string) TranscoderTrackInfoAudio {
	if s == nil {
		return nil
	}
	s.VolumeValue = &v
	return s
}

// NewTranscoderTrackInfoAudioSpec creates a new TranscoderTrackInfoAudioSpec instance
func NewTranscoderTrackInfoAudioSpec() TranscoderTrackInfoAudioSpec {
	return &TranscoderTrackInfoAudioSpecImpl{}
}

// Audio codec (the AAC codec is used by default).
// Example: opus
func (s TranscoderTrackInfoAudioSpecImpl) Codec() *string {
	return s.CodecValue
}

// Audio codec (the AAC codec is used by default).
// Example: opus
func (s *TranscoderTrackInfoAudioSpecImpl) SetCodec(v string) TranscoderTrackInfoAudioSpec {
	if s == nil {
		return nil
	}
	s.CodecValue = &v
	return s
}

// Input audio track to be transcoded.
// Example: 1
func (s TranscoderTrackInfoAudioSpecImpl) InputTrack() *int {
	return s.InputTrackValue
}

// Input audio track to be transcoded.
// Example: 1
func (s *TranscoderTrackInfoAudioSpecImpl) SetInputTrack(v int) TranscoderTrackInfoAudioSpec {
	if s == nil {
		return nil
	}
	s.InputTrackValue = &v
	return s
}

// Language value of the track, if applicable.
// Example: eng
func (s TranscoderTrackInfoAudioSpecImpl) Language() *string {
	return s.LanguageValue
}

// Language value of the track, if applicable.
// Example: eng
func (s *TranscoderTrackInfoAudioSpecImpl) SetLanguage(v string) TranscoderTrackInfoAudioSpec {
	if s == nil {
		return nil
	}
	s.LanguageValue = &v
	return s
}

// This option allows to split each audio track with multiple channels into several mono tracks.
func (s TranscoderTrackInfoAudioSpecImpl) SplitChannels() *bool {
	return s.SplitChannelsValue
}

// This option allows to split each audio track with multiple channels into several mono tracks.
func (s *TranscoderTrackInfoAudioSpecImpl) SetSplitChannels(v bool) TranscoderTrackInfoAudioSpec {
	if s == nil {
		return nil
	}
	s.SplitChannelsValue = &v
	return s
}

// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
// If it is just an integer or a float, the output audio volume is calculated by this formula:
// `output_volume = volume * input_volume`
// If specified in decibels (dB), the output audio volume is calculated as follows:
// `output_volume = input_volume +/- volume`
// depending whether it is a positive (+9dB) or a negative value (-6dB).
// By default it equals to 1 (the input audio volume).
// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
// Example: -6dB
func (s TranscoderTrackInfoAudioSpecImpl) Volume() *string {
	return s.VolumeValue
}

// Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).
// If it is just an integer or a float, the output audio volume is calculated by this formula:
// `output_volume = volume * input_volume`
// If specified in decibels (dB), the output audio volume is calculated as follows:
// `output_volume = input_volume +/- volume`
// depending whether it is a positive (+9dB) or a negative value (-6dB).
// By default it equals to 1 (the input audio volume).
// Pattern: ^([0-9]+(\.[0-9]+)?|(\+|\-)[0-9]+(\.[0-9]+)?dB)$
// Example: -6dB
func (s *TranscoderTrackInfoAudioSpecImpl) SetVolume(v string) TranscoderTrackInfoAudioSpec {
	if s == nil {
		return nil
	}
	s.VolumeValue = &v
	return s
}

// NewTranscoderTrackInfoVideo creates a new TranscoderTrackInfoVideo instance
func NewTranscoderTrackInfoVideo() TranscoderTrackInfoVideo {
	return &TranscoderTrackInfoVideoImpl{}
}

// The configuration of a logo added to the video track after the video was resized as specified in the `size` option.
// This prevents the logo picture from stretching that might occur when the `logo` option is used.
// You will need to prepare and specify a separate file with a logo for each size of the resulting video track.
func (s TranscoderTrackInfoVideoImpl) Alogo() TcLogo {
	return s.AlogoValue
}

// The configuration of a logo added to the video track after the video was resized as specified in the `size` option.
// This prevents the logo picture from stretching that might occur when the `logo` option is used.
// You will need to prepare and specify a separate file with a logo for each size of the resulting video track.
func (s *TranscoderTrackInfoVideoImpl) SetAlogo(v TcLogo) TranscoderTrackInfoVideo {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*TcLogoImpl); ok {
		s.AlogoValue = impl
	}
	return s
}

// Number of B-frames between I and P-frames. B-frames contain links to keyframes and P-frames before and after themselves.
// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
// When set to 0, this option disables b-frames. This may be necessary, for example, when broadcasting to RTSP.
// Example: 3
func (s TranscoderTrackInfoVideoImpl) Bframes() *int {
	return s.BframesValue
}

// Number of B-frames between I and P-frames. B-frames contain links to keyframes and P-frames before and after themselves.
// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
// When set to 0, this option disables b-frames. This may be necessary, for example, when broadcasting to RTSP.
// Example: 3
func (s *TranscoderTrackInfoVideoImpl) SetBframes(v int) TranscoderTrackInfoVideo {
	if s == nil {
		return nil
	}
	s.BframesValue = &v
	return s
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s TranscoderTrackInfoVideoImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s *TranscoderTrackInfoVideoImpl) SetBitrate(v Speed) TranscoderTrackInfoVideo {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// Configuration of burn-in text, timestamp, or subtitles to video frames.
func (s TranscoderTrackInfoVideoImpl) Burn() TcBurn {
	return s.BurnValue
}

// Configuration of burn-in text, timestamp, or subtitles to video frames.
func (s *TranscoderTrackInfoVideoImpl) SetBurn(v TcBurn) TranscoderTrackInfoVideo {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*TcBurnImpl); ok {
		s.BurnValue = impl
	}
	return s
}

// Codec of the track. Different codecs do **not** get the same track.
// Example: h264
func (s TranscoderTrackInfoVideoImpl) Codec() *FrameCodec {
	return s.CodecValue
}

// Codec of the track. Different codecs do **not** get the same track.
// Example: h264
func (s *TranscoderTrackInfoVideoImpl) SetCodec(v FrameCodec) TranscoderTrackInfoVideo {
	if s == nil {
		return nil
	}
	s.CodecValue = &v
	return s
}

// Content of the track (audio, video, or text).
func (s TranscoderTrackInfoVideoImpl) Content() FrameContent {
	return s.ContentValue
}

// Content of the track (audio, video, or text).
func (s *TranscoderTrackInfoVideoImpl) SetContent(v FrameContent) TranscoderTrackInfoVideo {
	if s == nil {
		return nil
	}
	s.ContentValue = v
	return s
}

// Some additional options.
func (s TranscoderTrackInfoVideoImpl) Extra() map[string]string {
	return s.ExtraValue
}

// Some additional options.
func (s *TranscoderTrackInfoVideoImpl) SetExtra(v map[string]string) TranscoderTrackInfoVideo {
	if s == nil {
		return nil
	}
	s.ExtraValue = v
	return s
}

// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
// Higher frame rates capture more images per second, which makes for smoother video.
// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
func (s TranscoderTrackInfoVideoImpl) FPS() *TcFPS {
	return s.FPSValue
}

// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
// Higher frame rates capture more images per second, which makes for smoother video.
// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
func (s *TranscoderTrackInfoVideoImpl) SetFPS(v *TcFPS) TranscoderTrackInfoVideo {
	if s == nil {
		return nil
	}
	s.FPSValue = v
	return s
}

// Sets the number of frames in a GOP.
// The encoder will create all GOPs of an exactly identical size - as specified in this option.
// Example: 150
func (s TranscoderTrackInfoVideoImpl) Gop() *int {
	return s.GopValue
}

// Sets the number of frames in a GOP.
// The encoder will create all GOPs of an exactly identical size - as specified in this option.
// Example: 150
func (s *TranscoderTrackInfoVideoImpl) SetGop(v int) TranscoderTrackInfoVideo {
	if s == nil {
		return nil
	}
	s.GopValue = &v
	return s
}

// This parameter is used to get an interlaced stream from a progressive one.
// The allowed values are `true` (interlaced video), `false` (progressive video), or one of the methods for producing interlaced video supported for the selected type of transcoder.
func (s TranscoderTrackInfoVideoImpl) Interlace() *InterlaceSettings {
	return s.InterlaceValue
}

// This parameter is used to get an interlaced stream from a progressive one.
// The allowed values are `true` (interlaced video), `false` (progressive video), or one of the methods for producing interlaced video supported for the selected type of transcoder.
func (s *TranscoderTrackInfoVideoImpl) SetInterlace(v *InterlaceSettings) TranscoderTrackInfoVideo {
	if s == nil {
		return nil
	}
	s.InterlaceValue = v
	return s
}

// A set of constraints that indicate a degree of required decoder performance.
// This parameter is used for compatibility with old devices.
func (s TranscoderTrackInfoVideoImpl) Level() any {
	return s.LevelValue
}

// A set of constraints that indicate a degree of required decoder performance.
// This parameter is used for compatibility with old devices.
func (s *TranscoderTrackInfoVideoImpl) SetLevel(v any) TranscoderTrackInfoVideo {
	if s == nil {
		return nil
	}
	s.LevelValue = v
	return s
}

// The configuration of a logo "burned" into the video track.
// The transcoder adds the logo before the video is resized as specified in the `size` option.
// This means that the logo can be visibly stretched if the size was changed significantly.
func (s TranscoderTrackInfoVideoImpl) Logo() TcLogo {
	return s.LogoValue
}

// The configuration of a logo "burned" into the video track.
// The transcoder adds the logo before the video is resized as specified in the `size` option.
// This means that the logo can be visibly stretched if the size was changed significantly.
func (s *TranscoderTrackInfoVideoImpl) SetLogo(v TcLogo) TranscoderTrackInfoVideo {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*TcLogoImpl); ok {
		s.LogoValue = impl
	}
	return s
}

// Whether open GOP is used. Open GOP contains P-frames that refer to the frames before the keyframe.
// It allows to decrease bitrate to 5-7%, but can result in breaking the picture.
// Do not enable this option if the track will be played over segment-based protocols (HLS, DASH, etc.) because
// absence of keyframes or IDR frames in the same segment with P-frames may prevent playback.
// [Read more about tracks, GOP and segments](https://flussonic.com/doc/live-stream-internals/).
func (s TranscoderTrackInfoVideoImpl) OpenGop() *bool {
	return s.OpenGopValue
}

// Whether open GOP is used. Open GOP contains P-frames that refer to the frames before the keyframe.
// It allows to decrease bitrate to 5-7%, but can result in breaking the picture.
// Do not enable this option if the track will be played over segment-based protocols (HLS, DASH, etc.) because
// absence of keyframes or IDR frames in the same segment with P-frames may prevent playback.
// [Read more about tracks, GOP and segments](https://flussonic.com/doc/live-stream-internals/).
func (s *TranscoderTrackInfoVideoImpl) SetOpenGop(v bool) TranscoderTrackInfoVideo {
	if s == nil {
		return nil
	}
	s.OpenGopValue = &v
	return s
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s TranscoderTrackInfoVideoImpl) Pid() *int {
	return s.PidValue
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s *TranscoderTrackInfoVideoImpl) SetPid(v int) TranscoderTrackInfoVideo {
	if s == nil {
		return nil
	}
	s.PidValue = &v
	return s
}

// A set of values that determine a certain encoding speed, which influences a compression ratio.
// A slower preset will provide better compression (compression is quality per file size).
// Example: medium
func (s TranscoderTrackInfoVideoImpl) Preset() *TcPreset {
	return s.PresetValue
}

// A set of values that determine a certain encoding speed, which influences a compression ratio.
// A slower preset will provide better compression (compression is quality per file size).
// Example: medium
func (s *TranscoderTrackInfoVideoImpl) SetPreset(v TcPreset) TranscoderTrackInfoVideo {
	if s == nil {
		return nil
	}
	s.PresetValue = &v
	return s
}

// Limits the output to a specific H.264 profile.
func (s TranscoderTrackInfoVideoImpl) Profile() *TcProfile {
	return s.ProfileValue
}

// Limits the output to a specific H.264 profile.
func (s *TranscoderTrackInfoVideoImpl) SetProfile(v TcProfile) TranscoderTrackInfoVideo {
	if s == nil {
		return nil
	}
	s.ProfileValue = &v
	return s
}

// The ranges of the quantization parameter for different types of frames in a GOP.
// Quantization is an algorithm used for video compression. It is based on fragmentation of video frames.
// Increasing this parameter allows to improve the compression but may lower the picture quality.
// Usually, these ranges are defined automatically by the transcoder, but for some types of transcoders it makes sense to set them manually.
func (s TranscoderTrackInfoVideoImpl) QpRange() TcQpRange {
	return s.QpRangeValue
}

// The ranges of the quantization parameter for different types of frames in a GOP.
// Quantization is an algorithm used for video compression. It is based on fragmentation of video frames.
// Increasing this parameter allows to improve the compression but may lower the picture quality.
// Usually, these ranges are defined automatically by the transcoder, but for some types of transcoders it makes sense to set them manually.
func (s *TranscoderTrackInfoVideoImpl) SetQpRange(v TcQpRange) TranscoderTrackInfoVideo {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*TcQpRangeImpl); ok {
		s.QpRangeValue = impl
	}
	return s
}

// A method for creating output video with constant bitrate suitable for broadcasting to television networks.
func (s TranscoderTrackInfoVideoImpl) RcMethod() *RcMethod {
	return s.RcMethodValue
}

// A method for creating output video with constant bitrate suitable for broadcasting to television networks.
func (s *TranscoderTrackInfoVideoImpl) SetRcMethod(v RcMethod) TranscoderTrackInfoVideo {
	if s == nil {
		return nil
	}
	s.RcMethodValue = &v
	return s
}

// The number of reference frames in a GOP.
// Reference frames are frames of a compressed video that are used to define other frames (P-frames and B-frames).
func (s TranscoderTrackInfoVideoImpl) Refs() *int {
	return s.RefsValue
}

// The number of reference frames in a GOP.
// Reference frames are frames of a compressed video that are used to define other frames (P-frames and B-frames).
func (s *TranscoderTrackInfoVideoImpl) SetRefs(v int) TranscoderTrackInfoVideo {
	if s == nil {
		return nil
	}
	s.RefsValue = &v
	return s
}

// The mode to be used for resizing video tracks. It is one of the computing platforms for Flussonic Coder:
// * vic -  Video Image Converter, specific for Jetson Nvidia
// * cuda - CUDA (or Compute Unified Device Architecture)
func (s TranscoderTrackInfoVideoImpl) ResizeMode() *TranscoderResizeMode {
	return s.ResizeModeValue
}

// The mode to be used for resizing video tracks. It is one of the computing platforms for Flussonic Coder:
// * vic -  Video Image Converter, specific for Jetson Nvidia
// * cuda - CUDA (or Compute Unified Device Architecture)
func (s *TranscoderTrackInfoVideoImpl) SetResizeMode(v TranscoderResizeMode) TranscoderTrackInfoVideo {
	if s == nil {
		return nil
	}
	s.ResizeModeValue = &v
	return s
}

// Target aspect ratio.
func (s TranscoderTrackInfoVideoImpl) Sar() TcSar {
	return s.SarValue
}

// Target aspect ratio.
func (s *TranscoderTrackInfoVideoImpl) SetSar(v TcSar) TranscoderTrackInfoVideo {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*TcSarImpl); ok {
		s.SarValue = impl
	}
	return s
}

// Target size of the image and the strategy to achieve it.
func (s TranscoderTrackInfoVideoImpl) Size() TcSize {
	return s.SizeValue
}

// Target size of the image and the strategy to achieve it.
func (s *TranscoderTrackInfoVideoImpl) SetSize(v TcSize) TranscoderTrackInfoVideo {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*TcSizeImpl); ok {
		s.SizeValue = impl
	}
	return s
}

// Drop some frames in dynamic scenes when the transcoder does not have time to code all frames.
// The allowed values are:
// * `15` - drop 1 from 5
// * `13` - drop 1 from 3
// * `12` - drop 1 from 2
// * `23` - drop 2 from 3
// * `0` - do not drop frames
func (s TranscoderTrackInfoVideoImpl) TemporalTradeoff() *int {
	return s.TemporalTradeoffValue
}

// Drop some frames in dynamic scenes when the transcoder does not have time to code all frames.
// The allowed values are:
// * `15` - drop 1 from 5
// * `13` - drop 1 from 3
// * `12` - drop 1 from 2
// * `23` - drop 2 from 3
// * `0` - do not drop frames
func (s *TranscoderTrackInfoVideoImpl) SetTemporalTradeoff(v int) TranscoderTrackInfoVideo {
	if s == nil {
		return nil
	}
	s.TemporalTradeoffValue = &v
	return s
}

// Number of threads used by the encoder when transcoding with CPU (it is not used for other types of transcoder).
// This parameter allows to increase performance by adding new threads. By default, it is autodetected.
func (s TranscoderTrackInfoVideoImpl) Threads() *int {
	return s.ThreadsValue
}

// Number of threads used by the encoder when transcoding with CPU (it is not used for other types of transcoder).
// This parameter allows to increase performance by adding new threads. By default, it is autodetected.
func (s *TranscoderTrackInfoVideoImpl) SetThreads(v int) TranscoderTrackInfoVideo {
	if s == nil {
		return nil
	}
	s.ThreadsValue = &v
	return s
}

// Human-readable localized title of the track.
// Example: Video1
func (s TranscoderTrackInfoVideoImpl) Title() *string {
	return s.TitleValue
}

// Human-readable localized title of the track.
// Example: Video1
func (s *TranscoderTrackInfoVideoImpl) SetTitle(v string) TranscoderTrackInfoVideo {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// Virtual buffer size, it bits. The default value is `gop / fps * bitrate`.
func (s TranscoderTrackInfoVideoImpl) VbvBufsize() *int {
	return s.VbvBufsizeValue
}

// Virtual buffer size, it bits. The default value is `gop / fps * bitrate`.
func (s *TranscoderTrackInfoVideoImpl) SetVbvBufsize(v int) TranscoderTrackInfoVideo {
	if s == nil {
		return nil
	}
	s.VbvBufsizeValue = &v
	return s
}

// NewTransponderPid creates a new TransponderPid instance
func NewTransponderPid() TransponderPid {
	return &TransponderPidImpl{}
}

// Bitrate of the track.
// Format: speed (speed)
// Example: 2543
func (s TransponderPidImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// Bitrate of the track.
// Format: speed (speed)
// Example: 2543
func (s *TransponderPidImpl) SetBitrate(v Speed) TransponderPid {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// Codec for this pid. Use this if just content+track is not enough.
// Example: scte35
func (s TransponderPidImpl) Codec() *FrameCodec {
	return s.CodecValue
}

// Codec for this pid. Use this if just content+track is not enough.
// Example: scte35
func (s *TransponderPidImpl) SetCodec(v FrameCodec) TransponderPid {
	if s == nil {
		return nil
	}
	s.CodecValue = &v
	return s
}

// Content of the track.
// Example: audio
func (s TransponderPidImpl) Content() string {
	return s.ContentValue
}

// Content of the track.
// Example: audio
func (s *TransponderPidImpl) SetContent(v string) TransponderPid {
	if s == nil {
		return nil
	}
	s.ContentValue = v
	return s
}

// Raw elementary stream descriptors to describe proprietary stream in PMT program info
// Plese refer to ISO/IEC 13818-1 section 2.6 for syntax
// This is an optional parameter for advanced users. By default, the media Server
// is automatically sets the stream_type according to the track codec.
// Format: hexbinary (hexbinary)
// Example: 52010D
func (s TransponderPidImpl) EsInfo() *Hexbinary {
	return s.EsInfoValue
}

// Raw elementary stream descriptors to describe proprietary stream in PMT program info
// Plese refer to ISO/IEC 13818-1 section 2.6 for syntax
// This is an optional parameter for advanced users. By default, the media Server
// is automatically sets the stream_type according to the track codec.
// Format: hexbinary (hexbinary)
// Example: 52010D
func (s *TransponderPidImpl) SetEsInfo(v Hexbinary) TransponderPid {
	if s == nil {
		return nil
	}
	s.EsInfoValue = &v
	return s
}

// A PID to assign to a matched track or system table.
// PID identifies the payload (media or service) in the resulting MPTS stream.
// Multiplexer will include only the tracks with specified PIDs.
// It is possible to set PID values for video, audio and other media tracks, as well as for PMT and SDT.
func (s TransponderPidImpl) Pid() int {
	return s.PidValue
}

// A PID to assign to a matched track or system table.
// PID identifies the payload (media or service) in the resulting MPTS stream.
// Multiplexer will include only the tracks with specified PIDs.
// It is possible to set PID values for video, audio and other media tracks, as well as for PMT and SDT.
func (s *TransponderPidImpl) SetPid(v int) TransponderPid {
	if s == nil {
		return nil
	}
	s.PidValue = v
	return s
}

// Detailed runtime information about the multiplexer pid.
func (s TransponderPidImpl) Stats() PushPidCounters {
	return s.StatsValue
}

// Detailed runtime information about the multiplexer pid.
func (s *TransponderPidImpl) SetStats(v PushPidCounters) TransponderPid {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*PushPidCountersImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// Custom program element type in PMT
// Combined with bypass (content=metadata, track=0) this option makes
// proprietary PSI streams appear in PMT program info with given stream_type field
// This is an optional parameter for advanced users. By default, the media Server
// is automatically sets the stream_type according to the track codec.
// Example: 12
func (s TransponderPidImpl) StreamType() *int {
	return s.StreamTypeValue
}

// Custom program element type in PMT
// Combined with bypass (content=metadata, track=0) this option makes
// proprietary PSI streams appear in PMT program info with given stream_type field
// This is an optional parameter for advanced users. By default, the media Server
// is automatically sets the stream_type according to the track codec.
// Example: 12
func (s *TransponderPidImpl) SetStreamType(v int) TransponderPid {
	if s == nil {
		return nil
	}
	s.StreamTypeValue = &v
	return s
}

// Index of a track with specified content and maybe codec.
// E.g. when you specify content=audio and track=2 the second audio track will be selected.
// If you specify content=audio, codec=aac and track=1, the first AAC track will be selected
// even if it is a third audio track and fifth track in stream media_info
// Example: 1
func (s TransponderPidImpl) Track() int {
	return s.TrackValue
}

// Index of a track with specified content and maybe codec.
// E.g. when you specify content=audio and track=2 the second audio track will be selected.
// If you specify content=audio, codec=aac and track=1, the first AAC track will be selected
// even if it is a third audio track and fifth track in stream media_info
// Example: 1
func (s *TransponderPidImpl) SetTrack(v int) TransponderPid {
	if s == nil {
		return nil
	}
	s.TrackValue = v
	return s
}

// NewTtxtDescriptors creates a new TtxtDescriptors instance
func NewTtxtDescriptors() TtxtDescriptors {
	return &TtxtDescriptorsImpl{}
}

// The language code of the teletext.
func (s TtxtDescriptorsImpl) Lang() string {
	return s.LangValue
}

// The language code of the teletext.
func (s *TtxtDescriptorsImpl) SetLang(v string) TtxtDescriptors {
	if s == nil {
		return nil
	}
	s.LangValue = v
	return s
}

// Page number of the teletext received from an SDI card.
// It is defined according to ETS 300 706 teletext specification.
// The information about the pages is received from the stream provider.
// Example: 100
func (s TtxtDescriptorsImpl) Page() int {
	return s.PageValue
}

// Page number of the teletext received from an SDI card.
// It is defined according to ETS 300 706 teletext specification.
// The information about the pages is received from the stream provider.
// Example: 100
func (s *TtxtDescriptorsImpl) SetPage(v int) TtxtDescriptors {
	if s == nil {
		return nil
	}
	s.PageValue = v
	return s
}

// Teletext page type defined according to the Specification for Service Information (SI) in DVB systems, 6.2.32 Teletext descriptor in EN 300 468 Digital Video Broadcasting (DVB).
// Example: initial
func (s TtxtDescriptorsImpl) Type() string {
	return s.TypeValue
}

// Teletext page type defined according to the Specification for Service Information (SI) in DVB systems, 6.2.32 Teletext descriptor in EN 300 468 Digital Video Broadcasting (DVB).
// Example: initial
func (s *TtxtDescriptorsImpl) SetType(v string) TtxtDescriptors {
	if s == nil {
		return nil
	}
	s.TypeValue = v
	return s
}

// NewVbiLines creates a new VbiLines instance
func NewVbiLines() VbiLines {
	return &VbiLinesImpl{}
}

// Numbers of VBI lines that will carry a teletext track.
func (s VbiLinesImpl) Lines() []VbiLine {
	return s.LinesValue
}

// Numbers of VBI lines that will carry a teletext track.
func (s *VbiLinesImpl) SetLines(v []VbiLine) VbiLines {
	if s == nil {
		return nil
	}
	s.LinesValue = v
	return s
}

// The service information passed to VBI of the output analog stream.
// The allowed value is `ttxt` - teletext.
func (s VbiLinesImpl) Service() *VbiService {
	return s.ServiceValue
}

// The service information passed to VBI of the output analog stream.
// The allowed value is `ttxt` - teletext.
func (s *VbiLinesImpl) SetService(v VbiService) VbiLines {
	if s == nil {
		return nil
	}
	s.ServiceValue = &v
	return s
}

// NewVisionAlerts creates a new VisionAlerts instance
func NewVisionAlerts() VisionAlerts {
	return &VisionAlertsImpl{}
}

// The time when an episode could not be created due to low detection quality (on blurry or noisy frames).
// It may be caused by uncertainty when the picture is not clear enough.
// Try adjusting the shutter speed parameters on your camera.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s VisionAlertsImpl) LowQualityAt() *UtcMs {
	return s.LowQualityAtValue
}

// The time when an episode could not be created due to low detection quality (on blurry or noisy frames).
// It may be caused by uncertainty when the picture is not clear enough.
// Try adjusting the shutter speed parameters on your camera.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s *VisionAlertsImpl) SetLowQualityAt(v UtcMs) VisionAlerts {
	if s == nil {
		return nil
	}
	s.LowQualityAtValue = &v
	return s
}

// The time when an episode could not be created due to insufficient detections.
// The issue occurs when the selected detector is unable to find the target object enough times.
// It is possible that the target object appears shortly or is obscured by something.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s VisionAlertsImpl) NotEnoughDetectionsAt() *UtcMs {
	return s.NotEnoughDetectionsAtValue
}

// The time when an episode could not be created due to insufficient detections.
// The issue occurs when the selected detector is unable to find the target object enough times.
// It is possible that the target object appears shortly or is obscured by something.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s *VisionAlertsImpl) SetNotEnoughDetectionsAt(v UtcMs) VisionAlerts {
	if s == nil {
		return nil
	}
	s.NotEnoughDetectionsAtValue = &v
	return s
}

// The time when an episode could not be created due to the small size of detections relative to the detector internal settings.
// The camera placement may need to be adjusted closer to the target objects.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s VisionAlertsImpl) SmallSizeAt() *UtcMs {
	return s.SmallSizeAtValue
}

// The time when an episode could not be created due to the small size of detections relative to the detector internal settings.
// The camera placement may need to be adjusted closer to the target objects.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s *VisionAlertsImpl) SetSmallSizeAt(v UtcMs) VisionAlerts {
	if s == nil {
		return nil
	}
	s.SmallSizeAtValue = &v
	return s
}

// NewVisionAppearance creates a new VisionAppearance instance
func NewVisionAppearance() VisionAppearance {
	return &VisionAppearanceImpl{}
}

// Position of the objects at the frame
func (s VisionAppearanceImpl) Box() VisionBox {
	return s.BoxValue
}

// Position of the objects at the frame
func (s *VisionAppearanceImpl) SetBox(v VisionBox) VisionAppearance {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionBoxImpl); ok {
		s.BoxValue = impl
	}
	return s
}

// NewVisionBox creates a new VisionBox instance
func NewVisionBox() VisionBox {
	return &VisionBoxImpl{}
}

// Bottom border of the bounding box. Fraction of full frame height
func (s VisionBoxImpl) Bottom() float64 {
	return s.BottomValue
}

// Bottom border of the bounding box. Fraction of full frame height
func (s *VisionBoxImpl) SetBottom(v float64) VisionBox {
	if s == nil {
		return nil
	}
	s.BottomValue = v
	return s
}

// Left border of the bounding box. Fraction of full frame width
func (s VisionBoxImpl) Left() float64 {
	return s.LeftValue
}

// Left border of the bounding box. Fraction of full frame width
func (s *VisionBoxImpl) SetLeft(v float64) VisionBox {
	if s == nil {
		return nil
	}
	s.LeftValue = v
	return s
}

// Right border of the bounding box. Fraction of full frame width
func (s VisionBoxImpl) Right() float64 {
	return s.RightValue
}

// Right border of the bounding box. Fraction of full frame width
func (s *VisionBoxImpl) SetRight(v float64) VisionBox {
	if s == nil {
		return nil
	}
	s.RightValue = v
	return s
}

// Top border of the bounding box. Fraction of full frame height
func (s VisionBoxImpl) Top() float64 {
	return s.TopValue
}

// Top border of the bounding box. Fraction of full frame height
func (s *VisionBoxImpl) SetTop(v float64) VisionBox {
	if s == nil {
		return nil
	}
	s.TopValue = v
	return s
}

// NewVisionDetectedFace creates a new VisionDetectedFace instance
func NewVisionDetectedFace() VisionDetectedFace {
	return &VisionDetectedFaceImpl{}
}

// Appearance attributes of the detected object
func (s VisionDetectedFaceImpl) Appearance() VisionAppearance {
	return s.AppearanceValue
}

// Appearance attributes of the detected object
func (s *VisionDetectedFaceImpl) SetAppearance(v VisionAppearance) VisionDetectedFace {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionAppearanceImpl); ok {
		s.AppearanceValue = impl
	}
	return s
}

// Confidence level of object detection
func (s VisionDetectedFaceImpl) Confidence() *float64 {
	return s.ConfidenceValue
}

// Confidence level of object detection
func (s *VisionDetectedFaceImpl) SetConfidence(v float64) VisionDetectedFace {
	if s == nil {
		return nil
	}
	s.ConfidenceValue = &v
	return s
}

// Timestamp when the object was detected
// Format: utc_ms (Unix timestamp in milliseconds)
func (s VisionDetectedFaceImpl) DetectedAt() UtcMs {
	return s.DetectedAtValue
}

// Timestamp when the object was detected
// Format: utc_ms (Unix timestamp in milliseconds)
func (s *VisionDetectedFaceImpl) SetDetectedAt(v UtcMs) VisionDetectedFace {
	if s == nil {
		return nil
	}
	s.DetectedAtValue = v
	return s
}

// The fingerprint of the detected face
func (s VisionDetectedFaceImpl) Fingerprint() VisionFaceFingerprint {
	return s.FingerprintValue
}

// The fingerprint of the detected face
func (s *VisionDetectedFaceImpl) SetFingerprint(v VisionFaceFingerprint) VisionDetectedFace {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionFaceFingerprintImpl); ok {
		s.FingerprintValue = impl
	}
	return s
}

// Class of the detected object
func (s VisionDetectedFaceImpl) ObjectClass() VisionObjectClass {
	return s.ObjectClassValue
}

// Class of the detected object
func (s *VisionDetectedFaceImpl) SetObjectClass(v VisionObjectClass) VisionDetectedFace {
	if s == nil {
		return nil
	}
	s.ObjectClassValue = v
	return s
}

// Preview of the detected object
func (s VisionDetectedFaceImpl) Thumbnail() VisionImageAttributes {
	return s.ThumbnailValue
}

// Preview of the detected object
func (s *VisionDetectedFaceImpl) SetThumbnail(v VisionImageAttributes) VisionDetectedFace {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionImageAttributesImpl); ok {
		s.ThumbnailValue = impl
	}
	return s
}

// Quality of the thumbnail
func (s VisionDetectedFaceImpl) ThumbnailQuality() *float64 {
	return s.ThumbnailQualityValue
}

// Quality of the thumbnail
func (s *VisionDetectedFaceImpl) SetThumbnailQuality(v float64) VisionDetectedFace {
	if s == nil {
		return nil
	}
	s.ThumbnailQualityValue = &v
	return s
}

// NewVisionDetectedLicensePlate creates a new VisionDetectedLicensePlate instance
func NewVisionDetectedLicensePlate() VisionDetectedLicensePlate {
	return &VisionDetectedLicensePlateImpl{}
}

// Appearance attributes of the detected object
func (s VisionDetectedLicensePlateImpl) Appearance() VisionAppearance {
	return s.AppearanceValue
}

// Appearance attributes of the detected object
func (s *VisionDetectedLicensePlateImpl) SetAppearance(v VisionAppearance) VisionDetectedLicensePlate {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionAppearanceImpl); ok {
		s.AppearanceValue = impl
	}
	return s
}

// Confidence level of object detection
func (s VisionDetectedLicensePlateImpl) Confidence() *float64 {
	return s.ConfidenceValue
}

// Confidence level of object detection
func (s *VisionDetectedLicensePlateImpl) SetConfidence(v float64) VisionDetectedLicensePlate {
	if s == nil {
		return nil
	}
	s.ConfidenceValue = &v
	return s
}

// Timestamp when the object was detected
// Format: utc_ms (Unix timestamp in milliseconds)
func (s VisionDetectedLicensePlateImpl) DetectedAt() UtcMs {
	return s.DetectedAtValue
}

// Timestamp when the object was detected
// Format: utc_ms (Unix timestamp in milliseconds)
func (s *VisionDetectedLicensePlateImpl) SetDetectedAt(v UtcMs) VisionDetectedLicensePlate {
	if s == nil {
		return nil
	}
	s.DetectedAtValue = v
	return s
}

// Shows from which side the vehicle was detected.
func (s VisionDetectedLicensePlateImpl) FacingSide() *VisionVehicleFacingSide {
	return s.FacingSideValue
}

// Shows from which side the vehicle was detected.
func (s *VisionDetectedLicensePlateImpl) SetFacingSide(v VisionVehicleFacingSide) VisionDetectedLicensePlate {
	if s == nil {
		return nil
	}
	s.FacingSideValue = &v
	return s
}

// Class of the detected object
func (s VisionDetectedLicensePlateImpl) ObjectClass() VisionObjectClass {
	return s.ObjectClassValue
}

// Class of the detected object
func (s *VisionDetectedLicensePlateImpl) SetObjectClass(v VisionObjectClass) VisionDetectedLicensePlate {
	if s == nil {
		return nil
	}
	s.ObjectClassValue = v
	return s
}

// Recognized vehicle's license plate number
func (s VisionDetectedLicensePlateImpl) PlateText() *string {
	return s.PlateTextValue
}

// Recognized vehicle's license plate number
func (s *VisionDetectedLicensePlateImpl) SetPlateText(v string) VisionDetectedLicensePlate {
	if s == nil {
		return nil
	}
	s.PlateTextValue = &v
	return s
}

// Preview of the detected object
func (s VisionDetectedLicensePlateImpl) Thumbnail() VisionImageAttributes {
	return s.ThumbnailValue
}

// Preview of the detected object
func (s *VisionDetectedLicensePlateImpl) SetThumbnail(v VisionImageAttributes) VisionDetectedLicensePlate {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionImageAttributesImpl); ok {
		s.ThumbnailValue = impl
	}
	return s
}

// Quality of the thumbnail
func (s VisionDetectedLicensePlateImpl) ThumbnailQuality() *float64 {
	return s.ThumbnailQualityValue
}

// Quality of the thumbnail
func (s *VisionDetectedLicensePlateImpl) SetThumbnailQuality(v float64) VisionDetectedLicensePlate {
	if s == nil {
		return nil
	}
	s.ThumbnailQualityValue = &v
	return s
}

// NewVisionDetectedObjectBase creates a new VisionDetectedObjectBase instance
func NewVisionDetectedObjectBase() VisionDetectedObjectBase {
	return &VisionDetectedObjectBaseImpl{}
}

// Appearance attributes of the detected object
func (s VisionDetectedObjectBaseImpl) Appearance() VisionAppearance {
	return s.AppearanceValue
}

// Appearance attributes of the detected object
func (s *VisionDetectedObjectBaseImpl) SetAppearance(v VisionAppearance) VisionDetectedObjectBase {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionAppearanceImpl); ok {
		s.AppearanceValue = impl
	}
	return s
}

// Confidence level of object detection
func (s VisionDetectedObjectBaseImpl) Confidence() *float64 {
	return s.ConfidenceValue
}

// Confidence level of object detection
func (s *VisionDetectedObjectBaseImpl) SetConfidence(v float64) VisionDetectedObjectBase {
	if s == nil {
		return nil
	}
	s.ConfidenceValue = &v
	return s
}

// Timestamp when the object was detected
// Format: utc_ms (Unix timestamp in milliseconds)
func (s VisionDetectedObjectBaseImpl) DetectedAt() UtcMs {
	return s.DetectedAtValue
}

// Timestamp when the object was detected
// Format: utc_ms (Unix timestamp in milliseconds)
func (s *VisionDetectedObjectBaseImpl) SetDetectedAt(v UtcMs) VisionDetectedObjectBase {
	if s == nil {
		return nil
	}
	s.DetectedAtValue = v
	return s
}

// Class of the detected object
func (s VisionDetectedObjectBaseImpl) ObjectClass() VisionObjectClass {
	return s.ObjectClassValue
}

// Class of the detected object
func (s *VisionDetectedObjectBaseImpl) SetObjectClass(v VisionObjectClass) VisionDetectedObjectBase {
	if s == nil {
		return nil
	}
	s.ObjectClassValue = v
	return s
}

// Preview of the detected object
func (s VisionDetectedObjectBaseImpl) Thumbnail() VisionImageAttributes {
	return s.ThumbnailValue
}

// Preview of the detected object
func (s *VisionDetectedObjectBaseImpl) SetThumbnail(v VisionImageAttributes) VisionDetectedObjectBase {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionImageAttributesImpl); ok {
		s.ThumbnailValue = impl
	}
	return s
}

// Quality of the thumbnail
func (s VisionDetectedObjectBaseImpl) ThumbnailQuality() *float64 {
	return s.ThumbnailQualityValue
}

// Quality of the thumbnail
func (s *VisionDetectedObjectBaseImpl) SetThumbnailQuality(v float64) VisionDetectedObjectBase {
	if s == nil {
		return nil
	}
	s.ThumbnailQualityValue = &v
	return s
}

// NewVisionDetectedVehicle creates a new VisionDetectedVehicle instance
func NewVisionDetectedVehicle() VisionDetectedVehicle {
	return &VisionDetectedVehicleImpl{}
}

// Appearance attributes of the detected object
func (s VisionDetectedVehicleImpl) Appearance() VisionAppearance {
	return s.AppearanceValue
}

// Appearance attributes of the detected object
func (s *VisionDetectedVehicleImpl) SetAppearance(v VisionAppearance) VisionDetectedVehicle {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionAppearanceImpl); ok {
		s.AppearanceValue = impl
	}
	return s
}

// Confidence level of object detection
func (s VisionDetectedVehicleImpl) Confidence() *float64 {
	return s.ConfidenceValue
}

// Confidence level of object detection
func (s *VisionDetectedVehicleImpl) SetConfidence(v float64) VisionDetectedVehicle {
	if s == nil {
		return nil
	}
	s.ConfidenceValue = &v
	return s
}

// Timestamp when the object was detected
// Format: utc_ms (Unix timestamp in milliseconds)
func (s VisionDetectedVehicleImpl) DetectedAt() UtcMs {
	return s.DetectedAtValue
}

// Timestamp when the object was detected
// Format: utc_ms (Unix timestamp in milliseconds)
func (s *VisionDetectedVehicleImpl) SetDetectedAt(v UtcMs) VisionDetectedVehicle {
	if s == nil {
		return nil
	}
	s.DetectedAtValue = v
	return s
}

// Indicates if no license plate is detected on this vehicle
func (s VisionDetectedVehicleImpl) LicensePlateMissing() *bool {
	return s.LicensePlateMissingValue
}

// Indicates if no license plate is detected on this vehicle
func (s *VisionDetectedVehicleImpl) SetLicensePlateMissing(v bool) VisionDetectedVehicle {
	if s == nil {
		return nil
	}
	s.LicensePlateMissingValue = &v
	return s
}

// Class of the detected object
func (s VisionDetectedVehicleImpl) ObjectClass() VisionObjectClass {
	return s.ObjectClassValue
}

// Class of the detected object
func (s *VisionDetectedVehicleImpl) SetObjectClass(v VisionObjectClass) VisionDetectedVehicle {
	if s == nil {
		return nil
	}
	s.ObjectClassValue = v
	return s
}

// The purpose of the vehicle, e.g. emergency or regular.
func (s VisionDetectedVehicleImpl) Purpose() *VisionVehiclePurpose {
	return s.PurposeValue
}

// The purpose of the vehicle, e.g. emergency or regular.
func (s *VisionDetectedVehicleImpl) SetPurpose(v VisionVehiclePurpose) VisionDetectedVehicle {
	if s == nil {
		return nil
	}
	s.PurposeValue = &v
	return s
}

// Preview of the detected object
func (s VisionDetectedVehicleImpl) Thumbnail() VisionImageAttributes {
	return s.ThumbnailValue
}

// Preview of the detected object
func (s *VisionDetectedVehicleImpl) SetThumbnail(v VisionImageAttributes) VisionDetectedVehicle {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionImageAttributesImpl); ok {
		s.ThumbnailValue = impl
	}
	return s
}

// Quality of the thumbnail
func (s VisionDetectedVehicleImpl) ThumbnailQuality() *float64 {
	return s.ThumbnailQualityValue
}

// Quality of the thumbnail
func (s *VisionDetectedVehicleImpl) SetThumbnailQuality(v float64) VisionDetectedVehicle {
	if s == nil {
		return nil
	}
	s.ThumbnailQualityValue = &v
	return s
}

// NewVisionDetectorConfig creates a new VisionDetectorConfig instance
func NewVisionDetectorConfig() VisionDetectorConfig {
	return &VisionDetectorConfigImpl{}
}

func (s VisionDetectorConfigImpl) DetectorType() VisionDetectorConfigDetectorType {
	return s.DetectorTypeValue
}

func (s *VisionDetectorConfigImpl) SetDetectorType(v VisionDetectorConfigDetectorType) VisionDetectorConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionDetectorConfigDetectorTypeImpl); ok {
		s.DetectorTypeValue = impl
	}
	return s
}

func (s VisionDetectorConfigImpl) RegionCoordinates() VisionDetectorConfigRegionCoordinates {
	return s.RegionCoordinatesValue
}

func (s *VisionDetectorConfigImpl) SetRegionCoordinates(v VisionDetectorConfigRegionCoordinates) VisionDetectorConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionDetectorConfigRegionCoordinatesImpl); ok {
		s.RegionCoordinatesValue = impl
	}
	return s
}

// Identifier of the detection area.
// It is used to distinguish episodes from various regions of interest within the frame.
// For instance, it can be used with a single camera facing two entrances to count visitors independently at each entrance.
func (s VisionDetectorConfigImpl) RegionID() string {
	return s.RegionIDValue
}

// Identifier of the detection area.
// It is used to distinguish episodes from various regions of interest within the frame.
// For instance, it can be used with a single camera facing two entrances to count visitors independently at each entrance.
func (s *VisionDetectorConfigImpl) SetRegionID(v string) VisionDetectorConfig {
	if s == nil {
		return nil
	}
	s.RegionIDValue = v
	return s
}

// Runtime information about the vision process.
func (s VisionDetectorConfigImpl) Stats() VisionDetectorStats {
	return s.StatsValue
}

// Runtime information about the vision process.
func (s *VisionDetectorConfigImpl) SetStats(v VisionDetectorStats) VisionDetectorConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionDetectorStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// NewVisionDetectorConfigDetectorType creates a new VisionDetectorConfigDetectorType instance
func NewVisionDetectorConfigDetectorType() VisionDetectorConfigDetectorType {
	return &VisionDetectorConfigDetectorTypeImpl{}
}

// NewVisionDetectorConfigRegionCoordinates creates a new VisionDetectorConfigRegionCoordinates instance
func NewVisionDetectorConfigRegionCoordinates() VisionDetectorConfigRegionCoordinates {
	return &VisionDetectorConfigRegionCoordinatesImpl{}
}

// NewVisionDetectorStats creates a new VisionDetectorStats instance
func NewVisionDetectorStats() VisionDetectorStats {
	return &VisionDetectorStatsImpl{}
}

// Identifies analytics issues related to frames in a stream that impact episode creation
func (s VisionDetectorStatsImpl) Alerts() VisionAlerts {
	return s.AlertsValue
}

// Identifies analytics issues related to frames in a stream that impact episode creation
func (s *VisionDetectorStatsImpl) SetAlerts(v VisionAlerts) VisionDetectorStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionAlertsImpl); ok {
		s.AlertsValue = impl
	}
	return s
}

// The time when there was the last detection. Constant updates mean that analytics can detect objects on frames.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s VisionDetectorStatsImpl) LastDetectionAt() *UtcMs {
	return s.LastDetectionAtValue
}

// The time when there was the last detection. Constant updates mean that analytics can detect objects on frames.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s *VisionDetectorStatsImpl) SetLastDetectionAt(v UtcMs) VisionDetectorStats {
	if s == nil {
		return nil
	}
	s.LastDetectionAtValue = &v
	return s
}

// Indicates the analytics status of the stream on inference node.
func (s VisionDetectorStatsImpl) Status() *StreamStatus {
	return s.StatusValue
}

// Indicates the analytics status of the stream on inference node.
func (s *VisionDetectorStatsImpl) SetStatus(v StreamStatus) VisionDetectorStats {
	if s == nil {
		return nil
	}
	s.StatusValue = &v
	return s
}

// NewVisionEpisodeContextSearch creates a new VisionEpisodeContextSearch instance
func NewVisionEpisodeContextSearch() VisionEpisodeContextSearch {
	return &VisionEpisodeContextSearchImpl{}
}

// The reason for closing the episode.
func (s VisionEpisodeContextSearchImpl) CloseReason() *EpisodeCloseReason {
	return s.CloseReasonValue
}

// The reason for closing the episode.
func (s *VisionEpisodeContextSearchImpl) SetCloseReason(v EpisodeCloseReason) VisionEpisodeContextSearch {
	if s == nil {
		return nil
	}
	s.CloseReasonValue = &v
	return s
}

// Episode emitter can decide that episode considered closed and will not grow further.
// `closed_at` MUST NOT change, it must be emitted only once.
// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
// of the episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s VisionEpisodeContextSearchImpl) ClosedAt() *UtcMs {
	return s.ClosedAtValue
}

// Episode emitter can decide that episode considered closed and will not grow further.
// `closed_at` MUST NOT change, it must be emitted only once.
// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
// of the episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *VisionEpisodeContextSearchImpl) SetClosedAt(v UtcMs) VisionEpisodeContextSearch {
	if s == nil {
		return nil
	}
	s.ClosedAtValue = &v
	return s
}

// The time when the episode appeared in the service relative to the server time.
func (s VisionEpisodeContextSearchImpl) EpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps {
	return s.EpisodeAppearanceTimestampsValue
}

// The time when the episode appeared in the service relative to the server time.
func (s *VisionEpisodeContextSearchImpl) SetEpisodeAppearanceTimestamps(v EpisodeAppearanceTimestamps) VisionEpisodeContextSearch {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*EpisodeAppearanceTimestampsImpl); ok {
		s.EpisodeAppearanceTimestampsValue = impl
	}
	return s
}

// Unique identifier of the episode. Must be created by the system that first creates this episode.
// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
// handle very long integers.
// Format: snowflake_id (snowflake_id)
// Examples: 1.722279170848854e+18
func (s VisionEpisodeContextSearchImpl) EpisodeID() SnowflakeID {
	return s.EpisodeIDValue
}

// Unique identifier of the episode. Must be created by the system that first creates this episode.
// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
// handle very long integers.
// Format: snowflake_id (snowflake_id)
// Examples: 1.722279170848854e+18
func (s *VisionEpisodeContextSearchImpl) SetEpisodeID(v SnowflakeID) VisionEpisodeContextSearch {
	if s == nil {
		return nil
	}
	s.EpisodeIDValue = v
	return s
}

// Episode matches context search text query
func (s VisionEpisodeContextSearchImpl) EpisodeType() *string {
	return s.EpisodeTypeValue
}

// Episode matches context search text query
func (s *VisionEpisodeContextSearchImpl) SetEpisodeType(v string) VisionEpisodeContextSearch {
	if s == nil {
		return nil
	}
	s.EpisodeTypeValue = &v
	return s
}

// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
// Format: base64 (base64)
func (s VisionEpisodeContextSearchImpl) FramePreview() *Base64 {
	return s.FramePreviewValue
}

// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
// Format: base64 (base64)
func (s *VisionEpisodeContextSearchImpl) SetFramePreview(v Base64) VisionEpisodeContextSearch {
	if s == nil {
		return nil
	}
	s.FramePreviewValue = &v
	return s
}

// Maximum matching score between the text query and episode.
// Examples: 0.2345
func (s VisionEpisodeContextSearchImpl) MatchScore() *float64 {
	return s.MatchScoreValue
}

// Maximum matching score between the text query and episode.
// Examples: 0.2345
func (s *VisionEpisodeContextSearchImpl) SetMatchScore(v float64) VisionEpisodeContextSearch {
	if s == nil {
		return nil
	}
	s.MatchScoreValue = &v
	return s
}

// Stream name on which this episode exists.
// Format: media_name (media_name)
func (s VisionEpisodeContextSearchImpl) Media() MediaName {
	return s.MediaValue
}

// Stream name on which this episode exists.
// Format: media_name (media_name)
func (s *VisionEpisodeContextSearchImpl) SetMedia(v MediaName) VisionEpisodeContextSearch {
	if s == nil {
		return nil
	}
	s.MediaValue = v
	return s
}

// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
// sort as by `opened_at`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s VisionEpisodeContextSearchImpl) OpenedAt() UtcMs {
	return s.OpenedAtValue
}

// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
// sort as by `opened_at`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *VisionEpisodeContextSearchImpl) SetOpenedAt(v UtcMs) VisionEpisodeContextSearch {
	if s == nil {
		return nil
	}
	s.OpenedAtValue = v
	return s
}

// This describes the way this episode was updated, whether via an inference node or an API.
// In the case of an inference node, its hostname will be provided.
func (s VisionEpisodeContextSearchImpl) Originator() EpisodeOriginator {
	return s.OriginatorValue
}

// This describes the way this episode was updated, whether via an inference node or an API.
// In the case of an inference node, its hostname will be provided.
func (s *VisionEpisodeContextSearchImpl) SetOriginator(v EpisodeOriginator) VisionEpisodeContextSearch {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*EpisodeOriginatorImpl); ok {
		s.OriginatorValue = impl
	}
	return s
}

// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Format: base64 (base64)
func (s VisionEpisodeContextSearchImpl) Preview() *Base64 {
	return s.PreviewValue
}

// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Format: base64 (base64)
func (s *VisionEpisodeContextSearchImpl) SetPreview(v Base64) VisionEpisodeContextSearch {
	if s == nil {
		return nil
	}
	s.PreviewValue = &v
	return s
}

// The time when the preview of this episode is available.
// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
// for details.
// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s VisionEpisodeContextSearchImpl) PreviewTimestamp() *UtcMs {
	return s.PreviewTimestampValue
}

// The time when the preview of this episode is available.
// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
// for details.
// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *VisionEpisodeContextSearchImpl) SetPreviewTimestamp(v UtcMs) VisionEpisodeContextSearch {
	if s == nil {
		return nil
	}
	s.PreviewTimestampValue = &v
	return s
}

// DVR recording status: fully recorded, not recorded, or partially recorded
func (s VisionEpisodeContextSearchImpl) RecordingStatus() *string {
	return s.RecordingStatusValue
}

// DVR recording status: fully recorded, not recorded, or partially recorded
func (s *VisionEpisodeContextSearchImpl) SetRecordingStatus(v string) VisionEpisodeContextSearch {
	if s == nil {
		return nil
	}
	s.RecordingStatusValue = &v
	return s
}

// This field can be used as indication of the fact that some system have checked and ensured that
// this episode has really started at some time, that may differ from `opened_at`.
// For example video analytics will use this field for the time when this episode was confirmed as confident.
// May be not relevant for television systems.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s VisionEpisodeContextSearchImpl) StartedAt() *UtcMs {
	return s.StartedAtValue
}

// This field can be used as indication of the fact that some system have checked and ensured that
// this episode has really started at some time, that may differ from `opened_at`.
// For example video analytics will use this field for the time when this episode was confirmed as confident.
// May be not relevant for television systems.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *VisionEpisodeContextSearchImpl) SetStartedAt(v UtcMs) VisionEpisodeContextSearch {
	if s == nil {
		return nil
	}
	s.StartedAtValue = &v
	return s
}

// The time of last change of the episode.
// System that processes episodes and can send them to other systems, MUST update this field
// on any changes in this episode.
// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
// this `updated_at` can be used as a sort key for fetching fresh updates.
// Consumer of the episodes can use `updated_at` in the following scenario:
// * fetch all exisiting episodes from the source
// * take biggest `updated_at` from this dataset, it will be T
// * ask source for all episodes with `updated_at > T`
// This algorithm can be used for fetching update stream from the source.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637098611e+12
func (s VisionEpisodeContextSearchImpl) UpdatedAt() UtcMs {
	return s.UpdatedAtValue
}

// The time of last change of the episode.
// System that processes episodes and can send them to other systems, MUST update this field
// on any changes in this episode.
// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
// this `updated_at` can be used as a sort key for fetching fresh updates.
// Consumer of the episodes can use `updated_at` in the following scenario:
// * fetch all exisiting episodes from the source
// * take biggest `updated_at` from this dataset, it will be T
// * ask source for all episodes with `updated_at > T`
// This algorithm can be used for fetching update stream from the source.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637098611e+12
func (s *VisionEpisodeContextSearchImpl) SetUpdatedAt(v UtcMs) VisionEpisodeContextSearch {
	if s == nil {
		return nil
	}
	s.UpdatedAtValue = v
	return s
}

// NewVisionEpisodeFace creates a new VisionEpisodeFace instance
func NewVisionEpisodeFace() VisionEpisodeFace {
	return &VisionEpisodeFaceImpl{}
}

// The reason for closing the episode.
func (s VisionEpisodeFaceImpl) CloseReason() *EpisodeCloseReason {
	return s.CloseReasonValue
}

// The reason for closing the episode.
func (s *VisionEpisodeFaceImpl) SetCloseReason(v EpisodeCloseReason) VisionEpisodeFace {
	if s == nil {
		return nil
	}
	s.CloseReasonValue = &v
	return s
}

// Episode emitter can decide that episode considered closed and will not grow further.
// `closed_at` MUST NOT change, it must be emitted only once.
// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
// of the episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s VisionEpisodeFaceImpl) ClosedAt() *UtcMs {
	return s.ClosedAtValue
}

// Episode emitter can decide that episode considered closed and will not grow further.
// `closed_at` MUST NOT change, it must be emitted only once.
// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
// of the episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *VisionEpisodeFaceImpl) SetClosedAt(v UtcMs) VisionEpisodeFace {
	if s == nil {
		return nil
	}
	s.ClosedAtValue = &v
	return s
}

// Detections associated with this episode
func (s VisionEpisodeFaceImpl) Detections() []VisionDetectedFace {
	if s.DetectionsValue == nil {
		return nil
	}
	result := make([]VisionDetectedFace, len(s.DetectionsValue))
	for i, item := range s.DetectionsValue {
		result[i] = item
	}
	return result
}

// Detections associated with this episode
func (s *VisionEpisodeFaceImpl) SetDetections(v []VisionDetectedFace) VisionEpisodeFace {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*VisionDetectedFaceImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*VisionDetectedFaceImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.DetectionsValue = impl
	}
	return s
}

// The time when the episode appeared in the service relative to the server time.
func (s VisionEpisodeFaceImpl) EpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps {
	return s.EpisodeAppearanceTimestampsValue
}

// The time when the episode appeared in the service relative to the server time.
func (s *VisionEpisodeFaceImpl) SetEpisodeAppearanceTimestamps(v EpisodeAppearanceTimestamps) VisionEpisodeFace {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*EpisodeAppearanceTimestampsImpl); ok {
		s.EpisodeAppearanceTimestampsValue = impl
	}
	return s
}

// Unique identifier of the episode. Must be created by the system that first creates this episode.
// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
// handle very long integers.
// Format: snowflake_id (snowflake_id)
// Examples: 1.722279170848854e+18
func (s VisionEpisodeFaceImpl) EpisodeID() SnowflakeID {
	return s.EpisodeIDValue
}

// Unique identifier of the episode. Must be created by the system that first creates this episode.
// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
// handle very long integers.
// Format: snowflake_id (snowflake_id)
// Examples: 1.722279170848854e+18
func (s *VisionEpisodeFaceImpl) SetEpisodeID(v SnowflakeID) VisionEpisodeFace {
	if s == nil {
		return nil
	}
	s.EpisodeIDValue = v
	return s
}

// Face is detected
func (s VisionEpisodeFaceImpl) EpisodeType() *string {
	return s.EpisodeTypeValue
}

// Face is detected
func (s *VisionEpisodeFaceImpl) SetEpisodeType(v string) VisionEpisodeFace {
	if s == nil {
		return nil
	}
	s.EpisodeTypeValue = &v
	return s
}

// The fingerprint of the detected face
func (s VisionEpisodeFaceImpl) Fingerprint() VisionFaceFingerprint {
	return s.FingerprintValue
}

// The fingerprint of the detected face
func (s *VisionEpisodeFaceImpl) SetFingerprint(v VisionFaceFingerprint) VisionEpisodeFace {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionFaceFingerprintImpl); ok {
		s.FingerprintValue = impl
	}
	return s
}

// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
// Format: base64 (base64)
func (s VisionEpisodeFaceImpl) FramePreview() *Base64 {
	return s.FramePreviewValue
}

// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
// Format: base64 (base64)
func (s *VisionEpisodeFaceImpl) SetFramePreview(v Base64) VisionEpisodeFace {
	if s == nil {
		return nil
	}
	s.FramePreviewValue = &v
	return s
}

// List of matched persons with similarity metric.
// Videoanalytics identification service enriches episode's data and fills this field
// with the list of persons that are similar to the face detected in this episode.
func (s VisionEpisodeFaceImpl) MatchedPersons() []VisionPersonMatch {
	if s.MatchedPersonsValue == nil {
		return nil
	}
	result := make([]VisionPersonMatch, len(s.MatchedPersonsValue))
	for i, item := range s.MatchedPersonsValue {
		result[i] = item
	}
	return result
}

// List of matched persons with similarity metric.
// Videoanalytics identification service enriches episode's data and fills this field
// with the list of persons that are similar to the face detected in this episode.
func (s *VisionEpisodeFaceImpl) SetMatchedPersons(v []VisionPersonMatch) VisionEpisodeFace {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*VisionPersonMatchImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*VisionPersonMatchImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.MatchedPersonsValue = impl
	}
	return s
}

// Stream name on which this episode exists.
// Format: media_name (media_name)
func (s VisionEpisodeFaceImpl) Media() MediaName {
	return s.MediaValue
}

// Stream name on which this episode exists.
// Format: media_name (media_name)
func (s *VisionEpisodeFaceImpl) SetMedia(v MediaName) VisionEpisodeFace {
	if s == nil {
		return nil
	}
	s.MediaValue = v
	return s
}

// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
// sort as by `opened_at`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s VisionEpisodeFaceImpl) OpenedAt() UtcMs {
	return s.OpenedAtValue
}

// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
// sort as by `opened_at`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *VisionEpisodeFaceImpl) SetOpenedAt(v UtcMs) VisionEpisodeFace {
	if s == nil {
		return nil
	}
	s.OpenedAtValue = v
	return s
}

// This describes the way this episode was updated, whether via an inference node or an API.
// In the case of an inference node, its hostname will be provided.
func (s VisionEpisodeFaceImpl) Originator() EpisodeOriginator {
	return s.OriginatorValue
}

// This describes the way this episode was updated, whether via an inference node or an API.
// In the case of an inference node, its hostname will be provided.
func (s *VisionEpisodeFaceImpl) SetOriginator(v EpisodeOriginator) VisionEpisodeFace {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*EpisodeOriginatorImpl); ok {
		s.OriginatorValue = impl
	}
	return s
}

// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Preview contains an image of person's face and has a resolution about 200 x 200 pixels with maximum size about 10 kilobytes.
// Format: base64 (base64)
func (s VisionEpisodeFaceImpl) Preview() Base64 {
	return s.PreviewValue
}

// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Preview contains an image of person's face and has a resolution about 200 x 200 pixels with maximum size about 10 kilobytes.
// Format: base64 (base64)
func (s *VisionEpisodeFaceImpl) SetPreview(v Base64) VisionEpisodeFace {
	if s == nil {
		return nil
	}
	s.PreviewValue = v
	return s
}

// The time when the preview of this episode is available.
// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
// for details.
// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s VisionEpisodeFaceImpl) PreviewTimestamp() *UtcMs {
	return s.PreviewTimestampValue
}

// The time when the preview of this episode is available.
// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
// for details.
// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *VisionEpisodeFaceImpl) SetPreviewTimestamp(v UtcMs) VisionEpisodeFace {
	if s == nil {
		return nil
	}
	s.PreviewTimestampValue = &v
	return s
}

// DVR recording status: fully recorded, not recorded, or partially recorded
func (s VisionEpisodeFaceImpl) RecordingStatus() *string {
	return s.RecordingStatusValue
}

// DVR recording status: fully recorded, not recorded, or partially recorded
func (s *VisionEpisodeFaceImpl) SetRecordingStatus(v string) VisionEpisodeFace {
	if s == nil {
		return nil
	}
	s.RecordingStatusValue = &v
	return s
}

// This field can be used as indication of the fact that some system have checked and ensured that
// this episode has really started at some time, that may differ from `opened_at`.
// For example video analytics will use this field for the time when this episode was confirmed as confident.
// May be not relevant for television systems.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s VisionEpisodeFaceImpl) StartedAt() *UtcMs {
	return s.StartedAtValue
}

// This field can be used as indication of the fact that some system have checked and ensured that
// this episode has really started at some time, that may differ from `opened_at`.
// For example video analytics will use this field for the time when this episode was confirmed as confident.
// May be not relevant for television systems.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *VisionEpisodeFaceImpl) SetStartedAt(v UtcMs) VisionEpisodeFace {
	if s == nil {
		return nil
	}
	s.StartedAtValue = &v
	return s
}

// The time of last change of the episode.
// System that processes episodes and can send them to other systems, MUST update this field
// on any changes in this episode.
// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
// this `updated_at` can be used as a sort key for fetching fresh updates.
// Consumer of the episodes can use `updated_at` in the following scenario:
// * fetch all exisiting episodes from the source
// * take biggest `updated_at` from this dataset, it will be T
// * ask source for all episodes with `updated_at > T`
// This algorithm can be used for fetching update stream from the source.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637098611e+12
func (s VisionEpisodeFaceImpl) UpdatedAt() UtcMs {
	return s.UpdatedAtValue
}

// The time of last change of the episode.
// System that processes episodes and can send them to other systems, MUST update this field
// on any changes in this episode.
// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
// this `updated_at` can be used as a sort key for fetching fresh updates.
// Consumer of the episodes can use `updated_at` in the following scenario:
// * fetch all exisiting episodes from the source
// * take biggest `updated_at` from this dataset, it will be T
// * ask source for all episodes with `updated_at > T`
// This algorithm can be used for fetching update stream from the source.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637098611e+12
func (s *VisionEpisodeFaceImpl) SetUpdatedAt(v UtcMs) VisionEpisodeFace {
	if s == nil {
		return nil
	}
	s.UpdatedAtValue = v
	return s
}

// NewVisionEpisodeHuman creates a new VisionEpisodeHuman instance
func NewVisionEpisodeHuman() VisionEpisodeHuman {
	return &VisionEpisodeHumanImpl{}
}

// The reason for closing the episode.
func (s VisionEpisodeHumanImpl) CloseReason() *EpisodeCloseReason {
	return s.CloseReasonValue
}

// The reason for closing the episode.
func (s *VisionEpisodeHumanImpl) SetCloseReason(v EpisodeCloseReason) VisionEpisodeHuman {
	if s == nil {
		return nil
	}
	s.CloseReasonValue = &v
	return s
}

// Episode emitter can decide that episode considered closed and will not grow further.
// `closed_at` MUST NOT change, it must be emitted only once.
// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
// of the episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s VisionEpisodeHumanImpl) ClosedAt() *UtcMs {
	return s.ClosedAtValue
}

// Episode emitter can decide that episode considered closed and will not grow further.
// `closed_at` MUST NOT change, it must be emitted only once.
// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
// of the episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *VisionEpisodeHumanImpl) SetClosedAt(v UtcMs) VisionEpisodeHuman {
	if s == nil {
		return nil
	}
	s.ClosedAtValue = &v
	return s
}

// Detections associated with this episode
func (s VisionEpisodeHumanImpl) Detections() []VisionDetectedObjectBase {
	if s.DetectionsValue == nil {
		return nil
	}
	result := make([]VisionDetectedObjectBase, len(s.DetectionsValue))
	for i, item := range s.DetectionsValue {
		result[i] = item
	}
	return result
}

// Detections associated with this episode
func (s *VisionEpisodeHumanImpl) SetDetections(v []VisionDetectedObjectBase) VisionEpisodeHuman {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*VisionDetectedObjectBaseImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*VisionDetectedObjectBaseImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.DetectionsValue = impl
	}
	return s
}

// The time when the episode appeared in the service relative to the server time.
func (s VisionEpisodeHumanImpl) EpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps {
	return s.EpisodeAppearanceTimestampsValue
}

// The time when the episode appeared in the service relative to the server time.
func (s *VisionEpisodeHumanImpl) SetEpisodeAppearanceTimestamps(v EpisodeAppearanceTimestamps) VisionEpisodeHuman {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*EpisodeAppearanceTimestampsImpl); ok {
		s.EpisodeAppearanceTimestampsValue = impl
	}
	return s
}

// Unique identifier of the episode. Must be created by the system that first creates this episode.
// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
// handle very long integers.
// Format: snowflake_id (snowflake_id)
// Examples: 1.722279170848854e+18
func (s VisionEpisodeHumanImpl) EpisodeID() SnowflakeID {
	return s.EpisodeIDValue
}

// Unique identifier of the episode. Must be created by the system that first creates this episode.
// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
// handle very long integers.
// Format: snowflake_id (snowflake_id)
// Examples: 1.722279170848854e+18
func (s *VisionEpisodeHumanImpl) SetEpisodeID(v SnowflakeID) VisionEpisodeHuman {
	if s == nil {
		return nil
	}
	s.EpisodeIDValue = v
	return s
}

// Human is detected
func (s VisionEpisodeHumanImpl) EpisodeType() *string {
	return s.EpisodeTypeValue
}

// Human is detected
func (s *VisionEpisodeHumanImpl) SetEpisodeType(v string) VisionEpisodeHuman {
	if s == nil {
		return nil
	}
	s.EpisodeTypeValue = &v
	return s
}

// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
// Format: base64 (base64)
func (s VisionEpisodeHumanImpl) FramePreview() *Base64 {
	return s.FramePreviewValue
}

// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
// Format: base64 (base64)
func (s *VisionEpisodeHumanImpl) SetFramePreview(v Base64) VisionEpisodeHuman {
	if s == nil {
		return nil
	}
	s.FramePreviewValue = &v
	return s
}

// Stream name on which this episode exists.
// Format: media_name (media_name)
func (s VisionEpisodeHumanImpl) Media() MediaName {
	return s.MediaValue
}

// Stream name on which this episode exists.
// Format: media_name (media_name)
func (s *VisionEpisodeHumanImpl) SetMedia(v MediaName) VisionEpisodeHuman {
	if s == nil {
		return nil
	}
	s.MediaValue = v
	return s
}

// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
// sort as by `opened_at`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s VisionEpisodeHumanImpl) OpenedAt() UtcMs {
	return s.OpenedAtValue
}

// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
// sort as by `opened_at`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *VisionEpisodeHumanImpl) SetOpenedAt(v UtcMs) VisionEpisodeHuman {
	if s == nil {
		return nil
	}
	s.OpenedAtValue = v
	return s
}

// This describes the way this episode was updated, whether via an inference node or an API.
// In the case of an inference node, its hostname will be provided.
func (s VisionEpisodeHumanImpl) Originator() EpisodeOriginator {
	return s.OriginatorValue
}

// This describes the way this episode was updated, whether via an inference node or an API.
// In the case of an inference node, its hostname will be provided.
func (s *VisionEpisodeHumanImpl) SetOriginator(v EpisodeOriginator) VisionEpisodeHuman {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*EpisodeOriginatorImpl); ok {
		s.OriginatorValue = impl
	}
	return s
}

// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Format: base64 (base64)
func (s VisionEpisodeHumanImpl) Preview() *Base64 {
	return s.PreviewValue
}

// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Format: base64 (base64)
func (s *VisionEpisodeHumanImpl) SetPreview(v Base64) VisionEpisodeHuman {
	if s == nil {
		return nil
	}
	s.PreviewValue = &v
	return s
}

// The time when the preview of this episode is available.
// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
// for details.
// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s VisionEpisodeHumanImpl) PreviewTimestamp() *UtcMs {
	return s.PreviewTimestampValue
}

// The time when the preview of this episode is available.
// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
// for details.
// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *VisionEpisodeHumanImpl) SetPreviewTimestamp(v UtcMs) VisionEpisodeHuman {
	if s == nil {
		return nil
	}
	s.PreviewTimestampValue = &v
	return s
}

// DVR recording status: fully recorded, not recorded, or partially recorded
func (s VisionEpisodeHumanImpl) RecordingStatus() *string {
	return s.RecordingStatusValue
}

// DVR recording status: fully recorded, not recorded, or partially recorded
func (s *VisionEpisodeHumanImpl) SetRecordingStatus(v string) VisionEpisodeHuman {
	if s == nil {
		return nil
	}
	s.RecordingStatusValue = &v
	return s
}

// This field can be used as indication of the fact that some system have checked and ensured that
// this episode has really started at some time, that may differ from `opened_at`.
// For example video analytics will use this field for the time when this episode was confirmed as confident.
// May be not relevant for television systems.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s VisionEpisodeHumanImpl) StartedAt() *UtcMs {
	return s.StartedAtValue
}

// This field can be used as indication of the fact that some system have checked and ensured that
// this episode has really started at some time, that may differ from `opened_at`.
// For example video analytics will use this field for the time when this episode was confirmed as confident.
// May be not relevant for television systems.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *VisionEpisodeHumanImpl) SetStartedAt(v UtcMs) VisionEpisodeHuman {
	if s == nil {
		return nil
	}
	s.StartedAtValue = &v
	return s
}

// The time of last change of the episode.
// System that processes episodes and can send them to other systems, MUST update this field
// on any changes in this episode.
// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
// this `updated_at` can be used as a sort key for fetching fresh updates.
// Consumer of the episodes can use `updated_at` in the following scenario:
// * fetch all exisiting episodes from the source
// * take biggest `updated_at` from this dataset, it will be T
// * ask source for all episodes with `updated_at > T`
// This algorithm can be used for fetching update stream from the source.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637098611e+12
func (s VisionEpisodeHumanImpl) UpdatedAt() UtcMs {
	return s.UpdatedAtValue
}

// The time of last change of the episode.
// System that processes episodes and can send them to other systems, MUST update this field
// on any changes in this episode.
// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
// this `updated_at` can be used as a sort key for fetching fresh updates.
// Consumer of the episodes can use `updated_at` in the following scenario:
// * fetch all exisiting episodes from the source
// * take biggest `updated_at` from this dataset, it will be T
// * ask source for all episodes with `updated_at > T`
// This algorithm can be used for fetching update stream from the source.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637098611e+12
func (s *VisionEpisodeHumanImpl) SetUpdatedAt(v UtcMs) VisionEpisodeHuman {
	if s == nil {
		return nil
	}
	s.UpdatedAtValue = v
	return s
}

// NewVisionEpisodeQrCode creates a new VisionEpisodeQrCode instance
func NewVisionEpisodeQrCode() VisionEpisodeQrCode {
	return &VisionEpisodeQrCodeImpl{}
}

// The reason for closing the episode.
func (s VisionEpisodeQrCodeImpl) CloseReason() *EpisodeCloseReason {
	return s.CloseReasonValue
}

// The reason for closing the episode.
func (s *VisionEpisodeQrCodeImpl) SetCloseReason(v EpisodeCloseReason) VisionEpisodeQrCode {
	if s == nil {
		return nil
	}
	s.CloseReasonValue = &v
	return s
}

// Episode emitter can decide that episode considered closed and will not grow further.
// `closed_at` MUST NOT change, it must be emitted only once.
// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
// of the episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s VisionEpisodeQrCodeImpl) ClosedAt() *UtcMs {
	return s.ClosedAtValue
}

// Episode emitter can decide that episode considered closed and will not grow further.
// `closed_at` MUST NOT change, it must be emitted only once.
// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
// of the episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *VisionEpisodeQrCodeImpl) SetClosedAt(v UtcMs) VisionEpisodeQrCode {
	if s == nil {
		return nil
	}
	s.ClosedAtValue = &v
	return s
}

// The time when the episode appeared in the service relative to the server time.
func (s VisionEpisodeQrCodeImpl) EpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps {
	return s.EpisodeAppearanceTimestampsValue
}

// The time when the episode appeared in the service relative to the server time.
func (s *VisionEpisodeQrCodeImpl) SetEpisodeAppearanceTimestamps(v EpisodeAppearanceTimestamps) VisionEpisodeQrCode {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*EpisodeAppearanceTimestampsImpl); ok {
		s.EpisodeAppearanceTimestampsValue = impl
	}
	return s
}

// Unique identifier of the episode. Must be created by the system that first creates this episode.
// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
// handle very long integers.
// Format: snowflake_id (snowflake_id)
// Examples: 1.722279170848854e+18
func (s VisionEpisodeQrCodeImpl) EpisodeID() SnowflakeID {
	return s.EpisodeIDValue
}

// Unique identifier of the episode. Must be created by the system that first creates this episode.
// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
// handle very long integers.
// Format: snowflake_id (snowflake_id)
// Examples: 1.722279170848854e+18
func (s *VisionEpisodeQrCodeImpl) SetEpisodeID(v SnowflakeID) VisionEpisodeQrCode {
	if s == nil {
		return nil
	}
	s.EpisodeIDValue = v
	return s
}

// QR-code is detected
func (s VisionEpisodeQrCodeImpl) EpisodeType() *string {
	return s.EpisodeTypeValue
}

// QR-code is detected
func (s *VisionEpisodeQrCodeImpl) SetEpisodeType(v string) VisionEpisodeQrCode {
	if s == nil {
		return nil
	}
	s.EpisodeTypeValue = &v
	return s
}

// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
// Format: base64 (base64)
func (s VisionEpisodeQrCodeImpl) FramePreview() *Base64 {
	return s.FramePreviewValue
}

// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
// Format: base64 (base64)
func (s *VisionEpisodeQrCodeImpl) SetFramePreview(v Base64) VisionEpisodeQrCode {
	if s == nil {
		return nil
	}
	s.FramePreviewValue = &v
	return s
}

// Stream name on which this episode exists.
// Format: media_name (media_name)
func (s VisionEpisodeQrCodeImpl) Media() MediaName {
	return s.MediaValue
}

// Stream name on which this episode exists.
// Format: media_name (media_name)
func (s *VisionEpisodeQrCodeImpl) SetMedia(v MediaName) VisionEpisodeQrCode {
	if s == nil {
		return nil
	}
	s.MediaValue = v
	return s
}

// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
// sort as by `opened_at`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s VisionEpisodeQrCodeImpl) OpenedAt() UtcMs {
	return s.OpenedAtValue
}

// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
// sort as by `opened_at`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *VisionEpisodeQrCodeImpl) SetOpenedAt(v UtcMs) VisionEpisodeQrCode {
	if s == nil {
		return nil
	}
	s.OpenedAtValue = v
	return s
}

// This describes the way this episode was updated, whether via an inference node or an API.
// In the case of an inference node, its hostname will be provided.
func (s VisionEpisodeQrCodeImpl) Originator() EpisodeOriginator {
	return s.OriginatorValue
}

// This describes the way this episode was updated, whether via an inference node or an API.
// In the case of an inference node, its hostname will be provided.
func (s *VisionEpisodeQrCodeImpl) SetOriginator(v EpisodeOriginator) VisionEpisodeQrCode {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*EpisodeOriginatorImpl); ok {
		s.OriginatorValue = impl
	}
	return s
}

// Raw data extracted from QR-code
// Example: WIFI:T:WPA;S:MyOfficeWiFi;P:Mypassword;H:;
func (s VisionEpisodeQrCodeImpl) Payload() *string {
	return s.PayloadValue
}

// Raw data extracted from QR-code
// Example: WIFI:T:WPA;S:MyOfficeWiFi;P:Mypassword;H:;
func (s *VisionEpisodeQrCodeImpl) SetPayload(v string) VisionEpisodeQrCode {
	if s == nil {
		return nil
	}
	s.PayloadValue = &v
	return s
}

// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Format: base64 (base64)
func (s VisionEpisodeQrCodeImpl) Preview() *Base64 {
	return s.PreviewValue
}

// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Format: base64 (base64)
func (s *VisionEpisodeQrCodeImpl) SetPreview(v Base64) VisionEpisodeQrCode {
	if s == nil {
		return nil
	}
	s.PreviewValue = &v
	return s
}

// The time when the preview of this episode is available.
// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
// for details.
// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s VisionEpisodeQrCodeImpl) PreviewTimestamp() *UtcMs {
	return s.PreviewTimestampValue
}

// The time when the preview of this episode is available.
// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
// for details.
// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *VisionEpisodeQrCodeImpl) SetPreviewTimestamp(v UtcMs) VisionEpisodeQrCode {
	if s == nil {
		return nil
	}
	s.PreviewTimestampValue = &v
	return s
}

// DVR recording status: fully recorded, not recorded, or partially recorded
func (s VisionEpisodeQrCodeImpl) RecordingStatus() *string {
	return s.RecordingStatusValue
}

// DVR recording status: fully recorded, not recorded, or partially recorded
func (s *VisionEpisodeQrCodeImpl) SetRecordingStatus(v string) VisionEpisodeQrCode {
	if s == nil {
		return nil
	}
	s.RecordingStatusValue = &v
	return s
}

// This field can be used as indication of the fact that some system have checked and ensured that
// this episode has really started at some time, that may differ from `opened_at`.
// For example video analytics will use this field for the time when this episode was confirmed as confident.
// May be not relevant for television systems.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s VisionEpisodeQrCodeImpl) StartedAt() *UtcMs {
	return s.StartedAtValue
}

// This field can be used as indication of the fact that some system have checked and ensured that
// this episode has really started at some time, that may differ from `opened_at`.
// For example video analytics will use this field for the time when this episode was confirmed as confident.
// May be not relevant for television systems.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *VisionEpisodeQrCodeImpl) SetStartedAt(v UtcMs) VisionEpisodeQrCode {
	if s == nil {
		return nil
	}
	s.StartedAtValue = &v
	return s
}

// The time of last change of the episode.
// System that processes episodes and can send them to other systems, MUST update this field
// on any changes in this episode.
// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
// this `updated_at` can be used as a sort key for fetching fresh updates.
// Consumer of the episodes can use `updated_at` in the following scenario:
// * fetch all exisiting episodes from the source
// * take biggest `updated_at` from this dataset, it will be T
// * ask source for all episodes with `updated_at > T`
// This algorithm can be used for fetching update stream from the source.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637098611e+12
func (s VisionEpisodeQrCodeImpl) UpdatedAt() UtcMs {
	return s.UpdatedAtValue
}

// The time of last change of the episode.
// System that processes episodes and can send them to other systems, MUST update this field
// on any changes in this episode.
// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
// this `updated_at` can be used as a sort key for fetching fresh updates.
// Consumer of the episodes can use `updated_at` in the following scenario:
// * fetch all exisiting episodes from the source
// * take biggest `updated_at` from this dataset, it will be T
// * ask source for all episodes with `updated_at > T`
// This algorithm can be used for fetching update stream from the source.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637098611e+12
func (s *VisionEpisodeQrCodeImpl) SetUpdatedAt(v UtcMs) VisionEpisodeQrCode {
	if s == nil {
		return nil
	}
	s.UpdatedAtValue = v
	return s
}

// NewVisionEpisodeVehicle creates a new VisionEpisodeVehicle instance
func NewVisionEpisodeVehicle() VisionEpisodeVehicle {
	return &VisionEpisodeVehicleImpl{}
}

// The reason for closing the episode.
func (s VisionEpisodeVehicleImpl) CloseReason() *EpisodeCloseReason {
	return s.CloseReasonValue
}

// The reason for closing the episode.
func (s *VisionEpisodeVehicleImpl) SetCloseReason(v EpisodeCloseReason) VisionEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.CloseReasonValue = &v
	return s
}

// Episode emitter can decide that episode considered closed and will not grow further.
// `closed_at` MUST NOT change, it must be emitted only once.
// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
// of the episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s VisionEpisodeVehicleImpl) ClosedAt() *UtcMs {
	return s.ClosedAtValue
}

// Episode emitter can decide that episode considered closed and will not grow further.
// `closed_at` MUST NOT change, it must be emitted only once.
// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
// of the episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *VisionEpisodeVehicleImpl) SetClosedAt(v UtcMs) VisionEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.ClosedAtValue = &v
	return s
}

// Detections associated with this episode
func (s VisionEpisodeVehicleImpl) Detections() []any {
	return s.DetectionsValue
}

// Detections associated with this episode
func (s *VisionEpisodeVehicleImpl) SetDetections(v []any) VisionEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.DetectionsValue = v
	return s
}

// The time when the episode appeared in the service relative to the server time.
func (s VisionEpisodeVehicleImpl) EpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps {
	return s.EpisodeAppearanceTimestampsValue
}

// The time when the episode appeared in the service relative to the server time.
func (s *VisionEpisodeVehicleImpl) SetEpisodeAppearanceTimestamps(v EpisodeAppearanceTimestamps) VisionEpisodeVehicle {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*EpisodeAppearanceTimestampsImpl); ok {
		s.EpisodeAppearanceTimestampsValue = impl
	}
	return s
}

// Unique identifier of the episode. Must be created by the system that first creates this episode.
// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
// handle very long integers.
// Format: snowflake_id (snowflake_id)
// Examples: 1.722279170848854e+18
func (s VisionEpisodeVehicleImpl) EpisodeID() SnowflakeID {
	return s.EpisodeIDValue
}

// Unique identifier of the episode. Must be created by the system that first creates this episode.
// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
// handle very long integers.
// Format: snowflake_id (snowflake_id)
// Examples: 1.722279170848854e+18
func (s *VisionEpisodeVehicleImpl) SetEpisodeID(v SnowflakeID) VisionEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.EpisodeIDValue = v
	return s
}

// Vehicle is detected
func (s VisionEpisodeVehicleImpl) EpisodeType() *string {
	return s.EpisodeTypeValue
}

// Vehicle is detected
func (s *VisionEpisodeVehicleImpl) SetEpisodeType(v string) VisionEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.EpisodeTypeValue = &v
	return s
}

// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
// Format: base64 (base64)
func (s VisionEpisodeVehicleImpl) FramePreview() *Base64 {
	return s.FramePreviewValue
}

// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
// Format: base64 (base64)
func (s *VisionEpisodeVehicleImpl) SetFramePreview(v Base64) VisionEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.FramePreviewValue = &v
	return s
}

// Indicates if no license plate is detected on this vehicle
func (s VisionEpisodeVehicleImpl) LicensePlateMissing() *bool {
	return s.LicensePlateMissingValue
}

// Indicates if no license plate is detected on this vehicle
func (s *VisionEpisodeVehicleImpl) SetLicensePlateMissing(v bool) VisionEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.LicensePlateMissingValue = &v
	return s
}

// Recognized vehicle's license plate number
func (s VisionEpisodeVehicleImpl) LicensePlateText() *string {
	return s.LicensePlateTextValue
}

// Recognized vehicle's license plate number
func (s *VisionEpisodeVehicleImpl) SetLicensePlateText(v string) VisionEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.LicensePlateTextValue = &v
	return s
}

// Stream name on which this episode exists.
// Format: media_name (media_name)
func (s VisionEpisodeVehicleImpl) Media() MediaName {
	return s.MediaValue
}

// Stream name on which this episode exists.
// Format: media_name (media_name)
func (s *VisionEpisodeVehicleImpl) SetMedia(v MediaName) VisionEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.MediaValue = v
	return s
}

// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
// sort as by `opened_at`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s VisionEpisodeVehicleImpl) OpenedAt() UtcMs {
	return s.OpenedAtValue
}

// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
// sort as by `opened_at`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *VisionEpisodeVehicleImpl) SetOpenedAt(v UtcMs) VisionEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.OpenedAtValue = v
	return s
}

// This describes the way this episode was updated, whether via an inference node or an API.
// In the case of an inference node, its hostname will be provided.
func (s VisionEpisodeVehicleImpl) Originator() EpisodeOriginator {
	return s.OriginatorValue
}

// This describes the way this episode was updated, whether via an inference node or an API.
// In the case of an inference node, its hostname will be provided.
func (s *VisionEpisodeVehicleImpl) SetOriginator(v EpisodeOriginator) VisionEpisodeVehicle {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*EpisodeOriginatorImpl); ok {
		s.OriginatorValue = impl
	}
	return s
}

// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Preview contains an image of vehicle's license plate and has a resolution about 160 x 64 pixels with maximum size about 10 kilobytes.
// Format: base64 (base64)
func (s VisionEpisodeVehicleImpl) Preview() Base64 {
	return s.PreviewValue
}

// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Preview contains an image of vehicle's license plate and has a resolution about 160 x 64 pixels with maximum size about 10 kilobytes.
// Format: base64 (base64)
func (s *VisionEpisodeVehicleImpl) SetPreview(v Base64) VisionEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.PreviewValue = v
	return s
}

// The time when the preview of this episode is available.
// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
// for details.
// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s VisionEpisodeVehicleImpl) PreviewTimestamp() *UtcMs {
	return s.PreviewTimestampValue
}

// The time when the preview of this episode is available.
// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
// for details.
// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *VisionEpisodeVehicleImpl) SetPreviewTimestamp(v UtcMs) VisionEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.PreviewTimestampValue = &v
	return s
}

// DVR recording status: fully recorded, not recorded, or partially recorded
func (s VisionEpisodeVehicleImpl) RecordingStatus() *string {
	return s.RecordingStatusValue
}

// DVR recording status: fully recorded, not recorded, or partially recorded
func (s *VisionEpisodeVehicleImpl) SetRecordingStatus(v string) VisionEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.RecordingStatusValue = &v
	return s
}

// This field can be used as indication of the fact that some system have checked and ensured that
// this episode has really started at some time, that may differ from `opened_at`.
// For example video analytics will use this field for the time when this episode was confirmed as confident.
// May be not relevant for television systems.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s VisionEpisodeVehicleImpl) StartedAt() *UtcMs {
	return s.StartedAtValue
}

// This field can be used as indication of the fact that some system have checked and ensured that
// this episode has really started at some time, that may differ from `opened_at`.
// For example video analytics will use this field for the time when this episode was confirmed as confident.
// May be not relevant for television systems.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *VisionEpisodeVehicleImpl) SetStartedAt(v UtcMs) VisionEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.StartedAtValue = &v
	return s
}

// The time of last change of the episode.
// System that processes episodes and can send them to other systems, MUST update this field
// on any changes in this episode.
// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
// this `updated_at` can be used as a sort key for fetching fresh updates.
// Consumer of the episodes can use `updated_at` in the following scenario:
// * fetch all exisiting episodes from the source
// * take biggest `updated_at` from this dataset, it will be T
// * ask source for all episodes with `updated_at > T`
// This algorithm can be used for fetching update stream from the source.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637098611e+12
func (s VisionEpisodeVehicleImpl) UpdatedAt() UtcMs {
	return s.UpdatedAtValue
}

// The time of last change of the episode.
// System that processes episodes and can send them to other systems, MUST update this field
// on any changes in this episode.
// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
// this `updated_at` can be used as a sort key for fetching fresh updates.
// Consumer of the episodes can use `updated_at` in the following scenario:
// * fetch all exisiting episodes from the source
// * take biggest `updated_at` from this dataset, it will be T
// * ask source for all episodes with `updated_at > T`
// This algorithm can be used for fetching update stream from the source.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637098611e+12
func (s *VisionEpisodeVehicleImpl) SetUpdatedAt(v UtcMs) VisionEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.UpdatedAtValue = v
	return s
}

// Emergency type of the vehicle.
func (s VisionEpisodeVehicleImpl) VehicleEmergencySubtype() *VisionVehicleEmergencySubtype {
	return s.VehicleEmergencySubtypeValue
}

// Emergency type of the vehicle.
func (s *VisionEpisodeVehicleImpl) SetVehicleEmergencySubtype(v VisionVehicleEmergencySubtype) VisionEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.VehicleEmergencySubtypeValue = &v
	return s
}

// Shows from which side the vehicle was detected.
func (s VisionEpisodeVehicleImpl) VehicleFacingSide() *VisionVehicleFacingSide {
	return s.VehicleFacingSideValue
}

// Shows from which side the vehicle was detected.
func (s *VisionEpisodeVehicleImpl) SetVehicleFacingSide(v VisionVehicleFacingSide) VisionEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.VehicleFacingSideValue = &v
	return s
}

// The purpose of the vehicle, e.g. emergency or regular.
func (s VisionEpisodeVehicleImpl) VehiclePurpose() *VisionVehiclePurpose {
	return s.VehiclePurposeValue
}

// The purpose of the vehicle, e.g. emergency or regular.
func (s *VisionEpisodeVehicleImpl) SetVehiclePurpose(v VisionVehiclePurpose) VisionEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.VehiclePurposeValue = &v
	return s
}

// NewVisionFaceAttributes creates a new VisionFaceAttributes instance
func NewVisionFaceAttributes() VisionFaceAttributes {
	return &VisionFaceAttributesImpl{}
}

// The fingerprint of the detected face
func (s VisionFaceAttributesImpl) Fingerprint() VisionFaceFingerprint {
	return s.FingerprintValue
}

// The fingerprint of the detected face
func (s *VisionFaceAttributesImpl) SetFingerprint(v VisionFaceFingerprint) VisionFaceAttributes {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionFaceFingerprintImpl); ok {
		s.FingerprintValue = impl
	}
	return s
}

// NewVisionFaceFingerprint creates a new VisionFaceFingerprint instance
func NewVisionFaceFingerprint() VisionFaceFingerprint {
	return &VisionFaceFingerprintImpl{}
}

// Base64 encoded representation of the fingerprint
// Format: base64 (base64)
func (s VisionFaceFingerprintImpl) Data() Base64 {
	return s.DataValue
}

// Base64 encoded representation of the fingerprint
// Format: base64 (base64)
func (s *VisionFaceFingerprintImpl) SetData(v Base64) VisionFaceFingerprint {
	if s == nil {
		return nil
	}
	s.DataValue = v
	return s
}

// Version identifier of the fingerprint's data. The version is assigned automatically.
// Fingerprints of different versions cannot be compared to each other.
// Examples: aabbccdd, c6ba4246
func (s VisionFaceFingerprintImpl) Version() string {
	return s.VersionValue
}

// Version identifier of the fingerprint's data. The version is assigned automatically.
// Fingerprints of different versions cannot be compared to each other.
// Examples: aabbccdd, c6ba4246
func (s *VisionFaceFingerprintImpl) SetVersion(v string) VisionFaceFingerprint {
	if s == nil {
		return nil
	}
	s.VersionValue = v
	return s
}

// NewVisionImageAttributes creates a new VisionImageAttributes instance
func NewVisionImageAttributes() VisionImageAttributes {
	return &VisionImageAttributesImpl{}
}

// Base64-encoded image data
// Format: base64 (base64)
func (s VisionImageAttributesImpl) Data() Base64 {
	return s.DataValue
}

// Base64-encoded image data
// Format: base64 (base64)
func (s *VisionImageAttributesImpl) SetData(v Base64) VisionImageAttributes {
	if s == nil {
		return nil
	}
	s.DataValue = v
	return s
}

// MIME type of the image
func (s VisionImageAttributesImpl) MimeType() *VisionImageMimetype {
	return s.MimeTypeValue
}

// MIME type of the image
func (s *VisionImageAttributesImpl) SetMimeType(v VisionImageMimetype) VisionImageAttributes {
	if s == nil {
		return nil
	}
	s.MimeTypeValue = &v
	return s
}

// Checksum of this image
// Format: hexbinary (hexbinary)
func (s VisionImageAttributesImpl) Sha256() *Hexbinary {
	return s.Sha256Value
}

// Checksum of this image
// Format: hexbinary (hexbinary)
func (s *VisionImageAttributesImpl) SetSha256(v Hexbinary) VisionImageAttributes {
	if s == nil {
		return nil
	}
	s.Sha256Value = &v
	return s
}

// NewVisionLicensePlateAttributes creates a new VisionLicensePlateAttributes instance
func NewVisionLicensePlateAttributes() VisionLicensePlateAttributes {
	return &VisionLicensePlateAttributesImpl{}
}

// Shows from which side the vehicle was detected.
func (s VisionLicensePlateAttributesImpl) FacingSide() *VisionVehicleFacingSide {
	return s.FacingSideValue
}

// Shows from which side the vehicle was detected.
func (s *VisionLicensePlateAttributesImpl) SetFacingSide(v VisionVehicleFacingSide) VisionLicensePlateAttributes {
	if s == nil {
		return nil
	}
	s.FacingSideValue = &v
	return s
}

// Recognized vehicle's license plate number
func (s VisionLicensePlateAttributesImpl) PlateText() *string {
	return s.PlateTextValue
}

// Recognized vehicle's license plate number
func (s *VisionLicensePlateAttributesImpl) SetPlateText(v string) VisionLicensePlateAttributes {
	if s == nil {
		return nil
	}
	s.PlateTextValue = &v
	return s
}

// NewVisionPerson creates a new VisionPerson instance
func NewVisionPerson() VisionPerson {
	return &VisionPersonImpl{}
}

// When this person was marked as deleted
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637095014573e+12
func (s VisionPersonImpl) DeletedAt() *UtcMs {
	return s.DeletedAtValue
}

// When this person was marked as deleted
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637095014573e+12
func (s *VisionPersonImpl) SetDeletedAt(v UtcMs) VisionPerson {
	if s == nil {
		return nil
	}
	s.DeletedAtValue = &v
	return s
}

// Identifier of the person in the external system.
// Use it when supplying the recognition results further into the external system
// (e.g. for access level check) if the person identifiers in the external system
// are different from the ones in Flussonic Identification database.
// This field may contain `null` when video analytics detects a new person
// which explicitly has no association in the external system (i.e. if `originator=identification_service`).
// Examples: dedcc8e8
func (s VisionPersonImpl) ExternalID() *string {
	return s.ExternalIDValue
}

// Identifier of the person in the external system.
// Use it when supplying the recognition results further into the external system
// (e.g. for access level check) if the person identifiers in the external system
// are different from the ones in Flussonic Identification database.
// This field may contain `null` when video analytics detects a new person
// which explicitly has no association in the external system (i.e. if `originator=identification_service`).
// Examples: dedcc8e8
func (s *VisionPersonImpl) SetExternalID(v string) VisionPerson {
	if s == nil {
		return nil
	}
	s.ExternalIDValue = &v
	return s
}

// Digital fingerprints of the person.
// Videoanalytics makes digital fingerprint of the person
// using uploaded photos or videostreams being processed
func (s VisionPersonImpl) Fingerprints() []VisionFaceFingerprint {
	if s.FingerprintsValue == nil {
		return nil
	}
	result := make([]VisionFaceFingerprint, len(s.FingerprintsValue))
	for i, item := range s.FingerprintsValue {
		result[i] = item
	}
	return result
}

// Digital fingerprints of the person.
// Videoanalytics makes digital fingerprint of the person
// using uploaded photos or videostreams being processed
func (s *VisionPersonImpl) SetFingerprints(v []VisionFaceFingerprint) VisionPerson {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*VisionFaceFingerprintImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*VisionFaceFingerprintImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.FingerprintsValue = impl
	}
	return s
}

// Indicates the way this person was created:
// manually via an api or automatically in the identification service.
func (s VisionPersonImpl) Originator() VisionPersonOriginator {
	return s.OriginatorValue
}

// Indicates the way this person was created:
// manually via an api or automatically in the identification service.
func (s *VisionPersonImpl) SetOriginator(v VisionPersonOriginator) VisionPerson {
	if s == nil {
		return nil
	}
	s.OriginatorValue = v
	return s
}

// Identifier of the person
// Format: snowflake_id (snowflake_id)
// Examples: 7.036001172460667e+18
func (s VisionPersonImpl) PersonID() SnowflakeID {
	return s.PersonIDValue
}

// Identifier of the person
// Format: snowflake_id (snowflake_id)
// Examples: 7.036001172460667e+18
func (s *VisionPersonImpl) SetPersonID(v SnowflakeID) VisionPerson {
	if s == nil {
		return nil
	}
	s.PersonIDValue = v
	return s
}

// Person's photos. External system uploads images
// which are being processed by videoanalytics
// to get digital fingerprint of the person
func (s VisionPersonImpl) Photos() []VisionImageAttributes {
	if s.PhotosValue == nil {
		return nil
	}
	result := make([]VisionImageAttributes, len(s.PhotosValue))
	for i, item := range s.PhotosValue {
		result[i] = item
	}
	return result
}

// Person's photos. External system uploads images
// which are being processed by videoanalytics
// to get digital fingerprint of the person
func (s *VisionPersonImpl) SetPhotos(v []VisionImageAttributes) VisionPerson {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*VisionImageAttributesImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*VisionImageAttributesImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.PhotosValue = impl
	}
	return s
}

// When this person was last updated
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637034282845e+12
func (s VisionPersonImpl) UpdatedAt() UtcMs {
	return s.UpdatedAtValue
}

// When this person was last updated
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637034282845e+12
func (s *VisionPersonImpl) SetUpdatedAt(v UtcMs) VisionPerson {
	if s == nil {
		return nil
	}
	s.UpdatedAtValue = v
	return s
}

// NewVisionPersonMatch creates a new VisionPersonMatch instance
func NewVisionPersonMatch() VisionPersonMatch {
	return &VisionPersonMatchImpl{}
}

// Score of the match with person. 1.0 means absolute match
func (s VisionPersonMatchImpl) MatchScore() float64 {
	return s.MatchScoreValue
}

// Score of the match with person. 1.0 means absolute match
func (s *VisionPersonMatchImpl) SetMatchScore(v float64) VisionPersonMatch {
	if s == nil {
		return nil
	}
	s.MatchScoreValue = v
	return s
}

// Matched person
func (s VisionPersonMatchImpl) Person() VisionPerson {
	return s.PersonValue
}

// Matched person
func (s *VisionPersonMatchImpl) SetPerson(v VisionPerson) VisionPersonMatch {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionPersonImpl); ok {
		s.PersonValue = impl
	}
	return s
}

// NewVisionPersonsList creates a new VisionPersonsList instance
func NewVisionPersonsList() VisionPersonsList {
	return &VisionPersonsListImpl{}
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s VisionPersonsListImpl) EstimatedCount() *int {
	return s.EstimatedCountValue
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s *VisionPersonsListImpl) SetEstimatedCount(v int) VisionPersonsList {
	if s == nil {
		return nil
	}
	s.EstimatedCountValue = &v
	return s
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s VisionPersonsListImpl) Next() *string {
	return s.NextValue
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s *VisionPersonsListImpl) SetNext(v string) VisionPersonsList {
	if s == nil {
		return nil
	}
	s.NextValue = &v
	return s
}

// List of fetched persons according to the query parameters.
func (s VisionPersonsListImpl) Persons() []VisionPerson {
	if s.PersonsValue == nil {
		return nil
	}
	result := make([]VisionPerson, len(s.PersonsValue))
	for i, item := range s.PersonsValue {
		result[i] = item
	}
	return result
}

// List of fetched persons according to the query parameters.
func (s *VisionPersonsListImpl) SetPersons(v []VisionPerson) VisionPersonsList {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*VisionPersonImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*VisionPersonImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.PersonsValue = impl
	}
	return s
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s VisionPersonsListImpl) Prev() *string {
	return s.PrevValue
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s *VisionPersonsListImpl) SetPrev(v string) VisionPersonsList {
	if s == nil {
		return nil
	}
	s.PrevValue = &v
	return s
}

// An object with a list of different timings measured during this API call.
func (s VisionPersonsListImpl) Timing() any {
	return s.TimingValue
}

// An object with a list of different timings measured during this API call.
func (s *VisionPersonsListImpl) SetTiming(v any) VisionPersonsList {
	if s == nil {
		return nil
	}
	s.TimingValue = v
	return s
}

// Collection returns the collection items from VisionPersonsList
func (s VisionPersonsListImpl) Collection() []VisionPerson {
	return s.Persons()
}

// NewVisionPoint creates a new VisionPoint instance
func NewVisionPoint() VisionPoint {
	return &VisionPointImpl{}
}

// X coordinate. Fraction of full frame width
// Examples: 0.54, 0.78
func (s VisionPointImpl) X() float64 {
	return s.XValue
}

// X coordinate. Fraction of full frame width
// Examples: 0.54, 0.78
func (s *VisionPointImpl) SetX(v float64) VisionPoint {
	if s == nil {
		return nil
	}
	s.XValue = v
	return s
}

// Y coordinate. Fraction of full frame height
// Examples: 0.12, 0.38
func (s VisionPointImpl) Y() float64 {
	return s.YValue
}

// Y coordinate. Fraction of full frame height
// Examples: 0.12, 0.38
func (s *VisionPointImpl) SetY(v float64) VisionPoint {
	if s == nil {
		return nil
	}
	s.YValue = v
	return s
}

// NewVisionSpec creates a new VisionSpec instance
func NewVisionSpec() VisionSpec {
	return &VisionSpecImpl{}
}

// The algorithm used for video analytics.
// Example: faces
func (s VisionSpecImpl) Alg() *VisionSpecAlg {
	return s.AlgValue
}

// The algorithm used for video analytics.
// Example: faces
func (s *VisionSpecImpl) SetAlg(v VisionSpecAlg) VisionSpec {
	if s == nil {
		return nil
	}
	s.AlgValue = &v
	return s
}

// This parameter allows you to select specific polygonal area(s) for detection.
// By default, it is empty, and the recognition system searches over the entire camera field of view.
// Each area is specified as a sequence of comma-separated coordinates of vertices of the polygon: `x0,y0,x1,y1,x2,y2,...`.
// The vertices are specified in a counter-clockwise direction. Multiple areas are separated by `:`.
func (s VisionSpecImpl) Areas() *string {
	return s.AreasValue
}

// This parameter allows you to select specific polygonal area(s) for detection.
// By default, it is empty, and the recognition system searches over the entire camera field of view.
// Each area is specified as a sequence of comma-separated coordinates of vertices of the polygon: `x0,y0,x1,y1,x2,y2,...`.
// The vertices are specified in a counter-clockwise direction. Multiple areas are separated by `:`.
func (s *VisionSpecImpl) SetAreas(v string) VisionSpec {
	if s == nil {
		return nil
	}
	s.AreasValue = &v
	return s
}

// Configuration of videoanalytics modules.
// This configuration supersedes `alg` and `areas` parameters.
// If this field is specified, values of `alg` and `areas` fields are being ignored.
func (s VisionSpecImpl) Detectors() []VisionDetectorConfig {
	if s.DetectorsValue == nil {
		return nil
	}
	result := make([]VisionDetectorConfig, len(s.DetectorsValue))
	for i, item := range s.DetectorsValue {
		result[i] = item
	}
	return result
}

// Configuration of videoanalytics modules.
// This configuration supersedes `alg` and `areas` parameters.
// If this field is specified, values of `alg` and `areas` fields are being ignored.
func (s *VisionSpecImpl) SetDetectors(v []VisionDetectorConfig) VisionSpec {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*VisionDetectorConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*VisionDetectorConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.DetectorsValue = impl
	}
	return s
}

// NewVisionVehicleAttributes creates a new VisionVehicleAttributes instance
func NewVisionVehicleAttributes() VisionVehicleAttributes {
	return &VisionVehicleAttributesImpl{}
}

// Indicates if no license plate is detected on this vehicle
func (s VisionVehicleAttributesImpl) LicensePlateMissing() *bool {
	return s.LicensePlateMissingValue
}

// Indicates if no license plate is detected on this vehicle
func (s *VisionVehicleAttributesImpl) SetLicensePlateMissing(v bool) VisionVehicleAttributes {
	if s == nil {
		return nil
	}
	s.LicensePlateMissingValue = &v
	return s
}

// The purpose of the vehicle, e.g. emergency or regular.
func (s VisionVehicleAttributesImpl) Purpose() *VisionVehiclePurpose {
	return s.PurposeValue
}

// The purpose of the vehicle, e.g. emergency or regular.
func (s *VisionVehicleAttributesImpl) SetPurpose(v VisionVehiclePurpose) VisionVehicleAttributes {
	if s == nil {
		return nil
	}
	s.PurposeValue = &v
	return s
}

// NewWatcherAgentConfig creates a new WatcherAgentConfig instance
func NewWatcherAgentConfig() WatcherAgentConfig {
	return &WatcherAgentConfigImpl{}
}

// Agent identifier
// Example: 1234567
func (s WatcherAgentConfigImpl) ID() *string {
	return s.IDValue
}

// Agent identifier
// Example: 1234567
func (s *WatcherAgentConfigImpl) SetID(v string) WatcherAgentConfig {
	if s == nil {
		return nil
	}
	s.IDValue = &v
	return s
}

// Agent authentication key.
func (s WatcherAgentConfigImpl) Key() *string {
	return s.KeyValue
}

// Agent authentication key.
func (s *WatcherAgentConfigImpl) SetKey(v string) WatcherAgentConfig {
	if s == nil {
		return nil
	}
	s.KeyValue = &v
	return s
}

// Agents's metrics and other statistical information.
func (s WatcherAgentConfigImpl) Stats() WatcherAgentStats {
	return s.StatsValue
}

// Agents's metrics and other statistical information.
func (s *WatcherAgentConfigImpl) SetStats(v WatcherAgentStats) WatcherAgentConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*WatcherAgentStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// NewWatcherAgentControlConnection creates a new WatcherAgentControlConnection instance
func NewWatcherAgentControlConnection() WatcherAgentControlConnection {
	return &WatcherAgentControlConnectionImpl{}
}

// A flag showing if Agent is connected at the moment of the request.
func (s WatcherAgentControlConnectionImpl) Alive() *bool {
	return s.AliveValue
}

// A flag showing if Agent is connected at the moment of the request.
func (s *WatcherAgentControlConnectionImpl) SetAlive(v bool) WatcherAgentControlConnection {
	if s == nil {
		return nil
	}
	s.AliveValue = &v
	return s
}

// A number of bytes received from the server by Agent since `opened_at`.
// Format: bytes (bytes)
// Example: 40000
func (s WatcherAgentControlConnectionImpl) BytesFromServer() *Bytes {
	return s.BytesFromServerValue
}

// A number of bytes received from the server by Agent since `opened_at`.
// Format: bytes (bytes)
// Example: 40000
func (s *WatcherAgentControlConnectionImpl) SetBytesFromServer(v Bytes) WatcherAgentControlConnection {
	if s == nil {
		return nil
	}
	s.BytesFromServerValue = &v
	return s
}

// A number of bytes sent to the server by Agent since `opened_at`.
// Format: bytes (bytes)
// Example: 4e+11
func (s WatcherAgentControlConnectionImpl) BytesToServer() *Bytes {
	return s.BytesToServerValue
}

// A number of bytes sent to the server by Agent since `opened_at`.
// Format: bytes (bytes)
// Example: 4e+11
func (s *WatcherAgentControlConnectionImpl) SetBytesToServer(v Bytes) WatcherAgentControlConnection {
	if s == nil {
		return nil
	}
	s.BytesToServerValue = &v
	return s
}

// Hostname of the server
// Example: agents-001.vsaas.io
func (s WatcherAgentControlConnectionImpl) Hostname() *string {
	return s.HostnameValue
}

// Hostname of the server
// Example: agents-001.vsaas.io
func (s *WatcherAgentControlConnectionImpl) SetHostname(v string) WatcherAgentControlConnection {
	if s == nil {
		return nil
	}
	s.HostnameValue = &v
	return s
}

// Timestamp of the current Agent control connection opening.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s WatcherAgentControlConnectionImpl) OpenedAt() *UtcMs {
	return s.OpenedAtValue
}

// Timestamp of the current Agent control connection opening.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s *WatcherAgentControlConnectionImpl) SetOpenedAt(v UtcMs) WatcherAgentControlConnection {
	if s == nil {
		return nil
	}
	s.OpenedAtValue = &v
	return s
}

// UTC timestamp of the last Agent status change to offline or online.
// Same as `opened_at` if Agent is now connected.
// Format: utc (Unix timestamp in seconds)
// Example: 1.634560921e+09
func (s WatcherAgentControlConnectionImpl) StatusChangedAt() *Utc {
	return s.StatusChangedAtValue
}

// UTC timestamp of the last Agent status change to offline or online.
// Same as `opened_at` if Agent is now connected.
// Format: utc (Unix timestamp in seconds)
// Example: 1.634560921e+09
func (s *WatcherAgentControlConnectionImpl) SetStatusChangedAt(v Utc) WatcherAgentControlConnection {
	if s == nil {
		return nil
	}
	s.StatusChangedAtValue = &v
	return s
}

// NewWatcherAgentDataConnections creates a new WatcherAgentDataConnections instance
func NewWatcherAgentDataConnections() WatcherAgentDataConnections {
	return &WatcherAgentDataConnectionsImpl{}
}

// A number of times the streamer tried to open a data connection via this Agent.
// Example: 400
func (s WatcherAgentDataConnectionsImpl) ConnectionsAttempted() *int {
	return s.ConnectionsAttemptedValue
}

// A number of times the streamer tried to open a data connection via this Agent.
// Example: 400
func (s *WatcherAgentDataConnectionsImpl) SetConnectionsAttempted(v int) WatcherAgentDataConnections {
	if s == nil {
		return nil
	}
	s.ConnectionsAttemptedValue = &v
	return s
}

// A number of currently active data connections opened via this Agent.
// Example: 2
func (s WatcherAgentDataConnectionsImpl) ConnectionsCurrent() *int {
	return s.ConnectionsCurrentValue
}

// A number of currently active data connections opened via this Agent.
// Example: 2
func (s *WatcherAgentDataConnectionsImpl) SetConnectionsCurrent(v int) WatcherAgentDataConnections {
	if s == nil {
		return nil
	}
	s.ConnectionsCurrentValue = &v
	return s
}

// A number of successfully opened data connections via this Agent.
// Example: 300
func (s WatcherAgentDataConnectionsImpl) ConnectionsOpened() *int {
	return s.ConnectionsOpenedValue
}

// A number of successfully opened data connections via this Agent.
// Example: 300
func (s *WatcherAgentDataConnectionsImpl) SetConnectionsOpened(v int) WatcherAgentDataConnections {
	if s == nil {
		return nil
	}
	s.ConnectionsOpenedValue = &v
	return s
}

// NewWatcherAgentLogs creates a new WatcherAgentLogs instance
func NewWatcherAgentLogs() WatcherAgentLogs {
	return &WatcherAgentLogsImpl{}
}

// Encoded log data for security purposes. Only the support team can decrypt it.
// Example: VDEVSvaNZZWeNOXqi7tA5Hm+KAqBjfHQKMzMl5aqRdYxHZkSnJ
func (s WatcherAgentLogsImpl) A() *string {
	return s.AValue
}

// Encoded log data for security purposes. Only the support team can decrypt it.
// Example: VDEVSvaNZZWeNOXqi7tA5Hm+KAqBjfHQKMzMl5aqRdYxHZkSnJ
func (s *WatcherAgentLogsImpl) SetA(v string) WatcherAgentLogs {
	if s == nil {
		return nil
	}
	s.AValue = &v
	return s
}

// Agent id
// Example: 1234567
func (s WatcherAgentLogsImpl) AgentID() *string {
	return s.AgentIDValue
}

// Agent id
// Example: 1234567
func (s *WatcherAgentLogsImpl) SetAgentID(v string) WatcherAgentLogs {
	if s == nil {
		return nil
	}
	s.AgentIDValue = &v
	return s
}

// Encoded log data for security purposes. Only the support team can decrypt it.
// Example: xglytWCTztsbTAUVBIhQymqik7nvzXi5VbJWEQNBHFCxw/NdvY6hdknh87/3gslKpER0hIaymR67Qo8zGKICFN==
func (s WatcherAgentLogsImpl) B() *string {
	return s.BValue
}

// Encoded log data for security purposes. Only the support team can decrypt it.
// Example: xglytWCTztsbTAUVBIhQymqik7nvzXi5VbJWEQNBHFCxw/NdvY6hdknh87/3gslKpER0hIaymR67Qo8zGKICFN==
func (s *WatcherAgentLogsImpl) SetB(v string) WatcherAgentLogs {
	if s == nil {
		return nil
	}
	s.BValue = &v
	return s
}

// Shows agent's buffer limit.
// Example: 0
func (s WatcherAgentLogsImpl) BufferLimit() *int {
	return s.BufferLimitValue
}

// Shows agent's buffer limit.
// Example: 0
func (s *WatcherAgentLogsImpl) SetBufferLimit(v int) WatcherAgentLogs {
	if s == nil {
		return nil
	}
	s.BufferLimitValue = &v
	return s
}

// Shows agent's buffer size.
// Example: 0
func (s WatcherAgentLogsImpl) BufferSize() *int {
	return s.BufferSizeValue
}

// Shows agent's buffer size.
// Example: 0
func (s *WatcherAgentLogsImpl) SetBufferSize(v int) WatcherAgentLogs {
	if s == nil {
		return nil
	}
	s.BufferSizeValue = &v
	return s
}

// Agent client ID.
// Example: 42195
func (s WatcherAgentLogsImpl) Cid() *string {
	return s.CidValue
}

// Agent client ID.
// Example: 42195
func (s *WatcherAgentLogsImpl) SetCid(v string) WatcherAgentLogs {
	if s == nil {
		return nil
	}
	s.CidValue = &v
	return s
}

// Main endpoint URL (Watcher host)
// Example: http://example.com
func (s WatcherAgentLogsImpl) MainURL() *string {
	return s.MainURLValue
}

// Main endpoint URL (Watcher host)
// Example: http://example.com
func (s *WatcherAgentLogsImpl) SetMainURL(v string) WatcherAgentLogs {
	if s == nil {
		return nil
	}
	s.MainURLValue = &v
	return s
}

// Physical memory size available on the device.
// Example: 806400
func (s WatcherAgentLogsImpl) Meminfo() *string {
	return s.MeminfoValue
}

// Physical memory size available on the device.
// Example: 806400
func (s *WatcherAgentLogsImpl) SetMeminfo(v string) WatcherAgentLogs {
	if s == nil {
		return nil
	}
	s.MeminfoValue = &v
	return s
}

// Agent model ID.
// Example: 3059
func (s WatcherAgentLogsImpl) Mid() *string {
	return s.MidValue
}

// Agent model ID.
// Example: 3059
func (s *WatcherAgentLogsImpl) SetMid(v string) WatcherAgentLogs {
	if s == nil {
		return nil
	}
	s.MidValue = &v
	return s
}

// Agent serial
// Example: a3dccd69f53deb79723a2a7a5f2037e1
func (s WatcherAgentLogsImpl) Serial() *string {
	return s.SerialValue
}

// Agent serial
// Example: a3dccd69f53deb79723a2a7a5f2037e1
func (s *WatcherAgentLogsImpl) SetSerial(v string) WatcherAgentLogs {
	if s == nil {
		return nil
	}
	s.SerialValue = &v
	return s
}

// Agent status
// Example: ok
func (s WatcherAgentLogsImpl) Status() *string {
	return s.StatusValue
}

// Agent status
// Example: ok
func (s *WatcherAgentLogsImpl) SetStatus(v string) WatcherAgentLogs {
	if s == nil {
		return nil
	}
	s.StatusValue = &v
	return s
}

// Agent version
// Example: version
func (s WatcherAgentLogsImpl) Version() *string {
	return s.VersionValue
}

// Agent version
// Example: version
func (s *WatcherAgentLogsImpl) SetVersion(v string) WatcherAgentLogs {
	if s == nil {
		return nil
	}
	s.VersionValue = &v
	return s
}

// NewWatcherAgentStats creates a new WatcherAgentStats instance
func NewWatcherAgentStats() WatcherAgentStats {
	return &WatcherAgentStatsImpl{}
}

// The type of Agent installed on the device:
// * `single` means "one Agent = one camera", i.e. Agent is installed on a camera itself.
// * `router` means "one Agent = multiple cameras", i.e. Agent is installed on a router
// to provision the cameras from LAN to Watcher.
func (s WatcherAgentStatsImpl) AgentType() *string {
	return s.AgentTypeValue
}

// The type of Agent installed on the device:
// * `single` means "one Agent = one camera", i.e. Agent is installed on a camera itself.
// * `router` means "one Agent = multiple cameras", i.e. Agent is installed on a router
// to provision the cameras from LAN to Watcher.
func (s *WatcherAgentStatsImpl) SetAgentType(v string) WatcherAgentStats {
	if s == nil {
		return nil
	}
	s.AgentTypeValue = &v
	return s
}

// The number of successfully established connections.
func (s WatcherAgentStatsImpl) ConnectionsEstablished() *int {
	return s.ConnectionsEstablishedValue
}

// The number of successfully established connections.
func (s *WatcherAgentStatsImpl) SetConnectionsEstablished(v int) WatcherAgentStats {
	if s == nil {
		return nil
	}
	s.ConnectionsEstablishedValue = &v
	return s
}

// The number of connections requested by Agent.
func (s WatcherAgentStatsImpl) ConnectionsRequested() *int {
	return s.ConnectionsRequestedValue
}

// The number of connections requested by Agent.
func (s *WatcherAgentStatsImpl) SetConnectionsRequested(v int) WatcherAgentStats {
	if s == nil {
		return nil
	}
	s.ConnectionsRequestedValue = &v
	return s
}

// Parameters of the connection between Agent and its endpoint.
func (s WatcherAgentStatsImpl) EndpointConnection() WatcherAgentControlConnection {
	return s.EndpointConnectionValue
}

// Parameters of the connection between Agent and its endpoint.
func (s *WatcherAgentStatsImpl) SetEndpointConnection(v WatcherAgentControlConnection) WatcherAgentStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*WatcherAgentControlConnectionImpl); ok {
		s.EndpointConnectionValue = impl
	}
	return s
}

// IP address of the device (camera or router) in the local network.
// Format: ipv4 (ipv4)
// Example: 10.10.17.88
func (s WatcherAgentStatsImpl) LocalIP() *Ipv4 {
	return s.LocalIPValue
}

// IP address of the device (camera or router) in the local network.
// Format: ipv4 (ipv4)
// Example: 10.10.17.88
func (s *WatcherAgentStatsImpl) SetLocalIP(v Ipv4) WatcherAgentStats {
	if s == nil {
		return nil
	}
	s.LocalIPValue = &v
	return s
}

// MAC-address of the device.
// Example: F0-23-B9-59-20-F1
func (s WatcherAgentStatsImpl) MacAddress() *string {
	return s.MacAddressValue
}

// MAC-address of the device.
// Example: F0-23-B9-59-20-F1
func (s *WatcherAgentStatsImpl) SetMacAddress(v string) WatcherAgentStats {
	if s == nil {
		return nil
	}
	s.MacAddressValue = &v
	return s
}

// Public IP address of the device (camera or router) on which the Agent is running.
// Format: ipv4 (ipv4)
// Example: 185.134.232.183
func (s WatcherAgentStatsImpl) PeerIP() *Ipv4 {
	return s.PeerIPValue
}

// Public IP address of the device (camera or router) on which the Agent is running.
// Format: ipv4 (ipv4)
// Example: 185.134.232.183
func (s *WatcherAgentStatsImpl) SetPeerIP(v Ipv4) WatcherAgentStats {
	if s == nil {
		return nil
	}
	s.PeerIPValue = &v
	return s
}

// Parameters of the connection between Agent and its streampoint.
func (s WatcherAgentStatsImpl) StreampointConnection() WatcherAgentStatsStreampointConnection {
	return s.StreampointConnectionValue
}

// Parameters of the connection between Agent and its streampoint.
func (s *WatcherAgentStatsImpl) SetStreampointConnection(v WatcherAgentStatsStreampointConnection) WatcherAgentStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*WatcherAgentStatsStreampointConnectionImpl); ok {
		s.StreampointConnectionValue = impl
	}
	return s
}

// Agent version.
// Example: v21.02-8-g535c85d
func (s WatcherAgentStatsImpl) Version() *string {
	return s.VersionValue
}

// Agent version.
// Example: v21.02-8-g535c85d
func (s *WatcherAgentStatsImpl) SetVersion(v string) WatcherAgentStats {
	if s == nil {
		return nil
	}
	s.VersionValue = &v
	return s
}

// NewWatcherAgentStatsStreampointConnection creates a new WatcherAgentStatsStreampointConnection instance
func NewWatcherAgentStatsStreampointConnection() WatcherAgentStatsStreampointConnection {
	return &WatcherAgentStatsStreampointConnectionImpl{}
}

// A flag showing if Agent is connected at the moment of the request.
func (s WatcherAgentStatsStreampointConnectionImpl) Alive() *bool {
	return s.AliveValue
}

// A flag showing if Agent is connected at the moment of the request.
func (s *WatcherAgentStatsStreampointConnectionImpl) SetAlive(v bool) WatcherAgentStatsStreampointConnection {
	if s == nil {
		return nil
	}
	s.AliveValue = &v
	return s
}

// A number of bytes received from the server by Agent since `opened_at`.
// Format: bytes (bytes)
// Example: 40000
func (s WatcherAgentStatsStreampointConnectionImpl) BytesFromServer() *Bytes {
	return s.BytesFromServerValue
}

// A number of bytes received from the server by Agent since `opened_at`.
// Format: bytes (bytes)
// Example: 40000
func (s *WatcherAgentStatsStreampointConnectionImpl) SetBytesFromServer(v Bytes) WatcherAgentStatsStreampointConnection {
	if s == nil {
		return nil
	}
	s.BytesFromServerValue = &v
	return s
}

// A number of bytes sent to the server by Agent since `opened_at`.
// Format: bytes (bytes)
// Example: 4e+11
func (s WatcherAgentStatsStreampointConnectionImpl) BytesToServer() *Bytes {
	return s.BytesToServerValue
}

// A number of bytes sent to the server by Agent since `opened_at`.
// Format: bytes (bytes)
// Example: 4e+11
func (s *WatcherAgentStatsStreampointConnectionImpl) SetBytesToServer(v Bytes) WatcherAgentStatsStreampointConnection {
	if s == nil {
		return nil
	}
	s.BytesToServerValue = &v
	return s
}

// A number of times the streamer tried to open a data connection via this Agent.
// Example: 400
func (s WatcherAgentStatsStreampointConnectionImpl) ConnectionsAttempted() *int {
	return s.ConnectionsAttemptedValue
}

// A number of times the streamer tried to open a data connection via this Agent.
// Example: 400
func (s *WatcherAgentStatsStreampointConnectionImpl) SetConnectionsAttempted(v int) WatcherAgentStatsStreampointConnection {
	if s == nil {
		return nil
	}
	s.ConnectionsAttemptedValue = &v
	return s
}

// A number of currently active data connections opened via this Agent.
// Example: 2
func (s WatcherAgentStatsStreampointConnectionImpl) ConnectionsCurrent() *int {
	return s.ConnectionsCurrentValue
}

// A number of currently active data connections opened via this Agent.
// Example: 2
func (s *WatcherAgentStatsStreampointConnectionImpl) SetConnectionsCurrent(v int) WatcherAgentStatsStreampointConnection {
	if s == nil {
		return nil
	}
	s.ConnectionsCurrentValue = &v
	return s
}

// A number of successfully opened data connections via this Agent.
// Example: 300
func (s WatcherAgentStatsStreampointConnectionImpl) ConnectionsOpened() *int {
	return s.ConnectionsOpenedValue
}

// A number of successfully opened data connections via this Agent.
// Example: 300
func (s *WatcherAgentStatsStreampointConnectionImpl) SetConnectionsOpened(v int) WatcherAgentStatsStreampointConnection {
	if s == nil {
		return nil
	}
	s.ConnectionsOpenedValue = &v
	return s
}

// Hostname of the server
// Example: agents-001.vsaas.io
func (s WatcherAgentStatsStreampointConnectionImpl) Hostname() *string {
	return s.HostnameValue
}

// Hostname of the server
// Example: agents-001.vsaas.io
func (s *WatcherAgentStatsStreampointConnectionImpl) SetHostname(v string) WatcherAgentStatsStreampointConnection {
	if s == nil {
		return nil
	}
	s.HostnameValue = &v
	return s
}

// Timestamp of the current Agent control connection opening.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s WatcherAgentStatsStreampointConnectionImpl) OpenedAt() *UtcMs {
	return s.OpenedAtValue
}

// Timestamp of the current Agent control connection opening.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s *WatcherAgentStatsStreampointConnectionImpl) SetOpenedAt(v UtcMs) WatcherAgentStatsStreampointConnection {
	if s == nil {
		return nil
	}
	s.OpenedAtValue = &v
	return s
}

// UTC timestamp of the last Agent status change to offline or online.
// Same as `opened_at` if Agent is now connected.
// Format: utc (Unix timestamp in seconds)
// Example: 1.634560921e+09
func (s WatcherAgentStatsStreampointConnectionImpl) StatusChangedAt() *Utc {
	return s.StatusChangedAtValue
}

// UTC timestamp of the last Agent status change to offline or online.
// Same as `opened_at` if Agent is now connected.
// Format: utc (Unix timestamp in seconds)
// Example: 1.634560921e+09
func (s *WatcherAgentStatsStreampointConnectionImpl) SetStatusChangedAt(v Utc) WatcherAgentStatsStreampointConnection {
	if s == nil {
		return nil
	}
	s.StatusChangedAtValue = &v
	return s
}

// NewWebrtcAbrOpts creates a new WebrtcAbrOpts instance
func NewWebrtcAbrOpts() WebrtcAbrOpts {
	return &WebrtcAbrOptsImpl{}
}

// Video track number from which playback starts. Possible values: `v1`, `v2`, `v3` and so on.
// If not specified, or an audio track specified (`start_track=a3`), or a video track number does not exist,
// playback starts with the track number in the middle of the list (e.g. `v2` if you have tracks `v1`, `v2`, and `v3`)
// and then adjusts to the bandwidth availability.
// If some tracks are excluded by the query parameter `?filter=tracks:...`, Flussonic searches for an available track with a lower number up to v0.
// If no track with a lower number was found, Flussonic searches for a closest track with a higher number.
// Example: v2
func (s WebrtcAbrOptsImpl) StartTrack() *string {
	return s.StartTrackValue
}

// Video track number from which playback starts. Possible values: `v1`, `v2`, `v3` and so on.
// If not specified, or an audio track specified (`start_track=a3`), or a video track number does not exist,
// playback starts with the track number in the middle of the list (e.g. `v2` if you have tracks `v1`, `v2`, and `v3`)
// and then adjusts to the bandwidth availability.
// If some tracks are excluded by the query parameter `?filter=tracks:...`, Flussonic searches for an available track with a lower number up to v0.
// If no track with a lower number was found, Flussonic searches for a closest track with a higher number.
// Example: v2
func (s *WebrtcAbrOptsImpl) SetStartTrack(v string) WebrtcAbrOpts {
	if s == nil {
		return nil
	}
	s.StartTrackValue = &v
	return s
}
