// Code generated by cmd/main. DO NOT EDIT.
package central

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"iter"
	"net/http"
	"net/url"
	"strconv"

	"github.com/flussonic/go-flussonic/authorization"
	model "github.com/flussonic/go-flussonic/central/model"
	"github.com/flussonic/go-flussonic/config"
	"github.com/flussonic/go-flussonic/internal/baseclient"
	"github.com/flussonic/go-flussonic/internal/cursors"
)

// Central defines the interface for interacting with Central API.
type Central interface {
	// AgentDelete Delete Agent
	// Agent and corresponding camera(s) will be permanently deleted from the system.
	AgentDelete(ctx context.Context, id string) error
	// AgentDisconnect Disconnect Agent
	// Disconnect the Agent by the Agent ID.
	AgentDisconnect(ctx context.Context, id string) error
	// AgentGet Get one Agent
	// The method allows you to fetch a single Agent.  The returned data are the same as for `agents_list` operation.
	AgentGet(ctx context.Context, id string) (model.CentralAgentConfig, error)
	// AgentLogsGet Get logs from Agent
	// The method allows you to fetch logs from online Agent.
	AgentLogsGet(ctx context.Context, id string) (model.WatcherAgentLogs, error)
	// AgentReboot Reboot Agent
	// Reboot the Agent by the Agent ID.
	AgentReboot(ctx context.Context, id string) error
	// AgentReset Reset Agent
	// Reset the Agent by the Agent ID.
	AgentReset(ctx context.Context, id string) error
	// AgentSave Save Agent
	// Save the Agent parameters by the Agent ID.
	AgentSave(ctx context.Context, id string, body model.CentralAgentConfig) (model.CentralAgentConfig, error)
	// AgentsList List Agents
	// The list of configured and provisioned Agents, i.e. Agents that connected to your server at least once.
	AgentsList(ctx context.Context, query *AgentsListQuery) (model.CentralAgentsList, error)
	// AgentsListIterator iterates through all items using cursor pagination
	AgentsListIterator(ctx context.Context, query *AgentsListQuery) iter.Seq2[model.CentralAgentConfig, error]
	// ApiTokenGet Get one API Token
	// Method allows to fetch single API token by name
	ApiTokenGet(ctx context.Context, name string) (model.APIToken, error)
	// ApiTokenSave Save API Token
	// Create a new API token or update an existing one by name.
	ApiTokenSave(ctx context.Context, name string, body model.APIToken) (model.APIToken, error)
	// ApiTokensList List API tokens
	// Method allows to fetch configured API tokens
	ApiTokensList(ctx context.Context, query *ApiTokensListQuery) (model.APITokensList, error)
	// ApiTokensListIterator iterates through all items using cursor pagination
	ApiTokensListIterator(ctx context.Context, query *ApiTokensListQuery) iter.Seq2[model.APIToken, error]
	// AuthBackendDelete Delete the auth backend
	// Delete the authorization backend by its name.
	AuthBackendDelete(ctx context.Context, name string) error
	// AuthBackendGet Get the auth backend
	// This method allows to get a single authorization backend.
	AuthBackendGet(ctx context.Context, name string) (model.AuthBackendConfig, error)
	// AuthBackendSave Save the auth backend
	// Create or update an authorization backend.  If you pass only a partial configuration, only the passed fields will be updated.
	AuthBackendSave(ctx context.Context, name string, body model.AuthBackendConfig) (model.AuthBackendConfig, error)
	// AuthBackendsList List auth backends
	// This method allows to get the list of all authorization backends configured in Flussonic.
	AuthBackendsList(ctx context.Context, query *AuthBackendsListQuery) (model.AuthBackendsList, error)
	// AuthBackendsListIterator iterates through all items using cursor pagination
	AuthBackendsListIterator(ctx context.Context, query *AuthBackendsListQuery) iter.Seq2[model.AuthBackendConfig, error]
	// AuthRequest Play session authorization
	// This method describes what Flussonic sends to an authorization backend for playing session and what it awaits as a response.
	AuthRequest(ctx context.Context, query *AuthRequestQuery) (model.AuthResponseV1, error)
	// BatchStreamLayoutPreview Dry run layouter for batch of changed stream configurations
	// This method allows you to see how the overall layout will change due to changes in the configurations of multiple streams. Note that if [Layouter](https://flussonic.com/doc/api/layouter/) is [disabled](https://flussonic.com/doc/api/central/#tag/config/operation/config_save%7Cbody%7Clayouter_enabled), this method will return an error.
	BatchStreamLayoutPreview(ctx context.Context, query *BatchStreamLayoutPreviewQuery, body any) (model.CentralStreamLayoutPrediction, error)
	// BatchStreamLayoutPreviewIterator iterates through all items using cursor pagination
	BatchStreamLayoutPreviewIterator(ctx context.Context, query *BatchStreamLayoutPreviewQuery, body any) iter.Seq2[model.CentralStreamLayoutListItem, error]
	// BatchStreamerLayoutPreview Dry run layouter for batch of changed streamer configurations
	// This method allows you to see how the overall layout will be changed due to changes in the configurations of multiple streamers. Note that if [Layouter](https://flussonic.com/doc/api/layouter/) is [disabled](https://flussonic.com/doc/api/central/#tag/config/operation/config_save%7Cbody%7Clayouter_enabled), this method will return an error.
	BatchStreamerLayoutPreview(ctx context.Context, query *BatchStreamerLayoutPreviewQuery, body any) (model.CentralStreamerLayoutPrediction, error)
	// BatchStreamerLayoutPreviewIterator iterates through all items using cursor pagination
	BatchStreamerLayoutPreviewIterator(ctx context.Context, query *BatchStreamerLayoutPreviewQuery, body any) iter.Seq2[model.CentralStreamerLayoutPredictionItem, error]
	// BatchUpdateAgentsLayouts Batch update layouts of agents
	// Batch update layouts of agents. This operation does everything or nothing. Only agents without streams will be processed, other ones would be ignored. If at least one agent has an invalid configuration or can't be processed, the request will fail.
	BatchUpdateAgentsLayouts(ctx context.Context, body model.CentralAgentLayoutList) error
	// BatchUpdateStreamsLayouts Batch update layouts of streams
	// Batch update layouts of streams. This operation does everything or nothing.  If at least one stream has an invalid configuration or can't be processed, the request will fail.
	BatchUpdateStreamsLayouts(ctx context.Context, body model.CentralStreamLayoutList) error
	// CentralEventsList Get events of Central
	// This method allows to get the batch of events. Currently this method is not implemented yet. However, its schema can be used for understanding Central logging.
	CentralEventsList(ctx context.Context, query *CentralEventsListQuery) (model.CentralEventsList, error)
	// CentralEventsListIterator iterates through all items using cursor pagination
	CentralEventsListIterator(ctx context.Context, query *CentralEventsListQuery) iter.Seq2[model.CentralEvent, error]
	// ClusterStatsGet Get current health of cluster
	// This method allows you to fetch cluster's health
	ClusterStatsGet(ctx context.Context, query *ClusterStatsGetQuery) (model.ClusterHealthStats, error)
	// ConfigGet Get configuration and stats of Central
	// This method allows you to fetch Central configuration and stats
	ConfigGet(ctx context.Context, query *ConfigGetQuery) (model.CentralConfig, error)
	// ConfigSave Update central configuration
	// This method allows you to update central configuration. Calling this method will update config file but will not change the env.
	ConfigSave(ctx context.Context, body model.CentralConfig) (model.CentralConfig, error)
	// DvrsList List of DVR configurations
	// This method allows to get the whole list of global DVR congifurations.
	DvrsList(ctx context.Context, query *DvrsListQuery) (model.CentralDvrsList, error)
	// DvrsListIterator iterates through all items using cursor pagination
	DvrsListIterator(ctx context.Context, query *DvrsListQuery) iter.Seq2[model.CentralDvrConfig, error]
	// EpisodeDelete Delete the Episode
	// This method allows you to delete an episode
	EpisodeDelete(ctx context.Context, episode_id string) error
	// EpisodeGet Get the episode
	// This method allows you to fetch the episode by its identifier
	EpisodeGet(ctx context.Context, episode_id string, query *EpisodeGetQuery) (model.Episode, error)
	// EpisodeSave Save the Episode
	// This method allows you to create a new episode or update attributes of the existing one
	EpisodeSave(ctx context.Context, episode_id string, body model.Episode) (model.Episode, error)
	// EpisodesList List episodes
	// This method allows you to fetch registered episodes
	EpisodesList(ctx context.Context, query *EpisodesListQuery) (model.EpisodesList, error)
	// EpisodesListIterator iterates through all items using cursor pagination
	EpisodesListIterator(ctx context.Context, query *EpisodesListQuery) iter.Seq2[model.Episode, error]
	// ExternalEpisodesList External episodes
	// This method will return episodes for selected streams that should be  left on disk during DVR cleaning process.
	ExternalEpisodesList(ctx context.Context, hostname string, query *ExternalEpisodesListQuery) (model.ExternalEpisodesList, error)
	// ExternalEpisodesListIterator iterates through all items using cursor pagination
	ExternalEpisodesListIterator(ctx context.Context, hostname string, query *ExternalEpisodesListQuery) iter.Seq2[model.ExternalEpisode, error]
	// LivenessProbe Liveness probe
	// K8s liveness probe.
	LivenessProbe(ctx context.Context) (model.ServerStatsWhoami, error)
	// LoadBalancerDelete Delete the Load Balancer
	// This method allows you to delete a load balancer
	LoadBalancerDelete(ctx context.Context, name string) error
	// LoadBalancerGet Get the load balancer
	// This method allows you to fetch the load balancer by its name
	LoadBalancerGet(ctx context.Context, name string) (model.BalancerConfig, error)
	// LoadBalancerSave Save the Load Balancer
	// This method allows you to create a new load balancer or update attributes of the existing one
	LoadBalancerSave(ctx context.Context, name string, body model.BalancerConfig) (model.BalancerConfig, error)
	// LoadBalancersList List load balancers
	// This method allows you to fetch registered load balancers.  Load balancers are used in [streaming api](https://flussonic.com/doc/api/central/#tag/streaming).
	LoadBalancersList(ctx context.Context, query *LoadBalancersListQuery) (model.BalancersList, error)
	// LoadBalancersListIterator iterates through all items using cursor pagination
	LoadBalancersListIterator(ctx context.Context, query *LoadBalancersListQuery) iter.Seq2[model.BalancerConfig, error]
	// PersonDelete Delete the Person
	// This method allows you to delete the person by its identifier
	PersonDelete(ctx context.Context, person_id string) error
	// PersonGet Get the Person
	// This method allows you to fetch the person by its identifier
	PersonGet(ctx context.Context, person_id string) (model.VisionPerson, error)
	// PersonSave Save the Person
	// This method allows you to create a new person or update attributes of the existing one
	PersonSave(ctx context.Context, person_id string, body model.VisionPerson) (model.VisionPerson, error)
	// PersonsList List Persons
	// The list of registered videoanalytics persons
	PersonsList(ctx context.Context, query *PersonsListQuery) (model.VisionPersonsList, error)
	// PersonsListIterator iterates through all items using cursor pagination
	PersonsListIterator(ctx context.Context, query *PersonsListQuery) iter.Seq2[model.VisionPerson, error]
	// PreviewLayoutChangeForStreamConfig Dry run layouter for changed stream configuration
	// This method allows you to see how the overall layout will be changed due to changes into stream configuration. Note that if [Layouter](https://flussonic.com/doc/api/layouter/) is [disabled](https://flussonic.com/doc/api/central/#tag/config/operation/config_save%7Cbody%7Clayouter_enabled), this method will return an error.
	PreviewLayoutChangeForStreamConfig(ctx context.Context, name string, query *PreviewLayoutChangeForStreamConfigQuery, body model.CentralStreamConfig) (model.CentralStreamLayoutPrediction, error)
	// PreviewLayoutChangeForStreamConfigIterator iterates through all items using cursor pagination
	PreviewLayoutChangeForStreamConfigIterator(ctx context.Context, name string, query *PreviewLayoutChangeForStreamConfigQuery, body model.CentralStreamConfig) iter.Seq2[model.CentralStreamLayoutListItem, error]
	// PreviewLayoutChangeForStreamerConfig Dry run layouter for changed streamer configuration
	// This method allows you to see how the overall layout will be changed due to changes into streamer configuration. Note that if [Layouter](https://flussonic.com/doc/api/layouter/) is [disabled](https://flussonic.com/doc/api/central/#tag/config/operation/config_save%7Cbody%7Clayouter_enabled), this method will return an error.
	PreviewLayoutChangeForStreamerConfig(ctx context.Context, hostname string, query *PreviewLayoutChangeForStreamerConfigQuery, body model.StreamerConfig) (model.CentralStreamerLayoutPrediction, error)
	// PreviewLayoutChangeForStreamerConfigIterator iterates through all items using cursor pagination
	PreviewLayoutChangeForStreamerConfigIterator(ctx context.Context, hostname string, query *PreviewLayoutChangeForStreamerConfigQuery, body model.StreamerConfig) iter.Seq2[model.CentralStreamerLayoutPredictionItem, error]
	// ReadinessProbe Readiness probe
	// K8s readiness probe.
	ReadinessProbe(ctx context.Context) (model.ServerStatsWhoami, error)
	// SrtPortResolve UDP port to stream name
	// This API method will be called to find stream name by the port which received srt connection.  SRT protocol has two modes: when no stream name is passed in protocol, or when it is passed, but only if passwords match on both sides.  So you cannot rely on a stream name, because it is either not passed, either is password protected.  When you build a cloud, you cannot offer the same password to all clients, because it is just the same like without password.  This method allows some dynamic configuration when you wait for a client on a pool of servers on a fixed UDP port. When connection comes (publish/ingress of play/egress), your configuration backend will be called for resolving this UDP port to a stream configuration. Streamer will find out what is the name of the stream, its password and all other settings.
	SrtPortResolve(ctx context.Context, hostname string, port string, query *SrtPortResolveQuery) (any, error)
	// StreamDelete Delete stream
	// The stream will be permanently deleted from the project.
	StreamDelete(ctx context.Context, name string) error
	// StreamGet Get one stream
	// This method allows you to fetch a single stream.  The data returned in this method are the same as for `streams_list` operation.
	StreamGet(ctx context.Context, name string) (model.CentralStreamConfig, error)
	// StreamLayoutsGet Get layouts of stream
	// This method allows you to fetch stream layouts list
	StreamLayoutsGet(ctx context.Context, name string, query *StreamLayoutsGetQuery) (model.CentralStreamLayouts, error)
	// StreamLayoutsGetIterator iterates through all items using cursor pagination
	StreamLayoutsGetIterator(ctx context.Context, name string, query *StreamLayoutsGetQuery) iter.Seq2[model.CentralStreamLayout, error]
	// StreamSave Save stream
	// Create or update a stream by its name. If the stream doesn't exists in the disk config, it will be created.  If you pass only a partial stream configuration, just the passed field(s) will be updated, not the whole stream.  To create a new stream the property `name` is required.  Pass the `"$reset": true` option to replace the stream configuration with the provided one.
	StreamSave(ctx context.Context, name string, body model.CentralStreamConfig) (model.CentralStreamConfig, error)
	// StreamerDelete Delete the streamer
	// Delete the streamer by its hostname.
	StreamerDelete(ctx context.Context, hostname string) error
	// StreamerDynamicStreamsList Get dynamic streams for streamer
	// This API method will be called to fetch list of streams configurations for newly requested by user streams.  If you do not send a configuration of any stream named in `name` query parameter, it will be considered as an unknown and terminated immediately
	StreamerDynamicStreamsList(ctx context.Context, hostname string, query *StreamerDynamicStreamsListQuery) (model.StreamsList, error)
	// StreamerDynamicStreamsListIterator iterates through all items using cursor pagination
	StreamerDynamicStreamsListIterator(ctx context.Context, hostname string, query *StreamerDynamicStreamsListQuery) iter.Seq2[model.StreamConfig, error]
	// StreamerGet Get the streamer
	// This method allows you to fetch the main parameters and current metrics of a single streamer
	StreamerGet(ctx context.Context, hostname string) (model.StreamerConfig, error)
	// StreamerSave Save the streamer
	// This method will either create a new streamer (if there is no streamer with the hostname specified in the request), or update the existing streamer having the specified hostname.
	StreamerSave(ctx context.Context, hostname string, query *StreamerSaveQuery, body model.StreamerConfig) (model.StreamerConfig, error)
	// StreamerStreamsList Get streams for streamer
	// Return list of configured streams for the streamer
	StreamerStreamsList(ctx context.Context, hostname string, query *StreamerStreamsListQuery) (model.StreamsList, error)
	// StreamerStreamsListIterator iterates through all items using cursor pagination
	StreamerStreamsListIterator(ctx context.Context, hostname string, query *StreamerStreamsListQuery) iter.Seq2[model.StreamConfig, error]
	// StreamerUpdateStreamsList Get update streams for streamer
	// This API method will be called to fetch list of streams configurations.  Streamer will send here list of streams that were not enumerated in `streams_list` response.  Use this to shutdown unknown streams or dynamically configure streams.  If you do not send a configuration of any stream named in `name` query parameter, it will be considered as an unknown and terminated immediately
	StreamerUpdateStreamsList(ctx context.Context, hostname string, query *StreamerUpdateStreamsListQuery) (model.StreamsList, error)
	// StreamerUpdateStreamsListIterator iterates through all items using cursor pagination
	StreamerUpdateStreamsListIterator(ctx context.Context, hostname string, query *StreamerUpdateStreamsListQuery) iter.Seq2[model.StreamConfig, error]
	// StreamersBatchUpdate Batch update streamers
	// This method allows you to update multiple streamers in a single request. This operation does everything or nothing.  If at least one streamer has an invalid configuration or can't be processed, the request will fail.  The request body should contain an array of streamer objects with the fields to be updated. The update is applied using [JSON Merge Patch](https://tools.ietf.org/html/rfc7386) semantics.  If a streamer does not exist, it will be created with the provided configuration.
	StreamersBatchUpdate(ctx context.Context, body any) error
	// StreamersList List streamers
	// Returns the list of all streamers with main parameters and current metric values.
	StreamersList(ctx context.Context, query *StreamersListQuery) (model.StreamersList, error)
	// StreamersListIterator iterates through all items using cursor pagination
	StreamersListIterator(ctx context.Context, query *StreamersListQuery) iter.Seq2[model.StreamerConfig, error]
	// StreamingLbPlayback Playback load balance
	// This method allows you to play a stream from the least loaded media server.
	StreamingLbPlayback(ctx context.Context, loadbalancer_name string, escaped_stream_name string, multi_segment_suffix string) (any, error)
	// StreamingLbPublish Publish load balance
	// This method allows to publish the stream to the least loaded media server.
	StreamingLbPublish(ctx context.Context, loadbalancer_name string, escaped_stream_name string, multi_segment_suffix string) error
	// StreamsBatchUpdate Batch update streams
	// This method allows you to update multiple streams in a single request. This operation does everything or nothing.  If at least one stream has an invalid configuration or can't be processed, the request will fail.  The request body should contain an array of stream objects with the fields to be updated. The update is applied using [JSON Merge Patch](https://tools.ietf.org/html/rfc7386) semantics.  If a stream does not exist, it will be created with the provided configuration.
	StreamsBatchUpdate(ctx context.Context, body any) error
	// StreamsList List streams
	// This API method is one of the most important in whole API, because it gives the list of all streams, including:  * configured (maybe not running at the moment) * running (including those that are created via template and do not have own disk configuration) * remote (available from other servers) * only recorded  You can pass any stream configuration options to the `q` query string for filtering,  not only those specified in the `select` parameters.  This method, as well as `stream_get`, will return the **effective stream configuration** with all templates, defaults included into the response. It is not exactly what you can see in your disk config. If you have configured this stream in disk file, then the original disk configuration can be found in the `config_on_disk` field.  Thus, what you get from this API call may differ from what you write to `stream_save` which is another important method for managing streams.
	StreamsList(ctx context.Context, query *StreamsListQuery) (model.CentralStreamsList, error)
	// StreamsListIterator iterates through all items using cursor pagination
	StreamsListIterator(ctx context.Context, query *StreamsListQuery) iter.Seq2[model.CentralStreamConfig, error]
}

// AgentsListQuery represents query parameters for AgentsList method
type AgentsListQuery struct {
	// A properly encoded equivalent of offset allowing you to read the next bunch of items.  We do not offer common `offset` fields, so please use cursor for predictable fetching of quickly changing list of items.
	Cursor string
	// Limit the number of records in the selected collection to N elements. Default value is 100
	Limit int
	// Full-text search for agents
	Q      string
	Select string
	// Composite sort direction. Specify field name(s) using comma `,` as a separator. Default sorting order is reverse alphabetical by `id`.  Place `-` before the field name to sort in reverse alphabetical order or descending.
	Sort string
	// Filter agents by stream presence. If any stream has the agent in its inputs, the agent will not be returned with filter `stream_is=null`.
	Stream string
	Extra  map[string]string
}

// ToQueryString converts AgentsListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *AgentsListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	if q.Limit != 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Q != "" {
		values.Set("q", q.Q)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Stream != "" {
		values.Set("stream", q.Stream)
	}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *AgentsListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// ApiTokensListQuery represents query parameters for ApiTokensList method
type ApiTokensListQuery struct {
	Cursor string
	Limit  int
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts ApiTokensListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *ApiTokensListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *ApiTokensListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// AuthBackendsListQuery represents query parameters for AuthBackendsList method
type AuthBackendsListQuery struct {
	Cursor string
	Limit  int
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts AuthBackendsListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *AuthBackendsListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *AuthBackendsListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// AuthRequestQuery represents query parameters for AuthRequest method
type AuthRequestQuery struct {
	// How many bytes have been passed in this session.
	Bytes int
	// If it is an update request, then it will be the duration of this session in seconds.
	Duration int
	// Is it a session for playing DVR archive.
	Dvr bool
	// A value of Host HTTP Header.
	Host string
	// IP address of the media client who initiated this session.
	Ip string
	// Stream or VOD file name for this session.
	Name string
	// Protocol for this session.
	Proto string
	// Here may go initial query string that was passed by client. Use it for additional authorization.
	Qs string
	// Referer HTTP header that identifies the address of the web page from which the request was made.
	Referer string
	// Counter of auth requests for this session, starting from 0.
	RequestNumber int
	// Is it a request for a new session or an update request.  The value `new_session` is used for a start of a new session and `update_session` - for an existing session.
	RequestType string
	// Unique session id. It will be the same for one session.
	SessionId string
	// How many clients are currently watching this stream or VOD file.
	StreamClients int
	// User provided authorization token.  The token is generated automatically or received from a website.
	Token string
	// How many clients are currently watching from this server.
	TotalClients int
	// Many protocols can signal a user agent. It will be provided in this field.
	UserAgent string
	Extra     map[string]string
}

// ToQueryString converts AuthRequestQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *AuthRequestQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", fmt.Errorf("query is required")
	}
	if q.Ip == "" {
		return "", fmt.Errorf("query parameter 'ip' is required")
	}
	if q.Name == "" {
		return "", fmt.Errorf("query parameter 'name' is required")
	}
	if q.Proto == "" {
		return "", fmt.Errorf("query parameter 'proto' is required")
	}
	if q.RequestNumber == 0 {
		return "", fmt.Errorf("query parameter 'request_number' is required")
	}
	if q.RequestType == "" {
		return "", fmt.Errorf("query parameter 'request_type' is required")
	}
	if q.SessionId == "" {
		return "", fmt.Errorf("query parameter 'session_id' is required")
	}
	if q.StreamClients == 0 {
		return "", fmt.Errorf("query parameter 'stream_clients' is required")
	}
	if q.TotalClients == 0 {
		return "", fmt.Errorf("query parameter 'total_clients' is required")
	}
	values := url.Values{}
	if q.Bytes != 0 {
		values.Set("bytes", strconv.Itoa(q.Bytes))
	}
	if q.Duration != 0 {
		values.Set("duration", strconv.Itoa(q.Duration))
	}
	values.Set("dvr", strconv.FormatBool(q.Dvr))
	if q.Host != "" {
		values.Set("host", q.Host)
	}
	values.Set("ip", q.Ip)
	values.Set("name", q.Name)
	values.Set("proto", q.Proto)
	if q.Qs != "" {
		values.Set("qs", q.Qs)
	}
	if q.Referer != "" {
		values.Set("referer", q.Referer)
	}
	values.Set("request_number", strconv.Itoa(q.RequestNumber))
	values.Set("request_type", q.RequestType)
	values.Set("session_id", q.SessionId)
	values.Set("stream_clients", strconv.Itoa(q.StreamClients))
	if q.Token != "" {
		values.Set("token", q.Token)
	}
	values.Set("total_clients", strconv.Itoa(q.TotalClients))
	if q.UserAgent != "" {
		values.Set("user_agent", q.UserAgent)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// BatchStreamLayoutPreviewQuery represents query parameters for BatchStreamLayoutPreview method
type BatchStreamLayoutPreviewQuery struct {
	Cursor string
	Limit  int
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts BatchStreamLayoutPreviewQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *BatchStreamLayoutPreviewQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *BatchStreamLayoutPreviewQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// BatchStreamerLayoutPreviewQuery represents query parameters for BatchStreamerLayoutPreview method
type BatchStreamerLayoutPreviewQuery struct {
	Cursor string
	Limit  int
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts BatchStreamerLayoutPreviewQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *BatchStreamerLayoutPreviewQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *BatchStreamerLayoutPreviewQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// CentralEventsListQuery represents query parameters for CentralEventsList method
type CentralEventsListQuery struct {
	Cursor string
	Limit  int
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts CentralEventsListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *CentralEventsListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *CentralEventsListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// ClusterStatsGetQuery represents query parameters for ClusterStatsGet method
type ClusterStatsGetQuery struct {
	// This parameter is used instead of the Accept header to select of non-JSON response content format.
	Format string
	Extra  map[string]string
}

// ToQueryString converts ClusterStatsGetQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *ClusterStatsGetQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Format != "" {
		values.Set("format", q.Format)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// ConfigGetQuery represents query parameters for ConfigGet method
type ConfigGetQuery struct {
	// This parameter is used instead of the Accept header to select of non-JSON response content format.
	Format string
	Extra  map[string]string
}

// ToQueryString converts ConfigGetQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *ConfigGetQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Format != "" {
		values.Set("format", q.Format)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// DvrsListQuery represents query parameters for DvrsList method
type DvrsListQuery struct {
	Cursor string
	Limit  int
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts DvrsListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *DvrsListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *DvrsListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// EpisodeGetQuery represents query parameters for EpisodeGet method
type EpisodeGetQuery struct {
	// Enables check of DVR presence on streamer for the episode.
	DvrPresenceCheck bool
	Extra            map[string]string
}

// ToQueryString converts EpisodeGetQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *EpisodeGetQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	values.Set("dvr_presence_check", strconv.FormatBool(q.DvrPresenceCheck))
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// EpisodesListQuery represents query parameters for EpisodesList method
type EpisodesListQuery struct {
	// Properly encoded analog of offset, allowing to read next bunch of items.  We do not offer common `offset` fields, use cursor for predictable fetching of quickly changing list of items. Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	Cursor string
	// Enables check of DVR presence on streamer for the episode.
	DvrPresenceCheck bool
	// Episode type
	EpisodeType string
	// Limit select count in collection to N elements.
	Limit int
	// Filter the collection by media name on which the episode is registered
	Media string
	// Client may ask to delay a response if there are no episodes to fetch. This should be used as a long-poll mechanism for lightweight fetching episodes from origin.
	PollTimeout int
	// Comma-separated list of fields (including nested) that will be returned.
	Select string
	Sort   string
	// Filter the collection by episode update time. This field is rather specific because it allows to have an update stream with new/updated episodes
	UpdatedAtGt int
	Extra       map[string]string
}

// ToQueryString converts EpisodesListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *EpisodesListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	values.Set("dvr_presence_check", strconv.FormatBool(q.DvrPresenceCheck))
	if q.EpisodeType != "" {
		values.Set("episode_type", q.EpisodeType)
	}
	if q.Limit != 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Media != "" {
		values.Set("media", q.Media)
	}
	if q.PollTimeout != 0 {
		values.Set("poll_timeout", strconv.Itoa(q.PollTimeout))
	}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.UpdatedAtGt != 0 {
		values.Set("updated_at_gt", strconv.Itoa(q.UpdatedAtGt))
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *EpisodesListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// ExternalEpisodesListQuery represents query parameters for ExternalEpisodesList method
type ExternalEpisodesListQuery struct {
	// Streamer may use this field to skip asking for dozens of very old episodes that were fetched some requests ago. For example: it may take sense to ask for episodes in the period from 2 days ago to 1 day ago. Everything older is not interesting and it takes too much time to fetch it.  Use this query option to fetch only required subset of episodes, reduce requested dataset to only required small amount.
	ClosedAtGt int
	Cursor     string
	Limit      int
	// Requested list of streams. If some stream is not returned, then all content for this will be erased.  If you cannot fetch this information for any reasons and not sure that you are ready to delete all old DVR for the requested stream, better fail with
	Media string
	// If you want to fetch episodes earlier than 1 day ago, you need to skip all new episodes, so you need those episodes, whose `opened_at` is in past, i.e. `less than = lt` then 1 day ago.  The meaning of this parameter is following: all episodes with `time =< opened_at` (opposite to requested) are very new and not interesting for the requester. Only old enough episodes with `opened_at` far in the past can be interesting to us.
	OpenedAtLt int
	Select     string
	Sort       string
	Extra      map[string]string
}

// ToQueryString converts ExternalEpisodesListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *ExternalEpisodesListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", fmt.Errorf("query is required")
	}
	if q.Media == "" {
		return "", fmt.Errorf("query parameter 'media' is required")
	}
	values := url.Values{}
	if q.ClosedAtGt != 0 {
		values.Set("closed_at_gt", strconv.Itoa(q.ClosedAtGt))
	}
	values.Set("media", q.Media)
	if q.OpenedAtLt != 0 {
		values.Set("opened_at_lt", strconv.Itoa(q.OpenedAtLt))
	}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *ExternalEpisodesListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// LoadBalancersListQuery represents query parameters for LoadBalancersList method
type LoadBalancersListQuery struct {
	// Properly encoded analog of offset, allowing to read next bunch of items. We do not offer common `offset` fields, use cursor for predictable fetching of quickly changing list of items. Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	Cursor string
	// Limit select count in collection to N elements.
	Limit int
	// Comma-separated list of fields (including nested) that will be returned.
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts LoadBalancersListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *LoadBalancersListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	if q.Limit != 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *LoadBalancersListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// PersonsListQuery represents query parameters for PersonsList method
type PersonsListQuery struct {
	// Properly encoded analog of offset, allowing to read next bunch of items.  We do not offer common `offset` fields, use please cursor for predictable fetching of quickly changing list of items. Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	Cursor string
	// Limit select count in collection to N elements.
	Limit int
	// Comma-separated list of fields (including nested) that will be returned.
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts PersonsListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *PersonsListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	if q.Limit != 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *PersonsListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// PreviewLayoutChangeForStreamConfigQuery represents query parameters for PreviewLayoutChangeForStreamConfig method
type PreviewLayoutChangeForStreamConfigQuery struct {
	Cursor string
	Limit  int
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts PreviewLayoutChangeForStreamConfigQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *PreviewLayoutChangeForStreamConfigQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *PreviewLayoutChangeForStreamConfigQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// PreviewLayoutChangeForStreamerConfigQuery represents query parameters for PreviewLayoutChangeForStreamerConfig method
type PreviewLayoutChangeForStreamerConfigQuery struct {
	Cursor string
	Limit  int
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts PreviewLayoutChangeForStreamerConfigQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *PreviewLayoutChangeForStreamerConfigQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *PreviewLayoutChangeForStreamerConfigQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// SrtPortResolveQuery represents query parameters for SrtPortResolve method
type SrtPortResolveQuery struct {
	// Configured mode of the listener, play or publish.  As SRT doesn't have any mandatory signalling in protocol: is this a play or a publish request, the pool of UDP ports has a mandatory configuration option: is it a play or a publish port.  When any connection is made to one of these ports, this mode is fetched from a configuration.
	Mode  string
	Extra map[string]string
}

// ToQueryString converts SrtPortResolveQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *SrtPortResolveQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", fmt.Errorf("query is required")
	}
	if q.Mode == "" {
		return "", fmt.Errorf("query parameter 'mode' is required")
	}
	values := url.Values{}
	values.Set("mode", q.Mode)
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// StreamLayoutsGetQuery represents query parameters for StreamLayoutsGet method
type StreamLayoutsGetQuery struct {
	// Get layouts created after this timestamp
	CreatedAtGt int
	// Get layouts created before this timestamp
	CreatedAtLt int
	// A properly encoded equivalent of offset allowing you to read the next bunch of items.  We do not offer common `offset` fields, so please use cursor for predictable fetching of quickly changing list of items.
	Cursor string
	// Limit the number of returned layouts
	Limit  int
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts StreamLayoutsGetQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *StreamLayoutsGetQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.CreatedAtGt != 0 {
		values.Set("created_at_gt", strconv.Itoa(q.CreatedAtGt))
	}
	if q.CreatedAtLt != 0 {
		values.Set("created_at_lt", strconv.Itoa(q.CreatedAtLt))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	if q.Limit != 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *StreamLayoutsGetQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// StreamerDynamicStreamsListQuery represents query parameters for StreamerDynamicStreamsList method
type StreamerDynamicStreamsListQuery struct {
	// Properly encoded analog of offset, allowing to read next bunch of items.  We do not offer common `offset` fields, use please cursor for predictable fetching of quickly changing list of items. Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	Cursor string
	Limit  int
	// Comma-separated expicitly passed list of stream names. Used to get configuration for the streams that were not listed in previous request without `name` field
	Name   string
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts StreamerDynamicStreamsListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *StreamerDynamicStreamsListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", fmt.Errorf("query is required")
	}
	if q.Name == "" {
		return "", fmt.Errorf("query parameter 'name' is required")
	}
	values := url.Values{}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	values.Set("name", q.Name)
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *StreamerDynamicStreamsListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// StreamerSaveQuery represents query parameters for StreamerSave method
type StreamerSaveQuery struct {
	// This flag enables some checks before saving streamer. List of checks:   - Central can reach the streamer (get its config);    If a request with `checks_enable=true` is sent,  then if at least one of the checks fails, the streamer will not be saved.
	ChecksEnable bool
	Extra        map[string]string
}

// ToQueryString converts StreamerSaveQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *StreamerSaveQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	values.Set("checks_enable", strconv.FormatBool(q.ChecksEnable))
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// StreamerStreamsListQuery represents query parameters for StreamerStreamsList method
type StreamerStreamsListQuery struct {
	// A properly encoded equivalent of offset allowing you to read the next bunch of items. We do not offer common `offset` fields, so please use cursor for predictable fetching of quickly changing list of items.
	Cursor string
	// Limit the number of records in the selected collection to N elements. Default value is 100
	Limit int
	// Search pattern for text fields like name, title, urls, etc.
	Q string
	// Comma-separated list of fields (including nested) that will be returned. Use `parent.child` notation to mention nested (child) fields.
	Select string
	// Composite sort direction. Specify field name(s) using comma `,` as a separator.  Default sorting order is alphabetical by `name`.  Place `-` before the field name to sort in reverse alphabetical order or descending.
	Sort  string
	Extra map[string]string
}

// ToQueryString converts StreamerStreamsListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *StreamerStreamsListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	if q.Limit != 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Q != "" {
		values.Set("q", q.Q)
	}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *StreamerStreamsListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// StreamerUpdateStreamsListQuery represents query parameters for StreamerUpdateStreamsList method
type StreamerUpdateStreamsListQuery struct {
	// Properly encoded analog of offset, allowing to read next bunch of items.  We do not offer common `offset` fields, use please cursor for predictable fetching of quickly changing list of items. Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	Cursor string
	Limit  int
	// Comma-separated exlpicitly passed list of stream names. Used to get configuration for the streams that were not listed in previous request without `name` field
	Name   string
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts StreamerUpdateStreamsListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *StreamerUpdateStreamsListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", fmt.Errorf("query is required")
	}
	if q.Name == "" {
		return "", fmt.Errorf("query parameter 'name' is required")
	}
	values := url.Values{}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	values.Set("name", q.Name)
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *StreamerUpdateStreamsListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// StreamersListQuery represents query parameters for StreamersList method
type StreamersListQuery struct {
	Cursor string
	Limit  int
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts StreamersListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *StreamersListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *StreamersListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// StreamsListQuery represents query parameters for StreamsList method
type StreamsListQuery struct {
	// client ip address which may be important for balancing
	ClientIp string
	// A properly encoded equivalent of offset allowing you to read the next bunch of items.  We do not offer common `offset` fields, so please use cursor for predictable fetching of quickly changing list of items.
	Cursor string
	// Set the parameter to true to get the layout.ingest_history field.
	IncludeIngestHistory bool
	// Limit the number of records in the selected collection to N elements. Default value is 100
	Limit int
	// Client may ask to delay a response if there are no streams matching the query yet. This parameter implements the long-polling mechanism, it defines the maximum waiting time in seconds until the request is completed.
	PollTimeout int
	// Search pattern for text fields like name, title, urls, etc.
	Q string
	// Which protocol was requested by client. Central will use the param to try adjust "streaming_endpoint" in the response if it possible. For example, if there are no streamers with configured "http" listeners, we'll return "https://" for requested "http" scheme.
	Scheme string
	// Comma-separated list of fields (including nested) that will be returned.  Use `parent.child` notation to mention nested (child) fields.
	Select string
	// Composite sort direction. Specify field name(s) using comma `,` as a separator.    Default sorting order is alphabetical by `name`.   Place `-` before the field name to sort in reverse alphabetical order or descending.
	Sort  string
	Extra map[string]string
}

// ToQueryString converts StreamsListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *StreamsListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.ClientIp != "" {
		values.Set("client_ip", q.ClientIp)
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	values.Set("include_ingest_history", strconv.FormatBool(q.IncludeIngestHistory))
	if q.Limit != 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.PollTimeout != 0 {
		values.Set("poll_timeout", strconv.Itoa(q.PollTimeout))
	}
	if q.Q != "" {
		values.Set("q", q.Q)
	}
	if q.Scheme != "" {
		values.Set("scheme", q.Scheme)
	}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *StreamsListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// BaseClientFactory is a factory function type for creating base HTTP clients.
type BaseClientFactory func(cfg *config.Config, apiURL string, authKey authorization.AuthKey) baseclient.BaseClient

// defaultBaseClientFactory creates a default base client instance.
func defaultBaseClientFactory(cfg *config.Config, apiURL string, authKey authorization.AuthKey) baseclient.BaseClient {
	return baseclient.New(cfg.HTTPClient, apiURL, authKey, cfg.Originator, cfg.Retry)
}

// Client is the concrete implementation of the Central interface.
type Client struct {
	base   baseclient.BaseClient
	apiURL string
}

// NewWithBaseFactory creates a new Central client with a custom base client factory.
// This is primarily used for testing or when custom HTTP client behavior is needed.
func NewWithBaseFactory(cfg *config.Config, baseFactory BaseClientFactory) (Central, error) {
	if cfg.Hostname == "" {
		return nil, fmt.Errorf("hostname is required")
	}

	if cfg.Protocol == "" {
		cfg.Protocol = "http"
	}

	if cfg.Port == 0 {
		if cfg.Protocol == "https" {
			cfg.Port = 443
		} else {
			cfg.Port = 80
		}
	}

	apiURL := fmt.Sprintf("%s://%s:%d", cfg.Protocol, cfg.Hostname, cfg.Port)

	var authKey authorization.AuthKey
	if cfg.Auth != nil {
		authKey = cfg.Auth
	} else if cfg.ClusterKey != "" {
		authKey = authorization.ClusterKey(cfg.ClusterKey)
	}

	if cfg.Originator == "" {
		cfg.Originator = config.DefaultOriginator
	}

	base := baseFactory(cfg, apiURL, authKey)

	return &Client{
		base:   base,
		apiURL: apiURL,
	}, nil
}

// New creates a new Central client with default settings.
func New(cfg *config.Config) (Central, error) {
	return NewWithBaseFactory(cfg, defaultBaseClientFactory)
}

// doGet performs a GET request and unmarshals the response into result.
func (c *Client) doGet(ctx context.Context, path string, result any) error {
	request, err := http.NewRequestWithContext(ctx, http.MethodGet, c.apiURL+path, http.NoBody)
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}
	request.Header.Set("Content-Type", "application/json")
	return c.base.Request(ctx, request, result)
}

// doPost performs a POST request with a JSON body and unmarshals the response into result.
func (c *Client) doPost(ctx context.Context, path string, body any, result any) error {
	bodyBytes, err := json.Marshal(body)
	if err != nil {
		return fmt.Errorf("failed to marshal request body: %w", err)
	}
	request, err := http.NewRequestWithContext(ctx, http.MethodPost, c.apiURL+path, bytes.NewBuffer(bodyBytes))
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}
	request.Header.Set("Content-Type", "application/json")
	return c.base.Request(ctx, request, result)
}

// doPut performs a PUT request with a JSON body and unmarshals the response into result.
func (c *Client) doPut(ctx context.Context, path string, body any, result any) error {
	bodyBytes, err := json.Marshal(body)
	if err != nil {
		return fmt.Errorf("failed to marshal request body: %w", err)
	}
	request, err := http.NewRequestWithContext(ctx, http.MethodPut, c.apiURL+path, bytes.NewBuffer(bodyBytes))
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}
	request.Header.Set("Content-Type", "application/json")
	return c.base.Request(ctx, request, result)
}

// doDelete performs a DELETE request.
func (c *Client) doDelete(ctx context.Context, path string) error {
	request, err := http.NewRequestWithContext(ctx, http.MethodDelete, c.apiURL+path, http.NoBody)
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}
	request.Header.Set("Content-Type", "application/json")
	return c.base.Request(ctx, request, nil)
}

// doList performs a GET request with query parameters and unmarshals the response into result.
func (c *Client) doList(ctx context.Context, path string, query interface{ ToQueryString() (string, error) }, result any) error {
	if query == nil {
		request, err := http.NewRequestWithContext(ctx, http.MethodGet, c.apiURL+path, http.NoBody)
		if err != nil {
			return fmt.Errorf("failed to create request: %w", err)
		}
		request.Header.Set("Content-Type", "application/json")
		return c.base.Request(ctx, request, result)
	}
	queryString, err := query.ToQueryString()
	if err != nil {
		return fmt.Errorf("failed to build query string: %w", err)
	}
	requestURL := c.apiURL + path
	if queryString != "" {
		requestURL += "?" + queryString
	}
	request, err := http.NewRequestWithContext(ctx, http.MethodGet, requestURL, http.NoBody)
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}
	request.Header.Set("Content-Type", "application/json")
	return c.base.Request(ctx, request, result)
}

// AgentDelete Delete Agent
// Agent and corresponding camera(s) will be permanently deleted from the system.
func (c *Client) AgentDelete(ctx context.Context, id string) error {
	path := fmt.Sprintf("/central/api/v3/agents/%s", id)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// AgentDisconnect Disconnect Agent
// Disconnect the Agent by the Agent ID.
func (c *Client) AgentDisconnect(ctx context.Context, id string) error {
	path := fmt.Sprintf("/central/api/v3/agents/%s/disconnect", id)
	if err := c.doPost(ctx, path, nil, nil); err != nil {
		return err
	}
	return nil
}

// AgentGet Get one Agent
// The method allows you to fetch a single Agent.  The returned data are the same as for `agents_list` operation.
func (c *Client) AgentGet(ctx context.Context, id string) (model.CentralAgentConfig, error) {
	path := fmt.Sprintf("/central/api/v3/agents/%s", id)
	result := &model.CentralAgentConfigImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// AgentLogsGet Get logs from Agent
// The method allows you to fetch logs from online Agent.
func (c *Client) AgentLogsGet(ctx context.Context, id string) (model.WatcherAgentLogs, error) {
	path := fmt.Sprintf("/central/api/v3/agents/%s/logs", id)
	result := &model.WatcherAgentLogsImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// AgentReboot Reboot Agent
// Reboot the Agent by the Agent ID.
func (c *Client) AgentReboot(ctx context.Context, id string) error {
	path := fmt.Sprintf("/central/api/v3/agents/%s/reboot", id)
	if err := c.doPost(ctx, path, nil, nil); err != nil {
		return err
	}
	return nil
}

// AgentReset Reset Agent
// Reset the Agent by the Agent ID.
func (c *Client) AgentReset(ctx context.Context, id string) error {
	path := fmt.Sprintf("/central/api/v3/agents/%s/reset", id)
	if err := c.doPost(ctx, path, nil, nil); err != nil {
		return err
	}
	return nil
}

// AgentSave Save Agent
// Save the Agent parameters by the Agent ID.
func (c *Client) AgentSave(ctx context.Context, id string, body model.CentralAgentConfig) (model.CentralAgentConfig, error) {
	path := fmt.Sprintf("/central/api/v3/agents/%s", id)
	result := &model.CentralAgentConfigImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// AgentsList List Agents
// The list of configured and provisioned Agents, i.e. Agents that connected to your server at least once.
func (c *Client) AgentsList(ctx context.Context, query *AgentsListQuery) (model.CentralAgentsList, error) {
	path := "/central/api/v3/agents"
	result := &model.CentralAgentsListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// AgentsListIterator iterates through all CentralAgentConfig items using cursor pagination.
func (c *Client) AgentsListIterator(ctx context.Context, query *AgentsListQuery) iter.Seq2[model.CentralAgentConfig, error] {
	return cursors.Iterator(ctx, c.AgentsList, query)
}

// ApiTokenGet Get one API Token
// Method allows to fetch single API token by name
func (c *Client) ApiTokenGet(ctx context.Context, name string) (model.APIToken, error) {
	path := fmt.Sprintf("/central/api/v3/api_tokens/%s", name)
	result := &model.APITokenImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// ApiTokenSave Save API Token
// Create a new API token or update an existing one by name.
func (c *Client) ApiTokenSave(ctx context.Context, name string, body model.APIToken) (model.APIToken, error) {
	path := fmt.Sprintf("/central/api/v3/api_tokens/%s", name)
	result := &model.APITokenImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// ApiTokensList List API tokens
// Method allows to fetch configured API tokens
func (c *Client) ApiTokensList(ctx context.Context, query *ApiTokensListQuery) (model.APITokensList, error) {
	path := "/central/api/v3/api_tokens"
	result := &model.APITokensListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// ApiTokensListIterator iterates through all APIToken items using cursor pagination.
func (c *Client) ApiTokensListIterator(ctx context.Context, query *ApiTokensListQuery) iter.Seq2[model.APIToken, error] {
	return cursors.Iterator(ctx, c.ApiTokensList, query)
}

// AuthBackendDelete Delete the auth backend
// Delete the authorization backend by its name.
func (c *Client) AuthBackendDelete(ctx context.Context, name string) error {
	path := fmt.Sprintf("/central/api/v3/auth_backends/%s", name)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// AuthBackendGet Get the auth backend
// This method allows to get a single authorization backend.
func (c *Client) AuthBackendGet(ctx context.Context, name string) (model.AuthBackendConfig, error) {
	path := fmt.Sprintf("/central/api/v3/auth_backends/%s", name)
	result := &model.AuthBackendConfigImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// AuthBackendSave Save the auth backend
// Create or update an authorization backend.  If you pass only a partial configuration, only the passed fields will be updated.
func (c *Client) AuthBackendSave(ctx context.Context, name string, body model.AuthBackendConfig) (model.AuthBackendConfig, error) {
	path := fmt.Sprintf("/central/api/v3/auth_backends/%s", name)
	result := &model.AuthBackendConfigImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// AuthBackendsList List auth backends
// This method allows to get the list of all authorization backends configured in Flussonic.
func (c *Client) AuthBackendsList(ctx context.Context, query *AuthBackendsListQuery) (model.AuthBackendsList, error) {
	path := "/central/api/v3/auth_backends"
	result := &model.AuthBackendsListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// AuthBackendsListIterator iterates through all AuthBackendConfig items using cursor pagination.
func (c *Client) AuthBackendsListIterator(ctx context.Context, query *AuthBackendsListQuery) iter.Seq2[model.AuthBackendConfig, error] {
	return cursors.Iterator(ctx, c.AuthBackendsList, query)
}

// AuthRequest Play session authorization
// This method describes what Flussonic sends to an authorization backend for playing session and what it awaits as a response.
func (c *Client) AuthRequest(ctx context.Context, query *AuthRequestQuery) (model.AuthResponseV1, error) {
	path := "/central/api/v3/auth"
	result := &model.AuthResponseV1Impl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// BatchStreamLayoutPreview Dry run layouter for batch of changed stream configurations
// This method allows you to see how the overall layout will change due to changes in the configurations of multiple streams. Note that if [Layouter](https://flussonic.com/doc/api/layouter/) is [disabled](https://flussonic.com/doc/api/central/#tag/config/operation/config_save%7Cbody%7Clayouter_enabled), this method will return an error.
func (c *Client) BatchStreamLayoutPreview(ctx context.Context, query *BatchStreamLayoutPreviewQuery, body any) (model.CentralStreamLayoutPrediction, error) {
	path := "/central/api/v3/streams/preview_layout_change"
	result := &model.CentralStreamLayoutPredictionImpl{}
	if err := c.doPost(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// BatchStreamLayoutPreviewIterator iterates through all CentralStreamLayoutListItem items using cursor pagination.
func (c *Client) BatchStreamLayoutPreviewIterator(ctx context.Context, query *BatchStreamLayoutPreviewQuery, body any) iter.Seq2[model.CentralStreamLayoutListItem, error] {
	return cursors.Iterator(ctx, func(ctx context.Context, query *BatchStreamLayoutPreviewQuery) (model.CentralStreamLayoutPrediction, error) {
		return c.BatchStreamLayoutPreview(ctx, query, body)
	}, query)
}

// BatchStreamerLayoutPreview Dry run layouter for batch of changed streamer configurations
// This method allows you to see how the overall layout will be changed due to changes in the configurations of multiple streamers. Note that if [Layouter](https://flussonic.com/doc/api/layouter/) is [disabled](https://flussonic.com/doc/api/central/#tag/config/operation/config_save%7Cbody%7Clayouter_enabled), this method will return an error.
func (c *Client) BatchStreamerLayoutPreview(ctx context.Context, query *BatchStreamerLayoutPreviewQuery, body any) (model.CentralStreamerLayoutPrediction, error) {
	path := "/central/api/v3/streamers/preview_layout_change"
	result := &model.CentralStreamerLayoutPredictionImpl{}
	if err := c.doPost(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// BatchStreamerLayoutPreviewIterator iterates through all CentralStreamerLayoutPredictionItem items using cursor pagination.
func (c *Client) BatchStreamerLayoutPreviewIterator(ctx context.Context, query *BatchStreamerLayoutPreviewQuery, body any) iter.Seq2[model.CentralStreamerLayoutPredictionItem, error] {
	return cursors.Iterator(ctx, func(ctx context.Context, query *BatchStreamerLayoutPreviewQuery) (model.CentralStreamerLayoutPrediction, error) {
		return c.BatchStreamerLayoutPreview(ctx, query, body)
	}, query)
}

// BatchUpdateAgentsLayouts Batch update layouts of agents
// Batch update layouts of agents. This operation does everything or nothing. Only agents without streams will be processed, other ones would be ignored. If at least one agent has an invalid configuration or can't be processed, the request will fail.
func (c *Client) BatchUpdateAgentsLayouts(ctx context.Context, body model.CentralAgentLayoutList) error {
	path := "/central/api/v3/agents/layouts"
	if err := c.doPost(ctx, path, body, nil); err != nil {
		return err
	}
	return nil
}

// BatchUpdateStreamsLayouts Batch update layouts of streams
// Batch update layouts of streams. This operation does everything or nothing.  If at least one stream has an invalid configuration or can't be processed, the request will fail.
func (c *Client) BatchUpdateStreamsLayouts(ctx context.Context, body model.CentralStreamLayoutList) error {
	path := "/central/api/v3/streams/layouts"
	if err := c.doPost(ctx, path, body, nil); err != nil {
		return err
	}
	return nil
}

// CentralEventsList Get events of Central
// This method allows to get the batch of events. Currently this method is not implemented yet. However, its schema can be used for understanding Central logging.
func (c *Client) CentralEventsList(ctx context.Context, query *CentralEventsListQuery) (model.CentralEventsList, error) {
	path := "/central/api/v3/events"
	result := &model.CentralEventsListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// CentralEventsListIterator iterates through all CentralEvent items using cursor pagination.
func (c *Client) CentralEventsListIterator(ctx context.Context, query *CentralEventsListQuery) iter.Seq2[model.CentralEvent, error] {
	return cursors.Iterator(ctx, c.CentralEventsList, query)
}

// ClusterStatsGet Get current health of cluster
// This method allows you to fetch cluster's health
func (c *Client) ClusterStatsGet(ctx context.Context, query *ClusterStatsGetQuery) (model.ClusterHealthStats, error) {
	path := "/central/api/v3/cluster/stats"
	result := &model.ClusterHealthStatsImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// ConfigGet Get configuration and stats of Central
// This method allows you to fetch Central configuration and stats
func (c *Client) ConfigGet(ctx context.Context, query *ConfigGetQuery) (model.CentralConfig, error) {
	path := "/central/api/v3/config"
	result := &model.CentralConfigImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// ConfigSave Update central configuration
// This method allows you to update central configuration. Calling this method will update config file but will not change the env.
func (c *Client) ConfigSave(ctx context.Context, body model.CentralConfig) (model.CentralConfig, error) {
	path := "/central/api/v3/config"
	result := &model.CentralConfigImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// DvrsList List of DVR configurations
// This method allows to get the whole list of global DVR congifurations.
func (c *Client) DvrsList(ctx context.Context, query *DvrsListQuery) (model.CentralDvrsList, error) {
	path := "/central/api/v3/dvrs"
	result := &model.CentralDvrsListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// DvrsListIterator iterates through all CentralDvrConfig items using cursor pagination.
func (c *Client) DvrsListIterator(ctx context.Context, query *DvrsListQuery) iter.Seq2[model.CentralDvrConfig, error] {
	return cursors.Iterator(ctx, c.DvrsList, query)
}

// EpisodeDelete Delete the Episode
// This method allows you to delete an episode
func (c *Client) EpisodeDelete(ctx context.Context, episode_id string) error {
	path := fmt.Sprintf("/central/api/v3/episodes/%s", episode_id)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// EpisodeGet Get the episode
// This method allows you to fetch the episode by its identifier
func (c *Client) EpisodeGet(ctx context.Context, episode_id string, query *EpisodeGetQuery) (model.Episode, error) {
	path := fmt.Sprintf("/central/api/v3/episodes/%s", episode_id)
	result := &model.EpisodeImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// EpisodeSave Save the Episode
// This method allows you to create a new episode or update attributes of the existing one
func (c *Client) EpisodeSave(ctx context.Context, episode_id string, body model.Episode) (model.Episode, error) {
	path := fmt.Sprintf("/central/api/v3/episodes/%s", episode_id)
	result := &model.EpisodeImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// EpisodesList List episodes
// This method allows you to fetch registered episodes
func (c *Client) EpisodesList(ctx context.Context, query *EpisodesListQuery) (model.EpisodesList, error) {
	path := "/central/api/v3/episodes"
	result := &model.EpisodesListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// EpisodesListIterator iterates through all Episode items using cursor pagination.
func (c *Client) EpisodesListIterator(ctx context.Context, query *EpisodesListQuery) iter.Seq2[model.Episode, error] {
	return cursors.Iterator(ctx, c.EpisodesList, query)
}

// ExternalEpisodesList External episodes
// This method will return episodes for selected streams that should be  left on disk during DVR cleaning process.
func (c *Client) ExternalEpisodesList(ctx context.Context, hostname string, query *ExternalEpisodesListQuery) (model.ExternalEpisodesList, error) {
	path := fmt.Sprintf("/central/api/v3/streamers/%s/episodes", hostname)
	result := &model.ExternalEpisodesListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// ExternalEpisodesListIterator iterates through all ExternalEpisode items using cursor pagination.
func (c *Client) ExternalEpisodesListIterator(ctx context.Context, hostname string, query *ExternalEpisodesListQuery) iter.Seq2[model.ExternalEpisode, error] {
	return cursors.Iterator(ctx, func(ctx context.Context, query *ExternalEpisodesListQuery) (model.ExternalEpisodesList, error) {
		return c.ExternalEpisodesList(ctx, hostname, query)
	}, query)
}

// LivenessProbe Liveness probe
// K8s liveness probe.
func (c *Client) LivenessProbe(ctx context.Context) (model.ServerStatsWhoami, error) {
	path := "/central/api/v3/monitoring/liveness"
	result := &model.ServerStatsWhoamiImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// LoadBalancerDelete Delete the Load Balancer
// This method allows you to delete a load balancer
func (c *Client) LoadBalancerDelete(ctx context.Context, name string) error {
	path := fmt.Sprintf("/central/api/v3/load-balancers/%s", name)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// LoadBalancerGet Get the load balancer
// This method allows you to fetch the load balancer by its name
func (c *Client) LoadBalancerGet(ctx context.Context, name string) (model.BalancerConfig, error) {
	path := fmt.Sprintf("/central/api/v3/load-balancers/%s", name)
	result := &model.BalancerConfigImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// LoadBalancerSave Save the Load Balancer
// This method allows you to create a new load balancer or update attributes of the existing one
func (c *Client) LoadBalancerSave(ctx context.Context, name string, body model.BalancerConfig) (model.BalancerConfig, error) {
	path := fmt.Sprintf("/central/api/v3/load-balancers/%s", name)
	result := &model.BalancerConfigImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// LoadBalancersList List load balancers
// This method allows you to fetch registered load balancers.  Load balancers are used in [streaming api](https://flussonic.com/doc/api/central/#tag/streaming).
func (c *Client) LoadBalancersList(ctx context.Context, query *LoadBalancersListQuery) (model.BalancersList, error) {
	path := "/central/api/v3/load-balancers"
	result := &model.BalancersListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// LoadBalancersListIterator iterates through all BalancerConfig items using cursor pagination.
func (c *Client) LoadBalancersListIterator(ctx context.Context, query *LoadBalancersListQuery) iter.Seq2[model.BalancerConfig, error] {
	return cursors.Iterator(ctx, c.LoadBalancersList, query)
}

// PersonDelete Delete the Person
// This method allows you to delete the person by its identifier
func (c *Client) PersonDelete(ctx context.Context, person_id string) error {
	path := fmt.Sprintf("/central/api/v3/persons/%s", person_id)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// PersonGet Get the Person
// This method allows you to fetch the person by its identifier
func (c *Client) PersonGet(ctx context.Context, person_id string) (model.VisionPerson, error) {
	path := fmt.Sprintf("/central/api/v3/persons/%s", person_id)
	result := &model.VisionPersonImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// PersonSave Save the Person
// This method allows you to create a new person or update attributes of the existing one
func (c *Client) PersonSave(ctx context.Context, person_id string, body model.VisionPerson) (model.VisionPerson, error) {
	path := fmt.Sprintf("/central/api/v3/persons/%s", person_id)
	result := &model.VisionPersonImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// PersonsList List Persons
// The list of registered videoanalytics persons
func (c *Client) PersonsList(ctx context.Context, query *PersonsListQuery) (model.VisionPersonsList, error) {
	path := "/central/api/v3/persons"
	result := &model.VisionPersonsListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// PersonsListIterator iterates through all VisionPerson items using cursor pagination.
func (c *Client) PersonsListIterator(ctx context.Context, query *PersonsListQuery) iter.Seq2[model.VisionPerson, error] {
	return cursors.Iterator(ctx, c.PersonsList, query)
}

// PreviewLayoutChangeForStreamConfig Dry run layouter for changed stream configuration
// This method allows you to see how the overall layout will be changed due to changes into stream configuration. Note that if [Layouter](https://flussonic.com/doc/api/layouter/) is [disabled](https://flussonic.com/doc/api/central/#tag/config/operation/config_save%7Cbody%7Clayouter_enabled), this method will return an error.
func (c *Client) PreviewLayoutChangeForStreamConfig(ctx context.Context, name string, query *PreviewLayoutChangeForStreamConfigQuery, body model.CentralStreamConfig) (model.CentralStreamLayoutPrediction, error) {
	path := fmt.Sprintf("/central/api/v3/streams/%s/preview_layout_change", name)
	result := &model.CentralStreamLayoutPredictionImpl{}
	if err := c.doPost(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// PreviewLayoutChangeForStreamConfigIterator iterates through all CentralStreamLayoutListItem items using cursor pagination.
func (c *Client) PreviewLayoutChangeForStreamConfigIterator(ctx context.Context, name string, query *PreviewLayoutChangeForStreamConfigQuery, body model.CentralStreamConfig) iter.Seq2[model.CentralStreamLayoutListItem, error] {
	return cursors.Iterator(ctx, func(ctx context.Context, query *PreviewLayoutChangeForStreamConfigQuery) (model.CentralStreamLayoutPrediction, error) {
		return c.PreviewLayoutChangeForStreamConfig(ctx, name, query, body)
	}, query)
}

// PreviewLayoutChangeForStreamerConfig Dry run layouter for changed streamer configuration
// This method allows you to see how the overall layout will be changed due to changes into streamer configuration. Note that if [Layouter](https://flussonic.com/doc/api/layouter/) is [disabled](https://flussonic.com/doc/api/central/#tag/config/operation/config_save%7Cbody%7Clayouter_enabled), this method will return an error.
func (c *Client) PreviewLayoutChangeForStreamerConfig(ctx context.Context, hostname string, query *PreviewLayoutChangeForStreamerConfigQuery, body model.StreamerConfig) (model.CentralStreamerLayoutPrediction, error) {
	path := fmt.Sprintf("/central/api/v3/streamers/%s/preview_layout_change", hostname)
	result := &model.CentralStreamerLayoutPredictionImpl{}
	if err := c.doPost(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// PreviewLayoutChangeForStreamerConfigIterator iterates through all CentralStreamerLayoutPredictionItem items using cursor pagination.
func (c *Client) PreviewLayoutChangeForStreamerConfigIterator(ctx context.Context, hostname string, query *PreviewLayoutChangeForStreamerConfigQuery, body model.StreamerConfig) iter.Seq2[model.CentralStreamerLayoutPredictionItem, error] {
	return cursors.Iterator(ctx, func(ctx context.Context, query *PreviewLayoutChangeForStreamerConfigQuery) (model.CentralStreamerLayoutPrediction, error) {
		return c.PreviewLayoutChangeForStreamerConfig(ctx, hostname, query, body)
	}, query)
}

// ReadinessProbe Readiness probe
// K8s readiness probe.
func (c *Client) ReadinessProbe(ctx context.Context) (model.ServerStatsWhoami, error) {
	path := "/central/api/v3/monitoring/readiness"
	result := &model.ServerStatsWhoamiImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// SrtPortResolve UDP port to stream name
// This API method will be called to find stream name by the port which received srt connection.  SRT protocol has two modes: when no stream name is passed in protocol, or when it is passed, but only if passwords match on both sides.  So you cannot rely on a stream name, because it is either not passed, either is password protected.  When you build a cloud, you cannot offer the same password to all clients, because it is just the same like without password.  This method allows some dynamic configuration when you wait for a client on a pool of servers on a fixed UDP port. When connection comes (publish/ingress of play/egress), your configuration backend will be called for resolving this UDP port to a stream configuration. Streamer will find out what is the name of the stream, its password and all other settings.
func (c *Client) SrtPortResolve(ctx context.Context, hostname string, port string, query *SrtPortResolveQuery) (any, error) {
	path := fmt.Sprintf("/central/api/v3/streamers/%s/srt_port_resolve/%s", hostname, port)
	var result any
	if err := c.doList(ctx, path, query, nil); err != nil {
		return nil, err
	}
	return result, nil
}

// StreamDelete Delete stream
// The stream will be permanently deleted from the project.
func (c *Client) StreamDelete(ctx context.Context, name string) error {
	path := fmt.Sprintf("/central/api/v3/streams/%s", name)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// StreamGet Get one stream
// This method allows you to fetch a single stream.  The data returned in this method are the same as for `streams_list` operation.
func (c *Client) StreamGet(ctx context.Context, name string) (model.CentralStreamConfig, error) {
	path := fmt.Sprintf("/central/api/v3/streams/%s", name)
	result := &model.CentralStreamConfigImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// StreamLayoutsGet Get layouts of stream
// This method allows you to fetch stream layouts list
func (c *Client) StreamLayoutsGet(ctx context.Context, name string, query *StreamLayoutsGetQuery) (model.CentralStreamLayouts, error) {
	path := fmt.Sprintf("/central/api/v3/streams/%s/layouts", name)
	result := &model.CentralStreamLayoutsImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// StreamLayoutsGetIterator iterates through all CentralStreamLayout items using cursor pagination.
func (c *Client) StreamLayoutsGetIterator(ctx context.Context, name string, query *StreamLayoutsGetQuery) iter.Seq2[model.CentralStreamLayout, error] {
	return cursors.Iterator(ctx, func(ctx context.Context, query *StreamLayoutsGetQuery) (model.CentralStreamLayouts, error) {
		return c.StreamLayoutsGet(ctx, name, query)
	}, query)
}

// StreamSave Save stream
// Create or update a stream by its name. If the stream doesn't exists in the disk config, it will be created.  If you pass only a partial stream configuration, just the passed field(s) will be updated, not the whole stream.  To create a new stream the property `name` is required.  Pass the `"$reset": true` option to replace the stream configuration with the provided one.
func (c *Client) StreamSave(ctx context.Context, name string, body model.CentralStreamConfig) (model.CentralStreamConfig, error) {
	path := fmt.Sprintf("/central/api/v3/streams/%s", name)
	result := &model.CentralStreamConfigImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// StreamerDelete Delete the streamer
// Delete the streamer by its hostname.
func (c *Client) StreamerDelete(ctx context.Context, hostname string) error {
	path := fmt.Sprintf("/central/api/v3/streamers/%s", hostname)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// StreamerDynamicStreamsList Get dynamic streams for streamer
// This API method will be called to fetch list of streams configurations for newly requested by user streams.  If you do not send a configuration of any stream named in `name` query parameter, it will be considered as an unknown and terminated immediately
func (c *Client) StreamerDynamicStreamsList(ctx context.Context, hostname string, query *StreamerDynamicStreamsListQuery) (model.StreamsList, error) {
	path := fmt.Sprintf("/central/api/v3/streamers/%s/dynamic-streams", hostname)
	result := &model.StreamsListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// StreamerDynamicStreamsListIterator iterates through all StreamConfig items using cursor pagination.
func (c *Client) StreamerDynamicStreamsListIterator(ctx context.Context, hostname string, query *StreamerDynamicStreamsListQuery) iter.Seq2[model.StreamConfig, error] {
	return cursors.Iterator(ctx, func(ctx context.Context, query *StreamerDynamicStreamsListQuery) (model.StreamsList, error) {
		return c.StreamerDynamicStreamsList(ctx, hostname, query)
	}, query)
}

// StreamerGet Get the streamer
// This method allows you to fetch the main parameters and current metrics of a single streamer
func (c *Client) StreamerGet(ctx context.Context, hostname string) (model.StreamerConfig, error) {
	path := fmt.Sprintf("/central/api/v3/streamers/%s", hostname)
	result := &model.StreamerConfigImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// StreamerSave Save the streamer
// This method will either create a new streamer (if there is no streamer with the hostname specified in the request), or update the existing streamer having the specified hostname.
func (c *Client) StreamerSave(ctx context.Context, hostname string, query *StreamerSaveQuery, body model.StreamerConfig) (model.StreamerConfig, error) {
	path := fmt.Sprintf("/central/api/v3/streamers/%s", hostname)
	result := &model.StreamerConfigImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// StreamerStreamsList Get streams for streamer
// Return list of configured streams for the streamer
func (c *Client) StreamerStreamsList(ctx context.Context, hostname string, query *StreamerStreamsListQuery) (model.StreamsList, error) {
	path := fmt.Sprintf("/central/api/v3/streamers/%s/streams", hostname)
	result := &model.StreamsListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// StreamerStreamsListIterator iterates through all StreamConfig items using cursor pagination.
func (c *Client) StreamerStreamsListIterator(ctx context.Context, hostname string, query *StreamerStreamsListQuery) iter.Seq2[model.StreamConfig, error] {
	return cursors.Iterator(ctx, func(ctx context.Context, query *StreamerStreamsListQuery) (model.StreamsList, error) {
		return c.StreamerStreamsList(ctx, hostname, query)
	}, query)
}

// StreamerUpdateStreamsList Get update streams for streamer
// This API method will be called to fetch list of streams configurations.  Streamer will send here list of streams that were not enumerated in `streams_list` response.  Use this to shutdown unknown streams or dynamically configure streams.  If you do not send a configuration of any stream named in `name` query parameter, it will be considered as an unknown and terminated immediately
func (c *Client) StreamerUpdateStreamsList(ctx context.Context, hostname string, query *StreamerUpdateStreamsListQuery) (model.StreamsList, error) {
	path := fmt.Sprintf("/central/api/v3/streamers/%s/update-streams", hostname)
	result := &model.StreamsListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// StreamerUpdateStreamsListIterator iterates through all StreamConfig items using cursor pagination.
func (c *Client) StreamerUpdateStreamsListIterator(ctx context.Context, hostname string, query *StreamerUpdateStreamsListQuery) iter.Seq2[model.StreamConfig, error] {
	return cursors.Iterator(ctx, func(ctx context.Context, query *StreamerUpdateStreamsListQuery) (model.StreamsList, error) {
		return c.StreamerUpdateStreamsList(ctx, hostname, query)
	}, query)
}

// StreamersBatchUpdate Batch update streamers
// This method allows you to update multiple streamers in a single request. This operation does everything or nothing.  If at least one streamer has an invalid configuration or can't be processed, the request will fail.  The request body should contain an array of streamer objects with the fields to be updated. The update is applied using [JSON Merge Patch](https://tools.ietf.org/html/rfc7386) semantics.  If a streamer does not exist, it will be created with the provided configuration.
func (c *Client) StreamersBatchUpdate(ctx context.Context, body any) error {
	path := "/central/api/v3/streamers/batch"
	if err := c.doPut(ctx, path, body, nil); err != nil {
		return err
	}
	return nil
}

// StreamersList List streamers
// Returns the list of all streamers with main parameters and current metric values.
func (c *Client) StreamersList(ctx context.Context, query *StreamersListQuery) (model.StreamersList, error) {
	path := "/central/api/v3/streamers"
	result := &model.StreamersListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// StreamersListIterator iterates through all StreamerConfig items using cursor pagination.
func (c *Client) StreamersListIterator(ctx context.Context, query *StreamersListQuery) iter.Seq2[model.StreamerConfig, error] {
	return cursors.Iterator(ctx, c.StreamersList, query)
}

// StreamingLbPlayback Playback load balance
// This method allows you to play a stream from the least loaded media server.
func (c *Client) StreamingLbPlayback(ctx context.Context, loadbalancer_name string, escaped_stream_name string, multi_segment_suffix string) (any, error) {
	path := fmt.Sprintf("/central/api/v3/lb/%s/%s/%s", loadbalancer_name, escaped_stream_name, multi_segment_suffix)
	var result any
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// StreamingLbPublish Publish load balance
// This method allows to publish the stream to the least loaded media server.
func (c *Client) StreamingLbPublish(ctx context.Context, loadbalancer_name string, escaped_stream_name string, multi_segment_suffix string) error {
	path := fmt.Sprintf("/central/api/v3/lb/%s/%s/%s", loadbalancer_name, escaped_stream_name, multi_segment_suffix)
	if err := c.doPost(ctx, path, nil, nil); err != nil {
		return err
	}
	return nil
}

// StreamsBatchUpdate Batch update streams
// This method allows you to update multiple streams in a single request. This operation does everything or nothing.  If at least one stream has an invalid configuration or can't be processed, the request will fail.  The request body should contain an array of stream objects with the fields to be updated. The update is applied using [JSON Merge Patch](https://tools.ietf.org/html/rfc7386) semantics.  If a stream does not exist, it will be created with the provided configuration.
func (c *Client) StreamsBatchUpdate(ctx context.Context, body any) error {
	path := "/central/api/v3/streams/batch"
	if err := c.doPut(ctx, path, body, nil); err != nil {
		return err
	}
	return nil
}

// StreamsList List streams
// This API method is one of the most important in whole API, because it gives the list of all streams, including:  * configured (maybe not running at the moment) * running (including those that are created via template and do not have own disk configuration) * remote (available from other servers) * only recorded  You can pass any stream configuration options to the `q` query string for filtering,  not only those specified in the `select` parameters.  This method, as well as `stream_get`, will return the **effective stream configuration** with all templates, defaults included into the response. It is not exactly what you can see in your disk config. If you have configured this stream in disk file, then the original disk configuration can be found in the `config_on_disk` field.  Thus, what you get from this API call may differ from what you write to `stream_save` which is another important method for managing streams.
func (c *Client) StreamsList(ctx context.Context, query *StreamsListQuery) (model.CentralStreamsList, error) {
	path := "/central/api/v3/streams"
	result := &model.CentralStreamsListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// StreamsListIterator iterates through all CentralStreamConfig items using cursor pagination.
func (c *Client) StreamsListIterator(ctx context.Context, query *StreamsListQuery) iter.Seq2[model.CentralStreamConfig, error] {
	return cursors.Iterator(ctx, c.StreamsList, query)
}
