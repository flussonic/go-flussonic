// Code generated by cmd/main. DO NOT EDIT.
package visioninference

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"iter"
	"net/http"
	"net/url"
	"strconv"
	"strings"

	"github.com/flussonic/go-flussonic/authorization"
	"github.com/flussonic/go-flussonic/config"
	"github.com/flussonic/go-flussonic/internal/baseclient"
	"github.com/flussonic/go-flussonic/internal/cursors"
	model "github.com/flussonic/go-flussonic/vision-inference/model"
)

// VisionInference defines the interface for interacting with VisionInference API.
type VisionInference interface {
	// ConfigGet Get configuration
	// Returns the current configuration of the analytics modules at your server.
	ConfigGet(ctx context.Context) (model.ConfigVision, error)
	// CounterRecordsList Counter records list
	// The returned list includes records of counters of all types, i.e. humans, vehicles, etc. Each record represents aggregated metrics within some timeframe, a minute for instance. Specify a set of collection filters (such as media, region, period of time) to pick records of interest.
	CounterRecordsList(ctx context.Context, query *CounterRecordsListQuery) (model.CounterRecordsList, error)
	// CounterRecordsListIterator iterates through all items using cursor pagination
	CounterRecordsListIterator(ctx context.Context, query *CounterRecordsListQuery) iter.Seq2[model.VisionCounterRecord, error]
	// EpisodesList Episodes list
	// Your client application shall make this long poll request to Inference node(s).  The request returns the list of episodes registered during operation on your server.  How to make long poll:  * Set `poll_timeout` and `updated_at_gt` in the query. * The episodes that match the `updated_at_gt` filter will be returned instantly (as in a regular request). * If there are no such episodes, the connection will last `poll_timeout` seconds. * If during this connection interval an episode appears that matches the `updated_at_gt` filter,  it is returned immediately.  The returned list includes all episodes, i.e. license plate recognition (LPR), face detection, etc. LPR results can be used right away while  face episodes shall be passed to the Identification service via `episodes_identify`  in order to match face fingerprints against the face database.  There may be several Inference nodes and one Identification service  to ensure that the same face is recognized on all your cameras.  Request all your Inference nodes before supplying the result to Identification.
	EpisodesList(ctx context.Context, query *EpisodesListQuery) (model.EpisodesList, error)
	// EpisodesListIterator iterates through all items using cursor pagination
	EpisodesListIterator(ctx context.Context, query *EpisodesListQuery) iter.Seq2[model.Episode, error]
	// LivenessProbe Liveness probe
	// Liveness probe.
	LivenessProbe(ctx context.Context) (model.VisionServerInfo, error)
	// MetricsGet Prometheus metrics
	// Provides endpoint for Prometheus scraper. Each record represents per-stream metrics.   Additionally there is a bunch of per-worker records containing aggregation of metrics of streams served by this worker.   Per-worker metrics are marked with `media=all` attribute.  JSON representation of metrics is not implemented.   Its schema can be used for getting the list of metrics with descriptions for reference
	MetricsGet(ctx context.Context) (model.VisionMetrics, error)
	// Process Image analysis
	// Analyzes the supplied image. Detects objects and computes digital fingerprints of the detected objects (if fingerprints are supported for the object type).
	Process(ctx context.Context) (model.VisionProcessResult, error)
	// StatsGet Server info and runtime stats
	// Provides information about running instance such as version, available hardware and utilization
	StatsGet(ctx context.Context) (model.VisionWorkerStats, error)
	// StreamsList List streams
	// This API method allows to get information about streams being processed by the server.
	StreamsList(ctx context.Context, query *StreamsListQuery) (model.StreamsList, error)
	// StreamsListIterator iterates through all items using cursor pagination
	StreamsListIterator(ctx context.Context, query *StreamsListQuery) iter.Seq2[model.StreamConfig, error]
}

// CounterRecordsListQuery represents query parameters for CounterRecordsList method
type CounterRecordsListQuery struct {
	Cursor string
	Limit  int
	// Filter results by stream name on which the counter is acting.
	Media string
	// Filter results by timstamp when record was created.
	OpenedAt int
	Select   []string
	Sort     []string
	Extra    map[string]string
}

// ToQueryString converts CounterRecordsListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *CounterRecordsListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Media != "" {
		values.Set("media", q.Media)
	}
	if q.OpenedAt != 0 {
		values.Set("opened_at", strconv.Itoa(q.OpenedAt))
	}
	if len(q.Select) > 0 {
		values.Set("select", strings.Join(q.Select, ","))
	}
	if len(q.Sort) > 0 {
		values.Set("sort", strings.Join(q.Sort, ","))
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *CounterRecordsListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// EpisodesListQuery represents query parameters for EpisodesList method
type EpisodesListQuery struct {
	Cursor string
	// Request specific episode type
	EpisodeType string
	Limit       int
	// Filter the collection by stream name on which the episode is registered
	Media string
	// Client may ask to delay a response if there are no episodes to fetch. This should be used as a long-poll mechanism for lightweight fetching episodes from origin.
	PollTimeout int
	// Request for the search across the streams being processed by the inference server. Query is a free-formed text that describes an object to search for and its attributes. Query may include color properties ("yellow"), appearance attributes ("beard"). Results may be inaccurate and should be reviewed by inspecting corresponding video fragments. In order to use "context search" feature package `vision-context-search` must be installed at the  inference server to make digital fingerprints of streams. In case you use the "q" parameter to get a list of episodes, the following collection filters are only supported: "media", "opened_at_gte", "opened_at_lte".
	Q      string
	Select []string
	Sort   []string
	// Filter results by timstamp when episode was updated.   To specify timestamp range these suffixes may be used:     `_gt`: greater than value     `_lt`: less than value     `_gte`: greater than or equal to value     `_lte`: less than or equal to value
	UpdatedAt int
	Extra     map[string]string
}

// ToQueryString converts EpisodesListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *EpisodesListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.EpisodeType != "" {
		values.Set("episode_type", q.EpisodeType)
	}
	if q.Media != "" {
		values.Set("media", q.Media)
	}
	if q.PollTimeout != 0 {
		values.Set("poll_timeout", strconv.Itoa(q.PollTimeout))
	}
	if q.Q != "" {
		values.Set("q", q.Q)
	}
	if q.UpdatedAt != 0 {
		values.Set("updated_at", strconv.Itoa(q.UpdatedAt))
	}
	if len(q.Select) > 0 {
		values.Set("select", strings.Join(q.Select, ","))
	}
	if len(q.Sort) > 0 {
		values.Set("sort", strings.Join(q.Sort, ","))
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *EpisodesListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// StreamsListQuery represents query parameters for StreamsList method
type StreamsListQuery struct {
	Cursor string
	Limit  int
	Select []string
	Sort   []string
	Extra  map[string]string
}

// ToQueryString converts StreamsListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *StreamsListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if len(q.Select) > 0 {
		values.Set("select", strings.Join(q.Select, ","))
	}
	if len(q.Sort) > 0 {
		values.Set("sort", strings.Join(q.Sort, ","))
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *StreamsListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// BaseClientFactory is a factory function type for creating base HTTP clients.
type BaseClientFactory func(cfg *config.Config, apiURL string, authKey authorization.AuthKey) baseclient.BaseClient

// defaultBaseClientFactory creates a default base client instance.
func defaultBaseClientFactory(cfg *config.Config, apiURL string, authKey authorization.AuthKey) baseclient.BaseClient {
	return baseclient.New(cfg.HTTPClient, apiURL, authKey, cfg.Originator, cfg.Retry)
}

// Client is the concrete implementation of the VisionInference interface.
type Client struct {
	base   baseclient.BaseClient
	apiURL string
}

// NewWithBaseFactory creates a new VisionInference client with a custom base client factory.
// This is primarily used for testing or when custom HTTP client behavior is needed.
func NewWithBaseFactory(cfg *config.Config, baseFactory BaseClientFactory) (VisionInference, error) {
	if cfg.Hostname == "" {
		return nil, fmt.Errorf("hostname is required")
	}

	if cfg.Protocol == "" {
		cfg.Protocol = "http"
	}

	if cfg.Port == 0 {
		if cfg.Protocol == "https" {
			cfg.Port = 443
		} else {
			cfg.Port = 80
		}
	}

	apiURL := fmt.Sprintf("%s://%s:%d", cfg.Protocol, cfg.Hostname, cfg.Port)

	var authKey authorization.AuthKey
	if cfg.Auth != nil {
		authKey = cfg.Auth
	} else if cfg.ClusterKey != "" {
		authKey = authorization.ClusterKey(cfg.ClusterKey)
	}

	if cfg.Originator == "" {
		cfg.Originator = config.DefaultOriginator
	}

	base := baseFactory(cfg, apiURL, authKey)

	return &Client{
		base:   base,
		apiURL: apiURL,
	}, nil
}

// New creates a new VisionInference client with default settings.
func New(cfg *config.Config) (VisionInference, error) {
	return NewWithBaseFactory(cfg, defaultBaseClientFactory)
}

// doGet performs a GET request and unmarshals the response into result.
func (c *Client) doGet(ctx context.Context, path string, result any) error {
	request, err := http.NewRequestWithContext(ctx, http.MethodGet, c.apiURL+path, http.NoBody)
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}
	request.Header.Set("Content-Type", "application/json")
	return c.base.Request(ctx, request, result)
}

// doPost performs a POST request with a JSON body and unmarshals the response into result.
func (c *Client) doPost(ctx context.Context, path string, body any, result any) error {
	bodyBytes, err := json.Marshal(body)
	if err != nil {
		return fmt.Errorf("failed to marshal request body: %w", err)
	}
	request, err := http.NewRequestWithContext(ctx, http.MethodPost, c.apiURL+path, bytes.NewBuffer(bodyBytes))
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}
	request.Header.Set("Content-Type", "application/json")
	return c.base.Request(ctx, request, result)
}

// doPut performs a PUT request with a JSON body and unmarshals the response into result.
func (c *Client) doPut(ctx context.Context, path string, body any, result any) error {
	bodyBytes, err := json.Marshal(body)
	if err != nil {
		return fmt.Errorf("failed to marshal request body: %w", err)
	}
	request, err := http.NewRequestWithContext(ctx, http.MethodPut, c.apiURL+path, bytes.NewBuffer(bodyBytes))
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}
	request.Header.Set("Content-Type", "application/json")
	return c.base.Request(ctx, request, result)
}

// doDelete performs a DELETE request.
func (c *Client) doDelete(ctx context.Context, path string) error {
	request, err := http.NewRequestWithContext(ctx, http.MethodDelete, c.apiURL+path, http.NoBody)
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}
	request.Header.Set("Content-Type", "application/json")
	return c.base.Request(ctx, request, nil)
}

// doList performs a GET request with query parameters and unmarshals the response into result.
func (c *Client) doList(ctx context.Context, path string, query interface{ ToQueryString() (string, error) }, result any) error {
	if query == nil {
		request, err := http.NewRequestWithContext(ctx, http.MethodGet, c.apiURL+path, http.NoBody)
		if err != nil {
			return fmt.Errorf("failed to create request: %w", err)
		}
		request.Header.Set("Content-Type", "application/json")
		return c.base.Request(ctx, request, result)
	}
	queryString, err := query.ToQueryString()
	if err != nil {
		return fmt.Errorf("failed to build query string: %w", err)
	}
	requestURL := c.apiURL + path
	if queryString != "" {
		requestURL += "?" + queryString
	}
	request, err := http.NewRequestWithContext(ctx, http.MethodGet, requestURL, http.NoBody)
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}
	request.Header.Set("Content-Type", "application/json")
	return c.base.Request(ctx, request, result)
}

// ConfigGet Get configuration
// Returns the current configuration of the analytics modules at your server.
func (c *Client) ConfigGet(ctx context.Context) (model.ConfigVision, error) {
	path := "/vision/api/v3/config"
	result := &model.ConfigVisionImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// CounterRecordsList Counter records list
// The returned list includes records of counters of all types, i.e. humans, vehicles, etc. Each record represents aggregated metrics within some timeframe, a minute for instance. Specify a set of collection filters (such as media, region, period of time) to pick records of interest.
func (c *Client) CounterRecordsList(ctx context.Context, query *CounterRecordsListQuery) (model.CounterRecordsList, error) {
	path := "/vision/api/v3/counters/records"
	result := &model.CounterRecordsListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// CounterRecordsListIterator iterates through all VisionCounterRecord items using cursor pagination.
func (c *Client) CounterRecordsListIterator(ctx context.Context, query *CounterRecordsListQuery) iter.Seq2[model.VisionCounterRecord, error] {
	return cursors.Iterator(ctx, c.CounterRecordsList, query)
}

// EpisodesList Episodes list
// Your client application shall make this long poll request to Inference node(s).  The request returns the list of episodes registered during operation on your server.  How to make long poll:  * Set `poll_timeout` and `updated_at_gt` in the query. * The episodes that match the `updated_at_gt` filter will be returned instantly (as in a regular request). * If there are no such episodes, the connection will last `poll_timeout` seconds. * If during this connection interval an episode appears that matches the `updated_at_gt` filter,  it is returned immediately.  The returned list includes all episodes, i.e. license plate recognition (LPR), face detection, etc. LPR results can be used right away while  face episodes shall be passed to the Identification service via `episodes_identify`  in order to match face fingerprints against the face database.  There may be several Inference nodes and one Identification service  to ensure that the same face is recognized on all your cameras.  Request all your Inference nodes before supplying the result to Identification.
func (c *Client) EpisodesList(ctx context.Context, query *EpisodesListQuery) (model.EpisodesList, error) {
	path := "/vision/api/v3/episodes"
	result := &model.EpisodesListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// EpisodesListIterator iterates through all Episode items using cursor pagination.
func (c *Client) EpisodesListIterator(ctx context.Context, query *EpisodesListQuery) iter.Seq2[model.Episode, error] {
	return cursors.Iterator(ctx, c.EpisodesList, query)
}

// LivenessProbe Liveness probe
// Liveness probe.
func (c *Client) LivenessProbe(ctx context.Context) (model.VisionServerInfo, error) {
	path := "/vision/api/v3/monitoring/liveness"
	result := &model.VisionServerInfoImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// MetricsGet Prometheus metrics
// Provides endpoint for Prometheus scraper. Each record represents per-stream metrics.   Additionally there is a bunch of per-worker records containing aggregation of metrics of streams served by this worker.   Per-worker metrics are marked with `media=all` attribute.  JSON representation of metrics is not implemented.   Its schema can be used for getting the list of metrics with descriptions for reference
func (c *Client) MetricsGet(ctx context.Context) (model.VisionMetrics, error) {
	path := "/vision/api/v3/monitoring/metrics"
	result := &model.VisionMetricsImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// Process Image analysis
// Analyzes the supplied image. Detects objects and computes digital fingerprints of the detected objects (if fingerprints are supported for the object type).
func (c *Client) Process(ctx context.Context) (model.VisionProcessResult, error) {
	path := "/vision/api/v3/process"
	result := &model.VisionProcessResultImpl{}
	if err := c.doPost(ctx, path, nil, result); err != nil {
		return nil, err
	}
	return result, nil
}

// StatsGet Server info and runtime stats
// Provides information about running instance such as version, available hardware and utilization
func (c *Client) StatsGet(ctx context.Context) (model.VisionWorkerStats, error) {
	path := "/vision/api/v3/stats"
	result := &model.VisionWorkerStatsImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// StreamsList List streams
// This API method allows to get information about streams being processed by the server.
func (c *Client) StreamsList(ctx context.Context, query *StreamsListQuery) (model.StreamsList, error) {
	path := "/vision/api/v3/streams"
	result := &model.StreamsListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// StreamsListIterator iterates through all StreamConfig items using cursor pagination.
func (c *Client) StreamsListIterator(ctx context.Context, query *StreamsListQuery) iter.Seq2[model.StreamConfig, error] {
	return cursors.Iterator(ctx, c.StreamsList, query)
}
