// Code generated by cmd/main. DO NOT EDIT.
package flussonic

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"iter"
	"net/http"
	"net/url"
	"strconv"

	"github.com/flussonic/go-flussonic/authorization"
	"github.com/flussonic/go-flussonic/config"
	model "github.com/flussonic/go-flussonic/flussonic/model"
	"github.com/flussonic/go-flussonic/internal/baseclient"
	"github.com/flussonic/go-flussonic/internal/cursors"
)

// Flussonic defines the interface for interacting with Flussonic API.
type Flussonic interface {
	// ApiTokensList List API tokens
	// Method allows to fetch configured API tokens
	ApiTokensList(ctx context.Context, query *ApiTokensListQuery) (model.APITokensList, error)
	// ApiTokensListIterator iterates through all items using cursor pagination
	ApiTokensListIterator(ctx context.Context, query *ApiTokensListQuery) iter.Seq2[model.APIToken, error]
	// AuthBackendDelete Delete the auth backend
	// Delete the authorization backend by its name.
	AuthBackendDelete(ctx context.Context, name string) error
	// AuthBackendGet Get the auth backend
	// This method allows to get a single authorization backend.
	AuthBackendGet(ctx context.Context, name string) (model.AuthBackendConfig, error)
	// AuthBackendSave Save the auth backend
	// Create or update an authorization backend.  If you pass only a partial configuration, only the passed fields will be updated.
	AuthBackendSave(ctx context.Context, name string, body model.AuthBackendConfig) (model.AuthBackendConfig, error)
	// AuthBackendsList List auth backends
	// This method allows to get the list of all authorization backends configured in Flussonic.
	AuthBackendsList(ctx context.Context, query *AuthBackendsListQuery) (model.AuthBackendsList, error)
	// AuthBackendsListIterator iterates through all items using cursor pagination
	AuthBackendsListIterator(ctx context.Context, query *AuthBackendsListQuery) iter.Seq2[model.AuthBackendConfig, error]
	// AvailableEventsList Get events from sink configuration
	// This method allows to get the batch of events from an event sink configuration. Currenly this method is not implemented yet. However, its schema can be used for getting the list of events with descriptions (see the `event` parameter in the response.)
	AvailableEventsList(ctx context.Context, name string, query *AvailableEventsListQuery) (model.AvailableEventsList, error)
	// AvailableEventsListIterator iterates through all items using cursor pagination
	AvailableEventsListIterator(ctx context.Context, name string, query *AvailableEventsListQuery) iter.Seq2[model.StreamerEvent1, error]
	// CacheDelete Delete the cache
	// Delete the cache by its name
	CacheDelete(ctx context.Context, name string) error
	// CacheGet Get the cache
	// Method allows to fetch single cache
	CacheGet(ctx context.Context, name string) (model.CacheConfig, error)
	// CacheSave Save cache
	// Create or update cache
	CacheSave(ctx context.Context, name string, body model.CacheConfig) (model.CacheConfig, error)
	// CachesList List of caches
	// Fetch all caches
	CachesList(ctx context.Context, query *CachesListQuery) (model.CachesList, error)
	// CachesListIterator iterates through all items using cursor pagination
	CachesListIterator(ctx context.Context, query *CachesListQuery) iter.Seq2[model.CacheConfig, error]
	// CameraAlarmDelete Delete camera alarm
	// Delete the configuration of the `camera_alarm` plugin.
	CameraAlarmDelete(ctx context.Context) error
	// CameraAlarmGet Get camera alarm
	// Get the configuration of the `camera_alarm` plugin.
	CameraAlarmGet(ctx context.Context) (model.CameraAlarmConfig, error)
	// CameraAlarmSave Save camera alarm
	// Update the configuration of the `camera_alarm` plugin.
	CameraAlarmSave(ctx context.Context) (model.CameraAlarmConfig, error)
	// ConfigGet Get server config
	// Method allows to fetch global server configuration and current runtime status.
	ConfigGet(ctx context.Context, query *ConfigGetQuery) (model.ServerConfig, error)
	// ConfigSave Save server config
	// Create or update global server configuration.
	ConfigSave(ctx context.Context, body model.ServerConfig) (model.ServerConfig, error)
	// ConfigStatsGet Get server stats
	// Method allows to fetch current runtime status.
	ConfigStatsGet(ctx context.Context) (model.ServerStats, error)
	// ConfigValidate Validate config
	// Just parse and validate config, nothing is saved.  Provide JSON structure or plain text.  Take a look at this example: ``` curl -d 'http 80; stream mystream { input ""; }' \   -H 'Content-Type: text/plain' \   -sS http://login:pass@localhost:8080/streamer/api/v3/config | jq {   "col": 34,   "config": {     "http": [       "80"     ],     "streams": [       {         "inputs": [           {             "url": ""           }         ],         "name": "mystream"       }     ]   },   "detail": "",   "error": "bad_url",   "line": 1,   "path": [     "streams",     0,     "inputs",     0,     "url",     "input_url"   ] } ```  You can see that it is possible to fix error on column 34 where bad, empty url was saved.
	ConfigValidate(ctx context.Context, body model.ServerConfig) (model.ServerConfig, error)
	// DiskFileDelete Delete a VOD file
	// Delete a VOD file by its name.
	DiskFileDelete(ctx context.Context, prefix string, storage_index string, subpath string) error
	// DiskFileGet Get a single VOD file
	// This method allows to get a single VOD file.
	DiskFileGet(ctx context.Context, prefix string, storage_index string, subpath string) (model.DiskFile, error)
	// DiskFileSave Save a VOD file
	// Upload a file to the VOD location.
	DiskFileSave(ctx context.Context, prefix string, storage_index string, subpath string) (model.DiskFile, error)
	// DiskFilesList List files in a VOD location
	// This method allows to get the list of all files and folders for a specific storage subpath in a VOD location.
	DiskFilesList(ctx context.Context, prefix string, storage_index string, query *DiskFilesListQuery) (model.DiskFilesList, error)
	// DiskFilesListIterator iterates through all items using cursor pagination
	DiskFilesListIterator(ctx context.Context, prefix string, storage_index string, query *DiskFilesListQuery) iter.Seq2[model.DiskFile, error]
	// DvbCardAvailableProgramsGet Get the media_info for each dvb_card program
	// Fetch the list of `media_info` for each program transmitted via the DVB card.
	DvbCardAvailableProgramsGet(ctx context.Context, name string, query *DvbCardAvailableProgramsGetQuery) (model.MediaInfoList, error)
	// DvbCardAvailableProgramsGetIterator iterates through all items using cursor pagination
	DvbCardAvailableProgramsGetIterator(ctx context.Context, name string, query *DvbCardAvailableProgramsGetQuery) iter.Seq2[model.MediaInfo, error]
	// DvbCardDelete Delete the DVB card
	// Delete the DVB card by its name.
	DvbCardDelete(ctx context.Context, name string) error
	// DvbCardGet Get the DVB card
	// This method allows to get a single DVB card by name.
	DvbCardGet(ctx context.Context, name string) (model.DvbCardConfig, error)
	// DvbCardSave Save the DVB card
	// Create or update a DVB card. If you pass only a partial DVB card configuration, only the passed fields will be updated, not the whole configuration.
	DvbCardSave(ctx context.Context, name string, body model.DvbCardConfig) (model.DvbCardConfig, error)
	// DvbCardsList Get list of DVB cards
	// This method allows to get the list of all DVB cards configured in Flussonic.
	DvbCardsList(ctx context.Context, query *DvbCardsListQuery) (model.DvbCardsList, error)
	// DvbCardsListIterator iterates through all items using cursor pagination
	DvbCardsListIterator(ctx context.Context, query *DvbCardsListQuery) iter.Seq2[model.DvbCardConfig, error]
	// DvrDelete Delete DVR configuration
	// Delete a single global DVR configuration by its name.
	DvrDelete(ctx context.Context, name string) error
	// DvrDiskDelete Delete the DVR disk
	// Delete the DVR disk by its path.
	DvrDiskDelete(ctx context.Context, name string, pathParam string) error
	// DvrDiskGet Get the DVR disk
	// This method allows to get a single DVR disk for a DVR configuration with RAID enabled.
	DvrDiskGet(ctx context.Context, name string, pathParam string) (model.RaidDiskConfig, error)
	// DvrDiskSave Save the DVR disk
	// Create or update a DVR disk.  If you pass only a partial DVR disk configuration, only the passed fields will be updated, not the whole disk configuration.
	DvrDiskSave(ctx context.Context, name string, pathParam string, body model.RaidDiskConfig) (model.RaidDiskConfig, error)
	// DvrDisksList List the DVR disks
	// This method allows to get the whole list of disks for a DVR configuration with RAID enabled.  Learn more in [Flussonic RAID for DVR](https://flussonic.com/doc/extend-video-storage-on-fly/).
	DvrDisksList(ctx context.Context, name string, query *DvrDisksListQuery) (model.DvrDisksList, error)
	// DvrDisksListIterator iterates through all items using cursor pagination
	DvrDisksListIterator(ctx context.Context, name string, query *DvrDisksListQuery) iter.Seq2[model.RaidDiskConfig, error]
	// DvrEpisodesList Recorded episodes list
	// This method allows you to fetch registered episodes with dvr recording status
	DvrEpisodesList(ctx context.Context, query *DvrEpisodesListQuery) (model.EpisodesList, error)
	// DvrEpisodesListIterator iterates through all items using cursor pagination
	DvrEpisodesListIterator(ctx context.Context, query *DvrEpisodesListQuery) iter.Seq2[model.Episode, error]
	// DvrExportJobCancel Cancel the job
	// Cancel the DVR export job.
	DvrExportJobCancel(ctx context.Context, id string) error
	// DvrExportJobList List DVR background jobs
	// List DVR export jobs
	DvrExportJobList(ctx context.Context) (model.DvrExportJobList, error)
	// DvrExportJobStart Start a job
	// Start a new DVR export job
	DvrExportJobStart(ctx context.Context, id string, body model.DvrExportJob) (model.DvrExportJob, error)
	// DvrExportJobStatus Get the job status
	// Get the status of the DVR export job
	DvrExportJobStatus(ctx context.Context, id string) (model.DvrExportJob, error)
	// DvrGet Get DVR configuration
	// This method allows to get a single global DVR configuration.
	DvrGet(ctx context.Context, name string) (model.DvrConfig, error)
	// DvrSave Save DVR configuration
	// Create or update a single global DVR configuration.  If you pass only a partial DVR configuration, only the passed fields will be updated, not the whole configuration.
	DvrSave(ctx context.Context, name string, body model.DvrConfig) (model.DvrConfig, error)
	// DvrsList List DVR configurations
	// This method allows to get the whole list of global DVR congifurations.
	DvrsList(ctx context.Context, query *DvrsListQuery) (model.DvrsList, error)
	// DvrsListIterator iterates through all items using cursor pagination
	DvrsListIterator(ctx context.Context, query *DvrsListQuery) iter.Seq2[model.DvrConfig, error]
	// EpisodesList List episodes
	// This method allows you to fetch registered episodes
	EpisodesList(ctx context.Context, query *EpisodesListQuery) (model.EpisodesList, error)
	// EpisodesListIterator iterates through all items using cursor pagination
	EpisodesListIterator(ctx context.Context, query *EpisodesListQuery) iter.Seq2[model.Episode, error]
	// EventSinkDelete Delete an event sink configuration
	// Delete an event sink configuration by its name.
	EventSinkDelete(ctx context.Context, name string) error
	// EventSinkGet Get one event sink configuration
	// This method allows to get a single event sink configuration.
	EventSinkGet(ctx context.Context, name string) (model.EventSinkConfig, error)
	// EventSinkSave Save a single event sink configuration
	// Create or update an event sink configuration by its name.
	EventSinkSave(ctx context.Context, name string, body model.EventSinkConfig) (model.EventSinkConfig, error)
	// EventSinksList List event sinks configs
	// This method allows to get the list of all event sinks (former `notify`) configured in Flussonic.  Each event sink is an instruction for Flussonic to send events to some target.  In particular, you can configure sending events to an event handler or writing them to a log file.  Event sink has its unique name just for management purposes, event filtering instructions and target for sending events.
	EventSinksList(ctx context.Context, query *EventSinksListQuery) (model.EventSinksList, error)
	// EventSinksListIterator iterates through all items using cursor pagination
	EventSinksListIterator(ctx context.Context, query *EventSinksListQuery) iter.Seq2[model.EventSinkConfig, error]
	// FileProcessorDelete Delete the file processor
	// Delete the file processor config
	FileProcessorDelete(ctx context.Context) error
	// FileProcessorGet Get the file processor config
	// Get the file processor config
	FileProcessorGet(ctx context.Context) (model.FileProcessorConfig, error)
	// FileProcessorJobCheck Get the job status
	// Get the status of the file processor job.
	FileProcessorJobCheck(ctx context.Context, id string) (model.FileProcessorJob, error)
	// FileProcessorJobDelete Cancel the job
	// Cancel the file processor job.
	FileProcessorJobDelete(ctx context.Context, id string) error
	// FileProcessorJobStart Start file_processor job
	// Start the file processor job.
	FileProcessorJobStart(ctx context.Context, body model.FileProcessorJob) (model.FileProcessorJob, error)
	// FileProcessorSave Save the file processor
	// Update the file processor config
	FileProcessorSave(ctx context.Context, body model.FileProcessorConfig) (model.FileProcessorConfig, error)
	// HttpProxiesList List http proxy configuration
	// This method allows to get the whole list of http proxy congifurations.
	HttpProxiesList(ctx context.Context, query *HttpProxiesListQuery) (model.HTTPProxiesList, error)
	// HttpProxiesListIterator iterates through all items using cursor pagination
	HttpProxiesListIterator(ctx context.Context, query *HttpProxiesListQuery) iter.Seq2[model.HTTPProxyConfig, error]
	// HttpProxyDelete Delete http_proxy
	// Delete http_proxy configuration.
	HttpProxyDelete(ctx context.Context, prefix string) error
	// HttpProxyGet Get http_proxy
	// Get http_proxy configuration.
	HttpProxyGet(ctx context.Context, prefix string) (model.HTTPProxyConfig, error)
	// HttpProxySave Save http_proxy
	// Update http_proxy configuration.
	HttpProxySave(ctx context.Context, prefix string, body model.HTTPProxyConfig) (model.HTTPProxyConfig, error)
	// IptvDelete Disable IPTV
	// Disable trivial IPTV plugin, remove it from the config and stop runtime status.
	IptvDelete(ctx context.Context) error
	// IptvGet IPTV status
	// Get current status of the trivial IPTV subscriber management system.
	IptvGet(ctx context.Context) (model.IptvConfig, error)
	// IptvSave Save IPTV
	// Enable or reload IPTV plugin configuration and disk state
	IptvSave(ctx context.Context, body model.IptvConfig) (model.IptvConfig, error)
	// LivenessProbe Liveness probe
	// K8s liveness probe.
	LivenessProbe(ctx context.Context) (model.ServerStatsWhoami, error)
	// LogoDelete Delete the logo file
	// Delete the logo by its path
	LogoDelete(ctx context.Context, name string) error
	// LogoGet Get the logo
	// Method allows to fetch single logo file
	LogoGet(ctx context.Context, name string) (model.LogoFile, error)
	// LogoSave Upload the logo
	// Upload logo file
	LogoSave(ctx context.Context, name string, body model.LogoFile) (model.LogoFile, error)
	// LogosList List logos
	// List logo files
	LogosList(ctx context.Context, query *LogosListQuery) (model.LogosList, error)
	// LogosListIterator iterates through all items using cursor pagination
	LogosListIterator(ctx context.Context, query *LogosListQuery) iter.Seq2[model.LogoFile, error]
	// MultiplexerXmltvUpload Upload XMLTV files
	// Upload XMLTV files to multiplexer
	MultiplexerXmltvUpload(ctx context.Context, name string) error
	// OpenedFilesList List files in VOD locations which are played by the clients
	// This method allows to get the list of files in VOD locations which are played by the clients.
	OpenedFilesList(ctx context.Context, query *OpenedFilesListQuery) (model.DiskFilesList, error)
	// OpenedFilesListIterator iterates through all items using cursor pagination
	OpenedFilesListIterator(ctx context.Context, query *OpenedFilesListQuery) iter.Seq2[model.DiskFile, error]
	// PackageDelete Delete the package
	// Delete this package with all links to streams and all links to subscribers.
	PackageDelete(ctx context.Context, name string) error
	// PackageGet Get the package
	// Package is a group of streams (channels), that are provided together to customer as a single billing item.
	PackageGet(ctx context.Context, name string) (model.PackageConfig, error)
	// PackageSave Save the package
	// Create or update the package.  Partial configuration can be provided.
	PackageSave(ctx context.Context, name string, body model.PackageConfig) (model.PackageConfig, error)
	// PackagesList List all packages
	// List existing packages. Take a look at operation `package_get` for detailed description of package concept.
	PackagesList(ctx context.Context, query *PackagesListQuery) (model.PackagesList, error)
	// PackagesListIterator iterates through all items using cursor pagination
	PackagesListIterator(ctx context.Context, query *PackagesListQuery) iter.Seq2[model.PackageConfig, error]
	// PeerDelete Delete the peer
	// Delete the peer by its name
	PeerDelete(ctx context.Context, hostname string) error
	// PeerGet Get the peer
	// Method allows to fetch single peer
	PeerGet(ctx context.Context, hostname string) (model.PeerConfig, error)
	// PeerSave Save the peer
	// Create or update peer
	PeerSave(ctx context.Context, hostname string, body model.PeerConfig) (model.PeerConfig, error)
	// PeersList List peers
	// Fetch all peers
	PeersList(ctx context.Context, query *PeersListQuery) (model.PeersList, error)
	// PeersListIterator iterates through all items using cursor pagination
	PeersListIterator(ctx context.Context, query *PeersListQuery) iter.Seq2[model.PeerConfig, error]
	// ReadinessProbe Readiness probe
	// K8s readiness probe.
	ReadinessProbe(ctx context.Context) (model.ServerStatsWhoami, error)
	// RproxyAgentsList List connected streampoint agents
	// Return a list of agents currently connected to the streampoint
	RproxyAgentsList(ctx context.Context, query *RproxyAgentsListQuery) (model.WatcherAgentsList, error)
	// RproxyAgentsListIterator iterates through all items using cursor pagination
	RproxyAgentsListIterator(ctx context.Context, query *RproxyAgentsListQuery) iter.Seq2[model.WatcherAgentConfig, error]
	// RproxyDelete Delete rproxy
	// Delete rproxy configuration.
	RproxyDelete(ctx context.Context) error
	// RproxyGet Get rproxy
	// Get rproxy configuration.
	RproxyGet(ctx context.Context) (model.RproxyConfig, error)
	// RproxySave Save rproxy
	// Update rproxy configuration.
	RproxySave(ctx context.Context, body model.RproxyConfig) (model.RproxyConfig, error)
	// SessionDelete Close the session
	// Close the play session. The closed session will be available in the sessions history.
	SessionDelete(ctx context.Context, id string) error
	// SessionGet Get the session
	// Get the play session.
	SessionGet(ctx context.Context, id string) (model.Session, error)
	// SessionsList List sessions
	// This method returns list of opened play sessions.  At this moment sessions are filtered only to `type=play`, however later we may add additional sessions like `publish`, `push`, or `ingest`.
	SessionsList(ctx context.Context, query *SessionsListQuery) (model.SessionsList, error)
	// SessionsListIterator iterates through all items using cursor pagination
	SessionsListIterator(ctx context.Context, query *SessionsListQuery) iter.Seq2[model.Session, error]
	// SessionsReauth Invalidate auth backend response cache for sessions of specified stream
	// Flussonic immediately re-call auth-backend and check if session is still authorized. This will be done for all open sessions.
	SessionsReauth(ctx context.Context, query *SessionsReauthQuery) (model.CollectionResponse, error)
	// SourceDelete Delete the source
	// Delete the source by its name
	SourceDelete(ctx context.Context, url string) error
	// SourceGet Get the source
	// Method allows to fetch single source
	SourceGet(ctx context.Context, url string) (model.SourceConfig, error)
	// SourceSave Save the source
	// Create or update source
	SourceSave(ctx context.Context, url string, body model.SourceConfig) (model.SourceConfig, error)
	// SourcesList List sources
	// Fetch all sources
	SourcesList(ctx context.Context, query *SourcesListQuery) (model.SourcesList, error)
	// SourcesListIterator iterates through all items using cursor pagination
	SourcesListIterator(ctx context.Context, query *SourcesListQuery) iter.Seq2[model.SourceConfig, error]
	// StreamDelete Delete the stream
	// This method allows to delete a single stream.
	StreamDelete(ctx context.Context, name string) error
	// StreamDvrConsistencyCheck Check stream DVR
	// Run DVR consistency checks on this stream. When there are any problems found, errors are returned in response body. This is a diagnostic operation, response format is not fully specified.
	StreamDvrConsistencyCheck(ctx context.Context, name string) (model.DvrConsistencyErrors, error)
	// StreamDvrLocksDelete Unlock stream recorded DVR range
	// This method allows to unlock a DVR range for a stream.
	StreamDvrLocksDelete(ctx context.Context, name string, body model.DvrRange) error
	// StreamDvrLocksList Get stream locked dvr ranges
	// This method allows to get the list of locked DVR ranges for a stream.
	StreamDvrLocksList(ctx context.Context, name string, query *StreamDvrLocksListQuery) (model.StreamDvrLocksList, error)
	// StreamDvrLocksListIterator iterates through all items using cursor pagination
	StreamDvrLocksListIterator(ctx context.Context, name string, query *StreamDvrLocksListQuery) iter.Seq2[model.DvrRange, error]
	// StreamDvrLocksSave Lock stream recorded DVR range
	// This method allows to lock a DVR range for a stream. Locking can be useful for the nPVR (Network Personal Video Recorder) service or just for keeping important recordings.
	StreamDvrLocksSave(ctx context.Context, name string, body model.DvrRange) error
	// StreamDvrRangesDelete Delete stream recorded DVR range
	// This method allows to delete a DVR recording in a specified range for a stream.
	StreamDvrRangesDelete(ctx context.Context, name string, body model.DvrRange) error
	// StreamDvrRangesList Get stream recorded dvr ranges
	// This method allows to get the list of DVR recorded ranges for a stream.
	StreamDvrRangesList(ctx context.Context, name string, query *StreamDvrRangesListQuery) (model.StreamDvrRangesList, error)
	// StreamDvrRangesListIterator iterates through all items using cursor pagination
	StreamDvrRangesListIterator(ctx context.Context, name string, query *StreamDvrRangesListQuery) iter.Seq2[model.DvrRange, error]
	// StreamGet Get one stream
	// This method allows to fetch a single stream. Refer to the `streams_list` operation to find out what data will be returned in this method.
	StreamGet(ctx context.Context, name string) (model.StreamConfig, error)
	// StreamSave Save stream
	// Create or update a stream by its name. If the stream doesn't exist in the disk config, it will be created.  If you update a stream that is created with a template using a user request having `named_by=user`, a new stream will be created in the disk config.  If you pass partial stream configuration, this exact part will be updated, not the whole stream.  To disable a feature, provide the corresponding property with the `null` value, like `'{"drm": null}'`.  Pass the `"$reset": true` option to replace the stream configuration with the provided one.
	StreamSave(ctx context.Context, name string, body model.StreamConfig) (model.StreamConfig, error)
	// StreamSaveMp4 Export DVR as MP4 file
	// This method allows to export MP4 files from DVR and save them on the server disk or to the S3 bucket.
	StreamSaveMp4(ctx context.Context, name string, query *StreamSaveMp4Query) error
	// StreamStop Stop the stream
	// Stop the stream with a specified name.  If the stream is static, it will restart according to existing rules.  This API call is a replacement for both: stop and restart.  Server cannot restart a stream that was started by user (publish for example), because it cannot ask user to repeat publishing.  Static stream declared in config will be started automatically as if it failed due to any bug.  This is why `restart` is actually a `stop` and maybe `start`, while `start` is made by live stream subsystem
	StreamStop(ctx context.Context, name string) error
	// StreamsList List streams
	// This API method is one of the most important in whole API, because it gives the list of all streams, including:  * configured (may not be running at the moment) * running (including those that are created via a template and do not have own disk configuration) * remote (available from other servers) * only recorded  Together with the `stream_save` method you can manage streams in Flussonic.  You can pass all stream configuration options to query string for filtering, not only specified in the parameters.  This method and `stream_get` will return `effective stream configuration` with all templates, defaults included into this response. It is not exactly what you can see in the disk config. If you have configured this stream in the disk file, then the original disk configuration can be found in the field `config_on_disk`.  What you get from this API call is not what you write to `stream_save`.
	StreamsList(ctx context.Context, query *StreamsListQuery) (model.StreamsList, error)
	// StreamsListIterator iterates through all items using cursor pagination
	StreamsListIterator(ctx context.Context, query *StreamsListQuery) iter.Seq2[model.StreamConfig, error]
	// SubscriberDelete Delete the subscriber
	// Delete the subscriber from database. If he is watching video, all his sessions will be terminated soon.
	SubscriberDelete(ctx context.Context, name string) error
	// SubscriberGet Get one subscriber
	// Get the subscriber status.
	SubscriberGet(ctx context.Context, name string) (model.SubscriberConfig, error)
	// SubscriberSave Save the subscriber
	// Create or update the subscriber, identified by his unique name. Partial configuration is ok.
	SubscriberSave(ctx context.Context, name string, body model.SubscriberConfig) (model.SubscriberConfig, error)
	// SubscribersList List all subscribers
	// List existing subscribers from database
	SubscribersList(ctx context.Context, query *SubscribersListQuery) (model.SubscribersList, error)
	// SubscribersListIterator iterates through all items using cursor pagination
	SubscribersListIterator(ctx context.Context, query *SubscribersListQuery) iter.Seq2[model.SubscriberConfig, error]
	// TemplateDelete Delete the template
	// Delete the template by its name.
	TemplateDelete(ctx context.Context, name string) error
	// TemplateGet Get the template
	// This method allows to get a single template by name.
	TemplateGet(ctx context.Context, name string) (model.TemplateConfig, error)
	// TemplateSave Save the template
	// Create or update a template.  If you pass only a partial template configuration, only the passed fields will be updated, not the whole template.
	TemplateSave(ctx context.Context, name string, body model.TemplateConfig) (model.TemplateConfig, error)
	// TemplatesList List templates
	// This method allows to get the list of all templates in Flussonic with all their settings.
	TemplatesList(ctx context.Context, query *TemplatesListQuery) (model.TemplatesList, error)
	// TemplatesListIterator iterates through all items using cursor pagination
	TemplatesListIterator(ctx context.Context, query *TemplatesListQuery) iter.Seq2[model.TemplateConfig, error]
	// TransponderDelete Delete the multiplexer
	// Delete the multiplexer by its name.
	TransponderDelete(ctx context.Context, name string) error
	// TransponderGet Get the multiplexer
	// This method allows you to fetch a single multiplexer.
	TransponderGet(ctx context.Context, name string) (model.TransponderConfig, error)
	// TransponderOtherDelete Delete the other multiplexer
	// Delete the other multiplexer by its index.
	TransponderOtherDelete(ctx context.Context, name string, index string) error
	// TransponderOtherGet Get the other multiplexer
	// Method allows to fetch a single other multiplexer.
	TransponderOtherGet(ctx context.Context, name string, index string) (model.TransponderOther, error)
	// TransponderOtherSave Save the other multiplexer
	// Create or update other multiplexer.
	TransponderOtherSave(ctx context.Context, name string, index string, body model.TransponderOther) (model.TransponderOther, error)
	// TransponderOthersList Get other multiplexers
	// Fetch all other multiplexers for the multiplexer with the specified name.
	TransponderOthersList(ctx context.Context, name string, query *TransponderOthersListQuery) (model.TransponderOthersList, error)
	// TransponderOthersListIterator iterates through all items using cursor pagination
	TransponderOthersListIterator(ctx context.Context, name string, query *TransponderOthersListQuery) iter.Seq2[model.TransponderOther, error]
	// TransponderProgramDelete Delete the multiplexer program
	// Delete the multiplexer program by its number.
	TransponderProgramDelete(ctx context.Context, name string, program_id string) error
	// TransponderProgramGet Get the multiplexer program
	// Method allows you to fetch single multiplexer program.
	TransponderProgramGet(ctx context.Context, name string, program_id string) (model.TransponderProgram, error)
	// TransponderProgramSave Save the multiplexer program
	// Create or update multiplexer program.
	TransponderProgramSave(ctx context.Context, name string, program_id string, body model.TransponderProgram) (model.TransponderProgram, error)
	// TransponderProgramsList Get multiplexer programs
	// Fetch all multiplexer programs.
	TransponderProgramsList(ctx context.Context, name string, query *TransponderProgramsListQuery) (model.TransponderProgramsList, error)
	// TransponderProgramsListIterator iterates through all items using cursor pagination
	TransponderProgramsListIterator(ctx context.Context, name string, query *TransponderProgramsListQuery) iter.Seq2[model.TransponderProgram, error]
	// TransponderPushDelete Delete the multiplexer push
	// Delete the multiplexer push by its index.
	TransponderPushDelete(ctx context.Context, name string, index string) error
	// TransponderPushGet Get the multiplexer push
	// Method allows to fetch single multiplexer push.
	TransponderPushGet(ctx context.Context, name string, index string) (model.TransponderPush, error)
	// TransponderPushSave Save the multiplexer push
	// Create or update multiplexer push.
	TransponderPushSave(ctx context.Context, name string, index string, body model.TransponderPush) (model.TransponderPush, error)
	// TransponderPushesList Get multiplexer pushes
	// Fetch all multiplexer pushes.
	TransponderPushesList(ctx context.Context, name string, query *TransponderPushesListQuery) (model.TransponderPushesList, error)
	// TransponderPushesListIterator iterates through all items using cursor pagination
	TransponderPushesListIterator(ctx context.Context, name string, query *TransponderPushesListQuery) iter.Seq2[model.TransponderPush, error]
	// TransponderSave Save the multiplexer
	// Create or update the multiplexer.
	TransponderSave(ctx context.Context, name string, body model.TransponderConfig) (model.TransponderConfig, error)
	// TransponderTimeOffsetDelete Delete the multiplexer time_offset
	// Delete the multiplexer time_offset by its index.
	TransponderTimeOffsetDelete(ctx context.Context, name string, index string) error
	// TransponderTimeOffsetGet Get the multiplexer time_offset
	// Method allows to fetch single multiplexer time_offset
	TransponderTimeOffsetGet(ctx context.Context, name string, index string) (model.TransponderTimeOffset, error)
	// TransponderTimeOffsetSave Save the multiplexer time_offset
	// Create or update multiplexer time_offset
	TransponderTimeOffsetSave(ctx context.Context, name string, index string, body model.TransponderTimeOffset) (model.TransponderTimeOffset, error)
	// TransponderTimeOffsetsList Get multiplexer time_offsets
	// Fetch all multiplexer time_offsets.
	TransponderTimeOffsetsList(ctx context.Context, name string, query *TransponderTimeOffsetsListQuery) (model.TransponderTimeOffsetsList, error)
	// TransponderTimeOffsetsListIterator iterates through all items using cursor pagination
	TransponderTimeOffsetsListIterator(ctx context.Context, name string, query *TransponderTimeOffsetsListQuery) iter.Seq2[model.TransponderTimeOffset, error]
	// TransponderTsDescriptorDelete Delete the multiplexer MPEG-TS descriptor
	// Delete the multiplexer descriptor by its index.
	TransponderTsDescriptorDelete(ctx context.Context, name string, index string) error
	// TransponderTsDescriptorGet Get the multiplexer descriptor
	// This method allows you to fetch a single multiplexer descriptor.
	TransponderTsDescriptorGet(ctx context.Context, name string, index string) (model.TSDescriptor, error)
	// TransponderTsDescriptorSave Save the multiplexer ts_descriptor
	// Create or update multiplexer descriptor.
	TransponderTsDescriptorSave(ctx context.Context, name string, index string, body model.TSDescriptor) (model.TSDescriptor, error)
	// TransponderTsDescriptorsList Get multiplexer ts_descriptors
	// Fetch all multiplexer ts_descriptors.
	TransponderTsDescriptorsList(ctx context.Context, name string, query *TransponderTsDescriptorsListQuery) (model.TransponderTSDescriptorsList, error)
	// TransponderTsDescriptorsListIterator iterates through all items using cursor pagination
	TransponderTsDescriptorsListIterator(ctx context.Context, name string, query *TransponderTsDescriptorsListQuery) iter.Seq2[model.TSDescriptor, error]
	// TranspondersList Get multiplexers
	// Fetch the multiplexers list.
	TranspondersList(ctx context.Context, query *TranspondersListQuery) (model.TranspondersList, error)
	// TranspondersListIterator iterates through all items using cursor pagination
	TranspondersListIterator(ctx context.Context, query *TranspondersListQuery) iter.Seq2[model.TransponderConfig, error]
	// VisionDelete Delete vision
	// Delete the video analytics configuration.
	VisionDelete(ctx context.Context) error
	// VisionGet Get vision
	// Get the video analytics configuration.
	VisionGet(ctx context.Context) (model.VisionConfig, error)
	// VisionSave Save vision
	// Save the video analytics configuration.
	VisionSave(ctx context.Context) (model.VisionConfig, error)
	// VodDelete Delete VOD location
	// Delete a single VOD location by its prefix
	VodDelete(ctx context.Context, prefix string) error
	// VodGet Get VOD location
	// This method allows to get a single VOD location.
	VodGet(ctx context.Context, prefix string) (model.VodConfig, error)
	// VodSave Save VOD location
	// Create or update a single VOD location. If you pass only a partial VOD location configuration, only the passed fields will be updated, not the whole configuration.
	VodSave(ctx context.Context, prefix string, body model.VodConfig) (model.VodConfig, error)
	// VodsList List VOD locations
	// This method allows to get the list of all VOD locations configured in Flussonic. VOD location is a virtual filepath used to place files for VOD (Video on Demand) broadcasting.
	VodsList(ctx context.Context, query *VodsListQuery) (model.VodsList, error)
	// VodsListIterator iterates through all items using cursor pagination
	VodsListIterator(ctx context.Context, query *VodsListQuery) iter.Seq2[model.VodConfig, error]
	// VsaasDelete Delete vsaas
	// Delete Watcher configuration.
	VsaasDelete(ctx context.Context) error
	// VsaasGet Get vsaas
	// Get Watcher configuration.
	VsaasGet(ctx context.Context) (model.VsaasConfig, error)
	// VsaasSave Save vsaas
	// Update Watcher configuration.
	VsaasSave(ctx context.Context, body model.VsaasConfig) (model.VsaasConfig, error)
}

// ApiTokensListQuery represents query parameters for ApiTokensList method
type ApiTokensListQuery struct {
	Cursor string
	Limit  int
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts ApiTokensListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *ApiTokensListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *ApiTokensListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// AuthBackendsListQuery represents query parameters for AuthBackendsList method
type AuthBackendsListQuery struct {
	Cursor string
	Limit  int
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts AuthBackendsListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *AuthBackendsListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *AuthBackendsListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// AvailableEventsListQuery represents query parameters for AvailableEventsList method
type AvailableEventsListQuery struct {
	Cursor string
	Limit  int
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts AvailableEventsListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *AvailableEventsListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *AvailableEventsListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// CachesListQuery represents query parameters for CachesList method
type CachesListQuery struct {
	Cursor string
	Limit  int
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts CachesListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *CachesListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *CachesListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// ConfigGetQuery represents query parameters for ConfigGet method
type ConfigGetQuery struct {
	// This parameter is used instead of the Accept header to select of non-JSON response content format.
	Format string
	// Whether to return full configuration.
	Full  bool
	Extra map[string]string
}

// ToQueryString converts ConfigGetQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *ConfigGetQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Format != "" {
		values.Set("format", q.Format)
	}
	values.Set("full", strconv.FormatBool(q.Full))
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// DiskFilesListQuery represents query parameters for DiskFilesList method
type DiskFilesListQuery struct {
	Cursor string
	// The folder in the storage to filter the results by.
	Folder string
	Limit  int
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts DiskFilesListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *DiskFilesListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Folder != "" {
		values.Set("folder", q.Folder)
	}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *DiskFilesListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// DvbCardAvailableProgramsGetQuery represents query parameters for DvbCardAvailableProgramsGet method
type DvbCardAvailableProgramsGetQuery struct {
	Cursor string
	Limit  int
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts DvbCardAvailableProgramsGetQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *DvbCardAvailableProgramsGetQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *DvbCardAvailableProgramsGetQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// DvbCardsListQuery represents query parameters for DvbCardsList method
type DvbCardsListQuery struct {
	Cursor string
	Limit  int
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts DvbCardsListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *DvbCardsListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *DvbCardsListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// DvrDisksListQuery represents query parameters for DvrDisksList method
type DvrDisksListQuery struct {
	Cursor string
	Limit  int
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts DvrDisksListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *DvrDisksListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *DvrDisksListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// DvrEpisodesListQuery represents query parameters for DvrEpisodesList method
type DvrEpisodesListQuery struct {
	// Properly encoded analog of offset, allowing to read next bunch of items.  We do not offer common `offset` fields, use cursor for predictable fetching of quickly changing list of items. Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	Cursor string
	// Limit select count in collection to N elements.
	Limit int
	// Filter the collection by media name on which the episode is registered
	Media string
	// Comma-separated list of fields (including nested) that will be returned.
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts DvrEpisodesListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *DvrEpisodesListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	if q.Limit != 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Media != "" {
		values.Set("media", q.Media)
	}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *DvrEpisodesListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// DvrsListQuery represents query parameters for DvrsList method
type DvrsListQuery struct {
	Cursor string
	// This parameter is used instead of the Accept header to select of non-JSON response content format.
	Format string
	Limit  int
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts DvrsListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *DvrsListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Format != "" {
		values.Set("format", q.Format)
	}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *DvrsListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// EpisodesListQuery represents query parameters for EpisodesList method
type EpisodesListQuery struct {
	// Properly encoded analog of offset, allowing to read next bunch of items.  We do not offer common `offset` fields, use cursor for predictable fetching of quickly changing list of items. Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	Cursor string
	// Enables check of DVR presence on streamer for the episode.
	DvrPresenceCheck bool
	// Episode type
	EpisodeType string
	// Limit select count in collection to N elements.
	Limit int
	// Filter the collection by media name on which the episode is registered
	Media string
	// Client may ask to delay a response if there are no episodes to fetch. This should be used as a long-poll mechanism for lightweight fetching episodes from origin.
	PollTimeout int
	// Comma-separated list of fields (including nested) that will be returned.
	Select string
	Sort   string
	// Filter the collection by episode update time. This field is rather specific because it allows to have an update stream with new/updated episodes
	UpdatedAtGt int
	Extra       map[string]string
}

// ToQueryString converts EpisodesListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *EpisodesListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	values.Set("dvr_presence_check", strconv.FormatBool(q.DvrPresenceCheck))
	if q.EpisodeType != "" {
		values.Set("episode_type", q.EpisodeType)
	}
	if q.Limit != 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Media != "" {
		values.Set("media", q.Media)
	}
	if q.PollTimeout != 0 {
		values.Set("poll_timeout", strconv.Itoa(q.PollTimeout))
	}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.UpdatedAtGt != 0 {
		values.Set("updated_at_gt", strconv.Itoa(q.UpdatedAtGt))
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *EpisodesListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// EventSinksListQuery represents query parameters for EventSinksList method
type EventSinksListQuery struct {
	Cursor string
	Limit  int
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts EventSinksListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *EventSinksListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *EventSinksListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// HttpProxiesListQuery represents query parameters for HttpProxiesList method
type HttpProxiesListQuery struct {
	Cursor string
	// This parameter is used instead of the Accept header to select of non-JSON response content format.
	Format string
	Limit  int
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts HttpProxiesListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *HttpProxiesListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Format != "" {
		values.Set("format", q.Format)
	}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *HttpProxiesListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// LogosListQuery represents query parameters for LogosList method
type LogosListQuery struct {
	Cursor string
	Limit  int
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts LogosListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *LogosListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *LogosListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// OpenedFilesListQuery represents query parameters for OpenedFilesList method
type OpenedFilesListQuery struct {
	// A properly encoded equivalent of offset allowing you to read the next bunch of items.  We do not offer common `offset` fields, so please use cursor for predictable fetching of quickly changing list of items. Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	Cursor string
	// Limit select count in collection to N elements.  Default value is 100.
	Limit int
	// The unique name of VOD location.  It is used as a prefix for displaying opened VOD files in this location.
	Prefix string
	Select string
	// Composite sort direction. Default sort order is `name`.
	Sort string
	// Index of the storage in the VOD location. It is used as a storage_index for displaying opened VOD files in this storage.
	StorageIndex int
	Extra        map[string]string
}

// ToQueryString converts OpenedFilesListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *OpenedFilesListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	if q.Limit != 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Prefix != "" {
		values.Set("prefix", q.Prefix)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.StorageIndex != 0 {
		values.Set("storage_index", strconv.Itoa(q.StorageIndex))
	}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *OpenedFilesListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// PackagesListQuery represents query parameters for PackagesList method
type PackagesListQuery struct {
	// Properly encoded analog of offset, allowing to read next bunch of items
	Cursor string
	// Limit select count in collection to N elements
	Limit int
	// Comma-separated list of fields (including nested) that will be returned
	Select string
	// Composite sort direction
	Sort  string
	Extra map[string]string
}

// ToQueryString converts PackagesListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *PackagesListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	if q.Limit != 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *PackagesListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// PeersListQuery represents query parameters for PeersList method
type PeersListQuery struct {
	Cursor string
	Limit  int
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts PeersListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *PeersListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *PeersListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// RproxyAgentsListQuery represents query parameters for RproxyAgentsList method
type RproxyAgentsListQuery struct {
	Cursor string
	Limit  int
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts RproxyAgentsListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *RproxyAgentsListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *RproxyAgentsListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// SessionsListQuery represents query parameters for SessionsList method
type SessionsListQuery struct {
	// Properly encoded analog of offset, allowing to read the next bunch of items. of items
	Cursor string
	// Limit select count in collection to N elements.
	Limit int
	// Comma-separated list of fields (including nested) that will be returned
	Select string
	// Composite sort direction.
	Sort  string
	Extra map[string]string
}

// ToQueryString converts SessionsListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *SessionsListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	if q.Limit != 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *SessionsListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// SessionsReauthQuery represents query parameters for SessionsReauth method
type SessionsReauthQuery struct {
	// Media name
	Name  string
	Extra map[string]string
}

// ToQueryString converts SessionsReauthQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *SessionsReauthQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", fmt.Errorf("query is required")
	}
	if q.Name == "" {
		return "", fmt.Errorf("query parameter 'name' is required")
	}
	values := url.Values{}
	values.Set("name", q.Name)
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SourcesListQuery represents query parameters for SourcesList method
type SourcesListQuery struct {
	Cursor string
	Limit  int
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts SourcesListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *SourcesListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *SourcesListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// StreamDvrLocksListQuery represents query parameters for StreamDvrLocksList method
type StreamDvrLocksListQuery struct {
	Cursor string
	Limit  int
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts StreamDvrLocksListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *StreamDvrLocksListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *StreamDvrLocksListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// StreamDvrRangesListQuery represents query parameters for StreamDvrRangesList method
type StreamDvrRangesListQuery struct {
	Cursor string
	Limit  int
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts StreamDvrRangesListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *StreamDvrRangesListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *StreamDvrRangesListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// StreamSaveMp4Query represents query parameters for StreamSaveMp4 method
type StreamSaveMp4Query struct {
	// Duration in seconds.
	Duration int
	// Start time in Unix timestamp (seconds).
	From int
	// The necessity to save the metadata with the MP4 file. If true, the metadata will be stored in the udta.meta.ilst.data atom.
	Meta bool
	// How to pack a recording data in the exported file
	Packing string
	// The recording path.
	Path string
	// Request a timelapse instead of normal speed
	Timelapse bool
	// Custom bitrate for timelapse
	TimelapseKbps int
	Extra         map[string]string
}

// ToQueryString converts StreamSaveMp4Query to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *StreamSaveMp4Query) ToQueryString() (string, error) {
	if q == nil {
		return "", fmt.Errorf("query is required")
	}
	if q.Duration == 0 {
		return "", fmt.Errorf("query parameter 'duration' is required")
	}
	if q.From == 0 {
		return "", fmt.Errorf("query parameter 'from' is required")
	}
	if q.Path == "" {
		return "", fmt.Errorf("query parameter 'path' is required")
	}
	values := url.Values{}
	values.Set("duration", strconv.Itoa(q.Duration))
	values.Set("from", strconv.Itoa(q.From))
	values.Set("meta", strconv.FormatBool(q.Meta))
	if q.Packing != "" {
		values.Set("packing", q.Packing)
	}
	values.Set("path", q.Path)
	values.Set("timelapse", strconv.FormatBool(q.Timelapse))
	if q.TimelapseKbps != 0 {
		values.Set("timelapse_kbps", strconv.Itoa(q.TimelapseKbps))
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// StreamsListQuery represents query parameters for StreamsList method
type StreamsListQuery struct {
	// Properly encoded analog of offset, allowing to read next bunch of items.  We do not offer common `offset` fields, use please cursor for predictable fetching of quickly changing list of items. Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	Cursor string
	// This parameter is used instead of the Accept header to select of non-JSON response content format.
	Format string
	// Limit select count in collection to N elements.  Default value is 100.
	Limit int
	// Search pattern for different fields like name, title, urls, etc.
	Q string
	// Comma-separated list of fields (including nested) that will be returned.
	Select string
	// Composite sort direction. Default sort order is `named_by (config,user,remote)`, `position`, `name`.
	Sort  string
	Extra map[string]string
}

// ToQueryString converts StreamsListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *StreamsListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	if q.Format != "" {
		values.Set("format", q.Format)
	}
	if q.Limit != 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Q != "" {
		values.Set("q", q.Q)
	}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *StreamsListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// SubscribersListQuery represents query parameters for SubscribersList method
type SubscribersListQuery struct {
	// Properly encoded analog of offset, allowing to read next bunch of items
	Cursor string
	// Limit select count in collection to N elements
	Limit int
	// Comma-separated list of fields (including nested) that will be returned
	Select string
	// Composite sort direction
	Sort  string
	Extra map[string]string
}

// ToQueryString converts SubscribersListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *SubscribersListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	if q.Limit != 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *SubscribersListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// TemplatesListQuery represents query parameters for TemplatesList method
type TemplatesListQuery struct {
	Cursor string
	Limit  int
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts TemplatesListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *TemplatesListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *TemplatesListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// TransponderOthersListQuery represents query parameters for TransponderOthersList method
type TransponderOthersListQuery struct {
	Cursor string
	Limit  int
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts TransponderOthersListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *TransponderOthersListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *TransponderOthersListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// TransponderProgramsListQuery represents query parameters for TransponderProgramsList method
type TransponderProgramsListQuery struct {
	Cursor string
	Limit  int
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts TransponderProgramsListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *TransponderProgramsListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *TransponderProgramsListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// TransponderPushesListQuery represents query parameters for TransponderPushesList method
type TransponderPushesListQuery struct {
	Cursor string
	Limit  int
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts TransponderPushesListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *TransponderPushesListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *TransponderPushesListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// TransponderTimeOffsetsListQuery represents query parameters for TransponderTimeOffsetsList method
type TransponderTimeOffsetsListQuery struct {
	Cursor string
	Limit  int
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts TransponderTimeOffsetsListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *TransponderTimeOffsetsListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *TransponderTimeOffsetsListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// TransponderTsDescriptorsListQuery represents query parameters for TransponderTsDescriptorsList method
type TransponderTsDescriptorsListQuery struct {
	Cursor string
	Limit  int
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts TransponderTsDescriptorsListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *TransponderTsDescriptorsListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *TransponderTsDescriptorsListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// TranspondersListQuery represents query parameters for TranspondersList method
type TranspondersListQuery struct {
	Cursor string
	// This parameter is used instead of the Accept header to select of non-JSON response content format.
	Format string
	Limit  int
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts TranspondersListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *TranspondersListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Format != "" {
		values.Set("format", q.Format)
	}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *TranspondersListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// VodsListQuery represents query parameters for VodsList method
type VodsListQuery struct {
	Cursor string
	Limit  int
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts VodsListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *VodsListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *VodsListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// BaseClientFactory is a factory function type for creating base HTTP clients.
type BaseClientFactory func(cfg *config.Config, apiURL string, authKey authorization.AuthKey) baseclient.BaseClient

// defaultBaseClientFactory creates a default base client instance.
func defaultBaseClientFactory(cfg *config.Config, apiURL string, authKey authorization.AuthKey) baseclient.BaseClient {
	return baseclient.New(cfg.HTTPClient, apiURL, authKey, cfg.Originator, cfg.Retry)
}

// Client is the concrete implementation of the Flussonic interface.
type Client struct {
	base   baseclient.BaseClient
	apiURL string
}

// NewWithBaseFactory creates a new Flussonic client with a custom base client factory.
// This is primarily used for testing or when custom HTTP client behavior is needed.
func NewWithBaseFactory(cfg *config.Config, baseFactory BaseClientFactory) (Flussonic, error) {
	if cfg.Hostname == "" {
		return nil, fmt.Errorf("hostname is required")
	}

	if cfg.Protocol == "" {
		cfg.Protocol = "http"
	}

	if cfg.Port == 0 {
		if cfg.Protocol == "https" {
			cfg.Port = 443
		} else {
			cfg.Port = 80
		}
	}

	apiURL := fmt.Sprintf("%s://%s:%d", cfg.Protocol, cfg.Hostname, cfg.Port)

	var authKey authorization.AuthKey
	if cfg.Auth != nil {
		authKey = cfg.Auth
	} else if cfg.ClusterKey != "" {
		authKey = authorization.ClusterKey(cfg.ClusterKey)
	}

	if cfg.Originator == "" {
		cfg.Originator = config.DefaultOriginator
	}

	base := baseFactory(cfg, apiURL, authKey)

	return &Client{
		base:   base,
		apiURL: apiURL,
	}, nil
}

// New creates a new Flussonic client with default settings.
func New(cfg *config.Config) (Flussonic, error) {
	return NewWithBaseFactory(cfg, defaultBaseClientFactory)
}

// doGet performs a GET request and unmarshals the response into result.
func (c *Client) doGet(ctx context.Context, path string, result any) error {
	request, err := http.NewRequestWithContext(ctx, http.MethodGet, c.apiURL+path, http.NoBody)
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}
	request.Header.Set("Content-Type", "application/json")
	return c.base.Request(ctx, request, result)
}

// doPost performs a POST request with a JSON body and unmarshals the response into result.
func (c *Client) doPost(ctx context.Context, path string, body any, result any) error {
	bodyBytes, err := json.Marshal(body)
	if err != nil {
		return fmt.Errorf("failed to marshal request body: %w", err)
	}
	request, err := http.NewRequestWithContext(ctx, http.MethodPost, c.apiURL+path, bytes.NewBuffer(bodyBytes))
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}
	request.Header.Set("Content-Type", "application/json")
	return c.base.Request(ctx, request, result)
}

// doPut performs a PUT request with a JSON body and unmarshals the response into result.
func (c *Client) doPut(ctx context.Context, path string, body any, result any) error {
	bodyBytes, err := json.Marshal(body)
	if err != nil {
		return fmt.Errorf("failed to marshal request body: %w", err)
	}
	request, err := http.NewRequestWithContext(ctx, http.MethodPut, c.apiURL+path, bytes.NewBuffer(bodyBytes))
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}
	request.Header.Set("Content-Type", "application/json")
	return c.base.Request(ctx, request, result)
}

// doDelete performs a DELETE request.
func (c *Client) doDelete(ctx context.Context, path string) error {
	request, err := http.NewRequestWithContext(ctx, http.MethodDelete, c.apiURL+path, http.NoBody)
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}
	request.Header.Set("Content-Type", "application/json")
	return c.base.Request(ctx, request, nil)
}

// doList performs a GET request with query parameters and unmarshals the response into result.
func (c *Client) doList(ctx context.Context, path string, query interface{ ToQueryString() (string, error) }, result any) error {
	if query == nil {
		request, err := http.NewRequestWithContext(ctx, http.MethodGet, c.apiURL+path, http.NoBody)
		if err != nil {
			return fmt.Errorf("failed to create request: %w", err)
		}
		request.Header.Set("Content-Type", "application/json")
		return c.base.Request(ctx, request, result)
	}
	queryString, err := query.ToQueryString()
	if err != nil {
		return fmt.Errorf("failed to build query string: %w", err)
	}
	requestURL := c.apiURL + path
	if queryString != "" {
		requestURL += "?" + queryString
	}
	request, err := http.NewRequestWithContext(ctx, http.MethodGet, requestURL, http.NoBody)
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}
	request.Header.Set("Content-Type", "application/json")
	return c.base.Request(ctx, request, result)
}

// ApiTokensList List API tokens
// Method allows to fetch configured API tokens
func (c *Client) ApiTokensList(ctx context.Context, query *ApiTokensListQuery) (model.APITokensList, error) {
	path := "/streamer/api/v3/api_tokens"
	result := &model.APITokensListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// ApiTokensListIterator iterates through all APIToken items using cursor pagination.
func (c *Client) ApiTokensListIterator(ctx context.Context, query *ApiTokensListQuery) iter.Seq2[model.APIToken, error] {
	return cursors.Iterator(ctx, c.ApiTokensList, query)
}

// AuthBackendDelete Delete the auth backend
// Delete the authorization backend by its name.
func (c *Client) AuthBackendDelete(ctx context.Context, name string) error {
	path := fmt.Sprintf("/streamer/api/v3/auth_backends/%s", name)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// AuthBackendGet Get the auth backend
// This method allows to get a single authorization backend.
func (c *Client) AuthBackendGet(ctx context.Context, name string) (model.AuthBackendConfig, error) {
	path := fmt.Sprintf("/streamer/api/v3/auth_backends/%s", name)
	result := &model.AuthBackendConfigImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// AuthBackendSave Save the auth backend
// Create or update an authorization backend.  If you pass only a partial configuration, only the passed fields will be updated.
func (c *Client) AuthBackendSave(ctx context.Context, name string, body model.AuthBackendConfig) (model.AuthBackendConfig, error) {
	path := fmt.Sprintf("/streamer/api/v3/auth_backends/%s", name)
	result := &model.AuthBackendConfigImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// AuthBackendsList List auth backends
// This method allows to get the list of all authorization backends configured in Flussonic.
func (c *Client) AuthBackendsList(ctx context.Context, query *AuthBackendsListQuery) (model.AuthBackendsList, error) {
	path := "/streamer/api/v3/auth_backends"
	result := &model.AuthBackendsListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// AuthBackendsListIterator iterates through all AuthBackendConfig items using cursor pagination.
func (c *Client) AuthBackendsListIterator(ctx context.Context, query *AuthBackendsListQuery) iter.Seq2[model.AuthBackendConfig, error] {
	return cursors.Iterator(ctx, c.AuthBackendsList, query)
}

// AvailableEventsList Get events from sink configuration
// This method allows to get the batch of events from an event sink configuration. Currenly this method is not implemented yet. However, its schema can be used for getting the list of events with descriptions (see the `event` parameter in the response.)
func (c *Client) AvailableEventsList(ctx context.Context, name string, query *AvailableEventsListQuery) (model.AvailableEventsList, error) {
	path := fmt.Sprintf("/streamer/api/v3/event_sinks/%s/events", name)
	result := &model.AvailableEventsListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// AvailableEventsListIterator iterates through all StreamerEvent1 items using cursor pagination.
func (c *Client) AvailableEventsListIterator(ctx context.Context, name string, query *AvailableEventsListQuery) iter.Seq2[model.StreamerEvent1, error] {
	return cursors.Iterator(ctx, func(ctx context.Context, query *AvailableEventsListQuery) (model.AvailableEventsList, error) {
		return c.AvailableEventsList(ctx, name, query)
	}, query)
}

// CacheDelete Delete the cache
// Delete the cache by its name
func (c *Client) CacheDelete(ctx context.Context, name string) error {
	path := fmt.Sprintf("/streamer/api/v3/caches/%s", name)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// CacheGet Get the cache
// Method allows to fetch single cache
func (c *Client) CacheGet(ctx context.Context, name string) (model.CacheConfig, error) {
	path := fmt.Sprintf("/streamer/api/v3/caches/%s", name)
	result := &model.CacheConfigImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// CacheSave Save cache
// Create or update cache
func (c *Client) CacheSave(ctx context.Context, name string, body model.CacheConfig) (model.CacheConfig, error) {
	path := fmt.Sprintf("/streamer/api/v3/caches/%s", name)
	result := &model.CacheConfigImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// CachesList List of caches
// Fetch all caches
func (c *Client) CachesList(ctx context.Context, query *CachesListQuery) (model.CachesList, error) {
	path := "/streamer/api/v3/caches"
	result := &model.CachesListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// CachesListIterator iterates through all CacheConfig items using cursor pagination.
func (c *Client) CachesListIterator(ctx context.Context, query *CachesListQuery) iter.Seq2[model.CacheConfig, error] {
	return cursors.Iterator(ctx, c.CachesList, query)
}

// CameraAlarmDelete Delete camera alarm
// Delete the configuration of the `camera_alarm` plugin.
func (c *Client) CameraAlarmDelete(ctx context.Context) error {
	path := "/streamer/api/v3/camera_alarm"
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// CameraAlarmGet Get camera alarm
// Get the configuration of the `camera_alarm` plugin.
func (c *Client) CameraAlarmGet(ctx context.Context) (model.CameraAlarmConfig, error) {
	path := "/streamer/api/v3/camera_alarm"
	result := &model.CameraAlarmConfigImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// CameraAlarmSave Save camera alarm
// Update the configuration of the `camera_alarm` plugin.
func (c *Client) CameraAlarmSave(ctx context.Context) (model.CameraAlarmConfig, error) {
	path := "/streamer/api/v3/camera_alarm"
	result := &model.CameraAlarmConfigImpl{}
	if err := c.doPut(ctx, path, nil, result); err != nil {
		return nil, err
	}
	return result, nil
}

// ConfigGet Get server config
// Method allows to fetch global server configuration and current runtime status.
func (c *Client) ConfigGet(ctx context.Context, query *ConfigGetQuery) (model.ServerConfig, error) {
	path := "/streamer/api/v3/config"
	result := &model.ServerConfigImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// ConfigSave Save server config
// Create or update global server configuration.
func (c *Client) ConfigSave(ctx context.Context, body model.ServerConfig) (model.ServerConfig, error) {
	path := "/streamer/api/v3/config"
	result := &model.ServerConfigImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// ConfigStatsGet Get server stats
// Method allows to fetch current runtime status.
func (c *Client) ConfigStatsGet(ctx context.Context) (model.ServerStats, error) {
	path := "/streamer/api/v3/config/stats"
	result := &model.ServerStatsImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// ConfigValidate Validate config
// Just parse and validate config, nothing is saved.  Provide JSON structure or plain text.  Take a look at this example: ``` curl -d 'http 80; stream mystream { input ""; }' \   -H 'Content-Type: text/plain' \   -sS http://login:pass@localhost:8080/streamer/api/v3/config | jq {   "col": 34,   "config": {     "http": [       "80"     ],     "streams": [       {         "inputs": [           {             "url": ""           }         ],         "name": "mystream"       }     ]   },   "detail": "",   "error": "bad_url",   "line": 1,   "path": [     "streams",     0,     "inputs",     0,     "url",     "input_url"   ] } ```  You can see that it is possible to fix error on column 34 where bad, empty url was saved.
func (c *Client) ConfigValidate(ctx context.Context, body model.ServerConfig) (model.ServerConfig, error) {
	path := "/streamer/api/v3/config"
	result := &model.ServerConfigImpl{}
	if err := c.doPost(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// DiskFileDelete Delete a VOD file
// Delete a VOD file by its name.
func (c *Client) DiskFileDelete(ctx context.Context, prefix string, storage_index string, subpath string) error {
	path := fmt.Sprintf("/streamer/api/v3/vods/%s/storages/%s/files/%s", prefix, storage_index, subpath)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// DiskFileGet Get a single VOD file
// This method allows to get a single VOD file.
func (c *Client) DiskFileGet(ctx context.Context, prefix string, storage_index string, subpath string) (model.DiskFile, error) {
	path := fmt.Sprintf("/streamer/api/v3/vods/%s/storages/%s/files/%s", prefix, storage_index, subpath)
	result := &model.DiskFileImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// DiskFileSave Save a VOD file
// Upload a file to the VOD location.
func (c *Client) DiskFileSave(ctx context.Context, prefix string, storage_index string, subpath string) (model.DiskFile, error) {
	path := fmt.Sprintf("/streamer/api/v3/vods/%s/storages/%s/files/%s", prefix, storage_index, subpath)
	result := &model.DiskFileImpl{}
	if err := c.doPut(ctx, path, nil, result); err != nil {
		return nil, err
	}
	return result, nil
}

// DiskFilesList List files in a VOD location
// This method allows to get the list of all files and folders for a specific storage subpath in a VOD location.
func (c *Client) DiskFilesList(ctx context.Context, prefix string, storage_index string, query *DiskFilesListQuery) (model.DiskFilesList, error) {
	path := fmt.Sprintf("/streamer/api/v3/vods/%s/storages/%s/files", prefix, storage_index)
	result := &model.DiskFilesListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// DiskFilesListIterator iterates through all DiskFile items using cursor pagination.
func (c *Client) DiskFilesListIterator(ctx context.Context, prefix string, storage_index string, query *DiskFilesListQuery) iter.Seq2[model.DiskFile, error] {
	return cursors.Iterator(ctx, func(ctx context.Context, query *DiskFilesListQuery) (model.DiskFilesList, error) {
		return c.DiskFilesList(ctx, prefix, storage_index, query)
	}, query)
}

// DvbCardAvailableProgramsGet Get the media_info for each dvb_card program
// Fetch the list of `media_info` for each program transmitted via the DVB card.
func (c *Client) DvbCardAvailableProgramsGet(ctx context.Context, name string, query *DvbCardAvailableProgramsGetQuery) (model.MediaInfoList, error) {
	path := fmt.Sprintf("/streamer/api/v3/dvb_cards/%s/available_programs", name)
	result := &model.MediaInfoListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// DvbCardAvailableProgramsGetIterator iterates through all MediaInfo items using cursor pagination.
func (c *Client) DvbCardAvailableProgramsGetIterator(ctx context.Context, name string, query *DvbCardAvailableProgramsGetQuery) iter.Seq2[model.MediaInfo, error] {
	return cursors.Iterator(ctx, func(ctx context.Context, query *DvbCardAvailableProgramsGetQuery) (model.MediaInfoList, error) {
		return c.DvbCardAvailableProgramsGet(ctx, name, query)
	}, query)
}

// DvbCardDelete Delete the DVB card
// Delete the DVB card by its name.
func (c *Client) DvbCardDelete(ctx context.Context, name string) error {
	path := fmt.Sprintf("/streamer/api/v3/dvb_cards/%s", name)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// DvbCardGet Get the DVB card
// This method allows to get a single DVB card by name.
func (c *Client) DvbCardGet(ctx context.Context, name string) (model.DvbCardConfig, error) {
	path := fmt.Sprintf("/streamer/api/v3/dvb_cards/%s", name)
	result := &model.DvbCardConfigImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// DvbCardSave Save the DVB card
// Create or update a DVB card. If you pass only a partial DVB card configuration, only the passed fields will be updated, not the whole configuration.
func (c *Client) DvbCardSave(ctx context.Context, name string, body model.DvbCardConfig) (model.DvbCardConfig, error) {
	path := fmt.Sprintf("/streamer/api/v3/dvb_cards/%s", name)
	result := &model.DvbCardConfigImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// DvbCardsList Get list of DVB cards
// This method allows to get the list of all DVB cards configured in Flussonic.
func (c *Client) DvbCardsList(ctx context.Context, query *DvbCardsListQuery) (model.DvbCardsList, error) {
	path := "/streamer/api/v3/dvb_cards"
	result := &model.DvbCardsListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// DvbCardsListIterator iterates through all DvbCardConfig items using cursor pagination.
func (c *Client) DvbCardsListIterator(ctx context.Context, query *DvbCardsListQuery) iter.Seq2[model.DvbCardConfig, error] {
	return cursors.Iterator(ctx, c.DvbCardsList, query)
}

// DvrDelete Delete DVR configuration
// Delete a single global DVR configuration by its name.
func (c *Client) DvrDelete(ctx context.Context, name string) error {
	path := fmt.Sprintf("/streamer/api/v3/dvrs/%s", name)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// DvrDiskDelete Delete the DVR disk
// Delete the DVR disk by its path.
func (c *Client) DvrDiskDelete(ctx context.Context, name string, pathParam string) error {
	path := fmt.Sprintf("/streamer/api/v3/dvrs/%s/disks/%s", name, pathParam)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// DvrDiskGet Get the DVR disk
// This method allows to get a single DVR disk for a DVR configuration with RAID enabled.
func (c *Client) DvrDiskGet(ctx context.Context, name string, pathParam string) (model.RaidDiskConfig, error) {
	path := fmt.Sprintf("/streamer/api/v3/dvrs/%s/disks/%s", name, pathParam)
	result := &model.RaidDiskConfigImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// DvrDiskSave Save the DVR disk
// Create or update a DVR disk.  If you pass only a partial DVR disk configuration, only the passed fields will be updated, not the whole disk configuration.
func (c *Client) DvrDiskSave(ctx context.Context, name string, pathParam string, body model.RaidDiskConfig) (model.RaidDiskConfig, error) {
	path := fmt.Sprintf("/streamer/api/v3/dvrs/%s/disks/%s", name, pathParam)
	result := &model.RaidDiskConfigImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// DvrDisksList List the DVR disks
// This method allows to get the whole list of disks for a DVR configuration with RAID enabled.  Learn more in [Flussonic RAID for DVR](https://flussonic.com/doc/extend-video-storage-on-fly/).
func (c *Client) DvrDisksList(ctx context.Context, name string, query *DvrDisksListQuery) (model.DvrDisksList, error) {
	path := fmt.Sprintf("/streamer/api/v3/dvrs/%s/disks", name)
	result := &model.DvrDisksListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// DvrDisksListIterator iterates through all RaidDiskConfig items using cursor pagination.
func (c *Client) DvrDisksListIterator(ctx context.Context, name string, query *DvrDisksListQuery) iter.Seq2[model.RaidDiskConfig, error] {
	return cursors.Iterator(ctx, func(ctx context.Context, query *DvrDisksListQuery) (model.DvrDisksList, error) {
		return c.DvrDisksList(ctx, name, query)
	}, query)
}

// DvrEpisodesList Recorded episodes list
// This method allows you to fetch registered episodes with dvr recording status
func (c *Client) DvrEpisodesList(ctx context.Context, query *DvrEpisodesListQuery) (model.EpisodesList, error) {
	path := "/streamer/api/v3/dvr_episodes"
	result := &model.EpisodesListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// DvrEpisodesListIterator iterates through all Episode items using cursor pagination.
func (c *Client) DvrEpisodesListIterator(ctx context.Context, query *DvrEpisodesListQuery) iter.Seq2[model.Episode, error] {
	return cursors.Iterator(ctx, c.DvrEpisodesList, query)
}

// DvrExportJobCancel Cancel the job
// Cancel the DVR export job.
func (c *Client) DvrExportJobCancel(ctx context.Context, id string) error {
	path := fmt.Sprintf("/streamer/api/v3/dvr_export_jobs/%s", id)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// DvrExportJobList List DVR background jobs
// List DVR export jobs
func (c *Client) DvrExportJobList(ctx context.Context) (model.DvrExportJobList, error) {
	path := "/streamer/api/v3/dvr_export_jobs"
	result := &model.DvrExportJobListImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// DvrExportJobStart Start a job
// Start a new DVR export job
func (c *Client) DvrExportJobStart(ctx context.Context, id string, body model.DvrExportJob) (model.DvrExportJob, error) {
	path := fmt.Sprintf("/streamer/api/v3/dvr_export_jobs/%s", id)
	result := &model.DvrExportJobImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// DvrExportJobStatus Get the job status
// Get the status of the DVR export job
func (c *Client) DvrExportJobStatus(ctx context.Context, id string) (model.DvrExportJob, error) {
	path := fmt.Sprintf("/streamer/api/v3/dvr_export_jobs/%s", id)
	result := &model.DvrExportJobImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// DvrGet Get DVR configuration
// This method allows to get a single global DVR configuration.
func (c *Client) DvrGet(ctx context.Context, name string) (model.DvrConfig, error) {
	path := fmt.Sprintf("/streamer/api/v3/dvrs/%s", name)
	result := &model.DvrConfigImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// DvrSave Save DVR configuration
// Create or update a single global DVR configuration.  If you pass only a partial DVR configuration, only the passed fields will be updated, not the whole configuration.
func (c *Client) DvrSave(ctx context.Context, name string, body model.DvrConfig) (model.DvrConfig, error) {
	path := fmt.Sprintf("/streamer/api/v3/dvrs/%s", name)
	result := &model.DvrConfigImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// DvrsList List DVR configurations
// This method allows to get the whole list of global DVR congifurations.
func (c *Client) DvrsList(ctx context.Context, query *DvrsListQuery) (model.DvrsList, error) {
	path := "/streamer/api/v3/dvrs"
	result := &model.DvrsListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// DvrsListIterator iterates through all DvrConfig items using cursor pagination.
func (c *Client) DvrsListIterator(ctx context.Context, query *DvrsListQuery) iter.Seq2[model.DvrConfig, error] {
	return cursors.Iterator(ctx, c.DvrsList, query)
}

// EpisodesList List episodes
// This method allows you to fetch registered episodes
func (c *Client) EpisodesList(ctx context.Context, query *EpisodesListQuery) (model.EpisodesList, error) {
	path := "/streamer/api/v3/episodes"
	result := &model.EpisodesListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// EpisodesListIterator iterates through all Episode items using cursor pagination.
func (c *Client) EpisodesListIterator(ctx context.Context, query *EpisodesListQuery) iter.Seq2[model.Episode, error] {
	return cursors.Iterator(ctx, c.EpisodesList, query)
}

// EventSinkDelete Delete an event sink configuration
// Delete an event sink configuration by its name.
func (c *Client) EventSinkDelete(ctx context.Context, name string) error {
	path := fmt.Sprintf("/streamer/api/v3/event_sinks/%s", name)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// EventSinkGet Get one event sink configuration
// This method allows to get a single event sink configuration.
func (c *Client) EventSinkGet(ctx context.Context, name string) (model.EventSinkConfig, error) {
	path := fmt.Sprintf("/streamer/api/v3/event_sinks/%s", name)
	result := &model.EventSinkConfigImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// EventSinkSave Save a single event sink configuration
// Create or update an event sink configuration by its name.
func (c *Client) EventSinkSave(ctx context.Context, name string, body model.EventSinkConfig) (model.EventSinkConfig, error) {
	path := fmt.Sprintf("/streamer/api/v3/event_sinks/%s", name)
	result := &model.EventSinkConfigImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// EventSinksList List event sinks configs
// This method allows to get the list of all event sinks (former `notify`) configured in Flussonic.  Each event sink is an instruction for Flussonic to send events to some target.  In particular, you can configure sending events to an event handler or writing them to a log file.  Event sink has its unique name just for management purposes, event filtering instructions and target for sending events.
func (c *Client) EventSinksList(ctx context.Context, query *EventSinksListQuery) (model.EventSinksList, error) {
	path := "/streamer/api/v3/event_sinks"
	result := &model.EventSinksListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// EventSinksListIterator iterates through all EventSinkConfig items using cursor pagination.
func (c *Client) EventSinksListIterator(ctx context.Context, query *EventSinksListQuery) iter.Seq2[model.EventSinkConfig, error] {
	return cursors.Iterator(ctx, c.EventSinksList, query)
}

// FileProcessorDelete Delete the file processor
// Delete the file processor config
func (c *Client) FileProcessorDelete(ctx context.Context) error {
	path := "/streamer/api/v3/file_processor"
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// FileProcessorGet Get the file processor config
// Get the file processor config
func (c *Client) FileProcessorGet(ctx context.Context) (model.FileProcessorConfig, error) {
	path := "/streamer/api/v3/file_processor"
	result := &model.FileProcessorConfigImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// FileProcessorJobCheck Get the job status
// Get the status of the file processor job.
func (c *Client) FileProcessorJobCheck(ctx context.Context, id string) (model.FileProcessorJob, error) {
	path := fmt.Sprintf("/streamer/api/v3/file_processor/jobs/%s", id)
	result := &model.FileProcessorJobImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// FileProcessorJobDelete Cancel the job
// Cancel the file processor job.
func (c *Client) FileProcessorJobDelete(ctx context.Context, id string) error {
	path := fmt.Sprintf("/streamer/api/v3/file_processor/jobs/%s", id)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// FileProcessorJobStart Start file_processor job
// Start the file processor job.
func (c *Client) FileProcessorJobStart(ctx context.Context, body model.FileProcessorJob) (model.FileProcessorJob, error) {
	path := "/streamer/api/v3/file_processor/jobs"
	result := &model.FileProcessorJobImpl{}
	if err := c.doPost(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// FileProcessorSave Save the file processor
// Update the file processor config
func (c *Client) FileProcessorSave(ctx context.Context, body model.FileProcessorConfig) (model.FileProcessorConfig, error) {
	path := "/streamer/api/v3/file_processor"
	result := &model.FileProcessorConfigImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// HttpProxiesList List http proxy configuration
// This method allows to get the whole list of http proxy congifurations.
func (c *Client) HttpProxiesList(ctx context.Context, query *HttpProxiesListQuery) (model.HTTPProxiesList, error) {
	path := "/streamer/api/v3/http_proxies"
	result := &model.HTTPProxiesListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// HttpProxiesListIterator iterates through all HTTPProxyConfig items using cursor pagination.
func (c *Client) HttpProxiesListIterator(ctx context.Context, query *HttpProxiesListQuery) iter.Seq2[model.HTTPProxyConfig, error] {
	return cursors.Iterator(ctx, c.HttpProxiesList, query)
}

// HttpProxyDelete Delete http_proxy
// Delete http_proxy configuration.
func (c *Client) HttpProxyDelete(ctx context.Context, prefix string) error {
	path := fmt.Sprintf("/streamer/api/v3/http_proxies/%s", prefix)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// HttpProxyGet Get http_proxy
// Get http_proxy configuration.
func (c *Client) HttpProxyGet(ctx context.Context, prefix string) (model.HTTPProxyConfig, error) {
	path := fmt.Sprintf("/streamer/api/v3/http_proxies/%s", prefix)
	result := &model.HTTPProxyConfigImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// HttpProxySave Save http_proxy
// Update http_proxy configuration.
func (c *Client) HttpProxySave(ctx context.Context, prefix string, body model.HTTPProxyConfig) (model.HTTPProxyConfig, error) {
	path := fmt.Sprintf("/streamer/api/v3/http_proxies/%s", prefix)
	result := &model.HTTPProxyConfigImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// IptvDelete Disable IPTV
// Disable trivial IPTV plugin, remove it from the config and stop runtime status.
func (c *Client) IptvDelete(ctx context.Context) error {
	path := "/streamer/api/v3/iptv"
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// IptvGet IPTV status
// Get current status of the trivial IPTV subscriber management system.
func (c *Client) IptvGet(ctx context.Context) (model.IptvConfig, error) {
	path := "/streamer/api/v3/iptv"
	result := &model.IptvConfigImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// IptvSave Save IPTV
// Enable or reload IPTV plugin configuration and disk state
func (c *Client) IptvSave(ctx context.Context, body model.IptvConfig) (model.IptvConfig, error) {
	path := "/streamer/api/v3/iptv"
	result := &model.IptvConfigImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// LivenessProbe Liveness probe
// K8s liveness probe.
func (c *Client) LivenessProbe(ctx context.Context) (model.ServerStatsWhoami, error) {
	path := "/streamer/api/v3/monitoring/liveness"
	result := &model.ServerStatsWhoamiImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// LogoDelete Delete the logo file
// Delete the logo by its path
func (c *Client) LogoDelete(ctx context.Context, name string) error {
	path := fmt.Sprintf("/streamer/api/v3/logos/%s", name)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// LogoGet Get the logo
// Method allows to fetch single logo file
func (c *Client) LogoGet(ctx context.Context, name string) (model.LogoFile, error) {
	path := fmt.Sprintf("/streamer/api/v3/logos/%s", name)
	result := &model.LogoFileImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// LogoSave Upload the logo
// Upload logo file
func (c *Client) LogoSave(ctx context.Context, name string, body model.LogoFile) (model.LogoFile, error) {
	path := fmt.Sprintf("/streamer/api/v3/logos/%s", name)
	result := &model.LogoFileImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// LogosList List logos
// List logo files
func (c *Client) LogosList(ctx context.Context, query *LogosListQuery) (model.LogosList, error) {
	path := "/streamer/api/v3/logos"
	result := &model.LogosListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// LogosListIterator iterates through all LogoFile items using cursor pagination.
func (c *Client) LogosListIterator(ctx context.Context, query *LogosListQuery) iter.Seq2[model.LogoFile, error] {
	return cursors.Iterator(ctx, c.LogosList, query)
}

// MultiplexerXmltvUpload Upload XMLTV files
// Upload XMLTV files to multiplexer
func (c *Client) MultiplexerXmltvUpload(ctx context.Context, name string) error {
	path := fmt.Sprintf("/streamer/api/v3/multiplexers/%s/xmltv_upload", name)
	if err := c.doPost(ctx, path, nil, nil); err != nil {
		return err
	}
	return nil
}

// OpenedFilesList List files in VOD locations which are played by the clients
// This method allows to get the list of files in VOD locations which are played by the clients.
func (c *Client) OpenedFilesList(ctx context.Context, query *OpenedFilesListQuery) (model.DiskFilesList, error) {
	path := "/streamer/api/v3/vods/opened_files"
	result := &model.DiskFilesListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// OpenedFilesListIterator iterates through all DiskFile items using cursor pagination.
func (c *Client) OpenedFilesListIterator(ctx context.Context, query *OpenedFilesListQuery) iter.Seq2[model.DiskFile, error] {
	return cursors.Iterator(ctx, c.OpenedFilesList, query)
}

// PackageDelete Delete the package
// Delete this package with all links to streams and all links to subscribers.
func (c *Client) PackageDelete(ctx context.Context, name string) error {
	path := fmt.Sprintf("/streamer/api/v3/iptv/packages/%s", name)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// PackageGet Get the package
// Package is a group of streams (channels), that are provided together to customer as a single billing item.
func (c *Client) PackageGet(ctx context.Context, name string) (model.PackageConfig, error) {
	path := fmt.Sprintf("/streamer/api/v3/iptv/packages/%s", name)
	result := &model.PackageConfigImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// PackageSave Save the package
// Create or update the package.  Partial configuration can be provided.
func (c *Client) PackageSave(ctx context.Context, name string, body model.PackageConfig) (model.PackageConfig, error) {
	path := fmt.Sprintf("/streamer/api/v3/iptv/packages/%s", name)
	result := &model.PackageConfigImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// PackagesList List all packages
// List existing packages. Take a look at operation `package_get` for detailed description of package concept.
func (c *Client) PackagesList(ctx context.Context, query *PackagesListQuery) (model.PackagesList, error) {
	path := "/streamer/api/v3/iptv/packages"
	result := &model.PackagesListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// PackagesListIterator iterates through all PackageConfig items using cursor pagination.
func (c *Client) PackagesListIterator(ctx context.Context, query *PackagesListQuery) iter.Seq2[model.PackageConfig, error] {
	return cursors.Iterator(ctx, c.PackagesList, query)
}

// PeerDelete Delete the peer
// Delete the peer by its name
func (c *Client) PeerDelete(ctx context.Context, hostname string) error {
	path := fmt.Sprintf("/streamer/api/v3/cluster/peers/%s", hostname)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// PeerGet Get the peer
// Method allows to fetch single peer
func (c *Client) PeerGet(ctx context.Context, hostname string) (model.PeerConfig, error) {
	path := fmt.Sprintf("/streamer/api/v3/cluster/peers/%s", hostname)
	result := &model.PeerConfigImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// PeerSave Save the peer
// Create or update peer
func (c *Client) PeerSave(ctx context.Context, hostname string, body model.PeerConfig) (model.PeerConfig, error) {
	path := fmt.Sprintf("/streamer/api/v3/cluster/peers/%s", hostname)
	result := &model.PeerConfigImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// PeersList List peers
// Fetch all peers
func (c *Client) PeersList(ctx context.Context, query *PeersListQuery) (model.PeersList, error) {
	path := "/streamer/api/v3/cluster/peers"
	result := &model.PeersListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// PeersListIterator iterates through all PeerConfig items using cursor pagination.
func (c *Client) PeersListIterator(ctx context.Context, query *PeersListQuery) iter.Seq2[model.PeerConfig, error] {
	return cursors.Iterator(ctx, c.PeersList, query)
}

// ReadinessProbe Readiness probe
// K8s readiness probe.
func (c *Client) ReadinessProbe(ctx context.Context) (model.ServerStatsWhoami, error) {
	path := "/streamer/api/v3/monitoring/readiness"
	result := &model.ServerStatsWhoamiImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// RproxyAgentsList List connected streampoint agents
// Return a list of agents currently connected to the streampoint
func (c *Client) RproxyAgentsList(ctx context.Context, query *RproxyAgentsListQuery) (model.WatcherAgentsList, error) {
	path := "/streamer/api/v3/rproxy/agents"
	result := &model.WatcherAgentsListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// RproxyAgentsListIterator iterates through all WatcherAgentConfig items using cursor pagination.
func (c *Client) RproxyAgentsListIterator(ctx context.Context, query *RproxyAgentsListQuery) iter.Seq2[model.WatcherAgentConfig, error] {
	return cursors.Iterator(ctx, c.RproxyAgentsList, query)
}

// RproxyDelete Delete rproxy
// Delete rproxy configuration.
func (c *Client) RproxyDelete(ctx context.Context) error {
	path := "/streamer/api/v3/rproxy"
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// RproxyGet Get rproxy
// Get rproxy configuration.
func (c *Client) RproxyGet(ctx context.Context) (model.RproxyConfig, error) {
	path := "/streamer/api/v3/rproxy"
	result := &model.RproxyConfigImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// RproxySave Save rproxy
// Update rproxy configuration.
func (c *Client) RproxySave(ctx context.Context, body model.RproxyConfig) (model.RproxyConfig, error) {
	path := "/streamer/api/v3/rproxy"
	result := &model.RproxyConfigImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// SessionDelete Close the session
// Close the play session. The closed session will be available in the sessions history.
func (c *Client) SessionDelete(ctx context.Context, id string) error {
	path := fmt.Sprintf("/streamer/api/v3/sessions/%s", id)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// SessionGet Get the session
// Get the play session.
func (c *Client) SessionGet(ctx context.Context, id string) (model.Session, error) {
	path := fmt.Sprintf("/streamer/api/v3/sessions/%s", id)
	result := &model.SessionImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// SessionsList List sessions
// This method returns list of opened play sessions.  At this moment sessions are filtered only to `type=play`, however later we may add additional sessions like `publish`, `push`, or `ingest`.
func (c *Client) SessionsList(ctx context.Context, query *SessionsListQuery) (model.SessionsList, error) {
	path := "/streamer/api/v3/sessions"
	result := &model.SessionsListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// SessionsListIterator iterates through all Session items using cursor pagination.
func (c *Client) SessionsListIterator(ctx context.Context, query *SessionsListQuery) iter.Seq2[model.Session, error] {
	return cursors.Iterator(ctx, c.SessionsList, query)
}

// SessionsReauth Invalidate auth backend response cache for sessions of specified stream
// Flussonic immediately re-call auth-backend and check if session is still authorized. This will be done for all open sessions.
func (c *Client) SessionsReauth(ctx context.Context, query *SessionsReauthQuery) (model.CollectionResponse, error) {
	path := "/streamer/api/v3/sessions/reauth"
	result := &model.CollectionResponseImpl{}
	if err := c.doPost(ctx, path, nil, result); err != nil {
		return nil, err
	}
	return result, nil
}

// SourceDelete Delete the source
// Delete the source by its name
func (c *Client) SourceDelete(ctx context.Context, url string) error {
	path := fmt.Sprintf("/streamer/api/v3/cluster/sources/%s", url)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// SourceGet Get the source
// Method allows to fetch single source
func (c *Client) SourceGet(ctx context.Context, url string) (model.SourceConfig, error) {
	path := fmt.Sprintf("/streamer/api/v3/cluster/sources/%s", url)
	result := &model.SourceConfigImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// SourceSave Save the source
// Create or update source
func (c *Client) SourceSave(ctx context.Context, url string, body model.SourceConfig) (model.SourceConfig, error) {
	path := fmt.Sprintf("/streamer/api/v3/cluster/sources/%s", url)
	result := &model.SourceConfigImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// SourcesList List sources
// Fetch all sources
func (c *Client) SourcesList(ctx context.Context, query *SourcesListQuery) (model.SourcesList, error) {
	path := "/streamer/api/v3/cluster/sources"
	result := &model.SourcesListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// SourcesListIterator iterates through all SourceConfig items using cursor pagination.
func (c *Client) SourcesListIterator(ctx context.Context, query *SourcesListQuery) iter.Seq2[model.SourceConfig, error] {
	return cursors.Iterator(ctx, c.SourcesList, query)
}

// StreamDelete Delete the stream
// This method allows to delete a single stream.
func (c *Client) StreamDelete(ctx context.Context, name string) error {
	path := fmt.Sprintf("/streamer/api/v3/streams/%s", name)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// StreamDvrConsistencyCheck Check stream DVR
// Run DVR consistency checks on this stream. When there are any problems found, errors are returned in response body. This is a diagnostic operation, response format is not fully specified.
func (c *Client) StreamDvrConsistencyCheck(ctx context.Context, name string) (model.DvrConsistencyErrors, error) {
	path := fmt.Sprintf("/streamer/api/v3/streams/%s/dvr/consistency_check", name)
	result := &model.DvrConsistencyErrorsImpl{}
	if err := c.doPost(ctx, path, nil, result); err != nil {
		return nil, err
	}
	return result, nil
}

// StreamDvrLocksDelete Unlock stream recorded DVR range
// This method allows to unlock a DVR range for a stream.
func (c *Client) StreamDvrLocksDelete(ctx context.Context, name string, body model.DvrRange) error {
	path := fmt.Sprintf("/streamer/api/v3/streams/%s/dvr/locks", name)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// StreamDvrLocksList Get stream locked dvr ranges
// This method allows to get the list of locked DVR ranges for a stream.
func (c *Client) StreamDvrLocksList(ctx context.Context, name string, query *StreamDvrLocksListQuery) (model.StreamDvrLocksList, error) {
	path := fmt.Sprintf("/streamer/api/v3/streams/%s/dvr/locks", name)
	result := &model.StreamDvrLocksListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// StreamDvrLocksListIterator iterates through all DvrRange items using cursor pagination.
func (c *Client) StreamDvrLocksListIterator(ctx context.Context, name string, query *StreamDvrLocksListQuery) iter.Seq2[model.DvrRange, error] {
	return cursors.Iterator(ctx, func(ctx context.Context, query *StreamDvrLocksListQuery) (model.StreamDvrLocksList, error) {
		return c.StreamDvrLocksList(ctx, name, query)
	}, query)
}

// StreamDvrLocksSave Lock stream recorded DVR range
// This method allows to lock a DVR range for a stream. Locking can be useful for the nPVR (Network Personal Video Recorder) service or just for keeping important recordings.
func (c *Client) StreamDvrLocksSave(ctx context.Context, name string, body model.DvrRange) error {
	path := fmt.Sprintf("/streamer/api/v3/streams/%s/dvr/locks", name)
	if err := c.doPost(ctx, path, body, nil); err != nil {
		return err
	}
	return nil
}

// StreamDvrRangesDelete Delete stream recorded DVR range
// This method allows to delete a DVR recording in a specified range for a stream.
func (c *Client) StreamDvrRangesDelete(ctx context.Context, name string, body model.DvrRange) error {
	path := fmt.Sprintf("/streamer/api/v3/streams/%s/dvr/ranges", name)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// StreamDvrRangesList Get stream recorded dvr ranges
// This method allows to get the list of DVR recorded ranges for a stream.
func (c *Client) StreamDvrRangesList(ctx context.Context, name string, query *StreamDvrRangesListQuery) (model.StreamDvrRangesList, error) {
	path := fmt.Sprintf("/streamer/api/v3/streams/%s/dvr/ranges", name)
	result := &model.StreamDvrRangesListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// StreamDvrRangesListIterator iterates through all DvrRange items using cursor pagination.
func (c *Client) StreamDvrRangesListIterator(ctx context.Context, name string, query *StreamDvrRangesListQuery) iter.Seq2[model.DvrRange, error] {
	return cursors.Iterator(ctx, func(ctx context.Context, query *StreamDvrRangesListQuery) (model.StreamDvrRangesList, error) {
		return c.StreamDvrRangesList(ctx, name, query)
	}, query)
}

// StreamGet Get one stream
// This method allows to fetch a single stream. Refer to the `streams_list` operation to find out what data will be returned in this method.
func (c *Client) StreamGet(ctx context.Context, name string) (model.StreamConfig, error) {
	path := fmt.Sprintf("/streamer/api/v3/streams/%s", name)
	result := &model.StreamConfigImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// StreamSave Save stream
// Create or update a stream by its name. If the stream doesn't exist in the disk config, it will be created.  If you update a stream that is created with a template using a user request having `named_by=user`, a new stream will be created in the disk config.  If you pass partial stream configuration, this exact part will be updated, not the whole stream.  To disable a feature, provide the corresponding property with the `null` value, like `'{"drm": null}'`.  Pass the `"$reset": true` option to replace the stream configuration with the provided one.
func (c *Client) StreamSave(ctx context.Context, name string, body model.StreamConfig) (model.StreamConfig, error) {
	path := fmt.Sprintf("/streamer/api/v3/streams/%s", name)
	result := &model.StreamConfigImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// StreamSaveMp4 Export DVR as MP4 file
// This method allows to export MP4 files from DVR and save them on the server disk or to the S3 bucket.
func (c *Client) StreamSaveMp4(ctx context.Context, name string, query *StreamSaveMp4Query) error {
	path := fmt.Sprintf("/streamer/api/v3/streams/%s/dvr/export", name)
	if err := c.doPost(ctx, path, nil, nil); err != nil {
		return err
	}
	return nil
}

// StreamStop Stop the stream
// Stop the stream with a specified name.  If the stream is static, it will restart according to existing rules.  This API call is a replacement for both: stop and restart.  Server cannot restart a stream that was started by user (publish for example), because it cannot ask user to repeat publishing.  Static stream declared in config will be started automatically as if it failed due to any bug.  This is why `restart` is actually a `stop` and maybe `start`, while `start` is made by live stream subsystem
func (c *Client) StreamStop(ctx context.Context, name string) error {
	path := fmt.Sprintf("/streamer/api/v3/streams/%s/stop", name)
	if err := c.doPost(ctx, path, nil, nil); err != nil {
		return err
	}
	return nil
}

// StreamsList List streams
// This API method is one of the most important in whole API, because it gives the list of all streams, including:  * configured (may not be running at the moment) * running (including those that are created via a template and do not have own disk configuration) * remote (available from other servers) * only recorded  Together with the `stream_save` method you can manage streams in Flussonic.  You can pass all stream configuration options to query string for filtering, not only specified in the parameters.  This method and `stream_get` will return `effective stream configuration` with all templates, defaults included into this response. It is not exactly what you can see in the disk config. If you have configured this stream in the disk file, then the original disk configuration can be found in the field `config_on_disk`.  What you get from this API call is not what you write to `stream_save`.
func (c *Client) StreamsList(ctx context.Context, query *StreamsListQuery) (model.StreamsList, error) {
	path := "/streamer/api/v3/streams"
	result := &model.StreamsListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// StreamsListIterator iterates through all StreamConfig items using cursor pagination.
func (c *Client) StreamsListIterator(ctx context.Context, query *StreamsListQuery) iter.Seq2[model.StreamConfig, error] {
	return cursors.Iterator(ctx, c.StreamsList, query)
}

// SubscriberDelete Delete the subscriber
// Delete the subscriber from database. If he is watching video, all his sessions will be terminated soon.
func (c *Client) SubscriberDelete(ctx context.Context, name string) error {
	path := fmt.Sprintf("/streamer/api/v3/iptv/subscribers/%s", name)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// SubscriberGet Get one subscriber
// Get the subscriber status.
func (c *Client) SubscriberGet(ctx context.Context, name string) (model.SubscriberConfig, error) {
	path := fmt.Sprintf("/streamer/api/v3/iptv/subscribers/%s", name)
	result := &model.SubscriberConfigImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// SubscriberSave Save the subscriber
// Create or update the subscriber, identified by his unique name. Partial configuration is ok.
func (c *Client) SubscriberSave(ctx context.Context, name string, body model.SubscriberConfig) (model.SubscriberConfig, error) {
	path := fmt.Sprintf("/streamer/api/v3/iptv/subscribers/%s", name)
	result := &model.SubscriberConfigImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// SubscribersList List all subscribers
// List existing subscribers from database
func (c *Client) SubscribersList(ctx context.Context, query *SubscribersListQuery) (model.SubscribersList, error) {
	path := "/streamer/api/v3/iptv/subscribers"
	result := &model.SubscribersListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// SubscribersListIterator iterates through all SubscriberConfig items using cursor pagination.
func (c *Client) SubscribersListIterator(ctx context.Context, query *SubscribersListQuery) iter.Seq2[model.SubscriberConfig, error] {
	return cursors.Iterator(ctx, c.SubscribersList, query)
}

// TemplateDelete Delete the template
// Delete the template by its name.
func (c *Client) TemplateDelete(ctx context.Context, name string) error {
	path := fmt.Sprintf("/streamer/api/v3/templates/%s", name)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// TemplateGet Get the template
// This method allows to get a single template by name.
func (c *Client) TemplateGet(ctx context.Context, name string) (model.TemplateConfig, error) {
	path := fmt.Sprintf("/streamer/api/v3/templates/%s", name)
	result := &model.TemplateConfigImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// TemplateSave Save the template
// Create or update a template.  If you pass only a partial template configuration, only the passed fields will be updated, not the whole template.
func (c *Client) TemplateSave(ctx context.Context, name string, body model.TemplateConfig) (model.TemplateConfig, error) {
	path := fmt.Sprintf("/streamer/api/v3/templates/%s", name)
	result := &model.TemplateConfigImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// TemplatesList List templates
// This method allows to get the list of all templates in Flussonic with all their settings.
func (c *Client) TemplatesList(ctx context.Context, query *TemplatesListQuery) (model.TemplatesList, error) {
	path := "/streamer/api/v3/templates"
	result := &model.TemplatesListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// TemplatesListIterator iterates through all TemplateConfig items using cursor pagination.
func (c *Client) TemplatesListIterator(ctx context.Context, query *TemplatesListQuery) iter.Seq2[model.TemplateConfig, error] {
	return cursors.Iterator(ctx, c.TemplatesList, query)
}

// TransponderDelete Delete the multiplexer
// Delete the multiplexer by its name.
func (c *Client) TransponderDelete(ctx context.Context, name string) error {
	path := fmt.Sprintf("/streamer/api/v3/transponders/%s", name)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// TransponderGet Get the multiplexer
// This method allows you to fetch a single multiplexer.
func (c *Client) TransponderGet(ctx context.Context, name string) (model.TransponderConfig, error) {
	path := fmt.Sprintf("/streamer/api/v3/transponders/%s", name)
	result := &model.TransponderConfigImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// TransponderOtherDelete Delete the other multiplexer
// Delete the other multiplexer by its index.
func (c *Client) TransponderOtherDelete(ctx context.Context, name string, index string) error {
	path := fmt.Sprintf("/streamer/api/v3/transponders/%s/others/%s", name, index)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// TransponderOtherGet Get the other multiplexer
// Method allows to fetch a single other multiplexer.
func (c *Client) TransponderOtherGet(ctx context.Context, name string, index string) (model.TransponderOther, error) {
	path := fmt.Sprintf("/streamer/api/v3/transponders/%s/others/%s", name, index)
	result := &model.TransponderOtherImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// TransponderOtherSave Save the other multiplexer
// Create or update other multiplexer.
func (c *Client) TransponderOtherSave(ctx context.Context, name string, index string, body model.TransponderOther) (model.TransponderOther, error) {
	path := fmt.Sprintf("/streamer/api/v3/transponders/%s/others/%s", name, index)
	result := &model.TransponderOtherImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// TransponderOthersList Get other multiplexers
// Fetch all other multiplexers for the multiplexer with the specified name.
func (c *Client) TransponderOthersList(ctx context.Context, name string, query *TransponderOthersListQuery) (model.TransponderOthersList, error) {
	path := fmt.Sprintf("/streamer/api/v3/transponders/%s/others", name)
	result := &model.TransponderOthersListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// TransponderOthersListIterator iterates through all TransponderOther items using cursor pagination.
func (c *Client) TransponderOthersListIterator(ctx context.Context, name string, query *TransponderOthersListQuery) iter.Seq2[model.TransponderOther, error] {
	return cursors.Iterator(ctx, func(ctx context.Context, query *TransponderOthersListQuery) (model.TransponderOthersList, error) {
		return c.TransponderOthersList(ctx, name, query)
	}, query)
}

// TransponderProgramDelete Delete the multiplexer program
// Delete the multiplexer program by its number.
func (c *Client) TransponderProgramDelete(ctx context.Context, name string, program_id string) error {
	path := fmt.Sprintf("/streamer/api/v3/transponders/%s/programs/%s", name, program_id)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// TransponderProgramGet Get the multiplexer program
// Method allows you to fetch single multiplexer program.
func (c *Client) TransponderProgramGet(ctx context.Context, name string, program_id string) (model.TransponderProgram, error) {
	path := fmt.Sprintf("/streamer/api/v3/transponders/%s/programs/%s", name, program_id)
	result := &model.TransponderProgramImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// TransponderProgramSave Save the multiplexer program
// Create or update multiplexer program.
func (c *Client) TransponderProgramSave(ctx context.Context, name string, program_id string, body model.TransponderProgram) (model.TransponderProgram, error) {
	path := fmt.Sprintf("/streamer/api/v3/transponders/%s/programs/%s", name, program_id)
	result := &model.TransponderProgramImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// TransponderProgramsList Get multiplexer programs
// Fetch all multiplexer programs.
func (c *Client) TransponderProgramsList(ctx context.Context, name string, query *TransponderProgramsListQuery) (model.TransponderProgramsList, error) {
	path := fmt.Sprintf("/streamer/api/v3/transponders/%s/programs", name)
	result := &model.TransponderProgramsListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// TransponderProgramsListIterator iterates through all TransponderProgram items using cursor pagination.
func (c *Client) TransponderProgramsListIterator(ctx context.Context, name string, query *TransponderProgramsListQuery) iter.Seq2[model.TransponderProgram, error] {
	return cursors.Iterator(ctx, func(ctx context.Context, query *TransponderProgramsListQuery) (model.TransponderProgramsList, error) {
		return c.TransponderProgramsList(ctx, name, query)
	}, query)
}

// TransponderPushDelete Delete the multiplexer push
// Delete the multiplexer push by its index.
func (c *Client) TransponderPushDelete(ctx context.Context, name string, index string) error {
	path := fmt.Sprintf("/streamer/api/v3/transponders/%s/pushes/%s", name, index)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// TransponderPushGet Get the multiplexer push
// Method allows to fetch single multiplexer push.
func (c *Client) TransponderPushGet(ctx context.Context, name string, index string) (model.TransponderPush, error) {
	path := fmt.Sprintf("/streamer/api/v3/transponders/%s/pushes/%s", name, index)
	result := &model.TransponderPushImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// TransponderPushSave Save the multiplexer push
// Create or update multiplexer push.
func (c *Client) TransponderPushSave(ctx context.Context, name string, index string, body model.TransponderPush) (model.TransponderPush, error) {
	path := fmt.Sprintf("/streamer/api/v3/transponders/%s/pushes/%s", name, index)
	result := &model.TransponderPushImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// TransponderPushesList Get multiplexer pushes
// Fetch all multiplexer pushes.
func (c *Client) TransponderPushesList(ctx context.Context, name string, query *TransponderPushesListQuery) (model.TransponderPushesList, error) {
	path := fmt.Sprintf("/streamer/api/v3/transponders/%s/pushes", name)
	result := &model.TransponderPushesListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// TransponderPushesListIterator iterates through all TransponderPush items using cursor pagination.
func (c *Client) TransponderPushesListIterator(ctx context.Context, name string, query *TransponderPushesListQuery) iter.Seq2[model.TransponderPush, error] {
	return cursors.Iterator(ctx, func(ctx context.Context, query *TransponderPushesListQuery) (model.TransponderPushesList, error) {
		return c.TransponderPushesList(ctx, name, query)
	}, query)
}

// TransponderSave Save the multiplexer
// Create or update the multiplexer.
func (c *Client) TransponderSave(ctx context.Context, name string, body model.TransponderConfig) (model.TransponderConfig, error) {
	path := fmt.Sprintf("/streamer/api/v3/transponders/%s", name)
	result := &model.TransponderConfigImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// TransponderTimeOffsetDelete Delete the multiplexer time_offset
// Delete the multiplexer time_offset by its index.
func (c *Client) TransponderTimeOffsetDelete(ctx context.Context, name string, index string) error {
	path := fmt.Sprintf("/streamer/api/v3/transponders/%s/time_offsets/%s", name, index)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// TransponderTimeOffsetGet Get the multiplexer time_offset
// Method allows to fetch single multiplexer time_offset
func (c *Client) TransponderTimeOffsetGet(ctx context.Context, name string, index string) (model.TransponderTimeOffset, error) {
	path := fmt.Sprintf("/streamer/api/v3/transponders/%s/time_offsets/%s", name, index)
	result := &model.TransponderTimeOffsetImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// TransponderTimeOffsetSave Save the multiplexer time_offset
// Create or update multiplexer time_offset
func (c *Client) TransponderTimeOffsetSave(ctx context.Context, name string, index string, body model.TransponderTimeOffset) (model.TransponderTimeOffset, error) {
	path := fmt.Sprintf("/streamer/api/v3/transponders/%s/time_offsets/%s", name, index)
	result := &model.TransponderTimeOffsetImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// TransponderTimeOffsetsList Get multiplexer time_offsets
// Fetch all multiplexer time_offsets.
func (c *Client) TransponderTimeOffsetsList(ctx context.Context, name string, query *TransponderTimeOffsetsListQuery) (model.TransponderTimeOffsetsList, error) {
	path := fmt.Sprintf("/streamer/api/v3/transponders/%s/time_offsets", name)
	result := &model.TransponderTimeOffsetsListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// TransponderTimeOffsetsListIterator iterates through all TransponderTimeOffset items using cursor pagination.
func (c *Client) TransponderTimeOffsetsListIterator(ctx context.Context, name string, query *TransponderTimeOffsetsListQuery) iter.Seq2[model.TransponderTimeOffset, error] {
	return cursors.Iterator(ctx, func(ctx context.Context, query *TransponderTimeOffsetsListQuery) (model.TransponderTimeOffsetsList, error) {
		return c.TransponderTimeOffsetsList(ctx, name, query)
	}, query)
}

// TransponderTsDescriptorDelete Delete the multiplexer MPEG-TS descriptor
// Delete the multiplexer descriptor by its index.
func (c *Client) TransponderTsDescriptorDelete(ctx context.Context, name string, index string) error {
	path := fmt.Sprintf("/streamer/api/v3/transponders/%s/ts_descriptors/%s", name, index)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// TransponderTsDescriptorGet Get the multiplexer descriptor
// This method allows you to fetch a single multiplexer descriptor.
func (c *Client) TransponderTsDescriptorGet(ctx context.Context, name string, index string) (model.TSDescriptor, error) {
	path := fmt.Sprintf("/streamer/api/v3/transponders/%s/ts_descriptors/%s", name, index)
	result := &model.TSDescriptorImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// TransponderTsDescriptorSave Save the multiplexer ts_descriptor
// Create or update multiplexer descriptor.
func (c *Client) TransponderTsDescriptorSave(ctx context.Context, name string, index string, body model.TSDescriptor) (model.TSDescriptor, error) {
	path := fmt.Sprintf("/streamer/api/v3/transponders/%s/ts_descriptors/%s", name, index)
	result := &model.TSDescriptorImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// TransponderTsDescriptorsList Get multiplexer ts_descriptors
// Fetch all multiplexer ts_descriptors.
func (c *Client) TransponderTsDescriptorsList(ctx context.Context, name string, query *TransponderTsDescriptorsListQuery) (model.TransponderTSDescriptorsList, error) {
	path := fmt.Sprintf("/streamer/api/v3/transponders/%s/ts_descriptors", name)
	result := &model.TransponderTSDescriptorsListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// TransponderTsDescriptorsListIterator iterates through all TSDescriptor items using cursor pagination.
func (c *Client) TransponderTsDescriptorsListIterator(ctx context.Context, name string, query *TransponderTsDescriptorsListQuery) iter.Seq2[model.TSDescriptor, error] {
	return cursors.Iterator(ctx, func(ctx context.Context, query *TransponderTsDescriptorsListQuery) (model.TransponderTSDescriptorsList, error) {
		return c.TransponderTsDescriptorsList(ctx, name, query)
	}, query)
}

// TranspondersList Get multiplexers
// Fetch the multiplexers list.
func (c *Client) TranspondersList(ctx context.Context, query *TranspondersListQuery) (model.TranspondersList, error) {
	path := "/streamer/api/v3/transponders"
	result := &model.TranspondersListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// TranspondersListIterator iterates through all TransponderConfig items using cursor pagination.
func (c *Client) TranspondersListIterator(ctx context.Context, query *TranspondersListQuery) iter.Seq2[model.TransponderConfig, error] {
	return cursors.Iterator(ctx, c.TranspondersList, query)
}

// VisionDelete Delete vision
// Delete the video analytics configuration.
func (c *Client) VisionDelete(ctx context.Context) error {
	path := "/streamer/api/v3/vision"
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// VisionGet Get vision
// Get the video analytics configuration.
func (c *Client) VisionGet(ctx context.Context) (model.VisionConfig, error) {
	path := "/streamer/api/v3/vision"
	result := &model.VisionConfigImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// VisionSave Save vision
// Save the video analytics configuration.
func (c *Client) VisionSave(ctx context.Context) (model.VisionConfig, error) {
	path := "/streamer/api/v3/vision"
	result := &model.VisionConfigImpl{}
	if err := c.doPut(ctx, path, nil, result); err != nil {
		return nil, err
	}
	return result, nil
}

// VodDelete Delete VOD location
// Delete a single VOD location by its prefix
func (c *Client) VodDelete(ctx context.Context, prefix string) error {
	path := fmt.Sprintf("/streamer/api/v3/vods/%s", prefix)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// VodGet Get VOD location
// This method allows to get a single VOD location.
func (c *Client) VodGet(ctx context.Context, prefix string) (model.VodConfig, error) {
	path := fmt.Sprintf("/streamer/api/v3/vods/%s", prefix)
	result := &model.VodConfigImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// VodSave Save VOD location
// Create or update a single VOD location. If you pass only a partial VOD location configuration, only the passed fields will be updated, not the whole configuration.
func (c *Client) VodSave(ctx context.Context, prefix string, body model.VodConfig) (model.VodConfig, error) {
	path := fmt.Sprintf("/streamer/api/v3/vods/%s", prefix)
	result := &model.VodConfigImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// VodsList List VOD locations
// This method allows to get the list of all VOD locations configured in Flussonic. VOD location is a virtual filepath used to place files for VOD (Video on Demand) broadcasting.
func (c *Client) VodsList(ctx context.Context, query *VodsListQuery) (model.VodsList, error) {
	path := "/streamer/api/v3/vods"
	result := &model.VodsListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// VodsListIterator iterates through all VodConfig items using cursor pagination.
func (c *Client) VodsListIterator(ctx context.Context, query *VodsListQuery) iter.Seq2[model.VodConfig, error] {
	return cursors.Iterator(ctx, c.VodsList, query)
}

// VsaasDelete Delete vsaas
// Delete Watcher configuration.
func (c *Client) VsaasDelete(ctx context.Context) error {
	path := "/streamer/api/v3/vsaas"
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// VsaasGet Get vsaas
// Get Watcher configuration.
func (c *Client) VsaasGet(ctx context.Context) (model.VsaasConfig, error) {
	path := "/streamer/api/v3/vsaas"
	result := &model.VsaasConfigImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// VsaasSave Save vsaas
// Update Watcher configuration.
func (c *Client) VsaasSave(ctx context.Context, body model.VsaasConfig) (model.VsaasConfig, error) {
	path := "/streamer/api/v3/vsaas"
	result := &model.VsaasConfigImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}
