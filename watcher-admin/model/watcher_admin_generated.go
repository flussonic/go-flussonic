// Code generated by cmd/main. DO NOT EDIT.
package model

// agent_id
type AgentID string

// agent://ID identification for `via` configuration option
type AgentURL string

// auth_backend_name
type AuthBackendName string

// auth_token
type AuthToken string

// Balancing mode
type BalancerConfigMode string

const (
	// Bandwidth usage
	BalancerConfigModeUsage BalancerConfigMode = "usage"
	// Total clients number
	BalancerConfigModeClients BalancerConfigMode = "clients"
	// Total output bitrate
	BalancerConfigModeBitrate BalancerConfigMode = "bitrate"
	// Streams number
	BalancerConfigModeStreams BalancerConfigMode = "streams"
)

// byte
type Byte string

// bytes
type Bytes int

// cache_name
type CacheName string

// Role of node
type CentralNodeRoleRole string

const (
	// The "streamer" role is used for nodes where Flussonic Media Server is deployed.
	CentralNodeRoleRoleStreamer CentralNodeRoleRole = "streamer"
	// The "inference" role is used for nodes where Flussonic Vision Inference is deployed. On "inference" nodes, Central provisions streams with the "vision" parameter set.
	CentralNodeRoleRoleInference CentralNodeRoleRole = "inference"
	// The "identification" role is used for nodes where Flussonic Vision Identification is deployed. Central fetches enriched episodes with persons from Flussonic Identification Service.
	CentralNodeRoleRoleIdentification CentralNodeRoleRole = "identification"
)

// Layout role of streamer.
type CentralStreamerLayoutPredictionItemRole string

const (
	// Streamer is used as ingest.
	//
	CentralStreamerLayoutPredictionItemRoleIngest CentralStreamerLayoutPredictionItemRole = "ingest"
	// Streamer is used as inference.
	//
	CentralStreamerLayoutPredictionItemRoleInference CentralStreamerLayoutPredictionItemRole = "inference"
	// Streamer is used as dvr backup.
	//
	CentralStreamerLayoutPredictionItemRoleDvrBackup CentralStreamerLayoutPredictionItemRole = "dvr_backup"
)

// cidr
type Cidr string

// client_count
type ClientCount int

// External config status
type ConfigExternalErrorStatusStatus string

const (
	// External config is successfully loaded, parsed and applied.
	ConfigExternalErrorStatusStatusLoaded ConfigExternalErrorStatusStatus = "loaded"
	// Valid external config could not be obtained because of error
	ConfigExternalErrorStatusStatusError ConfigExternalErrorStatusStatus = "error"
)

// Conditions of the error occurrence.
type ConfigExternalErrorStatusWhile string

const (
	// Configuration server returned an error while performing a background batch refresh.
	ConfigExternalErrorStatusWhileRefresh ConfigExternalErrorStatusWhile = "refresh"
	// Configuration server returned an error while requesting a stream configuration for the first time.
	ConfigExternalErrorStatusWhileRequest ConfigExternalErrorStatusWhile = "request"
	// Configuration server returned an error while resolving srt port.
	ConfigExternalErrorStatusWhileSrtPortResolve ConfigExternalErrorStatusWhile = "srt_port_resolve"
)

// date_time
type DateTime string

// The Decklink card profile that allows choosing between input and output direction.
type DecklinkConfigProfile string

const (
	// The `bmdProfileOneSubDeviceFullDuplex` mode.
	DecklinkConfigProfileOneFull DecklinkConfigProfile = "one_full"
	// The `bmdProfileOneSubDeviceHalfDuplex` mode.
	DecklinkConfigProfileOneHalf DecklinkConfigProfile = "one_half"
	// The `bmdProfileTwoSubDevicesFullDuplex` mode.
	DecklinkConfigProfileTwoFull DecklinkConfigProfile = "two_full"
	// The `bmdProfileTwoSubDevicesHalfDuplex` mode.
	DecklinkConfigProfileTwoHalf DecklinkConfigProfile = "two_half"
	// The `bmdProfileFourSubDevicesHalfDuplex` mode.
	DecklinkConfigProfileFourHalf DecklinkConfigProfile = "four_half"
)

// disk_device
type DiskDevice string

// disk_path
type DiskPath string

// drm_resource_id
type DrmResourceID string

// dvb_card_name
type DvbCardName string

// dvr_name
type DvrName string

// dvr_url
type DvrURL string

// email
type Email string

// event_sink_name
type EventSinkName string

// Protocol for connecting to camera.
type FirmwareUpdateProto string

const (
	// Iris protocol
	FirmwareUpdateProtoIris FirmwareUpdateProto = "iris"
	// ISAPI/PSIA protocol
	FirmwareUpdateProtoIsapi FirmwareUpdateProto = "isapi"
	// Xm protocol
	FirmwareUpdateProtoXm FirmwareUpdateProto = "xm"
	// MSTAR/Sputnik protocol
	FirmwareUpdateProtoSputnik FirmwareUpdateProto = "sputnik"
)

// hexbinary
type Hexbinary string

// ip
type IP string

type ISO6391 string

// input_url
type InputURL string

// interface_name
type InterfaceName string

// ipv4
type Ipv4 string

// iso3166
type Iso3166 string

// connecting to the server using TLS/STARTTLS
type MailSmtpSecurity string

const (
	// Do not use
	MailSmtpSecurityNone MailSmtpSecurity = "none"
	// Usually works on port 465, sometimes the connection is called SSL (SMTP name)
	MailSmtpSecurityTls MailSmtpSecurity = "tls"
	// Usually works on port 587, sometimes the connection is called TLS (SMTP name)
	MailSmtpSecurityStarttls MailSmtpSecurity = "starttls"
)

// max_bitrate
type MaxBitrate int

// Whether it is a file with a finite start and end time or a live stream.
type MediaInfoSpecificFlowType string

const (
	MediaInfoSpecificFlowTypeFile      MediaInfoSpecificFlowType = "file"
	MediaInfoSpecificFlowTypeStream    MediaInfoSpecificFlowType = "stream"
	MediaInfoSpecificFlowTypeDvrFile   MediaInfoSpecificFlowType = "dvr_file"
	MediaInfoSpecificFlowTypeDvrStream MediaInfoSpecificFlowType = "dvr_stream"
)

// media_name
type MediaName string

// megabytes
type Megabytes int

// microseconds
type Microseconds int

// milliseconds
type Milliseconds float64

// network_port
type NetworkPort int

type OnOffAutoMode string

const (
	// The system is turned on
	OnOffAutoModeOn OnOffAutoMode = "on"
	// The system is turned off
	OnOffAutoModeOff OnOffAutoMode = "off"
	// The system automatically adjusts based on conditions
	OnOffAutoModeAuto OnOffAutoMode = "auto"
)

type OnOffMode string

const (
	// The system is turned on
	OnOffModeOn OnOffMode = "on"
	// The system is turned off
	OnOffModeOff OnOffMode = "off"
)

// password
type Password string

// percent
type Percent int

// phone-number
type PhoneNumber string

// pixels
type Pixels int

// query_session_key
type QuerySessionKey string

// seconds
type Seconds int

// Installation position of the camera
type SensorImageOrientation string

const (
	// Default camera mount.
	SensorImageOrientationNormal SensorImageOrientation = "normal"
	// Camera is mounted on the ceiling.
	SensorImageOrientationUpsideDown SensorImageOrientation = "upside_down"
)

// server_name
type ServerName string

// server_version
type ServerVersion string

// sort_index
type SortIndex int

// speed
type Speed int

// This configuration is deprecated. Use `dvbocr` configuration field in stream.
//
// This parameter allows to manage subtitles in an output stream.
type StreamInputMpegtsSpecificSubtitles string

const (
	// An output stream will have no subtitles track.
	StreamInputMpegtsSpecificSubtitlesDrop StreamInputMpegtsSpecificSubtitles = "drop"
	// An output stream will have a subtitles track in DVB, without conversion to text (default behavior).
	StreamInputMpegtsSpecificSubtitlesAccept StreamInputMpegtsSpecificSubtitles = "accept"
	// An output stream will have a track containing subtitles converted to a text format (WebVTT).
	StreamInputMpegtsSpecificSubtitlesOcrReplace StreamInputMpegtsSpecificSubtitles = "ocr_replace"
	// An output stream will have two tracks containing subtitles:
	// the original track with subtitles in DVB and a new track with text subtitles.
	//
	StreamInputMpegtsSpecificSubtitlesOcrAdd StreamInputMpegtsSpecificSubtitles = "ocr_add"
)

// This configuration is deprecated. Use `dvbocr` configuration field in stream.
//
// This parameter allows to manage subtitles in an output stream.
type StreamInputSrtPublishSpecificSubtitles string

const (
	// An output stream will have no subtitles track.
	StreamInputSrtPublishSpecificSubtitlesDrop StreamInputSrtPublishSpecificSubtitles = "drop"
	// An output stream will have a subtitles track in DVB, without conversion to text (default behavior).
	StreamInputSrtPublishSpecificSubtitlesAccept StreamInputSrtPublishSpecificSubtitles = "accept"
	// An output stream will have a track containing subtitles converted to a text format (WebVTT).
	StreamInputSrtPublishSpecificSubtitlesOcrReplace StreamInputSrtPublishSpecificSubtitles = "ocr_replace"
	// An output stream will have two tracks containing subtitles:
	// the original track with subtitles in DVB and a new track with text subtitles.
	//
	StreamInputSrtPublishSpecificSubtitlesOcrAdd StreamInputSrtPublishSpecificSubtitles = "ocr_add"
)

// ticks
type Ticks float64

// url
type URL string

// uuid
type UUID string

// Contains only alphanumeric characters (a-z, A-Z, 0-9), underscores (_), hyphens (-) and periods (.).
type UnixName string

// The parameter regulates the rights for the user
type UserAdminAccessLevel string

const (
	// Defines standard rights for the user (access is allowed only in the client ui and
	// view of those cameras to which access is granted explicitly)
	//
	UserAdminAccessLevelGeneric UserAdminAccessLevel = "generic"
	// Grants full rights (allows you to create organizations,
	// use both admin ui and client ui, change domain settings)
	//
	UserAdminAccessLevelAdmin UserAdminAccessLevel = "admin"
)

// Unix timestamp in seconds
type Utc int

// Unix timestamp in milliseconds
type UtcMs int

// The algorithm used for video analytics.
type VisionSpecAlg string

const (
	// The algorithm for face recognition is used.
	VisionSpecAlgFaces VisionSpecAlg = "faces"
	// The algorithm for license plate recognition is used.
	VisionSpecAlgPlates VisionSpecAlg = "plates"
)

// The algorithm used for video analytics.
type VisionSpecPresetsAlg string

const (
	// The algorithm for face recognition is used.
	VisionSpecPresetsAlgFaces VisionSpecPresetsAlg = "faces"
	// The algorithm for license plate recognition is used.
	VisionSpecPresetsAlgPlates VisionSpecPresetsAlg = "plates"
)

type AuthURL string

// Name of decision reason for node incompatibility with the stream
type CentralNodeLayoutDecisionReason string

const (
	// Stream doesn't have labels that match all the node's required labels.
	CentralNodeLayoutDecisionReasonStreamMissesNodeRequiredLabels CentralNodeLayoutDecisionReason = "stream_misses_node_required_labels"
	// Node doesn't have labels that match all the stream's required labels.
	CentralNodeLayoutDecisionReasonNodeMissesStreamRequiredLabels CentralNodeLayoutDecisionReason = "node_misses_stream_required_labels"
	// Channel limit of previous node was exceeded
	CentralNodeLayoutDecisionReasonNodeChannelLimitExceeded CentralNodeLayoutDecisionReason = "node_channel_limit_exceeded"
	// Estimated disk space load exceeds the threshold for the streamer's DVR.
	CentralNodeLayoutDecisionReasonStreamerDvrSizeExceeded CentralNodeLayoutDecisionReason = "streamer_dvr_size_exceeded"
	// Node is not available for transcoding.
	CentralNodeLayoutDecisionReasonNodeNotAvailableForTranscoding CentralNodeLayoutDecisionReason = "node_not_available_for_transcoding"
	// Node is offline.
	CentralNodeLayoutDecisionReasonNodeOffline CentralNodeLayoutDecisionReason = "node_offline"
	// Bandwidth load exceeds the threshold for the streamer defined by
	// [total_bandwidth](https://flussonic.com/doc/api/central/#tag/streamer/operation/streamer_get/response__0%7Ctotal_bandwidth).
	//
	CentralNodeLayoutDecisionReasonStreamerTotalBandwidthExceeded CentralNodeLayoutDecisionReason = "streamer_total_bandwidth_exceeded"
	// The node's namespace does not match the stream's namespace.
	CentralNodeLayoutDecisionReasonNamespaceMismatch CentralNodeLayoutDecisionReason = "namespace_mismatch"
)

// Reason why layout was changed
type CentralStreamLayoutChangeReason string

const (
	// Stream doesn't have labels that match all the node's required labels.
	CentralStreamLayoutChangeReasonStreamMissesNodeRequiredLabels CentralStreamLayoutChangeReason = "stream_misses_node_required_labels"
	// Node doesn't have labels that match all the stream's required labels.
	CentralStreamLayoutChangeReasonNodeMissesStreamRequiredLabels CentralStreamLayoutChangeReason = "node_misses_stream_required_labels"
	// Previous node become offline
	CentralStreamLayoutChangeReasonNodeBecomeOffline CentralStreamLayoutChangeReason = "node_become_offline"
	// Stream has been disabled
	CentralStreamLayoutChangeReasonStreamDisabled CentralStreamLayoutChangeReason = "stream_disabled"
	// Node has been deleted
	CentralStreamLayoutChangeReasonNodeDeleted CentralStreamLayoutChangeReason = "node_deleted"
	// Channel limit of previous node was exceeded
	CentralStreamLayoutChangeReasonNodeChannelLimitExceeded CentralStreamLayoutChangeReason = "node_channel_limit_exceeded"
	// Other stream has same agent_id in its inputs, but different ingest.
	//
	CentralStreamLayoutChangeReasonMultistreamAgentIngestConflict CentralStreamLayoutChangeReason = "multistream_agent_ingest_conflict"
	// Estimated disk space load exceeds the threshold for the streamer's DVR.
	//
	CentralStreamLayoutChangeReasonStreamerDvrSizeExceeded CentralStreamLayoutChangeReason = "streamer_dvr_size_exceeded"
	// Bandwidth load exceeds the threshold for the streamer defined by [total_bandwidth](https://flussonic.com/doc/api/central/#tag/streamer/operation/streamer_get/response__0%7Ctotal_bandwidth).
	//
	CentralStreamLayoutChangeReasonStreamerTotalBandwidthExceeded CentralStreamLayoutChangeReason = "streamer_total_bandwidth_exceeded"
	// There is an available node with better match for stream labels than the one currently in use.
	//
	CentralStreamLayoutChangeReasonPreferredLabelsBetterMatch CentralStreamLayoutChangeReason = "preferred_labels_better_match"
	// Stream has not been distributed to node yet.
	CentralStreamLayoutChangeReasonNotDistributed CentralStreamLayoutChangeReason = "not_distributed"
	// DVR backups have been adjusted to match [dvr.redundancy_factor](https://flussonic.com/doc/api/central/#tag/stream/operation/stream_get/response%7Cdvr%7Credundancy_factor).
	//
	CentralStreamLayoutChangeReasonDvrRedundancyAdjust CentralStreamLayoutChangeReason = "dvr_redundancy_adjust"
	// Node has high cpu and can not operate normally.
	CentralStreamLayoutChangeReasonNodeCpuPressure CentralStreamLayoutChangeReason = "node_cpu_pressure"
	// Layout was changed by API call and the change_reason field was empty.
	// If the change_reason is not empty this value is not used.
	//
	CentralStreamLayoutChangeReasonRelayoutByAPI CentralStreamLayoutChangeReason = "relayout_by_api"
	// The node's namespace does not match the stream's namespace.
	CentralStreamLayoutChangeReasonNamespaceMismatch CentralStreamLayoutChangeReason = "namespace_mismatch"
)

// Service or admin user who changed the layout of the stream using an API call.
type CentralStreamLayoutOriginator string

const (
	// Layout was changed via layouter.
	CentralStreamLayoutOriginatorLayouter CentralStreamLayoutOriginator = "layouter"
	// Layout was changed via something other.
	CentralStreamLayoutOriginatorOther CentralStreamLayoutOriginator = "other"
)

type ChassisProduct string

const (
	// Basic coder with transcoding support
	ChassisProductCoderTranscoder ChassisProduct = "coder_transcoder"
	// Coder with video analytic support
	ChassisProductCoderVision ChassisProduct = "coder_vision"
	// Basic coder with transcoding support and DVB output
	ChassisProductCoderDvb ChassisProduct = "coder_dvb"
)

// Collective status of certain object's metric.
type ClusterHealthStatus string

const (
	// Indicates that the entity is fully functional and performing optimally.
	ClusterHealthStatusOperational ClusterHealthStatus = "operational"
	// Indicates that the entity is partly functional but performing optimally.
	ClusterHealthStatusDegradated ClusterHealthStatus = "degradated"
	// Indicates that the entity is mostly non-functional, reduced performance.
	ClusterHealthStatusPartialOutage ClusterHealthStatus = "partial_outage"
	// Indicates that the entity is non-functional.
	ClusterHealthStatusOutage ClusterHealthStatus = "outage"
	// Indicates that the entity is disabled
	ClusterHealthStatusDisabled ClusterHealthStatus = "disabled"
)

type ConfigPathSegment interface{}

type DecklinkCardID any

type DrmSystem string

type DvbFec string

type DvrRaidLevel int

const (
	// RAID level 0
	DvrRaidLevel0 DvrRaidLevel = 0
)

type FrameAppCodec string

const (
	FrameAppCodecMpegts FrameAppCodec = "mpegts"
	FrameAppCodecObject FrameAppCodec = "object"
	FrameAppCodecEit    FrameAppCodec = "eit"
	FrameAppCodecScte27 FrameAppCodec = "scte27"
	FrameAppCodecScte35 FrameAppCodec = "scte35"
	FrameAppCodecKlv    FrameAppCodec = "klv"
	FrameAppCodecEmpty  FrameAppCodec = "empty"
)

type FrameAudioCodec string

const (
	FrameAudioCodecAac FrameAudioCodec = "aac"
)

type FrameCodec string

type FrameContent string

const (
	FrameContentAudio       FrameContent = "audio"
	FrameContentVideo       FrameContent = "video"
	FrameContentText        FrameContent = "text"
	FrameContentMetadata    FrameContent = "metadata"
	FrameContentApplication FrameContent = "application"
)

type FrameRawCodec string

const (
	FrameRawCodecYuv       FrameRawCodec = "yuv"
	FrameRawCodecUyvy422   FrameRawCodec = "uyvy422"
	FrameRawCodecYuyv422   FrameRawCodec = "yuyv422"
	FrameRawCodecYuv422p10 FrameRawCodec = "yuv422p10"
	FrameRawCodecArgb      FrameRawCodec = "argb"
	FrameRawCodecRgb48     FrameRawCodec = "rgb48"
	FrameRawCodecV210      FrameRawCodec = "v210"
	FrameRawCodecPcm       FrameRawCodec = "pcm"
	FrameRawCodecR210      FrameRawCodec = "r210"
)

type FrameTextCodec string

const (
	FrameTextCodecTtxt     FrameTextCodec = "ttxt"
	FrameTextCodecText     FrameTextCodec = "text"
	FrameTextCodecWvtt     FrameTextCodec = "wvtt"
	FrameTextCodecTtml     FrameTextCodec = "ttml"
	FrameTextCodecSubtitle FrameTextCodec = "subtitle"
	FrameTextCodecId3t     FrameTextCodec = "id3t"
	FrameTextCodecOnvif    FrameTextCodec = "onvif"
	FrameTextCodecTx3g     FrameTextCodec = "tx3g"
)

type FrameVideoCodec string

const (
	FrameVideoCodecH264   FrameVideoCodec = "h264"
	FrameVideoCodecHevc   FrameVideoCodec = "hevc"
	FrameVideoCodecMp2v   FrameVideoCodec = "mp2v"
	FrameVideoCodecVp9    FrameVideoCodec = "vp9"
	FrameVideoCodecMjpeg  FrameVideoCodec = "mjpeg"
	FrameVideoCodecScreen FrameVideoCodec = "screen"
	FrameVideoCodecJpeg   FrameVideoCodec = "jpeg"
	FrameVideoCodecAv1    FrameVideoCodec = "av1"
	FrameVideoCodecJ2k    FrameVideoCodec = "j2k"
)

type FrameVideoPixFmt string

const (
	FrameVideoPixFmtYuv420p   FrameVideoPixFmt = "yuv420p"
	FrameVideoPixFmtYuvj420p  FrameVideoPixFmt = "yuvj420p"
	FrameVideoPixFmtYuv422p   FrameVideoPixFmt = "yuv422p"
	FrameVideoPixFmtYuv444p   FrameVideoPixFmt = "yuv444p"
	FrameVideoPixFmtYuv420p10 FrameVideoPixFmt = "yuv420p10"
	FrameVideoPixFmtYuv422p10 FrameVideoPixFmt = "yuv422p10"
	FrameVideoPixFmtYuv444p10 FrameVideoPixFmt = "yuv444p10"
	FrameVideoPixFmtYuv420p12 FrameVideoPixFmt = "yuv420p12"
	FrameVideoPixFmtYuv422p12 FrameVideoPixFmt = "yuv422p12"
	FrameVideoPixFmtYuv444p12 FrameVideoPixFmt = "yuv444p12"
	FrameVideoPixFmtGray8     FrameVideoPixFmt = "gray8"
	FrameVideoPixFmtGray10    FrameVideoPixFmt = "gray10"
	FrameVideoPixFmtGray12    FrameVideoPixFmt = "gray12"
	FrameVideoPixFmtNv12      FrameVideoPixFmt = "nv12"
	FrameVideoPixFmtP016      FrameVideoPixFmt = "p016"
	FrameVideoPixFmtV210      FrameVideoPixFmt = "v210"
	FrameVideoPixFmtUyvy422   FrameVideoPixFmt = "uyvy422"
	FrameVideoPixFmtYuyv422   FrameVideoPixFmt = "yuyv422"
	FrameVideoPixFmtRgb48     FrameVideoPixFmt = "rgb48"
	FrameVideoPixFmtArgb      FrameVideoPixFmt = "argb"
	FrameVideoPixFmtX2rgb10be FrameVideoPixFmt = "x2rgb10be"
)

type GenlockStatus string

const (
	GenlockStatusNoRef        GenlockStatus = "no_ref"
	GenlockStatusLocking      GenlockStatus = "locking"
	GenlockStatusLocked       GenlockStatus = "locked"
	GenlockStatusInvalid      GenlockStatus = "invalid"
	GenlockStatusNotSupported GenlockStatus = "not_supported"
	GenlockStatusUnknown      GenlockStatus = "unknown"
)

type LicenseType string

type ListenSpec interface{}

// The level of logging according to event importance. Several values separated by comma.
type Loglevel string

const (
	// Messages of all types are logged.
	LoglevelDebug Loglevel = "debug"
	// Log info messages.
	LoglevelInfo Loglevel = "info"
	// Log warnings.
	LoglevelWarning Loglevel = "warning"
	// Log errors.
	LoglevelError Loglevel = "error"
	// Log critical messages.
	LoglevelCritical Loglevel = "critical"
)

type MediaQuality string

const (
	MediaQualityLow    MediaQuality = "low"
	MediaQualityMedium MediaQuality = "medium"
	MediaQualityHigh   MediaQuality = "high"
)

type OutputAudio string

const (
	// Keep the original audio codec.
	OutputAudioKeep OutputAudio = "keep"
	// Keep AAC if available or transcode to AAC; delete other tracks if any.
	OutputAudioAac OutputAudio = "aac"
	// Add AAC if it was not available already while keeping the original track.
	OutputAudioAddAac OutputAudio = "add_aac"
	// Make silence in audio track by using AAC codec. Replace original non-AAC track to AAC.
	OutputAudioAacSilence OutputAudio = "aac_silence"
	// Make silence in audio track by using original audio codec.
	OutputAudioKeepSilence OutputAudio = "keep_silence"
)

type Protocol string

const (
	ProtocolCopy         Protocol = "copy"
	ProtocolFake         Protocol = "fake"
	ProtocolRTP          Protocol = "rtp"
	ProtocolRtmp         Protocol = "rtmp"
	ProtocolRtmps        Protocol = "rtmps"
	ProtocolRtmpe        Protocol = "rtmpe"
	ProtocolRtsp         Protocol = "rtsp"
	ProtocolRtspUDP      Protocol = "rtsp-udp"
	ProtocolRtsp2        Protocol = "rtsp2"
	ProtocolRtsps        Protocol = "rtsps"
	ProtocolEst          Protocol = "est"
	ProtocolSrt          Protocol = "srt"
	ProtocolMseld        Protocol = "mseld"
	ProtocolShoutcast    Protocol = "shoutcast"
	ProtocolShoutcasts   Protocol = "shoutcasts"
	ProtocolWebrtc       Protocol = "webrtc"
	ProtocolHls          Protocol = "hls"
	ProtocolHlss         Protocol = "hlss"
	ProtocolHls2         Protocol = "hls2"
	ProtocolHlss2        Protocol = "hlss2"
	ProtocolLlhls        Protocol = "llhls"
	ProtocolCmaf         Protocol = "cmaf"
	ProtocolDash         Protocol = "dash"
	ProtocolMss          Protocol = "mss"
	ProtocolM4s          Protocol = "m4s"
	ProtocolM4ss         Protocol = "m4ss"
	ProtocolM4f          Protocol = "m4f"
	ProtocolM4fs         Protocol = "m4fs"
	ProtocolTshttp       Protocol = "tshttp"
	ProtocolTshttps      Protocol = "tshttps"
	ProtocolTstcp        Protocol = "tstcp"
	ProtocolTsssl        Protocol = "tsssl"
	ProtocolFlv          Protocol = "flv"
	ProtocolAnnexb       Protocol = "annexb"
	ProtocolUDP          Protocol = "udp"
	ProtocolUdp1         Protocol = "udp1"
	ProtocolUdp2         Protocol = "udp2"
	ProtocolUdp3         Protocol = "udp3"
	ProtocolMptsUDP      Protocol = "mpts-udp"
	ProtocolMptsHTTP     Protocol = "mpts-http"
	ProtocolMptsHTTPS    Protocol = "mpts-https"
	ProtocolMptsDvb      Protocol = "mpts-dvb"
	ProtocolDvb          Protocol = "dvb"
	ProtocolDecklink     Protocol = "decklink"
	ProtocolDektec       Protocol = "dektec"
	ProtocolDektecAsi    Protocol = "dektec-asi"
	ProtocolV4l          Protocol = "v4l"
	ProtocolV4l2         Protocol = "v4l2"
	ProtocolPlaylist     Protocol = "playlist"
	ProtocolMixer        Protocol = "mixer"
	ProtocolMosaic       Protocol = "mosaic"
	ProtocolMosaic2      Protocol = "mosaic2"
	ProtocolTimeshift    Protocol = "timeshift"
	ProtocolFile         Protocol = "file"
	ProtocolDownload     Protocol = "download"
	ProtocolMbr          Protocol = "mbr"
	ProtocolMp4          Protocol = "mp4"
	ProtocolLogo         Protocol = "logo"
	ProtocolJpeg         Protocol = "jpeg"
	ProtocolMjpeg        Protocol = "mjpeg"
	ProtocolH323         Protocol = "h323"
	ProtocolAdInjector   Protocol = "ad_injector"
	ProtocolFfmpeg       Protocol = "ffmpeg"
	ProtocolTransponder  Protocol = "transponder"
	ProtocolAPI          Protocol = "api"
	ProtocolJSONManifest Protocol = "json_manifest"
	ProtocolPlayer       Protocol = "player"
	ProtocolNdi          Protocol = "ndi"
	ProtocolFrip         Protocol = "frip"
	ProtocolSt2110       Protocol = "st2110"
	ProtocolBackup       Protocol = "backup"
	ProtocolMxl          Protocol = "mxl"
)

type PusherStandbyStatus string

const (
	PusherStandbyStatusActive  PusherStandbyStatus = "active"
	PusherStandbyStatusWaiting PusherStandbyStatus = "waiting"
)

type PusherStatus interface{}

type RaidDiskMode string

const (
	// Flussonic reads the data from and writes it to the hard drive, removing the data according to the DVR settings.
	// The default mode.
	//
	RaidDiskModeNormal RaidDiskMode = "normal"
	// Flussonic migrates the data from the current hard drive to other hard drives in the array on the fly, cleaning up the current hard drive.
	// You can check that Flussonic finished migrating the data, when there aren't any calls to this hard drive.
	// In the meantime, Flussonic continues archive recording, so it isn't interrupted. You don't need to restart Flussonic after you remove the disk.
	// Use this option if you need to extract the hard drive and don't want to lose the data.
	//
	RaidDiskModeMigrate RaidDiskMode = "migrate"
	// Flussonic reads the data from the hard drive, restricting any writing to it. Use this option in the following cases:
	// Flussonic reads the data from the hard drive until the data on it expires. Then Flussonic deletes the data.
	// * If the hard drive is worn out and you can't write the data to the hard drive, delete files, update the index, or copy the data to another hard drive.
	// * If the hard drive stores the records written in the `keep` mode and you want to store the data permanently.
	//
	RaidDiskModeReadonly RaidDiskMode = "readonly"
	// Flussonic copies all the data from the old hard drive that's going to fail and stops writing the data to this hard drive.
	// Flussonic doesn't delete the data from the hard drive, unlike in `migrate` mode, so you can still access the archive.
	// Use this option in an emergency.
	//
	RaidDiskModeRescue RaidDiskMode = "rescue"
	// Flussonic stops writing new data on this hard drive. When the data becomes obsolete, Flussonic deletes it, updating the index.
	// Use this option when you want to replace a hard drive, for example, with a larger one.
	//
	RaidDiskModeAbandon RaidDiskMode = "abandon"
	// Flussonic writes the data to the hard drive, but doesn't delete it.
	// Use this option if you need to store the entire archive permanently.
	//
	RaidDiskModeKeep RaidDiskMode = "keep"
)

// Reason of the error.
type RequestErrorReason string

const (
	// New configuration does not match reference.
	RequestErrorReasonValidationError RequestErrorReason = "validation_error"
	// Streamer could not get reply from the configuration server.
	RequestErrorReasonNetworkError RequestErrorReason = "network_error"
	// Configuration server returned an malformed json body.
	RequestErrorReasonMalformedJSON RequestErrorReason = "malformed_json"
	// Configuration server received an invalid request, e.g. required headers is missing or invalid authorization.
	RequestErrorReasonInvalidRequest RequestErrorReason = "invalid_request"
	// Configuration server returned an error for an unknown reason.
	RequestErrorReasonUnknown RequestErrorReason = "unknown"
)

type ServerStatsStreamerStatus string

const (
	// The configuration file is not found at `/etc/flussonic/flussonic.conf`.
	ServerStatsStreamerStatusNoConfig ServerStatsStreamerStatus = "no_config"
	// There are some errors in the config file saved at `/etc/flussonic/flussonic.conf`.
	// Try checking logs and `text_alerts` for details.
	//
	ServerStatsStreamerStatusBrokenConfig ServerStatsStreamerStatus = "broken_config"
	// There are some errors during external config receiving or validating.
	// Try checking logs and `config_external_error` for details.
	//
	ServerStatsStreamerStatusConfigExternalError ServerStatsStreamerStatus = "config_external_error"
	// The license cannot be activated. Please contact the support team.
	ServerStatsStreamerStatusLicenseFailure ServerStatsStreamerStatus = "license_failure"
	// The license file is not found at `/etc/flussonic/license.txt`.
	ServerStatsStreamerStatusNoLicense ServerStatsStreamerStatus = "no_license"
	// The server is starting.
	ServerStatsStreamerStatusStarting ServerStatsStreamerStatus = "starting"
	// Normal operation mode.
	ServerStatsStreamerStatusRunning ServerStatsStreamerStatus = "running"
)

type SessionKey interface{}

type SessionStatus string

const (
	SessionStatusEstablishing SessionStatus = "establishing"
	SessionStatusRunning      SessionStatus = "running"
	SessionStatusStalling     SessionStatus = "stalling"
	SessionStatusFinished     SessionStatus = "finished"
)

type StreamInput any

type StreamPush any

type StreamStatus string

const (
	// Input is OK, stream is ready to be served to your audience.
	StreamStatusRunning StreamStatus = "running"
	// Flussonic awaits for input (publish) or it's an 'on demand' stream waiting for client.
	StreamStatusWaiting StreamStatus = "waiting"
	// Something is wrong and Flussonic is not able to serve the stream to your audience.
	StreamStatusError StreamStatus = "error"
)

type TcDeviceid interface{}

type TcReconfigSupport interface{}

type ThumbnailsEnabledSpec any

type TranscoderDevice string

const (
	TranscoderDeviceCpu   TranscoderDevice = "cpu"
	TranscoderDeviceQsv   TranscoderDevice = "qsv"
	TranscoderDeviceNvenc TranscoderDevice = "nvenc"
	TranscoderDeviceCoder TranscoderDevice = "coder"
)

type TSServiceType interface{}

type URLPrefix interface{}

type VideoFormat string

const (
	// pal 720x576 @ 50Hz interlace SMPTE-259
	VideoFormatPal VideoFormat = "pal"
	// Similar PAL
	VideoFormat625I50 VideoFormat = "625i50"
	// NTSC 720x480 @ 59.94Hz interlace SMPTE-259
	VideoFormatNtsc VideoFormat = "ntsc"
	// Similar NTSC
	VideoFormat525I2997 VideoFormat = "525i29.97"
	// Similar NTSC
	VideoFormat525I29 VideoFormat = "525i29"
	// 1280x720 @ 23.98Hz progressive SMPTE-296
	VideoFormat720P2398 VideoFormat = "720p23.98"
	// Similar 720p23.98
	VideoFormat720P23   VideoFormat = "720p23"
	VideoFormat720P24   VideoFormat = "720p24"
	VideoFormat720P25   VideoFormat = "720p25"
	VideoFormat720P2997 VideoFormat = "720p29.97"
	VideoFormat720P29   VideoFormat = "720p29"
	VideoFormat720P30   VideoFormat = "720p30"
	VideoFormat720P50   VideoFormat = "720p50"
	VideoFormat720P5994 VideoFormat = "720p59.94"
	VideoFormat720P59   VideoFormat = "720p59"
	VideoFormat720P60   VideoFormat = "720p60"
	// 1920x1080 @ 23.98Hz progressive SMPTE-274
	VideoFormat1080P2398 VideoFormat = "1080p23.98"
	VideoFormat1080P23   VideoFormat = "1080p23"
	VideoFormat1080P24   VideoFormat = "1080p24"
	VideoFormat1080P25   VideoFormat = "1080p25"
	VideoFormat1080P2997 VideoFormat = "1080p29.97"
	VideoFormat1080P29   VideoFormat = "1080p29"
	VideoFormat1080P30   VideoFormat = "1080p30"
	// 1920x1080 @ 23.98Hz progressive Progressive segmented Frame SMPTE-274
	VideoFormat1080Psf2398 VideoFormat = "1080psf23.98"
	VideoFormat1080Psf23   VideoFormat = "1080psf23"
	VideoFormat1080Psf24   VideoFormat = "1080psf24"
	VideoFormat1080Psf25   VideoFormat = "1080psf25"
	VideoFormat1080Psf2997 VideoFormat = "1080psf29.97"
	VideoFormat1080Psf29   VideoFormat = "1080psf29"
	VideoFormat1080Psf30   VideoFormat = "1080psf30"
	VideoFormat1080I50     VideoFormat = "1080i50"
	VideoFormat1080I5994   VideoFormat = "1080i59.94"
	VideoFormat1080I60     VideoFormat = "1080i60"
	// 1920x1080 @ 50Hz progressive annex A or annex B depending hardware SMPTE-274
	VideoFormat1080P50 VideoFormat = "1080p50"
	// 1920x1080 @ 50Hz progressive annex B SMPTE-274
	VideoFormat1080P50b   VideoFormat = "1080p50b"
	VideoFormat1080P5994  VideoFormat = "1080p59.94"
	VideoFormat1080P59    VideoFormat = "1080p59"
	VideoFormat1080P5994B VideoFormat = "1080p59.94b"
	VideoFormat1080P59b   VideoFormat = "1080p59b"
	VideoFormat1080P60    VideoFormat = "1080p60"
	VideoFormat1080P60b   VideoFormat = "1080p60b"
	// 4k 3840x2160 @ 50Hz progressive SMPTE-2036
	VideoFormat2160P50    VideoFormat = "2160p50"
	VideoFormat2160P50b   VideoFormat = "2160p50b"
	VideoFormat2160P5994  VideoFormat = "2160p59.94"
	VideoFormat2160P59    VideoFormat = "2160p59"
	VideoFormat2160P5994B VideoFormat = "2160p59.94b"
	VideoFormat2160P59b   VideoFormat = "2160p59b"
	VideoFormat2160P60    VideoFormat = "2160p60"
	VideoFormat2160P60b   VideoFormat = "2160p60b"
	VideoFormat2160P23    VideoFormat = "2160p23"
	VideoFormat2160P24    VideoFormat = "2160p24"
	VideoFormat2160P25    VideoFormat = "2160p25"
	VideoFormat2160P29    VideoFormat = "2160p29"
	VideoFormat2160P30    VideoFormat = "2160p30"
)

type VisionDetector string

const (
	VisionDetectorFaces    VisionDetector = "faces"
	VisionDetectorVehicles VisionDetector = "vehicles"
	VisionDetectorMotion   VisionDetector = "motion"
	VisionDetectorQrCodes  VisionDetector = "qr-codes"
	VisionDetectorHumans   VisionDetector = "humans"
)

type WebrtcPreferVideoCodec string

type WebrtcTransport string

const (
	WebrtcTransportUDP WebrtcTransport = "udp"
	WebrtcTransportTCP WebrtcTransport = "tcp"
)

type APICall interface {
	// Creation date and time
	// Format: date_time (date_time)
	// Example: 2021-01-30T08:30:00.432567Z
	CreatedAt() *DateTime
	// Creation date and time
	// Format: date_time (date_time)
	// Example: 2021-01-30T08:30:00.432567Z
	SetCreatedAt(DateTime) APICall
	// Microseconds that this request took
	// Format: microseconds (microseconds)
	Duration() *Microseconds
	// Microseconds that this request took
	// Format: microseconds (microseconds)
	SetDuration(Microseconds) APICall
	// IP address of the caller.
	// Format: ip (ip)
	// Example: 192.34.32.10
	IP() *IP
	// IP address of the caller.
	// Format: ip (ip)
	// Example: 192.34.32.10
	SetIP(IP) APICall
	// API method ID.
	// Example: streams_list
	OperationID() *string
	// API method ID.
	// Example: streams_list
	SetOperationID(string) APICall
	// The program produced the API call. Content of `X-Originator` header.
	// Example: flussonic
	Originator() *string
	// The program produced the API call. Content of `X-Originator` header.
	// Example: flussonic
	SetOriginator(string) APICall
	// Payload data transmitter in the API call.
	Payload() *string
	// Payload data transmitter in the API call.
	SetPayload(string) APICall
	// Internal request-id for this operation
	RequestID() *string
	// Internal request-id for this operation
	SetRequestID(string) APICall
	// Request status code.
	Status() *int
	// Request status code.
	SetStatus(int) APICall
	// The type of the device from which the API call was produced.
	// Example: Flussonic 24.04
	UserAgent() *string
	// The type of the device from which the API call was produced.
	// Example: Flussonic 24.04
	SetUserAgent(string) APICall
}

type APICallEvent interface {
	// Creation date and time
	// Format: date_time (date_time)
	// Example: 2021-01-30T08:30:00.432567Z
	CreatedAt() *DateTime
	// Creation date and time
	// Format: date_time (date_time)
	// Example: 2021-01-30T08:30:00.432567Z
	SetCreatedAt(DateTime) APICallEvent
	// Microseconds that this request took
	// Format: microseconds (microseconds)
	Duration() *Microseconds
	// Microseconds that this request took
	// Format: microseconds (microseconds)
	SetDuration(Microseconds) APICallEvent
	// The api call.
	Event() string
	// The api call.
	SetEvent(string) APICallEvent
	// Event identifier.
	EventID() *int
	// Event identifier.
	SetEventID(int) APICallEvent
	// IP address of the caller.
	// Format: ip (ip)
	// Example: 192.34.32.10
	IP() *IP
	// IP address of the caller.
	// Format: ip (ip)
	// Example: 192.34.32.10
	SetIP(IP) APICallEvent
	// API method ID.
	// Example: streams_list
	OperationID() *string
	// API method ID.
	// Example: streams_list
	SetOperationID(string) APICallEvent
	// The program produced the API call. Content of `X-Originator` header.
	// Example: flussonic
	Originator() *string
	// The program produced the API call. Content of `X-Originator` header.
	// Example: flussonic
	SetOriginator(string) APICallEvent
	// The api call path.
	Path() *string
	// The api call path.
	SetPath(string) APICallEvent
	// Payload data transmitter in the API call.
	Payload() *string
	// Payload data transmitter in the API call.
	SetPayload(string) APICallEvent
	// The api call query string.
	Qs() *string
	// The api call query string.
	SetQs(string) APICallEvent
	// Internal request-id for this operation
	RequestID() *string
	// Internal request-id for this operation
	SetRequestID(string) APICallEvent
	// Originator of event.
	// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
	// is configured as HTTP/HTTPS url.
	// Example: flussonic.host
	Server() *string
	// Originator of event.
	// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
	// is configured as HTTP/HTTPS url.
	// Example: flussonic.host
	SetServer(string) APICallEvent
	// Request status code.
	Status() *int
	// Request status code.
	SetStatus(int) APICallEvent
	// Unique identifier of the operation.
	// You can use this field to search for events related to same operation.
	// Value of this field is taken from the `X-Trace-Id` header.
	// If `X-Trace-Id` header is not set, it will be generated automatically.
	// Service will use the value of this field to make outgoing requests.
	// Format: uuid (uuid)
	// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
	TraceID() *UUID
	// Unique identifier of the operation.
	// You can use this field to search for events related to same operation.
	// Value of this field is taken from the `X-Trace-Id` header.
	// If `X-Trace-Id` header is not set, it will be generated automatically.
	// Service will use the value of this field to make outgoing requests.
	// Format: uuid (uuid)
	// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
	SetTraceID(UUID) APICallEvent
	// The type of the device from which the API call was produced.
	// Example: Flussonic 24.04
	UserAgent() *string
	// The type of the device from which the API call was produced.
	// Example: Flussonic 24.04
	SetUserAgent(string) APICallEvent
	// The time of the event registration on the server.
	// Format: utc_ms (Unix timestamp in milliseconds)
	UtcMs() *UtcMs
	// The time of the event registration on the server.
	// Format: utc_ms (Unix timestamp in milliseconds)
	SetUtcMs(UtcMs) APICallEvent
}

// Required: login, password
type AdminCredentials interface {
	// Login
	// Example: secretlogin
	Login() string
	// Login
	// Example: secretlogin
	SetLogin(string) AdminCredentials
	// Password
	// Format: password (password)
	// Example: passw
	Password() Password
	// Password
	// Format: password (password)
	// Example: passw
	SetPassword(Password) AdminCredentials
}

type Agent interface {
	// Agent identifier
	// Example: 1234567
	ID() *string
	// Agent identifier
	// Example: 1234567
	SetID(string) Agent
	// Agent authentication key.
	Key() *string
	// Agent authentication key.
	SetKey(string) Agent
	// The model of the camera with [Agent](https://flussonic.com/doc/agent-with-watcher/).
	Model() *string
	// The model of the camera with [Agent](https://flussonic.com/doc/agent-with-watcher/).
	SetModel(string) Agent
	// The device (camera or router) serial number.
	Serial() *string
	// The device (camera or router) serial number.
	SetSerial(string) Agent
	// Agents's metrics and other statistical information.
	Stats() WatcherAgentStats
	// Agents's metrics and other statistical information.
	SetStats(WatcherAgentStats) Agent
	// List of streams info that have this agent in their inputs
	Streams() []any
	// List of streams info that have this agent in their inputs
	SetStreams([]any) Agent
}

type AgentConfigBase interface {
	// Agent identifier
	// Example: 1234567
	ID() *string
	// Agent identifier
	// Example: 1234567
	SetID(string) AgentConfigBase
	// Agent authentication key.
	Key() *string
	// Agent authentication key.
	SetKey(string) AgentConfigBase
	// The model of the camera with [Agent](https://flussonic.com/doc/agent-with-watcher/).
	Model() *string
	// The model of the camera with [Agent](https://flussonic.com/doc/agent-with-watcher/).
	SetModel(string) AgentConfigBase
	// The device (camera or router) serial number.
	Serial() *string
	// The device (camera or router) serial number.
	SetSerial(string) AgentConfigBase
	// Agents's metrics and other statistical information.
	Stats() WatcherAgentStats
	// Agents's metrics and other statistical information.
	SetStats(WatcherAgentStats) AgentConfigBase
}

type AgentsList interface {
	// The list of Agents fetched according to the query parameters.
	Agents() []Agent
	// The list of Agents fetched according to the query parameters.
	SetAgents([]Agent) AgentsList
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	EstimatedCount() *int
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	SetEstimatedCount(int) AgentsList
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	Next() *string
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	SetNext(string) AgentsList
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	Prev() *string
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	SetPrev(string) AgentsList
	// An object with a list of different timings measured during this API call.
	Timing() any
	// An object with a list of different timings measured during this API call.
	SetTiming(any) AgentsList
	// Collection returns the collection items
	Collection() []Agent
}

// Users apikey for access via API.
type Apikey interface {
	// Apikey for users access via API.
	Apikey() *string
	// Apikey for users access via API.
	SetApikey(string) Apikey
}

type AppearanceConfig interface {
	// The interface colors.
	Colors() AppearanceConfigColors
	// The interface colors.
	SetColors(AppearanceConfigColors) AppearanceConfig
	// The favicon image.
	// Format: byte (byte)
	// Example: data:image/png;base64,<base64string>
	Favicon() *Byte
	// The favicon image.
	// Format: byte (byte)
	// Example: data:image/png;base64,<base64string>
	SetFavicon(Byte) AppearanceConfig
	// The logo image in the sidebar.
	// Format: byte (byte)
	// Example: data:image/png;base64,<base64string>
	Logo() *Byte
	// The logo image in the sidebar.
	// Format: byte (byte)
	// Example: data:image/png;base64,<base64string>
	SetLogo(Byte) AppearanceConfig
	// The logo image on the login page.
	// Format: byte (byte)
	// Example: data:image/jpg;base64,<base64string>
	LogoAuth() *Byte
	// The logo image on the login page.
	// Format: byte (byte)
	// Example: data:image/jpg;base64,<base64string>
	SetLogoAuth(Byte) AppearanceConfig
	// The custom page title.
	// Example: My video site
	Title() *string
	// The custom page title.
	// Example: My video site
	SetTitle(string) AppearanceConfig
}

// The interface colors.
type AppearanceConfigColors interface {
	// The background color.
	// Example: #f3f5f7
	Background() *string
	// The background color.
	// Example: #f3f5f7
	SetBackground(string) AppearanceConfigColors
	// Primary color for interface elements like selection in the main menu, info icons, buttons, etc.
	// Example: #444951
	Primary() *string
	// Primary color for interface elements like selection in the main menu, info icons, buttons, etc.
	// Example: #444951
	SetPrimary(string) AppearanceConfigColors
	// Secondary color for obsolete interface elements like active tab.
	// Example: #2469f2
	Secondary() *string
	// Secondary color for obsolete interface elements like active tab.
	// Example: #2469f2
	SetSecondary(string) AppearanceConfigColors
}

type AuditLogRecord interface {
	// The time when the last changes were made.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	CreatedAt() *UtcMs
	// The time when the last changes were made.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetCreatedAt(UtcMs) AuditLogRecord
	// Who initiated the last changes.
	// Examples: admin
	User() *string
	// Who initiated the last changes.
	// Examples: admin
	SetUser(string) AuditLogRecord
}

// Authentication details configuration
type Auth interface {
	// Username authentication
	Login() *string
	// Username authentication
	SetLogin(string) Auth
	// Password authentication
	Password() *string
	// Password authentication
	SetPassword(string) Auth
	// Service port on which Onvif/PSIA is accessible, default is 80
	Port() *int
	// Service port on which Onvif/PSIA is accessible, default is 80
	SetPort(int) Auth
}

// Required: name
type AuthBackendConfig interface {
	// Explicit list of countries (two-letter country codes according to ISO 3166-1) that have access to the content without any other checks.
	// Flussonic uses the MaxMind GeoLite2 Country database to map a country to a block of IP addresses.
	// New releases of GeoIP2 databases come out more often than the releases of Flussonic server, so sometimes the used database can become outdated.
	// Therefore we recommend you to install a separate GeoIP2 library and set up Flussonic to use it.
	// Example: [RU US]
	AllowCountries() []string
	// Explicit list of countries (two-letter country codes according to ISO 3166-1) that have access to the content without any other checks.
	// Flussonic uses the MaxMind GeoLite2 Country database to map a country to a block of IP addresses.
	// New releases of GeoIP2 databases come out more often than the releases of Flussonic server, so sometimes the used database can become outdated.
	// Therefore we recommend you to install a separate GeoIP2 library and set up Flussonic to use it.
	// Example: [RU US]
	SetAllowCountries([]string) AuthBackendConfig
	// This option defines the default behavior when all backends are not responding (usually, because of errors in HTTP responses) and the session is not started yet.
	// If this option is enabled, all clients or devices except those listed in `deny` option will have access to the content.
	// If this option is disabled, all clients or devices except those listed in `allow` option will not have access to the content.
	AllowDefault() *bool
	// This option defines the default behavior when all backends are not responding (usually, because of errors in HTTP responses) and the session is not started yet.
	// If this option is enabled, all clients or devices except those listed in `deny` option will have access to the content.
	// If this option is disabled, all clients or devices except those listed in `allow` option will not have access to the content.
	SetAllowDefault(bool) AuthBackendConfig
	// Explicit list of IP-addresses or subnet masks that have access to the content without any other checks.
	// Example: [127.0.0.1 10.10.0.0/24]
	AllowIps() []string
	// Explicit list of IP-addresses or subnet masks that have access to the content without any other checks.
	// Example: [127.0.0.1 10.10.0.0/24]
	SetAllowIps([]string) AuthBackendConfig
	// Explicit list of tokens that give access to the content without any other checks.
	// Example: [test_token1 test_token2]
	AllowTokens() []string
	// Explicit list of tokens that give access to the content without any other checks.
	// Example: [test_token1 test_token2]
	SetAllowTokens([]string) AuthBackendConfig
	// Explicit list of user agents (set-top boxes or browsers) that have access to the content without any other checks.
	// Example: [AppleWebKit/533.3 (KHTML, like Gecko) VLC/3.0.8 LibVLC/3.0.8]
	AllowUas() []string
	// Explicit list of user agents (set-top boxes or browsers) that have access to the content without any other checks.
	// Example: [AppleWebKit/533.3 (KHTML, like Gecko) VLC/3.0.8 LibVLC/3.0.8]
	SetAllowUas([]string) AuthBackendConfig
	// URL(s) of the HTTP backend(s).
	Backends() []AuthBackendURL
	// URL(s) of the HTTP backend(s).
	SetBackends([]AuthBackendURL) AuthBackendConfig
	// Explicit list of countries (two-letter country codes according to ISO 3166-1) that are banned from accessing the content.
	// Flussonic uses the MaxMind GeoLite2 Country database to map a country to a block of IP addresses.
	// New releases of GeoIP2 databases come out more often than the releases of Flussonic server, so sometimes the used database can become outdated.
	// Therefore we recommend you to install a separate GeoIP2 library and set up Flussonic to use it.
	// Example: [RU GB]
	DenyCountries() []string
	// Explicit list of countries (two-letter country codes according to ISO 3166-1) that are banned from accessing the content.
	// Flussonic uses the MaxMind GeoLite2 Country database to map a country to a block of IP addresses.
	// New releases of GeoIP2 databases come out more often than the releases of Flussonic server, so sometimes the used database can become outdated.
	// Therefore we recommend you to install a separate GeoIP2 library and set up Flussonic to use it.
	// Example: [RU GB]
	SetDenyCountries([]string) AuthBackendConfig
	// Explicit list of IP-addresses or subnet masks that are banned from accessing the content.
	// Example: [8.8.8.8 10.10.0.0/24]
	DenyIps() []string
	// Explicit list of IP-addresses or subnet masks that are banned from accessing the content.
	// Example: [8.8.8.8 10.10.0.0/24]
	SetDenyIps([]string) AuthBackendConfig
	// Explicit list of tokens that deny access to the content and stop any other checks.
	// Example: [test_token3 test_token4]
	DenyTokens() []string
	// Explicit list of tokens that deny access to the content and stop any other checks.
	// Example: [test_token3 test_token4]
	SetDenyTokens([]string) AuthBackendConfig
	// The list of user agents (set-top boxes or browsers) that are banned from accessing the content.
	// Example: [Mobile Safari/533.3 VLC/3.0.8 LibVLC/3.0.8]
	DenyUas() []string
	// The list of user agents (set-top boxes or browsers) that are banned from accessing the content.
	// Example: [Mobile Safari/533.3 VLC/3.0.8 LibVLC/3.0.8]
	SetDenyUas([]string) AuthBackendConfig
	// Globally unique [`auth_backend`](https://flussonic.com/doc/complex-authorization-with-backends/) name.
	// Format: auth_backend_name (auth_backend_name)
	Name() AuthBackendName
	// Globally unique [`auth_backend`](https://flussonic.com/doc/complex-authorization-with-backends/) name.
	// Format: auth_backend_name (auth_backend_name)
	SetName(AuthBackendName) AuthBackendConfig
}

// Required: url
type AuthBackendURL interface {
	// The URL of an HTTP backend.
	// Example: http://stalker-1.iptv.net/auth.php
	URL() string
	// The URL of an HTTP backend.
	// Example: http://stalker-1.iptv.net/auth.php
	SetURL(string) AuthBackendURL
}

type AuthSpec interface {
	// Explicit list of countries (two-letter country codes according to ISO 3166-1) that have access to the content without any other checks.
	// Flussonic uses the MaxMind GeoLite2 Country database to map a country to a block of IP addresses.
	// New releases of GeoIP2 databases come out more often than the releases of Flussonic server, so sometimes the used database can become outdated.
	// Therefore we recommend you to install a separate GeoIP2 library and set up Flussonic to use it.
	// Example: [US DE GB]
	AllowedCountries() []Iso3166
	// Explicit list of countries (two-letter country codes according to ISO 3166-1) that have access to the content without any other checks.
	// Flussonic uses the MaxMind GeoLite2 Country database to map a country to a block of IP addresses.
	// New releases of GeoIP2 databases come out more often than the releases of Flussonic server, so sometimes the used database can become outdated.
	// Therefore we recommend you to install a separate GeoIP2 library and set up Flussonic to use it.
	// Example: [US DE GB]
	SetAllowedCountries([]Iso3166) AuthSpec
	// Explicit list of countries (two-letter country codes according to ISO 3166-1) that are banned from accessing the content.
	// Flussonic uses the MaxMind GeoLite2 Country database to map a country to a block of IP addresses.
	// New releases of GeoIP2 databases come out more often than the releases of Flussonic server, so sometimes the used database can become outdated.
	// Therefore we recommend you to install a separate GeoIP2 library and set up Flussonic to use it.
	// Example: [US DE GB]
	DisallowedCountries() []Iso3166
	// Explicit list of countries (two-letter country codes according to ISO 3166-1) that are banned from accessing the content.
	// Flussonic uses the MaxMind GeoLite2 Country database to map a country to a block of IP addresses.
	// New releases of GeoIP2 databases come out more often than the releases of Flussonic server, so sometimes the used database can become outdated.
	// Therefore we recommend you to install a separate GeoIP2 library and set up Flussonic to use it.
	// Example: [US DE GB]
	SetDisallowedCountries([]Iso3166) AuthSpec
	// Specifying the domains, within which playing this video is allowed.
	// This does not work for those clients that do not pass the value of Referer HTTP header.
	// Example: [mycompany.com]
	Domains() []string
	// Specifying the domains, within which playing this video is allowed.
	// This does not work for those clients that do not pass the value of Referer HTTP header.
	// Example: [mycompany.com]
	SetDomains([]string) AuthSpec
	// Some additional options.
	Extra() map[string]string
	// Some additional options.
	SetExtra(map[string]string) AuthSpec
	// The maximal number of streams or files the user can view simultaneously.
	// This limitation allows to prevent users from full restreaming to their servers.
	// Example: 5000
	MaxSessions() *int
	// The maximal number of streams or files the user can view simultaneously.
	// This limitation allows to prevent users from full restreaming to their servers.
	// Example: 5000
	SetMaxSessions(int) AuthSpec
	// A list of keys to generate a session ID value, allowing to configure the authorization scheme
	// which is a hash sum calculated as follows: `hash(name + ip + proto)`.
	// This parameter allows to finish one session and start another one with the same authorization token.
	// The keys `name`,`ip`, and `proto` are required.
	// Example: [name token proto ip]
	SessionKeys() []SessionKey
	// A list of keys to generate a session ID value, allowing to configure the authorization scheme
	// which is a hash sum calculated as follows: `hash(name + ip + proto)`.
	// This parameter allows to finish one session and start another one with the same authorization token.
	// The keys `name`,`ip`, and `proto` are required.
	// Example: [name token proto ip]
	SetSessionKeys([]SessionKey) AuthSpec
	// If this option is enabled and `max_sessions` limitation is used, the extra sessions are interrupted not immediately, but in 30 or 90 seconds.
	// This can be useful for middlewares that cannot generate a new token for every new stream or file request
	// and therefore need time to understand that all sessions are being used.
	// Example: false
	SoftLimitation() *bool
	// If this option is enabled and `max_sessions` limitation is used, the extra sessions are interrupted not immediately, but in 30 or 90 seconds.
	// This can be useful for middlewares that cannot generate a new token for every new stream or file request
	// and therefore need time to understand that all sessions are being used.
	// Example: false
	SetSoftLimitation(bool) AuthSpec
	// The URL of an HTTP backend.
	// Example: http://middleware-address/auth/v2
	URL() *AuthURL
	// The URL of an HTTP backend.
	// Example: http://middleware-address/auth/v2
	SetURL(AuthURL) AuthSpec
}

type BalancerConfig interface {
	// Balancing mode
	Mode() *BalancerConfigMode
	// Balancing mode
	SetMode(BalancerConfigMode) BalancerConfig
	// Globally unique balancer name.
	// Format: media_name (media_name)
	Name() *MediaName
	// Globally unique balancer name.
	// Format: media_name (media_name)
	SetName(MediaName) BalancerConfig
	// Balancer will distribute requests between these servers.
	Servers() []BalancerServerConfig
	// Balancer will distribute requests between these servers.
	SetServers([]BalancerServerConfig) BalancerConfig
}

type BalancerServerConfig interface {
	// Client will be redirected to the peer if its IP belongs to one of these countries.
	Countries() []Iso3166
	// Client will be redirected to the peer if its IP belongs to one of these countries.
	SetCountries([]Iso3166) BalancerServerConfig
	// This flag allows to redirect a request to this peer if "countries" list not matched.
	CountriesDefault() *bool
	// This flag allows to redirect a request to this peer if "countries" list not matched.
	SetCountriesDefault(bool) BalancerServerConfig
	// Maximum allowed bitrate, request is redirecting if current bitrate is lower.
	// Format: speed (speed)
	MaxBitrate() *Speed
	// Maximum allowed bitrate, request is redirecting if current bitrate is lower.
	// Format: speed (speed)
	SetMaxBitrate(Speed) BalancerServerConfig
	// Hostname of the peer. Can refer to globally defined peer.
	// Format: server_name (server_name)
	Name() *ServerName
	// Hostname of the peer. Can refer to globally defined peer.
	// Format: server_name (server_name)
	SetName(ServerName) BalancerServerConfig
}

// Required: name
type CacheConfig interface {
	// A period (in seconds) back from the current moment during which the files are stored.
	// As time goes, the files which are older than this period are being overridden by the later files.
	// Format: seconds (seconds)
	// Example: 604800
	Expiration() *Seconds
	// A period (in seconds) back from the current moment during which the files are stored.
	// As time goes, the files which are older than this period are being overridden by the later files.
	// Format: seconds (seconds)
	// Example: 604800
	SetExpiration(Seconds) CacheConfig
	// The number of requests necessary for a file to be cached.
	// Example: 3
	Misses() *int
	// The number of requests necessary for a file to be cached.
	// Example: 3
	SetMisses(int) CacheConfig
	// Globally unique cache name.
	// Format: cache_name (cache_name)
	// Example: cache1
	Name() CacheName
	// Globally unique cache name.
	// Format: cache_name (cache_name)
	// Example: cache1
	SetName(CacheName) CacheConfig
	// The path where the files from the cloud or HTTP are cached to speed up broadcasting.
	// Format: disk_path (disk_path)
	// Example: /storage/cache
	Path() *DiskPath
	// The path where the files from the cloud or HTTP are cached to speed up broadcasting.
	// Format: disk_path (disk_path)
	// Example: /storage/cache
	SetPath(DiskPath) CacheConfig
	// Maximum disk consumption in bytes.
	// When this limit is reached, the oldest files will be overridden by later files.
	// Format: bytes (bytes)
	// Example: 400000
	StorageLimit() *Bytes
	// Maximum disk consumption in bytes.
	// When this limit is reached, the oldest files will be overridden by later files.
	// Format: bytes (bytes)
	// Example: 400000
	SetStorageLimit(Bytes) CacheConfig
}

type CacheSpec interface {
	// A period (in seconds) back from the current moment during which the files are stored.
	// As time goes, the files which are older than this period are being overridden by the later files.
	// Format: seconds (seconds)
	// Example: 3600
	Expiration() *Seconds
	// A period (in seconds) back from the current moment during which the files are stored.
	// As time goes, the files which are older than this period are being overridden by the later files.
	// Format: seconds (seconds)
	// Example: 3600
	SetExpiration(Seconds) CacheSpec
	// The number of requests necessary for a file to be cached.
	// Example: 3
	Misses() *int
	// The number of requests necessary for a file to be cached.
	// Example: 3
	SetMisses(int) CacheSpec
	// The name of the cache.
	// Format: cache_name (cache_name)
	// Example: cache1
	Reference() *CacheName
	// The name of the cache.
	// Format: cache_name (cache_name)
	// Example: cache1
	SetReference(CacheName) CacheSpec
	// Maximum disk consumption in bytes.
	// When this limit is reached, the oldest files will be overridden by later files.
	// Format: bytes (bytes)
	// Example: 400000
	StorageLimit() *Bytes
	// Maximum disk consumption in bytes.
	// When this limit is reached, the oldest files will be overridden by later files.
	// Format: bytes (bytes)
	// Example: 400000
	SetStorageLimit(Bytes) CacheSpec
}

type CameraAlarmConfig interface {
	// The list of keywords in the e-mails that are considered alarms.
	Catch() []string
	// The list of keywords in the e-mails that are considered alarms.
	SetCatch([]string) CameraAlarmConfig
	// The `smtp://` link to get camera alarms from.
	Listen() *ListenSpec
	// The `smtp://` link to get camera alarms from.
	SetListen(*ListenSpec) CameraAlarmConfig
}

type CameraConfig interface {
	// Describes camera information.
	CameraInfo() any
	// Describes camera information.
	SetCameraInfo(any) CameraConfig
	// These parameters allow optimizing media quality and performance based on device capabilities and network conditions.
	MediaQuality() any
	// These parameters allow optimizing media quality and performance based on device capabilities and network conditions.
	SetMediaQuality(any) CameraConfig
	// Describes sensor configuration.
	Sensor() any
	// Describes sensor configuration.
	SetSensor(any) CameraConfig
}

// Camera information
type CameraInfo interface {
	// Firmware version
	Firmware() *string
	// Firmware version
	SetFirmware(string) CameraInfo
	// Manufacturer name
	Manufacturer() *string
	// Manufacturer name
	SetManufacturer(string) CameraInfo
	// Model name
	Model() *string
	// Model name
	SetModel(string) CameraInfo
	// Serial number
	SerialNumber() *string
	// Serial number
	SetSerialNumber(string) CameraInfo
}

type CameraTagWb interface {
}

// Predictions for disk usage.
type CentralDiskPredictions interface {
	// Estimated disk usage in percent.
	// This value is estimated on the based on streamer disk space and current configurations of streams processed by the streamer,
	// which specify the rate of data writing to disk by them and the duration of their data storage.
	// Note: This value represents what percentage of the disk will be filled when all streams on the streamer reach the point where the disk is static.
	// It can be greater than 100% if streamer can't store estimated amount of data.
	// Format: percent (percent)
	EstimatedDiskUsage() *Percent
	// Estimated disk usage in percent.
	// This value is estimated on the based on streamer disk space and current configurations of streams processed by the streamer,
	// which specify the rate of data writing to disk by them and the duration of their data storage.
	// Note: This value represents what percentage of the disk will be filled when all streams on the streamer reach the point where the disk is static.
	// It can be greater than 100% if streamer can't store estimated amount of data.
	// Format: percent (percent)
	SetEstimatedDiskUsage(Percent) CentralDiskPredictions
}

type CentralNodeLayoutDecision interface {
	// Hostname of streamer
	// Format: server_name (server_name)
	// Example: streamer1.com
	Hostname() *ServerName
	// Hostname of streamer
	// Format: server_name (server_name)
	// Example: streamer1.com
	SetHostname(ServerName) CentralNodeLayoutDecision
	// This field is true if the stream can be layouted on this node.
	// Example: false
	NodeDecision() *bool
	// This field is true if the stream can be layouted on this node.
	// Example: false
	SetNodeDecision(bool) CentralNodeLayoutDecision
	// List of decision reasons explaining why the stream cannot be layouted on this node. This field may be empty if stream can be layouted on this node.
	// Example: [stream_misses_node_required_labels node_misses_stream_required_labels node_channel_limit_exceeded]
	Reasons() []CentralNodeLayoutDecisionReason
	// List of decision reasons explaining why the stream cannot be layouted on this node. This field may be empty if stream can be layouted on this node.
	// Example: [stream_misses_node_required_labels node_misses_stream_required_labels node_channel_limit_exceeded]
	SetReasons([]CentralNodeLayoutDecisionReason) CentralNodeLayoutDecision
	// Role of node
	Role() *CentralNodeRoleRole
	// Role of node
	SetRole(CentralNodeRoleRole) CentralNodeLayoutDecision
}

type CentralNodeRole interface {
	// Role of node
	Role() *CentralNodeRoleRole
	// Role of node
	SetRole(CentralNodeRoleRole) CentralNodeRole
}

type CentralStreamLayout interface {
	// Reason why layout was changed
	ChangeReason() *CentralStreamLayoutChangeReason
	// Reason why layout was changed
	SetChangeReason(CentralStreamLayoutChangeReason) CentralStreamLayout
	// Time when the node change occurred
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	CreatedAt() *UtcMs
	// Time when the node change occurred
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	SetCreatedAt(UtcMs) CentralStreamLayout
	// Current nodes on which the dvr backup is saving
	DvrBackups() []ServerName
	// Current nodes on which the dvr backup is saving
	SetDvrBackups([]ServerName) CentralStreamLayout
	// Hostname of current inference node on which stream analytics running.
	// Format: server_name (server_name)
	Inference() *ServerName
	// Hostname of current inference node on which stream analytics running.
	// Format: server_name (server_name)
	SetInference(ServerName) CentralStreamLayout
	// Hostname of current ingest on which the stream is being captured
	// Format: server_name (server_name)
	Ingest() *ServerName
	// Hostname of current ingest on which the stream is being captured
	// Format: server_name (server_name)
	SetIngest(ServerName) CentralStreamLayout
	// History of layout ingest. This field includes only 5 last records.
	// This field is only returned with explicit `include_ingest_history=true` query param.
	IngestHistory() []CentralStreamLayoutBase
	// History of layout ingest. This field includes only 5 last records.
	// This field is only returned with explicit `include_ingest_history=true` query param.
	SetIngestHistory([]CentralStreamLayoutBase) CentralStreamLayout
	// List of decisions made by [layouter](https://flussonic.com/doc/api/layouter/) for each node.
	// These decisions are used to determine the final layout of the stream.
	NodeLayoutDecisions() []CentralNodeLayoutDecision
	// List of decisions made by [layouter](https://flussonic.com/doc/api/layouter/) for each node.
	// These decisions are used to determine the final layout of the stream.
	SetNodeLayoutDecisions([]CentralNodeLayoutDecision) CentralStreamLayout
	// Service or admin user who changed the layout of the stream using an API call.
	Originator() *CentralStreamLayoutOriginator
	// Service or admin user who changed the layout of the stream using an API call.
	SetOriginator(CentralStreamLayoutOriginator) CentralStreamLayout
}

type CentralStreamLayoutBase interface {
	// Time when the node change occurred
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	CreatedAt() *UtcMs
	// Time when the node change occurred
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	SetCreatedAt(UtcMs) CentralStreamLayoutBase
	// Hostname of current ingest on which the stream is being captured
	// Format: server_name (server_name)
	Ingest() *ServerName
	// Hostname of current ingest on which the stream is being captured
	// Format: server_name (server_name)
	SetIngest(ServerName) CentralStreamLayoutBase
	// Service or admin user who changed the layout of the stream using an API call.
	Originator() *CentralStreamLayoutOriginator
	// Service or admin user who changed the layout of the stream using an API call.
	SetOriginator(CentralStreamLayoutOriginator) CentralStreamLayoutBase
}

type CentralStreamLayoutListItem interface {
	// Reason why layout was changed
	ChangeReason() *CentralStreamLayoutChangeReason
	// Reason why layout was changed
	SetChangeReason(CentralStreamLayoutChangeReason) CentralStreamLayoutListItem
	// Time when the node change occurred
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	CreatedAt() *UtcMs
	// Time when the node change occurred
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	SetCreatedAt(UtcMs) CentralStreamLayoutListItem
	// Current nodes on which the dvr backup is saving
	DvrBackups() []ServerName
	// Current nodes on which the dvr backup is saving
	SetDvrBackups([]ServerName) CentralStreamLayoutListItem
	// Hostname of current inference node on which stream analytics running.
	// Format: server_name (server_name)
	Inference() *ServerName
	// Hostname of current inference node on which stream analytics running.
	// Format: server_name (server_name)
	SetInference(ServerName) CentralStreamLayoutListItem
	// Hostname of current ingest on which the stream is being captured
	// Format: server_name (server_name)
	Ingest() *ServerName
	// Hostname of current ingest on which the stream is being captured
	// Format: server_name (server_name)
	SetIngest(ServerName) CentralStreamLayoutListItem
	// History of layout ingest. This field includes only 5 last records.
	// This field is only returned with explicit `include_ingest_history=true` query param.
	IngestHistory() []CentralStreamLayoutBase
	// History of layout ingest. This field includes only 5 last records.
	// This field is only returned with explicit `include_ingest_history=true` query param.
	SetIngestHistory([]CentralStreamLayoutBase) CentralStreamLayoutListItem
	// Name of the stream
	Name() *string
	// Name of the stream
	SetName(string) CentralStreamLayoutListItem
	// List of decisions made by [layouter](https://flussonic.com/doc/api/layouter/) for each node.
	// These decisions are used to determine the final layout of the stream.
	NodeLayoutDecisions() []CentralNodeLayoutDecision
	// List of decisions made by [layouter](https://flussonic.com/doc/api/layouter/) for each node.
	// These decisions are used to determine the final layout of the stream.
	SetNodeLayoutDecisions([]CentralNodeLayoutDecision) CentralStreamLayoutListItem
	// Service or admin user who changed the layout of the stream using an API call.
	Originator() *CentralStreamLayoutOriginator
	// Service or admin user who changed the layout of the stream using an API call.
	SetOriginator(CentralStreamLayoutOriginator) CentralStreamLayoutListItem
}

type CentralStreamLayoutPrediction interface {
	// List of streams layout changes
	Changes() []CentralStreamLayoutListItem
	// List of streams layout changes
	SetChanges([]CentralStreamLayoutListItem) CentralStreamLayoutPrediction
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	EstimatedCount() *int
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	SetEstimatedCount(int) CentralStreamLayoutPrediction
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	Next() *string
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	SetNext(string) CentralStreamLayoutPrediction
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	Prev() *string
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	SetPrev(string) CentralStreamLayoutPrediction
	// An object with a list of different timings measured during this API call.
	Timing() any
	// An object with a list of different timings measured during this API call.
	SetTiming(any) CentralStreamLayoutPrediction
	// Collection returns the collection items
	Collection() []CentralStreamLayoutListItem
}

type CentralStreamLayouts interface {
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	EstimatedCount() *int
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	SetEstimatedCount(int) CentralStreamLayouts
	// List of streams layouts records according to the query parameters.
	Layouts() []CentralStreamLayout
	// List of streams layouts records according to the query parameters.
	SetLayouts([]CentralStreamLayout) CentralStreamLayouts
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	Next() *string
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	SetNext(string) CentralStreamLayouts
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	Prev() *string
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	SetPrev(string) CentralStreamLayouts
	// An object with a list of different timings measured during this API call.
	Timing() any
	// An object with a list of different timings measured during this API call.
	SetTiming(any) CentralStreamLayouts
	// Collection returns the collection items
	Collection() []CentralStreamLayout
}

type CentralStreamerLayoutPrediction interface {
	// Predicted layout based on changed properties of streamer grouped by hostname and role.
	// The result does not contain unchanged streamers.
	// If streamer config was not changed, the result will be empty.
	Changes() []CentralStreamerLayoutPredictionItem
	// Predicted layout based on changed properties of streamer grouped by hostname and role.
	// The result does not contain unchanged streamers.
	// If streamer config was not changed, the result will be empty.
	SetChanges([]CentralStreamerLayoutPredictionItem) CentralStreamerLayoutPrediction
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	EstimatedCount() *int
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	SetEstimatedCount(int) CentralStreamerLayoutPrediction
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	Next() *string
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	SetNext(string) CentralStreamerLayoutPrediction
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	Prev() *string
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	SetPrev(string) CentralStreamerLayoutPrediction
	// An object with a list of different timings measured during this API call.
	Timing() any
	// An object with a list of different timings measured during this API call.
	SetTiming(any) CentralStreamerLayoutPrediction
	// Collection returns the collection items
	Collection() []CentralStreamerLayoutPredictionItem
}

type CentralStreamerLayoutPredictionItem interface {
	// Number of streams assigned to the streamer after the layouter iteration.
	// Example: 123
	After() *int
	// Number of streams assigned to the streamer after the layouter iteration.
	// Example: 123
	SetAfter(int) CentralStreamerLayoutPredictionItem
	// Number of streams assigned to the streamer before the layouter iteration.
	// Example: 321
	Before() *int
	// Number of streams assigned to the streamer before the layouter iteration.
	// Example: 321
	SetBefore(int) CentralStreamerLayoutPredictionItem
	// `after - before` value.
	// Example: 1
	Delta() *int
	// `after - before` value.
	// Example: 1
	SetDelta(int) CentralStreamerLayoutPredictionItem
	// Hostname of streamer
	// Format: server_name (server_name)
	// Example: streamer1
	Hostname() *ServerName
	// Hostname of streamer
	// Format: server_name (server_name)
	// Example: streamer1
	SetHostname(ServerName) CentralStreamerLayoutPredictionItem
	// Layout role of streamer.
	// Example: ingest
	Role() *CentralStreamerLayoutPredictionItemRole
	// Layout role of streamer.
	// Example: ingest
	SetRole(CentralStreamerLayoutPredictionItemRole) CentralStreamerLayoutPredictionItem
}

type CertificateInfo interface {
	// One or more domains for which the certificate is issued.
	Domains() []string
	// One or more domains for which the certificate is issued.
	SetDomains([]string) CertificateInfo
	// The name of the issuing authority.
	IssuerName() *string
	// The name of the issuing authority.
	SetIssuerName(string) CertificateInfo
	// End date of the certificate.
	NotAfter() *int
	// End date of the certificate.
	SetNotAfter(int) CertificateInfo
	// Start date of the certificate.
	NotBefore() *int
	// Start date of the certificate.
	SetNotBefore(int) CertificateInfo
	// Public key.
	PublicKey() *string
	// Public key.
	SetPublicKey(string) CertificateInfo
}

type ChassisConfig interface {
	// Private port for API requests to the chassis from coders.
	APIPort() *ListenSpec
	// Private port for API requests to the chassis from coders.
	SetAPIPort(*ListenSpec) ChassisConfig
	// Shows if auto restart of coders when (re)starting chassis is enabled.
	AutoReboot() *bool
	// Shows if auto restart of coders when (re)starting chassis is enabled.
	SetAutoReboot(bool) ChassisConfig
	// If `default_gateway` parameters are set the individual interfaces config,
	// this gateway is only used for checking license and updates.
	// Otherwise, it is used as gateway for all traffic.
	// Example: streaming
	DefaultGatewayInterface() *string
	// If `default_gateway` parameters are set the individual interfaces config,
	// this gateway is only used for checking license and updates.
	// Otherwise, it is used as gateway for all traffic.
	// Example: streaming
	SetDefaultGatewayInterface(string) ChassisConfig
	// Network interface for automatic reception of IP address from DHCP server.
	// This interface will be used for launching coders.
	// Format: interface_name (interface_name)
	DhcpdIface() *InterfaceName
	// Network interface for automatic reception of IP address from DHCP server.
	// This interface will be used for launching coders.
	// Format: interface_name (interface_name)
	SetDhcpdIface(InterfaceName) ChassisConfig
	// Source port for DHCP requests.
	DhcpdPort() *ListenSpec
	// Source port for DHCP requests.
	SetDhcpdPort(*ListenSpec) ChassisConfig
	// Destination port for DHCP requests.
	DhcpdPortDest() *ListenSpec
	// Destination port for DHCP requests.
	SetDhcpdPortDest(*ListenSpec) ChassisConfig
	// Directory to boot the device from. This is also where the firmware is downloaded on updates.
	// Format: disk_path (disk_path)
	FirmwareBootDir() *DiskPath
	// Directory to boot the device from. This is also where the firmware is downloaded on updates.
	// Format: disk_path (disk_path)
	SetFirmwareBootDir(DiskPath) ChassisConfig
	// URL for downloading firmware.
	// Format: url (url)
	FirmwareHost() *URL
	// URL for downloading firmware.
	// Format: url (url)
	SetFirmwareHost(URL) ChassisConfig
	// Firmware version installed on the device.
	FirmwareVersion() *string
	// Firmware version installed on the device.
	SetFirmwareVersion(string) ChassisConfig
	// The name of the chassis server.
	// Format: server_name (server_name)
	// Example: coder1.example.com
	Hostname() *ServerName
	// The name of the chassis server.
	// Format: server_name (server_name)
	// Example: coder1.example.com
	SetHostname(ServerName) ChassisConfig
	// Shows if LCD monitor capabilities are enabled in the firmware.
	Lcd() *bool
	// Shows if LCD monitor capabilities are enabled in the firmware.
	SetLcd(bool) ChassisConfig
	// List of NTP server host names or IP addresses
	NtpServers() []string
	// List of NTP server host names or IP addresses
	SetNtpServers([]string) ChassisConfig
	// Network interface for NTP daemon.
	// Format: interface_name (interface_name)
	NtpdIface() *InterfaceName
	// Network interface for NTP daemon.
	// Format: interface_name (interface_name)
	SetNtpdIface(InterfaceName) ChassisConfig
	// Port for NTP daemon.
	NtpdPort() *ListenSpec
	// Port for NTP daemon.
	SetNtpdPort(*ListenSpec) ChassisConfig
	// Coder product name
	ProductName() *ChassisProduct
	// Coder product name
	SetProductName(ChassisProduct) ChassisConfig
	// Timeout for restarting coders.
	RestartCoderTimeout() *int
	// Timeout for restarting coders.
	SetRestartCoderTimeout(int) ChassisConfig
	// Statistics of the chassis connections.
	Stats() ChassisStats
	// Statistics of the chassis connections.
	SetStats(ChassisStats) ChassisConfig
	// Port for TFTP used for loading program core to the coders.
	TftpPort() *ListenSpec
	// Port for TFTP used for loading program core to the coders.
	SetTftpPort(*ListenSpec) ChassisConfig
	// TFTP root directory.
	// Format: disk_path (disk_path)
	TftpRoot() *DiskPath
	// TFTP root directory.
	// Format: disk_path (disk_path)
	SetTftpRoot(DiskPath) ChassisConfig
	// Update channel specified in the config file.
	UpdateChannel() *string
	// Update channel specified in the config file.
	SetUpdateChannel(string) ChassisConfig
}

type ChassisStats interface {
	// MAC address of the manage0 interface.
	HardwareID() *string
	// MAC address of the manage0 interface.
	SetHardwareID(string) ChassisStats
	// Hostname of the server.
	// Example: coder1.example.com
	Hostname() *string
	// Hostname of the server.
	// Example: coder1.example.com
	SetHostname(string) ChassisStats
	// The chassis model name.
	// Example: chassis_model
	Model() *string
	// The chassis model name.
	// Example: chassis_model
	SetModel(string) ChassisStats
	// Deprecated field. Will be deleted at 24.10
	// The latest available version of the firmware, if any. Deprecated. Last available version could be obtained from `chassis_firmwares_list`
	NextVersion() *string
	// Deprecated field. Will be deleted at 24.10
	// The latest available version of the firmware, if any. Deprecated. Last available version could be obtained from `chassis_firmwares_list`
	SetNextVersion(string) ChassisStats
	// Whether a system clock synchronized with NTP server
	NtpClockSynchronized() *bool
	// Whether a system clock synchronized with NTP server
	SetNtpClockSynchronized(bool) ChassisStats
	// The serial number of the chassis.
	// Example: 2174220024
	SerialNumber() *string
	// The serial number of the chassis.
	// Example: 2174220024
	SetSerialNumber(string) ChassisStats
	// Chassis system time (in UTC milliseconds)
	// Format: utc_ms (Unix timestamp in milliseconds)
	SystemTime() *UtcMs
	// Chassis system time (in UTC milliseconds)
	// Format: utc_ms (Unix timestamp in milliseconds)
	SetSystemTime(UtcMs) ChassisStats
	// Deprecated field. Will be deleted at 24.10
	// Full version number of the firmware. Deprecated. Version could be found at `chassis_config/firmware_version`
	// Example: 21.09.1-234
	Version() *string
	// Deprecated field. Will be deleted at 24.10
	// Full version number of the firmware. Deprecated. Version could be found at `chassis_config/firmware_version`
	// Example: 21.09.1-234
	SetVersion(string) ChassisStats
}

type ClosedCaptions interface {
	// Language of closed captions.
	// Example: eng
	Language() *string
	// Language of closed captions.
	// Example: eng
	SetLanguage(string) ClosedCaptions
	// Under what name the audio track will be displayed on the player.
	// Example: English
	Name() *string
	// Under what name the audio track will be displayed on the player.
	// Example: English
	SetName(string) ClosedCaptions
}

// Number of entities, grouped by status
type ClusterHealthMetricsTotal interface {
	// Number of degraded entities
	Degradated() *int
	// Number of degraded entities
	SetDegradated(int) ClusterHealthMetricsTotal
	// Number of disabled entities
	Disabled() *int
	// Number of disabled entities
	SetDisabled(int) ClusterHealthMetricsTotal
	// Number of operational entities
	Operational() *int
	// Number of operational entities
	SetOperational(int) ClusterHealthMetricsTotal
	// Number of outage entities
	Outage() *int
	// Number of outage entities
	SetOutage(int) ClusterHealthMetricsTotal
	// Number of partial outage entities
	PartialOutage() *int
	// Number of partial outage entities
	SetPartialOutage(int) ClusterHealthMetricsTotal
	// Total number of entities
	Total() *int
	// Total number of entities
	SetTotal(int) ClusterHealthMetricsTotal
}

type ClusterHealthStats interface {
	// Number of agents, grouped by status
	AgentMetricsTotal() ClusterHealthMetricsTotal
	// Number of agents, grouped by status
	SetAgentMetricsTotal(ClusterHealthMetricsTotal) ClusterHealthStats
	// Metrics collection time
	// Format: utc_ms (Unix timestamp in milliseconds)
	CollectedAt() *UtcMs
	// Metrics collection time
	// Format: utc_ms (Unix timestamp in milliseconds)
	SetCollectedAt(UtcMs) ClusterHealthStats
	// Unique server ID generated on a first run.
	// Format: uuid (uuid)
	// Example: 123e4567-e89b-12d3-a456-426655440000
	ServerID() *UUID
	// Unique server ID generated on a first run.
	// Format: uuid (uuid)
	// Example: 123e4567-e89b-12d3-a456-426655440000
	SetServerID(UUID) ClusterHealthStats
	// Number of streams, grouped by status
	StreamMetricsTotal() ClusterHealthMetricsTotal
	// Number of streams, grouped by status
	SetStreamMetricsTotal(ClusterHealthMetricsTotal) ClusterHealthStats
	// Cluster total bitrate metrics
	StreamerBitrateMetricsTotal() ClusterHealthStatsStreamerBitrateMetricsTotal
	// Cluster total bitrate metrics
	SetStreamerBitrateMetricsTotal(ClusterHealthStatsStreamerBitrateMetricsTotal) ClusterHealthStats
	// Streamer stats
	StreamerMetrics() []ClusterHealthStreamerStats
	// Streamer stats
	SetStreamerMetrics([]ClusterHealthStreamerStats) ClusterHealthStats
	// Number of streamers, grouped by status
	StreamerMetricsTotal() ClusterHealthMetricsTotal
	// Number of streamers, grouped by status
	SetStreamerMetricsTotal(ClusterHealthMetricsTotal) ClusterHealthStats
	// The running version of instance in format TAGCNUM. TAG is a five-digit number that contains the year number, month number, and version number. CNUM is a four-digit number that indicates the commit number. Number 240100023 represents version 24.01-23.
	// Example: 2.40100023e+08
	Version() *int
	// The running version of instance in format TAGCNUM. TAG is a five-digit number that contains the year number, month number, and version number. CNUM is a four-digit number that indicates the commit number. Number 240100023 represents version 24.01-23.
	// Example: 2.40100023e+08
	SetVersion(int) ClusterHealthStats
}

// Cluster total bitrate metrics
type ClusterHealthStatsStreamerBitrateMetricsTotal interface {
	// Current incoming speed (bitrate) of the data transmission over the network of all streamers.
	// Format: speed (speed)
	InputKbit() *Speed
	// Current incoming speed (bitrate) of the data transmission over the network of all streamers.
	// Format: speed (speed)
	SetInputKbit(Speed) ClusterHealthStatsStreamerBitrateMetricsTotal
	// Current outgoing speed (bitrate) of the data transmission over the network of all streamers.
	// Format: speed (speed)
	OutputKbit() *Speed
	// Current outgoing speed (bitrate) of the data transmission over the network of all streamers.
	// Format: speed (speed)
	SetOutputKbit(Speed) ClusterHealthStatsStreamerBitrateMetricsTotal
}

// Streamer stats
// Required: hostname
type ClusterHealthStreamerStats interface {
	// Streamer agents info.
	AgentMetrics() ClusterHealthStreamerStatsAgentMetrics
	// Streamer agents info.
	SetAgentMetrics(ClusterHealthStreamerStatsAgentMetrics) ClusterHealthStreamerStats
	// Streamer config info.
	Config() ClusterHealthStreamerStatsConfig
	// Streamer config info.
	SetConfig(ClusterHealthStreamerStatsConfig) ClusterHealthStreamerStats
	// CPU usage info.
	Cpu() ClusterHealthStreamerStatsCpu
	// CPU usage info.
	SetCpu(ClusterHealthStreamerStatsCpu) ClusterHealthStreamerStats
	// Hostname of streamer.
	// Format: server_name (server_name)
	Hostname() ServerName
	// Hostname of streamer.
	// Format: server_name (server_name)
	SetHostname(ServerName) ClusterHealthStreamerStats
	// Memory usage info.
	Memory() ClusterHealthStreamerStatsMemory
	// Memory usage info.
	SetMemory(ClusterHealthStreamerStatsMemory) ClusterHealthStreamerStats
	// Network IO info.
	Network() ClusterHealthStreamerStatsNetwork
	// Network IO info.
	SetNetwork(ClusterHealthStreamerStatsNetwork) ClusterHealthStreamerStats
	Status() *ClusterHealthStatus
	SetStatus(ClusterHealthStatus) ClusterHealthStreamerStats
	// Total disk usage info.
	Storage() ClusterHealthStreamerStatsStorage
	// Total disk usage info.
	SetStorage(ClusterHealthStreamerStatsStorage) ClusterHealthStreamerStats
	// Streamer streams info.
	StreamMetrics() ClusterHealthStreamerStatsStreamMetrics
	// Streamer streams info.
	SetStreamMetrics(ClusterHealthStreamerStatsStreamMetrics) ClusterHealthStreamerStats
	// The server uptime.
	// Format: seconds (seconds)
	// Example: 4.325502e+06
	Uptime() *Seconds
	// The server uptime.
	// Format: seconds (seconds)
	// Example: 4.325502e+06
	SetUptime(Seconds) ClusterHealthStreamerStats
}

// Streamer agents info.
type ClusterHealthStreamerStatsAgentMetrics interface {
	// Number of degraded entities
	Degradated() *int
	// Number of degraded entities
	SetDegradated(int) ClusterHealthStreamerStatsAgentMetrics
	// Number of disabled entities
	Disabled() *int
	// Number of disabled entities
	SetDisabled(int) ClusterHealthStreamerStatsAgentMetrics
	// Number of operational entities
	Operational() *int
	// Number of operational entities
	SetOperational(int) ClusterHealthStreamerStatsAgentMetrics
	// Number of outage entities
	Outage() *int
	// Number of outage entities
	SetOutage(int) ClusterHealthStreamerStatsAgentMetrics
	// Number of partial outage entities
	PartialOutage() *int
	// Number of partial outage entities
	SetPartialOutage(int) ClusterHealthStreamerStatsAgentMetrics
	Status() *ClusterHealthStatus
	SetStatus(ClusterHealthStatus) ClusterHealthStreamerStatsAgentMetrics
	// Total number of entities
	Total() *int
	// Total number of entities
	SetTotal(int) ClusterHealthStreamerStatsAgentMetrics
}

// Streamer config info.
type ClusterHealthStreamerStatsConfig interface {
	Status() *ClusterHealthStatus
	SetStatus(ClusterHealthStatus) ClusterHealthStreamerStatsConfig
}

// CPU usage info.
type ClusterHealthStreamerStatsCpu interface {
	Status() *ClusterHealthStatus
	SetStatus(ClusterHealthStatus) ClusterHealthStreamerStatsCpu
	// CPU usage on the server.
	// Format: percent (percent)
	// Example: 48
	Usage() *Percent
	// CPU usage on the server.
	// Format: percent (percent)
	// Example: 48
	SetUsage(Percent) ClusterHealthStreamerStatsCpu
}

// Memory usage info.
type ClusterHealthStreamerStatsMemory interface {
	Status() *ClusterHealthStatus
	SetStatus(ClusterHealthStatus) ClusterHealthStreamerStatsMemory
	// Memory usage on the server.
	// Format: percent (percent)
	// Example: 27
	Usage() *Percent
	// Memory usage on the server.
	// Format: percent (percent)
	// Example: 27
	SetUsage(Percent) ClusterHealthStreamerStatsMemory
}

// Network IO info.
type ClusterHealthStreamerStatsNetwork interface {
	// Inbound network info on the server.
	InKbit() ClusterHealthStreamerStatsNetworkInKbit
	// Inbound network info on the server.
	SetInKbit(ClusterHealthStreamerStatsNetworkInKbit) ClusterHealthStreamerStatsNetwork
	// Outbound network info on the server.
	OutKbit() ClusterHealthStreamerStatsNetworkOutKbit
	// Outbound network info on the server.
	SetOutKbit(ClusterHealthStreamerStatsNetworkOutKbit) ClusterHealthStreamerStatsNetwork
}

// Inbound network info on the server.
type ClusterHealthStreamerStatsNetworkInKbit interface {
	Status() *ClusterHealthStatus
	SetStatus(ClusterHealthStatus) ClusterHealthStreamerStatsNetworkInKbit
	// Inbound network usage on the server.
	// Format: speed (speed)
	Usage() *Speed
	// Inbound network usage on the server.
	// Format: speed (speed)
	SetUsage(Speed) ClusterHealthStreamerStatsNetworkInKbit
}

// Outbound network info on the server.
type ClusterHealthStreamerStatsNetworkOutKbit interface {
	Status() *ClusterHealthStatus
	SetStatus(ClusterHealthStatus) ClusterHealthStreamerStatsNetworkOutKbit
	// Outbound network usage on the server.
	// Format: speed (speed)
	Usage() *Speed
	// Outbound network usage on the server.
	// Format: speed (speed)
	SetUsage(Speed) ClusterHealthStreamerStatsNetworkOutKbit
}

// Total disk usage info.
type ClusterHealthStreamerStatsStorage interface {
	Status() *ClusterHealthStatus
	SetStatus(ClusterHealthStatus) ClusterHealthStreamerStatsStorage
	// Total disk space usage on the server.
	// Format: percent (percent)
	// Example: 18
	Usage() *Percent
	// Total disk space usage on the server.
	// Format: percent (percent)
	// Example: 18
	SetUsage(Percent) ClusterHealthStreamerStatsStorage
}

// Streamer streams info.
type ClusterHealthStreamerStatsStreamMetrics interface {
	// Number of degraded entities
	Degradated() *int
	// Number of degraded entities
	SetDegradated(int) ClusterHealthStreamerStatsStreamMetrics
	// Number of disabled entities
	Disabled() *int
	// Number of disabled entities
	SetDisabled(int) ClusterHealthStreamerStatsStreamMetrics
	// Number of operational entities
	Operational() *int
	// Number of operational entities
	SetOperational(int) ClusterHealthStreamerStatsStreamMetrics
	// Number of outage entities
	Outage() *int
	// Number of outage entities
	SetOutage(int) ClusterHealthStreamerStatsStreamMetrics
	// Number of partial outage entities
	PartialOutage() *int
	// Number of partial outage entities
	SetPartialOutage(int) ClusterHealthStreamerStatsStreamMetrics
	Status() *ClusterHealthStatus
	SetStatus(ClusterHealthStatus) ClusterHealthStreamerStatsStreamMetrics
	// Total number of entities
	Total() *int
	// Total number of entities
	SetTotal(int) ClusterHealthStreamerStatsStreamMetrics
}

type CollectionResponse interface {
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	EstimatedCount() *int
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	SetEstimatedCount(int) CollectionResponse
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	Next() *string
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	SetNext(string) CollectionResponse
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	Prev() *string
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	SetPrev(string) CollectionResponse
	// An object with a list of different timings measured during this API call.
	Timing() any
	// An object with a list of different timings measured during this API call.
	SetTiming(any) CollectionResponse
}

type ConfigErrorStatus interface {
	// The column number pointing to where the error was detected.
	// Example: 20
	Col() *int
	// The column number pointing to where the error was detected.
	// Example: 20
	SetCol(int) ConfigErrorStatus
	// Partial configuration that can be recovered if an error occurs.
	Config() any
	// Partial configuration that can be recovered if an error occurs.
	SetConfig(any) ConfigErrorStatus
	// Some other details that may help to identify the error.
	Detail() any
	// Some other details that may help to identify the error.
	SetDetail(any) ConfigErrorStatus
	// Short error description.
	// Example: bad_url
	Error() *string
	// Short error description.
	// Example: bad_url
	SetError(string) ConfigErrorStatus
	// Last column with something valid.
	// Example: 5
	FirstErrorCol() *int
	// Last column with something valid.
	// Example: 5
	SetFirstErrorCol(int) ConfigErrorStatus
	// If an error takes up to several lines, it is the first line where the error was detected.
	// Example: 14
	FirstErrorLine() *int
	// If an error takes up to several lines, it is the first line where the error was detected.
	// Example: 14
	SetFirstErrorLine(int) ConfigErrorStatus
	// Line number pointing to where an error was detected.
	// Example: 15
	Line() *int
	// Line number pointing to where an error was detected.
	// Example: 15
	SetLine(int) ConfigErrorStatus
	// Config path to the erroneous element.
	// Example: [streams 0 inputs 0 url input_url]
	Path() []ConfigPathSegment
	// Config path to the erroneous element.
	// Example: [streams 0 inputs 0 url input_url]
	SetPath([]ConfigPathSegment) ConfigErrorStatus
}

type ConfigExternalErrorStatus interface {
	// HTTP response code
	Code() *int
	// HTTP response code
	SetCode(int) ConfigExternalErrorStatus
	// Detailed error description (optional)
	Detail() *string
	// Detailed error description (optional)
	SetDetail(string) ConfigExternalErrorStatus
	// Error description (optional)
	// Example: invalid_authorization
	Error() *string
	// Error description (optional)
	// Example: invalid_authorization
	SetError(string) ConfigExternalErrorStatus
	// Config path to the erroneous element.
	// Example: [streams 0 inputs 0 url input_url]
	Path() []ConfigPathSegment
	// Config path to the erroneous element.
	// Example: [streams 0 inputs 0 url input_url]
	SetPath([]ConfigPathSegment) ConfigExternalErrorStatus
	Reason() *RequestErrorReason
	SetReason(RequestErrorReason) ConfigExternalErrorStatus
	// External config status
	Status() *ConfigExternalErrorStatusStatus
	// External config status
	SetStatus(ConfigExternalErrorStatusStatus) ConfigExternalErrorStatus
	// Conditions of the error occurrence.
	While() *ConfigExternalErrorStatusWhile
	// Conditions of the error occurrence.
	SetWhile(ConfigExternalErrorStatusWhile) ConfigExternalErrorStatus
}

type CreationInfo interface {
	// The time when the entity was created.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	CreatedAt() *UtcMs
	// The time when the entity was created.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetCreatedAt(UtcMs) CreationInfo
	// Information about the user who created the entity.
	User() CreationInfoUser
	// Information about the user who created the entity.
	SetUser(CreationInfoUser) CreationInfo
}

// Information about the user who created the entity.
type CreationInfoUser interface {
	// Identifier of the user.
	// Example: 1
	ID() *int
	// Identifier of the user.
	// Example: 1
	SetID(int) CreationInfoUser
	// User name(login).
	// Example: admin
	Name() *string
	// User name(login).
	// Example: admin
	SetName(string) CreationInfoUser
}

// Required: url
type Database interface {
	// Connection string to PostgreSQL database.
	// Format: `postgres://[user[:password]@][host][:port][/dbname][?param1=value1&...&paramN=valueN]`
	// Allowed parameters:
	// - `sslmode` - configuring SSL connection to the database.
	// This parameter defines whether and how SSL should be used to connect to the database.
	// Possible values include `disable`, `allow`, `prefer`, `require`, `verify-ca`, and `verify-full`.
	// - `default_query_exec_mode` - if you use PgBouncer, it's necessary to set this parameter to `cache_describe`.
	// Example: postgres://central:pass@localhost:5432/central_dev
	URL() string
	// Connection string to PostgreSQL database.
	// Format: `postgres://[user[:password]@][host][:port][/dbname][?param1=value1&...&paramN=valueN]`
	// Allowed parameters:
	// - `sslmode` - configuring SSL connection to the database.
	// This parameter defines whether and how SSL should be used to connect to the database.
	// Possible values include `disable`, `allow`, `prefer`, `require`, `verify-ca`, and `verify-full`.
	// - `default_query_exec_mode` - if you use PgBouncer, it's necessary to set this parameter to `cache_describe`.
	// Example: postgres://central:pass@localhost:5432/central_dev
	SetURL(string) Database
}

type DecklinkConfig interface {
	// The Decklink card name.
	Name() *DecklinkCardID
	// The Decklink card name.
	SetName(*DecklinkCardID) DecklinkConfig
	// The Decklink card profile that allows choosing between input and output direction.
	Profile() *DecklinkConfigProfile
	// The Decklink card profile that allows choosing between input and output direction.
	SetProfile(DecklinkConfigProfile) DecklinkConfig
}

// Base information about domain
type DomainBase interface {
	// Domain ID.
	// Example: 123
	ID() *int
	// Domain ID.
	// Example: 123
	SetID(int) DomainBase
	// The name of the domain.
	// Example: domain1
	Title() *string
	// The name of the domain.
	// Example: domain1
	SetTitle(string) DomainBase
}

// All domain settings
type DomainConfig interface {
	// Appearance settings allow you to edit the colors, logos, favicon and other brand UI settings of your service.
	Appearance() AppearanceConfig
	// Appearance settings allow you to edit the colors, logos, favicon and other brand UI settings of your service.
	SetAppearance(AppearanceConfig) DomainConfig
	Mail() MailSpec
	SetMail(MailSpec) DomainConfig
}

type DrmBase interface {
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	Encryption() *string
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	SetEncryption(string) DrmBase
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	Expires() *int
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	SetExpires(int) DrmBase
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	Keyserver() *string
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	SetKeyserver(string) DrmBase
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	ResourceID() *DrmResourceID
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	SetResourceID(DrmResourceID) DrmBase
}

type DrmCpixBase interface {
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	Encryption() *string
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	SetEncryption(string) DrmCpixBase
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	Expires() *int
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	SetExpires(int) DrmCpixBase
	// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
	// It is employed only one time in any session.
	// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
	// Usually, IV is received from a DRM provider.
	Iv() *string
	// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
	// It is employed only one time in any session.
	// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
	// Usually, IV is received from a DRM provider.
	SetIv(string) DrmCpixBase
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	Keyserver() *string
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	SetKeyserver(string) DrmCpixBase
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	ResourceID() *DrmResourceID
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	SetResourceID(DrmResourceID) DrmCpixBase
	// This parameter is used to specify applicable DRM systems.
	// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
	Systems() []DrmSystem
	// This parameter is used to specify applicable DRM systems.
	// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
	SetSystems([]DrmSystem) DrmCpixBase
}

type DrmEncKey interface {
	// Encryption Key in hex or file. Length must be 128 bit.
	// Example: 0x76359e1212952a6db42b41eeb94ceb29
	Key() *string
	// Encryption Key in hex or file. Length must be 128 bit.
	// Example: 0x76359e1212952a6db42b41eeb94ceb29
	SetKey(string) DrmEncKey
}

type DrmEncKeyURL interface {
	// Http link which specifies how to obtain the key. It is URI attribute of HLS manifest EXT-X-KEY method.
	URL() *string
	// Http link which specifies how to obtain the key. It is URI attribute of HLS manifest EXT-X-KEY method.
	SetURL(string) DrmEncKeyURL
}

type DrmIv interface {
	// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
	// It is employed only one time in any session.
	// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
	// Usually, IV is received from a DRM provider.
	Iv() *string
	// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
	// It is employed only one time in any session.
	// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
	// Usually, IV is received from a DRM provider.
	SetIv(string) DrmIv
}

type DrmKeyosBase interface {
	// A unique identifier of the content, used for Widevine DRM.
	// By default, it is equal to the stream name.
	ContentID() *string
	// A unique identifier of the content, used for Widevine DRM.
	// By default, it is equal to the stream name.
	SetContentID(string) DrmKeyosBase
	// Path to end user certificate file.
	EndUserCert() *string
	// Path to end user certificate file.
	SetEndUserCert(string) DrmKeyosBase
	// Path to end user private key file
	EndUserPrivateKey() *string
	// Path to end user private key file
	SetEndUserPrivateKey(string) DrmKeyosBase
	// Deprecated field. Will be deleted at 25.04
	// A unique identifier of the user
	Userkey() *string
	// Deprecated field. Will be deleted at 25.04
	// A unique identifier of the user
	SetUserkey(string) DrmKeyosBase
}

type DrmSpec interface {
	// ID of the Irdeto DRM account.
	AccountID() *string
	// ID of the Irdeto DRM account.
	SetAccountID(string) DrmSpec
	// AES (Advanced Encryption Standard) key. Used for Widevine DRM.
	AesKey() *string
	// AES (Advanced Encryption Standard) key. Used for Widevine DRM.
	SetAesKey(string) DrmSpec
	// Authentication server for DRMtoday.
	// Example: https://auth.drmtoday.com
	AuthServer() *string
	// Authentication server for DRMtoday.
	// Example: https://auth.drmtoday.com
	SetAuthServer(string) DrmSpec
	// A unique identifier of the content, used for Widevine DRM.
	// By default, it is equal to the stream name.
	ContentID() *string
	// A unique identifier of the content, used for Widevine DRM.
	// By default, it is equal to the stream name.
	SetContentID(string) DrmSpec
	// The uuid of the CPIX/SPEKE ingest configuration
	CpixConfigID() *string
	// The uuid of the CPIX/SPEKE ingest configuration
	SetCpixConfigID(string) DrmSpec
	// An API authentication token that is generated when you sign up for the PallyCon service at https://login.pallycon.com/.
	EncToken() *string
	// An API authentication token that is generated when you sign up for the PallyCon service at https://login.pallycon.com/.
	SetEncToken(string) DrmSpec
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	Encryption() *string
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	SetEncryption(string) DrmSpec
	// Path to end user certificate file.
	EndUserCert() *string
	// Path to end user certificate file.
	SetEndUserCert(string) DrmSpec
	// Path to end user private key file
	EndUserPrivateKey() *string
	// Path to end user private key file
	SetEndUserPrivateKey(string) DrmSpec
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	Expires() *int
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	SetExpires(int) DrmSpec
	// Whether to use FairPlay system for key generation.
	// If set to `false`, the requests for FairPlay encryption key are disabled.
	Fp() *string
	// Whether to use FairPlay system for key generation.
	// If set to `false`, the requests for FairPlay encryption key are disabled.
	SetFp(string) DrmSpec
	// This parameter is used for encryption of HLS streams.
	// For successful playback of an AES128 encrypted HLS streams on some modern devices (running on Tizen 5),
	// set this pareameter to `false`.
	HlsExtXKeyIv() *bool
	// This parameter is used for encryption of HLS streams.
	// For successful playback of an AES128 encrypted HLS streams on some modern devices (running on Tizen 5),
	// set this pareameter to `false`.
	SetHlsExtXKeyIv(bool) DrmSpec
	// A hostname of Irdeto DRM key server.
	IcHost() *string
	// A hostname of Irdeto DRM key server.
	SetIcHost(string) DrmSpec
	// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
	// It is employed only one time in any session.
	// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
	// Usually, IV is received from a DRM provider.
	Iv() *string
	// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
	// It is employed only one time in any session.
	// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
	// Usually, IV is received from a DRM provider.
	SetIv(string) DrmSpec
	// Encryption Key in hex or file. Length must be 128 bit.
	// Example: 0x76359e1212952a6db42b41eeb94ceb29
	Key() *string
	// Encryption Key in hex or file. Length must be 128 bit.
	// Example: 0x76359e1212952a6db42b41eeb94ceb29
	SetKey(string) DrmSpec
	// An arbitrary Base64-encoded string of 30 bytes.
	// It is necessary for PlayReady to create an encryption key.
	Keyseed() *string
	// An arbitrary Base64-encoded string of 30 bytes.
	// It is necessary for PlayReady to create an encryption key.
	SetKeyseed(string) DrmSpec
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	Keyserver() *string
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	SetKeyserver(string) DrmSpec
	// License URL, used for PlayReady DRM.
	// Format: url (url)
	LaURL() *URL
	// License URL, used for PlayReady DRM.
	// Format: url (url)
	SetLaURL(URL) DrmSpec
	// Axinom Management Key
	ManagementKey() *string
	// Axinom Management Key
	SetManagementKey(string) DrmSpec
	// The uuid of the merchant at DRMtoday.
	MerchantID() *string
	// The uuid of the merchant at DRMtoday.
	SetMerchantID(string) DrmSpec
	// A password for API account./A password for authorization of a user on a key server.
	Password() *string
	// A password for API account./A password for authorization of a user on a key server.
	SetPassword(string) DrmSpec
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	ResourceID() *DrmResourceID
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	SetResourceID(DrmResourceID) DrmSpec
	// A part of the keyserver's URL: `https://SITE.solocoo.tv/SITEadmintools/papi/SECRET/method`.
	Secret() *string
	// A part of the keyserver's URL: `https://SITE.solocoo.tv/SITEadmintools/papi/SECRET/method`.
	SetSecret(string) DrmSpec
	// A unique ID of the signer.
	// Flussonic uses it to connect to the key server when using test key for Widevine DRM.
	Signer() *string
	// A unique ID of the signer.
	// Flussonic uses it to connect to the key server when using test key for Widevine DRM.
	SetSigner(string) DrmSpec
	// A part of the keyserver's URL: `https://SITE.solocoo.tv/SITEadmintools/papi/SECRET/method`.
	Site() *string
	// A part of the keyserver's URL: `https://SITE.solocoo.tv/SITEadmintools/papi/SECRET/method`.
	SetSite(string) DrmSpec
	// This parameter is used to specify applicable DRM systems.
	// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
	Systems() []DrmSystem
	// This parameter is used to specify applicable DRM systems.
	// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
	SetSystems([]DrmSystem) DrmSpec
	// Axinom Tenant Id
	TenantID() *string
	// Axinom Tenant Id
	SetTenantID(string) DrmSpec
	// Http link which specifies how to obtain the key. It is URI attribute of HLS manifest EXT-X-KEY method.
	URL() *string
	// Http link which specifies how to obtain the key. It is URI attribute of HLS manifest EXT-X-KEY method.
	SetURL(string) DrmSpec
	// A user name for authorization of a user on a key server.
	User() *string
	// A user name for authorization of a user on a key server.
	SetUser(string) DrmSpec
	// The URL sent to the client for watching the content.
	// Example: https://public-keyserver.mycompany.com
	UserKeyserver() *string
	// The URL sent to the client for watching the content.
	// Example: https://public-keyserver.mycompany.com
	SetUserKeyserver(string) DrmSpec
	// A user name of the Irdeto DRM user.
	UserName() *string
	// A user name of the Irdeto DRM user.
	SetUserName(string) DrmSpec
	// A custom key server path
	// Example: 12345/nks/conax
	UserPath() *string
	// A custom key server path
	// Example: 12345/nks/conax
	SetUserPath(string) DrmSpec
	// Deprecated field. Will be deleted at 25.04
	// A unique identifier of the user
	Userkey() *string
	// Deprecated field. Will be deleted at 25.04
	// A unique identifier of the user
	SetUserkey(string) DrmSpec
	// The login name of an API account.
	Username() *string
	// The login name of an API account.
	SetUsername(string) DrmSpec
	// FIXME: Aes128
	// /FIXME: Axinom
	// /BuyDRM
	// /Clear Key is a lightweight DRM mode, where decryption keys are provided directly to the player. Its easy to
	// integrate (simple JSON key/KID), requires minimal infrastructure, and can work via a license URL or with
	// client-embedded keys.
	// /FIXME: Conax
	// /FIXME: Cpix
	// /FIXME: DRMtoday
	// /FIXME: Ezdrm
	// /FIXME: Ezdrm classic
	// /FIXME: GS DRM
	// /FIXME: Irdeto
	// /KeyOs
	// /FIXME: Pallycon
	// /FIXME: Playready
	// /FIXME: Sample AES
	// /Sample AES which uses KEYFORMAT=identity. It allows to encrypt and decrypt content using clear text AES key.
	// The identity value for KEYFORMAT should be used only for testing.
	// /FIXME: Solocoo
	// /FIXME: Verimatrix
	// /FIXME: Widevine
	Vendor() string
	// FIXME: Aes128
	// /FIXME: Axinom
	// /BuyDRM
	// /Clear Key is a lightweight DRM mode, where decryption keys are provided directly to the player. Its easy to
	// integrate (simple JSON key/KID), requires minimal infrastructure, and can work via a license URL or with
	// client-embedded keys.
	// /FIXME: Conax
	// /FIXME: Cpix
	// /FIXME: DRMtoday
	// /FIXME: Ezdrm
	// /FIXME: Ezdrm classic
	// /FIXME: GS DRM
	// /FIXME: Irdeto
	// /KeyOs
	// /FIXME: Pallycon
	// /FIXME: Playready
	// /FIXME: Sample AES
	// /Sample AES which uses KEYFORMAT=identity. It allows to encrypt and decrypt content using clear text AES key.
	// The identity value for KEYFORMAT should be used only for testing.
	// /FIXME: Solocoo
	// /FIXME: Verimatrix
	// /FIXME: Widevine
	SetVendor(string) DrmSpec
}

type DrmSystems interface {
	// This parameter is used to specify applicable DRM systems.
	// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
	Systems() []DrmSystem
	// This parameter is used to specify applicable DRM systems.
	// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
	SetSystems([]DrmSystem) DrmSystems
}

type DrmVendorAes128 interface {
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	Encryption() *string
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	SetEncryption(string) DrmVendorAes128
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	Expires() *int
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	SetExpires(int) DrmVendorAes128
	// This parameter is used for encryption of HLS streams.
	// For successful playback of an AES128 encrypted HLS streams on some modern devices (running on Tizen 5),
	// set this pareameter to `false`.
	HlsExtXKeyIv() *bool
	// This parameter is used for encryption of HLS streams.
	// For successful playback of an AES128 encrypted HLS streams on some modern devices (running on Tizen 5),
	// set this pareameter to `false`.
	SetHlsExtXKeyIv(bool) DrmVendorAes128
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	Keyserver() *string
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	SetKeyserver(string) DrmVendorAes128
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	ResourceID() *DrmResourceID
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	SetResourceID(DrmResourceID) DrmVendorAes128
	// FIXME: Aes128
	Vendor() string
	// FIXME: Aes128
	SetVendor(string) DrmVendorAes128
}

type DrmVendorAxinom interface {
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	Encryption() *string
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	SetEncryption(string) DrmVendorAxinom
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	Expires() *int
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	SetExpires(int) DrmVendorAxinom
	// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
	// It is employed only one time in any session.
	// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
	// Usually, IV is received from a DRM provider.
	Iv() *string
	// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
	// It is employed only one time in any session.
	// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
	// Usually, IV is received from a DRM provider.
	SetIv(string) DrmVendorAxinom
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	Keyserver() *string
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	SetKeyserver(string) DrmVendorAxinom
	// Axinom Management Key
	ManagementKey() *string
	// Axinom Management Key
	SetManagementKey(string) DrmVendorAxinom
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	ResourceID() *DrmResourceID
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	SetResourceID(DrmResourceID) DrmVendorAxinom
	// This parameter is used to specify applicable DRM systems.
	// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
	Systems() []DrmSystem
	// This parameter is used to specify applicable DRM systems.
	// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
	SetSystems([]DrmSystem) DrmVendorAxinom
	// Axinom Tenant Id
	TenantID() *string
	// Axinom Tenant Id
	SetTenantID(string) DrmVendorAxinom
	// FIXME: Axinom
	Vendor() string
	// FIXME: Axinom
	SetVendor(string) DrmVendorAxinom
}

type DrmVendorBuydrm interface {
	// A unique identifier of the content, used for Widevine DRM.
	// By default, it is equal to the stream name.
	ContentID() *string
	// A unique identifier of the content, used for Widevine DRM.
	// By default, it is equal to the stream name.
	SetContentID(string) DrmVendorBuydrm
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	Encryption() *string
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	SetEncryption(string) DrmVendorBuydrm
	// Path to end user certificate file.
	EndUserCert() *string
	// Path to end user certificate file.
	SetEndUserCert(string) DrmVendorBuydrm
	// Path to end user private key file
	EndUserPrivateKey() *string
	// Path to end user private key file
	SetEndUserPrivateKey(string) DrmVendorBuydrm
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	Expires() *int
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	SetExpires(int) DrmVendorBuydrm
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	Keyserver() *string
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	SetKeyserver(string) DrmVendorBuydrm
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	ResourceID() *DrmResourceID
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	SetResourceID(DrmResourceID) DrmVendorBuydrm
	// Deprecated field. Will be deleted at 25.04
	// A unique identifier of the user
	Userkey() *string
	// Deprecated field. Will be deleted at 25.04
	// A unique identifier of the user
	SetUserkey(string) DrmVendorBuydrm
	// BuyDRM
	Vendor() string
	// BuyDRM
	SetVendor(string) DrmVendorBuydrm
}

type DrmVendorClearkey interface {
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	Encryption() *string
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	SetEncryption(string) DrmVendorClearkey
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	Expires() *int
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	SetExpires(int) DrmVendorClearkey
	// Encryption Key in hex or file. Length must be 128 bit.
	// Example: 0x76359e1212952a6db42b41eeb94ceb29
	Key() *string
	// Encryption Key in hex or file. Length must be 128 bit.
	// Example: 0x76359e1212952a6db42b41eeb94ceb29
	SetKey(string) DrmVendorClearkey
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	Keyserver() *string
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	SetKeyserver(string) DrmVendorClearkey
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	ResourceID() *DrmResourceID
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	SetResourceID(DrmResourceID) DrmVendorClearkey
	// Clear Key is a lightweight DRM mode, where decryption keys are provided directly to the player. Its easy to
	// integrate (simple JSON key/KID), requires minimal infrastructure, and can work via a license URL or with
	// client-embedded keys.
	Vendor() string
	// Clear Key is a lightweight DRM mode, where decryption keys are provided directly to the player. Its easy to
	// integrate (simple JSON key/KID), requires minimal infrastructure, and can work via a license URL or with
	// client-embedded keys.
	SetVendor(string) DrmVendorClearkey
}

type DrmVendorConax interface {
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	Encryption() *string
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	SetEncryption(string) DrmVendorConax
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	Expires() *int
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	SetExpires(int) DrmVendorConax
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	Keyserver() *string
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	SetKeyserver(string) DrmVendorConax
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	ResourceID() *DrmResourceID
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	SetResourceID(DrmResourceID) DrmVendorConax
	// This parameter is used to specify applicable DRM systems.
	// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
	Systems() []DrmSystem
	// This parameter is used to specify applicable DRM systems.
	// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
	SetSystems([]DrmSystem) DrmVendorConax
	// A custom key server path
	// Example: 12345/nks/conax
	UserPath() *string
	// A custom key server path
	// Example: 12345/nks/conax
	SetUserPath(string) DrmVendorConax
	// FIXME: Conax
	Vendor() string
	// FIXME: Conax
	SetVendor(string) DrmVendorConax
}

type DrmVendorCpix interface {
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	Encryption() *string
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	SetEncryption(string) DrmVendorCpix
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	Expires() *int
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	SetExpires(int) DrmVendorCpix
	// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
	// It is employed only one time in any session.
	// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
	// Usually, IV is received from a DRM provider.
	Iv() *string
	// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
	// It is employed only one time in any session.
	// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
	// Usually, IV is received from a DRM provider.
	SetIv(string) DrmVendorCpix
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	Keyserver() *string
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	SetKeyserver(string) DrmVendorCpix
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	ResourceID() *DrmResourceID
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	SetResourceID(DrmResourceID) DrmVendorCpix
	// This parameter is used to specify applicable DRM systems.
	// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
	Systems() []DrmSystem
	// This parameter is used to specify applicable DRM systems.
	// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
	SetSystems([]DrmSystem) DrmVendorCpix
	// FIXME: Cpix
	Vendor() string
	// FIXME: Cpix
	SetVendor(string) DrmVendorCpix
}

type DrmVendorDrmtoday interface {
	// Authentication server for DRMtoday.
	// Example: https://auth.drmtoday.com
	AuthServer() *string
	// Authentication server for DRMtoday.
	// Example: https://auth.drmtoday.com
	SetAuthServer(string) DrmVendorDrmtoday
	// The uuid of the CPIX/SPEKE ingest configuration
	CpixConfigID() *string
	// The uuid of the CPIX/SPEKE ingest configuration
	SetCpixConfigID(string) DrmVendorDrmtoday
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	Encryption() *string
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	SetEncryption(string) DrmVendorDrmtoday
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	Expires() *int
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	SetExpires(int) DrmVendorDrmtoday
	// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
	// It is employed only one time in any session.
	// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
	// Usually, IV is received from a DRM provider.
	Iv() *string
	// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
	// It is employed only one time in any session.
	// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
	// Usually, IV is received from a DRM provider.
	SetIv(string) DrmVendorDrmtoday
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	Keyserver() *string
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	SetKeyserver(string) DrmVendorDrmtoday
	// The uuid of the merchant at DRMtoday.
	MerchantID() *string
	// The uuid of the merchant at DRMtoday.
	SetMerchantID(string) DrmVendorDrmtoday
	// A password for API account.
	Password() *string
	// A password for API account.
	SetPassword(string) DrmVendorDrmtoday
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	ResourceID() *DrmResourceID
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	SetResourceID(DrmResourceID) DrmVendorDrmtoday
	// This parameter is used to specify applicable DRM systems.
	// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
	Systems() []DrmSystem
	// This parameter is used to specify applicable DRM systems.
	// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
	SetSystems([]DrmSystem) DrmVendorDrmtoday
	// The login name of an API account.
	Username() *string
	// The login name of an API account.
	SetUsername(string) DrmVendorDrmtoday
	// FIXME: DRMtoday
	Vendor() string
	// FIXME: DRMtoday
	SetVendor(string) DrmVendorDrmtoday
}

type DrmVendorEzdrm interface {
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	Encryption() *string
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	SetEncryption(string) DrmVendorEzdrm
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	Expires() *int
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	SetExpires(int) DrmVendorEzdrm
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	Keyserver() *string
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	SetKeyserver(string) DrmVendorEzdrm
	// A password for authorization of a user on a key server.
	Password() *string
	// A password for authorization of a user on a key server.
	SetPassword(string) DrmVendorEzdrm
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	ResourceID() *DrmResourceID
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	SetResourceID(DrmResourceID) DrmVendorEzdrm
	// A user name for authorization of a user on a key server.
	User() *string
	// A user name for authorization of a user on a key server.
	SetUser(string) DrmVendorEzdrm
	// FIXME: Ezdrm
	Vendor() string
	// FIXME: Ezdrm
	SetVendor(string) DrmVendorEzdrm
}

type DrmVendorEzdrmClassic interface {
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	Encryption() *string
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	SetEncryption(string) DrmVendorEzdrmClassic
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	Expires() *int
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	SetExpires(int) DrmVendorEzdrmClassic
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	Keyserver() *string
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	SetKeyserver(string) DrmVendorEzdrmClassic
	// A password for authorization of a user on a key server.
	Password() *string
	// A password for authorization of a user on a key server.
	SetPassword(string) DrmVendorEzdrmClassic
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	ResourceID() *DrmResourceID
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	SetResourceID(DrmResourceID) DrmVendorEzdrmClassic
	// A user name for authorization of a user on a key server.
	User() *string
	// A user name for authorization of a user on a key server.
	SetUser(string) DrmVendorEzdrmClassic
	// FIXME: Ezdrm classic
	Vendor() string
	// FIXME: Ezdrm classic
	SetVendor(string) DrmVendorEzdrmClassic
}

type DrmVendorGsdrm interface {
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	Encryption() *string
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	SetEncryption(string) DrmVendorGsdrm
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	Expires() *int
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	SetExpires(int) DrmVendorGsdrm
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	Keyserver() *string
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	SetKeyserver(string) DrmVendorGsdrm
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	ResourceID() *DrmResourceID
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	SetResourceID(DrmResourceID) DrmVendorGsdrm
	// FIXME: GS DRM
	Vendor() string
	// FIXME: GS DRM
	SetVendor(string) DrmVendorGsdrm
}

type DrmVendorIrdeto interface {
	// ID of the Irdeto DRM account.
	AccountID() *string
	// ID of the Irdeto DRM account.
	SetAccountID(string) DrmVendorIrdeto
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	Encryption() *string
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	SetEncryption(string) DrmVendorIrdeto
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	Expires() *int
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	SetExpires(int) DrmVendorIrdeto
	// A hostname of Irdeto DRM key server.
	IcHost() *string
	// A hostname of Irdeto DRM key server.
	SetIcHost(string) DrmVendorIrdeto
	// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
	// It is employed only one time in any session.
	// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
	// Usually, IV is received from a DRM provider.
	Iv() *string
	// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
	// It is employed only one time in any session.
	// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
	// Usually, IV is received from a DRM provider.
	SetIv(string) DrmVendorIrdeto
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	Keyserver() *string
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	SetKeyserver(string) DrmVendorIrdeto
	// A password for authorization of a user on a key server.
	Password() *string
	// A password for authorization of a user on a key server.
	SetPassword(string) DrmVendorIrdeto
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	ResourceID() *DrmResourceID
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	SetResourceID(DrmResourceID) DrmVendorIrdeto
	// This parameter is used to specify applicable DRM systems.
	// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
	Systems() []DrmSystem
	// This parameter is used to specify applicable DRM systems.
	// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
	SetSystems([]DrmSystem) DrmVendorIrdeto
	// A user name of the Irdeto DRM user.
	UserName() *string
	// A user name of the Irdeto DRM user.
	SetUserName(string) DrmVendorIrdeto
	// FIXME: Irdeto
	Vendor() string
	// FIXME: Irdeto
	SetVendor(string) DrmVendorIrdeto
}

type DrmVendorKeyos interface {
	// A unique identifier of the content, used for Widevine DRM.
	// By default, it is equal to the stream name.
	ContentID() *string
	// A unique identifier of the content, used for Widevine DRM.
	// By default, it is equal to the stream name.
	SetContentID(string) DrmVendorKeyos
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	Encryption() *string
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	SetEncryption(string) DrmVendorKeyos
	// Path to end user certificate file.
	EndUserCert() *string
	// Path to end user certificate file.
	SetEndUserCert(string) DrmVendorKeyos
	// Path to end user private key file
	EndUserPrivateKey() *string
	// Path to end user private key file
	SetEndUserPrivateKey(string) DrmVendorKeyos
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	Expires() *int
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	SetExpires(int) DrmVendorKeyos
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	Keyserver() *string
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	SetKeyserver(string) DrmVendorKeyos
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	ResourceID() *DrmResourceID
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	SetResourceID(DrmResourceID) DrmVendorKeyos
	// Deprecated field. Will be deleted at 25.04
	// A unique identifier of the user
	Userkey() *string
	// Deprecated field. Will be deleted at 25.04
	// A unique identifier of the user
	SetUserkey(string) DrmVendorKeyos
	// KeyOs
	Vendor() string
	// KeyOs
	SetVendor(string) DrmVendorKeyos
}

type DrmVendorPallycon interface {
	// An API authentication token that is generated when you sign up for the PallyCon service at https://login.pallycon.com/.
	EncToken() *string
	// An API authentication token that is generated when you sign up for the PallyCon service at https://login.pallycon.com/.
	SetEncToken(string) DrmVendorPallycon
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	Encryption() *string
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	SetEncryption(string) DrmVendorPallycon
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	Expires() *int
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	SetExpires(int) DrmVendorPallycon
	// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
	// It is employed only one time in any session.
	// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
	// Usually, IV is received from a DRM provider.
	Iv() *string
	// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
	// It is employed only one time in any session.
	// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
	// Usually, IV is received from a DRM provider.
	SetIv(string) DrmVendorPallycon
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	Keyserver() *string
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	SetKeyserver(string) DrmVendorPallycon
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	ResourceID() *DrmResourceID
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	SetResourceID(DrmResourceID) DrmVendorPallycon
	// This parameter is used to specify applicable DRM systems.
	// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
	Systems() []DrmSystem
	// This parameter is used to specify applicable DRM systems.
	// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
	SetSystems([]DrmSystem) DrmVendorPallycon
	// FIXME: Pallycon
	Vendor() string
	// FIXME: Pallycon
	SetVendor(string) DrmVendorPallycon
}

type DrmVendorPlayready interface {
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	Encryption() *string
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	SetEncryption(string) DrmVendorPlayready
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	Expires() *int
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	SetExpires(int) DrmVendorPlayready
	// An arbitrary Base64-encoded string of 30 bytes.
	// It is necessary for PlayReady to create an encryption key.
	Keyseed() *string
	// An arbitrary Base64-encoded string of 30 bytes.
	// It is necessary for PlayReady to create an encryption key.
	SetKeyseed(string) DrmVendorPlayready
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	Keyserver() *string
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	SetKeyserver(string) DrmVendorPlayready
	// License URL, used for PlayReady DRM.
	// Format: url (url)
	LaURL() *URL
	// License URL, used for PlayReady DRM.
	// Format: url (url)
	SetLaURL(URL) DrmVendorPlayready
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	ResourceID() *DrmResourceID
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	SetResourceID(DrmResourceID) DrmVendorPlayready
	// FIXME: Playready
	Vendor() string
	// FIXME: Playready
	SetVendor(string) DrmVendorPlayready
}

type DrmVendorSampleAes interface {
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	Encryption() *string
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	SetEncryption(string) DrmVendorSampleAes
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	Expires() *int
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	SetExpires(int) DrmVendorSampleAes
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	Keyserver() *string
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	SetKeyserver(string) DrmVendorSampleAes
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	ResourceID() *DrmResourceID
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	SetResourceID(DrmResourceID) DrmVendorSampleAes
	// FIXME: Sample AES
	Vendor() string
	// FIXME: Sample AES
	SetVendor(string) DrmVendorSampleAes
}

type DrmVendorSampleAesIdentity interface {
	// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
	// It is employed only one time in any session.
	// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
	// Usually, IV is received from a DRM provider.
	Iv() *string
	// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
	// It is employed only one time in any session.
	// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
	// Usually, IV is received from a DRM provider.
	SetIv(string) DrmVendorSampleAesIdentity
	// Encryption Key in hex or file. Length must be 128 bit.
	// Example: 0x76359e1212952a6db42b41eeb94ceb29
	Key() *string
	// Encryption Key in hex or file. Length must be 128 bit.
	// Example: 0x76359e1212952a6db42b41eeb94ceb29
	SetKey(string) DrmVendorSampleAesIdentity
	// Http link which specifies how to obtain the key. It is URI attribute of HLS manifest EXT-X-KEY method.
	URL() *string
	// Http link which specifies how to obtain the key. It is URI attribute of HLS manifest EXT-X-KEY method.
	SetURL(string) DrmVendorSampleAesIdentity
	// Sample AES which uses KEYFORMAT=identity. It allows to encrypt and decrypt content using clear text AES key.
	// The identity value for KEYFORMAT should be used only for testing.
	Vendor() string
	// Sample AES which uses KEYFORMAT=identity. It allows to encrypt and decrypt content using clear text AES key.
	// The identity value for KEYFORMAT should be used only for testing.
	SetVendor(string) DrmVendorSampleAesIdentity
}

type DrmVendorSolocoo interface {
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	Encryption() *string
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	SetEncryption(string) DrmVendorSolocoo
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	Expires() *int
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	SetExpires(int) DrmVendorSolocoo
	// Whether to use FairPlay system for key generation.
	// If set to `false`, the requests for FairPlay encryption key are disabled.
	Fp() *string
	// Whether to use FairPlay system for key generation.
	// If set to `false`, the requests for FairPlay encryption key are disabled.
	SetFp(string) DrmVendorSolocoo
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	Keyserver() *string
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	SetKeyserver(string) DrmVendorSolocoo
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	ResourceID() *DrmResourceID
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	SetResourceID(DrmResourceID) DrmVendorSolocoo
	// A part of the keyserver's URL: `https://SITE.solocoo.tv/SITEadmintools/papi/SECRET/method`.
	Secret() *string
	// A part of the keyserver's URL: `https://SITE.solocoo.tv/SITEadmintools/papi/SECRET/method`.
	SetSecret(string) DrmVendorSolocoo
	// A part of the keyserver's URL: `https://SITE.solocoo.tv/SITEadmintools/papi/SECRET/method`.
	Site() *string
	// A part of the keyserver's URL: `https://SITE.solocoo.tv/SITEadmintools/papi/SECRET/method`.
	SetSite(string) DrmVendorSolocoo
	// FIXME: Solocoo
	Vendor() string
	// FIXME: Solocoo
	SetVendor(string) DrmVendorSolocoo
}

type DrmVendorVerimatrix interface {
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	Encryption() *string
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	SetEncryption(string) DrmVendorVerimatrix
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	Expires() *int
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	SetExpires(int) DrmVendorVerimatrix
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	Keyserver() *string
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	SetKeyserver(string) DrmVendorVerimatrix
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	ResourceID() *DrmResourceID
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	SetResourceID(DrmResourceID) DrmVendorVerimatrix
	// The URL sent to the client for watching the content.
	// Example: https://public-keyserver.mycompany.com
	UserKeyserver() *string
	// The URL sent to the client for watching the content.
	// Example: https://public-keyserver.mycompany.com
	SetUserKeyserver(string) DrmVendorVerimatrix
	// FIXME: Verimatrix
	Vendor() string
	// FIXME: Verimatrix
	SetVendor(string) DrmVendorVerimatrix
}

type DrmVendorWidevine interface {
	// AES (Advanced Encryption Standard) key. Used for Widevine DRM.
	AesKey() *string
	// AES (Advanced Encryption Standard) key. Used for Widevine DRM.
	SetAesKey(string) DrmVendorWidevine
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	Encryption() *string
	// If this parameter is set to `full`, all frames are encrypted.
	// If it is set to `sparse` (or empty), only the keyframes are encrypted.
	// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
	// It also reduces the power consumption, when decrypting on the client side.
	// However, some Smart TVs and STBs require all frames to be encrypted.
	SetEncryption(string) DrmVendorWidevine
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	Expires() *int
	// Key rotation interval, in minutes.
	// By default, Flussonic does not rotate enryption keys.
	// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
	SetExpires(int) DrmVendorWidevine
	// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
	// It is employed only one time in any session.
	// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
	// Usually, IV is received from a DRM provider.
	Iv() *string
	// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
	// It is employed only one time in any session.
	// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
	// Usually, IV is received from a DRM provider.
	SetIv(string) DrmVendorWidevine
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	Keyserver() *string
	// DRM key server.
	// Example: https://keyserver1.mycompany.com
	SetKeyserver(string) DrmVendorWidevine
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	ResourceID() *DrmResourceID
	// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
	// The DRM system keeps track of viewing each resource by clients.
	// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
	// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
	// Format: drm_resource_id (drm_resource_id)
	// Example: L2sItm6
	SetResourceID(DrmResourceID) DrmVendorWidevine
	// A unique ID of the signer.
	// Flussonic uses it to connect to the key server when using test key for Widevine DRM.
	Signer() *string
	// A unique ID of the signer.
	// Flussonic uses it to connect to the key server when using test key for Widevine DRM.
	SetSigner(string) DrmVendorWidevine
	// FIXME: Widevine
	Vendor() string
	// FIXME: Widevine
	SetVendor(string) DrmVendorWidevine
}

// Required: name
type DvbCardConfig interface {
	// Adapter number.
	// Example: 16
	Adapter() *int
	// Adapter number.
	// Example: 16
	SetAdapter(int) DvbCardConfig
	// Attenuation of the signal level. Takes values from 0 to 10.
	Attenuator() *int
	// Attenuation of the signal level. Takes values from 0 to 10.
	SetAttenuator(int) DvbCardConfig
	// Bandwidth, in Hz.
	// Example: 6e+06
	Bandwidth() *int
	// Bandwidth, in Hz.
	// Example: 6e+06
	SetBandwidth(int) DvbCardConfig
	// High priority stream code rate.
	CodeRateHp() *DvbFec
	// High priority stream code rate.
	SetCodeRateHp(DvbFec) DvbCardConfig
	// Low priority stream code rate.
	CodeRateLp() *DvbFec
	// Low priority stream code rate.
	SetCodeRateLp(DvbFec) DvbCardConfig
	// Any text comment.
	Comment() *string
	// Any text comment.
	SetComment(string) DvbCardConfig
	// Max source's internal clock drift to compensate, rounding to six decimal places.
	CompensateTimeDriftPpm() *int
	// Max source's internal clock drift to compensate, rounding to six decimal places.
	SetCompensateTimeDriftPpm(int) DvbCardConfig
	// Modulator number in adapter.
	Device() *int
	// Modulator number in adapter.
	SetDevice(int) DvbCardConfig
	// Whether this DVB card is disabled.
	// Example: false
	Disabled() *bool
	// Whether this DVB card is disabled.
	// Example: false
	SetDisabled(bool) DvbCardConfig
	// The carrier frequency of the transponder for this channel, in Hz.
	// Example: 11606
	Frequency() *int
	// The carrier frequency of the transponder for this channel, in Hz.
	// Example: 11606
	SetFrequency(int) DvbCardConfig
	// Frontend number.
	Frontend() *int
	// Frontend number.
	SetFrontend(int) DvbCardConfig
	// Adjust the output gain to the specified value in dB.
	Gain() *int
	// Adjust the output gain to the specified value in dB.
	SetGain(int) DvbCardConfig
	// The mode of inserting a guard interval - a padding separating transmissions so that they do not interfere with each other.
	// Example: 1_16
	GuardInterval() *string
	// The mode of inserting a guard interval - a padding separating transmissions so that they do not interfere with each other.
	// Example: 1_16
	SetGuardInterval(string) DvbCardConfig
	// Constellation ratio for hierarchical transmission.
	Hierarchy() *string
	// Constellation ratio for hierarchical transmission.
	SetHierarchy(string) DvbCardConfig
	// Whether high frequency band is used.
	HighBand() *bool
	// Whether high frequency band is used.
	SetHighBand(bool) DvbCardConfig
	// Adapter card hardware type.
	// Example: dvb
	Hw() *string
	// Adapter card hardware type.
	// Example: dvb
	SetHw(string) DvbCardConfig
	// Input bitrate, in Mbps.
	InputBitrate() *int
	// Input bitrate, in Mbps.
	SetInputBitrate(int) DvbCardConfig
	// Base frequency, in MHz.
	IntFreq() *int
	// Base frequency, in MHz.
	SetIntFreq(int) DvbCardConfig
	// Use interleaver.
	// The interlaver disperses sequence of bits in bit stream to minimize effect of burst errors during transmission.
	Interleave() *int
	// Use interleaver.
	// The interlaver disperses sequence of bits in bit stream to minimize effect of burst errors during transmission.
	SetInterleave(int) DvbCardConfig
	// DVB-C modulation method.
	// Example: auto
	Modulation() *string
	// DVB-C modulation method.
	// Example: auto
	SetModulation(string) DvbCardConfig
	// DVB card name.
	// Format: dvb_card_name (dvb_card_name)
	// Example: a16
	Name() DvbCardName
	// DVB card name.
	// Format: dvb_card_name (dvb_card_name)
	// Example: a16
	SetName(DvbCardName) DvbCardConfig
	// Enable, disable, or autodetect pilot tones.
	// Example: auto
	Pilot() *string
	// Enable, disable, or autodetect pilot tones.
	// Example: auto
	SetPilot(string) DvbCardConfig
	// PLP stream selector. Used in DVB-T2.
	PlpStreamID() *int
	// PLP stream selector. Used in DVB-T2.
	SetPlpStreamID(int) DvbCardConfig
	// Polarization of the transponder for this channel.
	// The supported values are:
	// * `v`- vertical linear polarization,
	// * `h` - horizontal linear polarization,
	// * `r` - right-hand circular polarization,
	// * `l` - left-hand circular polarization.
	// Example: v
	Polarization() *string
	// Polarization of the transponder for this channel.
	// The supported values are:
	// * `v`- vertical linear polarization,
	// * `h` - horizontal linear polarization,
	// * `r` - right-hand circular polarization,
	// * `l` - left-hand circular polarization.
	// Example: v
	SetPolarization(string) DvbCardConfig
	// Port number, used for capturing from DekTec ASI cards.
	Port() *int
	// Port number, used for capturing from DekTec ASI cards.
	SetPort(int) DvbCardConfig
	// Rolloff factor, in %.
	// It is used to estimate bandwidth, together with symbol rate.
	Rolloff() *string
	// Rolloff factor, in %.
	// It is used to estimate bandwidth, together with symbol rate.
	SetRolloff(string) DvbCardConfig
	// Serial number of the card, used for capturing from DekTec ASI cards.
	Serial() *int
	// Serial number of the card, used for capturing from DekTec ASI cards.
	SetSerial(int) DvbCardConfig
	// Statistic information about the captured signal.
	Stats() DvbCardStats
	// Statistic information about the captured signal.
	SetStats(DvbCardStats) DvbCardConfig
	// The symbol rate of the transponder, in symbols per second.
	// A symbol is a pulse in digital baseband transmission.
	// Example: 27500
	SymbolRate() *int
	// The symbol rate of the transponder, in symbols per second.
	// A symbol is a pulse in digital baseband transmission.
	// Example: 27500
	SetSymbolRate(int) DvbCardConfig
	// Adapter type. Different systems are supported besides DVB, as the configuring is similar.
	System() *string
	// Adapter type. Different systems are supported besides DVB, as the configuring is similar.
	SetSystem(string) DvbCardConfig
	// DVB transmission mode.
	TransmissionMode() *string
	// DVB transmission mode.
	SetTransmissionMode(string) DvbCardConfig
	// The video device to capture video from Stream Labs SDI/ASI cards.
	// It is actually a path to a device file created on the disk by Video4Linux.
	// Example: /dev/video0
	VideoDevice() *string
	// The video device to capture video from Stream Labs SDI/ASI cards.
	// It is actually a path to a device file created on the disk by Video4Linux.
	// Example: /dev/video0
	SetVideoDevice(string) DvbCardConfig
}

type DvbCardStats interface {
	// Bit error rate. It is the percent of bit errors from total number of transferred bits.
	// Example: 5
	Ber() *int
	// Bit error rate. It is the percent of bit errors from total number of transferred bits.
	// Example: 5
	SetBer(int) DvbCardStats
	// Carrier detected in signal.
	// Example: true
	HasCarrier() *bool
	// Carrier detected in signal.
	// Example: true
	SetHasCarrier(bool) DvbCardStats
	// DVB signal was successfully locked.
	// Example: true
	HasLock() *bool
	// DVB signal was successfully locked.
	// Example: true
	SetHasLock(bool) DvbCardStats
	// Input rate is sufficient (900 bps or greater). Used for capturing from DekTec ASI cards.
	// Example: true
	HasRate() *bool
	// Input rate is sufficient (900 bps or greater). Used for capturing from DekTec ASI cards.
	// Example: true
	SetHasRate(bool) DvbCardStats
	// The frontend was reinitialized, the application is recommended to reset DiSEqC, tone and parameters.
	// Example: false
	HasReinit() *bool
	// The frontend was reinitialized, the application is recommended to reset DiSEqC, tone and parameters.
	// Example: false
	SetHasReinit(bool) DvbCardStats
	// Whether a signal is detected above the normal noise level.
	// Example: true
	HasSignal() *bool
	// Whether a signal is detected above the normal noise level.
	// Example: true
	SetHasSignal(bool) DvbCardStats
	// Synchronization bytes detected.
	// Example: true
	HasSync() *bool
	// Synchronization bytes detected.
	// Example: true
	SetHasSync(bool) DvbCardStats
	// The signal was not locked within the last about 2 seconds.
	// Example: false
	HasTimedout() *bool
	// The signal was not locked within the last about 2 seconds.
	// Example: false
	SetHasTimedout(bool) DvbCardStats
	// DVB signal was locked at Viterbi decoder stage.
	// Example: true
	HasViterbi() *bool
	// DVB signal was locked at Viterbi decoder stage.
	// Example: true
	SetHasViterbi(bool) DvbCardStats
	// Signal-noise ratio, in percent. It is the ratio of signal power to the noise power.
	// Example: 1
	Snr() *int
	// Signal-noise ratio, in percent. It is the ratio of signal power to the noise power.
	// Example: 1
	SetSnr(int) DvbCardStats
	// Signal-noise ratio, as a raw 16-bit number received from DVB API. It is the ratio of signal power to the noise power.
	// Example: 894
	SnrRaw() *int
	// Signal-noise ratio, as a raw 16-bit number received from DVB API. It is the ratio of signal power to the noise power.
	// Example: 894
	SetSnrRaw(int) DvbCardStats
	// Signal strength, in percent.
	// Example: 95
	Strength() *int
	// Signal strength, in percent.
	// Example: 95
	SetStrength(int) DvbCardStats
	// Signal strength, as a raw 16-bit number received from DVB API.
	// Example: 62446
	StrengthRaw() *int
	// Signal strength, as a raw 16-bit number received from DVB API.
	// Example: 62446
	SetStrengthRaw(int) DvbCardStats
}

type DvrBaseConfig interface {
	// Maximum disk consumption in percents. When this limit is reached,
	// the oldest segment of the recording will be overridden by later data.
	// It important to understand that this is not a "per-stream" option, this option means
	// that cleaning of this stream will be triggered if overall disk usage reaches this number.
	// If you have all streams with configuration 98% and one stream with 95%, it will be permanently
	// empty.
	// Format: percent (percent)
	// Example: 98
	DiskUsageLimit() *Percent
	// Maximum disk consumption in percents. When this limit is reached,
	// the oldest segment of the recording will be overridden by later data.
	// It important to understand that this is not a "per-stream" option, this option means
	// that cleaning of this stream will be triggered if overall disk usage reaches this number.
	// If you have all streams with configuration 98% and one stream with 95%, it will be permanently
	// empty.
	// Format: percent (percent)
	// Example: 98
	SetDiskUsageLimit(Percent) DvrBaseConfig
	// Additional archive depth in seconds for episodes. If set, episodes and their corresponding DVR record
	// will be saved for `expiration + episodes_expiration` seconds.
	// The archive clean-up within `[expiration, expiration+episodes_expiration]` seconds of the
	// recording performed depending on [external_episodes_list](https://flussonic.com/doc/api/config-external/#tag/dvr/operation/external_episodes_list)
	// response of `episodes_url`.
	// Anything older than `expiration+episodes_expiration` seconds will
	// be cleaned even if `episodes_url` does not respond.
	// Format: seconds (seconds)
	// Examples: 6.048e+06
	EpisodesExpiration() *Seconds
	// Additional archive depth in seconds for episodes. If set, episodes and their corresponding DVR record
	// will be saved for `expiration + episodes_expiration` seconds.
	// The archive clean-up within `[expiration, expiration+episodes_expiration]` seconds of the
	// recording performed depending on [external_episodes_list](https://flussonic.com/doc/api/config-external/#tag/dvr/operation/external_episodes_list)
	// response of `episodes_url`.
	// Anything older than `expiration+episodes_expiration` seconds will
	// be cleaned even if `episodes_url` does not respond.
	// Format: seconds (seconds)
	// Examples: 6.048e+06
	SetEpisodesExpiration(Seconds) DvrBaseConfig
	// Archive depth - a period (in seconds) back from the current moment during which the
	// contigious part of archive is stored.
	// As time goes, the parts of the recording which are older than the archive depth are deleted.
	// If you have option `episodes_expiration` enabled, then some parts of DVR that are
	// locked by episode signalling mechanism may be kept more than this `expiration` depth.
	// If `episodes_url` does not respond, the archive clean-up by `expiration` is not performed;
	// only the archive with expired episodes (`episodes_expiration`) is cleaned up until the `episodes_url` restores.
	// Format: seconds (seconds)
	// Examples: 604800
	Expiration() *Seconds
	// Archive depth - a period (in seconds) back from the current moment during which the
	// contigious part of archive is stored.
	// As time goes, the parts of the recording which are older than the archive depth are deleted.
	// If you have option `episodes_expiration` enabled, then some parts of DVR that are
	// locked by episode signalling mechanism may be kept more than this `expiration` depth.
	// If `episodes_url` does not respond, the archive clean-up by `expiration` is not performed;
	// only the archive with expired episodes (`episodes_expiration`) is cleaned up until the `episodes_url` restores.
	// Format: seconds (seconds)
	// Examples: 604800
	SetExpiration(Seconds) DvrBaseConfig
	// Maximum disk consumption in bytes. When this limit is reached,
	// the oldest segment of the recording will be overridden by later data.
	// This option affects both continuous recording and locked episodes (see `episodes_url`).
	// If `episodes_url` does not respond, the archive clean-up by `storage_limit` is not performed
	// to avoid deleting the recordings that should not be deleted.
	// Format: bytes (bytes)
	// Example: 4e+11
	StorageLimit() *Bytes
	// Maximum disk consumption in bytes. When this limit is reached,
	// the oldest segment of the recording will be overridden by later data.
	// This option affects both continuous recording and locked episodes (see `episodes_url`).
	// If `episodes_url` does not respond, the archive clean-up by `storage_limit` is not performed
	// to avoid deleting the recordings that should not be deleted.
	// Format: bytes (bytes)
	// Example: 4e+11
	SetStorageLimit(Bytes) DvrBaseConfig
}

// This list of stats can be used to monitor health of invidiual disk in storage.
// There are several layers of indexes in internal database, here you can validate
// integrity of data.
type DvrCapacityStats interface {
	// The number of blobs on the disk that are enlisted in individual stream indexes.
	// It must be equal to blobs_count_db and can be different in case of software
	// or hardware errors.
	BlobsCount() *int
	// The number of blobs on the disk that are enlisted in individual stream indexes.
	// It must be equal to blobs_count_db and can be different in case of software
	// or hardware errors.
	SetBlobsCount(int) DvrCapacityStats
	// The number of blobs on the disk according to centralized Raid DB that is
	// used to allocate blobs across whole storage.
	BlobsCountDb() *int
	// The number of blobs on the disk according to centralized Raid DB that is
	// used to allocate blobs across whole storage.
	SetBlobsCountDb(int) DvrCapacityStats
	// Disk capacity in bytes.
	// Format: bytes (bytes)
	Size() *Bytes
	// Disk capacity in bytes.
	// Format: bytes (bytes)
	SetSize(Bytes) DvrCapacityStats
	// Disk utilization percentage.
	// Format: percent (percent)
	Usage() *Percent
	// Disk utilization percentage.
	// Format: percent (percent)
	SetUsage(Percent) DvrCapacityStats
	// Used disk space in bytes according to linux metrics. It must be equal (almost equal) to
	// `used_index`. If it differs more than in 1%, then it means that there are lot of unknown files.
	// If this disk is used exclusively for Raid, then it may mean that some blobs are lost from
	// database and repairing is required.
	// Format: bytes (bytes)
	Used() *Bytes
	// Used disk space in bytes according to linux metrics. It must be equal (almost equal) to
	// `used_index`. If it differs more than in 1%, then it means that there are lot of unknown files.
	// If this disk is used exclusively for Raid, then it may mean that some blobs are lost from
	// database and repairing is required.
	// Format: bytes (bytes)
	SetUsed(Bytes) DvrCapacityStats
	// Used disk space in bytes according to internal database index.
	// Format: bytes (bytes)
	UsedIndex() *Bytes
	// Used disk space in bytes according to internal database index.
	// Format: bytes (bytes)
	SetUsedIndex(Bytes) DvrCapacityStats
}

type DvrConfig interface {
	// The number of disks to write the archive.
	Active() *int
	// The number of disks to write the archive.
	SetActive(int) DvrConfig
	// Maximum disk consumption in percents. When this limit is reached,
	// the oldest segment of the recording will be overridden by later data.
	// It important to understand that this is not a "per-stream" option, this option means
	// that cleaning of this stream will be triggered if overall disk usage reaches this number.
	// If you have all streams with configuration 98% and one stream with 95%, it will be permanently
	// empty.
	// Format: percent (percent)
	// Example: 98
	DiskUsageLimit() *Percent
	// Maximum disk consumption in percents. When this limit is reached,
	// the oldest segment of the recording will be overridden by later data.
	// It important to understand that this is not a "per-stream" option, this option means
	// that cleaning of this stream will be triggered if overall disk usage reaches this number.
	// If you have all streams with configuration 98% and one stream with 95%, it will be permanently
	// empty.
	// Format: percent (percent)
	// Example: 98
	SetDiskUsageLimit(Percent) DvrConfig
	// RAID disks mounted on the server.
	Disks() []RaidDiskConfig
	// RAID disks mounted on the server.
	SetDisks([]RaidDiskConfig) DvrConfig
	// Additional archive depth in seconds for episodes. If set, episodes and their corresponding DVR record
	// will be saved for `expiration + episodes_expiration` seconds.
	// The archive clean-up within `[expiration, expiration+episodes_expiration]` seconds of the
	// recording performed depending on [external_episodes_list](https://flussonic.com/doc/api/config-external/#tag/dvr/operation/external_episodes_list)
	// response of `episodes_url`.
	// Anything older than `expiration+episodes_expiration` seconds will
	// be cleaned even if `episodes_url` does not respond.
	// Format: seconds (seconds)
	// Examples: 6.048e+06
	EpisodesExpiration() *Seconds
	// Additional archive depth in seconds for episodes. If set, episodes and their corresponding DVR record
	// will be saved for `expiration + episodes_expiration` seconds.
	// The archive clean-up within `[expiration, expiration+episodes_expiration]` seconds of the
	// recording performed depending on [external_episodes_list](https://flussonic.com/doc/api/config-external/#tag/dvr/operation/external_episodes_list)
	// response of `episodes_url`.
	// Anything older than `expiration+episodes_expiration` seconds will
	// be cleaned even if `episodes_url` does not respond.
	// Format: seconds (seconds)
	// Examples: 6.048e+06
	SetEpisodesExpiration(Seconds) DvrConfig
	// Archive depth - a period (in seconds) back from the current moment during which the
	// contigious part of archive is stored.
	// As time goes, the parts of the recording which are older than the archive depth are deleted.
	// If you have option `episodes_expiration` enabled, then some parts of DVR that are
	// locked by episode signalling mechanism may be kept more than this `expiration` depth.
	// If `episodes_url` does not respond, the archive clean-up by `expiration` is not performed;
	// only the archive with expired episodes (`episodes_expiration`) is cleaned up until the `episodes_url` restores.
	// Format: seconds (seconds)
	// Examples: 604800
	Expiration() *Seconds
	// Archive depth - a period (in seconds) back from the current moment during which the
	// contigious part of archive is stored.
	// As time goes, the parts of the recording which are older than the archive depth are deleted.
	// If you have option `episodes_expiration` enabled, then some parts of DVR that are
	// locked by episode signalling mechanism may be kept more than this `expiration` depth.
	// If `episodes_url` does not respond, the archive clean-up by `expiration` is not performed;
	// only the archive with expired episodes (`episodes_expiration`) is cleaned up until the `episodes_url` restores.
	// Format: seconds (seconds)
	// Examples: 604800
	SetExpiration(Seconds) DvrConfig
	// A directory on an SSD disk where the data will be cached.
	// Format: disk_path (disk_path)
	Index() *DiskPath
	// A directory on an SSD disk where the data will be cached.
	// Format: disk_path (disk_path)
	SetIndex(DiskPath) DvrConfig
	// DVR configuration name.
	// Format: dvr_name (dvr_name)
	Name() DvrName
	// DVR configuration name.
	// Format: dvr_name (dvr_name)
	SetName(DvrName) DvrConfig
	// This value is present if RAID (redundant array of independent disks) is enabled. Learn more in [Flussonic RAID for DVR](https://flussonic.com/doc/extend-video-storage-on-fly/).
	Raid() *DvrRaidLevel
	// This value is present if RAID (redundant array of independent disks) is enabled. Learn more in [Flussonic RAID for DVR](https://flussonic.com/doc/extend-video-storage-on-fly/).
	SetRaid(DvrRaidLevel) DvrConfig
	// A path where the DVR archive is stored.
	// Format: dvr_url (dvr_url)
	Root() DvrURL
	// A path where the DVR archive is stored.
	// Format: dvr_url (dvr_url)
	SetRoot(DvrURL) DvrConfig
	// The runtime statistics about DVR.
	Stats() DvrStorageConfigStats
	// The runtime statistics about DVR.
	SetStats(DvrStorageConfigStats) DvrConfig
	// Maximum disk consumption in bytes. When this limit is reached,
	// the oldest segment of the recording will be overridden by later data.
	// This option affects both continuous recording and locked episodes (see `episodes_url`).
	// If `episodes_url` does not respond, the archive clean-up by `storage_limit` is not performed
	// to avoid deleting the recordings that should not be deleted.
	// Format: bytes (bytes)
	// Example: 4e+11
	StorageLimit() *Bytes
	// Maximum disk consumption in bytes. When this limit is reached,
	// the oldest segment of the recording will be overridden by later data.
	// This option affects both continuous recording and locked episodes (see `episodes_url`).
	// If `episodes_url` does not respond, the archive clean-up by `storage_limit` is not performed
	// to avoid deleting the recordings that should not be deleted.
	// Format: bytes (bytes)
	// Example: 4e+11
	SetStorageLimit(Bytes) DvrConfig
}

// Required: from, depth, ranges
type DvrInfo interface {
	// The size of the recorded archive.
	// Format: bytes (bytes)
	// Example: 1.296e+11
	Bytes() *Bytes
	// The size of the recorded archive.
	// Format: bytes (bytes)
	// Example: 1.296e+11
	SetBytes(Bytes) DvrInfo
	// The time interval between the start of the *first* recording segment and the end of the *last* one.
	// Format: seconds (seconds)
	// Example: 259200
	Depth() Seconds
	// The time interval between the start of the *first* recording segment and the end of the *last* one.
	// Format: seconds (seconds)
	// Example: 259200
	SetDepth(Seconds) DvrInfo
	// Deprecated field. Will be deleted at 25.07
	// The size of the recorded archive. Please, use bytes instead.
	// Format: bytes (bytes)
	// Example: 1.099511627776e+12
	DiskSize() *Bytes
	// Deprecated field. Will be deleted at 25.07
	// The size of the recorded archive. Please, use bytes instead.
	// Format: bytes (bytes)
	// Example: 1.099511627776e+12
	SetDiskSize(Bytes) DvrInfo
	// A total duration of the recorded segments, excluding recording gaps.
	// It can be smaller than depth if you have gaps.
	// Format: seconds (seconds)
	// Example: 172800
	Duration() *Seconds
	// A total duration of the recorded segments, excluding recording gaps.
	// It can be smaller than depth if you have gaps.
	// Format: seconds (seconds)
	// Example: 172800
	SetDuration(Seconds) DvrInfo
	// The UTC timestamp of the first recording in this archive.
	// Format: utc (Unix timestamp in seconds)
	// Example: 1.641045644e+09
	From() Utc
	// The UTC timestamp of the first recording in this archive.
	// Format: utc (Unix timestamp in seconds)
	// Example: 1.641045644e+09
	SetFrom(Utc) DvrInfo
	// Deprecated field. Will be deleted at 24.09
	// The list of DVR ranges. The param is replaced with `ranges_list` method.
	Ranges() []DvrRange
	// Deprecated field. Will be deleted at 24.09
	// The list of DVR ranges. The param is replaced with `ranges_list` method.
	SetRanges([]DvrRange) DvrInfo
}

type DvrRange interface {
	// The the of the last recorded data.
	// Please notice that closed_at could be changed. There are two reasons.
	// - Cleaner process reduced data. Read [more](https://flussonic.com/doc/api/reference/#tag/stream/operation/stream_get/response%7Cdvr%7Cepisodes_url).
	// - Recording is still working. Near real-time value means that DVR is active at the moment.
	// This is a replacement for `duration` field
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	ClosedAt() *UtcMs
	// The the of the last recorded data.
	// Please notice that closed_at could be changed. There are two reasons.
	// - Cleaner process reduced data. Read [more](https://flussonic.com/doc/api/reference/#tag/stream/operation/stream_get/response%7Cdvr%7Cepisodes_url).
	// - Recording is still working. Near real-time value means that DVR is active at the moment.
	// This is a replacement for `duration` field
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetClosedAt(UtcMs) DvrRange
	// Deprecated field. Will be deleted at 24.11
	// The duration of the recorded DVR range.
	// Use closed_at instead of this field.
	// Format: seconds (seconds)
	// Example: 28800
	Duration() *Seconds
	// Deprecated field. Will be deleted at 24.11
	// The duration of the recorded DVR range.
	// Use closed_at instead of this field.
	// Format: seconds (seconds)
	// Example: 28800
	SetDuration(Seconds) DvrRange
	// Deprecated field. Will be deleted at 24.11
	// The beginning of the recorded DVR range. Use opened_at instead.
	// Mention that opened_at has milliseconds
	// Format: utc (Unix timestamp in seconds)
	// Example: 1.525186456e+09
	From() *Utc
	// Deprecated field. Will be deleted at 24.11
	// The beginning of the recorded DVR range. Use opened_at instead.
	// Mention that opened_at has milliseconds
	// Format: utc (Unix timestamp in seconds)
	// Example: 1.525186456e+09
	SetFrom(Utc) DvrRange
	// The time when this range was started. Naming is standard for whole flussonic ecosystem.
	// Is a replacement for field `from`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	OpenedAt() *UtcMs
	// The time when this range was started. Naming is standard for whole flussonic ecosystem.
	// Is a replacement for field `from`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetOpenedAt(UtcMs) DvrRange
}

// Required: name, root
type DvrStorageConfig interface {
	// The number of disks to write the archive.
	Active() *int
	// The number of disks to write the archive.
	SetActive(int) DvrStorageConfig
	// RAID disks mounted on the server.
	Disks() []RaidDiskConfig
	// RAID disks mounted on the server.
	SetDisks([]RaidDiskConfig) DvrStorageConfig
	// A directory on an SSD disk where the data will be cached.
	// Format: disk_path (disk_path)
	Index() *DiskPath
	// A directory on an SSD disk where the data will be cached.
	// Format: disk_path (disk_path)
	SetIndex(DiskPath) DvrStorageConfig
	// DVR configuration name.
	// Format: dvr_name (dvr_name)
	Name() DvrName
	// DVR configuration name.
	// Format: dvr_name (dvr_name)
	SetName(DvrName) DvrStorageConfig
	// This value is present if RAID (redundant array of independent disks) is enabled. Learn more in [Flussonic RAID for DVR](https://flussonic.com/doc/extend-video-storage-on-fly/).
	Raid() *DvrRaidLevel
	// This value is present if RAID (redundant array of independent disks) is enabled. Learn more in [Flussonic RAID for DVR](https://flussonic.com/doc/extend-video-storage-on-fly/).
	SetRaid(DvrRaidLevel) DvrStorageConfig
	// A path where the DVR archive is stored.
	// Format: dvr_url (dvr_url)
	Root() DvrURL
	// A path where the DVR archive is stored.
	// Format: dvr_url (dvr_url)
	SetRoot(DvrURL) DvrStorageConfig
	// The runtime statistics about DVR.
	Stats() DvrStorageConfigStats
	// The runtime statistics about DVR.
	SetStats(DvrStorageConfigStats) DvrStorageConfig
}

// The runtime statistics about DVR.
type DvrStorageConfigStats interface {
	// The number of blobs on the disk that are enlisted in individual stream indexes.
	// It must be equal to blobs_count_db and can be different in case of software
	// or hardware errors.
	BlobsCount() *int
	// The number of blobs on the disk that are enlisted in individual stream indexes.
	// It must be equal to blobs_count_db and can be different in case of software
	// or hardware errors.
	SetBlobsCount(int) DvrStorageConfigStats
	// The number of blobs on the disk according to centralized Raid DB that is
	// used to allocate blobs across whole storage.
	BlobsCountDb() *int
	// The number of blobs on the disk according to centralized Raid DB that is
	// used to allocate blobs across whole storage.
	SetBlobsCountDb(int) DvrStorageConfigStats
	// The runtime DVR errors.
	Errors() DvrStorageErrors
	// The runtime DVR errors.
	SetErrors(DvrStorageErrors) DvrStorageConfigStats
	// Disk capacity in bytes.
	// Format: bytes (bytes)
	Size() *Bytes
	// Disk capacity in bytes.
	// Format: bytes (bytes)
	SetSize(Bytes) DvrStorageConfigStats
	// Disk utilization percentage.
	// Format: percent (percent)
	Usage() *Percent
	// Disk utilization percentage.
	// Format: percent (percent)
	SetUsage(Percent) DvrStorageConfigStats
	// Used disk space in bytes according to linux metrics. It must be equal (almost equal) to
	// `used_index`. If it differs more than in 1%, then it means that there are lot of unknown files.
	// If this disk is used exclusively for Raid, then it may mean that some blobs are lost from
	// database and repairing is required.
	// Format: bytes (bytes)
	Used() *Bytes
	// Used disk space in bytes according to linux metrics. It must be equal (almost equal) to
	// `used_index`. If it differs more than in 1%, then it means that there are lot of unknown files.
	// If this disk is used exclusively for Raid, then it may mean that some blobs are lost from
	// database and repairing is required.
	// Format: bytes (bytes)
	SetUsed(Bytes) DvrStorageConfigStats
	// Used disk space in bytes according to internal database index.
	// Format: bytes (bytes)
	UsedIndex() *Bytes
	// Used disk space in bytes according to internal database index.
	// Format: bytes (bytes)
	SetUsedIndex(Bytes) DvrStorageConfigStats
}

type DvrStorageErrors interface {
	// Total number of collapsed segments while writing to the archive. Collapsed segments are pack of segments written together occur due to lack of storage performance.
	CollapsedWriteCount() *int
	// Total number of collapsed segments while writing to the archive. Collapsed segments are pack of segments written together occur due to lack of storage performance.
	SetCollapsedWriteCount(int) DvrStorageErrors
	// Total number of errors while deleting from the archive.
	DeleteErrors() *int
	// Total number of errors while deleting from the archive.
	SetDeleteErrors(int) DvrStorageErrors
	// Total number of dropped segments while writing to the archive.
	DropWriteCount() *int
	// Total number of dropped segments while writing to the archive.
	SetDropWriteCount(int) DvrStorageErrors
	// Total number of errors while reading the archive.
	ReadErrors() *int
	// Total number of errors while reading the archive.
	SetReadErrors(int) DvrStorageErrors
	// Total number of errors while writing to the archive.
	WriteErrors() *int
	// Total number of errors while writing to the archive.
	SetWriteErrors(int) DvrStorageErrors
}

type DvrStorageStats interface {
	// The runtime DVR errors.
	Errors() DvrStorageErrors
	// The runtime DVR errors.
	SetErrors(DvrStorageErrors) DvrStorageStats
}

type Error interface {
	// an application-specific error code, expressed as a string value
	Code() *string
	// an application-specific error code, expressed as a string value
	SetCode(string) Error
	// a unique identifier for this particular occurrence of the problem
	ID() *string
	// a unique identifier for this particular occurrence of the problem
	SetID(string) Error
	// a meta object containing non-standard meta-information about the error.
	Meta() map[string]string
	// a meta object containing non-standard meta-information about the error.
	SetMeta(map[string]string) Error
	// an object containing references to the source of the error
	Source() ErrorSource
	// an object containing references to the source of the error
	SetSource(ErrorSource) Error
	// the HTTP status code applicable to this problem, expressed as a string value
	Status() *string
	// the HTTP status code applicable to this problem, expressed as a string value
	SetStatus(string) Error
	// a short, human-readable summary of the problem that SHOULD NOT change from
	// occurrence to occurrence of the problem, except for purposes of localization
	Title() *string
	// a short, human-readable summary of the problem that SHOULD NOT change from
	// occurrence to occurrence of the problem, except for purposes of localization
	SetTitle(string) Error
}

type ErrorResponse interface {
	// List of structured errors
	Errors() []Error
	// List of structured errors
	SetErrors([]Error) ErrorResponse
}

// an object containing references to the source of the error
type ErrorSource interface {
	// a string indicating which URI query parameter caused the error.
	Parameter() *string
	// a string indicating which URI query parameter caused the error.
	SetParameter(string) ErrorSource
	// a JSON Pointer [RFC6901] to the associated entity in the request document
	// [e.g. `"/data"` for a primary data object, or `"/data/attributes/title"` for a specific attribute].
	Pointer() *string
	// a JSON Pointer [RFC6901] to the associated entity in the request document
	// [e.g. `"/data"` for a primary data object, or `"/data/attributes/title"` for a specific attribute].
	SetPointer(string) ErrorSource
}

type Event interface {
	// Creation date and time
	// Format: date_time (date_time)
	// Example: 2021-01-30T08:30:00.432567Z
	CreatedAt() *DateTime
	// Creation date and time
	// Format: date_time (date_time)
	// Example: 2021-01-30T08:30:00.432567Z
	SetCreatedAt(DateTime) Event
	// Microseconds that this request took
	// Format: microseconds (microseconds)
	Duration() *Microseconds
	// Microseconds that this request took
	// Format: microseconds (microseconds)
	SetDuration(Microseconds) Event
	// The api call.
	Event() string
	// The api call.
	SetEvent(string) Event
	// Event identifier.
	EventID() *int
	// Event identifier.
	SetEventID(int) Event
	// IP address of the caller.
	// Format: ip (ip)
	// Example: 192.34.32.10
	IP() *IP
	// IP address of the caller.
	// Format: ip (ip)
	// Example: 192.34.32.10
	SetIP(IP) Event
	// API method ID.
	// Example: streams_list
	OperationID() *string
	// API method ID.
	// Example: streams_list
	SetOperationID(string) Event
	// The program produced the API call. Content of `X-Originator` header.
	// Example: flussonic
	Originator() *string
	// The program produced the API call. Content of `X-Originator` header.
	// Example: flussonic
	SetOriginator(string) Event
	// The api call path.
	Path() *string
	// The api call path.
	SetPath(string) Event
	// Payload data transmitter in the API call.
	Payload() *string
	// Payload data transmitter in the API call.
	SetPayload(string) Event
	// The api call query string.
	Qs() *string
	// The api call query string.
	SetQs(string) Event
	// Internal request-id for this operation
	RequestID() *string
	// Internal request-id for this operation
	SetRequestID(string) Event
	// Originator of event.
	// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
	// is configured as HTTP/HTTPS url.
	// Example: flussonic.host
	Server() *string
	// Originator of event.
	// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
	// is configured as HTTP/HTTPS url.
	// Example: flussonic.host
	SetServer(string) Event
	// Request status code.
	Status() *int
	// Request status code.
	SetStatus(int) Event
	// Unique identifier of the operation.
	// You can use this field to search for events related to same operation.
	// Value of this field is taken from the `X-Trace-Id` header.
	// If `X-Trace-Id` header is not set, it will be generated automatically.
	// Service will use the value of this field to make outgoing requests.
	// Format: uuid (uuid)
	// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
	TraceID() *UUID
	// Unique identifier of the operation.
	// You can use this field to search for events related to same operation.
	// Value of this field is taken from the `X-Trace-Id` header.
	// If `X-Trace-Id` header is not set, it will be generated automatically.
	// Service will use the value of this field to make outgoing requests.
	// Format: uuid (uuid)
	// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
	SetTraceID(UUID) Event
	// The type of the device from which the API call was produced.
	// Example: Flussonic 24.04
	UserAgent() *string
	// The type of the device from which the API call was produced.
	// Example: Flussonic 24.04
	SetUserAgent(string) Event
	// The time of the event registration on the server.
	// Format: utc_ms (Unix timestamp in milliseconds)
	UtcMs() *UtcMs
	// The time of the event registration on the server.
	// Format: utc_ms (Unix timestamp in milliseconds)
	SetUtcMs(UtcMs) Event
}

type EventDefault interface {
	// Event identifier.
	EventID() *int
	// Event identifier.
	SetEventID(int) EventDefault
	// Originator of event.
	// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
	// is configured as HTTP/HTTPS url.
	// Example: flussonic.host
	Server() *string
	// Originator of event.
	// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
	// is configured as HTTP/HTTPS url.
	// Example: flussonic.host
	SetServer(string) EventDefault
	// Unique identifier of the operation.
	// You can use this field to search for events related to same operation.
	// Value of this field is taken from the `X-Trace-Id` header.
	// If `X-Trace-Id` header is not set, it will be generated automatically.
	// Service will use the value of this field to make outgoing requests.
	// Format: uuid (uuid)
	// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
	TraceID() *UUID
	// Unique identifier of the operation.
	// You can use this field to search for events related to same operation.
	// Value of this field is taken from the `X-Trace-Id` header.
	// If `X-Trace-Id` header is not set, it will be generated automatically.
	// Service will use the value of this field to make outgoing requests.
	// Format: uuid (uuid)
	// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
	SetTraceID(UUID) EventDefault
	// The time of the event registration on the server.
	// Format: utc_ms (Unix timestamp in milliseconds)
	UtcMs() *UtcMs
	// The time of the event registration on the server.
	// Format: utc_ms (Unix timestamp in milliseconds)
	SetUtcMs(UtcMs) EventDefault
}

// Required: name, url
type EventSinkConfig interface {
	// If specified, only the events that match **every** filter in the filter set will not be be passed to the event sink target.
	// That is, if even one of the conditions is not satisfied, an event will be processed.
	// Each filter (condition) has several possible values. For an event to satisfy the condition,
	// an event should match **any** of the specified values, not all of them.
	// Examples: [map[event:[stream_stopped, stream_started, source_*]]]
	Except() []map[string][]string
	// If specified, only the events that match **every** filter in the filter set will not be be passed to the event sink target.
	// That is, if even one of the conditions is not satisfied, an event will be processed.
	// Each filter (condition) has several possible values. For an event to satisfy the condition,
	// an event should match **any** of the specified values, not all of them.
	// Examples: [map[event:[stream_stopped, stream_started, source_*]]]
	SetExcept([]map[string][]string) EventSinkConfig
	// Some additional options.
	Extra() map[string]string
	// Some additional options.
	SetExtra(map[string]string) EventSinkConfig
	// Specify logging level for this sink. Anything more verbose than it will not get into this sink.
	Level() *Loglevel
	// Specify logging level for this sink. Anything more verbose than it will not get into this sink.
	SetLevel(Loglevel) EventSinkConfig
	// Maximal number of log files with events (JSON or text) that can be stored on a disk.
	// When this limit is reached, log rotation is performed: the oldest files will be overridden by later data.
	// Example: 100
	MaxDepth() *int
	// Maximal number of log files with events (JSON or text) that can be stored on a disk.
	// When this limit is reached, log rotation is performed: the oldest files will be overridden by later data.
	// Example: 100
	SetMaxDepth(int) EventSinkConfig
	// Maximum size of a log file.
	// When this limit is reached, log rotation is performed: the oldest events will be overridden by later data.
	// Format: bytes (bytes)
	// Example: 10000
	MaxSize() *Bytes
	// Maximum size of a log file.
	// When this limit is reached, log rotation is performed: the oldest events will be overridden by later data.
	// Format: bytes (bytes)
	// Example: 10000
	SetMaxSize(Bytes) EventSinkConfig
	// Globally unique event sink name.
	// Format: event_sink_name (event_sink_name)
	// Example: my_json_sink
	Name() EventSinkName
	// Globally unique event sink name.
	// Format: event_sink_name (event_sink_name)
	// Example: my_json_sink
	SetName(EventSinkName) EventSinkConfig
	// If specified, only the events that match **every** filter in the filter set will be passed to the event sink target.
	// That is, if even one of the conditions is not satisfied, an event will **not** be processed.
	// Each filter (condition) has several possible values. For an event to satisfy the condition,
	// an event should match **any** of the specified values, not all of them.
	// Examples: [map[event:[listener_start], group:[system_overloaded]]]
	Only() []map[string][]string
	// If specified, only the events that match **every** filter in the filter set will be passed to the event sink target.
	// That is, if even one of the conditions is not satisfied, an event will **not** be processed.
	// Each filter (condition) has several possible values. For an event to satisfy the condition,
	// an event should match **any** of the specified values, not all of them.
	// Examples: [map[event:[listener_start], group:[system_overloaded]]]
	SetOnly([]map[string][]string) EventSinkConfig
	// If an error occurs (`HTTP 500` or any other error), then *Flussonic* will try to buffer events and send them later.
	// The option defines the **number** of events to keep in memory for further delivery.
	// The default value is `unlimited`.
	// Example: 1000
	ResendLimit() *int
	// If an error occurs (`HTTP 500` or any other error), then *Flussonic* will try to buffer events and send them later.
	// The option defines the **number** of events to keep in memory for further delivery.
	// The default value is `unlimited`.
	// Example: 1000
	SetResendLimit(int) EventSinkConfig
	// How often *Flussonic* will try to resend non-confirmed events to the handler (in seconds).
	// Example: 10
	ResendTimeout() *int
	// How often *Flussonic* will try to resend non-confirmed events to the handler (in seconds).
	// Example: 10
	SetResendTimeout(int) EventSinkConfig
	// The delay (in seconds) before sending an event to the sink after saving it into the buffer.
	// This parameter allows to lower frequency of sending events.
	// If there are more than 100 events in the buffer, all of them will be sent to the sink without any delay.
	// Format: seconds (seconds)
	// Example: 1
	ThrottleDelay() *Seconds
	// The delay (in seconds) before sending an event to the sink after saving it into the buffer.
	// This parameter allows to lower frequency of sending events.
	// If there are more than 100 events in the buffer, all of them will be sent to the sink without any delay.
	// Format: seconds (seconds)
	// Example: 1
	SetThrottleDelay(Seconds) EventSinkConfig
	// Path where events are sent.
	// * For event handler, it is the URL of an HTTP handler or the path to a lua script:  `http://URL`, `https://URL`, or `path_to_lua_script.lua`.
	// * For event logging, it is the path to a log file (human-readable text file or JSON): `log://path_to_log_file.log` or `jsonlog://path_to_log_file.json`.
	// Pattern: ^(log|jsonlog|http|https)://.+$|^pid://<[0-9]+\.[0-9]+\.[0-9]+>$
	// Example: jsonlog:///var/log/events-json.log
	URL() string
	// Path where events are sent.
	// * For event handler, it is the URL of an HTTP handler or the path to a lua script:  `http://URL`, `https://URL`, or `path_to_lua_script.lua`.
	// * For event logging, it is the path to a log file (human-readable text file or JSON): `log://path_to_log_file.log` or `jsonlog://path_to_log_file.json`.
	// Pattern: ^(log|jsonlog|http|https)://.+$|^pid://<[0-9]+\.[0-9]+\.[0-9]+>$
	// Example: jsonlog:///var/log/events-json.log
	SetURL(string) EventSinkConfig
}

type EventsList interface {
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	EstimatedCount() *int
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	SetEstimatedCount(int) EventsList
	// List of events
	Events() []Event
	// List of events
	SetEvents([]Event) EventsList
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	Next() *string
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	SetNext(string) EventsList
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	Prev() *string
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	SetPrev(string) EventsList
	// An object with a list of different timings measured during this API call.
	Timing() any
	// An object with a list of different timings measured during this API call.
	SetTiming(any) EventsList
	// Collection returns the collection items
	Collection() []Event
}

type FileProcessorConfig interface {
	// The directory where Flussonic puts output files.
	// Format: disk_path (disk_path)
	Path() *DiskPath
	// The directory where Flussonic puts output files.
	// Format: disk_path (disk_path)
	SetPath(DiskPath) FileProcessorConfig
}

// Update camera firmware
// Required: image
type FirmwareUpdate interface {
	// Image for updating camera. Documentation for updating cameras: https://flussonic.com/doc/flussonic-home-v1/#upgrade.
	// Format: binary (binary)
	// Example: b'DL'
	Image() any
	// Image for updating camera. Documentation for updating cameras: https://flussonic.com/doc/flussonic-home-v1/#upgrade.
	// Format: binary (binary)
	// Example: b'DL'
	SetImage(any) FirmwareUpdate
	// Protocol for connecting to camera.
	// Example: iris
	Proto() *FirmwareUpdateProto
	// Protocol for connecting to camera.
	// Example: iris
	SetProto(FirmwareUpdateProto) FirmwareUpdate
}

type ForwardPortsConfig interface {
	// The handler name.
	Handler() *string
	// The handler name.
	SetHandler(string) ForwardPortsConfig
	// The handler options.
	Options() any
	// The handler options.
	SetOptions(any) ForwardPortsConfig
}

type GenrefStatus interface {
	// If true genref port is a physical port, else genref port is a virtual port (internal clock-lock feature).
	External() *bool
	// If true genref port is a physical port, else genref port is a virtual port (internal clock-lock feature).
	SetExternal(bool) GenrefStatus
	// Detected genref input port number.
	Port() *int
	// Detected genref input port number.
	SetPort(int) GenrefStatus
	// Configured reference signal video standard.
	Vstd() *string
	// Configured reference signal video standard.
	SetVstd(string) GenrefStatus
	// Detected (actual) reference signal video standard.
	VstdDetected() *string
	// Detected (actual) reference signal video standard.
	SetVstdDetected(string) GenrefStatus
}

// Here are counters for h264/h265 decoder.
type H26xDecoderCounters interface {
	// Number of NAL units, which `forbidden_zero_bit` is set to one.
	DiscardedBrokenNalCount() *int
	// Number of NAL units, which `forbidden_zero_bit` is set to one.
	SetDiscardedBrokenNalCount(int) H26xDecoderCounters
	// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
	// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
	// This counter shows number of discarded `Fragmentation Units`
	DiscardedFuCount() *int
	// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
	// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
	// This counter shows number of discarded `Fragmentation Units`
	SetDiscardedFuCount(int) H26xDecoderCounters
	// Number of discarded NAL units.
	DiscardedNalCount() *int
	// Number of discarded NAL units.
	SetDiscardedNalCount(int) H26xDecoderCounters
	// Number of NAL units, which type is not allowed in `non-interleaved packetization mode`.
	DiscardedNotAllowedNalCount() *int
	// Number of NAL units, which type is not allowed in `non-interleaved packetization mode`.
	SetDiscardedNotAllowedNalCount(int) H26xDecoderCounters
	// Number of discarded `SEI` NAL units
	DiscardedSeiCount() *int
	// Number of discarded `SEI` NAL units
	SetDiscardedSeiCount(int) H26xDecoderCounters
	// There is workaround to not interrupt `FU` sequence if `end-FU` followed by `middle-FU`.
	// This counter shows how many time the workaround was applied.
	FuEndThenMiddleWorkaroundCount() *int
	// There is workaround to not interrupt `FU` sequence if `end-FU` followed by `middle-FU`.
	// This counter shows how many time the workaround was applied.
	SetFuEndThenMiddleWorkaroundCount(int) H26xDecoderCounters
	// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
	// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
	// This counter shows number of `Fragmentation Units` which `Start bit` and `End bit` are set to one in the same `FU` header
	FuHasBothStartEndBitsCount() *int
	// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
	// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
	// This counter shows number of `Fragmentation Units` which `Start bit` and `End bit` are set to one in the same `FU` header
	SetFuHasBothStartEndBitsCount(int) H26xDecoderCounters
	// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
	// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
	// `Fragmentation Units` pattern must have a `Start FU`, `End FU` and could have `FUs` between these ones.
	// This counter indicates how many times pattern was broken.
	FuPatternIsBrokenCount() *int
	// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
	// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
	// `Fragmentation Units` pattern must have a `Start FU`, `End FU` and could have `FUs` between these ones.
	// This counter indicates how many times pattern was broken.
	SetFuPatternIsBrokenCount(int) H26xDecoderCounters
	// NAL deframentation could be interrupted by unexpected NAL or broken/incomplete packet.
	// If NAL deframentation is interrupted then incomplete fragment of NAL is not discarded and used in decoding process.
	// This counter indicates how many incomplete NALs were used.
	IncompleteNalCount() *int
	// NAL deframentation could be interrupted by unexpected NAL or broken/incomplete packet.
	// If NAL deframentation is interrupted then incomplete fragment of NAL is not discarded and used in decoding process.
	// This counter indicates how many incomplete NALs were used.
	SetIncompleteNalCount(int) H26xDecoderCounters
	// Number of `SEI` NAL units with bad payload
	InvalidSeiPayloadCount() *int
	// Number of `SEI` NAL units with bad payload
	SetInvalidSeiPayloadCount(int) H26xDecoderCounters
	// Number of `SEI` NAL units with invalid size
	InvalidSeiSizeCount() *int
	// Number of `SEI` NAL units with invalid size
	SetInvalidSeiSizeCount(int) H26xDecoderCounters
	// Number of `SEI` NAL units with invalid type
	InvalidSeiTypeCount() *int
	// Number of `SEI` NAL units with invalid type
	SetInvalidSeiTypeCount(int) H26xDecoderCounters
	// How many NAL `AGGREGATION` units handled by this decoder.
	NalAggregationCount() *int
	// How many NAL `AGGREGATION` units handled by this decoder.
	SetNalAggregationCount(int) H26xDecoderCounters
	// How many NAL `AUD` units handled by this decoder.
	NalAudCount() *int
	// How many NAL `AUD` units handled by this decoder.
	SetNalAudCount(int) H26xDecoderCounters
	// How many NAL units handled by this decoder.
	NalCount() *int
	// How many NAL units handled by this decoder.
	SetNalCount(int) H26xDecoderCounters
	// How many NAL `FILLER` units handled by this decoder.
	NalFillerCount() *int
	// How many NAL `FILLER` units handled by this decoder.
	SetNalFillerCount(int) H26xDecoderCounters
	// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
	// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
	// This counter shows how many `Fragmentation Units` handled by this decoder.
	NalFuCount() *int
	// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
	// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
	// This counter shows how many `Fragmentation Units` handled by this decoder.
	SetNalFuCount(int) H26xDecoderCounters
	// How many NAL `IDR` units handled by this decoder.
	NalIdrCount() *int
	// How many NAL `IDR` units handled by this decoder.
	SetNalIdrCount(int) H26xDecoderCounters
	// How many other NAL units handled by this decoder.
	NalOtherCount() *int
	// How many other NAL units handled by this decoder.
	SetNalOtherCount(int) H26xDecoderCounters
	// How many NAL `PPS` units handled by this decoder.
	NalPpsCount() *int
	// How many NAL `PPS` units handled by this decoder.
	SetNalPpsCount(int) H26xDecoderCounters
	// How many NAL `SEI` units handled by this decoder.
	NalSeiCount() *int
	// How many NAL `SEI` units handled by this decoder.
	SetNalSeiCount(int) H26xDecoderCounters
	// How many NAL `SINGLE` units handled by this decoder.
	NalSingleCount() *int
	// How many NAL `SINGLE` units handled by this decoder.
	SetNalSingleCount(int) H26xDecoderCounters
	// How many NAL `SLICE` units handled by this decoder.
	NalSliceCount() *int
	// How many NAL `SLICE` units handled by this decoder.
	SetNalSliceCount(int) H26xDecoderCounters
	// How many NAL `SPS` units handled by this decoder.
	NalSpsCount() *int
	// How many NAL `SPS` units handled by this decoder.
	SetNalSpsCount(int) H26xDecoderCounters
	// How many NAL `STAP_A` units handled by this decoder.
	NalStapACount() *int
	// How many NAL `STAP_A` units handled by this decoder.
	SetNalStapACount(int) H26xDecoderCounters
	// How many NAL `VPS` units handled by this decoder.
	NalVpsCount() *int
	// How many NAL `VPS` units handled by this decoder.
	SetNalVpsCount(int) H26xDecoderCounters
}

// Required: prefix, url
type HTTPProxyConfig interface {
	// If this flag is set, then streamer will redirect from "/" to this proxy configuration.
	Mainpage() *bool
	// If this flag is set, then streamer will redirect from "/" to this proxy configuration.
	SetMainpage(bool) HTTPProxyConfig
	// HTTP prefix that will be intercepted by this http proxy configuration
	// Format: media_name (media_name)
	Prefix() MediaName
	// HTTP prefix that will be intercepted by this http proxy configuration
	// Format: media_name (media_name)
	SetPrefix(MediaName) HTTPProxyConfig
	// The runtime statistics about http proxy
	Stats() HTTPProxyStats
	// The runtime statistics about http proxy
	SetStats(HTTPProxyStats) HTTPProxyConfig
	// Upstream url
	// Format: url (url)
	URL() URL
	// Upstream url
	// Format: url (url)
	SetURL(URL) HTTPProxyConfig
}

type HTTPProxyStats interface {
	// Number of requests with HTTP code 1xx (e.g. protocol upgrades)
	// Example: 1000
	HTTP100() *int
	// Number of requests with HTTP code 1xx (e.g. protocol upgrades)
	// Example: 1000
	SetHTTP100(int) HTTPProxyStats
	// Number of requests with HTTP code 2xx
	// Example: 1000
	HTTP200() *int
	// Number of requests with HTTP code 2xx
	// Example: 1000
	SetHTTP200(int) HTTPProxyStats
	// Number of requests with HTTP code 3xx
	// Example: 10
	HTTP300() *int
	// Number of requests with HTTP code 3xx
	// Example: 10
	SetHTTP300(int) HTTPProxyStats
	// Number of requests with HTTP code 4xx
	// Example: 10
	HTTP400() *int
	// Number of requests with HTTP code 4xx
	// Example: 10
	SetHTTP400(int) HTTPProxyStats
	// Number of requests with HTTP code 5xx
	// Example: 10
	HTTP500() *int
	// Number of requests with HTTP code 5xx
	// Example: 10
	SetHTTP500(int) HTTPProxyStats
	// Total number of requests with protocol upgrade (e.g. websocket)
	// Example: 1000
	ProtocolUpgrades() *int
	// Total number of requests with protocol upgrade (e.g. websocket)
	// Example: 1000
	SetProtocolUpgrades(int) HTTPProxyStats
	// Number of requests with error on proxy itself
	// Example: 10
	ProxyError() *int
	// Number of requests with error on proxy itself
	// Example: 10
	SetProxyError(int) HTTPProxyStats
	// Number of requests with connection errors - econnrefused, etc
	// Example: 10
	ProxyErrorConnection() *int
	// Number of requests with connection errors - econnrefused, etc
	// Example: 10
	SetProxyErrorConnection(int) HTTPProxyStats
	// Total number of requests this prefix received
	// Example: 1000
	Requests() *int
	// Total number of requests this prefix received
	// Example: 1000
	SetRequests(int) HTTPProxyStats
	// Number of API calls that took more than 500ms and less than 1s
	// Example: 2
	Time1000Ms() *int
	// Number of API calls that took more than 500ms and less than 1s
	// Example: 2
	SetTime1000Ms(int) HTTPProxyStats
	// Number of API calls that took less than 100ms
	// Example: 10
	Time100Ms() *int
	// Number of API calls that took less than 100ms
	// Example: 10
	SetTime100Ms(int) HTTPProxyStats
	// Number of API calls that took more than 1s and less than 5s
	// Example: 2
	Time5000Ms() *int
	// Number of API calls that took more than 1s and less than 5s
	// Example: 2
	SetTime5000Ms(int) HTTPProxyStats
	// Number of API calls that took more than 100ms and less than 500ms
	// Example: 5
	Time500Ms() *int
	// Number of API calls that took more than 100ms and less than 500ms
	// Example: 5
	SetTime500Ms(int) HTTPProxyStats
	// Number of API calls that took more than 5s
	// Example: 1
	TimeLongms() *int
	// Number of API calls that took more than 5s
	// Example: 1
	SetTimeLongms(int) HTTPProxyStats
}

// Agent counters
type InputAgentCounters interface {
	// These errors indicate that the agent does not have enough buffer size to handle outgoing traffic.
	ErrorsBufferOverrun() *int
	// These errors indicate that the agent does not have enough buffer size to handle outgoing traffic.
	SetErrorsBufferOverrun(int) InputAgentCounters
	// The agent was unable to open the requested connection. These errors may indicate problems opening the TCP socket on the agent or the remote host is unreacheable.
	ErrorsConnFailed() *int
	// The agent was unable to open the requested connection. These errors may indicate problems opening the TCP socket on the agent or the remote host is unreacheable.
	SetErrorsConnFailed(int) InputAgentCounters
	// These errors indicate that the agent is receiving invalid requests.
	ErrorsInvalidRequest() *int
	// These errors indicate that the agent is receiving invalid requests.
	SetErrorsInvalidRequest(int) InputAgentCounters
	// These errors indicate that the agent does not have enough memory to establish a connection to the remote host.
	ErrorsOutOfMemory() *int
	// These errors indicate that the agent does not have enough memory to establish a connection to the remote host.
	SetErrorsOutOfMemory(int) InputAgentCounters
	// Unknown errors counter.
	ErrorsUnknown() *int
	// Unknown errors counter.
	SetErrorsUnknown(int) InputAgentCounters
}

// Here are grouped different counters for sessions: generic and errors
type InputCounters interface {
	// How many Ad markers passed to this stream from the inputs.
	AdSplicesIngested() *int
	// How many Ad markers passed to this stream from the inputs.
	SetAdSplicesIngested(int) InputCounters
	// How many Ad markers inserted to this stream by user.
	AdSplicesInserted() *int
	// How many Ad markers inserted to this stream by user.
	SetAdSplicesInserted(int) InputCounters
	Agent() InputAgentCounters
	SetAgent(InputAgentCounters) InputCounters
	// Number of bytes received by this stream from live sources.
	// It will be counted before transcoding and will sum all inputs working together.
	// Format: bytes (bytes)
	Bytes() *Bytes
	// Number of bytes received by this stream from live sources.
	// It will be counted before transcoding and will sum all inputs working together.
	// Format: bytes (bytes)
	SetBytes(Bytes) InputCounters
	// Number of bytes received by this stream when downloading from remote DVR.
	// Format: bytes (bytes)
	BytesDvr() *Bytes
	// Number of bytes received by this stream when downloading from remote DVR.
	// Format: bytes (bytes)
	SetBytesDvr(Bytes) InputCounters
	// Sum of all other specific errors in the last minute
	// Example: 0
	ErrorRate() *int
	// Sum of all other specific errors in the last minute
	// Example: 0
	SetErrorRate(int) InputCounters
	// Sum of all other specific errors. Can be used for triggering alert on any error
	// Example: 0
	Errors() *int
	// Sum of all other specific errors. Can be used for triggering alert on any error
	// Example: 0
	SetErrors(int) InputCounters
	// How many times we've got 403 (eaccess).
	Errors403() *int
	// How many times we've got 403 (eaccess).
	SetErrors403(int) InputCounters
	// How many times we've got 404 (enoent).
	Errors404() *int
	// How many times we've got 404 (enoent).
	SetErrors404(int) InputCounters
	// How many times we've got 500 (backend error).
	Errors500() *int
	// How many times we've got 500 (backend error).
	SetErrors500(int) InputCounters
	// Demultiplexing was done right, but content is broken.
	ErrorsBrokenPayload() *int
	// Demultiplexing was done right, but content is broken.
	SetErrorsBrokenPayload(int) InputCounters
	// How many times input was restarted due to internal crash.
	// This may happen due to unhandled input.
	ErrorsCrashed() *int
	// How many times input was restarted due to internal crash.
	// This may happen due to unhandled input.
	SetErrorsCrashed(int) InputCounters
	// Decoder reset count due to abnormal DTS change. Can happen in MPEG-TS, RTP.
	ErrorsDecoderReset() *int
	// Decoder reset count due to abnormal DTS change. Can happen in MPEG-TS, RTP.
	SetErrorsDecoderReset(int) InputCounters
	// This can be used as a `TS_sync_loss` - how many times MPEG-TS sync was lost.
	// Also this counter refers to RTSP desync, when camera starts dropping TCP data and
	// we have to find packet boundaries.
	// Here we write count of such resynchronizations.
	ErrorsDesync() *int
	// This can be used as a `TS_sync_loss` - how many times MPEG-TS sync was lost.
	// Also this counter refers to RTSP desync, when camera starts dropping TCP data and
	// we have to find packet boundaries.
	// Here we write count of such resynchronizations.
	SetErrorsDesync(int) InputCounters
	// Dropped frames count due timestamp adjustment.
	ErrorsDroppedFrames() *int
	// Dropped frames count due timestamp adjustment.
	SetErrorsDroppedFrames(int) InputCounters
	// RTP, MPEG-TS or other protocols have enough information to tell how many packets were lost
	ErrorsLostPackets() *int
	// RTP, MPEG-TS or other protocols have enough information to tell how many packets were lost
	SetErrorsLostPackets(int) InputCounters
	// how many times PAT was missing during 0,5 seconds or pid 0 misses PAT
	// `PAT_error`
	ErrorsTSPat() *int
	// how many times PAT was missing during 0,5 seconds or pid 0 misses PAT
	// `PAT_error`
	SetErrorsTSPat(int) InputCounters
	// How many times have received PAT that was missing required service (program)
	ErrorsTSServiceLost() *int
	// How many times have received PAT that was missing required service (program)
	SetErrorsTSServiceLost(int) InputCounters
	// Number of connection restarts to fix ts_stuck issue. Can happen in RTSP.
	ErrorsTSStuckRestarts() *int
	// Number of connection restarts to fix ts_stuck issue. Can happen in RTSP.
	SetErrorsTSStuckRestarts(int) InputCounters
	// Number of frames passed to this stream from the inputs.
	Frames() *int
	// Number of frames passed to this stream from the inputs.
	SetFrames(int) InputCounters
	// Aggregated: how many times this stream has switched between different inputs.
	// Individual input: number of times switched to this input.
	InputSwitches() *int
	// Aggregated: how many times this stream has switched between different inputs.
	// Individual input: number of times switched to this input.
	SetInputSwitches(int) InputCounters
	// Number of secondary inputs that have some problems.
	// Example: 0
	InvalidSecondaryInputs() *int
	// Number of secondary inputs that have some problems.
	// Example: 0
	SetInvalidSecondaryInputs(int) InputCounters
	// Indicates, how often does media_info changes
	MediaInfoChanges() *int
	// Indicates, how often does media_info changes
	SetMediaInfoChanges(int) InputCounters
	MotionDetector() InputMotionDetectorCounters
	SetMotionDetector(InputMotionDetectorCounters) InputCounters
	// How many seconds has this stream had no frames.
	// Format: seconds (seconds)
	NumSecNoData() *Seconds
	// How many seconds has this stream had no frames.
	// Format: seconds (seconds)
	SetNumSecNoData(Seconds) InputCounters
	// How many seconds has this stream played from primary input.
	// Format: seconds (seconds)
	NumSecOnPrimaryInput() *Seconds
	// How many seconds has this stream played from primary input.
	// Format: seconds (seconds)
	SetNumSecOnPrimaryInput(Seconds) InputCounters
	// How many seconds has this stream played from secondary inputs.
	// Format: seconds (seconds)
	NumSecOnSecondaryInput() *Seconds
	// How many seconds has this stream played from secondary inputs.
	// Format: seconds (seconds)
	SetNumSecOnSecondaryInput(Seconds) InputCounters
	// Per pid statistics calculated for MPEG-TS input
	Pids() []InputPidCounters
	// Per pid statistics calculated for MPEG-TS input
	SetPids([]InputPidCounters) InputCounters
	// Source may send frames not in the order they should be played. It will be catched and reordered.
	// This counter indicates how many times did it happened.
	ReorderCount() *int
	// Source may send frames not in the order they should be played. It will be catched and reordered.
	// This counter indicates how many times did it happened.
	SetReorderCount(int) InputCounters
	// Source may send frames timestamps faster or slower than realtime.
	// Live stream will catch it and resync. This counter indicates how many times did it happened.
	ResyncCountDrift() *int
	// Source may send frames timestamps faster or slower than realtime.
	// Live stream will catch it and resync. This counter indicates how many times did it happened.
	SetResyncCountDrift(int) InputCounters
	// Source may change timestamps without any signalling. This counter indicates how bad is the source
	ResyncCountJump() *int
	// Source may change timestamps without any signalling. This counter indicates how bad is the source
	SetResyncCountJump(int) InputCounters
	// Stream timestamps are synchronized with real time. This counter tells, how many times
	// it was syncronized after source reconnect.
	ResyncCountNormal() *int
	// Stream timestamps are synchronized with real time. This counter tells, how many times
	// it was syncronized after source reconnect.
	SetResyncCountNormal(int) InputCounters
	// How many times has this stream retried to connect to source
	Retries() *int
	// How many times has this stream retried to connect to source
	SetRetries(int) InputCounters
	// Per channel statistics calculated for RTP input
	RTPChannels() []InputRTPCounters
	// Per channel statistics calculated for RTP input
	SetRTPChannels([]InputRTPCounters) InputCounters
	Sdi() InputSdiCounters
	SetSdi(InputSdiCounters) InputCounters
	Srt() InputSrtCounters
	SetSrt(InputSrtCounters) InputCounters
	// Number of secondary inputs that have no problems.
	// Example: 2
	ValidSecondaryInputs() *int
	// Number of secondary inputs that have no problems.
	// Example: 2
	SetValidSecondaryInputs(int) InputCounters
}

// Specific counters to get insights on current state of getting events from cameras.
// Designed to be used by analyzers, monitoring and alerting tools
type InputMotionDetectorCounters interface {
	// Number of collected episodes.
	EpisodesCount() *int
	// Number of collected episodes.
	SetEpisodesCount(int) InputMotionDetectorCounters
	// Number of responses with broken content.
	ErrorsBrokenPayload() *int
	// Number of responses with broken content.
	SetErrorsBrokenPayload(int) InputMotionDetectorCounters
	// `ONVIF Event Handling Test Specification` says that valid values for `CurrentTime` and `TerminationTime` are
	// `TerminationTime >= CurrentTime + InitialTerminationTime`.
	// How many responses did not met the condition.
	ErrorsIncorrectTimeValuesCount() *int
	// `ONVIF Event Handling Test Specification` says that valid values for `CurrentTime` and `TerminationTime` are
	// `TerminationTime >= CurrentTime + InitialTerminationTime`.
	// How many responses did not met the condition.
	SetErrorsIncorrectTimeValuesCount(int) InputMotionDetectorCounters
	// Number of failed request attempts because of no agent connected.
	ErrorsNoAgentConnected() *int
	// Number of failed request attempts because of no agent connected.
	SetErrorsNoAgentConnected(int) InputMotionDetectorCounters
	// Number of attempts to request disabled or unsupported ONVIF service
	ErrorsNoServiceCount() *int
	// Number of attempts to request disabled or unsupported ONVIF service
	SetErrorsNoServiceCount(int) InputMotionDetectorCounters
	// Number of not authorized requests
	ErrorsNotAuthorizedCount() *int
	// Number of not authorized requests
	SetErrorsNotAuthorizedCount(int) InputMotionDetectorCounters
	// Number of failed requests because of bad url or network issues.
	ErrorsURLUnreachableCount() *int
	// Number of failed requests because of bad url or network issues.
	SetErrorsURLUnreachableCount(int) InputMotionDetectorCounters
	// Number of detected motions.
	MotionDetectedCount() *int
	// Number of detected motions.
	SetMotionDetectedCount(int) InputMotionDetectorCounters
}

// Required: pid
type InputPidCounters interface {
	// How many PES packets were started not from startcode
	BrokenPesCount() *int
	// How many PES packets were started not from startcode
	SetBrokenPesCount(int) InputPidCounters
	// How many bytes were discarded due to lack of PES startcode
	BrokenPesSum() *int
	// How many bytes were discarded due to lack of PES startcode
	SetBrokenPesSum(int) InputPidCounters
	// How many times PTS was less than PCR or previous PTS
	CorrectedBackwardPts() *int
	// How many times PTS was less than PCR or previous PTS
	SetCorrectedBackwardPts(int) InputPidCounters
	// Unhandled crashes inside mpegts decoding process due
	Crashed() *int
	// Unhandled crashes inside mpegts decoding process due
	SetCrashed(int) InputPidCounters
	// How many times was discarded too big ES buffer without making a frame of it
	DiscardedBufferCount() *int
	// How many times was discarded too big ES buffer without making a frame of it
	SetDiscardedBufferCount(int) InputPidCounters
	// How many bytes were lost due to discarding ES buffer
	DiscardedBufferSum() *int
	// How many bytes were lost due to discarding ES buffer
	SetDiscardedBufferSum(int) InputPidCounters
	// Time on this PID jumped back from reference PTS and it was not a roll over zero
	DtsGoesBackwards() *int
	// Time on this PID jumped back from reference PTS and it was not a roll over zero
	SetDtsGoesBackwards(int) InputPidCounters
	// Time on this PID jumped forward too far away from reference PTS
	DtsJumpForward() *int
	// Time on this PID jumped forward too far away from reference PTS
	SetDtsJumpForward(int) InputPidCounters
	// Packets without payload and adaptation field
	EmptyPackets() *int
	// Packets without payload and adaptation field
	SetEmptyPackets(int) InputPidCounters
	// Packets with adaptation field larger than packet size
	ErrorsAdaptationBroken() *int
	// Packets with adaptation field larger than packet size
	SetErrorsAdaptationBroken(int) InputPidCounters
	// How many times pid has been lost
	ErrorsPidLost() *int
	// How many times pid has been lost
	SetErrorsPidLost(int) InputPidCounters
	// how many MPEG-TS packets were received with non-contigious contiuity counters.
	// `Continuity_count_error`
	// Example: 0
	ErrorsTSCc() *int
	// how many MPEG-TS packets were received with non-contigious contiuity counters.
	// `Continuity_count_error`
	// Example: 0
	SetErrorsTSCc(int) InputPidCounters
	// how many times PMT was not received after 0,5 seconds
	// `PMT_error`
	ErrorsTSPmt() *int
	// how many times PMT was not received after 0,5 seconds
	// `PMT_error`
	SetErrorsTSPmt(int) InputPidCounters
	// How many times have received PSI entry with broken checksum
	// `CRC_error`
	ErrorsTSPsiChecksum() *int
	// How many times have received PSI entry with broken checksum
	// `CRC_error`
	SetErrorsTSPsiChecksum(int) InputPidCounters
	// Amount of scrambled TS packets
	ErrorsTSScrambled() *int
	// Amount of scrambled TS packets
	SetErrorsTSScrambled(int) InputPidCounters
	// How many MPEG-TS packets with Transport Error Indicator were received
	// `Transport_error`, 2.1
	ErrorsTSTei() *int
	// How many MPEG-TS packets with Transport Error Indicator were received
	// `Transport_error`, 2.1
	SetErrorsTSTei(int) InputPidCounters
	// How many H264(5) NAL fillers were seen in the input
	FillersCount() *int
	// How many H264(5) NAL fillers were seen in the input
	SetFillersCount(int) InputPidCounters
	// How many bytes were seen in NAL fillers
	FillersSum() *int
	// How many bytes were seen in NAL fillers
	SetFillersSum(int) InputPidCounters
	// Frame count on this pid
	Frames() *int
	// Frame count on this pid
	SetFrames(int) InputPidCounters
	// How many MPEG-TS packets with 188 bytes on this pid received
	Packets() *int
	// How many MPEG-TS packets with 188 bytes on this pid received
	SetPackets(int) InputPidCounters
	// How many PES packets were on the Padding streamId
	PaddingPesCount() *int
	// How many PES packets were on the Padding streamId
	SetPaddingPesCount(int) InputPidCounters
	// How many bytes were in PES packets on the Padding streamId
	PaddingPesSum() *int
	// How many bytes were in PES packets on the Padding streamId
	SetPaddingPesSum(int) InputPidCounters
	// If PTS is drifting away from PCR, it can be resynchronized with PCR. This is a resync count
	PcrResync() *int
	// If PTS is drifting away from PCR, it can be resynchronized with PCR. This is a resync count
	SetPcrResync(int) InputPidCounters
	// Related MPEG-TS pid with following problems
	Pid() int
	// Related MPEG-TS pid with following problems
	SetPid(int) InputPidCounters
	// What program does have this pid
	Pnr() *int
	// What program does have this pid
	SetPnr(int) InputPidCounters
	// In case of CC error last frame can be repeated. This is a count of repeated frames
	RepeatedFrames() *int
	// In case of CC error last frame can be repeated. This is a count of repeated frames
	SetRepeatedFrames(int) InputPidCounters
	// Jumps of timestamps inside a MPEG-TS stream
	TimeCorrections() *int
	// Jumps of timestamps inside a MPEG-TS stream
	SetTimeCorrections(int) InputPidCounters
	// Jump of the PTS was so big from previous, that had to flush all frames and restart parsing
	TooLargeDtsJump() *int
	// Jump of the PTS was so big from previous, that had to flush all frames and restart parsing
	SetTooLargeDtsJump(int) InputPidCounters
}

type InputRTPCounters interface {
	// How many bytes received for this channel
	Bytes() *int
	// How many bytes received for this channel
	SetBytes(int) InputRTPCounters
	// RTP channel number
	// Example: 0
	ChannelID() int
	// RTP channel number
	// Example: 0
	SetChannelID(int) InputRTPCounters
	// Content of the track transmitted in the channel
	// Example: video
	Content() *string
	// Content of the track transmitted in the channel
	// Example: video
	SetContent(string) InputRTPCounters
	// Number of NAL units, which `forbidden_zero_bit` is set to one.
	DiscardedBrokenNalCount() *int
	// Number of NAL units, which `forbidden_zero_bit` is set to one.
	SetDiscardedBrokenNalCount(int) InputRTPCounters
	// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
	// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
	// This counter shows number of discarded `Fragmentation Units`
	DiscardedFuCount() *int
	// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
	// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
	// This counter shows number of discarded `Fragmentation Units`
	SetDiscardedFuCount(int) InputRTPCounters
	// Number of discarded NAL units.
	DiscardedNalCount() *int
	// Number of discarded NAL units.
	SetDiscardedNalCount(int) InputRTPCounters
	// Number of NAL units, which type is not allowed in `non-interleaved packetization mode`.
	DiscardedNotAllowedNalCount() *int
	// Number of NAL units, which type is not allowed in `non-interleaved packetization mode`.
	SetDiscardedNotAllowedNalCount(int) InputRTPCounters
	// Number of discarded `SEI` NAL units
	DiscardedSeiCount() *int
	// Number of discarded `SEI` NAL units
	SetDiscardedSeiCount(int) InputRTPCounters
	// Demultiplexing was done right, but content is broken.
	ErrorsBrokenPayload() *int
	// Demultiplexing was done right, but content is broken.
	SetErrorsBrokenPayload(int) InputRTPCounters
	// Number of frames which dts is same as previous frame dts.
	ErrorsDtsStuck() *int
	// Number of frames which dts is same as previous frame dts.
	SetErrorsDtsStuck(int) InputRTPCounters
	// RTP have enough information to tell how many packets were lost
	ErrorsLostPackets() *int
	// RTP have enough information to tell how many packets were lost
	SetErrorsLostPackets(int) InputRTPCounters
	// How many frames received for this channel
	Frames() *int
	// How many frames received for this channel
	SetFrames(int) InputRTPCounters
	// There is workaround to not interrupt `FU` sequence if `end-FU` followed by `middle-FU`.
	// This counter shows how many time the workaround was applied.
	FuEndThenMiddleWorkaroundCount() *int
	// There is workaround to not interrupt `FU` sequence if `end-FU` followed by `middle-FU`.
	// This counter shows how many time the workaround was applied.
	SetFuEndThenMiddleWorkaroundCount(int) InputRTPCounters
	// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
	// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
	// This counter shows number of `Fragmentation Units` which `Start bit` and `End bit` are set to one in the same `FU` header
	FuHasBothStartEndBitsCount() *int
	// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
	// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
	// This counter shows number of `Fragmentation Units` which `Start bit` and `End bit` are set to one in the same `FU` header
	SetFuHasBothStartEndBitsCount(int) InputRTPCounters
	// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
	// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
	// `Fragmentation Units` pattern must have a `Start FU`, `End FU` and could have `FUs` between these ones.
	// This counter indicates how many times pattern was broken.
	FuPatternIsBrokenCount() *int
	// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
	// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
	// `Fragmentation Units` pattern must have a `Start FU`, `End FU` and could have `FUs` between these ones.
	// This counter indicates how many times pattern was broken.
	SetFuPatternIsBrokenCount(int) InputRTPCounters
	// NAL deframentation could be interrupted by unexpected NAL or broken/incomplete packet.
	// If NAL deframentation is interrupted then incomplete fragment of NAL is not discarded and used in decoding process.
	// This counter indicates how many incomplete NALs were used.
	IncompleteNalCount() *int
	// NAL deframentation could be interrupted by unexpected NAL or broken/incomplete packet.
	// If NAL deframentation is interrupted then incomplete fragment of NAL is not discarded and used in decoding process.
	// This counter indicates how many incomplete NALs were used.
	SetIncompleteNalCount(int) InputRTPCounters
	// Number of `SEI` NAL units with bad payload
	InvalidSeiPayloadCount() *int
	// Number of `SEI` NAL units with bad payload
	SetInvalidSeiPayloadCount(int) InputRTPCounters
	// Number of `SEI` NAL units with invalid size
	InvalidSeiSizeCount() *int
	// Number of `SEI` NAL units with invalid size
	SetInvalidSeiSizeCount(int) InputRTPCounters
	// Number of `SEI` NAL units with invalid type
	InvalidSeiTypeCount() *int
	// Number of `SEI` NAL units with invalid type
	SetInvalidSeiTypeCount(int) InputRTPCounters
	// Number of RTP packets which marker bit is set to one.
	MarkerPacketsCount() *int
	// Number of RTP packets which marker bit is set to one.
	SetMarkerPacketsCount(int) InputRTPCounters
	// How many NACK messages are sent for this channel
	NackCount() *int
	// How many NACK messages are sent for this channel
	SetNackCount(int) InputRTPCounters
	// How many NAL `AGGREGATION` units handled by this decoder.
	NalAggregationCount() *int
	// How many NAL `AGGREGATION` units handled by this decoder.
	SetNalAggregationCount(int) InputRTPCounters
	// How many NAL `AUD` units handled by this decoder.
	NalAudCount() *int
	// How many NAL `AUD` units handled by this decoder.
	SetNalAudCount(int) InputRTPCounters
	// How many NAL units handled by this decoder.
	NalCount() *int
	// How many NAL units handled by this decoder.
	SetNalCount(int) InputRTPCounters
	// How many NAL `FILLER` units handled by this decoder.
	NalFillerCount() *int
	// How many NAL `FILLER` units handled by this decoder.
	SetNalFillerCount(int) InputRTPCounters
	// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
	// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
	// This counter shows how many `Fragmentation Units` handled by this decoder.
	NalFuCount() *int
	// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
	// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
	// This counter shows how many `Fragmentation Units` handled by this decoder.
	SetNalFuCount(int) InputRTPCounters
	// How many NAL `IDR` units handled by this decoder.
	NalIdrCount() *int
	// How many NAL `IDR` units handled by this decoder.
	SetNalIdrCount(int) InputRTPCounters
	// How many other NAL units handled by this decoder.
	NalOtherCount() *int
	// How many other NAL units handled by this decoder.
	SetNalOtherCount(int) InputRTPCounters
	// How many NAL `PPS` units handled by this decoder.
	NalPpsCount() *int
	// How many NAL `PPS` units handled by this decoder.
	SetNalPpsCount(int) InputRTPCounters
	// How many NAL `SEI` units handled by this decoder.
	NalSeiCount() *int
	// How many NAL `SEI` units handled by this decoder.
	SetNalSeiCount(int) InputRTPCounters
	// How many NAL `SINGLE` units handled by this decoder.
	NalSingleCount() *int
	// How many NAL `SINGLE` units handled by this decoder.
	SetNalSingleCount(int) InputRTPCounters
	// How many NAL `SLICE` units handled by this decoder.
	NalSliceCount() *int
	// How many NAL `SLICE` units handled by this decoder.
	SetNalSliceCount(int) InputRTPCounters
	// How many NAL `SPS` units handled by this decoder.
	NalSpsCount() *int
	// How many NAL `SPS` units handled by this decoder.
	SetNalSpsCount(int) InputRTPCounters
	// How many NAL `STAP_A` units handled by this decoder.
	NalStapACount() *int
	// How many NAL `STAP_A` units handled by this decoder.
	SetNalStapACount(int) InputRTPCounters
	// How many NAL `VPS` units handled by this decoder.
	NalVpsCount() *int
	// How many NAL `VPS` units handled by this decoder.
	SetNalVpsCount(int) InputRTPCounters
	// If no marker bit packet is received after 400 RTP packets then decoder switches to `no_marker_mode` and
	// makes frame on each timecode change.
	// This flag shows if decoder works in `no_marker_mode`.
	NoMarkerModeFlag() *bool
	// If no marker bit packet is received after 400 RTP packets then decoder switches to `no_marker_mode` and
	// makes frame on each timecode change.
	// This flag shows if decoder works in `no_marker_mode`.
	SetNoMarkerModeFlag(bool) InputRTPCounters
	// Number of rtp packets rejected due to wrong payload type
	PtRejectCount() *int
	// Number of rtp packets rejected due to wrong payload type
	SetPtRejectCount(int) InputRTPCounters
	// Total size of rejected packets due to wrong payload type (pt_reject_count) rtp packets
	PtRejectSum() *int
	// Total size of rejected packets due to wrong payload type (pt_reject_count) rtp packets
	SetPtRejectSum(int) InputRTPCounters
	// How many RTCP packets received for this channel
	RtcpPackets() *int
	// How many RTCP packets received for this channel
	SetRtcpPackets(int) InputRTPCounters
	// How many RTP packets received for this channel
	RTPPackets() *int
	// How many RTP packets received for this channel
	SetRTPPackets(int) InputRTPCounters
	// Sender wallclock deviation from server time in ms. Positive value means that sender time is ahead of server time.
	SenderClockDeviation() *int
	// Sender wallclock deviation from server time in ms. Positive value means that sender time is ahead of server time.
	SetSenderClockDeviation(int) InputRTPCounters
	// Number of rtcp SR packets which `RTP timestamp` is equal to the previous rtcp SR packet `RTP timestamp`.
	SrTSStuck() *int
	// Number of rtcp SR packets which `RTP timestamp` is equal to the previous rtcp SR packet `RTP timestamp`.
	SetSrTSStuck(int) InputRTPCounters
	// Time on this channel is jumped back from reference wallclock.
	TSGoesBackwards() *int
	// Time on this channel is jumped back from reference wallclock.
	SetTSGoesBackwards(int) InputRTPCounters
	// Time on this channel is jumped forward from reference wallclock.
	TSJumpForward() *int
	// Time on this channel is jumped forward from reference wallclock.
	SetTSJumpForward(int) InputRTPCounters
	// https://datatracker.ietf.org/doc/html/rfc6184#section-4.1
	// access unit: A set of NAL units always containing a primary coded picture.  In addition to the primary coded
	// picture, an access unit may also contain one or more redundant coded pictures or other NAL units not containing
	// slices or slice data partitions of a coded picture.  The decoding of an access unit always results in a
	// decoded picture.
	// There is `marker bit` in RTP packet which is set for the very last packet of the access unit indicated by the RTP timestamp.
	// It is protocol violation if received RTP packet has the same timestamp as previous marker bit packet.
	// This counter is a number of RTP packets which `RTP timestamp` is equal to previous RTP marker bit packet.
	TSStuck() *int
	// https://datatracker.ietf.org/doc/html/rfc6184#section-4.1
	// access unit: A set of NAL units always containing a primary coded picture.  In addition to the primary coded
	// picture, an access unit may also contain one or more redundant coded pictures or other NAL units not containing
	// slices or slice data partitions of a coded picture.  The decoding of an access unit always results in a
	// decoded picture.
	// There is `marker bit` in RTP packet which is set for the very last packet of the access unit indicated by the RTP timestamp.
	// It is protocol violation if received RTP packet has the same timestamp as previous marker bit packet.
	// This counter is a number of RTP packets which `RTP timestamp` is equal to previous RTP marker bit packet.
	SetTSStuck(int) InputRTPCounters
}

// SDI,HDMI and other raw input counters
type InputSdiCounters interface {
	// Gauge of average duration of incoming frame calculated in real time.
	AvgRecvDuration() *int
	// Gauge of average duration of incoming frame calculated in real time.
	SetAvgRecvDuration(int) InputSdiCounters
	// Frames injected to fix client-side SDI stream drift.
	CompensatedFrames() *int
	// Frames injected to fix client-side SDI stream drift.
	SetCompensatedFrames(int) InputSdiCounters
	// Counter of configured audio sdi channels without samples or non valid.
	ErrorLostAudio() *int
	// Counter of configured audio sdi channels without samples or non valid.
	SetErrorLostAudio(int) InputSdiCounters
	// The frame was dropped due to too high CPU load.
	ErrorsCpuStall() *int
	// The frame was dropped due to too high CPU load.
	SetErrorsCpuStall(int) InputSdiCounters
	// Frame data is duplicated from previous frame because the input was too slow.
	ErrorsDuplicate() *int
	// Frame data is duplicated from previous frame because the input was too slow.
	SetErrorsDuplicate(int) InputSdiCounters
	// Frames dropped due to 'No signal'.
	ErrorsNoSignal() *int
	// Frames dropped due to 'No signal'.
	SetErrorsNoSignal(int) InputSdiCounters
	// Frame time is the same as the previous frame.
	ErrorsTSDuplicate() *int
	// Frame time is the same as the previous frame.
	SetErrorsTSDuplicate(int) InputSdiCounters
	// Gauge of maximum deviation from the estimated frame duration.
	PeakDurationDeviation() *int
	// Gauge of maximum deviation from the estimated frame duration.
	SetPeakDurationDeviation(int) InputSdiCounters
}

// SRT specific counters
type InputSrtCounters interface {
	// How many SRT packets were dropped by various reasons
	ErrorDroppedPackets() *int
	// How many SRT packets were dropped by various reasons
	SetErrorDroppedPackets(int) InputSrtCounters
	// How many SRT packets were lost
	ErrorLostPackets() *int
	// How many SRT packets were lost
	SetErrorLostPackets(int) InputSrtCounters
	// Receiver buffering delay
	Latency() *int
	// Receiver buffering delay
	SetLatency(int) InputSrtCounters
	// Total incoming SRT packets counter
	Packets() *int
	// Total incoming SRT packets counter
	SetPackets(int) InputSrtCounters
	// How many packets were retransmitted
	RetransmittedPackets() *int
	// How many packets were retransmitted
	SetRetransmittedPackets(int) InputSrtCounters
	// Round-trip time
	Rtt() *int
	// Round-trip time
	SetRtt(int) InputSrtCounters
}

type InputStats interface {
	// Whether this input is selected as active for the stream.
	// Example: true
	Active() *bool
	// Whether this input is selected as active for the stream.
	// Example: true
	SetActive(bool) InputStats
	// How many Ad markers passed to this stream from the inputs.
	AdSplicesIngested() *int
	// How many Ad markers passed to this stream from the inputs.
	SetAdSplicesIngested(int) InputStats
	// How many Ad markers inserted to this stream by user.
	AdSplicesInserted() *int
	// How many Ad markers inserted to this stream by user.
	SetAdSplicesInserted(int) InputStats
	Agent() InputAgentCounters
	SetAgent(InputAgentCounters) InputStats
	// Number of bytes received by this stream from live sources.
	// It will be counted before transcoding and will sum all inputs working together.
	// Format: bytes (bytes)
	Bytes() *Bytes
	// Number of bytes received by this stream from live sources.
	// It will be counted before transcoding and will sum all inputs working together.
	// Format: bytes (bytes)
	SetBytes(Bytes) InputStats
	// Number of bytes received by this stream when downloading from remote DVR.
	// Format: bytes (bytes)
	BytesDvr() *Bytes
	// Number of bytes received by this stream when downloading from remote DVR.
	// Format: bytes (bytes)
	SetBytesDvr(Bytes) InputStats
	// Indicates that the stream sources have different track sets, which may cause switching problems. The list of tracks to be compared is obtained only when the sources are checked or started, until then the stream is considered normal.
	DivergentInputs() *bool
	// Indicates that the stream sources have different track sets, which may cause switching problems. The list of tracks to be compared is obtained only when the sources are checked or started, until then the stream is considered normal.
	SetDivergentInputs(bool) InputStats
	// Information about DVR that this input has
	DvrInfo() DvrInfo
	// Information about DVR that this input has
	SetDvrInfo(DvrInfo) InputStats
	// Sum of all other specific errors in the last minute
	// Example: 0
	ErrorRate() *int
	// Sum of all other specific errors in the last minute
	// Example: 0
	SetErrorRate(int) InputStats
	// Sum of all other specific errors. Can be used for triggering alert on any error
	// Example: 0
	Errors() *int
	// Sum of all other specific errors. Can be used for triggering alert on any error
	// Example: 0
	SetErrors(int) InputStats
	// How many times we've got 403 (eaccess).
	Errors403() *int
	// How many times we've got 403 (eaccess).
	SetErrors403(int) InputStats
	// How many times we've got 404 (enoent).
	Errors404() *int
	// How many times we've got 404 (enoent).
	SetErrors404(int) InputStats
	// How many times we've got 500 (backend error).
	Errors500() *int
	// How many times we've got 500 (backend error).
	SetErrors500(int) InputStats
	// Demultiplexing was done right, but content is broken.
	ErrorsBrokenPayload() *int
	// Demultiplexing was done right, but content is broken.
	SetErrorsBrokenPayload(int) InputStats
	// How many times input was restarted due to internal crash.
	// This may happen due to unhandled input.
	ErrorsCrashed() *int
	// How many times input was restarted due to internal crash.
	// This may happen due to unhandled input.
	SetErrorsCrashed(int) InputStats
	// Decoder reset count due to abnormal DTS change. Can happen in MPEG-TS, RTP.
	ErrorsDecoderReset() *int
	// Decoder reset count due to abnormal DTS change. Can happen in MPEG-TS, RTP.
	SetErrorsDecoderReset(int) InputStats
	// This can be used as a `TS_sync_loss` - how many times MPEG-TS sync was lost.
	// Also this counter refers to RTSP desync, when camera starts dropping TCP data and
	// we have to find packet boundaries.
	// Here we write count of such resynchronizations.
	ErrorsDesync() *int
	// This can be used as a `TS_sync_loss` - how many times MPEG-TS sync was lost.
	// Also this counter refers to RTSP desync, when camera starts dropping TCP data and
	// we have to find packet boundaries.
	// Here we write count of such resynchronizations.
	SetErrorsDesync(int) InputStats
	// Dropped frames count due timestamp adjustment.
	ErrorsDroppedFrames() *int
	// Dropped frames count due timestamp adjustment.
	SetErrorsDroppedFrames(int) InputStats
	// RTP, MPEG-TS or other protocols have enough information to tell how many packets were lost
	ErrorsLostPackets() *int
	// RTP, MPEG-TS or other protocols have enough information to tell how many packets were lost
	SetErrorsLostPackets(int) InputStats
	// how many times PAT was missing during 0,5 seconds or pid 0 misses PAT
	// `PAT_error`
	ErrorsTSPat() *int
	// how many times PAT was missing during 0,5 seconds or pid 0 misses PAT
	// `PAT_error`
	SetErrorsTSPat(int) InputStats
	// How many times have received PAT that was missing required service (program)
	ErrorsTSServiceLost() *int
	// How many times have received PAT that was missing required service (program)
	SetErrorsTSServiceLost(int) InputStats
	// Number of connection restarts to fix ts_stuck issue. Can happen in RTSP.
	ErrorsTSStuckRestarts() *int
	// Number of connection restarts to fix ts_stuck issue. Can happen in RTSP.
	SetErrorsTSStuckRestarts(int) InputStats
	// Number of frames passed to this stream from the inputs.
	Frames() *int
	// Number of frames passed to this stream from the inputs.
	SetFrames(int) InputStats
	// Aggregated: how many times this stream has switched between different inputs.
	// Individual input: number of times switched to this input.
	InputSwitches() *int
	// Aggregated: how many times this stream has switched between different inputs.
	// Individual input: number of times switched to this input.
	SetInputSwitches(int) InputStats
	// Number of secondary inputs that have some problems.
	// Example: 0
	InvalidSecondaryInputs() *int
	// Number of secondary inputs that have some problems.
	// Example: 0
	SetInvalidSecondaryInputs(int) InputStats
	// IP address of the connected peer.
	// Example: 172.16.25.73
	IP() *string
	// IP address of the connected peer.
	// Example: 172.16.25.73
	SetIP(string) InputStats
	// Technical description of the input content.
	MediaInfo() MediaInfo
	// Technical description of the input content.
	SetMediaInfo(MediaInfo) InputStats
	// Indicates, how often does media_info changes
	MediaInfoChanges() *int
	// Indicates, how often does media_info changes
	SetMediaInfoChanges(int) InputStats
	MotionDetector() InputMotionDetectorCounters
	SetMotionDetector(InputMotionDetectorCounters) InputStats
	// How many seconds has this stream had no frames.
	// Format: seconds (seconds)
	NumSecNoData() *Seconds
	// How many seconds has this stream had no frames.
	// Format: seconds (seconds)
	SetNumSecNoData(Seconds) InputStats
	// How many seconds has this stream played from primary input.
	// Format: seconds (seconds)
	NumSecOnPrimaryInput() *Seconds
	// How many seconds has this stream played from primary input.
	// Format: seconds (seconds)
	SetNumSecOnPrimaryInput(Seconds) InputStats
	// How many seconds has this stream played from secondary inputs.
	// Format: seconds (seconds)
	NumSecOnSecondaryInput() *Seconds
	// How many seconds has this stream played from secondary inputs.
	// Format: seconds (seconds)
	SetNumSecOnSecondaryInput(Seconds) InputStats
	// The time when this session was created.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	OpenedAt() *UtcMs
	// The time when this session was created.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	SetOpenedAt(UtcMs) InputStats
	// Per pid statistics calculated for MPEG-TS input
	Pids() []InputPidCounters
	// Per pid statistics calculated for MPEG-TS input
	SetPids([]InputPidCounters) InputStats
	// Protocol used for the data transmission in the session.
	// Example: dash
	Proto() *Protocol
	// Protocol used for the data transmission in the session.
	// Example: dash
	SetProto(Protocol) InputStats
	// Source may send frames not in the order they should be played. It will be catched and reordered.
	// This counter indicates how many times did it happened.
	ReorderCount() *int
	// Source may send frames not in the order they should be played. It will be catched and reordered.
	// This counter indicates how many times did it happened.
	SetReorderCount(int) InputStats
	// Source may send frames timestamps faster or slower than realtime.
	// Live stream will catch it and resync. This counter indicates how many times did it happened.
	ResyncCountDrift() *int
	// Source may send frames timestamps faster or slower than realtime.
	// Live stream will catch it and resync. This counter indicates how many times did it happened.
	SetResyncCountDrift(int) InputStats
	// Source may change timestamps without any signalling. This counter indicates how bad is the source
	ResyncCountJump() *int
	// Source may change timestamps without any signalling. This counter indicates how bad is the source
	SetResyncCountJump(int) InputStats
	// Stream timestamps are synchronized with real time. This counter tells, how many times
	// it was syncronized after source reconnect.
	ResyncCountNormal() *int
	// Stream timestamps are synchronized with real time. This counter tells, how many times
	// it was syncronized after source reconnect.
	SetResyncCountNormal(int) InputStats
	// How many times has this stream retried to connect to source
	Retries() *int
	// How many times has this stream retried to connect to source
	SetRetries(int) InputStats
	// Per channel statistics calculated for RTP input
	RTPChannels() []InputRTPCounters
	// Per channel statistics calculated for RTP input
	SetRTPChannels([]InputRTPCounters) InputStats
	Sdi() InputSdiCounters
	SetSdi(InputSdiCounters) InputStats
	Srt() InputSrtCounters
	SetSrt(InputSrtCounters) InputStats
	// The time period during which no frames were received from the stream's input.
	// Format: ticks (ticks)
	// Example: 1284
	TSDelay() *Ticks
	// The time period during which no frames were received from the stream's input.
	// Format: ticks (ticks)
	// Example: 1284
	SetTSDelay(Ticks) InputStats
	// The time period during which no frames were received per each track according to `media_info`
	// Example: [1284]
	TSDelayPerTracks() []Ticks
	// The time period during which no frames were received per each track according to `media_info`
	// Example: [1284]
	SetTSDelayPerTracks([]Ticks) InputStats
	// Deprecated field. Will be deleted at 25.03
	// Final URL after redirects.
	// Deprecated because was never actually used.
	// Format: url (url)
	// Example: udp://239.0.0.1:1234
	URL() *URL
	// Deprecated field. Will be deleted at 25.03
	// Final URL after redirects.
	// Deprecated because was never actually used.
	// Format: url (url)
	// Example: udp://239.0.0.1:1234
	SetURL(URL) InputStats
	// Client's user agent for selected protocol.
	// Example: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML. like Gecko) Chrome/90.0.4430.72 Safari/537.36
	UserAgent() *string
	// Client's user agent for selected protocol.
	// Example: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML. like Gecko) Chrome/90.0.4430.72 Safari/537.36
	SetUserAgent(string) InputStats
	// Number of secondary inputs that have no problems.
	// Example: 2
	ValidSecondaryInputs() *int
	// Number of secondary inputs that have no problems.
	// Example: 2
	SetValidSecondaryInputs(int) InputStats
}

type IptvConfig interface {
	// DB connection string.
	Database() *string
	// DB connection string.
	SetDatabase(string) IptvConfig
}

type LetsencryptRequest interface {
	// One or more domain names to issue the Let's Encrypt certificate for.
	Domains() []string
	// One or more domain names to issue the Let's Encrypt certificate for.
	SetDomains([]string) LetsencryptRequest
}

// Required: port
type ListenConfig interface {
	// Network address that will be used for listening.
	// Example: 10.0.35.1
	Address() *string
	// Network address that will be used for listening.
	// Example: 10.0.35.1
	SetAddress(string) ListenConfig
	// Port that will be used for listening.
	// Format: network_port (network_port)
	// Example: 80
	Port() NetworkPort
	// Port that will be used for listening.
	// Format: network_port (network_port)
	// Example: 80
	SetPort(NetworkPort) ListenConfig
}

type ListenHTTPConfig interface {
	// Network address that will be used for listening.
	// Example: 10.0.35.1
	Address() *string
	// Network address that will be used for listening.
	// Example: 10.0.35.1
	SetAddress(string) ListenHTTPConfig
	// Port that will be used for listening.
	// Format: network_port (network_port)
	// Example: 80
	Port() NetworkPort
	// Port that will be used for listening.
	// Format: network_port (network_port)
	// Example: 80
	SetPort(NetworkPort) ListenHTTPConfig
}

type ListenHTTPConfigParams interface {
}

type Listeners interface {
	// List of HTTP ports or `host:port` pairs that will be used for listening.
	// Examples: [map[api:false, port:80]]
	HTTP() []ListenHTTPConfig
	// List of HTTP ports or `host:port` pairs that will be used for listening.
	// Examples: [map[api:false, port:80]]
	SetHTTP([]ListenHTTPConfig) Listeners
}

type LoginInfoAdditional interface {
	// A JWT token with a limited lifetime duration. JWT algorithm is RS256.
	// Example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
	AccessToken() *string
	// A JWT token with a limited lifetime duration. JWT algorithm is RS256.
	// Example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
	SetAccessToken(string) LoginInfoAdditional
	// A token used to get a new access_token after expiration.
	// It works with `/login` request only.
	// Example: 3637e790-5530-11ed-bdc3-0242ac120002
	RefreshToken() *string
	// A token used to get a new access_token after expiration.
	// It works with `/login` request only.
	// Example: 3637e790-5530-11ed-bdc3-0242ac120002
	SetRefreshToken(string) LoginInfoAdditional
}

type LoginInfoBase interface {
	// A JWT token with a limited lifetime duration. JWT algorithm is RS256.
	// Example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
	AccessToken() *string
	// A JWT token with a limited lifetime duration. JWT algorithm is RS256.
	// Example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
	SetAccessToken(string) LoginInfoBase
	// A token used to get a new access_token after expiration.
	// It works with `/login` request only.
	// Example: 3637e790-5530-11ed-bdc3-0242ac120002
	RefreshToken() *string
	// A token used to get a new access_token after expiration.
	// It works with `/login` request only.
	// Example: 3637e790-5530-11ed-bdc3-0242ac120002
	SetRefreshToken(string) LoginInfoBase
}

// mail settings
// Required: sending_method
type MailBase interface {
	// Information about the sender
	Sender() MailBaseSender
	// Information about the sender
	SetSender(MailBaseSender) MailBase
	// the method of sending messages by mail
	// Example: SMTP
	SendingMethod() string
	// the method of sending messages by mail
	// Example: SMTP
	SetSendingMethod(string) MailBase
}

// Information about the sender
type MailBaseSender interface {
	// sender email
	// Example: watcher@someserver.com
	Email() *string
	// sender email
	// Example: watcher@someserver.com
	SetEmail(string) MailBaseSender
	// sender title
	// Example: Flussonic Watcher
	Title() *string
	// sender title
	// Example: Flussonic Watcher
	SetTitle(string) MailBaseSender
}

type MailSendgrid interface {
	// api key for SendGrid
	APIKey() *string
	// api key for SendGrid
	SetAPIKey(string) MailSendgrid
	// Information about the sender
	Sender() MailBaseSender
	// Information about the sender
	SetSender(MailBaseSender) MailSendgrid
	// the method of sending messages by mail
	// Example: SMTP
	SendingMethod() string
	// the method of sending messages by mail
	// Example: SMTP
	SetSendingMethod(string) MailSendgrid
}

type MailSmtp interface {
	// smtp server host
	Host() *string
	// smtp server host
	SetHost(string) MailSmtp
	// login for smtp server
	Login() *string
	// login for smtp server
	SetLogin(string) MailSmtp
	// password for smtp server
	Password() *string
	// password for smtp server
	SetPassword(string) MailSmtp
	// port for smtp server
	Port() *int
	// port for smtp server
	SetPort(int) MailSmtp
	// connecting to the server using TLS/STARTTLS
	Security() *MailSmtpSecurity
	// connecting to the server using TLS/STARTTLS
	SetSecurity(MailSmtpSecurity) MailSmtp
	// Information about the sender
	Sender() MailBaseSender
	// Information about the sender
	SetSender(MailBaseSender) MailSmtp
	// the method of sending messages by mail
	// Example: SMTP
	SendingMethod() string
	// the method of sending messages by mail
	// Example: SMTP
	SetSendingMethod(string) MailSmtp
}

type MailSpec interface {
	// api key for SendGrid
	APIKey() *string
	// api key for SendGrid
	SetAPIKey(string) MailSpec
	// smtp server host
	Host() *string
	// smtp server host
	SetHost(string) MailSpec
	// login for smtp server
	Login() *string
	// login for smtp server
	SetLogin(string) MailSpec
	// password for smtp server
	Password() *string
	// password for smtp server
	SetPassword(string) MailSpec
	// port for smtp server
	Port() *int
	// port for smtp server
	SetPort(int) MailSpec
	// connecting to the server using TLS/STARTTLS
	Security() *MailSmtpSecurity
	// connecting to the server using TLS/STARTTLS
	SetSecurity(MailSmtpSecurity) MailSpec
	// Information about the sender
	Sender() MailBaseSender
	// Information about the sender
	SetSender(MailBaseSender) MailSpec
	// the method of sending messages by mail
	// Example: SMTP
	SendingMethod() string
	// the method of sending messages by mail
	// Example: SMTP
	SetSendingMethod(string) MailSpec
}

// Required: latitude, longitude
type MapSpec interface {
	// Geographic latitude.
	// Example: 55.7512
	Latitude() float64
	// Geographic latitude.
	// Example: 55.7512
	SetLatitude(float64) MapSpec
	// Geographic longitude.
	// Example: 37.6184
	Longitude() float64
	// Geographic longitude.
	// Example: 37.6184
	SetLongitude(float64) MapSpec
}

type MediaInfo interface {
	// Duration of the media, if applicable.
	// Format: ticks (ticks)
	Duration() *Ticks
	// Duration of the media, if applicable.
	// Format: ticks (ticks)
	SetDuration(Ticks) MediaInfo
	// Whether it is a file with a finite start and end time or a live stream.
	// Example: stream
	FlowType() *MediaInfoSpecificFlowType
	// Whether it is a file with a finite start and end time or a live stream.
	// Example: stream
	SetFlowType(MediaInfoSpecificFlowType) MediaInfo
	// The program ID for MPEG TS streams.
	// Example: 110
	ProgramID() *int
	// The program ID for MPEG TS streams.
	// Example: 110
	SetProgramID(int) MediaInfo
	// The media provider of this content.
	// Example: Netflix
	Provider() *string
	// The media provider of this content.
	// Example: Netflix
	SetProvider(string) MediaInfo
	// The identifier of the transport stream for MPEG TS streams.
	// Example: 253
	StreamID() *int
	// The identifier of the transport stream for MPEG TS streams.
	// Example: 253
	SetStreamID(int) MediaInfo
	// Human-readable title of the media.
	// Example: Bunny
	Title() *string
	// Human-readable title of the media.
	// Example: Bunny
	SetTitle(string) MediaInfo
	// Information about available tracks (video, audio, or text).
	Tracks() []TrackInfo
	// Information about available tracks (video, audio, or text).
	SetTracks([]TrackInfo) MediaInfo
}

type MediaInfoCommon interface {
	// The program ID for MPEG TS streams.
	// Example: 110
	ProgramID() *int
	// The program ID for MPEG TS streams.
	// Example: 110
	SetProgramID(int) MediaInfoCommon
	// The media provider of this content.
	// Example: Netflix
	Provider() *string
	// The media provider of this content.
	// Example: Netflix
	SetProvider(string) MediaInfoCommon
	// The identifier of the transport stream for MPEG TS streams.
	// Example: 253
	StreamID() *int
	// The identifier of the transport stream for MPEG TS streams.
	// Example: 253
	SetStreamID(int) MediaInfoCommon
	// Human-readable title of the media.
	// Example: Bunny
	Title() *string
	// Human-readable title of the media.
	// Example: Bunny
	SetTitle(string) MediaInfoCommon
}

type MediaInfoSpecific interface {
	// Duration of the media, if applicable.
	// Format: ticks (ticks)
	Duration() *Ticks
	// Duration of the media, if applicable.
	// Format: ticks (ticks)
	SetDuration(Ticks) MediaInfoSpecific
	// Whether it is a file with a finite start and end time or a live stream.
	// Example: stream
	FlowType() *MediaInfoSpecificFlowType
	// Whether it is a file with a finite start and end time or a live stream.
	// Example: stream
	SetFlowType(MediaInfoSpecificFlowType) MediaInfoSpecific
	// Information about available tracks (video, audio, or text).
	Tracks() []TrackInfo
	// Information about available tracks (video, audio, or text).
	SetTracks([]TrackInfo) MediaInfoSpecific
}

type MultiplexerStats interface {
	// Bitrate of the MPTS stream, configured or autotuned.
	// Format: speed (speed)
	Bitrate() *Speed
	// Bitrate of the MPTS stream, configured or autotuned.
	// Format: speed (speed)
	SetBitrate(Speed) MultiplexerStats
	// The encoded bytes count.
	// Format: bytes (bytes)
	Encoded() *Bytes
	// The encoded bytes count.
	// Format: bytes (bytes)
	SetEncoded(Bytes) MultiplexerStats
	// Number of programs for which EPG is transmitted.
	EpgPrograms() *int
	// Number of programs for which EPG is transmitted.
	SetEpgPrograms(int) MultiplexerStats
	// Number of XMLTV file read errors.
	ErrorsXmltvFile() *int
	// Number of XMLTV file read errors.
	SetErrorsXmltvFile(int) MultiplexerStats
	// Number of XMLTV parse errors.
	ErrorsXmltvParse() *int
	// Number of XMLTV parse errors.
	SetErrorsXmltvParse(int) MultiplexerStats
	// The number of bytes exceeding the allocated bandwidth.
	// Format: bytes (bytes)
	ExceededBytes() *Bytes
	// The number of bytes exceeding the allocated bandwidth.
	// Format: bytes (bytes)
	SetExceededBytes(Bytes) MultiplexerStats
	// The number of PES packets with an instant bitrate boost.
	ExceededFrames() *int
	// The number of PES packets with an instant bitrate boost.
	SetExceededFrames(int) MultiplexerStats
	// The filler packets count.
	Fillers() *int
	// The filler packets count.
	SetFillers(int) MultiplexerStats
	// Encoder is too slow events counter
	LateTicks() *int
	// Encoder is too slow events counter
	SetLateTicks(int) MultiplexerStats
	// The payload bytes count.
	// Format: bytes (bytes)
	Payload() *Bytes
	// The payload bytes count.
	// Format: bytes (bytes)
	SetPayload(Bytes) MultiplexerStats
	// Per pid statistics for MPEG-TS encoding
	Pids() []PushPidCounters
	// Per pid statistics for MPEG-TS encoding
	SetPids([]PushPidCounters) MultiplexerStats
	// Per pid statistics for MPEG-TS encoding
	Programs() []TransponderProgramStats
	// Per pid statistics for MPEG-TS encoding
	SetPrograms([]TransponderProgramStats) MultiplexerStats
	// The stuff packets count.
	Stuffing() *int
	// The stuff packets count.
	SetStuffing(int) MultiplexerStats
	// Number of system traffic packets
	SysPackets() *int
	// Number of system traffic packets
	SetSysPackets(int) MultiplexerStats
	// Counts payload bytes for system traffic, including PSI tables and raw bypass.
	// Format: bytes (bytes)
	SysPayload() *Bytes
	// Counts payload bytes for system traffic, including PSI tables and raw bypass.
	// Format: bytes (bytes)
	SetSysPayload(Bytes) MultiplexerStats
	// Number of NULL packets (PID 0x1FFF) inserted when no data was scheduled on any PID.
	SysStuffingPackets() *int
	// Number of NULL packets (PID 0x1FFF) inserted when no data was scheduled on any PID.
	SetSysStuffingPackets(int) MultiplexerStats
	// The trimmed bytes count.
	// Format: bytes (bytes)
	TrimmedBytes() *Bytes
	// The trimmed bytes count.
	// Format: bytes (bytes)
	SetTrimmedBytes(Bytes) MultiplexerStats
	// The trimmed frames count.
	TrimmedFrames() *int
	// The trimmed frames count.
	SetTrimmedFrames(int) MultiplexerStats
	// Is TS overflowed. True if no stuffing at last time.
	TSOverflow() *bool
	// Is TS overflowed. True if no stuffing at last time.
	SetTSOverflow(bool) MultiplexerStats
}

type OnOff interface {
	Mode() *OnOffMode
	SetMode(OnOffMode) OnOff
}

type OnOffAuto interface {
	Mode() *OnOffAutoMode
	SetMode(OnOffAutoMode) OnOffAuto
}

// Required: id, title
type OrganizationBase interface {
	// Organization identifier.
	// Example: 7
	ID() int
	// Organization identifier.
	// Example: 7
	SetID(int) OrganizationBase
	// Human-readable name of the organization.
	// Example: Example LLC
	Title() string
	// Human-readable name of the organization.
	// Example: Example LLC
	SetTitle(string) OrganizationBase
}

type OrganizationPermissions interface {
	// An indicator of whether the user has control over the persons list in organization.
	// Example: true
	CanEditPersonsLists() *bool
	// An indicator of whether the user has control over the persons list in organization.
	// Example: true
	SetCanEditPersonsLists(bool) OrganizationPermissions
	// An indicator of whether the user has control over the streams.
	// Example: true
	CanEditStreams() *bool
	// An indicator of whether the user has control over the streams.
	// Example: true
	SetCanEditStreams(bool) OrganizationPermissions
	// An indicator of whether the user has control over the users.
	// Example: true
	CanEditUsers() *bool
	// An indicator of whether the user has control over the users.
	// Example: true
	SetCanEditUsers(bool) OrganizationPermissions
	// An indicator of whether the user can view persons list in organization.
	// Example: true
	CanViewPersonsLists() *bool
	// An indicator of whether the user can view persons list in organization.
	// Example: true
	SetCanViewPersonsLists(bool) OrganizationPermissions
	// An indicator of whether the user can view statistics of organization.
	// Example: true
	CanViewStats() *bool
	// An indicator of whether the user can view statistics of organization.
	// Example: true
	SetCanViewStats(bool) OrganizationPermissions
	// An indicator of whether the user can view the streams.
	// Example: true
	CanViewStreams() *bool
	// An indicator of whether the user can view the streams.
	// Example: true
	SetCanViewStreams(bool) OrganizationPermissions
	// Is the user a member of the organization.
	// Example: true
	IsMember() *bool
	// Is the user a member of the organization.
	// Example: true
	SetIsMember(bool) OrganizationPermissions
}

type OrganizationPreset interface {
	// Preset identifier
	// Example: 7
	PresetID() *int
	// Preset identifier
	// Example: 7
	SetPresetID(int) OrganizationPreset
}

type OrganizationStream interface {
	// ID of the organization. Only organization owner or domain administrator could change it.
	// Example: 9
	ID() *int
	// ID of the organization. Only organization owner or domain administrator could change it.
	// Example: 9
	SetID(int) OrganizationStream
	// Title of the organization.
	// Example: Organization 1
	Title() *string
	// Title of the organization.
	// Example: Organization 1
	SetTitle(string) OrganizationStream
}

type OutputMpegtsPids interface {
	// The default algorithm of selecting PID for a track.
	// * `auto`: track PID = PMT PID + track ID,
	// where PMT PID is the PID of Program Map Table and track ID is a number of the track set by Flussonic
	// (usually, all video tracks and then all audio tracks are numbered starting from 1).
	// * `increment`: track PID = previous track PID + 1.
	Default() *string
	// The default algorithm of selecting PID for a track.
	// * `auto`: track PID = PMT PID + track ID,
	// where PMT PID is the PID of Program Map Table and track ID is a number of the track set by Flussonic
	// (usually, all video tracks and then all audio tracks are numbered starting from 1).
	// * `increment`: track PID = previous track PID + 1.
	SetDefault(string) OutputMpegtsPids
	// Information about a particular media track.
	Media() []TransponderPid
	// Information about a particular media track.
	SetMedia([]TransponderPid) OutputMpegtsPids
	// PID of the elementary stream that contains PCR (Program Clock Reference) in the outgoing MPEG-TS stream.
	// PCR is the time label used for synchronization of a stream playback with real time.
	// Additionally, for DVB streams it is used for managing a decoder and its buffer.
	// In this case, PCR gives a signal to the frames with DTS<PCR to be sent to the decoder from the buffer.
	// This mechanism allows to compensate different sizes of frames: if a frame is too big to be played in time with a specified FPS, the frames from the buffer are played.
	Pcr() *int
	// PID of the elementary stream that contains PCR (Program Clock Reference) in the outgoing MPEG-TS stream.
	// PCR is the time label used for synchronization of a stream playback with real time.
	// Additionally, for DVB streams it is used for managing a decoder and its buffer.
	// In this case, PCR gives a signal to the frames with DTS<PCR to be sent to the decoder from the buffer.
	// This mechanism allows to compensate different sizes of frames: if a frame is too big to be played in time with a specified FPS, the frames from the buffer are played.
	SetPcr(int) OutputMpegtsPids
	// PID  of the elementary stream that contains Program Map Table (PMT) in the outgoing MPEG-TS stream.
	// PMT contains the description of each program and lists the PIDs of elementary streams associated with that program.
	// For instance, a transport stream used in digital television might contain three programs, to represent three television channels.
	// Suppose each channel consists of one video stream, one or two audio streams, and any necessary metadata.
	// A receiver wishing to decode one of the three channels merely has to decode the payloads of each PID associated with its program.
	// It can discard the contents of all other PIDs.
	Pmt() *int
	// PID  of the elementary stream that contains Program Map Table (PMT) in the outgoing MPEG-TS stream.
	// PMT contains the description of each program and lists the PIDs of elementary streams associated with that program.
	// For instance, a transport stream used in digital television might contain three programs, to represent three television channels.
	// Suppose each channel consists of one video stream, one or two audio streams, and any necessary metadata.
	// A receiver wishing to decode one of the three channels merely has to decode the payloads of each PID associated with its program.
	// It can discard the contents of all other PIDs.
	SetPmt(int) OutputMpegtsPids
	// PID  of the elementary stream that contains Service Description Table (SDT) in the outgoing MPEG-TS stream.
	// SDT provides information about services contained in MPEG-TS stream.
	Sdt() *int
	// PID  of the elementary stream that contains Service Description Table (SDT) in the outgoing MPEG-TS stream.
	// SDT provides information about services contained in MPEG-TS stream.
	SetSdt(int) OutputMpegtsPids
}

type PartitionStats interface {
	// The block device or file related to a mount path.
	// Format: disk_device (disk_device)
	// Example: sda1
	Device() *DiskDevice
	// The block device or file related to a mount path.
	// Format: disk_device (disk_device)
	// Example: sda1
	SetDevice(DiskDevice) PartitionStats
	// Percentage of IO utilization for device related to a mount path.
	// Format: percent (percent)
	// Example: 42
	IoUtil() *Percent
	// Percentage of IO utilization for device related to a mount path.
	// Format: percent (percent)
	// Example: 42
	SetIoUtil(Percent) PartitionStats
	// Mount path.
	// Format: disk_path (disk_path)
	// Example: _var_lib_docker_overlay2_3684778579db0a4d418fdc1a8a6953b680ab92d179a7d6f9506710d073095e36_merged
	Path() *DiskPath
	// Mount path.
	// Format: disk_path (disk_path)
	// Example: _var_lib_docker_overlay2_3684778579db0a4d418fdc1a8a6953b680ab92d179a7d6f9506710d073095e36_merged
	SetPath(DiskPath) PartitionStats
	// Total number of megabytes shown by the OS for this partition.
	// Format: megabytes (megabytes)
	// Example: 45423
	TotalMb() *Megabytes
	// Total number of megabytes shown by the OS for this partition.
	// Format: megabytes (megabytes)
	// Example: 45423
	SetTotalMb(Megabytes) PartitionStats
	// Percentage of usage of this partition.
	// Format: percent (percent)
	// Example: 30
	Usage() *Percent
	// Percentage of usage of this partition.
	// Format: percent (percent)
	// Example: 30
	SetUsage(Percent) PartitionStats
}

type PeerConfig interface {
	// The URL for provisioning of configuration from the managing server to the streamer.
	// This URL does not have to be public but must be accessible from the managing server.
	// The API URL can also be used as Public and/or Private payload URL if they are not set.
	// When used as Public payload URL, the API URL shall be public to allow playback from this streamer.
	// Format: url (url)
	// Example: http://streamer.local:8080
	APIURL() *URL
	// The URL for provisioning of configuration from the managing server to the streamer.
	// This URL does not have to be public but must be accessible from the managing server.
	// The API URL can also be used as Public and/or Private payload URL if they are not set.
	// When used as Public payload URL, the API URL shall be public to allow playback from this streamer.
	// Format: url (url)
	// Example: http://streamer.local:8080
	SetAPIURL(URL) PeerConfig
	// Maximal number of streams.
	// Example: 5
	ChannelLimit() *int
	// Maximal number of streams.
	// Example: 5
	SetChannelLimit(int) PeerConfig
	// The key for authorization for inter-Flussonic connections.
	// All cluster peers should have the same cluster key.
	// Example: xS6i6Q3DCc5nEvnu
	ClusterKey() *string
	// The key for authorization for inter-Flussonic connections.
	// All cluster peers should have the same cluster key.
	// Example: xS6i6Q3DCc5nEvnu
	SetClusterKey(string) PeerConfig
	// Streamer's identifier in the cluster.
	// The managing server may try using this hostname to access the streamer
	// if API URL is not specified.
	// Format: server_name (server_name)
	// Example: peer.example.com
	Hostname() *ServerName
	// Streamer's identifier in the cluster.
	// The managing server may try using this hostname to access the streamer
	// if API URL is not specified.
	// Format: server_name (server_name)
	// Example: peer.example.com
	SetHostname(ServerName) PeerConfig
	// Statistics on peers in the cluster.
	Stats() PeerStats
	// Statistics on peers in the cluster.
	SetStats(PeerStats) PeerConfig
}

type PeerStats interface {
	// Outbound bandwidth usage (load balancing in `usage` mode is based on this value).
	// Format: percent (percent)
	// Example: 67
	BandwidthUsage() *Percent
	// Outbound bandwidth usage (load balancing in `usage` mode is based on this value).
	// Format: percent (percent)
	// Example: 67
	SetBandwidthUsage(Percent) PeerStats
	// Build version
	Build() *int
	// Build version
	SetBuild(int) PeerStats
	// Information about errors in the config file.
	ConfigError() ConfigErrorStatus
	// Information about errors in the config file.
	SetConfigError(ConfigErrorStatus) PeerStats
	// Information about current external config status
	ConfigExternalStatus() ConfigExternalErrorStatus
	// Information about current external config status
	SetConfigExternalStatus(ConfigExternalErrorStatus) PeerStats
	// Current runtime version of config. We do not declare exact structure, but we promise
	// that it will be always comparable and increasing (if server has proper NTP configuration, of course).
	// Right now it is a tuple of server start time and incrementing version of config.
	// Example: [1.636709231e+09 4]
	ConfigVersion() []int
	// Current runtime version of config. We do not declare exact structure, but we promise
	// that it will be always comparable and increasing (if server has proper NTP configuration, of course).
	// Right now it is a tuple of server start time and incrementing version of config.
	// Example: [1.636709231e+09 4]
	SetConfigVersion([]int) PeerStats
	// CPU usage on the server.
	// Format: percent (percent)
	// Example: 48
	CpuUsage() *Percent
	// CPU usage on the server.
	// Format: percent (percent)
	// Example: 48
	SetCpuUsage(Percent) PeerStats
	// Description of an error, if any.
	Error() *string
	// Description of an error, if any.
	SetError(string) PeerStats
	// Hostname of your server. Please, use FQDN, do not leave your Linux misconfigured.
	// Example: openapi.flussonic.com
	Hostname() *string
	// Hostname of your server. Please, use FQDN, do not leave your Linux misconfigured.
	// Example: openapi.flussonic.com
	SetHostname(string) PeerStats
	// Unique runtime ID of this instance. Updated with the restart.
	// Format: uuid (uuid)
	// Example: 61893b15-75b2-4fcb-b4cf-ae1dd0858ea2
	ID() *UUID
	// Unique runtime ID of this instance. Updated with the restart.
	// Format: uuid (uuid)
	// Example: 61893b15-75b2-4fcb-b4cf-ae1dd0858ea2
	SetID(UUID) PeerStats
	// Current incoming speed (bitrate) of the data transmission over the network.
	// Format: speed (speed)
	// Example: 400300
	InputKbit() *Speed
	// Current incoming speed (bitrate) of the data transmission over the network.
	// Format: speed (speed)
	// Example: 400300
	SetInputKbit(Speed) PeerStats
	// The flag shows if Flussonic runs on Flussonic Coder.
	IsChassis() *bool
	// The flag shows if Flussonic runs on Flussonic Coder.
	SetIsChassis(bool) PeerStats
	// The code of the license applied on the server.
	// Example: uO8v12HJhNXVj5gM
	LicenseTxt() *string
	// The code of the license applied on the server.
	// Example: uO8v12HJhNXVj5gM
	SetLicenseTxt(string) PeerStats
	// The license type.
	LicenseType() *LicenseType
	// The license type.
	SetLicenseType(LicenseType) PeerStats
	// Memory usage on the server.
	// Format: percent (percent)
	// Example: 27
	MemoryUsage() *Percent
	// Memory usage on the server.
	// Format: percent (percent)
	// Example: 27
	SetMemoryUsage(Percent) PeerStats
	// Notification about a newer version in the repository.
	// Format: server_version (server_version)
	// Example: 22.01
	NextVersion() *ServerVersion
	// Notification about a newer version in the repository.
	// Format: server_version (server_version)
	// Example: 22.01
	SetNextVersion(ServerVersion) PeerStats
	// Current response time
	// Format: utc_ms (Unix timestamp in milliseconds)
	Now() *UtcMs
	// Current response time
	// Format: utc_ms (Unix timestamp in milliseconds)
	SetNow(UtcMs) PeerStats
	// The number of streams that are ready to be served to the clients.
	// Example: 27
	OnlineStreams() *int
	// The number of streams that are ready to be served to the clients.
	// Example: 27
	SetOnlineStreams(int) PeerStats
	// The number of opened files.
	// Example: 5
	OpenedFiles() *int
	// The number of opened files.
	// Example: 5
	SetOpenedFiles(int) PeerStats
	// Current outgoing speed (bitrate) of the data transmission over the network.
	// Format: speed (speed)
	// Example: 500400
	OutputKbit() *Speed
	// Current outgoing speed (bitrate) of the data transmission over the network.
	// Format: speed (speed)
	// Example: 500400
	SetOutputKbit(Speed) PeerStats
	// The list of disk partitions on the server.
	Partitions() []PartitionStats
	// The list of disk partitions on the server.
	SetPartitions([]PartitionStats) PeerStats
	// Predictions of future stats based on the current state of the cluster.
	Predictions() PeerStatsPredictions
	// Predictions of future stats based on the current state of the cluster.
	SetPredictions(PeerStatsPredictions) PeerStats
	// Shows if rproxy is configured.
	Rproxy() *bool
	// Shows if rproxy is configured.
	SetRproxy(bool) PeerStats
	// Shows if rproxy is running.
	RproxyRunning() *bool
	// Shows if rproxy is running.
	SetRproxyRunning(bool) PeerStats
	// Erlang scheduler load.
	// Format: percent (percent)
	// Example: 40
	SchedulerLoad() *Percent
	// Erlang scheduler load.
	// Format: percent (percent)
	// Example: 40
	SetSchedulerLoad(Percent) PeerStats
	// Package version of the server. Might be simple a number of release like 21.11 or longer if you have a rolling release installed.
	// Format: server_version (server_version)
	// Example: 23.04
	ServerVersion() *ServerVersion
	// Package version of the server. Might be simple a number of release like 21.11 or longer if you have a rolling release installed.
	// Format: server_version (server_version)
	// Example: 23.04
	SetServerVersion(ServerVersion) PeerStats
	// Boot time of this instance.
	// Format: utc (Unix timestamp in seconds)
	// Example: 1.639337825e+09
	StartedAt() *Utc
	// Boot time of this instance.
	// Format: utc (Unix timestamp in seconds)
	// Example: 1.639337825e+09
	SetStartedAt(Utc) PeerStats
	// *Flussonic* will always try to start even if there are severe errors that do not
	// allow functioning.
	// `starting` status means you should wait for some time (not more than
	// a minute).
	// `running` status means all configuration was loaded. However, the status does not provide
	// an information about your streams and the quality of provided service.
	// All other statuses mean there are some severe problems on the server
	// that cannot be repaired by Flussonic itself.
	StreamerStatus() *ServerStatsStreamerStatus
	// *Flussonic* will always try to start even if there are severe errors that do not
	// allow functioning.
	// `starting` status means you should wait for some time (not more than
	// a minute).
	// `running` status means all configuration was loaded. However, the status does not provide
	// an information about your streams and the quality of provided service.
	// All other statuses mean there are some severe problems on the server
	// that cannot be repaired by Flussonic itself.
	SetStreamerStatus(ServerStatsStreamerStatus) PeerStats
	// Human-readable format of errors and alerts that need to be fixed.
	// Provided by some *Flussonic* subsystems.
	TextAlerts() map[string]string
	// Human-readable format of errors and alerts that need to be fixed.
	// Provided by some *Flussonic* subsystems.
	SetTextAlerts(map[string]string) PeerStats
	// Deprecated field. Will be deleted at 22.03
	// Total server bandwidth.
	// Format: speed (speed)
	TotalBandwidth() *Speed
	// Deprecated field. Will be deleted at 22.03
	// Total server bandwidth.
	// Format: speed (speed)
	SetTotalBandwidth(Speed) PeerStats
	// The number of clients receiving the streams from the server at the moment of request.
	// Example: 2040
	TotalClients() *int
	// The number of clients receiving the streams from the server at the moment of request.
	// Example: 2040
	SetTotalClients(int) PeerStats
	// The number of streams created on the server.
	// Example: 45
	TotalStreams() *int
	// The number of streams created on the server.
	// Example: 45
	SetTotalStreams(int) PeerStats
	// Shows if the server's CPU can be used for transcoding
	// (i.e. if the `flussonic-transcoder` package is installed on the server).
	Transcoder() *bool
	// Shows if the server's CPU can be used for transcoding
	// (i.e. if the `flussonic-transcoder` package is installed on the server).
	SetTranscoder(bool) PeerStats
	// Statistics on the devices used for transcoding.
	TranscoderDevices() []TranscoderDeviceStats
	// Statistics on the devices used for transcoding.
	SetTranscoderDevices([]TranscoderDeviceStats) PeerStats
	// The server uptime.
	// Format: seconds (seconds)
	// Example: 4.325502e+06
	Uptime() *Seconds
	// The server uptime.
	// Format: seconds (seconds)
	// Example: 4.325502e+06
	SetUptime(Seconds) PeerStats
	// Shows if Flussonic Watcher is enabled in the license.
	Vsaas() *bool
	// Shows if Flussonic Watcher is enabled in the license.
	SetVsaas(bool) PeerStats
	// Shows if Watcher branding is enabled in the license.
	VsaasBranding() *bool
	// Shows if Watcher branding is enabled in the license.
	SetVsaasBranding(bool) PeerStats
	// Shows if Watcher is currently running.
	VsaasRunning() *bool
	// Shows if Watcher is currently running.
	SetVsaasRunning(bool) PeerStats
}

// Predictions of future stats based on the current state of the cluster.
type PeerStatsPredictions interface {
	Disk() CentralDiskPredictions
	SetDisk(CentralDiskPredictions) PeerStatsPredictions
}

type PlayProtocolsSpec interface {
	// Whether to allow or deny API requests, depending on the `whitelist` properties.
	API() *bool
	// Whether to allow or deny API requests, depending on the `whitelist` properties.
	SetAPI(bool) PlayProtocolsSpec
	// Whether to allow or deny an LL-HLS stream playback, depending on the `whitelist` properties.
	Cmaf() *bool
	// Whether to allow or deny an LL-HLS stream playback, depending on the `whitelist` properties.
	SetCmaf(bool) PlayProtocolsSpec
	// Whether to allow or deny a DASH stream playback, depending on the `whitelist` properties.
	Dash() *bool
	// Whether to allow or deny a DASH stream playback, depending on the `whitelist` properties.
	SetDash(bool) PlayProtocolsSpec
	// Whether to allow or deny an HLS stream playback, depending on the `whitelist` properties.
	Hls() *bool
	// Whether to allow or deny an HLS stream playback, depending on the `whitelist` properties.
	SetHls(bool) PlayProtocolsSpec
	// Whether to allow or deny delivering JPEG thumbnails over HTTP(S), depending on the `whitelist` properties.
	Jpeg() *bool
	// Whether to allow or deny delivering JPEG thumbnails over HTTP(S), depending on the `whitelist` properties.
	SetJpeg(bool) PlayProtocolsSpec
	// Whether to allow or deny an M4F stream playback, depending on the `whitelist` properties.
	M4f() *bool
	// Whether to allow or deny an M4F stream playback, depending on the `whitelist` properties.
	SetM4f(bool) PlayProtocolsSpec
	// Whether to allow or deny an M4S stream playback, depending on the `whitelist` properties.
	M4s() *bool
	// Whether to allow or deny an M4S stream playback, depending on the `whitelist` properties.
	SetM4s(bool) PlayProtocolsSpec
	// Whether to allow or deny an MP4 file download over HTTP(S), depending on the `whitelist` properties.
	// Used to export DVR segment(s) in MP4 file.
	Mp4() *bool
	// Whether to allow or deny an MP4 file download over HTTP(S), depending on the `whitelist` properties.
	// Used to export DVR segment(s) in MP4 file.
	SetMp4(bool) PlayProtocolsSpec
	// Whether to allow or deny an MSE-LD stream playback, depending on the `whitelist` properties.
	Mseld() *bool
	// Whether to allow or deny an MSE-LD stream playback, depending on the `whitelist` properties.
	SetMseld(bool) PlayProtocolsSpec
	// Whether to allow or deny an MSS stream playback, depending on the `whitelist` properties.
	Mss() *bool
	// Whether to allow or deny an MSS stream playback, depending on the `whitelist` properties.
	SetMss(bool) PlayProtocolsSpec
	// Whether to allow or deny playback in embed.html, depending on the `whitelist` properties.
	Player() *bool
	// Whether to allow or deny playback in embed.html, depending on the `whitelist` properties.
	SetPlayer(bool) PlayProtocolsSpec
	// Whether to allow or deny an RTMP stream playback, depending on the `whitelist` properties.
	Rtmp() *bool
	// Whether to allow or deny an RTMP stream playback, depending on the `whitelist` properties.
	SetRtmp(bool) PlayProtocolsSpec
	// Whether to allow or deny an RTSP stream playback, depending on the `whitelist` properties.
	Rtsp() *bool
	// Whether to allow or deny an RTSP stream playback, depending on the `whitelist` properties.
	SetRtsp(bool) PlayProtocolsSpec
	// Whether to allow or deny a SHOUTcast/Icecast stream playback, depending on the `whitelist` properties.
	Shoutcast() *bool
	// Whether to allow or deny a SHOUTcast/Icecast stream playback, depending on the `whitelist` properties.
	SetShoutcast(bool) PlayProtocolsSpec
	// Whether to allow or deny an SRT stream playback, depending on the `whitelist` properties.
	Srt() *bool
	// Whether to allow or deny an SRT stream playback, depending on the `whitelist` properties.
	SetSrt(bool) PlayProtocolsSpec
	// Whether to allow or deny an MPEG-TS stream playback over HTTP(S), depending on the `whitelist` properties.
	Tshttp() *bool
	// Whether to allow or deny an MPEG-TS stream playback over HTTP(S), depending on the `whitelist` properties.
	SetTshttp(bool) PlayProtocolsSpec
	// Whether to allow or deny an WebRTC stream playback, depending on the `whitelist` properties.
	Webrtc() *bool
	// Whether to allow or deny an WebRTC stream playback, depending on the `whitelist` properties.
	SetWebrtc(bool) PlayProtocolsSpec
	// - If set to `True`, server **allows** a playback only for listed protocols;
	// - If set to `False`, server **forbids** a playback only for listed protocols;
	Whitelist() *bool
	// - If set to `True`, server **allows** a playback only for listed protocols;
	// - If set to `False`, server **forbids** a playback only for listed protocols;
	SetWhitelist(bool) PlayProtocolsSpec
}

// Required: id, title
type Preset interface {
	// When this preset was marked as deleted
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637095014573e+12
	DeletedAt() *UtcMs
	// When this preset was marked as deleted
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637095014573e+12
	SetDeletedAt(UtcMs) Preset
	// DVR configuration
	Dvr() StreamDvrSpec
	// DVR configuration
	SetDvr(StreamDvrSpec) Preset
	// Preset identifier
	// Example: 7
	ID() int
	// Preset identifier
	// Example: 7
	SetID(int) Preset
	// Shows if the preset is adjustable.
	// ```is_adjustable``` is needed for a situation where presets are managed by external billing.
	// If ```is_adjustable: true``` user can change camera settings meanwhile using this preset.
	// If ```is_adjustable: false``` user can not change camera settings meanwhile using this preset.
	// If the camera has a non-adjustable presets, the DVR and analytics parameters from PUT requests will not be applied.
	// In this case, either make the preset adjustable, or change the preset itself to achieve the required configuration.
	// Example: true
	IsAdjustable() *bool
	// Shows if the preset is adjustable.
	// ```is_adjustable``` is needed for a situation where presets are managed by external billing.
	// If ```is_adjustable: true``` user can change camera settings meanwhile using this preset.
	// If ```is_adjustable: false``` user can not change camera settings meanwhile using this preset.
	// If the camera has a non-adjustable presets, the DVR and analytics parameters from PUT requests will not be applied.
	// In this case, either make the preset adjustable, or change the preset itself to achieve the required configuration.
	// Example: true
	SetIsAdjustable(bool) Preset
	// Shows if the preset is available in all Organizations.
	IsDefault() *bool
	// Shows if the preset is available in all Organizations.
	SetIsDefault(bool) Preset
	// Information about the latest changes made to the preset configuration.
	LastChange() PresetLastChange
	// Information about the latest changes made to the preset configuration.
	SetLastChange(PresetLastChange) Preset
	// Zone configuration that will be applied to all new cameras when this preset is selected.
	// If at least one zone with the specified name does not exist at the time of camera creation, the camera creation will fail.
	// This field does not follow adjustable or non-adjustable rules.
	// This zone configuration will be applied only to new cameras.
	// When updating layout_rules in a preset, cameras linked to this preset will not update their layout_rules.
	LayoutRules() StreamZoneConfig
	// Zone configuration that will be applied to all new cameras when this preset is selected.
	// If at least one zone with the specified name does not exist at the time of camera creation, the camera creation will fail.
	// This field does not follow adjustable or non-adjustable rules.
	// This zone configuration will be applied only to new cameras.
	// When updating layout_rules in a preset, cameras linked to this preset will not update their layout_rules.
	SetLayoutRules(StreamZoneConfig) Preset
	// Statistics of the preset.
	Stats() PresetStats
	// Statistics of the preset.
	SetStats(PresetStats) Preset
	// Human-readable name of the preset.
	// Example: Example preset name
	Title() string
	// Human-readable name of the preset.
	// Example: Example preset name
	SetTitle(string) Preset
	// Vision configuration
	Vision() VisionSpecPresets
	// Vision configuration
	SetVision(VisionSpecPresets) Preset
}

type PresetLastChange interface {
	// The time when the last changes were made.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.672531199e+12
	UpdatedAt() *UtcMs
	// The time when the last changes were made.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.672531199e+12
	SetUpdatedAt(UtcMs) PresetLastChange
	// Information about the user who modified.
	User() PresetLastChangeUser
	// Information about the user who modified.
	SetUser(PresetLastChangeUser) PresetLastChange
}

// Information about the user who modified.
type PresetLastChangeUser interface {
	// Identifier of the user.
	// Example: 1
	ID() *int
	// Identifier of the user.
	// Example: 1
	SetID(int) PresetLastChangeUser
	// User name (login)
	// Example: admin
	Name() *string
	// User name (login)
	// Example: admin
	SetName(string) PresetLastChangeUser
}

// Statistics of the preset.
type PresetStats interface {
	// Count of organizations are currently using this preset.
	// Example: 12
	OrganizationsCount() *int
	// Count of organizations are currently using this preset.
	// Example: 12
	SetOrganizationsCount(int) PresetStats
	// Count of streams are currently using this preset.
	// Example: 12
	StreamsCount() *int
	// Count of streams are currently using this preset.
	// Example: 12
	SetStreamsCount(int) PresetStats
}

type PresetsList interface {
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	EstimatedCount() *int
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	SetEstimatedCount(int) PresetsList
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	Next() *string
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	SetNext(string) PresetsList
	// List of presets.
	Presets() []Preset
	// List of presets.
	SetPresets([]Preset) PresetsList
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	Prev() *string
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	SetPrev(string) PresetsList
	// An object with a list of different timings measured during this API call.
	Timing() any
	// An object with a list of different timings measured during this API call.
	SetTiming(any) PresetsList
	// Collection returns the collection items
	Collection() []Preset
}

type PushCounters interface {
	// Total amount of bytes sent since the pusher was created.
	// Format: bytes (bytes)
	Bytes() *Bytes
	// Total amount of bytes sent since the pusher was created.
	// Format: bytes (bytes)
	SetBytes(Bytes) PushCounters
	// The encoded bytes count.
	// Format: bytes (bytes)
	EncodedBytes() *Bytes
	// The encoded bytes count.
	// Format: bytes (bytes)
	SetEncodedBytes(Bytes) PushCounters
	// How many times we've got 401 (unauthorized).
	Errors401() *int
	// How many times we've got 401 (unauthorized).
	SetErrors401(int) PushCounters
	// How many times we've got 403 (forbidden).
	Errors403() *int
	// How many times we've got 403 (forbidden).
	SetErrors403(int) PushCounters
	// How many times we've got 404 (enoent).
	Errors404() *int
	// How many times we've got 404 (enoent).
	SetErrors404(int) PushCounters
	// How many times we've got 409 (double_publish_denied).
	Errors409() *int
	// How many times we've got 409 (double_publish_denied).
	SetErrors409(int) PushCounters
	// How many times we've got 500 (server_error).
	Errors500() *int
	// How many times we've got 500 (server_error).
	SetErrors500(int) PushCounters
	// Number of errors during of audio frame decoding to raw format.
	ErrorsAudioFrameDecode() *int
	// Number of errors during of audio frame decoding to raw format.
	SetErrorsAudioFrameDecode(int) PushCounters
	// How many times pusher unexpectedly lost connection with peer
	ErrorsConnectionLost() *int
	// How many times pusher unexpectedly lost connection with peer
	SetErrorsConnectionLost(int) PushCounters
	// How many times internal device buffer was overflowed.
	ErrorsDeviceBufferOverflow() *int
	// How many times internal device buffer was overflowed.
	SetErrorsDeviceBufferOverflow(int) PushCounters
	// How much times pusher was unable to open (attach to) device for pushing
	ErrorsDeviceNotOpened() *int
	// How much times pusher was unable to open (attach to) device for pushing
	SetErrorsDeviceNotOpened(int) PushCounters
	// Number of dropped frames
	ErrorsDroppedFrames() *int
	// Number of dropped frames
	SetErrorsDroppedFrames(int) PushCounters
	// Number of dropped segments
	ErrorsDroppedSegments() *int
	// Number of dropped segments
	SetErrorsDroppedSegments(int) PushCounters
	// How many times pusher did not establish connection because of destination peer is not reached
	ErrorsNoDestination() *int
	// How many times pusher did not establish connection because of destination peer is not reached
	SetErrorsNoDestination(int) PushCounters
	// How many times pusher did not establish connection because of missing or wrong credentials
	ErrorsNotAuthorized() *int
	// How many times pusher did not establish connection because of missing or wrong credentials
	SetErrorsNotAuthorized(int) PushCounters
	// How many times pusher was stopped because of redirect limit is reached
	ErrorsRedirectLimit() *int
	// How many times pusher was stopped because of redirect limit is reached
	SetErrorsRedirectLimit(int) PushCounters
	// How many times pusher was stopped due to overload
	ErrorsStopOverloaded() *int
	// How many times pusher was stopped due to overload
	SetErrorsStopOverloaded(int) PushCounters
	// How many times pusher got TLS errors.
	ErrorsTls() *int
	// How many times pusher got TLS errors.
	SetErrorsTls(int) PushCounters
	// Number of errors during of video frame decoding to raw format.
	ErrorsVideoFrameDecode() *int
	// Number of errors during of video frame decoding to raw format.
	SetErrorsVideoFrameDecode(int) PushCounters
	// Number of frames sent by this pusher.
	Frames() *int
	// Number of frames sent by this pusher.
	SetFrames(int) PushCounters
	// SDI card output clock-lock state.
	GenlockStatus() *GenlockStatus
	// SDI card output clock-lock state.
	SetGenlockStatus(GenlockStatus) PushCounters
	// SDI card reference port (Ref In Port) status.
	GenrefStatus() GenrefStatus
	// SDI card reference port (Ref In Port) status.
	SetGenrefStatus(GenrefStatus) PushCounters
	// The time in milliseconds when the pusher instance was created.
	// Format: utc_ms (Unix timestamp in milliseconds)
	OpenedAt() *UtcMs
	// The time in milliseconds when the pusher instance was created.
	// Format: utc_ms (Unix timestamp in milliseconds)
	SetOpenedAt(UtcMs) PushCounters
	// Per pid statistics for MPEG-TS encoding calculated for the pusher
	Pids() []PushPidCounters
	// Per pid statistics for MPEG-TS encoding calculated for the pusher
	SetPids([]PushPidCounters) PushCounters
	// How many times there were no data to push in pusher queue
	PusherQueueExhaustedCount() *int
	// How many times there were no data to push in pusher queue
	SetPusherQueueExhaustedCount(int) PushCounters
	// How many times pusher was restarted
	PusherRestarts() *int
	// How many times pusher was restarted
	SetPusherRestarts(int) PushCounters
	// Number of retries since the last successful push.
	ResentPackets() *int
	// Number of retries since the last successful push.
	SetResentPackets(int) PushCounters
	// Number of segments sent by this pusher.
	Segments() *int
	// Number of segments sent by this pusher.
	SetSegments(int) PushCounters
	// State of the standby push.
	StandbyStatus() *PusherStandbyStatus
	// State of the standby push.
	SetStandbyStatus(PusherStandbyStatus) PushCounters
	// State of the push session.
	Status() *PusherStatus
	// State of the push session.
	SetStatus(*PusherStatus) PushCounters
	// Deprecated field. Will be deleted at 26.03
	// The fillers bytes count for system traffic. Currently this field is always zero.
	// Format: bytes (bytes)
	SysFillersBytes() *Bytes
	// Deprecated field. Will be deleted at 26.03
	// The fillers bytes count for system traffic. Currently this field is always zero.
	// Format: bytes (bytes)
	SetSysFillersBytes(Bytes) PushCounters
	// The payload bytes count for system traffic.
	// Format: bytes (bytes)
	SysPayloadBytes() *Bytes
	// The payload bytes count for system traffic.
	// Format: bytes (bytes)
	SetSysPayloadBytes(Bytes) PushCounters
	// The stuff packets count for system traffic.
	SysStuffingPackets() *int
	// The stuff packets count for system traffic.
	SetSysStuffingPackets(int) PushCounters
	// Obfuscated URL where to push to
	// Format: input_url (input_url)
	URL() *InputURL
	// Obfuscated URL where to push to
	// Format: input_url (input_url)
	SetURL(InputURL) PushCounters
}

// Required: pid
type PushPidCounters interface {
	// Bitrate on this PID, configured or autotuned.
	// Format: speed (speed)
	Bitrate() *Speed
	// Bitrate on this PID, configured or autotuned.
	// Format: speed (speed)
	SetBitrate(Speed) PushPidCounters
	// Content of the track (e.g. audio, video, text).
	Content() *FrameContent
	// Content of the track (e.g. audio, video, text).
	SetContent(FrameContent) PushPidCounters
	// Number of times a frame was dropped on this PID due to DTS going backward.
	// Each such event currently triggers a full program reset.
	ErrorsDtsGoesBackward() *int
	// Number of times a frame was dropped on this PID due to DTS going backward.
	// Each such event currently triggers a full program reset.
	SetErrorsDtsGoesBackward(int) PushPidCounters
	// Number of times a frame was dropped on this PID due to a forward DTS jump.
	// Each such event currently triggers a full program reset.
	ErrorsDtsJumpsForward() *int
	// Number of times a frame was dropped on this PID due to a forward DTS jump.
	// Each such event currently triggers a full program reset.
	SetErrorsDtsJumpsForward(int) PushPidCounters
	// Number of times this PID was dropped from the output multiplexed stream (e.g., due to prebuffer exhaustion).
	ErrorsPidOff() *int
	// Number of times this PID was dropped from the output multiplexed stream (e.g., due to prebuffer exhaustion).
	SetErrorsPidOff(int) PushPidCounters
	// Number of PID start errors caused by DTS values too far in the future.
	// Each such event currently triggers a full program reset.
	ErrorsStartFutureDts() *int
	// Number of PID start errors caused by DTS values too far in the future.
	// Each such event currently triggers a full program reset.
	SetErrorsStartFutureDts(int) PushPidCounters
	// Number of PID start errors caused by late DTS.
	// Each such event currently triggers a full program reset.
	ErrorsStartLateDts() *int
	// Number of PID start errors caused by late DTS.
	// Each such event currently triggers a full program reset.
	SetErrorsStartLateDts(int) PushPidCounters
	// Number of times a frame was received on an unconfigured PID.
	// Usually occurs after reconfiguration.
	ErrorsUnconfiguredQueue() *int
	// Number of times a frame was received on an unconfigured PID.
	// Usually occurs after reconfiguration.
	SetErrorsUnconfiguredQueue(int) PushPidCounters
	// The number of bytes exceeding the allocated bandwidth.
	// Format: bytes (bytes)
	ExceededBytes() *Bytes
	// The number of bytes exceeding the allocated bandwidth.
	// Format: bytes (bytes)
	SetExceededBytes(Bytes) PushPidCounters
	// The number of PES packets with an instant bitrate boost.
	ExceededFrames() *int
	// The number of PES packets with an instant bitrate boost.
	SetExceededFrames(int) PushPidCounters
	// How many MPEG-TS packets with NAL fillers on this PID produced.
	FillerPackets() *int
	// How many MPEG-TS packets with NAL fillers on this PID produced.
	SetFillerPackets(int) PushPidCounters
	// Deprecated field. Will be deleted at 25.11
	// The filler bytes count.
	// Use `filler_packets` instead.
	// Format: bytes (bytes)
	Fillers() *Bytes
	// Deprecated field. Will be deleted at 25.11
	// The filler bytes count.
	// Use `filler_packets` instead.
	// Format: bytes (bytes)
	SetFillers(Bytes) PushPidCounters
	// Deprecated field. Will be deleted at 25.11
	// How many bytes were seen in NAL fillers.
	// Use `filler_packets` instead.
	// Format: bytes (bytes)
	FillersBytes() *Bytes
	// Deprecated field. Will be deleted at 25.11
	// How many bytes were seen in NAL fillers.
	// Use `filler_packets` instead.
	// Format: bytes (bytes)
	SetFillersBytes(Bytes) PushPidCounters
	// Highest recorded level of the TS buffer.
	// With too big values the HRD buffer may be filling up completely (overflow).
	// Format: milliseconds (milliseconds)
	MaxBuffer() *Milliseconds
	// Highest recorded level of the TS buffer.
	// With too big values the HRD buffer may be filling up completely (overflow).
	// Format: milliseconds (milliseconds)
	SetMaxBuffer(Milliseconds) PushPidCounters
	// Lowest recorded level of the TS buffer.
	// With too small values the HRD buffer may be completely empty (underflow).
	// Format: milliseconds (milliseconds)
	MinBuffer() *Milliseconds
	// Lowest recorded level of the TS buffer.
	// With too small values the HRD buffer may be completely empty (underflow).
	// Format: milliseconds (milliseconds)
	SetMinBuffer(Milliseconds) PushPidCounters
	// How many MPEG-TS packets with 188 bytes on this PID produced.
	Packets() *int
	// How many MPEG-TS packets with 188 bytes on this PID produced.
	SetPackets(int) PushPidCounters
	// Deprecated field. Will be deleted at 25.11
	// The payload bytes count.
	// Use `payload_bytes` instead.
	// Format: bytes (bytes)
	Payload() *Bytes
	// Deprecated field. Will be deleted at 25.11
	// The payload bytes count.
	// Use `payload_bytes` instead.
	// Format: bytes (bytes)
	SetPayload(Bytes) PushPidCounters
	// The payload bytes count.
	// Format: bytes (bytes)
	PayloadBytes() *Bytes
	// The payload bytes count.
	// Format: bytes (bytes)
	SetPayloadBytes(Bytes) PushPidCounters
	// Related MPEG-TS PID.
	Pid() int
	// Related MPEG-TS PID.
	SetPid(int) PushPidCounters
	// Program ID this PID belongs to.
	Pnr() *int
	// Program ID this PID belongs to.
	SetPnr(int) PushPidCounters
	// Deprecated field. Will be deleted at 25.11
	// The stuff packets count.
	// Use `stuffing_packets` instead.
	Stuffing() *int
	// Deprecated field. Will be deleted at 25.11
	// The stuff packets count.
	// Use `stuffing_packets` instead.
	SetStuffing(int) PushPidCounters
	// How many NULL packets (PID 0x1FFF) inserted when no data is scheduled on this PID.
	StuffingPackets() *int
	// How many NULL packets (PID 0x1FFF) inserted when no data is scheduled on this PID.
	SetStuffingPackets(int) PushPidCounters
	// The trimmed bytes count.
	// Format: bytes (bytes)
	TrimmedBytes() *Bytes
	// The trimmed bytes count.
	// Format: bytes (bytes)
	SetTrimmedBytes(Bytes) PushPidCounters
	// The trimmed PES packets count.
	TrimmedFrames() *int
	// The trimmed PES packets count.
	SetTrimmedFrames(int) PushPidCounters
}

// Required: channel_id
type RTPCountersBase interface {
	// How many bytes received for this channel
	Bytes() *int
	// How many bytes received for this channel
	SetBytes(int) RTPCountersBase
	// RTP channel number
	// Example: 0
	ChannelID() int
	// RTP channel number
	// Example: 0
	SetChannelID(int) RTPCountersBase
	// Content of the track transmitted in the channel
	// Example: video
	Content() *string
	// Content of the track transmitted in the channel
	// Example: video
	SetContent(string) RTPCountersBase
	// Demultiplexing was done right, but content is broken.
	ErrorsBrokenPayload() *int
	// Demultiplexing was done right, but content is broken.
	SetErrorsBrokenPayload(int) RTPCountersBase
	// Number of frames which dts is same as previous frame dts.
	ErrorsDtsStuck() *int
	// Number of frames which dts is same as previous frame dts.
	SetErrorsDtsStuck(int) RTPCountersBase
	// RTP have enough information to tell how many packets were lost
	ErrorsLostPackets() *int
	// RTP have enough information to tell how many packets were lost
	SetErrorsLostPackets(int) RTPCountersBase
	// How many frames received for this channel
	Frames() *int
	// How many frames received for this channel
	SetFrames(int) RTPCountersBase
	// Number of RTP packets which marker bit is set to one.
	MarkerPacketsCount() *int
	// Number of RTP packets which marker bit is set to one.
	SetMarkerPacketsCount(int) RTPCountersBase
	// How many NACK messages are sent for this channel
	NackCount() *int
	// How many NACK messages are sent for this channel
	SetNackCount(int) RTPCountersBase
	// If no marker bit packet is received after 400 RTP packets then decoder switches to `no_marker_mode` and
	// makes frame on each timecode change.
	// This flag shows if decoder works in `no_marker_mode`.
	NoMarkerModeFlag() *bool
	// If no marker bit packet is received after 400 RTP packets then decoder switches to `no_marker_mode` and
	// makes frame on each timecode change.
	// This flag shows if decoder works in `no_marker_mode`.
	SetNoMarkerModeFlag(bool) RTPCountersBase
	// Number of rtp packets rejected due to wrong payload type
	PtRejectCount() *int
	// Number of rtp packets rejected due to wrong payload type
	SetPtRejectCount(int) RTPCountersBase
	// Total size of rejected packets due to wrong payload type (pt_reject_count) rtp packets
	PtRejectSum() *int
	// Total size of rejected packets due to wrong payload type (pt_reject_count) rtp packets
	SetPtRejectSum(int) RTPCountersBase
	// How many RTCP packets received for this channel
	RtcpPackets() *int
	// How many RTCP packets received for this channel
	SetRtcpPackets(int) RTPCountersBase
	// How many RTP packets received for this channel
	RTPPackets() *int
	// How many RTP packets received for this channel
	SetRTPPackets(int) RTPCountersBase
	// Sender wallclock deviation from server time in ms. Positive value means that sender time is ahead of server time.
	SenderClockDeviation() *int
	// Sender wallclock deviation from server time in ms. Positive value means that sender time is ahead of server time.
	SetSenderClockDeviation(int) RTPCountersBase
	// Number of rtcp SR packets which `RTP timestamp` is equal to the previous rtcp SR packet `RTP timestamp`.
	SrTSStuck() *int
	// Number of rtcp SR packets which `RTP timestamp` is equal to the previous rtcp SR packet `RTP timestamp`.
	SetSrTSStuck(int) RTPCountersBase
	// Time on this channel is jumped back from reference wallclock.
	TSGoesBackwards() *int
	// Time on this channel is jumped back from reference wallclock.
	SetTSGoesBackwards(int) RTPCountersBase
	// Time on this channel is jumped forward from reference wallclock.
	TSJumpForward() *int
	// Time on this channel is jumped forward from reference wallclock.
	SetTSJumpForward(int) RTPCountersBase
	// https://datatracker.ietf.org/doc/html/rfc6184#section-4.1
	// access unit: A set of NAL units always containing a primary coded picture.  In addition to the primary coded
	// picture, an access unit may also contain one or more redundant coded pictures or other NAL units not containing
	// slices or slice data partitions of a coded picture.  The decoding of an access unit always results in a
	// decoded picture.
	// There is `marker bit` in RTP packet which is set for the very last packet of the access unit indicated by the RTP timestamp.
	// It is protocol violation if received RTP packet has the same timestamp as previous marker bit packet.
	// This counter is a number of RTP packets which `RTP timestamp` is equal to previous RTP marker bit packet.
	TSStuck() *int
	// https://datatracker.ietf.org/doc/html/rfc6184#section-4.1
	// access unit: A set of NAL units always containing a primary coded picture.  In addition to the primary coded
	// picture, an access unit may also contain one or more redundant coded pictures or other NAL units not containing
	// slices or slice data partitions of a coded picture.  The decoding of an access unit always results in a
	// decoded picture.
	// There is `marker bit` in RTP packet which is set for the very last packet of the access unit indicated by the RTP timestamp.
	// It is protocol violation if received RTP packet has the same timestamp as previous marker bit packet.
	// This counter is a number of RTP packets which `RTP timestamp` is equal to previous RTP marker bit packet.
	SetTSStuck(int) RTPCountersBase
}

// Required: path
type RaidDiskConfig interface {
	// The mode of using the disk.
	// Example: keep
	Mode() *RaidDiskMode
	// The mode of using the disk.
	// Example: keep
	SetMode(RaidDiskMode) RaidDiskConfig
	// The path to a mounted disk.
	// Format: disk_path (disk_path)
	// Example: volume1
	Path() DiskPath
	// The path to a mounted disk.
	// Format: disk_path (disk_path)
	// Example: volume1
	SetPath(DiskPath) RaidDiskConfig
	// The runtime statistics about RAID. The statistics shows the state of disks.
	// Learn more in [Flussonic RAID for DVR](https://flussonic.com/doc/extend-video-storage-on-fly/#dvr-flussonic-raid-stats)
	Stats() RaidDiskConfigStats
	// The runtime statistics about RAID. The statistics shows the state of disks.
	// Learn more in [Flussonic RAID for DVR](https://flussonic.com/doc/extend-video-storage-on-fly/#dvr-flussonic-raid-stats)
	SetStats(RaidDiskConfigStats) RaidDiskConfig
}

// The runtime statistics about RAID. The statistics shows the state of disks.
// Learn more in [Flussonic RAID for DVR](https://flussonic.com/doc/extend-video-storage-on-fly/#dvr-flussonic-raid-stats)
type RaidDiskConfigStats interface {
	// The number of blobs on the disk that are enlisted in individual stream indexes.
	// It must be equal to blobs_count_db and can be different in case of software
	// or hardware errors.
	BlobsCount() *int
	// The number of blobs on the disk that are enlisted in individual stream indexes.
	// It must be equal to blobs_count_db and can be different in case of software
	// or hardware errors.
	SetBlobsCount(int) RaidDiskConfigStats
	// The number of blobs on the disk according to centralized Raid DB that is
	// used to allocate blobs across whole storage.
	BlobsCountDb() *int
	// The number of blobs on the disk according to centralized Raid DB that is
	// used to allocate blobs across whole storage.
	SetBlobsCountDb(int) RaidDiskConfigStats
	// Errors of using the disk.
	Errors() RaidDiskErrors
	// Errors of using the disk.
	SetErrors(RaidDiskErrors) RaidDiskConfigStats
	// Disk I/O utilization percentage from `/proc/devstat`.
	// Format: percent (percent)
	IoUsage() *Percent
	// Disk I/O utilization percentage from `/proc/devstat`.
	// Format: percent (percent)
	SetIoUsage(Percent) RaidDiskConfigStats
	// The estimated migration end time, in UTC seconds.
	// Format: utc (Unix timestamp in seconds)
	MigrationEta() *Utc
	// The estimated migration end time, in UTC seconds.
	// Format: utc (Unix timestamp in seconds)
	SetMigrationEta(Utc) RaidDiskConfigStats
	// The speed of copying the last blob, in bytes per second.
	// Format: speed (speed)
	MigrationSpeed() *Speed
	// The speed of copying the last blob, in bytes per second.
	// Format: speed (speed)
	SetMigrationSpeed(Speed) RaidDiskConfigStats
	// The time when the values of `migration_speed` and `migration_eta` were last updated.
	// Format: utc (Unix timestamp in seconds)
	MigrationUpdated() *Utc
	// The time when the values of `migration_speed` and `migration_eta` were last updated.
	// Format: utc (Unix timestamp in seconds)
	SetMigrationUpdated(Utc) RaidDiskConfigStats
	// The mode of using the disk.
	// Example: keep
	Mode() *RaidDiskMode
	// The mode of using the disk.
	// Example: keep
	SetMode(RaidDiskMode) RaidDiskConfigStats
	// Whether the disk is mounted correctly.
	Mounted() *bool
	// Whether the disk is mounted correctly.
	SetMounted(bool) RaidDiskConfigStats
	// Disk capacity in bytes.
	// Format: bytes (bytes)
	Size() *Bytes
	// Disk capacity in bytes.
	// Format: bytes (bytes)
	SetSize(Bytes) RaidDiskConfigStats
	// Disk utilization percentage.
	// Format: percent (percent)
	Usage() *Percent
	// Disk utilization percentage.
	// Format: percent (percent)
	SetUsage(Percent) RaidDiskConfigStats
	// Used disk space in bytes according to linux metrics. It must be equal (almost equal) to
	// `used_index`. If it differs more than in 1%, then it means that there are lot of unknown files.
	// If this disk is used exclusively for Raid, then it may mean that some blobs are lost from
	// database and repairing is required.
	// Format: bytes (bytes)
	Used() *Bytes
	// Used disk space in bytes according to linux metrics. It must be equal (almost equal) to
	// `used_index`. If it differs more than in 1%, then it means that there are lot of unknown files.
	// If this disk is used exclusively for Raid, then it may mean that some blobs are lost from
	// database and repairing is required.
	// Format: bytes (bytes)
	SetUsed(Bytes) RaidDiskConfigStats
	// Used disk space in bytes according to internal database index.
	// Format: bytes (bytes)
	UsedIndex() *Bytes
	// Used disk space in bytes according to internal database index.
	// Format: bytes (bytes)
	SetUsedIndex(Bytes) RaidDiskConfigStats
}

type RaidDiskErrors interface {
	// Total number of connection timeout errors
	// Example: 1
	ConnectionTimeout() *int
	// Total number of connection timeout errors
	// Example: 1
	SetConnectionTimeout(int) RaidDiskErrors
	// Total number of permission denied errors
	// Example: 1
	Eacces() *int
	// Total number of permission denied errors
	// Example: 1
	SetEacces(int) RaidDiskErrors
	// Total number of temporarily unavailable errors
	// Example: 1
	Eagain() *int
	// Total number of temporarily unavailable errors
	// Example: 1
	SetEagain(int) RaidDiskErrors
	// Total number of file busy errors
	// Example: 1
	Ebusy() *int
	// Total number of file busy errors
	// Example: 1
	SetEbusy(int) RaidDiskErrors
	// Total number of connection refused errors
	// Example: 1
	Econnrefused() *int
	// Total number of connection refused errors
	// Example: 1
	SetEconnrefused(int) RaidDiskErrors
	// Total number of disk quota exceeded errors
	// Example: 1
	Edquot() *int
	// Total number of disk quota exceeded errors
	// Example: 1
	SetEdquot(int) RaidDiskErrors
	// Total number of too many open files errors
	// Example: 1
	Emfile() *int
	// Total number of too many open files errors
	// Example: 1
	SetEmfile(int) RaidDiskErrors
	// Total number of no such device errors
	// Example: 1
	Enodev() *int
	// Total number of no such device errors
	// Example: 1
	SetEnodev(int) RaidDiskErrors
	// Total number of no such file or directory errors
	// Example: 1
	Enoent() *int
	// Total number of no such file or directory errors
	// Example: 1
	SetEnoent(int) RaidDiskErrors
	// Total number of no space left on device errors
	// Example: 1
	Enospc() *int
	// Total number of no space left on device errors
	// Example: 1
	SetEnospc(int) RaidDiskErrors
	// Total number of read-only file system errors
	// Example: 1
	Erofs() *int
	// Total number of read-only file system errors
	// Example: 1
	SetErofs(int) RaidDiskErrors
	// Total number of non-existing domain errors
	// Example: 1
	Nxdomain() *int
	// Total number of non-existing domain errors
	// Example: 1
	SetNxdomain(int) RaidDiskErrors
	// Total number of other errors
	// Example: 1
	Other() *int
	// Total number of other errors
	// Example: 1
	SetOther(int) RaidDiskErrors
	// Total number of SSL errors
	// Example: 1
	SslError() *int
	// Total number of SSL errors
	// Example: 1
	SetSslError(int) RaidDiskErrors
}

type RaidDiskStats interface {
	// Errors of using the disk.
	Errors() RaidDiskErrors
	// Errors of using the disk.
	SetErrors(RaidDiskErrors) RaidDiskStats
	// Disk I/O utilization percentage from `/proc/devstat`.
	// Format: percent (percent)
	IoUsage() *Percent
	// Disk I/O utilization percentage from `/proc/devstat`.
	// Format: percent (percent)
	SetIoUsage(Percent) RaidDiskStats
	// The estimated migration end time, in UTC seconds.
	// Format: utc (Unix timestamp in seconds)
	MigrationEta() *Utc
	// The estimated migration end time, in UTC seconds.
	// Format: utc (Unix timestamp in seconds)
	SetMigrationEta(Utc) RaidDiskStats
	// The speed of copying the last blob, in bytes per second.
	// Format: speed (speed)
	MigrationSpeed() *Speed
	// The speed of copying the last blob, in bytes per second.
	// Format: speed (speed)
	SetMigrationSpeed(Speed) RaidDiskStats
	// The time when the values of `migration_speed` and `migration_eta` were last updated.
	// Format: utc (Unix timestamp in seconds)
	MigrationUpdated() *Utc
	// The time when the values of `migration_speed` and `migration_eta` were last updated.
	// Format: utc (Unix timestamp in seconds)
	SetMigrationUpdated(Utc) RaidDiskStats
	// The mode of using the disk.
	// Example: keep
	Mode() *RaidDiskMode
	// The mode of using the disk.
	// Example: keep
	SetMode(RaidDiskMode) RaidDiskStats
	// Whether the disk is mounted correctly.
	Mounted() *bool
	// Whether the disk is mounted correctly.
	SetMounted(bool) RaidDiskStats
}

// Required: streampoint_key
type RproxyConfig interface {
	// Path to authorization backend on the endpoint to check if the Agents are allowed to connect.
	EndpointAuth() *string
	// Path to authorization backend on the endpoint to check if the Agents are allowed to connect.
	SetEndpointAuth(string) RproxyConfig
	// Configuration of port handlers.
	ForwardPorts() map[string]ForwardPortsConfig
	// Configuration of port handlers.
	SetForwardPorts(map[string]ForwardPortsConfig) RproxyConfig
	// The streamer ID key.
	StreampointKey() string
	// The streamer ID key.
	SetStreampointKey(string) RproxyConfig
}

type Sensor interface {
	// Image blacklight compensation correction
	BlacklightCompensation() OnOff
	// Image blacklight compensation correction
	SetBlacklightCompensation(OnOff) Sensor
	// Image brightness correction.
	// The value is indicated as a percentage from 0 to 100.
	// Format: percent (percent)
	BrightnessCorrection() *Percent
	// Image brightness correction.
	// The value is indicated as a percentage from 0 to 100.
	// Format: percent (percent)
	SetBrightnessCorrection(Percent) Sensor
	// Image contrast correction.
	// The value is indicated as a percentage from 0 to 100.
	// Format: percent (percent)
	ContrastCorrection() *Percent
	// Image contrast correction.
	// The value is indicated as a percentage from 0 to 100.
	// Format: percent (percent)
	SetContrastCorrection(Percent) Sensor
	// Installation position of the camera
	ImageOrientation() *SensorImageOrientation
	// Installation position of the camera
	SetImageOrientation(SensorImageOrientation) Sensor
	// Infrared cut-of filter
	InfraredCutoffFilter() OnOffAuto
	// Infrared cut-of filter
	SetInfraredCutoffFilter(OnOffAuto) Sensor
	// Image saturation correction.
	// The value is indicated as a percentage from 0 to 100.
	// Format: percent (percent)
	Saturation() *Percent
	// Image saturation correction.
	// The value is indicated as a percentage from 0 to 100.
	// Format: percent (percent)
	SetSaturation(Percent) Sensor
	// Sharpness / edges contrast enhancement level.
	// The value is indicated as a percentage from 0 to 100.
	// Format: percent (percent)
	Sharpness() *Percent
	// Sharpness / edges contrast enhancement level.
	// The value is indicated as a percentage from 0 to 100.
	// Format: percent (percent)
	SetSharpness(Percent) Sensor
	// Image wide dynamic range correction.
	// The value is indicated as a percentage from 0 to 100.
	// Format: percent (percent)
	WideDynamicRange() *Percent
	// Image wide dynamic range correction.
	// The value is indicated as a percentage from 0 to 100.
	// Format: percent (percent)
	SetWideDynamicRange(Percent) Sensor
}

type ServerConfigBase interface {
	// The list of allowed subnets to accept API requests from.
	APIAllowedFrom() []Cidr
	// The list of allowed subnets to accept API requests from.
	SetAPIAllowedFrom([]Cidr) ServerConfigBase
	// Configure key name of query string key-value pair for token authentication
	AuthToken() *AuthToken
	// Configure key name of query string key-value pair for token authentication
	SetAuthToken(AuthToken) ServerConfigBase
	// The cluster key to unite several servers with the same key into a cluster.
	// Example: xS6i6Q3DCc5nEvnu
	ClusterKey() *string
	// The cluster key to unite several servers with the same key into a cluster.
	// Example: xS6i6Q3DCc5nEvnu
	SetClusterKey(string) ServerConfigBase
	// Credentials for administrator access to the server.
	EditAuth() AdminCredentials
	// Credentials for administrator access to the server.
	SetEditAuth(AdminCredentials) ServerConfigBase
	// Use your own GeoIP database.
	// Format: disk_path (disk_path)
	// Example: /usr/share/GeoIP/GeoLite2-City.mmdb
	Geoip() *DiskPath
	// Use your own GeoIP database.
	// Format: disk_path (disk_path)
	// Example: /usr/share/GeoIP/GeoLite2-City.mmdb
	SetGeoip(DiskPath) ServerConfigBase
	// The configuration of network listeners.
	Listeners() Listeners
	// The configuration of network listeners.
	SetListeners(Listeners) ServerConfigBase
	// Enables logging of requests for streams (manifests, segments) and API request.
	LogRequests() *bool
	// Enables logging of requests for streams (manifests, segments) and API request.
	SetLogRequests(bool) ServerConfigBase
	// Raise loglevel to debug if needed.
	// Example: error
	Loglevel() *Loglevel
	// Raise loglevel to debug if needed.
	// Example: error
	SetLoglevel(Loglevel) ServerConfigBase
	// Some additional options of the server.
	// Example: {"role": "transcoder"}
	Meta() *string
	// Some additional options of the server.
	// Example: {"role": "transcoder"}
	SetMeta(string) ServerConfigBase
	// Deprecated field. Will be deleted at 25.11
	// Enables saving statistics on Nvidia performance.
	// Example: true
	NvidiaMonitor() *bool
	// Deprecated field. Will be deleted at 25.11
	// Enables saving statistics on Nvidia performance.
	// Example: true
	SetNvidiaMonitor(bool) ServerConfigBase
	// Directory to store Pulse statistics.
	// Format: disk_path (disk_path)
	// Example: /var/run/flussonic/pulsedb
	Pulsedb() *DiskPath
	// Directory to store Pulse statistics.
	// Format: disk_path (disk_path)
	// Example: /var/run/flussonic/pulsedb
	SetPulsedb(DiskPath) ServerConfigBase
	// The configuration of server domain name and aliases
	ServerNames() []ServerNameConfig
	// The configuration of server domain name and aliases
	SetServerNames([]ServerNameConfig) ServerConfigBase
	// Deprecated field. Will be deleted at 26.01
	// Directory to store the session log.
	// Format: disk_path (disk_path)
	// Example: /var/run/flussonic/session_log
	SessionLog() *DiskPath
	// Deprecated field. Will be deleted at 26.01
	// Directory to store the session log.
	// Format: disk_path (disk_path)
	// Example: /var/run/flussonic/session_log
	SetSessionLog(DiskPath) ServerConfigBase
	// Global SRT listening port. It is possible to use a single port for playback and publishing, but it is not compatible with clients.
	// Consider configuring separate ports for playback and publishing for each stream.
	Srt() *ListenSpec
	// Global SRT listening port. It is possible to use a single port for playback and publishing, but it is not compatible with clients.
	// Consider configuring separate ports for playback and publishing for each stream.
	SetSrt(*ListenSpec) ServerConfigBase
	// SRT2 play configuration with single-port mode. Not supported by many clients, better use per-stream mode.
	Srt2Play() SrtConfig
	// SRT2 play configuration with single-port mode. Not supported by many clients, better use per-stream mode.
	SetSrt2Play(SrtConfig) ServerConfigBase
	// SRT2 publish configuration with single-port mode. Not supported by many clients, better use per-stream mode.
	Srt2Publish() SrtConfig
	// SRT2 publish configuration with single-port mode. Not supported by many clients, better use per-stream mode.
	SetSrt2Publish(SrtConfig) ServerConfigBase
	// SRT play configuration with single-port mode. Not supported by many clients, better use per-stream mode.
	SrtPlay() SrtConfig
	// SRT play configuration with single-port mode. Not supported by many clients, better use per-stream mode.
	SetSrtPlay(SrtConfig) ServerConfigBase
	// SRT publish configuration with single-port mode. Not supported by many clients, better use per-stream mode.
	SrtPublish() SrtConfig
	// SRT publish configuration with single-port mode. Not supported by many clients, better use per-stream mode.
	SetSrtPublish(SrtConfig) ServerConfigBase
	// Total server bandwidth.
	// Format: speed (speed)
	// Example: 1e+09
	TotalBandwidth() *Speed
	// Total server bandwidth.
	// Format: speed (speed)
	// Example: 1e+09
	SetTotalBandwidth(Speed) ServerConfigBase
	// This option applies to HLS and DASH protocols, for all streams on the server.
	// The addresses of individual segments within a segment-based playlist will start with the specified prefix.
	// This setting is available in the global part of the config file as well as locally for any individual stream.
	// When specified at the stream level, it is only valid for this particular stream.
	URLPrefix() *URLPrefix
	// This option applies to HLS and DASH protocols, for all streams on the server.
	// The addresses of individual segments within a segment-based playlist will start with the specified prefix.
	// This setting is available in the global part of the config file as well as locally for any individual stream.
	// When specified at the stream level, it is only valid for this particular stream.
	SetURLPrefix(*URLPrefix) ServerConfigBase
	// Credentials for access to readonly API functions like getting streams info, status, and statistics.
	ViewAuth() AdminCredentials
	// Credentials for access to readonly API functions like getting streams info, status, and statistics.
	SetViewAuth(AdminCredentials) ServerConfigBase
	// Global WebRTC ports configuration for playback (via WHEP - WebRTC HTTP egress protocol).
	WebrtcPlay() WebrtcRouterConfig
	// Global WebRTC ports configuration for playback (via WHEP - WebRTC HTTP egress protocol).
	SetWebrtcPlay(WebrtcRouterConfig) ServerConfigBase
	// Global WebRTC ports configuration for publishing (via WHIP - WebRTC HTTP ingestion protocol).
	WebrtcPublish() WebrtcRouterConfig
	// Global WebRTC ports configuration for publishing (via WHIP - WebRTC HTTP ingestion protocol).
	SetWebrtcPublish(WebrtcRouterConfig) ServerConfigBase
}

type ServerConfigFull interface {
	// The configuration of auth backends
	AuthBackends() []AuthBackendConfig
	// The configuration of auth backends
	SetAuthBackends([]AuthBackendConfig) ServerConfigFull
	// The configuration of the balancers.
	Balancers() []BalancerConfig
	// The configuration of the balancers.
	SetBalancers([]BalancerConfig) ServerConfigFull
	// The configuration of the cache.
	Caches() []CacheConfig
	// The configuration of the cache.
	SetCaches([]CacheConfig) ServerConfigFull
	// The configuration of the camera alarms.
	CameraAlarm() CameraAlarmConfig
	// The configuration of the camera alarms.
	SetCameraAlarm(CameraAlarmConfig) ServerConfigFull
	// The configuration of the chassis.
	Chassis() ChassisConfig
	// The configuration of the chassis.
	SetChassis(ChassisConfig) ServerConfigFull
	// Configuration of decklink SDI capture cards
	Decklinks() []DecklinkConfig
	// Configuration of decklink SDI capture cards
	SetDecklinks([]DecklinkConfig) ServerConfigFull
	// The configuration of the DVB cards.
	DvbCards() []DvbCardConfig
	// The configuration of the DVB cards.
	SetDvbCards([]DvbCardConfig) ServerConfigFull
	// The configuration of the DVRs
	Dvrs() []DvrConfig
	// The configuration of the DVRs
	SetDvrs([]DvrConfig) ServerConfigFull
	// The configuration of event notifications
	EventSinks() []EventSinkConfig
	// The configuration of event notifications
	SetEventSinks([]EventSinkConfig) ServerConfigFull
	// The configuration of the file processor.
	FileProcessor() FileProcessorConfig
	// The configuration of the file processor.
	SetFileProcessor(FileProcessorConfig) ServerConfigFull
	// List of HTTP prefixes that can be handled via call to remote http server
	HTTPProxies() []HTTPProxyConfig
	// List of HTTP prefixes that can be handled via call to remote http server
	SetHTTPProxies([]HTTPProxyConfig) ServerConfigFull
	// The configuration of the IPTV
	Iptv() IptvConfig
	// The configuration of the IPTV
	SetIptv(IptvConfig) ServerConfigFull
	// The configuration of peers in the cluster.
	Peers() []PeerConfig
	// The configuration of peers in the cluster.
	SetPeers([]PeerConfig) ServerConfigFull
	// The configuration of the port forwarding.
	Rproxy() RproxyConfig
	// The configuration of the port forwarding.
	SetRproxy(RproxyConfig) ServerConfigFull
	// The configuration of the video sources.
	Sources() []SourceConfig
	// The configuration of the video sources.
	SetSources([]SourceConfig) ServerConfigFull
	// The configuration of the streams.
	Streams() []StreamConfig
	// The configuration of the streams.
	SetStreams([]StreamConfig) ServerConfigFull
	// The configuration of the templates.
	Templates() []TemplateConfig
	// The configuration of the templates.
	SetTemplates([]TemplateConfig) ServerConfigFull
	// The configuration of the transponders.
	Transponders() []TransponderConfig
	// The configuration of the transponders.
	SetTransponders([]TransponderConfig) ServerConfigFull
	// The configuration of VODs
	Vods() []VodConfig
	// The configuration of VODs
	SetVods([]VodConfig) ServerConfigFull
	// The configuration of the video surveillance subsystem.
	Vsaas() VsaasConfig
	// The configuration of the video surveillance subsystem.
	SetVsaas(VsaasConfig) ServerConfigFull
}

// Required: domain
type ServerNameConfig interface {
	// List of domain aliases, used together with the primary name to issue ssl certs
	// Example: [s1.streamer.local s2.streamer.local]
	Aliases() []string
	// List of domain aliases, used together with the primary name to issue ssl certs
	// Example: [s1.streamer.local s2.streamer.local]
	SetAliases([]string) ServerNameConfig
	// Domain names to issue ssl certificates for
	// Example: streamer.local
	Domain() string
	// Domain names to issue ssl certificates for
	// Example: streamer.local
	SetDomain(string) ServerNameConfig
}

type ServerStatsNetwork interface {
	// Current incoming speed (bitrate) of the data transmission over the network.
	// Format: speed (speed)
	// Example: 400300
	InputKbit() *Speed
	// Current incoming speed (bitrate) of the data transmission over the network.
	// Format: speed (speed)
	// Example: 400300
	SetInputKbit(Speed) ServerStatsNetwork
	// The number of streams that are ready to be served to the clients.
	// Example: 27
	OnlineStreams() *int
	// The number of streams that are ready to be served to the clients.
	// Example: 27
	SetOnlineStreams(int) ServerStatsNetwork
	// The number of opened files.
	// Example: 5
	OpenedFiles() *int
	// The number of opened files.
	// Example: 5
	SetOpenedFiles(int) ServerStatsNetwork
	// Current outgoing speed (bitrate) of the data transmission over the network.
	// Format: speed (speed)
	// Example: 500400
	OutputKbit() *Speed
	// Current outgoing speed (bitrate) of the data transmission over the network.
	// Format: speed (speed)
	// Example: 500400
	SetOutputKbit(Speed) ServerStatsNetwork
	// The number of clients receiving the streams from the server at the moment of request.
	// Example: 2040
	TotalClients() *int
	// The number of clients receiving the streams from the server at the moment of request.
	// Example: 2040
	SetTotalClients(int) ServerStatsNetwork
	// The number of streams created on the server.
	// Example: 45
	TotalStreams() *int
	// The number of streams created on the server.
	// Example: 45
	SetTotalStreams(int) ServerStatsNetwork
}

type ServerStatsStreamer interface {
	// Outbound bandwidth usage (load balancing in `usage` mode is based on this value).
	// Format: percent (percent)
	// Example: 67
	BandwidthUsage() *Percent
	// Outbound bandwidth usage (load balancing in `usage` mode is based on this value).
	// Format: percent (percent)
	// Example: 67
	SetBandwidthUsage(Percent) ServerStatsStreamer
	// Information about errors in the config file.
	ConfigError() ConfigErrorStatus
	// Information about errors in the config file.
	SetConfigError(ConfigErrorStatus) ServerStatsStreamer
	// Information about current external config status
	ConfigExternalStatus() ConfigExternalErrorStatus
	// Information about current external config status
	SetConfigExternalStatus(ConfigExternalErrorStatus) ServerStatsStreamer
	// Current runtime version of config. We do not declare exact structure, but we promise
	// that it will be always comparable and increasing (if server has proper NTP configuration, of course).
	// Right now it is a tuple of server start time and incrementing version of config.
	// Example: [1.636709231e+09 4]
	ConfigVersion() []int
	// Current runtime version of config. We do not declare exact structure, but we promise
	// that it will be always comparable and increasing (if server has proper NTP configuration, of course).
	// Right now it is a tuple of server start time and incrementing version of config.
	// Example: [1.636709231e+09 4]
	SetConfigVersion([]int) ServerStatsStreamer
	// CPU usage on the server.
	// Format: percent (percent)
	// Example: 48
	CpuUsage() *Percent
	// CPU usage on the server.
	// Format: percent (percent)
	// Example: 48
	SetCpuUsage(Percent) ServerStatsStreamer
	// Hostname of your server. Please, use FQDN, do not leave your Linux misconfigured.
	// Example: openapi.flussonic.com
	Hostname() *string
	// Hostname of your server. Please, use FQDN, do not leave your Linux misconfigured.
	// Example: openapi.flussonic.com
	SetHostname(string) ServerStatsStreamer
	// Unique runtime ID of this instance. Updated with the restart.
	// Format: uuid (uuid)
	// Example: 61893b15-75b2-4fcb-b4cf-ae1dd0858ea2
	ID() *UUID
	// Unique runtime ID of this instance. Updated with the restart.
	// Format: uuid (uuid)
	// Example: 61893b15-75b2-4fcb-b4cf-ae1dd0858ea2
	SetID(UUID) ServerStatsStreamer
	// The flag shows if Flussonic runs on Flussonic Coder.
	IsChassis() *bool
	// The flag shows if Flussonic runs on Flussonic Coder.
	SetIsChassis(bool) ServerStatsStreamer
	// The code of the license applied on the server.
	// Example: uO8v12HJhNXVj5gM
	LicenseTxt() *string
	// The code of the license applied on the server.
	// Example: uO8v12HJhNXVj5gM
	SetLicenseTxt(string) ServerStatsStreamer
	// The license type.
	LicenseType() *LicenseType
	// The license type.
	SetLicenseType(LicenseType) ServerStatsStreamer
	// Memory usage on the server.
	// Format: percent (percent)
	// Example: 27
	MemoryUsage() *Percent
	// Memory usage on the server.
	// Format: percent (percent)
	// Example: 27
	SetMemoryUsage(Percent) ServerStatsStreamer
	// Notification about a newer version in the repository.
	// Format: server_version (server_version)
	// Example: 22.01
	NextVersion() *ServerVersion
	// Notification about a newer version in the repository.
	// Format: server_version (server_version)
	// Example: 22.01
	SetNextVersion(ServerVersion) ServerStatsStreamer
	// The list of disk partitions on the server.
	Partitions() []PartitionStats
	// The list of disk partitions on the server.
	SetPartitions([]PartitionStats) ServerStatsStreamer
	// Shows if rproxy is configured.
	Rproxy() *bool
	// Shows if rproxy is configured.
	SetRproxy(bool) ServerStatsStreamer
	// Shows if rproxy is running.
	RproxyRunning() *bool
	// Shows if rproxy is running.
	SetRproxyRunning(bool) ServerStatsStreamer
	// Erlang scheduler load.
	// Format: percent (percent)
	// Example: 40
	SchedulerLoad() *Percent
	// Erlang scheduler load.
	// Format: percent (percent)
	// Example: 40
	SetSchedulerLoad(Percent) ServerStatsStreamer
	// *Flussonic* will always try to start even if there are severe errors that do not
	// allow functioning.
	// `starting` status means you should wait for some time (not more than
	// a minute).
	// `running` status means all configuration was loaded. However, the status does not provide
	// an information about your streams and the quality of provided service.
	// All other statuses mean there are some severe problems on the server
	// that cannot be repaired by Flussonic itself.
	StreamerStatus() *ServerStatsStreamerStatus
	// *Flussonic* will always try to start even if there are severe errors that do not
	// allow functioning.
	// `starting` status means you should wait for some time (not more than
	// a minute).
	// `running` status means all configuration was loaded. However, the status does not provide
	// an information about your streams and the quality of provided service.
	// All other statuses mean there are some severe problems on the server
	// that cannot be repaired by Flussonic itself.
	SetStreamerStatus(ServerStatsStreamerStatus) ServerStatsStreamer
	// Human-readable format of errors and alerts that need to be fixed.
	// Provided by some *Flussonic* subsystems.
	TextAlerts() map[string]string
	// Human-readable format of errors and alerts that need to be fixed.
	// Provided by some *Flussonic* subsystems.
	SetTextAlerts(map[string]string) ServerStatsStreamer
	// Deprecated field. Will be deleted at 22.03
	// Total server bandwidth.
	// Format: speed (speed)
	TotalBandwidth() *Speed
	// Deprecated field. Will be deleted at 22.03
	// Total server bandwidth.
	// Format: speed (speed)
	SetTotalBandwidth(Speed) ServerStatsStreamer
	// Shows if the server's CPU can be used for transcoding
	// (i.e. if the `flussonic-transcoder` package is installed on the server).
	Transcoder() *bool
	// Shows if the server's CPU can be used for transcoding
	// (i.e. if the `flussonic-transcoder` package is installed on the server).
	SetTranscoder(bool) ServerStatsStreamer
	// Statistics on the devices used for transcoding.
	TranscoderDevices() []TranscoderDeviceStats
	// Statistics on the devices used for transcoding.
	SetTranscoderDevices([]TranscoderDeviceStats) ServerStatsStreamer
	// The server uptime.
	// Format: seconds (seconds)
	// Example: 4.325502e+06
	Uptime() *Seconds
	// The server uptime.
	// Format: seconds (seconds)
	// Example: 4.325502e+06
	SetUptime(Seconds) ServerStatsStreamer
	// Shows if Flussonic Watcher is enabled in the license.
	Vsaas() *bool
	// Shows if Flussonic Watcher is enabled in the license.
	SetVsaas(bool) ServerStatsStreamer
	// Shows if Watcher branding is enabled in the license.
	VsaasBranding() *bool
	// Shows if Watcher branding is enabled in the license.
	SetVsaasBranding(bool) ServerStatsStreamer
	// Shows if Watcher is currently running.
	VsaasRunning() *bool
	// Shows if Watcher is currently running.
	SetVsaasRunning(bool) ServerStatsStreamer
}

type ServerStatsWhoami interface {
	// Build version
	Build() *int
	// Build version
	SetBuild(int) ServerStatsWhoami
	// Current response time
	// Format: utc_ms (Unix timestamp in milliseconds)
	Now() *UtcMs
	// Current response time
	// Format: utc_ms (Unix timestamp in milliseconds)
	SetNow(UtcMs) ServerStatsWhoami
	// Package version of the server. Might be simple a number of release like 21.11 or longer if you have a rolling release installed.
	// Format: server_version (server_version)
	// Example: 23.04
	ServerVersion() *ServerVersion
	// Package version of the server. Might be simple a number of release like 21.11 or longer if you have a rolling release installed.
	// Format: server_version (server_version)
	// Example: 23.04
	SetServerVersion(ServerVersion) ServerStatsWhoami
	// Boot time of this instance.
	// Format: utc (Unix timestamp in seconds)
	// Example: 1.639337825e+09
	StartedAt() *Utc
	// Boot time of this instance.
	// Format: utc (Unix timestamp in seconds)
	// Example: 1.639337825e+09
	SetStartedAt(Utc) ServerStatsWhoami
}

// Shared token are designed to provide access to the camera and its archive via a link.
// In the permission parameters, you can specify the access level that will be available for this token.
// Each token provides secure access to certain features of the system, including real-time viewing,
// recording and playback of archived data, tilt and zoom control,
// as well as the integration of advertising.
// Required: key, name
type SharedToken interface {
	// Unique secret string
	// Example: IJCo3KGLBf6NAqMCGgHf5gNhpl9
	Key() string
	// Unique secret string
	// Example: IJCo3KGLBf6NAqMCGgHf5gNhpl9
	SetKey(string) SharedToken
	// Stream that this shared token provides access to.
	// Examples: cam1-abcdef
	Media() *string
	// Stream that this shared token provides access to.
	// Examples: cam1-abcdef
	SetMedia(string) SharedToken
	// Unique name of the token that can be used to distinguish tokens
	// Examples: root
	Name() string
	// Unique name of the token that can be used to distinguish tokens
	// Examples: root
	SetName(string) SharedToken
	// List of independent permissions, available for this shared token
	Permissions() []SharedTokenPermission
	// List of independent permissions, available for this shared token
	SetPermissions([]SharedTokenPermission) SharedToken
}

type SharedTokenPermission interface {
	// The advertising access allows you to show advertisements to viewers during viewing.
	// Advertising works only in live mode.
	Advert() *bool
	// The advertising access allows you to show advertisements to viewers during viewing.
	// Advertising works only in live mode.
	SetAdvert(bool) SharedTokenPermission
	// The DVR access allows the archive and play recordings of past broadcasts.
	Dvr() *bool
	// The DVR access allows the archive and play recordings of past broadcasts.
	SetDvr(bool) SharedTokenPermission
	// The dvr depth limit allows to:
	// Set the maximum recording depth, which determines how far back recorded materials can be viewed.
	// Manage access to archived data, ensuring security and control over who can access records.
	// Format: seconds (seconds)
	// Example: 3600
	DvrDepthLimit() *Seconds
	// The dvr depth limit allows to:
	// Set the maximum recording depth, which determines how far back recorded materials can be viewed.
	// Manage access to archived data, ensuring security and control over who can access records.
	// Format: seconds (seconds)
	// Example: 3600
	SetDvrDepthLimit(Seconds) SharedTokenPermission
	// The export access allows you to export the dvr to a file.
	Export() *bool
	// The export access allows you to export the dvr to a file.
	SetExport(bool) SharedTokenPermission
	// The live access token allows you to watch videos in real time.
	Live() *bool
	// The live access token allows you to watch videos in real time.
	SetLive(bool) SharedTokenPermission
	// The PTZ access allows to control the tilt and zoom of the camera.
	// Change the position and focus of the camera during the broadcast.
	Ptz() *bool
	// The PTZ access allows to control the tilt and zoom of the camera.
	// Change the position and focus of the camera during the broadcast.
	SetPtz(bool) SharedTokenPermission
}

type SharedTokensList interface {
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	EstimatedCount() *int
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	SetEstimatedCount(int) SharedTokensList
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	Next() *string
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	SetNext(string) SharedTokensList
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	Prev() *string
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	SetPrev(string) SharedTokensList
	// List of available shared tokens
	SharedTokens() []SharedToken
	// List of available shared tokens
	SetSharedTokens([]SharedToken) SharedTokensList
	// An object with a list of different timings measured during this API call.
	Timing() any
	// An object with a list of different timings measured during this API call.
	SetTiming(any) SharedTokensList
	// Collection returns the collection items
	Collection() []SharedToken
}

type SourceConfig interface {
	// DVR configuraton.
	Dvr() StreamDvrSpec
	// DVR configuraton.
	SetDvr(StreamDvrSpec) SourceConfig
	// Stream labels in key value format.
	// Key is a string in unix_name format (alphanumeric characters, underscores, hyphens and periods).
	Labels() map[string]UnixName
	// Stream labels in key value format.
	// Key is a string in unix_name format (alphanumeric characters, underscores, hyphens and periods).
	SetLabels(map[string]UnixName) SourceConfig
	// A list of pushes. When a server initiates the connection and sends a stream
	// to other server(s), it is called a `push`.
	Pushes() []StreamPush
	// A list of pushes. When a server initiates the connection and sends a stream
	// to other server(s), it is called a `push`.
	SetPushes([]StreamPush) SourceConfig
	// Video analytics parameters.
	Vision() VisionSpec
	// Video analytics parameters.
	SetVision(VisionSpec) SourceConfig
}

type SourceSpecificConfig interface {
}

type SrtConfig interface {
	// Listening port or a `host:port` pair for the SRT configuration.
	// Must be unique on the whole server.
	// Example: 9050
	Port() *ListenSpec
	// Listening port or a `host:port` pair for the SRT configuration.
	// Must be unique on the whole server.
	// Example: 9050
	SetPort(*ListenSpec) SrtConfig
	// Data transmission timeout in seconds.
	// If set to `false` then data transmission time is unlimited. This is a defalut behavior.
	// Example: 10
	Timeout() any
	// Data transmission timeout in seconds.
	// If set to `false` then data transmission time is unlimited. This is a defalut behavior.
	// Example: 10
	SetTimeout(any) SrtConfig
}

type SrtConfigBase interface {
}

type StreamConfig interface {
	// Audio settings for the stream.
	Audio() WatcherStreamConfigAudio
	// Audio settings for the stream.
	SetAudio(WatcherStreamConfigAudio) StreamConfig
	// A publishable stream.
	// Example: false
	CanPublish() *bool
	// A publishable stream.
	// Example: false
	SetCanPublish(bool) StreamConfig
	// Human-readable description of the stream.
	// Example: This is a test stream
	Comment() *string
	// Human-readable description of the stream.
	// Example: This is a test stream
	SetComment(string) StreamConfig
	// Camera coordinates on a map or a floor plan.
	Coordinates() MapSpec
	// Camera coordinates on a map or a floor plan.
	SetCoordinates(MapSpec) StreamConfig
	// The date and time when the steam was created.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.672531199e+12
	CreatedAt() *UtcMs
	// The date and time when the steam was created.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.672531199e+12
	SetCreatedAt(UtcMs) StreamConfig
	// Whether a stream is disabled. Disabled streams are inactive and do not run.
	// Displayed only with the API calls.
	// Example: false
	Disabled() *bool
	// Whether a stream is disabled. Disabled streams are inactive and do not run.
	// Displayed only with the API calls.
	// Example: false
	SetDisabled(bool) StreamConfig
	// Domain the stream belongs to.
	Domain() DomainBase
	// Domain the stream belongs to.
	SetDomain(DomainBase) StreamConfig
	// DVR configuraton.
	Dvr() StreamDvrSpec
	// DVR configuraton.
	SetDvr(StreamDvrSpec) StreamConfig
	// Duration of the firmware update. If this field is present, the update process is ongoing.
	// Format: milliseconds (milliseconds)
	FirmwareUpdateDuration() *Milliseconds
	// Duration of the firmware update. If this field is present, the update process is ongoing.
	// Format: milliseconds (milliseconds)
	SetFirmwareUpdateDuration(Milliseconds) StreamConfig
	// Folder identificator.
	FolderID() *int
	// Folder identificator.
	SetFolderID(int) StreamConfig
	// List of stream inputs.
	// ***Important:*** A stream without any inputs can receive video frames **only** if backup file is specified.
	Inputs() []StreamInput
	// List of stream inputs.
	// ***Important:*** A stream without any inputs can receive video frames **only** if backup file is specified.
	SetInputs([]StreamInput) StreamConfig
	// Stream labels in key value format.
	// Key is a string in unix_name format (alphanumeric characters, underscores, hyphens and periods).
	Labels() map[string]UnixName
	// Stream labels in key value format.
	// Key is a string in unix_name format (alphanumeric characters, underscores, hyphens and periods).
	SetLabels(map[string]UnixName) StreamConfig
	// Information about the latest changes made to the camera configuration.
	LastChange() AuditLogRecord
	// Information about the latest changes made to the camera configuration.
	SetLastChange(AuditLogRecord) StreamConfig
	// The time when the last episode occurred.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	LastEpisodeAt() *UtcMs
	// The time when the last episode occurred.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetLastEpisodeAt(UtcMs) StreamConfig
	// Layouts information
	Layout() CentralStreamLayout
	// Layouts information
	SetLayout(CentralStreamLayout) StreamConfig
	// Rules of layout.
	LayoutRules() StreamZoneConfig
	// Rules of layout.
	SetLayoutRules(StreamZoneConfig) StreamConfig
	// Deprecated field. Will be deleted at 24.12
	// Camera coordinates on a map or a floor plan. Deprecated. Use coordinates instead.
	MapCoordinates() MapSpec
	// Deprecated field. Will be deleted at 24.12
	// Camera coordinates on a map or a floor plan. Deprecated. Use coordinates instead.
	SetMapCoordinates(MapSpec) StreamConfig
	// Globally unique stream name.
	// Note that the name could not be changed after the stream is created.
	// Format: media_name (media_name)
	// Examples: Decklink-Stream, Dektec-Stream, hockey1, mylive/bunny, test_stream
	Name() MediaName
	// Globally unique stream name.
	// Note that the name could not be changed after the stream is created.
	// Format: media_name (media_name)
	// Examples: Decklink-Stream, Dektec-Stream, hockey1, mylive/bunny, test_stream
	SetName(MediaName) StreamConfig
	// Onvif configuration
	Onvif() StreamOnvifConfig
	// Onvif configuration
	SetOnvif(StreamOnvifConfig) StreamConfig
	// Organization the stream belongs to.
	Organization() OrganizationStream
	// Organization the stream belongs to.
	SetOrganization(OrganizationStream) StreamConfig
	// Deprecated field. Will be deleted at 25.11
	// ID of the organization the stream belongs to.
	// Only organization owner or domain administrator could change it.
	// Example: 9
	OrganizationID() *int
	// Deprecated field. Will be deleted at 25.11
	// ID of the organization the stream belongs to.
	// Only organization owner or domain administrator could change it.
	// Example: 9
	SetOrganizationID(int) StreamConfig
	// Contains path to stream as a list.
	// Each item of the list can be interpreted as a node in a folders tree.
	Path() []StreamPathItem
	// Contains path to stream as a list.
	// Each item of the list can be interpreted as a node in a folders tree.
	SetPath([]StreamPathItem) StreamConfig
	// Camera adress on a map.
	PostalAddress() *string
	// Camera adress on a map.
	SetPostalAddress(string) StreamConfig
	// Preset settings.
	Preset() StreamPreset
	// Preset settings.
	SetPreset(StreamPreset) StreamConfig
	// Deprecated field. Will be deleted at 26.01
	// Preset identificator.
	PresetID() *int
	// Deprecated field. Will be deleted at 26.01
	// Preset identificator.
	SetPresetID(int) StreamConfig
	// A list of pushes. When a server initiates the connection and sends a stream
	// to other server(s), it is called a `push`.
	Pushes() []StreamPush
	// A list of pushes. When a server initiates the connection and sends a stream
	// to other server(s), it is called a `push`.
	SetPushes([]StreamPush) StreamConfig
	// Whether a stream is `static` or not.
	// If set to `True` the server will try to keep this stream running even if
	// there are no viewers or errors encountered.
	// Streamer restarts *all* `static` streams even if any internal errors occur
	// and the `static` streams crash.
	// Example: true
	Static() *bool
	// Whether a stream is `static` or not.
	// If set to `True` the server will try to keep this stream running even if
	// there are no viewers or errors encountered.
	// Streamer restarts *all* `static` streams even if any internal errors occur
	// and the `static` streams crash.
	// Example: true
	SetStatic(bool) StreamConfig
	// Stream's metrics and other statistical information.
	Stats() StreamStats
	// Stream's metrics and other statistical information.
	SetStats(StreamStats) StreamConfig
	// Human-readable title of the stream. Provided for SDT MPEG-TS table or
	// SDP RTSP title parameter.
	// Example: Hockey channel
	Title() *string
	// Human-readable title of the stream. Provided for SDT MPEG-TS table or
	// SDP RTSP title parameter.
	// Example: Hockey channel
	SetTitle(string) StreamConfig
	// Video analytics parameters.
	Vision() VisionSpec
	// Video analytics parameters.
	SetVision(VisionSpec) StreamConfig
}

type StreamConfigAdditional interface {
	// Stream's metrics and other statistical information.
	Stats() StreamStats
	// Stream's metrics and other statistical information.
	SetStats(StreamStats) StreamConfigAdditional
}

type StreamConfigBase interface {
	// Whether a stream is disabled. Disabled streams are inactive and do not run.
	// Displayed only with the API calls.
	// Example: false
	Disabled() *bool
	// Whether a stream is disabled. Disabled streams are inactive and do not run.
	// Displayed only with the API calls.
	// Example: false
	SetDisabled(bool) StreamConfigBase
	// Whether a stream is `static` or not.
	// If set to `True` the server will try to keep this stream running even if
	// there are no viewers or errors encountered.
	// Streamer restarts *all* `static` streams even if any internal errors occur
	// and the `static` streams crash.
	// Example: true
	Static() *bool
	// Whether a stream is `static` or not.
	// If set to `True` the server will try to keep this stream running even if
	// there are no viewers or errors encountered.
	// Streamer restarts *all* `static` streams even if any internal errors occur
	// and the `static` streams crash.
	// Example: true
	SetStatic(bool) StreamConfigBase
}

type StreamConfigDeprecated interface {
}

type StreamConfigInput interface {
	// List of stream inputs.
	// ***Important:*** A stream without any inputs can receive video frames **only** if backup file is specified.
	Inputs() []StreamInput
	// List of stream inputs.
	// ***Important:*** A stream without any inputs can receive video frames **only** if backup file is specified.
	SetInputs([]StreamInput) StreamConfigInput
}

type StreamConfigMedia interface {
	// DVR configuraton.
	Dvr() StreamDvrSpec
	// DVR configuraton.
	SetDvr(StreamDvrSpec) StreamConfigMedia
	// Stream labels in key value format.
	// Key is a string in unix_name format (alphanumeric characters, underscores, hyphens and periods).
	Labels() map[string]UnixName
	// Stream labels in key value format.
	// Key is a string in unix_name format (alphanumeric characters, underscores, hyphens and periods).
	SetLabels(map[string]UnixName) StreamConfigMedia
	// A list of pushes. When a server initiates the connection and sends a stream
	// to other server(s), it is called a `push`.
	Pushes() []StreamPush
	// A list of pushes. When a server initiates the connection and sends a stream
	// to other server(s), it is called a `push`.
	SetPushes([]StreamPush) StreamConfigMedia
}

type StreamConfigMultiedit interface {
	// DVR configuration.
	Dvr() StreamDvrSpec
	// DVR configuration.
	SetDvr(StreamDvrSpec) StreamConfigMultiedit
	// Rules of layout.
	LayoutRules() StreamZoneConfig
	// Rules of layout.
	SetLayoutRules(StreamZoneConfig) StreamConfigMultiedit
	// Stream name
	Name() *string
	// Stream name
	SetName(string) StreamConfigMultiedit
	// Preset identificator.
	PresetID() *int
	// Preset identificator.
	SetPresetID(int) StreamConfigMultiedit
}

type StreamConfigOnpremises interface {
	// Video analytics parameters.
	Vision() VisionSpec
	// Video analytics parameters.
	SetVision(VisionSpec) StreamConfigOnpremises
}

// Required: name
type StreamConfigSpecific interface {
	// Human-readable description of the stream.
	// Example: This is a test stream
	Comment() *string
	// Human-readable description of the stream.
	// Example: This is a test stream
	SetComment(string) StreamConfigSpecific
	// Globally unique stream name.
	// Note that the name could not be changed after the stream is created.
	// Format: media_name (media_name)
	// Examples: Decklink-Stream, Dektec-Stream, hockey1, mylive/bunny, test_stream
	Name() MediaName
	// Globally unique stream name.
	// Note that the name could not be changed after the stream is created.
	// Format: media_name (media_name)
	// Examples: Decklink-Stream, Dektec-Stream, hockey1, mylive/bunny, test_stream
	SetName(MediaName) StreamConfigSpecific
	// Human-readable title of the stream. Provided for SDT MPEG-TS table or
	// SDP RTSP title parameter.
	// Example: Hockey channel
	Title() *string
	// Human-readable title of the stream. Provided for SDT MPEG-TS table or
	// SDP RTSP title parameter.
	// Example: Hockey channel
	SetTitle(string) StreamConfigSpecific
}

type StreamDvrSpec interface {
	// Maximum disk consumption in percents. When this limit is reached,
	// the oldest segment of the recording will be overridden by later data.
	// It important to understand that this is not a "per-stream" option, this option means
	// that cleaning of this stream will be triggered if overall disk usage reaches this number.
	// If you have all streams with configuration 98% and one stream with 95%, it will be permanently
	// empty.
	// Format: percent (percent)
	// Example: 98
	DiskUsageLimit() *Percent
	// Maximum disk consumption in percents. When this limit is reached,
	// the oldest segment of the recording will be overridden by later data.
	// It important to understand that this is not a "per-stream" option, this option means
	// that cleaning of this stream will be triggered if overall disk usage reaches this number.
	// If you have all streams with configuration 98% and one stream with 95%, it will be permanently
	// empty.
	// Format: percent (percent)
	// Example: 98
	SetDiskUsageLimit(Percent) StreamDvrSpec
	// Additional archive depth in seconds for episodes. If set, episodes and their corresponding DVR record
	// will be saved for `expiration + episodes_expiration` seconds.
	// The archive clean-up within `[expiration, expiration+episodes_expiration]` seconds of the
	// recording performed depending on [external_episodes_list](https://flussonic.com/doc/api/config-external/#tag/dvr/operation/external_episodes_list)
	// response of `episodes_url`.
	// Anything older than `expiration+episodes_expiration` seconds will
	// be cleaned even if `episodes_url` does not respond.
	// Format: seconds (seconds)
	// Examples: 6.048e+06
	EpisodesExpiration() *Seconds
	// Additional archive depth in seconds for episodes. If set, episodes and their corresponding DVR record
	// will be saved for `expiration + episodes_expiration` seconds.
	// The archive clean-up within `[expiration, expiration+episodes_expiration]` seconds of the
	// recording performed depending on [external_episodes_list](https://flussonic.com/doc/api/config-external/#tag/dvr/operation/external_episodes_list)
	// response of `episodes_url`.
	// Anything older than `expiration+episodes_expiration` seconds will
	// be cleaned even if `episodes_url` does not respond.
	// Format: seconds (seconds)
	// Examples: 6.048e+06
	SetEpisodesExpiration(Seconds) StreamDvrSpec
	// Archive depth - a period (in seconds) back from the current moment during which the
	// contigious part of archive is stored.
	// As time goes, the parts of the recording which are older than the archive depth are deleted.
	// If you have option `episodes_expiration` enabled, then some parts of DVR that are
	// locked by episode signalling mechanism may be kept more than this `expiration` depth.
	// If `episodes_url` does not respond, the archive clean-up by `expiration` is not performed;
	// only the archive with expired episodes (`episodes_expiration`) is cleaned up until the `episodes_url` restores.
	// Format: seconds (seconds)
	// Examples: 604800
	Expiration() *Seconds
	// Archive depth - a period (in seconds) back from the current moment during which the
	// contigious part of archive is stored.
	// As time goes, the parts of the recording which are older than the archive depth are deleted.
	// If you have option `episodes_expiration` enabled, then some parts of DVR that are
	// locked by episode signalling mechanism may be kept more than this `expiration` depth.
	// If `episodes_url` does not respond, the archive clean-up by `expiration` is not performed;
	// only the archive with expired episodes (`episodes_expiration`) is cleaned up until the `episodes_url` restores.
	// Format: seconds (seconds)
	// Examples: 604800
	SetExpiration(Seconds) StreamDvrSpec
	// How many servers will contain a copy of the DVR archive.
	// You can find more information [here](https://flussonic.com/doc/api/layouter/#tag/stream/operation/streams_list/response%7Cstreams%7Cdvr%7Credundancy_factor)
	// Example: 1
	RedundancyFactor() *int
	// How many servers will contain a copy of the DVR archive.
	// You can find more information [here](https://flussonic.com/doc/api/layouter/#tag/stream/operation/streams_list/response%7Cstreams%7Cdvr%7Credundancy_factor)
	// Example: 1
	SetRedundancyFactor(int) StreamDvrSpec
	// Maximum disk consumption in bytes. When this limit is reached,
	// the oldest segment of the recording will be overridden by later data.
	// This option affects both continuous recording and locked episodes (see `episodes_url`).
	// If `episodes_url` does not respond, the archive clean-up by `storage_limit` is not performed
	// to avoid deleting the recordings that should not be deleted.
	// Format: bytes (bytes)
	// Example: 4e+11
	StorageLimit() *Bytes
	// Maximum disk consumption in bytes. When this limit is reached,
	// the oldest segment of the recording will be overridden by later data.
	// This option affects both continuous recording and locked episodes (see `episodes_url`).
	// If `episodes_url` does not respond, the archive clean-up by `storage_limit` is not performed
	// to avoid deleting the recordings that should not be deleted.
	// Format: bytes (bytes)
	// Example: 4e+11
	SetStorageLimit(Bytes) StreamDvrSpec
}

type StreamDvrSpecificSpec interface {
	// How many servers will contain a copy of the DVR archive.
	// You can find more information [here](https://flussonic.com/doc/api/layouter/#tag/stream/operation/streams_list/response%7Cstreams%7Cdvr%7Credundancy_factor)
	// Example: 1
	RedundancyFactor() *int
	// How many servers will contain a copy of the DVR archive.
	// You can find more information [here](https://flussonic.com/doc/api/layouter/#tag/stream/operation/streams_list/response%7Cstreams%7Cdvr%7Credundancy_factor)
	// Example: 1
	SetRedundancyFactor(int) StreamDvrSpecificSpec
}

type StreamInputBase interface {
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	AllowIf() *string
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	SetAllowIf(string) StreamInputBase
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	AudioTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetAudioTimeout(Seconds) StreamInputBase
	// Human-readable description of the input.
	// Example: This is a test input
	Comment() *string
	// Human-readable description of the input.
	// Example: This is a test input
	SetComment(string) StreamInputBase
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	DenyIf() *string
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	SetDenyIf(string) StreamInputBase
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	FramesTimeout() *int
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	SetFramesTimeout(int) StreamInputBase
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	Headers() map[string]string
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	SetHeaders(map[string]string) StreamInputBase
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	MaxRetryTimeout() *Seconds
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	SetMaxRetryTimeout(Seconds) StreamInputBase
	// Skip input start if the stream has no clients.
	NoClientsReconnectDelay() *int
	// Skip input start if the stream has no clients.
	SetNoClientsReconnectDelay(int) StreamInputBase
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	OutputAudio() *OutputAudio
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	SetOutputAudio(OutputAudio) StreamInputBase
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	Priority() *int
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	SetPriority(int) StreamInputBase
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SourceTimeout() any
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SetSourceTimeout(any) StreamInputBase
	// Detailed runtime information about the input.
	Stats() InputStats
	// Detailed runtime information about the input.
	SetStats(InputStats) StreamInputBase
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	Timeout() *int
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	SetTimeout(int) StreamInputBase
	// User agent. Can be modified if a protocol allows it.
	UserAgent() *string
	// User agent. Can be modified if a protocol allows it.
	SetUserAgent(string) StreamInputBase
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	Via() *AgentURL
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	SetVia(AgentURL) StreamInputBase
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	VideoTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetVideoTimeout(Seconds) StreamInputBase
}

type StreamInputFake interface {
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	AllowIf() *string
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	SetAllowIf(string) StreamInputFake
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	AudioTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetAudioTimeout(Seconds) StreamInputFake
	// Bitrate of an artificially created test video stream.
	// Applicable to the `fake://fake` URL.
	// Format: speed (speed)
	Bitrate() *Speed
	// Bitrate of an artificially created test video stream.
	// Applicable to the `fake://fake` URL.
	// Format: speed (speed)
	SetBitrate(Speed) StreamInputFake
	// Human-readable description of the input.
	// Example: This is a test input
	Comment() *string
	// Human-readable description of the input.
	// Example: This is a test input
	SetComment(string) StreamInputFake
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	DenyIf() *string
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	SetDenyIf(string) StreamInputFake
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	FramesTimeout() *int
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	SetFramesTimeout(int) StreamInputFake
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	Headers() map[string]string
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	SetHeaders(map[string]string) StreamInputFake
	// Height of an artificially created test video stream.
	// Applicable to the `fake://fake` URL.
	Height() *int
	// Height of an artificially created test video stream.
	// Applicable to the `fake://fake` URL.
	SetHeight(int) StreamInputFake
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	MaxRetryTimeout() *Seconds
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	SetMaxRetryTimeout(Seconds) StreamInputFake
	// Skip input start if the stream has no clients.
	NoClientsReconnectDelay() *int
	// Skip input start if the stream has no clients.
	SetNoClientsReconnectDelay(int) StreamInputFake
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	OutputAudio() *OutputAudio
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	SetOutputAudio(OutputAudio) StreamInputFake
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	Priority() *int
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	SetPriority(int) StreamInputFake
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SourceTimeout() any
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SetSourceTimeout(any) StreamInputFake
	// Detailed runtime information about the input.
	Stats() InputStats
	// Detailed runtime information about the input.
	SetStats(InputStats) StreamInputFake
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	Timeout() *int
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	SetTimeout(int) StreamInputFake
	// URL to get a demo stream.
	// Format: input_url (input_url)
	// Pattern: ^fake://.*$
	// Example: fake://fake
	URL() InputURL
	// URL to get a demo stream.
	// Format: input_url (input_url)
	// Pattern: ^fake://.*$
	// Example: fake://fake
	SetURL(InputURL) StreamInputFake
	// User agent. Can be modified if a protocol allows it.
	UserAgent() *string
	// User agent. Can be modified if a protocol allows it.
	SetUserAgent(string) StreamInputFake
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	Via() *AgentURL
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	SetVia(AgentURL) StreamInputFake
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	VideoTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetVideoTimeout(Seconds) StreamInputFake
	// Width of an artificially created test video stream.
	// Applicable to the `fake://fake` URL.
	Width() *int
	// Width of an artificially created test video stream.
	// Applicable to the `fake://fake` URL.
	SetWidth(int) StreamInputFake
}

type StreamInputFile interface {
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	AllowIf() *string
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	SetAllowIf(string) StreamInputFile
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	AudioTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetAudioTimeout(Seconds) StreamInputFile
	// The rules for handling the closed captions.
	ClosedCaptions() map[string]string
	// The rules for handling the closed captions.
	SetClosedCaptions(map[string]string) StreamInputFile
	// Human-readable description of the input.
	// Example: This is a test input
	Comment() *string
	// Human-readable description of the input.
	// Example: This is a test input
	SetComment(string) StreamInputFile
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	DenyIf() *string
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	SetDenyIf(string) StreamInputFile
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	FramesTimeout() *int
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	SetFramesTimeout(int) StreamInputFile
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	Headers() map[string]string
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	SetHeaders(map[string]string) StreamInputFile
	// An array of MPEG-TS language descriptors in format `[{key: track, value: language}]`
	Languages() map[string]string
	// An array of MPEG-TS language descriptors in format `[{key: track, value: language}]`
	SetLanguages(map[string]string) StreamInputFile
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	MaxRetryTimeout() *Seconds
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	SetMaxRetryTimeout(Seconds) StreamInputFile
	// Skip input start if the stream has no clients.
	NoClientsReconnectDelay() *int
	// Skip input start if the stream has no clients.
	SetNoClientsReconnectDelay(int) StreamInputFile
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	OutputAudio() *OutputAudio
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	SetOutputAudio(OutputAudio) StreamInputFile
	// Choose a specific PID to ingest from an MPEG-TS stream.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Example: [211]
	Pids() []int
	// Choose a specific PID to ingest from an MPEG-TS stream.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Example: [211]
	SetPids([]int) StreamInputFile
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	Priority() *int
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	SetPriority(int) StreamInputFile
	// Choose a program to ingest from an MPEG-TS stream.
	// Example: [1]
	Programs() []int
	// Choose a program to ingest from an MPEG-TS stream.
	// Example: [1]
	SetPrograms([]int) StreamInputFile
	// Deprecated field. Will be deleted at 23.09
	// This option disables processing of SCTE-35 markers from an MPEG-TS input stream.
	// Deprecated since 22.12.
	// Available ways to disable processing of SCTE-35 markers:
	// 1. pids option to select tracks without SCTE-35 markers
	// 2. hls_scte35 option from stream_config_media for hls output
	// 3. performing appropriate tuning pids in the transponder
	// Example: true
	Scte35() *bool
	// Deprecated field. Will be deleted at 23.09
	// This option disables processing of SCTE-35 markers from an MPEG-TS input stream.
	// Deprecated since 22.12.
	// Available ways to disable processing of SCTE-35 markers:
	// 1. pids option to select tracks without SCTE-35 markers
	// 2. hls_scte35 option from stream_config_media for hls output
	// 3. performing appropriate tuning pids in the transponder
	// Example: true
	SetScte35(bool) StreamInputFile
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SourceTimeout() any
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SetSourceTimeout(any) StreamInputFile
	// Detailed runtime information about the input.
	Stats() InputStats
	// Detailed runtime information about the input.
	SetStats(InputStats) StreamInputFile
	// Deprecated field. Will be deleted at 25.03
	// This configuration is deprecated. Use `dvbocr` configuration field in stream.
	// This parameter allows to manage subtitles in an output stream.
	// Example: drop
	Subtitles() *StreamInputMpegtsSpecificSubtitles
	// Deprecated field. Will be deleted at 25.03
	// This configuration is deprecated. Use `dvbocr` configuration field in stream.
	// This parameter allows to manage subtitles in an output stream.
	// Example: drop
	SetSubtitles(StreamInputMpegtsSpecificSubtitles) StreamInputFile
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	Timeout() *int
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	SetTimeout(int) StreamInputFile
	// URL to get a stream from file.
	// Format: input_url (input_url)
	// Pattern: ^file://.*$
	// Example: file://vod/bunny.mp4
	URL() InputURL
	// URL to get a stream from file.
	// Format: input_url (input_url)
	// Pattern: ^file://.*$
	// Example: file://vod/bunny.mp4
	SetURL(InputURL) StreamInputFile
	// User agent. Can be modified if a protocol allows it.
	UserAgent() *string
	// User agent. Can be modified if a protocol allows it.
	SetUserAgent(string) StreamInputFile
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	Via() *AgentURL
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	SetVia(AgentURL) StreamInputFile
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	VideoTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetVideoTimeout(Seconds) StreamInputFile
}

type StreamInputMpegtsSpecific interface {
	// The rules for handling the closed captions.
	ClosedCaptions() map[string]string
	// The rules for handling the closed captions.
	SetClosedCaptions(map[string]string) StreamInputMpegtsSpecific
	// An array of MPEG-TS language descriptors in format `[{key: track, value: language}]`
	Languages() map[string]string
	// An array of MPEG-TS language descriptors in format `[{key: track, value: language}]`
	SetLanguages(map[string]string) StreamInputMpegtsSpecific
	// Choose a specific PID to ingest from an MPEG-TS stream.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Example: [211]
	Pids() []int
	// Choose a specific PID to ingest from an MPEG-TS stream.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Example: [211]
	SetPids([]int) StreamInputMpegtsSpecific
	// Choose a program to ingest from an MPEG-TS stream.
	// Example: [1]
	Programs() []int
	// Choose a program to ingest from an MPEG-TS stream.
	// Example: [1]
	SetPrograms([]int) StreamInputMpegtsSpecific
	// Deprecated field. Will be deleted at 23.09
	// This option disables processing of SCTE-35 markers from an MPEG-TS input stream.
	// Deprecated since 22.12.
	// Available ways to disable processing of SCTE-35 markers:
	// 1. pids option to select tracks without SCTE-35 markers
	// 2. hls_scte35 option from stream_config_media for hls output
	// 3. performing appropriate tuning pids in the transponder
	// Example: true
	Scte35() *bool
	// Deprecated field. Will be deleted at 23.09
	// This option disables processing of SCTE-35 markers from an MPEG-TS input stream.
	// Deprecated since 22.12.
	// Available ways to disable processing of SCTE-35 markers:
	// 1. pids option to select tracks without SCTE-35 markers
	// 2. hls_scte35 option from stream_config_media for hls output
	// 3. performing appropriate tuning pids in the transponder
	// Example: true
	SetScte35(bool) StreamInputMpegtsSpecific
	// Deprecated field. Will be deleted at 25.03
	// This configuration is deprecated. Use `dvbocr` configuration field in stream.
	// This parameter allows to manage subtitles in an output stream.
	// Example: drop
	Subtitles() *StreamInputMpegtsSpecificSubtitles
	// Deprecated field. Will be deleted at 25.03
	// This configuration is deprecated. Use `dvbocr` configuration field in stream.
	// This parameter allows to manage subtitles in an output stream.
	// Example: drop
	SetSubtitles(StreamInputMpegtsSpecificSubtitles) StreamInputMpegtsSpecific
}

type StreamInputPublish interface {
	// The correction between the target bitrate (Receiver Estimated Maximum Bitrate, calculated in Flussonic) and browser bitrate, in kbit/s.
	// Flussonic sends the target bitrate to the browser from which the publication is carried out so that the browser adjusts the bitrate of the publication by this value.
	// The default value is 300 kbit/s.
	// Example: 200
	AbrCorrection() *int
	// The correction between the target bitrate (Receiver Estimated Maximum Bitrate, calculated in Flussonic) and browser bitrate, in kbit/s.
	// Flussonic sends the target bitrate to the browser from which the publication is carried out so that the browser adjusts the bitrate of the publication by this value.
	// The default value is 300 kbit/s.
	// Example: 200
	SetAbrCorrection(int) StreamInputPublish
	// The number of cycles of bitrate auto-adjustment.
	// After the specified number of auto-adjustment cycles passes, Flussonic considers the bitrate to be optimal, and it is no longer analyzed.
	// By default, `abr_cycles`=5.
	// If `abr_cycles`=0, the adjustment process takes place all the time while the publication lasts.
	// Example: 3
	AbrCycles() *int
	// The number of cycles of bitrate auto-adjustment.
	// After the specified number of auto-adjustment cycles passes, Flussonic considers the bitrate to be optimal, and it is no longer analyzed.
	// By default, `abr_cycles`=5.
	// If `abr_cycles`=0, the adjustment process takes place all the time while the publication lasts.
	// Example: 3
	SetAbrCycles(int) StreamInputPublish
	// Whether adaptive bitrate process is logged.
	// Example: 1
	AbrDebug() *int
	// Whether adaptive bitrate process is logged.
	// Example: 1
	SetAbrDebug(int) StreamInputPublish
	// The lower limit of packet loss. When it is reached, Flussonic raises the bitrate.
	// That is, if packet loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup` percent.
	// Example: 2
	AbrLossLower() *float64
	// The lower limit of packet loss. When it is reached, Flussonic raises the bitrate.
	// That is, if packet loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup` percent.
	// Example: 2
	SetAbrLossLower(float64) StreamInputPublish
	// The upper limit of packet loss. When it is reached, Flussonic reduces the bitrate.
	// That is, if packet loss is greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.
	// Example: 10
	AbrLossUpper() *float64
	// The upper limit of packet loss. When it is reached, Flussonic reduces the bitrate.
	// That is, if packet loss is greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.
	// Example: 10
	SetAbrLossUpper(float64) StreamInputPublish
	// Maximum bitrate for adjustment process, in kbit/s.
	// Flussonic will keep the publication bitrate equal or below of the specified value.
	// Example: 1000
	AbrMaxBitrate() *int
	// Maximum bitrate for adjustment process, in kbit/s.
	// Flussonic will keep the publication bitrate equal or below of the specified value.
	// Example: 1000
	SetAbrMaxBitrate(int) StreamInputPublish
	// The algorithm for determining the need to change the bitrate of the published stream and for calculating the target bitrate.
	// Two options are possible:
	// * `abr_mode=0` - This mode takes into account the packet losses, target bitrate, browser bitrate and the number of auto-adjustment cycles.
	// * `abr_mode=1` - This mode considers only packet losses and target bitrate.
	// Example: 1
	AbrMode() *int
	// The algorithm for determining the need to change the bitrate of the published stream and for calculating the target bitrate.
	// Two options are possible:
	// * `abr_mode=0` - This mode takes into account the packet losses, target bitrate, browser bitrate and the number of auto-adjustment cycles.
	// * `abr_mode=1` - This mode considers only packet losses and target bitrate.
	// Example: 1
	SetAbrMode(int) StreamInputPublish
	// A step of reducing the bitrate to the minimum.
	// If packet losses are greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.
	AbrStepdown() *float64
	// A step of reducing the bitrate to the minimum.
	// If packet losses are greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.
	SetAbrStepdown(float64) StreamInputPublish
	// Increment step for raising the bitrate to the maximum, in percent. The default step is 30%.
	// If the loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup percent`.
	AbrStepup() *int
	// Increment step for raising the bitrate to the maximum, in percent. The default step is 30%.
	// If the loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup percent`.
	SetAbrStepup(int) StreamInputPublish
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	AllowIf() *string
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	SetAllowIf(string) StreamInputPublish
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	AudioTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetAudioTimeout(Seconds) StreamInputPublish
	// Human-readable description of the input.
	// Example: This is a test input
	Comment() *string
	// Human-readable description of the input.
	// Example: This is a test input
	SetComment(string) StreamInputPublish
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	DenyIf() *string
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	SetDenyIf(string) StreamInputPublish
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	FramesTimeout() *int
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	SetFramesTimeout(int) StreamInputPublish
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	Headers() map[string]string
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	SetHeaders(map[string]string) StreamInputPublish
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	MaxRetryTimeout() *Seconds
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	SetMaxRetryTimeout(Seconds) StreamInputPublish
	// The minimum bitrate threshold, in kbit/s. The default value is 100 kbit/s.
	// Example: 150
	MinBitrate() *int
	// The minimum bitrate threshold, in kbit/s. The default value is 100 kbit/s.
	// Example: 150
	SetMinBitrate(int) StreamInputPublish
	// Skip input start if the stream has no clients.
	NoClientsReconnectDelay() *int
	// Skip input start if the stream has no clients.
	SetNoClientsReconnectDelay(int) StreamInputPublish
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	OutputAudio() *OutputAudio
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	SetOutputAudio(OutputAudio) StreamInputPublish
	// Deprecated field. Will be deleted at 24.11
	// Choose one of the listed video codecs at the start of the publication via WebRTC.
	// Example: av1
	PreferCodec() *WebrtcPreferVideoCodec
	// Deprecated field. Will be deleted at 24.11
	// Choose one of the listed video codecs at the start of the publication via WebRTC.
	// Example: av1
	SetPreferCodec(WebrtcPreferVideoCodec) StreamInputPublish
	// Prefer one of the listed video codecs at the start of the publication via WebRTC.
	// Example: av1
	PreferVideoCodec() *WebrtcPreferVideoCodec
	// Prefer one of the listed video codecs at the start of the publication via WebRTC.
	// Example: av1
	SetPreferVideoCodec(WebrtcPreferVideoCodec) StreamInputPublish
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	Priority() *int
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	SetPriority(int) StreamInputPublish
	// This option disables processing of SCTE-35 markers from SRT input stream.
	// Example: true
	Scte35() *bool
	// This option disables processing of SCTE-35 markers from SRT input stream.
	// Example: true
	SetScte35(bool) StreamInputPublish
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SourceTimeout() any
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SetSourceTimeout(any) StreamInputPublish
	// Detailed runtime information about the input.
	Stats() InputStats
	// Detailed runtime information about the input.
	SetStats(InputStats) StreamInputPublish
	// Deprecated field. Will be deleted at 25.03
	// This configuration is deprecated. Use `dvbocr` configuration field in stream.
	// This parameter allows to manage subtitles in an output stream.
	// Example: drop
	Subtitles() *StreamInputSrtPublishSpecificSubtitles
	// Deprecated field. Will be deleted at 25.03
	// This configuration is deprecated. Use `dvbocr` configuration field in stream.
	// This parameter allows to manage subtitles in an output stream.
	// Example: drop
	SetSubtitles(StreamInputSrtPublishSpecificSubtitles) StreamInputPublish
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	Timeout() *int
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	SetTimeout(int) StreamInputPublish
	// Choose the prefered transport of the publication via WebRTC: UDP or TCP.
	// Example: udp
	Transport() *WebrtcTransport
	// Choose the prefered transport of the publication via WebRTC: UDP or TCP.
	// Example: udp
	SetTransport(WebrtcTransport) StreamInputPublish
	// The publish:// URL used to indicate where this stream started in publish mode.
	// You can publish videos to Flussonic using the following URLs:
	// __RTSP__: rtsp://FLUSSONIC-IP/stream_name
	// __HTTP MPEG-TS__: http://FLUSSONIC-IP/stream_name/mpegts
	// __RTMP__: rtmp://flussonic-ip/published or rtmp://flussonic-ip/static/published
	// __WebRTC__: http://FLUSSONIC-IP/stream_name/whip
	// __SRT__: srt://FLUSSONIC-IP:SRT_PORT?streamid=#!::r=STREAM_NAME,m=publish
	// Format: input_url (input_url)
	// Pattern: ^publish://.*$
	// Example: publish://
	URL() InputURL
	// The publish:// URL used to indicate where this stream started in publish mode.
	// You can publish videos to Flussonic using the following URLs:
	// __RTSP__: rtsp://FLUSSONIC-IP/stream_name
	// __HTTP MPEG-TS__: http://FLUSSONIC-IP/stream_name/mpegts
	// __RTMP__: rtmp://flussonic-ip/published or rtmp://flussonic-ip/static/published
	// __WebRTC__: http://FLUSSONIC-IP/stream_name/whip
	// __SRT__: srt://FLUSSONIC-IP:SRT_PORT?streamid=#!::r=STREAM_NAME,m=publish
	// Format: input_url (input_url)
	// Pattern: ^publish://.*$
	// Example: publish://
	SetURL(InputURL) StreamInputPublish
	// User agent. Can be modified if a protocol allows it.
	UserAgent() *string
	// User agent. Can be modified if a protocol allows it.
	SetUserAgent(string) StreamInputPublish
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	Via() *AgentURL
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	SetVia(AgentURL) StreamInputPublish
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	VideoTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetVideoTimeout(Seconds) StreamInputPublish
	// Whether the adaptive bitrate mechanism is used for WebRTC publications.
	// Example: true
	WebrtcAbr() *bool
	// Whether the adaptive bitrate mechanism is used for WebRTC publications.
	// Example: true
	SetWebrtcAbr(bool) StreamInputPublish
}

type StreamInputRtsp interface {
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	AllowIf() *string
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	SetAllowIf(string) StreamInputRtsp
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	AudioTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetAudioTimeout(Seconds) StreamInputRtsp
	// Human-readable description of the input.
	// Example: This is a test input
	Comment() *string
	// Human-readable description of the input.
	// Example: This is a test input
	SetComment(string) StreamInputRtsp
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	DenyIf() *string
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	SetDenyIf(string) StreamInputRtsp
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	FramesTimeout() *int
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	SetFramesTimeout(int) StreamInputRtsp
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	Headers() map[string]string
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	SetHeaders(map[string]string) StreamInputRtsp
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	MaxRetryTimeout() *Seconds
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	SetMaxRetryTimeout(Seconds) StreamInputRtsp
	// Skip input start if the stream has no clients.
	NoClientsReconnectDelay() *int
	// Skip input start if the stream has no clients.
	SetNoClientsReconnectDelay(int) StreamInputRtsp
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	OutputAudio() *OutputAudio
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	SetOutputAudio(OutputAudio) StreamInputRtsp
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	Priority() *int
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	SetPriority(int) StreamInputRtsp
	// Whether to force UDP to capture a video from RTSP cameras.
	RTP() *string
	// Whether to force UDP to capture a video from RTSP cameras.
	SetRTP(string) StreamInputRtsp
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SourceTimeout() any
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SetSourceTimeout(any) StreamInputRtsp
	// Detailed runtime information about the input.
	Stats() InputStats
	// Detailed runtime information about the input.
	SetStats(InputStats) StreamInputRtsp
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	Timeout() *int
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	SetTimeout(int) StreamInputRtsp
	// URL to connect to the RTSP source and get the stream.
	// Format: input_url (input_url)
	// Pattern: ^(rtsp|rtsps|rtsp-udp|rtsp2)://.*$
	// Examples: rtsp-udp://remote.host.com/example, rtsp2://remote.host.com/example, rtsp://remote.host.com/example, rtsps://remote.host.com/example
	URL() InputURL
	// URL to connect to the RTSP source and get the stream.
	// Format: input_url (input_url)
	// Pattern: ^(rtsp|rtsps|rtsp-udp|rtsp2)://.*$
	// Examples: rtsp-udp://remote.host.com/example, rtsp2://remote.host.com/example, rtsp://remote.host.com/example, rtsps://remote.host.com/example
	SetURL(InputURL) StreamInputRtsp
	// User agent. Can be modified if a protocol allows it.
	UserAgent() *string
	// User agent. Can be modified if a protocol allows it.
	SetUserAgent(string) StreamInputRtsp
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	Via() *AgentURL
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	SetVia(AgentURL) StreamInputRtsp
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	VideoTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetVideoTimeout(Seconds) StreamInputRtsp
	// Whether to wait for the full RTP time synchronization before the processing of frames from the RTSP camera.
	WaitRtcp() *bool
	// Whether to wait for the full RTP time synchronization before the processing of frames from the RTSP camera.
	SetWaitRtcp(bool) StreamInputRtsp
}

type StreamInputSrtPublishSpecific interface {
	// This option disables processing of SCTE-35 markers from SRT input stream.
	// Example: true
	Scte35() *bool
	// This option disables processing of SCTE-35 markers from SRT input stream.
	// Example: true
	SetScte35(bool) StreamInputSrtPublishSpecific
	// Deprecated field. Will be deleted at 25.03
	// This configuration is deprecated. Use `dvbocr` configuration field in stream.
	// This parameter allows to manage subtitles in an output stream.
	// Example: drop
	Subtitles() *StreamInputSrtPublishSpecificSubtitles
	// Deprecated field. Will be deleted at 25.03
	// This configuration is deprecated. Use `dvbocr` configuration field in stream.
	// This parameter allows to manage subtitles in an output stream.
	// Example: drop
	SetSubtitles(StreamInputSrtPublishSpecificSubtitles) StreamInputSrtPublishSpecific
}

// Title: WebRTC
type StreamInputWebrtcPublishSpecific interface {
	// The correction between the target bitrate (Receiver Estimated Maximum Bitrate, calculated in Flussonic) and browser bitrate, in kbit/s.
	// Flussonic sends the target bitrate to the browser from which the publication is carried out so that the browser adjusts the bitrate of the publication by this value.
	// The default value is 300 kbit/s.
	// Example: 200
	AbrCorrection() *int
	// The correction between the target bitrate (Receiver Estimated Maximum Bitrate, calculated in Flussonic) and browser bitrate, in kbit/s.
	// Flussonic sends the target bitrate to the browser from which the publication is carried out so that the browser adjusts the bitrate of the publication by this value.
	// The default value is 300 kbit/s.
	// Example: 200
	SetAbrCorrection(int) StreamInputWebrtcPublishSpecific
	// The number of cycles of bitrate auto-adjustment.
	// After the specified number of auto-adjustment cycles passes, Flussonic considers the bitrate to be optimal, and it is no longer analyzed.
	// By default, `abr_cycles`=5.
	// If `abr_cycles`=0, the adjustment process takes place all the time while the publication lasts.
	// Example: 3
	AbrCycles() *int
	// The number of cycles of bitrate auto-adjustment.
	// After the specified number of auto-adjustment cycles passes, Flussonic considers the bitrate to be optimal, and it is no longer analyzed.
	// By default, `abr_cycles`=5.
	// If `abr_cycles`=0, the adjustment process takes place all the time while the publication lasts.
	// Example: 3
	SetAbrCycles(int) StreamInputWebrtcPublishSpecific
	// Whether adaptive bitrate process is logged.
	// Example: 1
	AbrDebug() *int
	// Whether adaptive bitrate process is logged.
	// Example: 1
	SetAbrDebug(int) StreamInputWebrtcPublishSpecific
	// The lower limit of packet loss. When it is reached, Flussonic raises the bitrate.
	// That is, if packet loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup` percent.
	// Example: 2
	AbrLossLower() *float64
	// The lower limit of packet loss. When it is reached, Flussonic raises the bitrate.
	// That is, if packet loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup` percent.
	// Example: 2
	SetAbrLossLower(float64) StreamInputWebrtcPublishSpecific
	// The upper limit of packet loss. When it is reached, Flussonic reduces the bitrate.
	// That is, if packet loss is greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.
	// Example: 10
	AbrLossUpper() *float64
	// The upper limit of packet loss. When it is reached, Flussonic reduces the bitrate.
	// That is, if packet loss is greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.
	// Example: 10
	SetAbrLossUpper(float64) StreamInputWebrtcPublishSpecific
	// Maximum bitrate for adjustment process, in kbit/s.
	// Flussonic will keep the publication bitrate equal or below of the specified value.
	// Example: 1000
	AbrMaxBitrate() *int
	// Maximum bitrate for adjustment process, in kbit/s.
	// Flussonic will keep the publication bitrate equal or below of the specified value.
	// Example: 1000
	SetAbrMaxBitrate(int) StreamInputWebrtcPublishSpecific
	// The algorithm for determining the need to change the bitrate of the published stream and for calculating the target bitrate.
	// Two options are possible:
	// * `abr_mode=0` - This mode takes into account the packet losses, target bitrate, browser bitrate and the number of auto-adjustment cycles.
	// * `abr_mode=1` - This mode considers only packet losses and target bitrate.
	// Example: 1
	AbrMode() *int
	// The algorithm for determining the need to change the bitrate of the published stream and for calculating the target bitrate.
	// Two options are possible:
	// * `abr_mode=0` - This mode takes into account the packet losses, target bitrate, browser bitrate and the number of auto-adjustment cycles.
	// * `abr_mode=1` - This mode considers only packet losses and target bitrate.
	// Example: 1
	SetAbrMode(int) StreamInputWebrtcPublishSpecific
	// A step of reducing the bitrate to the minimum.
	// If packet losses are greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.
	AbrStepdown() *float64
	// A step of reducing the bitrate to the minimum.
	// If packet losses are greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.
	SetAbrStepdown(float64) StreamInputWebrtcPublishSpecific
	// Increment step for raising the bitrate to the maximum, in percent. The default step is 30%.
	// If the loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup percent`.
	AbrStepup() *int
	// Increment step for raising the bitrate to the maximum, in percent. The default step is 30%.
	// If the loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup percent`.
	SetAbrStepup(int) StreamInputWebrtcPublishSpecific
	// The minimum bitrate threshold, in kbit/s. The default value is 100 kbit/s.
	// Example: 150
	MinBitrate() *int
	// The minimum bitrate threshold, in kbit/s. The default value is 100 kbit/s.
	// Example: 150
	SetMinBitrate(int) StreamInputWebrtcPublishSpecific
	// Deprecated field. Will be deleted at 24.11
	// Choose one of the listed video codecs at the start of the publication via WebRTC.
	// Example: av1
	PreferCodec() *WebrtcPreferVideoCodec
	// Deprecated field. Will be deleted at 24.11
	// Choose one of the listed video codecs at the start of the publication via WebRTC.
	// Example: av1
	SetPreferCodec(WebrtcPreferVideoCodec) StreamInputWebrtcPublishSpecific
	// Prefer one of the listed video codecs at the start of the publication via WebRTC.
	// Example: av1
	PreferVideoCodec() *WebrtcPreferVideoCodec
	// Prefer one of the listed video codecs at the start of the publication via WebRTC.
	// Example: av1
	SetPreferVideoCodec(WebrtcPreferVideoCodec) StreamInputWebrtcPublishSpecific
	// Choose the prefered transport of the publication via WebRTC: UDP or TCP.
	// Example: udp
	Transport() *WebrtcTransport
	// Choose the prefered transport of the publication via WebRTC: UDP or TCP.
	// Example: udp
	SetTransport(WebrtcTransport) StreamInputWebrtcPublishSpecific
	// Whether the adaptive bitrate mechanism is used for WebRTC publications.
	// Example: true
	WebrtcAbr() *bool
	// Whether the adaptive bitrate mechanism is used for WebRTC publications.
	// Example: true
	SetWebrtcAbr(bool) StreamInputWebrtcPublishSpecific
}

type StreamOnvifConfig interface {
	// Shows if PTZ control should be enabled for the camera.
	// The PTZ function must be supported and enabled on the ONVIF camera
	// in order to be able to actually control PTZ from Watcher or your UI.
	Ptz() *bool
	// Shows if PTZ control should be enabled for the camera.
	// The PTZ function must be supported and enabled on the ONVIF camera
	// in order to be able to actually control PTZ from Watcher or your UI.
	SetPtz(bool) StreamOnvifConfig
	// The URL that Watcher uses for exchanging data with the camera via ONVIF.
	// This URL usually can be found in the manual for your camera.
	URL() *string
	// The URL that Watcher uses for exchanging data with the camera via ONVIF.
	// This URL usually can be found in the manual for your camera.
	SetURL(string) StreamOnvifConfig
}

type StreamPathItem interface {
	// ID of the path item the stream is included in.
	ID() *int
	// ID of the path item the stream is included in.
	SetID(int) StreamPathItem
	// Title of path item the stream is included in.
	Title() *string
	// Title of path item the stream is included in.
	SetTitle(string) StreamPathItem
}

type StreamPreset interface {
	// Preset identificator.
	ID() *int
	// Preset identificator.
	SetID(int) StreamPreset
	// Shows if the preset is adjustable.
	// ```is_adjustable``` is needed for a situation where presets are managed by external billing.
	// If ```is_adjustable: true``` user can change camera settings meanwhile using this preset.
	// If ```is_adjustable: false``` user can not change camera settings meanwhile using this preset.
	// If the camera has a non-adjustable presets, the DVR and analytics parameters from PUT requests will not be applied.
	// In this case, either make the preset adjustable, or change the preset itself to achieve the required configuration.
	// Example: true
	IsAdjustable() *bool
	// Shows if the preset is adjustable.
	// ```is_adjustable``` is needed for a situation where presets are managed by external billing.
	// If ```is_adjustable: true``` user can change camera settings meanwhile using this preset.
	// If ```is_adjustable: false``` user can not change camera settings meanwhile using this preset.
	// If the camera has a non-adjustable presets, the DVR and analytics parameters from PUT requests will not be applied.
	// In this case, either make the preset adjustable, or change the preset itself to achieve the required configuration.
	// Example: true
	SetIsAdjustable(bool) StreamPreset
	// Human-readable name of the preset.
	// Example: Example preset name
	Title() *string
	// Human-readable name of the preset.
	// Example: Example preset name
	SetTitle(string) StreamPreset
}

type StreamPushBase interface {
	// Human-readable description of the pusher.
	// Example: This is a test push
	Comment() *string
	// Human-readable description of the pusher.
	// Example: This is a test push
	SetComment(string) StreamPushBase
	// Disable pushing the stream.
	// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
	// In this way, the URL and other settings of a disabled stream remain in Flussonic.
	Disabled() *bool
	// Disable pushing the stream.
	// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
	// In this way, the URL and other settings of a disabled stream remain in Flussonic.
	SetDisabled(bool) StreamPushBase
	// The maximum number of times *Flussonic* retries to push the stream.
	RetryLimit() *int
	// The maximum number of times *Flussonic* retries to push the stream.
	SetRetryLimit(int) StreamPushBase
	// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
	// It is an interval in seconds, 5 seconds by default.
	// You can increase this value to reduce server load.
	// Format: seconds (seconds)
	// Example: 7
	RetryTimeout() *Seconds
	// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
	// It is an interval in seconds, 5 seconds by default.
	// You can increase this value to reduce server load.
	// Format: seconds (seconds)
	// Example: 7
	SetRetryTimeout(Seconds) StreamPushBase
	// Detailed runtime information about the push.
	Stats() PushCounters
	// Detailed runtime information about the push.
	SetStats(PushCounters) StreamPushBase
	// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
	// Format: seconds (seconds)
	// Example: 10
	Timeout() *Seconds
	// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
	// Format: seconds (seconds)
	// Example: 10
	SetTimeout(Seconds) StreamPushBase
}

type StreamPushRtmp interface {
	// Human-readable description of the pusher.
	// Example: This is a test push
	Comment() *string
	// Human-readable description of the pusher.
	// Example: This is a test push
	SetComment(string) StreamPushRtmp
	// Disable pushing the stream.
	// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
	// In this way, the URL and other settings of a disabled stream remain in Flussonic.
	Disabled() *bool
	// Disable pushing the stream.
	// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
	// In this way, the URL and other settings of a disabled stream remain in Flussonic.
	SetDisabled(bool) StreamPushRtmp
	// The maximum number of times *Flussonic* retries to push the stream.
	RetryLimit() *int
	// The maximum number of times *Flussonic* retries to push the stream.
	SetRetryLimit(int) StreamPushRtmp
	// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
	// It is an interval in seconds, 5 seconds by default.
	// You can increase this value to reduce server load.
	// Format: seconds (seconds)
	// Example: 7
	RetryTimeout() *Seconds
	// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
	// It is an interval in seconds, 5 seconds by default.
	// You can increase this value to reduce server load.
	// Format: seconds (seconds)
	// Example: 7
	SetRetryTimeout(Seconds) StreamPushRtmp
	// Detailed runtime information about the push.
	Stats() PushCounters
	// Detailed runtime information about the push.
	SetStats(PushCounters) StreamPushRtmp
	// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
	// Format: seconds (seconds)
	// Example: 10
	Timeout() *Seconds
	// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
	// Format: seconds (seconds)
	// Example: 10
	SetTimeout(Seconds) StreamPushRtmp
	// RTMP URL where to push.
	// You can publish to RTMP servers. Usually it is a social network streaming.
	// Format: input_url (input_url)
	// Pattern: ^rtmps?://.*$
	// Examples: rtmp://your-server.com/app/stream1
	URL() InputURL
	// RTMP URL where to push.
	// You can publish to RTMP servers. Usually it is a social network streaming.
	// Format: input_url (input_url)
	// Pattern: ^rtmps?://.*$
	// Examples: rtmp://your-server.com/app/stream1
	SetURL(InputURL) StreamPushRtmp
}

type StreamStats interface {
	// The status of the Agent serving the stream.
	AgentStatus() *string
	// The status of the Agent serving the stream.
	SetAgentStatus(string) StreamStats
	// Becomes `false` when `ts_delay` > 12000 (= 12 seconds)
	// Example: true
	Alive() *bool
	// Becomes `false` when `ts_delay` > 12000 (= 12 seconds)
	// Example: true
	SetAlive(bool) StreamStats
	// Stream bitrate.
	// Format: speed (speed)
	// Example: 186
	Bitrate() *Speed
	// Stream bitrate.
	// Format: speed (speed)
	// Example: 186
	SetBitrate(Speed) StreamStats
	// The amount of stream data sent to the clients.
	// Format: bytes (bytes)
	// Example: 0
	BytesOut() *Bytes
	// The amount of stream data sent to the clients.
	// Format: bytes (bytes)
	// Example: 0
	SetBytesOut(Bytes) StreamStats
	// The identifier of the Agent that is currently serving the stream.
	// Format: agent_id (agent_id)
	CurrentAgentID() *AgentID
	// The identifier of the Agent that is currently serving the stream.
	// Format: agent_id (agent_id)
	SetCurrentAgentID(AgentID) StreamStats
	// The information about the recorded DVR archive.
	DvrInfo() DvrInfo
	// The information about the recorded DVR archive.
	SetDvrInfo(DvrInfo) StreamStats
	// The time when the last time frame was sent to the stream output (in UTC).
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.636383841974e+12
	LastDtsAt() *UtcMs
	// The time when the last time frame was sent to the stream output (in UTC).
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.636383841974e+12
	SetLastDtsAt(UtcMs) StreamStats
	// The time period in seconds during which the stream is being captured.
	// Can be calculated from `opened_at`
	// Format: milliseconds (milliseconds)
	// Example: 71977
	Lifetime() *Milliseconds
	// The time period in seconds during which the stream is being captured.
	// Can be calculated from `opened_at`
	// Format: milliseconds (milliseconds)
	// Example: 71977
	SetLifetime(Milliseconds) StreamStats
	// Technical information about the output media content.
	MediaInfo() MediaInfo
	// Technical information about the output media content.
	SetMediaInfo(MediaInfo) StreamStats
	// Deprecated field. Will be deleted at 25.04
	// The number of clients receiving the stream.
	// Use play.play_opened_sessions instead
	// Format: client_count (client_count)
	// Example: 3
	OnlineClients() *ClientCount
	// Deprecated field. Will be deleted at 25.04
	// The number of clients receiving the stream.
	// Use play.play_opened_sessions instead
	// Format: client_count (client_count)
	// Example: 3
	SetOnlineClients(ClientCount) StreamStats
	// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
	// Example: onetime_token
	PlaybackToken() *string
	// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
	// Example: onetime_token
	SetPlaybackToken(string) StreamStats
	// Publish endpoint. Used to publish the stream.
	PublishEndpoint() *string
	// Publish endpoint. Used to publish the stream.
	SetPublishEndpoint(string) StreamStats
	// Indicates the status of the stream.
	Status() *StreamStatus
	// Indicates the status of the stream.
	SetStatus(StreamStatus) StreamStats
	// HTTP(s) URL that can be used for streaming API of this stream
	StreamingEndpoint() *string
	// HTTP(s) URL that can be used for streaming API of this stream
	SetStreamingEndpoint(string) StreamStats
	// The time period during which no frames were received from the stream's input.
	// Format: ticks (ticks)
	// Example: 1284
	TSDelay() *Ticks
	// The time period during which no frames were received from the stream's input.
	// Format: ticks (ticks)
	// Example: 1284
	SetTSDelay(Ticks) StreamStats
}

type StreamZoneConfig interface {
	// The name of the zone to which the stream belongs. Preferred zones means that the stream will be provisioned to these zones first.
	// If preferred zones is empty, stream will be provisioned to any available zone.
	// If preferred zones is not available, stream will be provisioned to any available zone.
	// After fallback stream will be provisioned to preferred zone.
	PreferredZones() []string
	// The name of the zone to which the stream belongs. Preferred zones means that the stream will be provisioned to these zones first.
	// If preferred zones is empty, stream will be provisioned to any available zone.
	// If preferred zones is not available, stream will be provisioned to any available zone.
	// After fallback stream will be provisioned to preferred zone.
	SetPreferredZones([]string) StreamZoneConfig
	// The name of the zone to which the stream belongs.
	// Required zones means that the stream can be provisioned only on these zones.
	// If required zones is empty, stream will be provisioned to any available zone.
	RequiredZones() []string
	// The name of the zone to which the stream belongs.
	// Required zones means that the stream can be provisioned only on these zones.
	// If required zones is empty, stream will be provisioned to any available zone.
	SetRequiredZones([]string) StreamZoneConfig
}

type Streamer interface {
	// The URL for provisioning of configuration from the managing server to the streamer.
	// This URL does not have to be public but must be accessible from the managing server.
	// The API URL can also be used as Public and/or Private payload URL if they are not set.
	// When used as Public payload URL, the API URL shall be public to allow playback from this streamer.
	// Format: url (url)
	// Example: http://streamer.local:8080
	APIURL() *URL
	// The URL for provisioning of configuration from the managing server to the streamer.
	// This URL does not have to be public but must be accessible from the managing server.
	// The API URL can also be used as Public and/or Private payload URL if they are not set.
	// When used as Public payload URL, the API URL shall be public to allow playback from this streamer.
	// Format: url (url)
	// Example: http://streamer.local:8080
	SetAPIURL(URL) Streamer
	// Maximal number of streams.
	// Example: 5
	ChannelLimit() *int
	// Maximal number of streams.
	// Example: 5
	SetChannelLimit(int) Streamer
	// The key for authorization for inter-Flussonic connections.
	// All cluster peers should have the same cluster key.
	// Example: xS6i6Q3DCc5nEvnu
	ClusterKey() *string
	// The key for authorization for inter-Flussonic connections.
	// All cluster peers should have the same cluster key.
	// Example: xS6i6Q3DCc5nEvnu
	SetClusterKey(string) Streamer
	// Flussonic Media Server configuration which will be provided to Streamer
	Config() StreamerConfigConfig
	// Flussonic Media Server configuration which will be provided to Streamer
	SetConfig(StreamerConfigConfig) Streamer
	// The configuration of the DVRs
	Dvrs() []DvrConfig
	// The configuration of the DVRs
	SetDvrs([]DvrConfig) Streamer
	// Streamer's identifier in the cluster.
	// The managing server may try using this hostname to access the streamer
	// if API URL is not specified.
	// Format: server_name (server_name)
	// Example: peer.example.com
	Hostname() *ServerName
	// Streamer's identifier in the cluster.
	// The managing server may try using this hostname to access the streamer
	// if API URL is not specified.
	// Format: server_name (server_name)
	// Example: peer.example.com
	SetHostname(ServerName) Streamer
	Labels() map[string]UnixName
	SetLabels(map[string]UnixName) Streamer
	// The internal address for communication in a local network (by default, it is equal to API URL).
	// Format: url (url)
	// Example: http://streamer.local
	PrivatePayloadURL() *URL
	// The internal address for communication in a local network (by default, it is equal to API URL).
	// Format: url (url)
	// Example: http://streamer.local
	SetPrivatePayloadURL(URL) Streamer
	// The public address that is exposed to clients. It can also contain a port number.
	// The client will be redirected to this URL and port when requesting for the stream captured on the peer
	// even if other `http` port is set in the peer's own config.
	// Format: url (url)
	// Example: http://public.example.com
	PublicPayloadURL() *URL
	// The public address that is exposed to clients. It can also contain a port number.
	// The client will be redirected to this URL and port when requesting for the stream captured on the peer
	// even if other `http` port is set in the peer's own config.
	// Format: url (url)
	// Example: http://public.example.com
	SetPublicPayloadURL(URL) Streamer
	// Role of node
	Role() *CentralNodeRoleRole
	// Role of node
	SetRole(CentralNodeRoleRole) Streamer
	// Statistics on peers in the cluster.
	Stats() PeerStats
	// Statistics on peers in the cluster.
	SetStats(PeerStats) Streamer
	// Server network bandwidth limit in kbit.
	// This value is used to calculate the current network load status.
	// Format: speed (speed)
	// Example: 1024
	TotalBandwidth() *Speed
	// Server network bandwidth limit in kbit.
	// This value is used to calculate the current network load status.
	// Format: speed (speed)
	// Example: 1024
	SetTotalBandwidth(Speed) Streamer
	// The names of the zones to which the streamer provides.
	// Example: [zone1 zone2]
	Zones() []string
	// The names of the zones to which the streamer provides.
	// Example: [zone1 zone2]
	SetZones([]string) Streamer
}

type StreamerConfig interface {
	// The URL for provisioning of configuration from the managing server to the streamer.
	// This URL does not have to be public but must be accessible from the managing server.
	// The API URL can also be used as Public and/or Private payload URL if they are not set.
	// When used as Public payload URL, the API URL shall be public to allow playback from this streamer.
	// Format: url (url)
	// Example: http://streamer.local:8080
	APIURL() *URL
	// The URL for provisioning of configuration from the managing server to the streamer.
	// This URL does not have to be public but must be accessible from the managing server.
	// The API URL can also be used as Public and/or Private payload URL if they are not set.
	// When used as Public payload URL, the API URL shall be public to allow playback from this streamer.
	// Format: url (url)
	// Example: http://streamer.local:8080
	SetAPIURL(URL) StreamerConfig
	// Maximal number of streams.
	// Example: 5
	ChannelLimit() *int
	// Maximal number of streams.
	// Example: 5
	SetChannelLimit(int) StreamerConfig
	// The key for authorization for inter-Flussonic connections.
	// All cluster peers should have the same cluster key.
	// Example: xS6i6Q3DCc5nEvnu
	ClusterKey() *string
	// The key for authorization for inter-Flussonic connections.
	// All cluster peers should have the same cluster key.
	// Example: xS6i6Q3DCc5nEvnu
	SetClusterKey(string) StreamerConfig
	// Flussonic Media Server configuration which will be provided to Streamer
	Config() StreamerConfigConfig
	// Flussonic Media Server configuration which will be provided to Streamer
	SetConfig(StreamerConfigConfig) StreamerConfig
	// The configuration of the DVRs
	Dvrs() []DvrConfig
	// The configuration of the DVRs
	SetDvrs([]DvrConfig) StreamerConfig
	// Streamer's identifier in the cluster.
	// The managing server may try using this hostname to access the streamer
	// if API URL is not specified.
	// Format: server_name (server_name)
	// Example: peer.example.com
	Hostname() *ServerName
	// Streamer's identifier in the cluster.
	// The managing server may try using this hostname to access the streamer
	// if API URL is not specified.
	// Format: server_name (server_name)
	// Example: peer.example.com
	SetHostname(ServerName) StreamerConfig
	Labels() map[string]UnixName
	SetLabels(map[string]UnixName) StreamerConfig
	// The internal address for communication in a local network (by default, it is equal to API URL).
	// Format: url (url)
	// Example: http://streamer.local
	PrivatePayloadURL() *URL
	// The internal address for communication in a local network (by default, it is equal to API URL).
	// Format: url (url)
	// Example: http://streamer.local
	SetPrivatePayloadURL(URL) StreamerConfig
	// The public address that is exposed to clients. It can also contain a port number.
	// The client will be redirected to this URL and port when requesting for the stream captured on the peer
	// even if other `http` port is set in the peer's own config.
	// Format: url (url)
	// Example: http://public.example.com
	PublicPayloadURL() *URL
	// The public address that is exposed to clients. It can also contain a port number.
	// The client will be redirected to this URL and port when requesting for the stream captured on the peer
	// even if other `http` port is set in the peer's own config.
	// Format: url (url)
	// Example: http://public.example.com
	SetPublicPayloadURL(URL) StreamerConfig
	// Role of node
	Role() *CentralNodeRoleRole
	// Role of node
	SetRole(CentralNodeRoleRole) StreamerConfig
	// Statistics on peers in the cluster.
	Stats() PeerStats
	// Statistics on peers in the cluster.
	SetStats(PeerStats) StreamerConfig
	// Server network bandwidth limit in kbit.
	// This value is used to calculate the current network load status.
	// Format: speed (speed)
	// Example: 1024
	TotalBandwidth() *Speed
	// Server network bandwidth limit in kbit.
	// This value is used to calculate the current network load status.
	// Format: speed (speed)
	// Example: 1024
	SetTotalBandwidth(Speed) StreamerConfig
}

// Flussonic Media Server configuration which will be provided to Streamer
type StreamerConfigConfig interface {
	// The list of allowed subnets to accept API requests from.
	APIAllowedFrom() []Cidr
	// The list of allowed subnets to accept API requests from.
	SetAPIAllowedFrom([]Cidr) StreamerConfigConfig
	// The configuration of auth backends
	AuthBackends() []AuthBackendConfig
	// The configuration of auth backends
	SetAuthBackends([]AuthBackendConfig) StreamerConfigConfig
	// Configure key name of query string key-value pair for token authentication
	AuthToken() *AuthToken
	// Configure key name of query string key-value pair for token authentication
	SetAuthToken(AuthToken) StreamerConfigConfig
	// The configuration of the balancers.
	Balancers() []BalancerConfig
	// The configuration of the balancers.
	SetBalancers([]BalancerConfig) StreamerConfigConfig
	// The configuration of the cache.
	Caches() []CacheConfig
	// The configuration of the cache.
	SetCaches([]CacheConfig) StreamerConfigConfig
	// The configuration of the camera alarms.
	CameraAlarm() CameraAlarmConfig
	// The configuration of the camera alarms.
	SetCameraAlarm(CameraAlarmConfig) StreamerConfigConfig
	// The configuration of the chassis.
	Chassis() ChassisConfig
	// The configuration of the chassis.
	SetChassis(ChassisConfig) StreamerConfigConfig
	// The cluster key to unite several servers with the same key into a cluster.
	// Example: xS6i6Q3DCc5nEvnu
	ClusterKey() *string
	// The cluster key to unite several servers with the same key into a cluster.
	// Example: xS6i6Q3DCc5nEvnu
	SetClusterKey(string) StreamerConfigConfig
	// Configuration of decklink SDI capture cards
	Decklinks() []DecklinkConfig
	// Configuration of decklink SDI capture cards
	SetDecklinks([]DecklinkConfig) StreamerConfigConfig
	// The configuration of the DVB cards.
	DvbCards() []DvbCardConfig
	// The configuration of the DVB cards.
	SetDvbCards([]DvbCardConfig) StreamerConfigConfig
	// The configuration of the DVRs
	Dvrs() []DvrConfig
	// The configuration of the DVRs
	SetDvrs([]DvrConfig) StreamerConfigConfig
	// Credentials for administrator access to the server.
	EditAuth() AdminCredentials
	// Credentials for administrator access to the server.
	SetEditAuth(AdminCredentials) StreamerConfigConfig
	// The configuration of event notifications
	EventSinks() []EventSinkConfig
	// The configuration of event notifications
	SetEventSinks([]EventSinkConfig) StreamerConfigConfig
	// The configuration of the file processor.
	FileProcessor() FileProcessorConfig
	// The configuration of the file processor.
	SetFileProcessor(FileProcessorConfig) StreamerConfigConfig
	// Use your own GeoIP database.
	// Format: disk_path (disk_path)
	// Example: /usr/share/GeoIP/GeoLite2-City.mmdb
	Geoip() *DiskPath
	// Use your own GeoIP database.
	// Format: disk_path (disk_path)
	// Example: /usr/share/GeoIP/GeoLite2-City.mmdb
	SetGeoip(DiskPath) StreamerConfigConfig
	// List of HTTP prefixes that can be handled via call to remote http server
	HTTPProxies() []HTTPProxyConfig
	// List of HTTP prefixes that can be handled via call to remote http server
	SetHTTPProxies([]HTTPProxyConfig) StreamerConfigConfig
	// The configuration of the IPTV
	Iptv() IptvConfig
	// The configuration of the IPTV
	SetIptv(IptvConfig) StreamerConfigConfig
	// The configuration of network listeners.
	Listeners() Listeners
	// The configuration of network listeners.
	SetListeners(Listeners) StreamerConfigConfig
	// Enables logging of requests for streams (manifests, segments) and API request.
	LogRequests() *bool
	// Enables logging of requests for streams (manifests, segments) and API request.
	SetLogRequests(bool) StreamerConfigConfig
	// Raise loglevel to debug if needed.
	// Example: error
	Loglevel() *Loglevel
	// Raise loglevel to debug if needed.
	// Example: error
	SetLoglevel(Loglevel) StreamerConfigConfig
	// Some additional options of the server.
	// Example: {"role": "transcoder"}
	Meta() *string
	// Some additional options of the server.
	// Example: {"role": "transcoder"}
	SetMeta(string) StreamerConfigConfig
	// Deprecated field. Will be deleted at 25.11
	// Enables saving statistics on Nvidia performance.
	// Example: true
	NvidiaMonitor() *bool
	// Deprecated field. Will be deleted at 25.11
	// Enables saving statistics on Nvidia performance.
	// Example: true
	SetNvidiaMonitor(bool) StreamerConfigConfig
	// The configuration of peers in the cluster.
	Peers() []PeerConfig
	// The configuration of peers in the cluster.
	SetPeers([]PeerConfig) StreamerConfigConfig
	// Directory to store Pulse statistics.
	// Format: disk_path (disk_path)
	// Example: /var/run/flussonic/pulsedb
	Pulsedb() *DiskPath
	// Directory to store Pulse statistics.
	// Format: disk_path (disk_path)
	// Example: /var/run/flussonic/pulsedb
	SetPulsedb(DiskPath) StreamerConfigConfig
	// The configuration of the port forwarding.
	Rproxy() RproxyConfig
	// The configuration of the port forwarding.
	SetRproxy(RproxyConfig) StreamerConfigConfig
	// The configuration of server domain name and aliases
	ServerNames() []ServerNameConfig
	// The configuration of server domain name and aliases
	SetServerNames([]ServerNameConfig) StreamerConfigConfig
	// Deprecated field. Will be deleted at 26.01
	// Directory to store the session log.
	// Format: disk_path (disk_path)
	// Example: /var/run/flussonic/session_log
	SessionLog() *DiskPath
	// Deprecated field. Will be deleted at 26.01
	// Directory to store the session log.
	// Format: disk_path (disk_path)
	// Example: /var/run/flussonic/session_log
	SetSessionLog(DiskPath) StreamerConfigConfig
	// The configuration of the video sources.
	Sources() []SourceConfig
	// The configuration of the video sources.
	SetSources([]SourceConfig) StreamerConfigConfig
	// Global SRT listening port. It is possible to use a single port for playback and publishing, but it is not compatible with clients.
	// Consider configuring separate ports for playback and publishing for each stream.
	Srt() *ListenSpec
	// Global SRT listening port. It is possible to use a single port for playback and publishing, but it is not compatible with clients.
	// Consider configuring separate ports for playback and publishing for each stream.
	SetSrt(*ListenSpec) StreamerConfigConfig
	// SRT2 play configuration with single-port mode. Not supported by many clients, better use per-stream mode.
	Srt2Play() SrtConfig
	// SRT2 play configuration with single-port mode. Not supported by many clients, better use per-stream mode.
	SetSrt2Play(SrtConfig) StreamerConfigConfig
	// SRT2 publish configuration with single-port mode. Not supported by many clients, better use per-stream mode.
	Srt2Publish() SrtConfig
	// SRT2 publish configuration with single-port mode. Not supported by many clients, better use per-stream mode.
	SetSrt2Publish(SrtConfig) StreamerConfigConfig
	// SRT play configuration with single-port mode. Not supported by many clients, better use per-stream mode.
	SrtPlay() SrtConfig
	// SRT play configuration with single-port mode. Not supported by many clients, better use per-stream mode.
	SetSrtPlay(SrtConfig) StreamerConfigConfig
	// SRT publish configuration with single-port mode. Not supported by many clients, better use per-stream mode.
	SrtPublish() SrtConfig
	// SRT publish configuration with single-port mode. Not supported by many clients, better use per-stream mode.
	SetSrtPublish(SrtConfig) StreamerConfigConfig
	// The configuration of the streams.
	Streams() []StreamConfig
	// The configuration of the streams.
	SetStreams([]StreamConfig) StreamerConfigConfig
	// The configuration of the templates.
	Templates() []TemplateConfig
	// The configuration of the templates.
	SetTemplates([]TemplateConfig) StreamerConfigConfig
	// Total server bandwidth.
	// Format: speed (speed)
	// Example: 1e+09
	TotalBandwidth() *Speed
	// Total server bandwidth.
	// Format: speed (speed)
	// Example: 1e+09
	SetTotalBandwidth(Speed) StreamerConfigConfig
	// The configuration of the transponders.
	Transponders() []TransponderConfig
	// The configuration of the transponders.
	SetTransponders([]TransponderConfig) StreamerConfigConfig
	// This option applies to HLS and DASH protocols, for all streams on the server.
	// The addresses of individual segments within a segment-based playlist will start with the specified prefix.
	// This setting is available in the global part of the config file as well as locally for any individual stream.
	// When specified at the stream level, it is only valid for this particular stream.
	URLPrefix() *URLPrefix
	// This option applies to HLS and DASH protocols, for all streams on the server.
	// The addresses of individual segments within a segment-based playlist will start with the specified prefix.
	// This setting is available in the global part of the config file as well as locally for any individual stream.
	// When specified at the stream level, it is only valid for this particular stream.
	SetURLPrefix(*URLPrefix) StreamerConfigConfig
	// Credentials for access to readonly API functions like getting streams info, status, and statistics.
	ViewAuth() AdminCredentials
	// Credentials for access to readonly API functions like getting streams info, status, and statistics.
	SetViewAuth(AdminCredentials) StreamerConfigConfig
	// The configuration of VODs
	Vods() []VodConfig
	// The configuration of VODs
	SetVods([]VodConfig) StreamerConfigConfig
	// The configuration of the video surveillance subsystem.
	Vsaas() VsaasConfig
	// The configuration of the video surveillance subsystem.
	SetVsaas(VsaasConfig) StreamerConfigConfig
	// Global WebRTC ports configuration for playback (via WHEP - WebRTC HTTP egress protocol).
	WebrtcPlay() WebrtcRouterConfig
	// Global WebRTC ports configuration for playback (via WHEP - WebRTC HTTP egress protocol).
	SetWebrtcPlay(WebrtcRouterConfig) StreamerConfigConfig
	// Global WebRTC ports configuration for publishing (via WHIP - WebRTC HTTP ingestion protocol).
	WebrtcPublish() WebrtcRouterConfig
	// Global WebRTC ports configuration for publishing (via WHIP - WebRTC HTTP ingestion protocol).
	SetWebrtcPublish(WebrtcRouterConfig) StreamerConfigConfig
}

type StreamerLayoutPrediction interface {
	// The URL for provisioning of configuration from the managing server to the streamer.
	// This URL does not have to be public but must be accessible from the managing server.
	// The API URL can also be used as Public and/or Private payload URL if they are not set.
	// When used as Public payload URL, the API URL shall be public to allow playback from this streamer.
	// Format: url (url)
	// Example: http://streamer.local:8080
	APIURL() *URL
	// The URL for provisioning of configuration from the managing server to the streamer.
	// This URL does not have to be public but must be accessible from the managing server.
	// The API URL can also be used as Public and/or Private payload URL if they are not set.
	// When used as Public payload URL, the API URL shall be public to allow playback from this streamer.
	// Format: url (url)
	// Example: http://streamer.local:8080
	SetAPIURL(URL) StreamerLayoutPrediction
	// Maximal number of streams.
	// Example: 5
	ChannelLimit() *int
	// Maximal number of streams.
	// Example: 5
	SetChannelLimit(int) StreamerLayoutPrediction
	// The key for authorization for inter-Flussonic connections.
	// All cluster peers should have the same cluster key.
	// Example: xS6i6Q3DCc5nEvnu
	ClusterKey() *string
	// The key for authorization for inter-Flussonic connections.
	// All cluster peers should have the same cluster key.
	// Example: xS6i6Q3DCc5nEvnu
	SetClusterKey(string) StreamerLayoutPrediction
	// Flussonic Media Server configuration which will be provided to Streamer
	Config() StreamerConfigConfig
	// Flussonic Media Server configuration which will be provided to Streamer
	SetConfig(StreamerConfigConfig) StreamerLayoutPrediction
	// The configuration of the DVRs
	Dvrs() []DvrConfig
	// The configuration of the DVRs
	SetDvrs([]DvrConfig) StreamerLayoutPrediction
	// Streamer's identifier in the cluster.
	// The managing server may try using this hostname to access the streamer
	// if API URL is not specified.
	// Format: server_name (server_name)
	// Example: peer.example.com
	Hostname() *ServerName
	// Streamer's identifier in the cluster.
	// The managing server may try using this hostname to access the streamer
	// if API URL is not specified.
	// Format: server_name (server_name)
	// Example: peer.example.com
	SetHostname(ServerName) StreamerLayoutPrediction
	Labels() map[string]UnixName
	SetLabels(map[string]UnixName) StreamerLayoutPrediction
	// The internal address for communication in a local network (by default, it is equal to API URL).
	// Format: url (url)
	// Example: http://streamer.local
	PrivatePayloadURL() *URL
	// The internal address for communication in a local network (by default, it is equal to API URL).
	// Format: url (url)
	// Example: http://streamer.local
	SetPrivatePayloadURL(URL) StreamerLayoutPrediction
	// The public address that is exposed to clients. It can also contain a port number.
	// The client will be redirected to this URL and port when requesting for the stream captured on the peer
	// even if other `http` port is set in the peer's own config.
	// Format: url (url)
	// Example: http://public.example.com
	PublicPayloadURL() *URL
	// The public address that is exposed to clients. It can also contain a port number.
	// The client will be redirected to this URL and port when requesting for the stream captured on the peer
	// even if other `http` port is set in the peer's own config.
	// Format: url (url)
	// Example: http://public.example.com
	SetPublicPayloadURL(URL) StreamerLayoutPrediction
	// Role of node
	Role() *CentralNodeRoleRole
	// Role of node
	SetRole(CentralNodeRoleRole) StreamerLayoutPrediction
	// Statistics on peers in the cluster.
	Stats() PeerStats
	// Statistics on peers in the cluster.
	SetStats(PeerStats) StreamerLayoutPrediction
	// Server network bandwidth limit in kbit.
	// This value is used to calculate the current network load status.
	// Format: speed (speed)
	// Example: 1024
	TotalBandwidth() *Speed
	// Server network bandwidth limit in kbit.
	// This value is used to calculate the current network load status.
	// Format: speed (speed)
	// Example: 1024
	SetTotalBandwidth(Speed) StreamerLayoutPrediction
	// The names of the zones to which the streamer provides.
	// Example: [zone1 zone2]
	Zones() []string
	// The names of the zones to which the streamer provides.
	// Example: [zone1 zone2]
	SetZones([]string) StreamerLayoutPrediction
}

type StreamersList interface {
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	EstimatedCount() *int
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	SetEstimatedCount(int) StreamersList
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	Next() *string
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	SetNext(string) StreamersList
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	Prev() *string
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	SetPrev(string) StreamersList
	// The list of streamers fetched according to the query parameters.
	Streamers() []Streamer
	// The list of streamers fetched according to the query parameters.
	SetStreamers([]Streamer) StreamersList
	// An object with a list of different timings measured during this API call.
	Timing() any
	// An object with a list of different timings measured during this API call.
	SetTiming(any) StreamersList
	// Collection returns the collection items
	Collection() []Streamer
}

type StreamsList interface {
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	EstimatedCount() *int
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	SetEstimatedCount(int) StreamsList
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	Next() *string
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	SetNext(string) StreamsList
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	Prev() *string
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	SetPrev(string) StreamsList
	// List of fetched streams according to the query parameters.
	Streams() []StreamConfig
	// List of fetched streams according to the query parameters.
	SetStreams([]StreamConfig) StreamsList
	// An object with a list of different timings measured during this API call.
	Timing() any
	// An object with a list of different timings measured during this API call.
	SetTiming(any) StreamsList
	// Collection returns the collection items
	Collection() []StreamConfig
}

// Array of streams with settings
type StreamsMultieditConfig interface {
	// List of streams with their settings
	Streams() []StreamConfigMultiedit
	// List of streams with their settings
	SetStreams([]StreamConfigMultiedit) StreamsMultieditConfig
}

// Array of streams with zone settings
type StreamsZoneSettings interface {
	// List of streams with their zone settings
	Streams() []any
	// List of streams with their zone settings
	SetStreams([]any) StreamsZoneSettings
}

// System settings
type SystemConfig interface {
	// The parameter is needed so that other elements of the cluster (the center and the media server)
	// can contact the watcher for authorization.
	// Format: url (url)
	// Example: auth@localhost:9015
	APIURL() *URL
	// The parameter is needed so that other elements of the cluster (the center and the media server)
	// can contact the watcher for authorization.
	// Format: url (url)
	// Example: auth@localhost:9015
	SetAPIURL(URL) SystemConfig
	// The url through which the watcher addresses the central
	// Format: url (url)
	// Example: http://auth@localhost:9019/streamer/api/v3
	CentralURL() *URL
	// The url through which the watcher addresses the central
	// Format: url (url)
	// Example: http://auth@localhost:9019/streamer/api/v3
	SetCentralURL(URL) SystemConfig
	// An additional authorization backend that allows you to authenticate the camera not only in the watcher
	// Format: url (url)
	// Example: http://localhost/camera/authorization
	CustomAuth() *URL
	// An additional authorization backend that allows you to authenticate the camera not only in the watcher
	// Format: url (url)
	// Example: http://localhost/camera/authorization
	SetCustomAuth(URL) SystemConfig
	// The configuration of database connection
	Database() Database
	// The configuration of database connection
	SetDatabase(Database) SystemConfig
	// Issued license key
	LicenseKey() *string
	// Issued license key
	SetLicenseKey(string) SystemConfig
	// The configuration of network listeners.
	Listeners() Listeners
	// The configuration of network listeners.
	SetListeners(Listeners) SystemConfig
	// Set logging level
	Loglevel() *Loglevel
	// Set logging level
	SetLoglevel(Loglevel) SystemConfig
	// A parameter that determines the time of blocking the user in seconds after several incorrect login attempts
	WatcherBruteForceTimeout() *int
	// A parameter that determines the time of blocking the user in seconds after several incorrect login attempts
	SetWatcherBruteForceTimeout(int) SystemConfig
}

// Required: tag, hex
type TSDescriptor interface {
	// Descriptor data.
	// Format: hexbinary (hexbinary)
	Hex() Hexbinary
	// Descriptor data.
	// Format: hexbinary (hexbinary)
	SetHex(Hexbinary) TSDescriptor
	// Identifier of the descriptor.
	Tag() int
	// Identifier of the descriptor.
	SetTag(int) TSDescriptor
}

type TSEitIntervals interface {
	// Period for the actual transponder.
	Actual() *int
	// Period for the actual transponder.
	SetActual(int) TSEitIntervals
	// Period for the other transponder.
	Other() *int
	// Period for the other transponder.
	SetOther(int) TSEitIntervals
}

type TSTimeouts interface {
	// The timeout value.
	MediaInfo() *int
	// The timeout value.
	SetMediaInfo(int) TSTimeouts
	// The type of the program.
	ServiceType() *int
	// The type of the program.
	SetServiceType(int) TSTimeouts
}

type TSVersions interface {
	// The version of CAT table.
	Cat() *int
	// The version of CAT table.
	SetCat(int) TSVersions
	// The version of NIT table.
	Nit() *int
	// The version of NIT table.
	SetNit(int) TSVersions
	// The version of PAT table.
	Pat() *int
	// The version of PAT table.
	SetPat(int) TSVersions
	// The version of PMT table.
	Pmt() *int
	// The version of PMT table.
	SetPmt(int) TSVersions
	// Global version for all PSI tables.
	Psi() *int
	// Global version for all PSI tables.
	SetPsi(int) TSVersions
	// The version of SDT table.
	Sdt() *int
	// The version of SDT table.
	SetSdt(int) TSVersions
}

type TemplateConfig interface {
	// Whether a stream is disabled. Disabled streams are inactive and do not run.
	// Displayed only with the API calls.
	// Example: false
	Disabled() *bool
	// Whether a stream is disabled. Disabled streams are inactive and do not run.
	// Displayed only with the API calls.
	// Example: false
	SetDisabled(bool) TemplateConfig
	// DVR configuraton.
	Dvr() StreamDvrSpec
	// DVR configuraton.
	SetDvr(StreamDvrSpec) TemplateConfig
	// List of stream inputs.
	// ***Important:*** A stream without any inputs can receive video frames **only** if backup file is specified.
	Inputs() []StreamInput
	// List of stream inputs.
	// ***Important:*** A stream without any inputs can receive video frames **only** if backup file is specified.
	SetInputs([]StreamInput) TemplateConfig
	// Stream labels in key value format.
	// Key is a string in unix_name format (alphanumeric characters, underscores, hyphens and periods).
	Labels() map[string]UnixName
	// Stream labels in key value format.
	// Key is a string in unix_name format (alphanumeric characters, underscores, hyphens and periods).
	SetLabels(map[string]UnixName) TemplateConfig
	// A list of pushes. When a server initiates the connection and sends a stream
	// to other server(s), it is called a `push`.
	Pushes() []StreamPush
	// A list of pushes. When a server initiates the connection and sends a stream
	// to other server(s), it is called a `push`.
	SetPushes([]StreamPush) TemplateConfig
	// Whether a stream is `static` or not.
	// If set to `True` the server will try to keep this stream running even if
	// there are no viewers or errors encountered.
	// Streamer restarts *all* `static` streams even if any internal errors occur
	// and the `static` streams crash.
	// Example: true
	Static() *bool
	// Whether a stream is `static` or not.
	// If set to `True` the server will try to keep this stream running even if
	// there are no viewers or errors encountered.
	// Streamer restarts *all* `static` streams even if any internal errors occur
	// and the `static` streams crash.
	// Example: true
	SetStatic(bool) TemplateConfig
	// Video analytics parameters.
	Vision() VisionSpec
	// Video analytics parameters.
	SetVision(VisionSpec) TemplateConfig
}

type TemplateConfigSpecific interface {
}

type ThumbnailsSpec interface {
	// Whether to generate thumbnails from the video stream.
	Enabled() any
	// Whether to generate thumbnails from the video stream.
	SetEnabled(any) ThumbnailsSpec
}

type TlsCertificate interface {
	// Deprecated field. Will be deleted at 25.09
	// Information about the CA certificate applied on the server.
	Cacert() CertificateInfo
	// Deprecated field. Will be deleted at 25.09
	// Information about the CA certificate applied on the server.
	SetCacert(CertificateInfo) TlsCertificate
	// Information about the server certificate.
	Cert() CertificateInfo
	// Information about the server certificate.
	SetCert(CertificateInfo) TlsCertificate
	// Information about the fullchain certificate including leaf and CA certificates.
	Fullchain() []CertificateInfo
	// Information about the fullchain certificate including leaf and CA certificates.
	SetFullchain([]CertificateInfo) TlsCertificate
	// Shows if the server private key matches the server certificate.
	PrivateKeyMatchCertificate() *bool
	// Shows if the server private key matches the server certificate.
	SetPrivateKeyMatchCertificate(bool) TlsCertificate
}

type TrackInfo interface {
	// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
	// The higher FPS is, the smoother the video playback is.
	// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
	AvgFPS() *float64
	// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
	// The higher FPS is, the smoother the video playback is.
	// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
	SetAvgFPS(float64) TrackInfo
	// Average GOP size (expressed in number of frames) of the last 1000-2000 frames.
	// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
	// If this value is floating, this means that your transcoder is working in flexible GOP size mode and some players may have problems.
	// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
	// Example: 25
	AvgGop() *int
	// Average GOP size (expressed in number of frames) of the last 1000-2000 frames.
	// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
	// If this value is floating, this means that your transcoder is working in flexible GOP size mode and some players may have problems.
	// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
	// Example: 25
	SetAvgGop(int) TrackInfo
	// Bandwidth necessary to transfer this track.
	// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
	// Format: speed (speed)
	// Example: 2600
	Bandwidth() *Speed
	// Bandwidth necessary to transfer this track.
	// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
	// Format: speed (speed)
	// Example: 2600
	SetBandwidth(Speed) TrackInfo
	// Average number of B-frames in a GOP. B-frames contain links to keyframes and P-frames before and after themselves.
	// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
	// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
	// Example: 3
	Bframes() *int
	// Average number of B-frames in a GOP. B-frames contain links to keyframes and P-frames before and after themselves.
	// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
	// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
	// Example: 3
	SetBframes(int) TrackInfo
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	Bitrate() *Speed
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	SetBitrate(Speed) TrackInfo
	// The number of audio channels.
	// Example: 2
	Channels() *int
	// The number of audio channels.
	// Example: 2
	SetChannels(int) TrackInfo
	// Parameters of closed captions.
	ClosedCaptions() []ClosedCaptions
	// Parameters of closed captions.
	SetClosedCaptions([]ClosedCaptions) TrackInfo
	// Codec of the track. Different codecs do **not** get the same track.
	// Example: h264
	Codec() *FrameCodec
	// Codec of the track. Different codecs do **not** get the same track.
	// Example: h264
	SetCodec(FrameCodec) TrackInfo
	// Content of the track (audio, video, or text).
	Content() FrameContent
	// Content of the track (audio, video, or text).
	SetContent(FrameContent) TrackInfo
	// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
	// Higher frame rates capture more images per second, which makes for smoother video.
	// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
	// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
	// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
	// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
	// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
	FPS() *float64
	// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
	// Higher frame rates capture more images per second, which makes for smoother video.
	// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
	// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
	// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
	// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
	// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
	SetFPS(float64) TrackInfo
	// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
	// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
	// However, sometimes (when the connection is broken) video breakups are possible.
	// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
	// This situation is considered as a frame gap and is handled differently across different protocols.
	// Format: ticks (ticks)
	FrameDuration() *Ticks
	// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
	// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
	// However, sometimes (when the connection is broken) video breakups are possible.
	// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
	// This situation is considered as a frame gap and is handled differently across different protocols.
	// Format: ticks (ticks)
	SetFrameDuration(Ticks) TrackInfo
	// The number of frames in a group of pictures (GOP).
	// The encoder will create all GOPs of an exactly identical size - as specified in this option.
	// A bigger GOP can be good for video compression but it can result in big zap-time (the duration of time between changing a channel and displaying a new channel.)
	GopSize() *int
	// The number of frames in a group of pictures (GOP).
	// The encoder will create all GOPs of an exactly identical size - as specified in this option.
	// A bigger GOP can be good for video compression but it can result in big zap-time (the duration of time between changing a channel and displaying a new channel.)
	SetGopSize(int) TrackInfo
	// The picture height in pixels on the display where it will be played by a player.
	// If you need to insert a web-player into a web page, use this value for choosing the player size.
	// Format: pixels (pixels)
	Height() *Pixels
	// The picture height in pixels on the display where it will be played by a player.
	// If you need to insert a web-player into a web page, use this value for choosing the player size.
	// Format: pixels (pixels)
	SetHeight(Pixels) TrackInfo
	// Indicates if progressive scanning method is used for all frames of the track
	IsProgressive() *bool
	// Indicates if progressive scanning method is used for all frames of the track
	SetIsProgressive(bool) TrackInfo
	// Language value of the track, if applicable.
	// Example: eng
	Language() *string
	// Language value of the track, if applicable.
	// Example: eng
	SetLanguage(string) TrackInfo
	// Last GOP size (expressed in number of frames).
	// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
	// If this value is floating, this means that your transcoder is working in a flexible GOP size mode and some players may have problems.
	// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
	// Example: 28
	LastGop() *int
	// Last GOP size (expressed in number of frames).
	// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
	// If this value is floating, this means that your transcoder is working in a flexible GOP size mode and some players may have problems.
	// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
	// Example: 28
	SetLastGop(int) TrackInfo
	// The size of the length field for H264 bitstream without start codes.
	LengthSize() *int
	// The size of the length field for H264 bitstream without start codes.
	SetLengthSize(int) TrackInfo
	// A set of constraints that indicate a degree of required decoder performance.
	// This parameter is used for compatibility with old devices.
	Level() *string
	// A set of constraints that indicate a degree of required decoder performance.
	// This parameter is used for compatibility with old devices.
	SetLevel(string) TrackInfo
	// The number of I-frames to be used for encoding.
	NumRefsFrames() *int
	// The number of I-frames to be used for encoding.
	SetNumRefsFrames(int) TrackInfo
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	Pid() *int
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	SetPid(int) TrackInfo
	// The color model of the video.
	PixFmt() *FrameVideoPixFmt
	// The color model of the video.
	SetPixFmt(FrameVideoPixFmt) TrackInfo
	// The picture width in pixels of the original video before transcoding.
	// Format: pixels (pixels)
	PixelHeight() *Pixels
	// The picture width in pixels of the original video before transcoding.
	// Format: pixels (pixels)
	SetPixelHeight(Pixels) TrackInfo
	// The picture width in pixels of the original video before transcoding.
	// Format: pixels (pixels)
	PixelWidth() *Pixels
	// The picture width in pixels of the original video before transcoding.
	// Format: pixels (pixels)
	SetPixelWidth(Pixels) TrackInfo
	// A specific codec-dependent profile of the output video.
	// The profile allows to assume if the track can be played on a particular device.
	Profile() *string
	// A specific codec-dependent profile of the output video.
	// The profile allows to assume if the track can be played on a particular device.
	SetProfile(string) TrackInfo
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// Example: 8000
	SampleRate() *int
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// Example: 8000
	SetSampleRate(int) TrackInfo
	// The second number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
	// SAR is used for creating non-anamorphic video from anamorphic video.
	SarHeight() *int
	// The second number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
	// SAR is used for creating non-anamorphic video from anamorphic video.
	SetSarHeight(int) TrackInfo
	// The first number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
	// SAR is used for creating non-anamorphic video from anamorphic video.
	SarWidth() *int
	// The first number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
	// SAR is used for creating non-anamorphic video from anamorphic video.
	SetSarWidth(int) TrackInfo
	// Human-readable localized title of the track.
	// Example: Video1
	Title() *string
	// Human-readable localized title of the track.
	// Example: Video1
	SetTitle(string) TrackInfo
	// Track identifier assigned by Flussonic.
	// Example: v1
	TrackID() any
	// Track identifier assigned by Flussonic.
	// Example: v1
	SetTrackID(any) TrackInfo
	// The picture width in pixels on the display where it will be played by a player.
	// If you need to insert a web-player into a web page, use this value for choosing the player size.
	// Format: pixels (pixels)
	Width() *Pixels
	// The picture width in pixels on the display where it will be played by a player.
	// If you need to insert a web-player into a web page, use this value for choosing the player size.
	// Format: pixels (pixels)
	SetWidth(Pixels) TrackInfo
}

type TrackInfoApplication interface {
	// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
	// The higher FPS is, the smoother the video playback is.
	// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
	AvgFPS() *float64
	// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
	// The higher FPS is, the smoother the video playback is.
	// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
	SetAvgFPS(float64) TrackInfoApplication
	// Bandwidth necessary to transfer this track.
	// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
	// Format: speed (speed)
	// Example: 2600
	Bandwidth() *Speed
	// Bandwidth necessary to transfer this track.
	// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
	// Format: speed (speed)
	// Example: 2600
	SetBandwidth(Speed) TrackInfoApplication
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	Bitrate() *Speed
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	SetBitrate(Speed) TrackInfoApplication
	// Codec of the track. Different codecs do **not** get the same track.
	// Example: h264
	Codec() *FrameCodec
	// Codec of the track. Different codecs do **not** get the same track.
	// Example: h264
	SetCodec(FrameCodec) TrackInfoApplication
	// Content of the track (audio, video, or text).
	Content() FrameContent
	// Content of the track (audio, video, or text).
	SetContent(FrameContent) TrackInfoApplication
	// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
	// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
	// However, sometimes (when the connection is broken) video breakups are possible.
	// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
	// This situation is considered as a frame gap and is handled differently across different protocols.
	// Format: ticks (ticks)
	FrameDuration() *Ticks
	// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
	// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
	// However, sometimes (when the connection is broken) video breakups are possible.
	// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
	// This situation is considered as a frame gap and is handled differently across different protocols.
	// Format: ticks (ticks)
	SetFrameDuration(Ticks) TrackInfoApplication
	// Language value of the track, if applicable.
	// Example: eng
	Language() *string
	// Language value of the track, if applicable.
	// Example: eng
	SetLanguage(string) TrackInfoApplication
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	Pid() *int
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	SetPid(int) TrackInfoApplication
	// Human-readable localized title of the track.
	// Example: Video1
	Title() *string
	// Human-readable localized title of the track.
	// Example: Video1
	SetTitle(string) TrackInfoApplication
	// Track identifier assigned by Flussonic.
	// Example: v1
	TrackID() any
	// Track identifier assigned by Flussonic.
	// Example: v1
	SetTrackID(any) TrackInfoApplication
}

type TrackInfoApplicationSpecific interface {
	// Language value of the track, if applicable.
	// Example: eng
	Language() *string
	// Language value of the track, if applicable.
	// Example: eng
	SetLanguage(string) TrackInfoApplicationSpecific
}

type TrackInfoAudio interface {
	// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
	// The higher FPS is, the smoother the video playback is.
	// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
	AvgFPS() *float64
	// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
	// The higher FPS is, the smoother the video playback is.
	// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
	SetAvgFPS(float64) TrackInfoAudio
	// Bandwidth necessary to transfer this track.
	// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
	// Format: speed (speed)
	// Example: 2600
	Bandwidth() *Speed
	// Bandwidth necessary to transfer this track.
	// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
	// Format: speed (speed)
	// Example: 2600
	SetBandwidth(Speed) TrackInfoAudio
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	Bitrate() *Speed
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	SetBitrate(Speed) TrackInfoAudio
	// The number of audio channels.
	// Example: 2
	Channels() *int
	// The number of audio channels.
	// Example: 2
	SetChannels(int) TrackInfoAudio
	// Codec of the track. Different codecs do **not** get the same track.
	// Example: h264
	Codec() *FrameCodec
	// Codec of the track. Different codecs do **not** get the same track.
	// Example: h264
	SetCodec(FrameCodec) TrackInfoAudio
	// Content of the track (audio, video, or text).
	Content() FrameContent
	// Content of the track (audio, video, or text).
	SetContent(FrameContent) TrackInfoAudio
	// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
	// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
	// However, sometimes (when the connection is broken) video breakups are possible.
	// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
	// This situation is considered as a frame gap and is handled differently across different protocols.
	// Format: ticks (ticks)
	FrameDuration() *Ticks
	// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
	// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
	// However, sometimes (when the connection is broken) video breakups are possible.
	// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
	// This situation is considered as a frame gap and is handled differently across different protocols.
	// Format: ticks (ticks)
	SetFrameDuration(Ticks) TrackInfoAudio
	// Language value of the track, if applicable.
	// Example: eng
	Language() *string
	// Language value of the track, if applicable.
	// Example: eng
	SetLanguage(string) TrackInfoAudio
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	Pid() *int
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	SetPid(int) TrackInfoAudio
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// Example: 8000
	SampleRate() *int
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// Example: 8000
	SetSampleRate(int) TrackInfoAudio
	// Human-readable localized title of the track.
	// Example: Video1
	Title() *string
	// Human-readable localized title of the track.
	// Example: Video1
	SetTitle(string) TrackInfoAudio
	// Track identifier assigned by Flussonic.
	// Example: v1
	TrackID() any
	// Track identifier assigned by Flussonic.
	// Example: v1
	SetTrackID(any) TrackInfoAudio
}

type TrackInfoAudioSpecific interface {
	// The number of audio channels.
	// Example: 2
	Channels() *int
	// The number of audio channels.
	// Example: 2
	SetChannels(int) TrackInfoAudioSpecific
	// Language value of the track, if applicable.
	// Example: eng
	Language() *string
	// Language value of the track, if applicable.
	// Example: eng
	SetLanguage(string) TrackInfoAudioSpecific
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// Example: 8000
	SampleRate() *int
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// Example: 8000
	SetSampleRate(int) TrackInfoAudioSpecific
}

type TrackInfoBase interface {
	// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
	// The higher FPS is, the smoother the video playback is.
	// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
	AvgFPS() *float64
	// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
	// The higher FPS is, the smoother the video playback is.
	// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
	SetAvgFPS(float64) TrackInfoBase
	// Bandwidth necessary to transfer this track.
	// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
	// Format: speed (speed)
	// Example: 2600
	Bandwidth() *Speed
	// Bandwidth necessary to transfer this track.
	// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
	// Format: speed (speed)
	// Example: 2600
	SetBandwidth(Speed) TrackInfoBase
	// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
	// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
	// However, sometimes (when the connection is broken) video breakups are possible.
	// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
	// This situation is considered as a frame gap and is handled differently across different protocols.
	// Format: ticks (ticks)
	FrameDuration() *Ticks
	// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
	// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
	// However, sometimes (when the connection is broken) video breakups are possible.
	// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
	// This situation is considered as a frame gap and is handled differently across different protocols.
	// Format: ticks (ticks)
	SetFrameDuration(Ticks) TrackInfoBase
	// Track identifier assigned by Flussonic.
	// Example: v1
	TrackID() any
	// Track identifier assigned by Flussonic.
	// Example: v1
	SetTrackID(any) TrackInfoBase
}

// Required: content
type TrackInfoBaseConfigurable interface {
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	Bitrate() *Speed
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	SetBitrate(Speed) TrackInfoBaseConfigurable
	// Content of the track (audio, video, or text).
	Content() FrameContent
	// Content of the track (audio, video, or text).
	SetContent(FrameContent) TrackInfoBaseConfigurable
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	Pid() *int
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	SetPid(int) TrackInfoBaseConfigurable
	// Human-readable localized title of the track.
	// Example: Video1
	Title() *string
	// Human-readable localized title of the track.
	// Example: Video1
	SetTitle(string) TrackInfoBaseConfigurable
}

type TrackInfoMetadata interface {
	// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
	// The higher FPS is, the smoother the video playback is.
	// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
	AvgFPS() *float64
	// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
	// The higher FPS is, the smoother the video playback is.
	// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
	SetAvgFPS(float64) TrackInfoMetadata
	// Bandwidth necessary to transfer this track.
	// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
	// Format: speed (speed)
	// Example: 2600
	Bandwidth() *Speed
	// Bandwidth necessary to transfer this track.
	// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
	// Format: speed (speed)
	// Example: 2600
	SetBandwidth(Speed) TrackInfoMetadata
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	Bitrate() *Speed
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	SetBitrate(Speed) TrackInfoMetadata
	// Codec of the track. Different codecs do **not** get the same track.
	// Example: h264
	Codec() *FrameCodec
	// Codec of the track. Different codecs do **not** get the same track.
	// Example: h264
	SetCodec(FrameCodec) TrackInfoMetadata
	// Content of the track (audio, video, or text).
	Content() FrameContent
	// Content of the track (audio, video, or text).
	SetContent(FrameContent) TrackInfoMetadata
	// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
	// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
	// However, sometimes (when the connection is broken) video breakups are possible.
	// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
	// This situation is considered as a frame gap and is handled differently across different protocols.
	// Format: ticks (ticks)
	FrameDuration() *Ticks
	// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
	// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
	// However, sometimes (when the connection is broken) video breakups are possible.
	// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
	// This situation is considered as a frame gap and is handled differently across different protocols.
	// Format: ticks (ticks)
	SetFrameDuration(Ticks) TrackInfoMetadata
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	Pid() *int
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	SetPid(int) TrackInfoMetadata
	// Human-readable localized title of the track.
	// Example: Video1
	Title() *string
	// Human-readable localized title of the track.
	// Example: Video1
	SetTitle(string) TrackInfoMetadata
	// Track identifier assigned by Flussonic.
	// Example: v1
	TrackID() any
	// Track identifier assigned by Flussonic.
	// Example: v1
	SetTrackID(any) TrackInfoMetadata
}

type TrackInfoText interface {
	// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
	// The higher FPS is, the smoother the video playback is.
	// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
	AvgFPS() *float64
	// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
	// The higher FPS is, the smoother the video playback is.
	// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
	SetAvgFPS(float64) TrackInfoText
	// Bandwidth necessary to transfer this track.
	// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
	// Format: speed (speed)
	// Example: 2600
	Bandwidth() *Speed
	// Bandwidth necessary to transfer this track.
	// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
	// Format: speed (speed)
	// Example: 2600
	SetBandwidth(Speed) TrackInfoText
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	Bitrate() *Speed
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	SetBitrate(Speed) TrackInfoText
	// Codec of the track. Different codecs do **not** get the same track.
	// Example: h264
	Codec() *FrameCodec
	// Codec of the track. Different codecs do **not** get the same track.
	// Example: h264
	SetCodec(FrameCodec) TrackInfoText
	// Content of the track (audio, video, or text).
	Content() FrameContent
	// Content of the track (audio, video, or text).
	SetContent(FrameContent) TrackInfoText
	// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
	// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
	// However, sometimes (when the connection is broken) video breakups are possible.
	// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
	// This situation is considered as a frame gap and is handled differently across different protocols.
	// Format: ticks (ticks)
	FrameDuration() *Ticks
	// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
	// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
	// However, sometimes (when the connection is broken) video breakups are possible.
	// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
	// This situation is considered as a frame gap and is handled differently across different protocols.
	// Format: ticks (ticks)
	SetFrameDuration(Ticks) TrackInfoText
	// Language value of the track, if applicable.
	// Example: eng
	Language() *string
	// Language value of the track, if applicable.
	// Example: eng
	SetLanguage(string) TrackInfoText
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	Pid() *int
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	SetPid(int) TrackInfoText
	// Human-readable localized title of the track.
	// Example: Video1
	Title() *string
	// Human-readable localized title of the track.
	// Example: Video1
	SetTitle(string) TrackInfoText
	// Track identifier assigned by Flussonic.
	// Example: v1
	TrackID() any
	// Track identifier assigned by Flussonic.
	// Example: v1
	SetTrackID(any) TrackInfoText
}

type TrackInfoTextSpecific interface {
	// Language value of the track, if applicable.
	// Example: eng
	Language() *string
	// Language value of the track, if applicable.
	// Example: eng
	SetLanguage(string) TrackInfoTextSpecific
}

type TrackInfoVideo interface {
	// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
	// The higher FPS is, the smoother the video playback is.
	// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
	AvgFPS() *float64
	// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
	// The higher FPS is, the smoother the video playback is.
	// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
	SetAvgFPS(float64) TrackInfoVideo
	// Average GOP size (expressed in number of frames) of the last 1000-2000 frames.
	// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
	// If this value is floating, this means that your transcoder is working in flexible GOP size mode and some players may have problems.
	// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
	// Example: 25
	AvgGop() *int
	// Average GOP size (expressed in number of frames) of the last 1000-2000 frames.
	// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
	// If this value is floating, this means that your transcoder is working in flexible GOP size mode and some players may have problems.
	// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
	// Example: 25
	SetAvgGop(int) TrackInfoVideo
	// Bandwidth necessary to transfer this track.
	// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
	// Format: speed (speed)
	// Example: 2600
	Bandwidth() *Speed
	// Bandwidth necessary to transfer this track.
	// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
	// Format: speed (speed)
	// Example: 2600
	SetBandwidth(Speed) TrackInfoVideo
	// Average number of B-frames in a GOP. B-frames contain links to keyframes and P-frames before and after themselves.
	// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
	// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
	// Example: 3
	Bframes() *int
	// Average number of B-frames in a GOP. B-frames contain links to keyframes and P-frames before and after themselves.
	// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
	// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
	// Example: 3
	SetBframes(int) TrackInfoVideo
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	Bitrate() *Speed
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	SetBitrate(Speed) TrackInfoVideo
	// Parameters of closed captions.
	ClosedCaptions() []ClosedCaptions
	// Parameters of closed captions.
	SetClosedCaptions([]ClosedCaptions) TrackInfoVideo
	// Codec of the track. Different codecs do **not** get the same track.
	// Example: h264
	Codec() *FrameCodec
	// Codec of the track. Different codecs do **not** get the same track.
	// Example: h264
	SetCodec(FrameCodec) TrackInfoVideo
	// Content of the track (audio, video, or text).
	Content() FrameContent
	// Content of the track (audio, video, or text).
	SetContent(FrameContent) TrackInfoVideo
	// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
	// Higher frame rates capture more images per second, which makes for smoother video.
	// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
	// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
	// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
	// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
	// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
	FPS() *float64
	// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
	// Higher frame rates capture more images per second, which makes for smoother video.
	// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
	// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
	// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
	// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
	// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
	SetFPS(float64) TrackInfoVideo
	// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
	// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
	// However, sometimes (when the connection is broken) video breakups are possible.
	// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
	// This situation is considered as a frame gap and is handled differently across different protocols.
	// Format: ticks (ticks)
	FrameDuration() *Ticks
	// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
	// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
	// However, sometimes (when the connection is broken) video breakups are possible.
	// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
	// This situation is considered as a frame gap and is handled differently across different protocols.
	// Format: ticks (ticks)
	SetFrameDuration(Ticks) TrackInfoVideo
	// The number of frames in a group of pictures (GOP).
	// The encoder will create all GOPs of an exactly identical size - as specified in this option.
	// A bigger GOP can be good for video compression but it can result in big zap-time (the duration of time between changing a channel and displaying a new channel.)
	GopSize() *int
	// The number of frames in a group of pictures (GOP).
	// The encoder will create all GOPs of an exactly identical size - as specified in this option.
	// A bigger GOP can be good for video compression but it can result in big zap-time (the duration of time between changing a channel and displaying a new channel.)
	SetGopSize(int) TrackInfoVideo
	// The picture height in pixels on the display where it will be played by a player.
	// If you need to insert a web-player into a web page, use this value for choosing the player size.
	// Format: pixels (pixels)
	Height() *Pixels
	// The picture height in pixels on the display where it will be played by a player.
	// If you need to insert a web-player into a web page, use this value for choosing the player size.
	// Format: pixels (pixels)
	SetHeight(Pixels) TrackInfoVideo
	// Indicates if progressive scanning method is used for all frames of the track
	IsProgressive() *bool
	// Indicates if progressive scanning method is used for all frames of the track
	SetIsProgressive(bool) TrackInfoVideo
	// Last GOP size (expressed in number of frames).
	// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
	// If this value is floating, this means that your transcoder is working in a flexible GOP size mode and some players may have problems.
	// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
	// Example: 28
	LastGop() *int
	// Last GOP size (expressed in number of frames).
	// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
	// If this value is floating, this means that your transcoder is working in a flexible GOP size mode and some players may have problems.
	// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
	// Example: 28
	SetLastGop(int) TrackInfoVideo
	// The size of the length field for H264 bitstream without start codes.
	LengthSize() *int
	// The size of the length field for H264 bitstream without start codes.
	SetLengthSize(int) TrackInfoVideo
	// A set of constraints that indicate a degree of required decoder performance.
	// This parameter is used for compatibility with old devices.
	Level() *string
	// A set of constraints that indicate a degree of required decoder performance.
	// This parameter is used for compatibility with old devices.
	SetLevel(string) TrackInfoVideo
	// The number of I-frames to be used for encoding.
	NumRefsFrames() *int
	// The number of I-frames to be used for encoding.
	SetNumRefsFrames(int) TrackInfoVideo
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	Pid() *int
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	SetPid(int) TrackInfoVideo
	// The color model of the video.
	PixFmt() *FrameVideoPixFmt
	// The color model of the video.
	SetPixFmt(FrameVideoPixFmt) TrackInfoVideo
	// The picture width in pixels of the original video before transcoding.
	// Format: pixels (pixels)
	PixelHeight() *Pixels
	// The picture width in pixels of the original video before transcoding.
	// Format: pixels (pixels)
	SetPixelHeight(Pixels) TrackInfoVideo
	// The picture width in pixels of the original video before transcoding.
	// Format: pixels (pixels)
	PixelWidth() *Pixels
	// The picture width in pixels of the original video before transcoding.
	// Format: pixels (pixels)
	SetPixelWidth(Pixels) TrackInfoVideo
	// A specific codec-dependent profile of the output video.
	// The profile allows to assume if the track can be played on a particular device.
	Profile() *string
	// A specific codec-dependent profile of the output video.
	// The profile allows to assume if the track can be played on a particular device.
	SetProfile(string) TrackInfoVideo
	// The second number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
	// SAR is used for creating non-anamorphic video from anamorphic video.
	SarHeight() *int
	// The second number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
	// SAR is used for creating non-anamorphic video from anamorphic video.
	SetSarHeight(int) TrackInfoVideo
	// The first number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
	// SAR is used for creating non-anamorphic video from anamorphic video.
	SarWidth() *int
	// The first number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
	// SAR is used for creating non-anamorphic video from anamorphic video.
	SetSarWidth(int) TrackInfoVideo
	// Human-readable localized title of the track.
	// Example: Video1
	Title() *string
	// Human-readable localized title of the track.
	// Example: Video1
	SetTitle(string) TrackInfoVideo
	// Track identifier assigned by Flussonic.
	// Example: v1
	TrackID() any
	// Track identifier assigned by Flussonic.
	// Example: v1
	SetTrackID(any) TrackInfoVideo
	// The picture width in pixels on the display where it will be played by a player.
	// If you need to insert a web-player into a web page, use this value for choosing the player size.
	// Format: pixels (pixels)
	Width() *Pixels
	// The picture width in pixels on the display where it will be played by a player.
	// If you need to insert a web-player into a web page, use this value for choosing the player size.
	// Format: pixels (pixels)
	SetWidth(Pixels) TrackInfoVideo
}

type TrackInfoVideoConfigurable interface {
	// Average number of B-frames in a GOP. B-frames contain links to keyframes and P-frames before and after themselves.
	// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
	// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
	// Example: 3
	Bframes() *int
	// Average number of B-frames in a GOP. B-frames contain links to keyframes and P-frames before and after themselves.
	// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
	// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
	// Example: 3
	SetBframes(int) TrackInfoVideoConfigurable
	// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
	// Higher frame rates capture more images per second, which makes for smoother video.
	// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
	// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
	// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
	// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
	// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
	FPS() *float64
	// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
	// Higher frame rates capture more images per second, which makes for smoother video.
	// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
	// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
	// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
	// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
	// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
	SetFPS(float64) TrackInfoVideoConfigurable
	// The number of frames in a group of pictures (GOP).
	// The encoder will create all GOPs of an exactly identical size - as specified in this option.
	// A bigger GOP can be good for video compression but it can result in big zap-time (the duration of time between changing a channel and displaying a new channel.)
	GopSize() *int
	// The number of frames in a group of pictures (GOP).
	// The encoder will create all GOPs of an exactly identical size - as specified in this option.
	// A bigger GOP can be good for video compression but it can result in big zap-time (the duration of time between changing a channel and displaying a new channel.)
	SetGopSize(int) TrackInfoVideoConfigurable
	// The picture height in pixels on the display where it will be played by a player.
	// If you need to insert a web-player into a web page, use this value for choosing the player size.
	// Format: pixels (pixels)
	Height() *Pixels
	// The picture height in pixels on the display where it will be played by a player.
	// If you need to insert a web-player into a web page, use this value for choosing the player size.
	// Format: pixels (pixels)
	SetHeight(Pixels) TrackInfoVideoConfigurable
	// A set of constraints that indicate a degree of required decoder performance.
	// This parameter is used for compatibility with old devices.
	Level() *string
	// A set of constraints that indicate a degree of required decoder performance.
	// This parameter is used for compatibility with old devices.
	SetLevel(string) TrackInfoVideoConfigurable
	// The number of I-frames to be used for encoding.
	NumRefsFrames() *int
	// The number of I-frames to be used for encoding.
	SetNumRefsFrames(int) TrackInfoVideoConfigurable
	// The color model of the video.
	PixFmt() *FrameVideoPixFmt
	// The color model of the video.
	SetPixFmt(FrameVideoPixFmt) TrackInfoVideoConfigurable
	// The picture width in pixels of the original video before transcoding.
	// Format: pixels (pixels)
	PixelHeight() *Pixels
	// The picture width in pixels of the original video before transcoding.
	// Format: pixels (pixels)
	SetPixelHeight(Pixels) TrackInfoVideoConfigurable
	// The picture width in pixels of the original video before transcoding.
	// Format: pixels (pixels)
	PixelWidth() *Pixels
	// The picture width in pixels of the original video before transcoding.
	// Format: pixels (pixels)
	SetPixelWidth(Pixels) TrackInfoVideoConfigurable
	// A specific codec-dependent profile of the output video.
	// The profile allows to assume if the track can be played on a particular device.
	Profile() *string
	// A specific codec-dependent profile of the output video.
	// The profile allows to assume if the track can be played on a particular device.
	SetProfile(string) TrackInfoVideoConfigurable
	// The second number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
	// SAR is used for creating non-anamorphic video from anamorphic video.
	SarHeight() *int
	// The second number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
	// SAR is used for creating non-anamorphic video from anamorphic video.
	SetSarHeight(int) TrackInfoVideoConfigurable
	// The first number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
	// SAR is used for creating non-anamorphic video from anamorphic video.
	SarWidth() *int
	// The first number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
	// SAR is used for creating non-anamorphic video from anamorphic video.
	SetSarWidth(int) TrackInfoVideoConfigurable
	// The picture width in pixels on the display where it will be played by a player.
	// If you need to insert a web-player into a web page, use this value for choosing the player size.
	// Format: pixels (pixels)
	Width() *Pixels
	// The picture width in pixels on the display where it will be played by a player.
	// If you need to insert a web-player into a web page, use this value for choosing the player size.
	// Format: pixels (pixels)
	SetWidth(Pixels) TrackInfoVideoConfigurable
}

type TrackInfoVideoSpecific interface {
	// Average GOP size (expressed in number of frames) of the last 1000-2000 frames.
	// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
	// If this value is floating, this means that your transcoder is working in flexible GOP size mode and some players may have problems.
	// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
	// Example: 25
	AvgGop() *int
	// Average GOP size (expressed in number of frames) of the last 1000-2000 frames.
	// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
	// If this value is floating, this means that your transcoder is working in flexible GOP size mode and some players may have problems.
	// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
	// Example: 25
	SetAvgGop(int) TrackInfoVideoSpecific
	// Parameters of closed captions.
	ClosedCaptions() []ClosedCaptions
	// Parameters of closed captions.
	SetClosedCaptions([]ClosedCaptions) TrackInfoVideoSpecific
	// Indicates if progressive scanning method is used for all frames of the track
	IsProgressive() *bool
	// Indicates if progressive scanning method is used for all frames of the track
	SetIsProgressive(bool) TrackInfoVideoSpecific
	// Last GOP size (expressed in number of frames).
	// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
	// If this value is floating, this means that your transcoder is working in a flexible GOP size mode and some players may have problems.
	// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
	// Example: 28
	LastGop() *int
	// Last GOP size (expressed in number of frames).
	// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
	// If this value is floating, this means that your transcoder is working in a flexible GOP size mode and some players may have problems.
	// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
	// Example: 28
	SetLastGop(int) TrackInfoVideoSpecific
	// The size of the length field for H264 bitstream without start codes.
	LengthSize() *int
	// The size of the length field for H264 bitstream without start codes.
	SetLengthSize(int) TrackInfoVideoSpecific
}

type TranscoderDeviceStats interface {
	// Shows if the device can make an interlaced stream from a progressive one.
	CanInterlace() *bool
	// Shows if the device can make an interlaced stream from a progressive one.
	SetCanInterlace(bool) TranscoderDeviceStats
	// Shows if the transcoder with this device can run in the same process as Flussonic Media Server.
	CanInternal() *bool
	// Shows if the transcoder with this device can run in the same process as Flussonic Media Server.
	SetCanInternal(bool) TranscoderDeviceStats
	// Shows if the device can put a logo on the image.
	CanLogo() *bool
	// Shows if the device can put a logo on the image.
	SetCanLogo(bool) TranscoderDeviceStats
	// GPU decoder load percentage.
	GpuDec() *int
	// GPU decoder load percentage.
	SetGpuDec(int) TranscoderDeviceStats
	// GPU encoder load percentage.
	GpuEnc() *int
	// GPU encoder load percentage.
	SetGpuEnc(int) TranscoderDeviceStats
	// GPU shared memory amount.
	GpuSm() *int
	// GPU shared memory amount.
	SetGpuSm(int) TranscoderDeviceStats
	// GPU temperature, C.
	GpuTemp() *int
	// GPU temperature, C.
	SetGpuTemp(int) TranscoderDeviceStats
	// The ID of the device used for transcoding.
	// In PUT requests, you can use `auto` for Flussonic to set the ID itself.
	// In the response to GET requests, the `id` will always be a number.
	ID() *TcDeviceid
	// The ID of the device used for transcoding.
	// In PUT requests, you can use `auto` for Flussonic to set the ID itself.
	// In the response to GET requests, the `id` will always be a number.
	SetID(*TcDeviceid) TranscoderDeviceStats
	// Free RAM.
	Memfree() *int
	// Free RAM.
	SetMemfree(int) TranscoderDeviceStats
	// Total RAM on the device.
	Memtotal() *int
	// Total RAM on the device.
	SetMemtotal(int) TranscoderDeviceStats
	// Utilized RAM.
	Memused() *int
	// Utilized RAM.
	SetMemused(int) TranscoderDeviceStats
	// The name of the transcoder device.
	Name() *string
	// The name of the transcoder device.
	SetName(string) TranscoderDeviceStats
	// The ability of the device to be reconfigured online, i.e. without complete restart of the transcoder.
	// `full` means that both decoder and encoder can be reconfigured online.
	// `encoder` means that only encoder can be reconfigured online.
	// `decoder` means that only decoder can be reconfigured online.
	// `false` means that online reconfiguration is not supported.
	ReconfigSupport() *TcReconfigSupport
	// The ability of the device to be reconfigured online, i.e. without complete restart of the transcoder.
	// `full` means that both decoder and encoder can be reconfigured online.
	// `encoder` means that only encoder can be reconfigured online.
	// `decoder` means that only decoder can be reconfigured online.
	// `false` means that online reconfiguration is not supported.
	SetReconfigSupport(*TcReconfigSupport) TranscoderDeviceStats
	// The type of the device used for transcoding.
	// Example: cpu
	Type() *TranscoderDevice
	// The type of the device used for transcoding.
	// Example: cpu
	SetType(TranscoderDevice) TranscoderDeviceStats
}

// Required: name
type TransponderConfig interface {
	// Transponder bitrate.
	// Format: speed (speed)
	Bitrate() *Speed
	// Transponder bitrate.
	// Format: speed (speed)
	SetBitrate(Speed) TransponderConfig
	// Transponder's program guide in EIT format.
	Eit() TransponderEit
	// Transponder's program guide in EIT format.
	SetEit(TransponderEit) TransponderConfig
	// The name of the transponder.
	// Format: media_name (media_name)
	// Example: multiplexer
	Name() MediaName
	// The name of the transponder.
	// Format: media_name (media_name)
	// Example: multiplexer
	SetName(MediaName) TransponderConfig
	// Identifier of the delivery network.
	NetworkID() *int
	// Identifier of the delivery network.
	SetNetworkID(int) TransponderConfig
	// The name of the TV network.
	// Example: Example Network
	NetworkName() *string
	// The name of the TV network.
	// Example: Example Network
	SetNetworkName(string) TransponderConfig
	// Identifier of the original delivery network. The same original network is used for NIT and SDT.
	OriginalNetworkID() *int
	// Identifier of the original delivery network. The same original network is used for NIT and SDT.
	SetOriginalNetworkID(int) TransponderConfig
	// The list of other transponders on the network.
	Others() []TransponderOther
	// The list of other transponders on the network.
	SetOthers([]TransponderOther) TransponderConfig
	// The length of multiplexer input buffer.
	// The higher value makes the multiplexer more robust to non-uniform inputs.
	// The lower value reduces input-to-output latency, but requires more stable bitrate (CBR) on input.
	// Format: milliseconds (milliseconds)
	// Example: 800
	Prebuffer() *Milliseconds
	// The length of multiplexer input buffer.
	// The higher value makes the multiplexer more robust to non-uniform inputs.
	// The lower value reduces input-to-output latency, but requires more stable bitrate (CBR) on input.
	// Format: milliseconds (milliseconds)
	// Example: 800
	SetPrebuffer(Milliseconds) TransponderConfig
	// The list of programs in the transponder.
	Programs() []TransponderProgram
	// The list of programs in the transponder.
	SetPrograms([]TransponderProgram) TransponderConfig
	// Provider of the transponder.
	// Example: Example Provider
	Provider() *string
	// Provider of the transponder.
	// Example: Example Provider
	SetProvider(string) TransponderConfig
	// The list of pushes for the transponder.
	Pushes() []TransponderPush
	// The list of pushes for the transponder.
	SetPushes([]TransponderPush) TransponderConfig
	// Detailed runtime information about the multiplexer.
	Stats() MultiplexerStats
	// Detailed runtime information about the multiplexer.
	SetStats(MultiplexerStats) TransponderConfig
	// The list of time offsets.
	TimeOffsets() []TransponderTimeOffset
	// The list of time offsets.
	SetTimeOffsets([]TransponderTimeOffset) TransponderConfig
	// The list of timeouts for autodetect of provider, title, and service_type of the programs.
	Timeouts() TSTimeouts
	// The list of timeouts for autodetect of provider, title, and service_type of the programs.
	SetTimeouts(TSTimeouts) TransponderConfig
	// The list of transport stream descriptors. Descriptors are added to NIT and SDT.
	TSDescriptors() []TSDescriptor
	// The list of transport stream descriptors. Descriptors are added to NIT and SDT.
	SetTSDescriptors([]TSDescriptor) TransponderConfig
	// The identifier of the transport stream for the transponder.
	TSStreamID() *int
	// The identifier of the transport stream for the transponder.
	SetTSStreamID(int) TransponderConfig
	// Versions of PSI tables.
	Versions() TSVersions
	// Versions of PSI tables.
	SetVersions(TSVersions) TransponderConfig
	// The size of the video buffer for the transponder.
	VideoBuffer() *int
	// The size of the video buffer for the transponder.
	SetVideoBuffer(int) TransponderConfig
}

type TransponderEit interface {
	// Periods for sending the present/following events.
	IntervalsPf() TSEitIntervals
	// Periods for sending the present/following events.
	SetIntervalsPf(TSEitIntervals) TransponderEit
	// Periods for sending the event schedules.
	IntervalsSchedule() TSEitIntervals
	// Periods for sending the event schedules.
	SetIntervalsSchedule(TSEitIntervals) TransponderEit
	// Period for storing the XMLTV files.
	// Format: seconds (seconds)
	KeepEpg() *Seconds
	// Period for storing the XMLTV files.
	// Format: seconds (seconds)
	SetKeepEpg(Seconds) TransponderEit
	// Maximum bitrate for the transponder's EIT EPG.
	// Format: max_bitrate (max_bitrate)
	MaxBitrate() *MaxBitrate
	// Maximum bitrate for the transponder's EIT EPG.
	// Format: max_bitrate (max_bitrate)
	SetMaxBitrate(MaxBitrate) TransponderEit
	// Directory for storing the XMLTV EPG files.
	// Example: xmltv_dir
	XmltvURL() *string
	// Directory for storing the XMLTV EPG files.
	// Example: xmltv_dir
	SetXmltvURL(string) TransponderEit
}

// Required: name
type TransponderOther interface {
	// The name of the other transponder on the network.
	// Format: media_name (media_name)
	Name() MediaName
	// The name of the other transponder on the network.
	// Format: media_name (media_name)
	SetName(MediaName) TransponderOther
}

// Required: pid, content, track
type TransponderPid interface {
	// Bitrate of the track.
	// Format: speed (speed)
	// Example: 2543
	Bitrate() *Speed
	// Bitrate of the track.
	// Format: speed (speed)
	// Example: 2543
	SetBitrate(Speed) TransponderPid
	// Codec for this pid. Use this if just content+track is not enough.
	// Example: scte35
	Codec() *FrameCodec
	// Codec for this pid. Use this if just content+track is not enough.
	// Example: scte35
	SetCodec(FrameCodec) TransponderPid
	// Content of the track.
	// Example: audio
	Content() string
	// Content of the track.
	// Example: audio
	SetContent(string) TransponderPid
	// Raw elementary stream descriptors to describe proprietary stream in PMT program info
	// Plese refer to ISO/IEC 13818-1 section 2.6 for syntax
	// This is an optional parameter for advanced users. By default, the media Server
	// is automatically sets the stream_type according to the track codec.
	// Format: hexbinary (hexbinary)
	// Example: 52010D
	EsInfo() *Hexbinary
	// Raw elementary stream descriptors to describe proprietary stream in PMT program info
	// Plese refer to ISO/IEC 13818-1 section 2.6 for syntax
	// This is an optional parameter for advanced users. By default, the media Server
	// is automatically sets the stream_type according to the track codec.
	// Format: hexbinary (hexbinary)
	// Example: 52010D
	SetEsInfo(Hexbinary) TransponderPid
	// A PID to assign to a matched track or system table.
	// PID identifies the payload (media or service) in the resulting MPTS stream.
	// Multiplexer will include only the tracks with specified PIDs.
	// It is possible to set PID values for video, audio and other media tracks, as well as for PMT and SDT.
	Pid() int
	// A PID to assign to a matched track or system table.
	// PID identifies the payload (media or service) in the resulting MPTS stream.
	// Multiplexer will include only the tracks with specified PIDs.
	// It is possible to set PID values for video, audio and other media tracks, as well as for PMT and SDT.
	SetPid(int) TransponderPid
	// Detailed runtime information about the multiplexer pid.
	Stats() PushPidCounters
	// Detailed runtime information about the multiplexer pid.
	SetStats(PushPidCounters) TransponderPid
	// Custom program element type in PMT
	// Combined with bypass (content=metadata, track=0) this option makes
	// proprietary PSI streams appear in PMT program info with given stream_type field
	// This is an optional parameter for advanced users. By default, the media Server
	// is automatically sets the stream_type according to the track codec.
	// Example: 12
	StreamType() *int
	// Custom program element type in PMT
	// Combined with bypass (content=metadata, track=0) this option makes
	// proprietary PSI streams appear in PMT program info with given stream_type field
	// This is an optional parameter for advanced users. By default, the media Server
	// is automatically sets the stream_type according to the track codec.
	// Example: 12
	SetStreamType(int) TransponderPid
	// Index of a track with specified content and maybe codec.
	// E.g. when you specify content=audio and track=2 the second audio track will be selected.
	// If you specify content=audio, codec=aac and track=1, the first AAC track will be selected
	// even if it is a third audio track and fifth track in stream media_info
	// Example: 1
	Track() int
	// Index of a track with specified content and maybe codec.
	// E.g. when you specify content=audio and track=2 the second audio track will be selected.
	// If you specify content=audio, codec=aac and track=1, the first AAC track will be selected
	// even if it is a third audio track and fifth track in stream media_info
	// Example: 1
	SetTrack(int) TransponderPid
}

// Required: program_id
type TransponderProgram interface {
	// The name of the EIT.
	// Example: EIT_Title
	EitTitle() *string
	// The name of the EIT.
	// Example: EIT_Title
	SetEitTitle(string) TransponderProgram
	// Logical channel number.
	// Example: 5
	Lcn() *int
	// Logical channel number.
	// Example: 5
	SetLcn(int) TransponderProgram
	// The list of PIDs.
	Pids() OutputMpegtsPids
	// The list of PIDs.
	SetPids(OutputMpegtsPids) TransponderProgram
	// Identifier of the program within the transponder.
	ProgramID() int
	// Identifier of the program within the transponder.
	SetProgramID(int) TransponderProgram
	// Information about the program type.
	// Example: digital_tv
	ServiceType() *TSServiceType
	// Information about the program type.
	// Example: digital_tv
	SetServiceType(*TSServiceType) TransponderProgram
	// The stream that is in use as the program source.
	// Format: media_name (media_name)
	// Example: hockey1
	Source() *MediaName
	// The stream that is in use as the program source.
	// Format: media_name (media_name)
	// Example: hockey1
	SetSource(MediaName) TransponderProgram
	// The program title.
	// Example: ProgramTitle
	Title() *string
	// The program title.
	// Example: ProgramTitle
	SetTitle(string) TransponderProgram
}

// Required: pnr
type TransponderProgramStats interface {
	// Number of times the program was reset.
	// This may occur when a frame fails to enqueue due to bad timing.
	ErrorsProgramReset() *int
	// Number of times the program was reset.
	// This may occur when a frame fails to enqueue due to bad timing.
	SetErrorsProgramReset(int) TransponderProgramStats
	// Number of SCTE-35 splices that missed their intended splice point.
	ErrorsScte35Announces() *int
	// Number of SCTE-35 splices that missed their intended splice point.
	SetErrorsScte35Announces(int) TransponderProgramStats
	// Number of times the program was reset due to a change in the `output_dts_shift` option.
	// This may happen when the input source is switched.
	OutputDtsShiftChanged() *int
	// Number of times the program was reset due to a change in the `output_dts_shift` option.
	// This may happen when the input source is switched.
	SetOutputDtsShiftChanged(int) TransponderProgramStats
	// Program ID of the program.
	Pnr() int
	// Program ID of the program.
	SetPnr(int) TransponderProgramStats
	// Number of SCTE-35 splices targeting an IDR frame.
	Scte35Announces() *int
	// Number of SCTE-35 splices targeting an IDR frame.
	SetScte35Announces(int) TransponderProgramStats
}

// Required: url
type TransponderPush interface {
	// The multicast socket option that enables ingesting the sent data back to the transponder.
	// Use for test purposes, e.g. if the same server creates MTPS and splits MPTS to separate programs.
	MulticastLoop() *bool
	// The multicast socket option that enables ingesting the sent data back to the transponder.
	// Use for test purposes, e.g. if the same server creates MTPS and splits MPTS to separate programs.
	SetMulticastLoop(bool) TransponderPush
	// Monitoring multicast group and stop pushing if another publisher presented
	Standby() *bool
	// Monitoring multicast group and stop pushing if another publisher presented
	SetStandby(bool) TransponderPush
	// Detailed runtime information about the push.
	Stats() PushCounters
	// Detailed runtime information about the push.
	SetStats(PushCounters) TransponderPush
	// ToS byte in the IP packages of the multicasted data.
	Tos() *int
	// ToS byte in the IP packages of the multicasted data.
	SetTos(int) TransponderPush
	// Push URL for the MPTS stream. Usually it is a `udp://` multicast address and port.
	URL() string
	// Push URL for the MPTS stream. Usually it is a `udp://` multicast address and port.
	SetURL(string) TransponderPush
}

// Required: country
type TransponderTimeOffset interface {
	// The country code.
	Country() string
	// The country code.
	SetCountry(string) TransponderTimeOffset
	// The current offset time from UTC.
	LocalTimeOffset() *string
	// The current offset time from UTC.
	SetLocalTimeOffset(string) TransponderTimeOffset
	// The next offset time after the change.
	NextTimeOffset() *string
	// The next offset time after the change.
	SetNextTimeOffset(string) TransponderTimeOffset
	// The region code.
	Region() *int
	// The region code.
	SetRegion(int) TransponderTimeOffset
	// Date and time when the time change takes place.
	TimeOfChange() *int
	// Date and time when the time change takes place.
	SetTimeOfChange(int) TransponderTimeOffset
}

type User interface {
	// The parameter regulates the rights for the user
	// Example: generic
	AccessLevel() *UserAdminAccessLevel
	// The parameter regulates the rights for the user
	// Example: generic
	SetAccessLevel(UserAdminAccessLevel) User
	// The date and time when the user was created.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.672531199e+12
	CreatedAt() *UtcMs
	// The date and time when the user was created.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.672531199e+12
	SetCreatedAt(UtcMs) User
	// A parameter that allows you to enable/disable the user
	// Example: false
	Disabled() *bool
	// A parameter that allows you to enable/disable the user
	// Example: false
	SetDisabled(bool) User
	// User's email. Required for password recovery.
	// Format: email (email)
	// Example: user@example.com
	Email() *Email
	// User's email. Required for password recovery.
	// Format: email (email)
	// Example: user@example.com
	SetEmail(Email) User
	// The user's full name.
	Fullname() *string
	// The user's full name.
	SetFullname(string) User
	// Identifier of the user.
	// Example: 1
	ID() *int
	// Identifier of the user.
	// Example: 1
	SetID(int) User
	// The language, selected by user.
	// Format: ISO 639-1
	// Example: en
	Locale() *ISO6391
	// The language, selected by user.
	// Format: ISO 639-1
	// Example: en
	SetLocale(ISO6391) User
	// The maximum number of sessions the user can have simultaneously.
	MaxSessions() *int
	// The maximum number of sessions the user can have simultaneously.
	SetMaxSessions(int) User
	// User name (login)
	Name() *string
	// User name (login)
	SetName(string) User
	// Additional information or notes about the user.
	Note() *string
	// Additional information or notes about the user.
	SetNote(string) User
	// A parameter indicating that the user belongs to certain organizations
	Organizations() []UserAdminOrganizationsItem
	// A parameter indicating that the user belongs to certain organizations
	SetOrganizations([]UserAdminOrganizationsItem) User
	// The specified password will be saved as a hash, used only for writing
	Password() *string
	// The specified password will be saved as a hash, used only for writing
	SetPassword(string) User
	// User's phone number
	// Format: phone-number (phone-number)
	// Example: +78007778413
	Phone() *PhoneNumber
	// User's phone number
	// Format: phone-number (phone-number)
	// Example: +78007778413
	SetPhone(PhoneNumber) User
	// A flag indicating that the user has read-only access and cannot modify their own data.
	// Example: false
	Readonly() *bool
	// A flag indicating that the user has read-only access and cannot modify their own data.
	// Example: false
	SetReadonly(bool) User
}

// User Parameters available from Admin API.
type UserAdmin interface {
	// The parameter regulates the rights for the user
	// Example: generic
	AccessLevel() *UserAdminAccessLevel
	// The parameter regulates the rights for the user
	// Example: generic
	SetAccessLevel(UserAdminAccessLevel) UserAdmin
	// A parameter that allows you to enable/disable the user
	// Example: false
	Disabled() *bool
	// A parameter that allows you to enable/disable the user
	// Example: false
	SetDisabled(bool) UserAdmin
	// Identifier of the user.
	// Example: 1
	ID() *int
	// Identifier of the user.
	// Example: 1
	SetID(int) UserAdmin
	// A parameter indicating that the user belongs to certain organizations
	Organizations() []UserAdminOrganizationsItem
	// A parameter indicating that the user belongs to certain organizations
	SetOrganizations([]UserAdminOrganizationsItem) UserAdmin
	// A flag indicating that the user has read-only access and cannot modify their own data.
	// Example: false
	Readonly() *bool
	// A flag indicating that the user has read-only access and cannot modify their own data.
	// Example: false
	SetReadonly(bool) UserAdmin
}

type UserAdminOrganizationsItem interface {
	// Id of the organization
	// Example: 1
	ID() *int
	// Id of the organization
	// Example: 1
	SetID(int) UserAdminOrganizationsItem
	// Owner properties.
	Owner() UserAdminOrganizationsItemOwner
	// Owner properties.
	SetOwner(UserAdminOrganizationsItemOwner) UserAdminOrganizationsItem
	// Organization permissions
	Permissions() OrganizationPermissions
	// Organization permissions
	SetPermissions(OrganizationPermissions) UserAdminOrganizationsItem
	// Display title of the organization
	// Example: Cameras
	Title() *string
	// Display title of the organization
	// Example: Cameras
	SetTitle(string) UserAdminOrganizationsItem
}

// Owner properties.
type UserAdminOrganizationsItemOwner interface {
	// ID of the organizations owner.
	// Example: 2
	ID() *int
	// ID of the organizations owner.
	// Example: 2
	SetID(int) UserAdminOrganizationsItemOwner
	// Name of the organizations owner.
	// Example: admin
	Name() *string
	// Name of the organizations owner.
	// Example: admin
	SetName(string) UserAdminOrganizationsItemOwner
}

// User parameters visible from Admin and Client APIs.
type UserBase interface {
	// The date and time when the user was created.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.672531199e+12
	CreatedAt() *UtcMs
	// The date and time when the user was created.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.672531199e+12
	SetCreatedAt(UtcMs) UserBase
	// User's email. Required for password recovery.
	// Format: email (email)
	// Example: user@example.com
	Email() *Email
	// User's email. Required for password recovery.
	// Format: email (email)
	// Example: user@example.com
	SetEmail(Email) UserBase
	// The user's full name.
	Fullname() *string
	// The user's full name.
	SetFullname(string) UserBase
	// The language, selected by user.
	// Format: ISO 639-1
	// Example: en
	Locale() *ISO6391
	// The language, selected by user.
	// Format: ISO 639-1
	// Example: en
	SetLocale(ISO6391) UserBase
	// The maximum number of sessions the user can have simultaneously.
	MaxSessions() *int
	// The maximum number of sessions the user can have simultaneously.
	SetMaxSessions(int) UserBase
	// User name (login)
	Name() *string
	// User name (login)
	SetName(string) UserBase
	// Additional information or notes about the user.
	Note() *string
	// Additional information or notes about the user.
	SetNote(string) UserBase
	// The specified password will be saved as a hash, used only for writing
	Password() *string
	// The specified password will be saved as a hash, used only for writing
	SetPassword(string) UserBase
	// User's phone number
	// Format: phone-number (phone-number)
	// Example: +78007778413
	Phone() *PhoneNumber
	// User's phone number
	// Format: phone-number (phone-number)
	// Example: +78007778413
	SetPhone(PhoneNumber) UserBase
}

type UserCreate interface {
	// The parameter regulates the rights for the user
	// Example: generic
	AccessLevel() *UserAdminAccessLevel
	// The parameter regulates the rights for the user
	// Example: generic
	SetAccessLevel(UserAdminAccessLevel) UserCreate
	// The date and time when the user was created.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.672531199e+12
	CreatedAt() *UtcMs
	// The date and time when the user was created.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.672531199e+12
	SetCreatedAt(UtcMs) UserCreate
	// A parameter that allows you to enable/disable the user
	// Example: false
	Disabled() *bool
	// A parameter that allows you to enable/disable the user
	// Example: false
	SetDisabled(bool) UserCreate
	// User's email. Required for password recovery.
	// Format: email (email)
	// Example: user@example.com
	Email() *Email
	// User's email. Required for password recovery.
	// Format: email (email)
	// Example: user@example.com
	SetEmail(Email) UserCreate
	// The user's full name.
	Fullname() *string
	// The user's full name.
	SetFullname(string) UserCreate
	// Identifier of the user.
	// Example: 1
	ID() *int
	// Identifier of the user.
	// Example: 1
	SetID(int) UserCreate
	// The language, selected by user.
	// Format: ISO 639-1
	// Example: en
	Locale() *ISO6391
	// The language, selected by user.
	// Format: ISO 639-1
	// Example: en
	SetLocale(ISO6391) UserCreate
	// The maximum number of sessions the user can have simultaneously.
	MaxSessions() *int
	// The maximum number of sessions the user can have simultaneously.
	SetMaxSessions(int) UserCreate
	// User name (login)
	Name() *string
	// User name (login)
	SetName(string) UserCreate
	// Additional information or notes about the user.
	Note() *string
	// Additional information or notes about the user.
	SetNote(string) UserCreate
	// The identifier of the Organization to which the user should be added.
	// If no organization_id - default organization should be used.
	// Example: 12
	OrganizationID() *int
	// The identifier of the Organization to which the user should be added.
	// If no organization_id - default organization should be used.
	// Example: 12
	SetOrganizationID(int) UserCreate
	// A parameter indicating that the user belongs to certain organizations
	Organizations() []UserAdminOrganizationsItem
	// A parameter indicating that the user belongs to certain organizations
	SetOrganizations([]UserAdminOrganizationsItem) UserCreate
	// The specified password will be saved as a hash, used only for writing
	Password() *string
	// The specified password will be saved as a hash, used only for writing
	SetPassword(string) UserCreate
	// User's phone number
	// Format: phone-number (phone-number)
	// Example: +78007778413
	Phone() *PhoneNumber
	// User's phone number
	// Format: phone-number (phone-number)
	// Example: +78007778413
	SetPhone(PhoneNumber) UserCreate
	// A flag indicating that the user has read-only access and cannot modify their own data.
	// Example: false
	Readonly() *bool
	// A flag indicating that the user has read-only access and cannot modify their own data.
	// Example: false
	SetReadonly(bool) UserCreate
}

type Users interface {
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	EstimatedCount() *int
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	SetEstimatedCount(int) Users
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	Next() *string
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	SetNext(string) Users
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	Prev() *string
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	SetPrev(string) Users
	// An object with a list of different timings measured during this API call.
	Timing() any
	// An object with a list of different timings measured during this API call.
	SetTiming(any) Users
	// List of fetched users according to the query parameters.
	UsersList() []User
	// List of fetched users according to the query parameters.
	SetUsersList([]User) Users
	// Collection returns the collection items
	Collection() []User
}

type VisionAlerts interface {
	// The time when an episode could not be created due to low detection quality (on blurry or noisy frames).
	// It may be caused by uncertainty when the picture is not clear enough.
	// Try adjusting the shutter speed parameters on your camera.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	LowQualityAt() *UtcMs
	// The time when an episode could not be created due to low detection quality (on blurry or noisy frames).
	// It may be caused by uncertainty when the picture is not clear enough.
	// Try adjusting the shutter speed parameters on your camera.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	SetLowQualityAt(UtcMs) VisionAlerts
	// The time when an episode could not be created due to insufficient detections.
	// The issue occurs when the selected detector is unable to find the target object enough times.
	// It is possible that the target object appears shortly or is obscured by something.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	NotEnoughDetectionsAt() *UtcMs
	// The time when an episode could not be created due to insufficient detections.
	// The issue occurs when the selected detector is unable to find the target object enough times.
	// It is possible that the target object appears shortly or is obscured by something.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	SetNotEnoughDetectionsAt(UtcMs) VisionAlerts
	// The time when an episode could not be created due to the small size of detections relative to the detector internal settings.
	// The camera placement may need to be adjusted closer to the target objects.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	SmallSizeAt() *UtcMs
	// The time when an episode could not be created due to the small size of detections relative to the detector internal settings.
	// The camera placement may need to be adjusted closer to the target objects.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	SetSmallSizeAt(UtcMs) VisionAlerts
}

// Required: detector_type, region_id
type VisionDetectorConfig interface {
	DetectorType() VisionDetectorConfigDetectorType
	SetDetectorType(VisionDetectorConfigDetectorType) VisionDetectorConfig
	RegionCoordinates() VisionDetectorConfigRegionCoordinates
	SetRegionCoordinates(VisionDetectorConfigRegionCoordinates) VisionDetectorConfig
	// Identifier of the detection area.
	// It is used to distinguish episodes from various regions of interest within the frame.
	// For instance, it can be used with a single camera facing two entrances to count visitors independently at each entrance.
	RegionID() string
	// Identifier of the detection area.
	// It is used to distinguish episodes from various regions of interest within the frame.
	// For instance, it can be used with a single camera facing two entrances to count visitors independently at each entrance.
	SetRegionID(string) VisionDetectorConfig
	// Name of the detection area
	// Example: Zone 1
	RegionTitle() *string
	// Name of the detection area
	// Example: Zone 1
	SetRegionTitle(string) VisionDetectorConfig
	// Runtime information about the vision process.
	Stats() VisionDetectorStats
	// Runtime information about the vision process.
	SetStats(VisionDetectorStats) VisionDetectorConfig
}

type VisionDetectorConfigDetectorType interface {
}

type VisionDetectorConfigRegionCoordinates interface {
}

type VisionDetectorStats interface {
	// Identifies analytics issues related to frames in a stream that impact episode creation
	Alerts() VisionAlerts
	// Identifies analytics issues related to frames in a stream that impact episode creation
	SetAlerts(VisionAlerts) VisionDetectorStats
	// The time when there was the last detection. Constant updates mean that analytics can detect objects on frames.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	LastDetectionAt() *UtcMs
	// The time when there was the last detection. Constant updates mean that analytics can detect objects on frames.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	SetLastDetectionAt(UtcMs) VisionDetectorStats
}

// 2D point
// Required: x, y
type VisionPoint interface {
	// X coordinate. Fraction of full frame width
	// Examples: 0.54, 0.78
	X() float64
	// X coordinate. Fraction of full frame width
	// Examples: 0.54, 0.78
	SetX(float64) VisionPoint
	// Y coordinate. Fraction of full frame height
	// Examples: 0.12, 0.38
	Y() float64
	// Y coordinate. Fraction of full frame height
	// Examples: 0.12, 0.38
	SetY(float64) VisionPoint
}

type VisionSpec interface {
	// The algorithm used for video analytics.
	// Example: faces
	Alg() *VisionSpecAlg
	// The algorithm used for video analytics.
	// Example: faces
	SetAlg(VisionSpecAlg) VisionSpec
	// This parameter allows you to select specific polygonal area(s) for detection.
	// By default, it is empty, and the recognition system searches over the entire camera field of view.
	// Each area is specified as a sequence of comma-separated coordinates of vertices of the polygon: `x0,y0,x1,y1,x2,y2,...`.
	// The vertices are specified in a counter-clockwise direction. Multiple areas are separated by `:`.
	Areas() *string
	// This parameter allows you to select specific polygonal area(s) for detection.
	// By default, it is empty, and the recognition system searches over the entire camera field of view.
	// Each area is specified as a sequence of comma-separated coordinates of vertices of the polygon: `x0,y0,x1,y1,x2,y2,...`.
	// The vertices are specified in a counter-clockwise direction. Multiple areas are separated by `:`.
	SetAreas(string) VisionSpec
	// Configuration of videoanalytics modules.
	// This configuration supersedes `alg` and `areas` parameters.
	// If this field is specified, values of `alg` and `areas` fields are being ignored.
	Detectors() []VisionDetectorConfig
	// Configuration of videoanalytics modules.
	// This configuration supersedes `alg` and `areas` parameters.
	// If this field is specified, values of `alg` and `areas` fields are being ignored.
	SetDetectors([]VisionDetectorConfig) VisionSpec
}

type VisionSpecPresets interface {
	// The algorithm used for video analytics.
	// Example: faces
	Alg() *VisionSpecPresetsAlg
	// The algorithm used for video analytics.
	// Example: faces
	SetAlg(VisionSpecPresetsAlg) VisionSpecPresets
}

type VodConfig interface {
	// Whether to add an audio-only version of an HLS stream.
	// Used to create App Store compliant HLS streams to deliver the content to Apple iOS devices.
	// Add audio-only HLS playlist to variant MBR playlist for iOS compliant streaming.
	// Example: false
	AddAudioOnly() *bool
	// Whether to add an audio-only version of an HLS stream.
	// Used to create App Store compliant HLS streams to deliver the content to Apple iOS devices.
	// Add audio-only HLS playlist to variant MBR playlist for iOS compliant streaming.
	// Example: false
	SetAddAudioOnly(bool) VodConfig
	// Turns on automatic creation of a multi-bitrate HLS playlist from several files with different bitrates.
	AutoMbr() *bool
	// Turns on automatic creation of a multi-bitrate HLS playlist from several files with different bitrates.
	SetAutoMbr(bool) VodConfig
	// Configuraton of the local file cache which is used for files from a cloud or an HTTP server.
	// If this option is enabled, a file will be downloaded to a local cache path by megabyte blocks.
	// During playback, the file will be first read from the cache.
	// This allows to avoid multiple HTTP requests to the source for each part of data and, thus, to speed up broadcasting.
	Cache() CacheSpec
	// Configuraton of the local file cache which is used for files from a cloud or an HTTP server.
	// If this option is enabled, a file will be downloaded to a local cache path by megabyte blocks.
	// During playback, the file will be first read from the cache.
	// This allows to avoid multiple HTTP requests to the source for each part of data and, thus, to speed up broadcasting.
	SetCache(CacheSpec) VodConfig
	// Whether this VOD location is disabled.
	// Example: false
	Disabled() *bool
	// Whether this VOD location is disabled.
	// Example: false
	SetDisabled(bool) VodConfig
	// Enables downloading files from the URL `http://FLUSSONIC-IP:80/vod_prefix/file_subpath.mp4`.
	// The `Range` HTTP headers are supported.
	// Example: false
	Download() *bool
	// Enables downloading files from the URL `http://FLUSSONIC-IP:80/vod_prefix/file_subpath.mp4`.
	// The `Range` HTTP headers are supported.
	// Example: false
	SetDownload(bool) VodConfig
	// Configuraton of the content encryption (DRM).
	Drm() DrmSpec
	// Configuraton of the content encryption (DRM).
	SetDrm(DrmSpec) VodConfig
	// Overlay logo.
	Logo() WebLogoSpec
	// Overlay logo.
	SetLogo(WebLogoSpec) VodConfig
	// Configuraton of the authorization backend for play sessions **only**.
	OnPlay() AuthSpec
	// Configuraton of the authorization backend for play sessions **only**.
	SetOnPlay(AuthSpec) VodConfig
	// If an order of VOD locations is declared, it is a position of the this VOD location in the order.
	// Format: sort_index (sort_index)
	// Example: 1
	Position() *SortIndex
	// If an order of VOD locations is declared, it is a position of the this VOD location in the order.
	// Format: sort_index (sort_index)
	// Example: 1
	SetPosition(SortIndex) VodConfig
	// The unique name of VOD location.
	// It is used as a prefix in file playback requests to explicitly specify where the system should find the files for playing.
	// All the path after the prefix will be cut and added to the specified path on the disk (the storage configured for this VOD location).
	// Thus, the system will find the file on the disk and play it.
	// Format: media_name (media_name)
	// Example: movies
	Prefix() *MediaName
	// The unique name of VOD location.
	// It is used as a prefix in file playback requests to explicitly specify where the system should find the files for playing.
	// All the path after the prefix will be cut and added to the specified path on the disk (the storage configured for this VOD location).
	// Thus, the system will find the file on the disk and play it.
	// Format: media_name (media_name)
	// Example: movies
	SetPrefix(MediaName) VodConfig
	// Configuraton of play protocols.
	Protocols() PlayProtocolsSpec
	// Configuraton of play protocols.
	SetProtocols(PlayProtocolsSpec) VodConfig
	// Human-readable name of the content provider. Applicable to MPEG-TS.
	Provider() *string
	// Human-readable name of the content provider. Applicable to MPEG-TS.
	SetProvider(string) VodConfig
	// The number of simultaneous readers form disk that should wait in a queue for playing a file.
	// Example: 100
	ReadQueue() *int
	// The number of simultaneous readers form disk that should wait in a queue for playing a file.
	// Example: 100
	SetReadQueue(int) VodConfig
	// The time, in seconds, of the segment duration. Used for the protocols like HLS or DASH.
	SegmentDuration() *Milliseconds
	// The time, in seconds, of the segment duration. Used for the protocols like HLS or DASH.
	SetSegmentDuration(Milliseconds) VodConfig
	// The directories (on disk or on another server) that Flussonic scans for VOD files.
	Storages() []VodStorage
	// The directories (on disk or on another server) that Flussonic scans for VOD files.
	SetStorages([]VodStorage) VodConfig
	// Configuration of thumbnails generator.
	Thumbnails() ThumbnailsSpec
	// Configuration of thumbnails generator.
	SetThumbnails(ThumbnailsSpec) VodConfig
	// The time (in milliseconds) passed since the last file request.
	// If the file was not requested within this period, it will be closed and its resources will be deallocated.
	// Example: 3
	Timeout() *int
	// The time (in milliseconds) passed since the last file request.
	// If the file was not requested within this period, it will be closed and its resources will be deallocated.
	// Example: 3
	SetTimeout(int) VodConfig
	// The names of separate segments within a segment-based HLS or DASH playlist start with the *specified* prefix.
	// The option no longer works for *variant playlists*.
	URLPrefix() *URLPrefix
	// The names of separate segments within a segment-based HLS or DASH playlist start with the *specified* prefix.
	// The option no longer works for *variant playlists*.
	SetURLPrefix(*URLPrefix) VodConfig
}

type VodStorage interface {
	// Some additional options.
	Extra() map[string]string
	// Some additional options.
	SetExtra(map[string]string) VodStorage
	// The storage (on the disk or on another server) that Flussonic will scan for VOD files.
	// If it is a path on the disk, it should be specified relating to the disk root.
	// It is possible to specify multiple storages for one VOD location. When Flussonic gets the URL for playing the file, it finds the prefix in this URL,
	// cuts the path after it and consequently searches for this path in all specified storages.
	// Example: /storage
	URL() *string
	// The storage (on the disk or on another server) that Flussonic will scan for VOD files.
	// If it is a path on the disk, it should be specified relating to the disk root.
	// It is possible to specify multiple storages for one VOD location. When Flussonic gets the URL for playing the file, it finds the prefix in this URL,
	// cuts the path after it and consequently searches for this path in all specified storages.
	// Example: /storage
	SetURL(string) VodStorage
}

type VsaasConfig interface {
	// All requests to /central will be proxied to this url.
	CentralURL() *string
	// All requests to /central will be proxied to this url.
	SetCentralURL(string) VsaasConfig
	// All requests to /vsaas and /watcher will be proxied to this url.
	// Watcher will not be launched by flussonic with this option.
	WatcherURL() *string
	// All requests to /vsaas and /watcher will be proxied to this url.
	// Watcher will not be launched by flussonic with this option.
	SetWatcherURL(string) VsaasConfig
}

type WatcherAgentConfig interface {
	// Agent identifier
	// Example: 1234567
	ID() *string
	// Agent identifier
	// Example: 1234567
	SetID(string) WatcherAgentConfig
	// Agent authentication key.
	Key() *string
	// Agent authentication key.
	SetKey(string) WatcherAgentConfig
	// The model of the camera with [Agent](https://flussonic.com/doc/agent-with-watcher/).
	Model() *string
	// The model of the camera with [Agent](https://flussonic.com/doc/agent-with-watcher/).
	SetModel(string) WatcherAgentConfig
	// The device (camera or router) serial number.
	Serial() *string
	// The device (camera or router) serial number.
	SetSerial(string) WatcherAgentConfig
	// Agents's metrics and other statistical information.
	Stats() WatcherAgentStats
	// Agents's metrics and other statistical information.
	SetStats(WatcherAgentStats) WatcherAgentConfig
	// List of streams info that have this agent in their inputs
	Streams() []any
	// List of streams info that have this agent in their inputs
	SetStreams([]any) WatcherAgentConfig
}

type WatcherAgentControlConnection interface {
	// A flag showing if Agent is connected at the moment of the request.
	Alive() *bool
	// A flag showing if Agent is connected at the moment of the request.
	SetAlive(bool) WatcherAgentControlConnection
	// A number of bytes received from the server by Agent since `opened_at`.
	// Format: bytes (bytes)
	// Example: 40000
	BytesFromServer() *Bytes
	// A number of bytes received from the server by Agent since `opened_at`.
	// Format: bytes (bytes)
	// Example: 40000
	SetBytesFromServer(Bytes) WatcherAgentControlConnection
	// A number of bytes sent to the server by Agent since `opened_at`.
	// Format: bytes (bytes)
	// Example: 4e+11
	BytesToServer() *Bytes
	// A number of bytes sent to the server by Agent since `opened_at`.
	// Format: bytes (bytes)
	// Example: 4e+11
	SetBytesToServer(Bytes) WatcherAgentControlConnection
	// Hostname of the server
	// Example: agents-001.vsaas.io
	Hostname() *string
	// Hostname of the server
	// Example: agents-001.vsaas.io
	SetHostname(string) WatcherAgentControlConnection
	// Timestamp of the current Agent control connection opening.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	OpenedAt() *UtcMs
	// Timestamp of the current Agent control connection opening.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	SetOpenedAt(UtcMs) WatcherAgentControlConnection
	// UTC timestamp of the last Agent status change to offline or online.
	// Same as `opened_at` if Agent is now connected.
	// Format: utc (Unix timestamp in seconds)
	// Example: 1.634560921e+09
	StatusChangedAt() *Utc
	// UTC timestamp of the last Agent status change to offline or online.
	// Same as `opened_at` if Agent is now connected.
	// Format: utc (Unix timestamp in seconds)
	// Example: 1.634560921e+09
	SetStatusChangedAt(Utc) WatcherAgentControlConnection
}

type WatcherAgentDataConnections interface {
	// A number of times the streamer tried to open a data connection via this Agent.
	// Example: 400
	ConnectionsAttempted() *int
	// A number of times the streamer tried to open a data connection via this Agent.
	// Example: 400
	SetConnectionsAttempted(int) WatcherAgentDataConnections
	// A number of currently active data connections opened via this Agent.
	// Example: 2
	ConnectionsCurrent() *int
	// A number of currently active data connections opened via this Agent.
	// Example: 2
	SetConnectionsCurrent(int) WatcherAgentDataConnections
	// A number of successfully opened data connections via this Agent.
	// Example: 300
	ConnectionsOpened() *int
	// A number of successfully opened data connections via this Agent.
	// Example: 300
	SetConnectionsOpened(int) WatcherAgentDataConnections
}

type WatcherAgentStats interface {
	// The type of Agent installed on the device:
	// * `single` means "one Agent = one camera", i.e. Agent is installed on a camera itself.
	// * `router` means "one Agent = multiple cameras", i.e. Agent is installed on a router
	// to provision the cameras from LAN to Watcher.
	AgentType() *string
	// The type of Agent installed on the device:
	// * `single` means "one Agent = one camera", i.e. Agent is installed on a camera itself.
	// * `router` means "one Agent = multiple cameras", i.e. Agent is installed on a router
	// to provision the cameras from LAN to Watcher.
	SetAgentType(string) WatcherAgentStats
	// The number of successfully established connections.
	ConnectionsEstablished() *int
	// The number of successfully established connections.
	SetConnectionsEstablished(int) WatcherAgentStats
	// The number of connections requested by Agent.
	ConnectionsRequested() *int
	// The number of connections requested by Agent.
	SetConnectionsRequested(int) WatcherAgentStats
	// Parameters of the connection between Agent and its endpoint.
	EndpointConnection() WatcherAgentControlConnection
	// Parameters of the connection between Agent and its endpoint.
	SetEndpointConnection(WatcherAgentControlConnection) WatcherAgentStats
	// IP address of the device (camera or router) in the local network.
	// Format: ipv4 (ipv4)
	// Example: 10.10.17.88
	LocalIP() *Ipv4
	// IP address of the device (camera or router) in the local network.
	// Format: ipv4 (ipv4)
	// Example: 10.10.17.88
	SetLocalIP(Ipv4) WatcherAgentStats
	// MAC-address of the device.
	// Example: F0-23-B9-59-20-F1
	MacAddress() *string
	// MAC-address of the device.
	// Example: F0-23-B9-59-20-F1
	SetMacAddress(string) WatcherAgentStats
	// Public IP address of the device (camera or router) on which the Agent is running.
	// Format: ipv4 (ipv4)
	// Example: 185.134.232.183
	PeerIP() *Ipv4
	// Public IP address of the device (camera or router) on which the Agent is running.
	// Format: ipv4 (ipv4)
	// Example: 185.134.232.183
	SetPeerIP(Ipv4) WatcherAgentStats
	// Parameters of the connection between Agent and its streampoint.
	StreampointConnection() WatcherAgentStatsStreampointConnection
	// Parameters of the connection between Agent and its streampoint.
	SetStreampointConnection(WatcherAgentStatsStreampointConnection) WatcherAgentStats
	// Agent version.
	// Example: v21.02-8-g535c85d
	Version() *string
	// Agent version.
	// Example: v21.02-8-g535c85d
	SetVersion(string) WatcherAgentStats
}

// Parameters of the connection between Agent and its streampoint.
type WatcherAgentStatsStreampointConnection interface {
	// A flag showing if Agent is connected at the moment of the request.
	Alive() *bool
	// A flag showing if Agent is connected at the moment of the request.
	SetAlive(bool) WatcherAgentStatsStreampointConnection
	// A number of bytes received from the server by Agent since `opened_at`.
	// Format: bytes (bytes)
	// Example: 40000
	BytesFromServer() *Bytes
	// A number of bytes received from the server by Agent since `opened_at`.
	// Format: bytes (bytes)
	// Example: 40000
	SetBytesFromServer(Bytes) WatcherAgentStatsStreampointConnection
	// A number of bytes sent to the server by Agent since `opened_at`.
	// Format: bytes (bytes)
	// Example: 4e+11
	BytesToServer() *Bytes
	// A number of bytes sent to the server by Agent since `opened_at`.
	// Format: bytes (bytes)
	// Example: 4e+11
	SetBytesToServer(Bytes) WatcherAgentStatsStreampointConnection
	// A number of times the streamer tried to open a data connection via this Agent.
	// Example: 400
	ConnectionsAttempted() *int
	// A number of times the streamer tried to open a data connection via this Agent.
	// Example: 400
	SetConnectionsAttempted(int) WatcherAgentStatsStreampointConnection
	// A number of currently active data connections opened via this Agent.
	// Example: 2
	ConnectionsCurrent() *int
	// A number of currently active data connections opened via this Agent.
	// Example: 2
	SetConnectionsCurrent(int) WatcherAgentStatsStreampointConnection
	// A number of successfully opened data connections via this Agent.
	// Example: 300
	ConnectionsOpened() *int
	// A number of successfully opened data connections via this Agent.
	// Example: 300
	SetConnectionsOpened(int) WatcherAgentStatsStreampointConnection
	// Hostname of the server
	// Example: agents-001.vsaas.io
	Hostname() *string
	// Hostname of the server
	// Example: agents-001.vsaas.io
	SetHostname(string) WatcherAgentStatsStreampointConnection
	// Timestamp of the current Agent control connection opening.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	OpenedAt() *UtcMs
	// Timestamp of the current Agent control connection opening.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	SetOpenedAt(UtcMs) WatcherAgentStatsStreampointConnection
	// UTC timestamp of the last Agent status change to offline or online.
	// Same as `opened_at` if Agent is now connected.
	// Format: utc (Unix timestamp in seconds)
	// Example: 1.634560921e+09
	StatusChangedAt() *Utc
	// UTC timestamp of the last Agent status change to offline or online.
	// Same as `opened_at` if Agent is now connected.
	// Format: utc (Unix timestamp in seconds)
	// Example: 1.634560921e+09
	SetStatusChangedAt(Utc) WatcherAgentStatsStreampointConnection
}

type WatcherStatus interface {
	// List of Watcher checks
	Checks() WatcherStatusChecks
	// List of Watcher checks
	SetChecks(WatcherStatusChecks) WatcherStatus
	// The operator identifier
	// Example: 15432
	OperatorID() *int
	// The operator identifier
	// Example: 15432
	SetOperatorID(int) WatcherStatus
}

// List of Watcher checks
type WatcherStatusChecks interface {
	// List of errors details
	ErrorsDetails() []WatcherStatusChecksErrorsDetailsItem
	// List of errors details
	SetErrorsDetails([]WatcherStatusChecksErrorsDetailsItem) WatcherStatusChecks
	// Whether or not the Watcher API key has been updated on the agent server.
	// Example: true
	IsDomainAPIKeyMatched() *bool
	// Whether or not the Watcher API key has been updated on the agent server.
	// Example: true
	SetIsDomainAPIKeyMatched(bool) WatcherStatusChecks
	// Watcher availability from the Internet
	// Example: true
	IsWatcherURLAvailable() *bool
	// Watcher availability from the Internet
	// Example: true
	SetIsWatcherURLAvailable(bool) WatcherStatusChecks
	// Whether or not the Watcher host has been updated on the agent server.
	// Example: false
	IsWatcherURLMatched() *bool
	// Whether or not the Watcher host has been updated on the agent server.
	// Example: false
	SetIsWatcherURLMatched(bool) WatcherStatusChecks
}

// Error details
type WatcherStatusChecksErrorsDetailsItem interface {
	// Failed check name
	Check() *string
	// Failed check name
	SetCheck(string) WatcherStatusChecksErrorsDetailsItem
	// Error message
	Error() *string
	// Error message
	SetError(string) WatcherStatusChecksErrorsDetailsItem
}

type WatcherStreamConfig interface {
	// Audio settings for the stream.
	Audio() WatcherStreamConfigAudio
	// Audio settings for the stream.
	SetAudio(WatcherStreamConfigAudio) WatcherStreamConfig
	// A publishable stream.
	// Example: false
	CanPublish() *bool
	// A publishable stream.
	// Example: false
	SetCanPublish(bool) WatcherStreamConfig
	// Camera coordinates on a map or a floor plan.
	Coordinates() MapSpec
	// Camera coordinates on a map or a floor plan.
	SetCoordinates(MapSpec) WatcherStreamConfig
	// The date and time when the steam was created.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.672531199e+12
	CreatedAt() *UtcMs
	// The date and time when the steam was created.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.672531199e+12
	SetCreatedAt(UtcMs) WatcherStreamConfig
	// Domain the stream belongs to.
	Domain() DomainBase
	// Domain the stream belongs to.
	SetDomain(DomainBase) WatcherStreamConfig
	// Duration of the firmware update. If this field is present, the update process is ongoing.
	// Format: milliseconds (milliseconds)
	FirmwareUpdateDuration() *Milliseconds
	// Duration of the firmware update. If this field is present, the update process is ongoing.
	// Format: milliseconds (milliseconds)
	SetFirmwareUpdateDuration(Milliseconds) WatcherStreamConfig
	// Folder identificator.
	FolderID() *int
	// Folder identificator.
	SetFolderID(int) WatcherStreamConfig
	// Information about the latest changes made to the camera configuration.
	LastChange() AuditLogRecord
	// Information about the latest changes made to the camera configuration.
	SetLastChange(AuditLogRecord) WatcherStreamConfig
	// The time when the last episode occurred.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	LastEpisodeAt() *UtcMs
	// The time when the last episode occurred.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetLastEpisodeAt(UtcMs) WatcherStreamConfig
	// Layouts information
	Layout() CentralStreamLayout
	// Layouts information
	SetLayout(CentralStreamLayout) WatcherStreamConfig
	// Rules of layout.
	LayoutRules() StreamZoneConfig
	// Rules of layout.
	SetLayoutRules(StreamZoneConfig) WatcherStreamConfig
	// Deprecated field. Will be deleted at 24.12
	// Camera coordinates on a map or a floor plan. Deprecated. Use coordinates instead.
	MapCoordinates() MapSpec
	// Deprecated field. Will be deleted at 24.12
	// Camera coordinates on a map or a floor plan. Deprecated. Use coordinates instead.
	SetMapCoordinates(MapSpec) WatcherStreamConfig
	// Onvif configuration
	Onvif() StreamOnvifConfig
	// Onvif configuration
	SetOnvif(StreamOnvifConfig) WatcherStreamConfig
	// Organization the stream belongs to.
	Organization() OrganizationStream
	// Organization the stream belongs to.
	SetOrganization(OrganizationStream) WatcherStreamConfig
	// Deprecated field. Will be deleted at 25.11
	// ID of the organization the stream belongs to.
	// Only organization owner or domain administrator could change it.
	// Example: 9
	OrganizationID() *int
	// Deprecated field. Will be deleted at 25.11
	// ID of the organization the stream belongs to.
	// Only organization owner or domain administrator could change it.
	// Example: 9
	SetOrganizationID(int) WatcherStreamConfig
	// Contains path to stream as a list.
	// Each item of the list can be interpreted as a node in a folders tree.
	Path() []StreamPathItem
	// Contains path to stream as a list.
	// Each item of the list can be interpreted as a node in a folders tree.
	SetPath([]StreamPathItem) WatcherStreamConfig
	// Camera adress on a map.
	PostalAddress() *string
	// Camera adress on a map.
	SetPostalAddress(string) WatcherStreamConfig
	// Preset settings.
	Preset() StreamPreset
	// Preset settings.
	SetPreset(StreamPreset) WatcherStreamConfig
	// Deprecated field. Will be deleted at 26.01
	// Preset identificator.
	PresetID() *int
	// Deprecated field. Will be deleted at 26.01
	// Preset identificator.
	SetPresetID(int) WatcherStreamConfig
}

// Audio settings for the stream.
type WatcherStreamConfigAudio interface {
	// A flag showing if the audio is captured (false) or not (true) from the stream.
	// Example: false
	Disabled() *bool
	// A flag showing if the audio is captured (false) or not (true) from the stream.
	// Example: false
	SetDisabled(bool) WatcherStreamConfigAudio
	// Audio codec (the AAC codec is used by default).
	TranscodeAudioCodec() *FrameAudioCodec
	// Audio codec (the AAC codec is used by default).
	SetTranscodeAudioCodec(FrameAudioCodec) WatcherStreamConfigAudio
}

type WebLogoSpec interface {
	// Change the position of the logo to the bottom.
	Bottom() *int
	// Change the position of the logo to the bottom.
	SetBottom(int) WebLogoSpec
	// Set the specified height for the logo.
	// Example: 100
	Height() *int
	// Set the specified height for the logo.
	// Example: 100
	SetHeight(int) WebLogoSpec
	// Change the position of the logo to the left.
	// Example: 15
	Left() *int
	// Change the position of the logo to the left.
	// Example: 15
	SetLeft(int) WebLogoSpec
	// Change the position of the logo to the right.
	Right() *int
	// Change the position of the logo to the right.
	SetRight(int) WebLogoSpec
	// Change the position of the logo to the top.
	// Example: 15
	Top() *int
	// Change the position of the logo to the top.
	// Example: 15
	SetTop(int) WebLogoSpec
	// Set the specified width for the logo.
	// Example: 200
	Width() *int
	// Set the specified width for the logo.
	// Example: 200
	SetWidth(int) WebLogoSpec
}

// Required: ports
type WebrtcRouterConfig interface {
	// Ports that will be used for WebRTC data handling.
	Ports() []int
	// Ports that will be used for WebRTC data handling.
	SetPorts([]int) WebrtcRouterConfig
	// Transport protocol
	Transport() *WebrtcTransport
	// Transport protocol
	SetTransport(WebrtcTransport) WebrtcRouterConfig
}

// Required: name
type Zone interface {
	// Information about the created zone.
	Created() CreationInfo
	// Information about the created zone.
	SetCreated(CreationInfo) Zone
	// Dedicated zones can only accept streams with the corresponding required or preferred zone assignment.
	// They are used to separate streamers from cameras that should not be assigned to them.
	// Example: false
	IsDedicated() *bool
	// Dedicated zones can only accept streams with the corresponding required or preferred zone assignment.
	// They are used to separate streamers from cameras that should not be assigned to them.
	// Example: false
	SetIsDedicated(bool) Zone
	// The name of the zone. Unique identifier.
	// Format: unix_name (Contains only alphanumeric characters (a-z, A-Z, 0-9), underscores (_), hyphens (-) and periods (.).)
	// Pattern: ^[a-zA-Z0-9_.-]+$
	// Example: zone1
	Name() UnixName
	// The name of the zone. Unique identifier.
	// Format: unix_name (Contains only alphanumeric characters (a-z, A-Z, 0-9), underscores (_), hyphens (-) and periods (.).)
	// Pattern: ^[a-zA-Z0-9_.-]+$
	// Example: zone1
	SetName(UnixName) Zone
	// Statistics of the zone.
	Stats() ZoneStats
	// Statistics of the zone.
	SetStats(ZoneStats) Zone
}

// Statistics of the zone.
type ZoneStats interface {
	// Number of streams with preferred zone assignment
	// Example: 10
	PreferredStreamsCount() *int
	// Number of streams with preferred zone assignment
	// Example: 10
	SetPreferredStreamsCount(int) ZoneStats
	// Number of streams with required zone assignment
	// Example: 10
	RequiredStreamsCount() *int
	// Number of streams with required zone assignment
	// Example: 10
	SetRequiredStreamsCount(int) ZoneStats
	// List of streamers assigned to this zone.
	// Example: [streamer1 streamer2]
	Streamers() []string
	// List of streamers assigned to this zone.
	// Example: [streamer1 streamer2]
	SetStreamers([]string) ZoneStats
	// Number of streamers assigned to this zone
	// Example: 1
	StreamersCount() *int
	// Number of streamers assigned to this zone
	// Example: 1
	SetStreamersCount(int) ZoneStats
}

type ZonesList interface {
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	EstimatedCount() *int
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	SetEstimatedCount(int) ZonesList
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	Next() *string
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	SetNext(string) ZonesList
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	Prev() *string
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	SetPrev(string) ZonesList
	// An object with a list of different timings measured during this API call.
	Timing() any
	// An object with a list of different timings measured during this API call.
	SetTiming(any) ZonesList
	// The list of zones fetched according to the query parameters.
	Zones() []Zone
	// The list of zones fetched according to the query parameters.
	SetZones([]Zone) ZonesList
	// Collection returns the collection items
	Collection() []Zone
}

type APICallImpl struct {
	CreatedAtValue   *DateTime     `json:"created_at,omitempty" validate:"omitempty"`
	DurationValue    *Microseconds `json:"duration,omitempty" validate:"omitempty"`
	IPValue          *IP           `json:"ip,omitempty" validate:"omitempty"`
	OperationIDValue *string       `json:"operation_id,omitempty" validate:"omitempty"`
	OriginatorValue  *string       `json:"originator,omitempty" validate:"omitempty"`
	PayloadValue     *string       `json:"payload,omitempty" validate:"omitempty"`
	RequestIDValue   *string       `json:"request_id,omitempty" validate:"omitempty"`
	StatusValue      *int          `json:"status,omitempty" validate:"omitempty"`
	UserAgentValue   *string       `json:"user_agent,omitempty" validate:"omitempty"`
}

type APICallEventImpl struct {
	PayloadValue     *string       `json:"payload,omitempty" validate:"omitempty"`
	QsValue          *string       `json:"qs,omitempty" validate:"omitempty"`
	UtcMsValue       *UtcMs        `json:"utc_ms,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	EventIDValue     *int          `json:"event_id,omitempty" validate:"omitempty"`
	IPValue          *IP           `json:"ip,omitempty" validate:"omitempty"`
	OperationIDValue *string       `json:"operation_id,omitempty" validate:"omitempty"`
	DurationValue    *Microseconds `json:"duration,omitempty" validate:"omitempty"`
	OriginatorValue  *string       `json:"originator,omitempty" validate:"omitempty"`
	CreatedAtValue   *DateTime     `json:"created_at,omitempty" validate:"omitempty"`
	PathValue        *string       `json:"path,omitempty" validate:"omitempty"`
	RequestIDValue   *string       `json:"request_id,omitempty" validate:"omitempty"`
	ServerValue      *string       `json:"server,omitempty" validate:"omitempty"`
	StatusValue      *int          `json:"status,omitempty" validate:"omitempty"`
	TraceIDValue     *UUID         `json:"trace_id,omitempty" validate:"omitempty"`
	UserAgentValue   *string       `json:"user_agent,omitempty" validate:"omitempty"`
	EventValue       string        `json:"event" validate:"required"`
}

// Required: login, password
type AdminCredentialsImpl struct {
	LoginValue    string   `json:"login" validate:"required"`
	PasswordValue Password `json:"password" validate:"required"`
}

type AgentImpl struct {
	IDValue      *string                `json:"id,omitempty" validate:"omitempty"`
	KeyValue     *string                `json:"key,omitempty" validate:"omitempty"`
	ModelValue   *string                `json:"model,omitempty" validate:"omitempty"`
	SerialValue  *string                `json:"serial,omitempty" validate:"omitempty"`
	StatsValue   *WatcherAgentStatsImpl `json:"stats,omitempty" validate:"omitempty"`
	StreamsValue []any                  `json:"streams,omitempty" validate:"omitempty"`
}

type AgentConfigBaseImpl struct {
	IDValue     *string                `json:"id,omitempty" validate:"omitempty"`
	KeyValue    *string                `json:"key,omitempty" validate:"omitempty"`
	ModelValue  *string                `json:"model,omitempty" validate:"omitempty"`
	SerialValue *string                `json:"serial,omitempty" validate:"omitempty"`
	StatsValue  *WatcherAgentStatsImpl `json:"stats,omitempty" validate:"omitempty"`
}

type AgentsListImpl struct {
	TimingValue         any          `json:"timing,omitempty" validate:"omitempty"`
	EstimatedCountValue *int         `json:"estimated_count,omitempty" validate:"omitempty"`
	NextValue           *string      `json:"next,omitempty" validate:"omitempty"`
	PrevValue           *string      `json:"prev,omitempty" validate:"omitempty"`
	AgentsValue         []*AgentImpl `json:"agents,omitempty" validate:"omitempty"`
}

// Users apikey for access via API.
type ApikeyImpl struct {
	ApikeyValue *string `json:"apikey,omitempty" validate:"omitempty"`
}

type AppearanceConfigImpl struct {
	ColorsValue   *AppearanceConfigColorsImpl `json:"colors,omitempty" validate:"omitempty"`
	FaviconValue  *Byte                       `json:"favicon,omitempty" validate:"omitempty"`
	LogoValue     *Byte                       `json:"logo,omitempty" validate:"omitempty"`
	LogoAuthValue *Byte                       `json:"logo_auth,omitempty" validate:"omitempty"`
	TitleValue    *string                     `json:"title,omitempty" validate:"omitempty"`
}

// The interface colors.
type AppearanceConfigColorsImpl struct {
	BackgroundValue *string `json:"background,omitempty" validate:"omitempty"`
	PrimaryValue    *string `json:"primary,omitempty" validate:"omitempty"`
	SecondaryValue  *string `json:"secondary,omitempty" validate:"omitempty"`
}

type AuditLogRecordImpl struct {
	CreatedAtValue *UtcMs  `json:"created_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	UserValue      *string `json:"user,omitempty" validate:"omitempty"`
}

// Authentication details configuration
type AuthImpl struct {
	LoginValue    *string `json:"login,omitempty" validate:"omitempty"`
	PasswordValue *string `json:"password,omitempty" validate:"omitempty"`
	PortValue     *int    `json:"port,omitempty" validate:"omitempty"`
}

// Required: name
type AuthBackendConfigImpl struct {
	AllowDefaultValue   *bool                 `json:"allow_default,omitempty" validate:"omitempty"`
	NameValue           AuthBackendName       `json:"name" validate:"required"`
	AllowCountriesValue []string              `json:"allow_countries,omitempty" validate:"omitempty"`
	AllowIpsValue       []string              `json:"allow_ips,omitempty" validate:"omitempty"`
	AllowTokensValue    []string              `json:"allow_tokens,omitempty" validate:"omitempty"`
	AllowUasValue       []string              `json:"allow_uas,omitempty" validate:"omitempty"`
	BackendsValue       []*AuthBackendURLImpl `json:"backends,omitempty" validate:"omitempty"`
	DenyCountriesValue  []string              `json:"deny_countries,omitempty" validate:"omitempty"`
	DenyIpsValue        []string              `json:"deny_ips,omitempty" validate:"omitempty"`
	DenyTokensValue     []string              `json:"deny_tokens,omitempty" validate:"omitempty"`
	DenyUasValue        []string              `json:"deny_uas,omitempty" validate:"omitempty"`
}

// Required: url
type AuthBackendURLImpl struct {
	URLValue string `json:"url" validate:"required"`
}

type AuthSpecImpl struct {
	ExtraValue               map[string]string `json:"extra,omitempty" validate:"omitempty"`
	MaxSessionsValue         *int              `json:"max_sessions,omitempty" validate:"omitempty"`
	SoftLimitationValue      *bool             `json:"soft_limitation,omitempty" validate:"omitempty"`
	URLValue                 *AuthURL          `json:"url,omitempty" validate:"omitempty"`
	AllowedCountriesValue    []Iso3166         `json:"allowed_countries,omitempty" validate:"omitempty"`
	DisallowedCountriesValue []Iso3166         `json:"disallowed_countries,omitempty" validate:"omitempty"`
	DomainsValue             []string          `json:"domains,omitempty" validate:"omitempty"`
	SessionKeysValue         []SessionKey      `json:"session_keys,omitempty" validate:"omitempty"`
}

type BalancerConfigImpl struct {
	ModeValue    *BalancerConfigMode         `json:"mode,omitempty" validate:"omitempty,oneof=usage clients bitrate streams"`
	NameValue    *MediaName                  `json:"name,omitempty" validate:"omitempty"`
	ServersValue []*BalancerServerConfigImpl `json:"servers,omitempty" validate:"omitempty"`
}

type BalancerServerConfigImpl struct {
	CountriesDefaultValue *bool       `json:"countries_default,omitempty" validate:"omitempty"`
	MaxBitrateValue       *Speed      `json:"max_bitrate,omitempty" validate:"omitempty"`
	NameValue             *ServerName `json:"name,omitempty" validate:"omitempty"`
	CountriesValue        []Iso3166   `json:"countries,omitempty" validate:"omitempty"`
}

// Required: name
type CacheConfigImpl struct {
	ExpirationValue   *Seconds  `json:"expiration,omitempty" validate:"omitempty"`
	MissesValue       *int      `json:"misses,omitempty" validate:"omitempty"`
	PathValue         *DiskPath `json:"path,omitempty" validate:"omitempty"`
	StorageLimitValue *Bytes    `json:"storage_limit,omitempty" validate:"omitempty"`
	NameValue         CacheName `json:"name" validate:"required"`
}

type CacheSpecImpl struct {
	ExpirationValue   *Seconds   `json:"expiration,omitempty" validate:"omitempty"`
	MissesValue       *int       `json:"misses,omitempty" validate:"omitempty"`
	ReferenceValue    *CacheName `json:"reference,omitempty" validate:"omitempty"`
	StorageLimitValue *Bytes     `json:"storage_limit,omitempty" validate:"omitempty"`
}

type CameraAlarmConfigImpl struct {
	ListenValue *ListenSpec `json:"listen,omitempty" validate:"omitempty"`
	CatchValue  []string    `json:"catch,omitempty" validate:"omitempty"`
}

type CameraConfigImpl struct {
	CameraInfoValue   any `json:"camera_info,omitempty" validate:"omitempty"`
	MediaQualityValue any `json:"media_quality,omitempty" validate:"omitempty"`
	SensorValue       any `json:"sensor,omitempty" validate:"omitempty"`
}

// Camera information
type CameraInfoImpl struct {
	FirmwareValue     *string `json:"firmware,omitempty" validate:"omitempty"`
	ManufacturerValue *string `json:"manufacturer,omitempty" validate:"omitempty"`
	ModelValue        *string `json:"model,omitempty" validate:"omitempty"`
	SerialNumberValue *string `json:"serial_number,omitempty" validate:"omitempty"`
}

type CameraTagWbImpl struct {
}

// Predictions for disk usage.
type CentralDiskPredictionsImpl struct {
	EstimatedDiskUsageValue *Percent `json:"estimated_disk_usage,omitempty" validate:"omitempty,min=0,max=100"`
}

type CentralNodeLayoutDecisionImpl struct {
	HostnameValue     *ServerName                       `json:"hostname,omitempty" validate:"omitempty"`
	NodeDecisionValue *bool                             `json:"node_decision,omitempty" validate:"omitempty"`
	RoleValue         *CentralNodeRoleRole              `json:"role,omitempty" validate:"omitempty,oneof=streamer inference identification"`
	ReasonsValue      []CentralNodeLayoutDecisionReason `json:"reasons,omitempty" validate:"omitempty"`
}

type CentralNodeRoleImpl struct {
	RoleValue *CentralNodeRoleRole `json:"role,omitempty" validate:"omitempty,oneof=streamer inference identification"`
}

type CentralStreamLayoutImpl struct {
	ChangeReasonValue        *CentralStreamLayoutChangeReason `json:"change_reason,omitempty" validate:"omitempty,oneof=stream_misses_node_required_labels node_misses_stream_required_labels node_become_offline stream_disabled node_deleted node_channel_limit_exceeded multistream_agent_ingest_conflict streamer_dvr_size_exceeded streamer_total_bandwidth_exceeded preferred_labels_better_match not_distributed dvr_redundancy_adjust node_cpu_pressure relayout_by_api namespace_mismatch"`
	CreatedAtValue           *UtcMs                           `json:"created_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	InferenceValue           *ServerName                      `json:"inference,omitempty" validate:"omitempty"`
	IngestValue              *ServerName                      `json:"ingest,omitempty" validate:"omitempty"`
	OriginatorValue          *CentralStreamLayoutOriginator   `json:"originator,omitempty" validate:"omitempty"`
	DvrBackupsValue          []ServerName                     `json:"dvr_backups,omitempty" validate:"omitempty"`
	IngestHistoryValue       []*CentralStreamLayoutBaseImpl   `json:"ingest_history,omitempty" validate:"omitempty"`
	NodeLayoutDecisionsValue []*CentralNodeLayoutDecisionImpl `json:"node_layout_decisions,omitempty" validate:"omitempty"`
}

type CentralStreamLayoutBaseImpl struct {
	CreatedAtValue  *UtcMs                         `json:"created_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	IngestValue     *ServerName                    `json:"ingest,omitempty" validate:"omitempty"`
	OriginatorValue *CentralStreamLayoutOriginator `json:"originator,omitempty" validate:"omitempty"`
}

type CentralStreamLayoutListItemImpl struct {
	ChangeReasonValue        *CentralStreamLayoutChangeReason `json:"change_reason,omitempty" validate:"omitempty,oneof=stream_misses_node_required_labels node_misses_stream_required_labels node_become_offline stream_disabled node_deleted node_channel_limit_exceeded multistream_agent_ingest_conflict streamer_dvr_size_exceeded streamer_total_bandwidth_exceeded preferred_labels_better_match not_distributed dvr_redundancy_adjust node_cpu_pressure relayout_by_api namespace_mismatch"`
	CreatedAtValue           *UtcMs                           `json:"created_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	InferenceValue           *ServerName                      `json:"inference,omitempty" validate:"omitempty"`
	IngestValue              *ServerName                      `json:"ingest,omitempty" validate:"omitempty"`
	NameValue                *string                          `json:"name,omitempty" validate:"omitempty"`
	OriginatorValue          *CentralStreamLayoutOriginator   `json:"originator,omitempty" validate:"omitempty"`
	DvrBackupsValue          []ServerName                     `json:"dvr_backups,omitempty" validate:"omitempty"`
	IngestHistoryValue       []*CentralStreamLayoutBaseImpl   `json:"ingest_history,omitempty" validate:"omitempty"`
	NodeLayoutDecisionsValue []*CentralNodeLayoutDecisionImpl `json:"node_layout_decisions,omitempty" validate:"omitempty"`
}

type CentralStreamLayoutPredictionImpl struct {
	TimingValue         any                                `json:"timing,omitempty" validate:"omitempty"`
	EstimatedCountValue *int                               `json:"estimated_count,omitempty" validate:"omitempty"`
	NextValue           *string                            `json:"next,omitempty" validate:"omitempty"`
	PrevValue           *string                            `json:"prev,omitempty" validate:"omitempty"`
	ChangesValue        []*CentralStreamLayoutListItemImpl `json:"changes,omitempty" validate:"omitempty"`
}

type CentralStreamLayoutsImpl struct {
	TimingValue         any                        `json:"timing,omitempty" validate:"omitempty"`
	EstimatedCountValue *int                       `json:"estimated_count,omitempty" validate:"omitempty"`
	NextValue           *string                    `json:"next,omitempty" validate:"omitempty"`
	PrevValue           *string                    `json:"prev,omitempty" validate:"omitempty"`
	LayoutsValue        []*CentralStreamLayoutImpl `json:"layouts,omitempty" validate:"omitempty"`
}

type CentralStreamerLayoutPredictionImpl struct {
	TimingValue         any                                        `json:"timing,omitempty" validate:"omitempty"`
	EstimatedCountValue *int                                       `json:"estimated_count,omitempty" validate:"omitempty"`
	NextValue           *string                                    `json:"next,omitempty" validate:"omitempty"`
	PrevValue           *string                                    `json:"prev,omitempty" validate:"omitempty"`
	ChangesValue        []*CentralStreamerLayoutPredictionItemImpl `json:"changes,omitempty" validate:"omitempty"`
}

type CentralStreamerLayoutPredictionItemImpl struct {
	AfterValue    *int                                     `json:"after,omitempty" validate:"omitempty"`
	BeforeValue   *int                                     `json:"before,omitempty" validate:"omitempty"`
	DeltaValue    *int                                     `json:"delta,omitempty" validate:"omitempty"`
	HostnameValue *ServerName                              `json:"hostname,omitempty" validate:"omitempty"`
	RoleValue     *CentralStreamerLayoutPredictionItemRole `json:"role,omitempty" validate:"omitempty,oneof=ingest inference dvr_backup"`
}

type CertificateInfoImpl struct {
	IssuerNameValue *string  `json:"issuer_name,omitempty" validate:"omitempty"`
	NotAfterValue   *int     `json:"not_after,omitempty" validate:"omitempty"`
	NotBeforeValue  *int     `json:"not_before,omitempty" validate:"omitempty"`
	PublicKeyValue  *string  `json:"public_key,omitempty" validate:"omitempty"`
	DomainsValue    []string `json:"domains,omitempty" validate:"omitempty"`
}

type ChassisConfigImpl struct {
	LcdValue                     *bool             `json:"lcd,omitempty" validate:"omitempty"`
	AutoRebootValue              *bool             `json:"auto_reboot,omitempty" validate:"omitempty"`
	DefaultGatewayInterfaceValue *string           `json:"default_gateway_interface,omitempty" validate:"omitempty"`
	DhcpdIfaceValue              *InterfaceName    `json:"dhcpd_iface,omitempty" validate:"omitempty"`
	DhcpdPortValue               *ListenSpec       `json:"dhcpd_port,omitempty" validate:"omitempty"`
	DhcpdPortDestValue           *ListenSpec       `json:"dhcpd_port_dest,omitempty" validate:"omitempty"`
	FirmwareBootDirValue         *DiskPath         `json:"firmware_boot_dir,omitempty" validate:"omitempty"`
	FirmwareHostValue            *URL              `json:"firmware_host,omitempty" validate:"omitempty"`
	HostnameValue                *ServerName       `json:"hostname,omitempty" validate:"omitempty"`
	FirmwareVersionValue         *string           `json:"firmware_version,omitempty" validate:"omitempty"`
	NtpdIfaceValue               *InterfaceName    `json:"ntpd_iface,omitempty" validate:"omitempty"`
	UpdateChannelValue           *string           `json:"update_channel,omitempty" validate:"omitempty"`
	APIPortValue                 *ListenSpec       `json:"api_port,omitempty" validate:"omitempty"`
	NtpdPortValue                *ListenSpec       `json:"ntpd_port,omitempty" validate:"omitempty"`
	ProductNameValue             *ChassisProduct   `json:"product_name,omitempty" validate:"omitempty"`
	RestartCoderTimeoutValue     *int              `json:"restart_coder_timeout,omitempty" validate:"omitempty"`
	StatsValue                   *ChassisStatsImpl `json:"stats,omitempty" validate:"omitempty"`
	TftpPortValue                *ListenSpec       `json:"tftp_port,omitempty" validate:"omitempty"`
	TftpRootValue                *DiskPath         `json:"tftp_root,omitempty" validate:"omitempty"`
	NtpServersValue              []string          `json:"ntp_servers,omitempty" validate:"omitempty"`
}

type ChassisStatsImpl struct {
	HardwareIDValue           *string `json:"hardware_id,omitempty" validate:"omitempty"`
	HostnameValue             *string `json:"hostname,omitempty" validate:"omitempty"`
	ModelValue                *string `json:"model,omitempty" validate:"omitempty"`
	NextVersionValue          *string `json:"next_version,omitempty" validate:"omitempty"`
	NtpClockSynchronizedValue *bool   `json:"ntp_clock_synchronized,omitempty" validate:"omitempty"`
	SerialNumberValue         *string `json:"serial_number,omitempty" validate:"omitempty"`
	SystemTimeValue           *UtcMs  `json:"system_time,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	VersionValue              *string `json:"version,omitempty" validate:"omitempty"`
}

type ClosedCaptionsImpl struct {
	LanguageValue *string `json:"language,omitempty" validate:"omitempty"`
	NameValue     *string `json:"name,omitempty" validate:"omitempty"`
}

// Number of entities, grouped by status
type ClusterHealthMetricsTotalImpl struct {
	DegradatedValue    *int `json:"degradated,omitempty" validate:"omitempty" openmetrics_metric:"degradated_count"`
	DisabledValue      *int `json:"disabled,omitempty" validate:"omitempty" openmetrics_metric:"disabled_count"`
	OperationalValue   *int `json:"operational,omitempty" validate:"omitempty" openmetrics_metric:"operational_count"`
	OutageValue        *int `json:"outage,omitempty" validate:"omitempty" openmetrics_metric:"outage_count"`
	PartialOutageValue *int `json:"partial_outage,omitempty" validate:"omitempty" openmetrics_metric:"partial_outage_count"`
	TotalValue         *int `json:"total,omitempty" validate:"omitempty" openmetrics_metric:"total_count"`
}

type ClusterHealthStatsImpl struct {
	AgentMetricsTotalValue           *ClusterHealthMetricsTotalImpl                     `json:"agent_metrics_total,omitempty" validate:"omitempty" openmetrics_metric_segment:"agent"`
	CollectedAtValue                 *UtcMs                                             `json:"collected_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	ServerIDValue                    *UUID                                              `json:"server_id,omitempty" validate:"omitempty" openmetrics_label:"server_id"`
	StreamMetricsTotalValue          *ClusterHealthMetricsTotalImpl                     `json:"stream_metrics_total,omitempty" validate:"omitempty" openmetrics_metric_segment:"stream"`
	StreamerBitrateMetricsTotalValue *ClusterHealthStatsStreamerBitrateMetricsTotalImpl `json:"streamer_bitrate_metrics_total,omitempty" validate:"omitempty"`
	StreamerMetricsTotalValue        *ClusterHealthMetricsTotalImpl                     `json:"streamer_metrics_total,omitempty" validate:"omitempty" openmetrics_metric_segment:"streamer"`
	VersionValue                     *int                                               `json:"version,omitempty" validate:"omitempty" openmetrics_metric:"version"`
	StreamerMetricsValue             []*ClusterHealthStreamerStatsImpl                  `json:"streamer_metrics,omitempty" validate:"omitempty"`
}

// Cluster total bitrate metrics
type ClusterHealthStatsStreamerBitrateMetricsTotalImpl struct {
	InputKbitValue  *Speed `json:"input_kbit,omitempty" validate:"omitempty" openmetrics_metric:"streamer_inbound_kbit_total"`
	OutputKbitValue *Speed `json:"output_kbit,omitempty" validate:"omitempty" openmetrics_metric:"streamer_outbound_kbit_total"`
}

// Streamer stats
// Required: hostname
type ClusterHealthStreamerStatsImpl struct {
	AgentMetricsValue  *ClusterHealthStreamerStatsAgentMetricsImpl  `json:"agent_metrics,omitempty" validate:"omitempty"`
	ConfigValue        *ClusterHealthStreamerStatsConfigImpl        `json:"config,omitempty" validate:"omitempty"`
	CpuValue           *ClusterHealthStreamerStatsCpuImpl           `json:"cpu,omitempty" validate:"omitempty"`
	MemoryValue        *ClusterHealthStreamerStatsMemoryImpl        `json:"memory,omitempty" validate:"omitempty"`
	NetworkValue       *ClusterHealthStreamerStatsNetworkImpl       `json:"network,omitempty" validate:"omitempty"`
	StatusValue        *ClusterHealthStatus                         `json:"status,omitempty" validate:"omitempty"`
	StorageValue       *ClusterHealthStreamerStatsStorageImpl       `json:"storage,omitempty" validate:"omitempty"`
	StreamMetricsValue *ClusterHealthStreamerStatsStreamMetricsImpl `json:"stream_metrics,omitempty" validate:"omitempty"`
	UptimeValue        *Seconds                                     `json:"uptime,omitempty" validate:"omitempty"`
	HostnameValue      ServerName                                   `json:"hostname" validate:"required" openmetrics_label:"hostname"`
}

// Streamer agents info.
type ClusterHealthStreamerStatsAgentMetricsImpl struct {
	DegradatedValue    *int                 `json:"degradated,omitempty" validate:"omitempty" openmetrics_metric:"degradated_count"`
	DisabledValue      *int                 `json:"disabled,omitempty" validate:"omitempty" openmetrics_metric:"disabled_count"`
	OperationalValue   *int                 `json:"operational,omitempty" validate:"omitempty" openmetrics_metric:"operational_count"`
	OutageValue        *int                 `json:"outage,omitempty" validate:"omitempty" openmetrics_metric:"outage_count"`
	PartialOutageValue *int                 `json:"partial_outage,omitempty" validate:"omitempty" openmetrics_metric:"partial_outage_count"`
	StatusValue        *ClusterHealthStatus `json:"status,omitempty" validate:"omitempty"`
	TotalValue         *int                 `json:"total,omitempty" validate:"omitempty" openmetrics_metric:"total_count"`
}

// Streamer config info.
type ClusterHealthStreamerStatsConfigImpl struct {
	StatusValue *ClusterHealthStatus `json:"status,omitempty" validate:"omitempty"`
}

// CPU usage info.
type ClusterHealthStreamerStatsCpuImpl struct {
	StatusValue *ClusterHealthStatus `json:"status,omitempty" validate:"omitempty"`
	UsageValue  *Percent             `json:"usage,omitempty" validate:"omitempty,min=0,max=100" openmetrics_metric:"cpu_usage"`
}

// Memory usage info.
type ClusterHealthStreamerStatsMemoryImpl struct {
	StatusValue *ClusterHealthStatus `json:"status,omitempty" validate:"omitempty"`
	UsageValue  *Percent             `json:"usage,omitempty" validate:"omitempty,min=0,max=100" openmetrics_metric:"memory_usage"`
}

// Network IO info.
type ClusterHealthStreamerStatsNetworkImpl struct {
	InKbitValue  *ClusterHealthStreamerStatsNetworkInKbitImpl  `json:"in_kbit,omitempty" validate:"omitempty"`
	OutKbitValue *ClusterHealthStreamerStatsNetworkOutKbitImpl `json:"out_kbit,omitempty" validate:"omitempty"`
}

// Inbound network info on the server.
type ClusterHealthStreamerStatsNetworkInKbitImpl struct {
	StatusValue *ClusterHealthStatus `json:"status,omitempty" validate:"omitempty"`
	UsageValue  *Speed               `json:"usage,omitempty" validate:"omitempty" openmetrics_metric:"network_usage_in"`
}

// Outbound network info on the server.
type ClusterHealthStreamerStatsNetworkOutKbitImpl struct {
	StatusValue *ClusterHealthStatus `json:"status,omitempty" validate:"omitempty"`
	UsageValue  *Speed               `json:"usage,omitempty" validate:"omitempty" openmetrics_metric:"network_usage_out"`
}

// Total disk usage info.
type ClusterHealthStreamerStatsStorageImpl struct {
	StatusValue *ClusterHealthStatus `json:"status,omitempty" validate:"omitempty"`
	UsageValue  *Percent             `json:"usage,omitempty" validate:"omitempty,min=0,max=100" openmetrics_metric:"storage_usage"`
}

// Streamer streams info.
type ClusterHealthStreamerStatsStreamMetricsImpl struct {
	DegradatedValue    *int                 `json:"degradated,omitempty" validate:"omitempty" openmetrics_metric:"degradated_count"`
	DisabledValue      *int                 `json:"disabled,omitempty" validate:"omitempty" openmetrics_metric:"disabled_count"`
	OperationalValue   *int                 `json:"operational,omitempty" validate:"omitempty" openmetrics_metric:"operational_count"`
	OutageValue        *int                 `json:"outage,omitempty" validate:"omitempty" openmetrics_metric:"outage_count"`
	PartialOutageValue *int                 `json:"partial_outage,omitempty" validate:"omitempty" openmetrics_metric:"partial_outage_count"`
	StatusValue        *ClusterHealthStatus `json:"status,omitempty" validate:"omitempty"`
	TotalValue         *int                 `json:"total,omitempty" validate:"omitempty" openmetrics_metric:"total_count"`
}

type CollectionResponseImpl struct {
	EstimatedCountValue *int    `json:"estimated_count,omitempty" validate:"omitempty"`
	NextValue           *string `json:"next,omitempty" validate:"omitempty"`
	PrevValue           *string `json:"prev,omitempty" validate:"omitempty"`
	TimingValue         any     `json:"timing,omitempty" validate:"omitempty"`
}

type ConfigErrorStatusImpl struct {
	ColValue            *int                `json:"col,omitempty" validate:"omitempty"`
	ConfigValue         any                 `json:"config,omitempty" validate:"omitempty"`
	DetailValue         any                 `json:"detail,omitempty" validate:"omitempty"`
	ErrorValue          *string             `json:"error,omitempty" validate:"omitempty"`
	FirstErrorColValue  *int                `json:"first_error_col,omitempty" validate:"omitempty"`
	FirstErrorLineValue *int                `json:"first_error_line,omitempty" validate:"omitempty"`
	LineValue           *int                `json:"line,omitempty" validate:"omitempty"`
	PathValue           []ConfigPathSegment `json:"path,omitempty" validate:"omitempty"`
}

type ConfigExternalErrorStatusImpl struct {
	CodeValue   *int                             `json:"code,omitempty" validate:"omitempty"`
	DetailValue *string                          `json:"detail,omitempty" validate:"omitempty"`
	ErrorValue  *string                          `json:"error,omitempty" validate:"omitempty"`
	ReasonValue *RequestErrorReason              `json:"reason,omitempty" validate:"omitempty"`
	StatusValue *ConfigExternalErrorStatusStatus `json:"status,omitempty" validate:"omitempty,oneof=loaded error"`
	WhileValue  *ConfigExternalErrorStatusWhile  `json:"while,omitempty" validate:"omitempty,oneof=refresh request srt_port_resolve"`
	PathValue   []ConfigPathSegment              `json:"path,omitempty" validate:"omitempty"`
}

type CreationInfoImpl struct {
	CreatedAtValue *UtcMs                `json:"created_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	UserValue      *CreationInfoUserImpl `json:"user,omitempty" validate:"omitempty"`
}

// Information about the user who created the entity.
type CreationInfoUserImpl struct {
	IDValue   *int    `json:"id,omitempty" validate:"omitempty"`
	NameValue *string `json:"name,omitempty" validate:"omitempty"`
}

// Required: url
type DatabaseImpl struct {
	URLValue string `json:"url" validate:"required"`
}

type DecklinkConfigImpl struct {
	NameValue    *DecklinkCardID        `json:"name,omitempty" validate:"omitempty"`
	ProfileValue *DecklinkConfigProfile `json:"profile,omitempty" validate:"omitempty,oneof=one_full one_half two_full two_half four_half"`
}

// Base information about domain
type DomainBaseImpl struct {
	IDValue    *int    `json:"id,omitempty" validate:"omitempty"`
	TitleValue *string `json:"title,omitempty" validate:"omitempty"`
}

// All domain settings
type DomainConfigImpl struct {
	AppearanceValue *AppearanceConfigImpl `json:"appearance,omitempty" validate:"omitempty"`
	MailValue       *MailSpecImpl         `json:"mail,omitempty" validate:"omitempty"`
}

type DrmBaseImpl struct {
	EncryptionValue *string        `json:"encryption,omitempty" validate:"omitempty"`
	ExpiresValue    *int           `json:"expires,omitempty" validate:"omitempty"`
	KeyserverValue  *string        `json:"keyserver,omitempty" validate:"omitempty"`
	ResourceIDValue *DrmResourceID `json:"resource_id,omitempty" validate:"omitempty"`
}

type DrmCpixBaseImpl struct {
	EncryptionValue *string        `json:"encryption,omitempty" validate:"omitempty"`
	ExpiresValue    *int           `json:"expires,omitempty" validate:"omitempty"`
	IvValue         *string        `json:"iv,omitempty" validate:"omitempty"`
	KeyserverValue  *string        `json:"keyserver,omitempty" validate:"omitempty"`
	ResourceIDValue *DrmResourceID `json:"resource_id,omitempty" validate:"omitempty"`
	SystemsValue    []DrmSystem    `json:"systems,omitempty" validate:"omitempty"`
}

type DrmEncKeyImpl struct {
	KeyValue *string `json:"key,omitempty" validate:"omitempty"`
}

type DrmEncKeyURLImpl struct {
	URLValue *string `json:"url,omitempty" validate:"omitempty"`
}

type DrmIvImpl struct {
	IvValue *string `json:"iv,omitempty" validate:"omitempty"`
}

type DrmKeyosBaseImpl struct {
	ContentIDValue         *string `json:"content_id,omitempty" validate:"omitempty"`
	EndUserCertValue       *string `json:"end_user_cert,omitempty" validate:"omitempty"`
	EndUserPrivateKeyValue *string `json:"end_user_private_key,omitempty" validate:"omitempty"`
	UserkeyValue           *string `json:"userkey,omitempty" validate:"omitempty"`
}

type DrmSpecImpl struct {
	KeyserverValue         *string        `json:"keyserver,omitempty" validate:"omitempty"`
	LaURLValue             *URL           `json:"la_url,omitempty" validate:"omitempty"`
	AuthServerValue        *string        `json:"auth_server,omitempty" validate:"omitempty"`
	ContentIDValue         *string        `json:"content_id,omitempty" validate:"omitempty"`
	CpixConfigIDValue      *string        `json:"cpix_config_id,omitempty" validate:"omitempty"`
	EncTokenValue          *string        `json:"enc_token,omitempty" validate:"omitempty"`
	EncryptionValue        *string        `json:"encryption,omitempty" validate:"omitempty"`
	EndUserCertValue       *string        `json:"end_user_cert,omitempty" validate:"omitempty"`
	EndUserPrivateKeyValue *string        `json:"end_user_private_key,omitempty" validate:"omitempty"`
	ExpiresValue           *int           `json:"expires,omitempty" validate:"omitempty"`
	FpValue                *string        `json:"fp,omitempty" validate:"omitempty"`
	HlsExtXKeyIvValue      *bool          `json:"hls_ext_x_key_iv,omitempty" validate:"omitempty"`
	IcHostValue            *string        `json:"ic_host,omitempty" validate:"omitempty"`
	IvValue                *string        `json:"iv,omitempty" validate:"omitempty"`
	KeyValue               *string        `json:"key,omitempty" validate:"omitempty"`
	KeyseedValue           *string        `json:"keyseed,omitempty" validate:"omitempty"`
	AesKeyValue            *string        `json:"aes_key,omitempty" validate:"omitempty"`
	AccountIDValue         *string        `json:"account_id,omitempty" validate:"omitempty"`
	ManagementKeyValue     *string        `json:"management_key,omitempty" validate:"omitempty"`
	MerchantIDValue        *string        `json:"merchant_id,omitempty" validate:"omitempty"`
	PasswordValue          *string        `json:"password,omitempty" validate:"omitempty"`
	ResourceIDValue        *DrmResourceID `json:"resource_id,omitempty" validate:"omitempty"`
	SecretValue            *string        `json:"secret,omitempty" validate:"omitempty"`
	SignerValue            *string        `json:"signer,omitempty" validate:"omitempty"`
	SiteValue              *string        `json:"site,omitempty" validate:"omitempty"`
	UsernameValue          *string        `json:"username,omitempty" validate:"omitempty"`
	TenantIDValue          *string        `json:"tenant_id,omitempty" validate:"omitempty"`
	URLValue               *string        `json:"url,omitempty" validate:"omitempty"`
	UserValue              *string        `json:"user,omitempty" validate:"omitempty"`
	UserKeyserverValue     *string        `json:"user_keyserver,omitempty" validate:"omitempty"`
	UserNameValue          *string        `json:"user_name,omitempty" validate:"omitempty"`
	UserPathValue          *string        `json:"user_path,omitempty" validate:"omitempty"`
	UserkeyValue           *string        `json:"userkey,omitempty" validate:"omitempty"`
	VendorValue            string         `json:"vendor" validate:"required"`
	SystemsValue           []DrmSystem    `json:"systems,omitempty" validate:"omitempty"`
}

type DrmSystemsImpl struct {
	SystemsValue []DrmSystem `json:"systems,omitempty" validate:"omitempty"`
}

type DrmVendorAes128Impl struct {
	EncryptionValue   *string        `json:"encryption,omitempty" validate:"omitempty"`
	ExpiresValue      *int           `json:"expires,omitempty" validate:"omitempty"`
	HlsExtXKeyIvValue *bool          `json:"hls_ext_x_key_iv,omitempty" validate:"omitempty"`
	KeyserverValue    *string        `json:"keyserver,omitempty" validate:"omitempty"`
	ResourceIDValue   *DrmResourceID `json:"resource_id,omitempty" validate:"omitempty"`
	VendorValue       string         `json:"vendor" validate:"required"`
}

type DrmVendorAxinomImpl struct {
	EncryptionValue    *string        `json:"encryption,omitempty" validate:"omitempty"`
	ExpiresValue       *int           `json:"expires,omitempty" validate:"omitempty"`
	IvValue            *string        `json:"iv,omitempty" validate:"omitempty"`
	KeyserverValue     *string        `json:"keyserver,omitempty" validate:"omitempty"`
	ManagementKeyValue *string        `json:"management_key,omitempty" validate:"omitempty"`
	ResourceIDValue    *DrmResourceID `json:"resource_id,omitempty" validate:"omitempty"`
	TenantIDValue      *string        `json:"tenant_id,omitempty" validate:"omitempty"`
	VendorValue        string         `json:"vendor" validate:"required"`
	SystemsValue       []DrmSystem    `json:"systems,omitempty" validate:"omitempty"`
}

type DrmVendorBuydrmImpl struct {
	ContentIDValue         *string        `json:"content_id,omitempty" validate:"omitempty"`
	EncryptionValue        *string        `json:"encryption,omitempty" validate:"omitempty"`
	EndUserCertValue       *string        `json:"end_user_cert,omitempty" validate:"omitempty"`
	EndUserPrivateKeyValue *string        `json:"end_user_private_key,omitempty" validate:"omitempty"`
	ExpiresValue           *int           `json:"expires,omitempty" validate:"omitempty"`
	KeyserverValue         *string        `json:"keyserver,omitempty" validate:"omitempty"`
	ResourceIDValue        *DrmResourceID `json:"resource_id,omitempty" validate:"omitempty"`
	UserkeyValue           *string        `json:"userkey,omitempty" validate:"omitempty"`
	VendorValue            string         `json:"vendor" validate:"required"`
}

type DrmVendorClearkeyImpl struct {
	EncryptionValue *string        `json:"encryption,omitempty" validate:"omitempty"`
	ExpiresValue    *int           `json:"expires,omitempty" validate:"omitempty"`
	KeyValue        *string        `json:"key,omitempty" validate:"omitempty"`
	KeyserverValue  *string        `json:"keyserver,omitempty" validate:"omitempty"`
	ResourceIDValue *DrmResourceID `json:"resource_id,omitempty" validate:"omitempty"`
	VendorValue     string         `json:"vendor" validate:"required"`
}

type DrmVendorConaxImpl struct {
	EncryptionValue *string        `json:"encryption,omitempty" validate:"omitempty"`
	ExpiresValue    *int           `json:"expires,omitempty" validate:"omitempty"`
	KeyserverValue  *string        `json:"keyserver,omitempty" validate:"omitempty"`
	ResourceIDValue *DrmResourceID `json:"resource_id,omitempty" validate:"omitempty"`
	UserPathValue   *string        `json:"user_path,omitempty" validate:"omitempty"`
	VendorValue     string         `json:"vendor" validate:"required"`
	SystemsValue    []DrmSystem    `json:"systems,omitempty" validate:"omitempty"`
}

type DrmVendorCpixImpl struct {
	EncryptionValue *string        `json:"encryption,omitempty" validate:"omitempty"`
	ExpiresValue    *int           `json:"expires,omitempty" validate:"omitempty"`
	IvValue         *string        `json:"iv,omitempty" validate:"omitempty"`
	KeyserverValue  *string        `json:"keyserver,omitempty" validate:"omitempty"`
	ResourceIDValue *DrmResourceID `json:"resource_id,omitempty" validate:"omitempty"`
	VendorValue     string         `json:"vendor" validate:"required"`
	SystemsValue    []DrmSystem    `json:"systems,omitempty" validate:"omitempty"`
}

type DrmVendorDrmtodayImpl struct {
	AuthServerValue   *string        `json:"auth_server,omitempty" validate:"omitempty"`
	CpixConfigIDValue *string        `json:"cpix_config_id,omitempty" validate:"omitempty"`
	EncryptionValue   *string        `json:"encryption,omitempty" validate:"omitempty"`
	ExpiresValue      *int           `json:"expires,omitempty" validate:"omitempty"`
	IvValue           *string        `json:"iv,omitempty" validate:"omitempty"`
	KeyserverValue    *string        `json:"keyserver,omitempty" validate:"omitempty"`
	MerchantIDValue   *string        `json:"merchant_id,omitempty" validate:"omitempty"`
	PasswordValue     *string        `json:"password,omitempty" validate:"omitempty"`
	ResourceIDValue   *DrmResourceID `json:"resource_id,omitempty" validate:"omitempty"`
	UsernameValue     *string        `json:"username,omitempty" validate:"omitempty"`
	VendorValue       string         `json:"vendor" validate:"required"`
	SystemsValue      []DrmSystem    `json:"systems,omitempty" validate:"omitempty"`
}

type DrmVendorEzdrmImpl struct {
	EncryptionValue *string        `json:"encryption,omitempty" validate:"omitempty"`
	ExpiresValue    *int           `json:"expires,omitempty" validate:"omitempty"`
	KeyserverValue  *string        `json:"keyserver,omitempty" validate:"omitempty"`
	PasswordValue   *string        `json:"password,omitempty" validate:"omitempty"`
	ResourceIDValue *DrmResourceID `json:"resource_id,omitempty" validate:"omitempty"`
	UserValue       *string        `json:"user,omitempty" validate:"omitempty"`
	VendorValue     string         `json:"vendor" validate:"required"`
}

type DrmVendorEzdrmClassicImpl struct {
	EncryptionValue *string        `json:"encryption,omitempty" validate:"omitempty"`
	ExpiresValue    *int           `json:"expires,omitempty" validate:"omitempty"`
	KeyserverValue  *string        `json:"keyserver,omitempty" validate:"omitempty"`
	PasswordValue   *string        `json:"password,omitempty" validate:"omitempty"`
	ResourceIDValue *DrmResourceID `json:"resource_id,omitempty" validate:"omitempty"`
	UserValue       *string        `json:"user,omitempty" validate:"omitempty"`
	VendorValue     string         `json:"vendor" validate:"required"`
}

type DrmVendorGsdrmImpl struct {
	EncryptionValue *string        `json:"encryption,omitempty" validate:"omitempty"`
	ExpiresValue    *int           `json:"expires,omitempty" validate:"omitempty"`
	KeyserverValue  *string        `json:"keyserver,omitempty" validate:"omitempty"`
	ResourceIDValue *DrmResourceID `json:"resource_id,omitempty" validate:"omitempty"`
	VendorValue     string         `json:"vendor" validate:"required"`
}

type DrmVendorIrdetoImpl struct {
	AccountIDValue  *string        `json:"account_id,omitempty" validate:"omitempty"`
	EncryptionValue *string        `json:"encryption,omitempty" validate:"omitempty"`
	ExpiresValue    *int           `json:"expires,omitempty" validate:"omitempty"`
	IcHostValue     *string        `json:"ic_host,omitempty" validate:"omitempty"`
	IvValue         *string        `json:"iv,omitempty" validate:"omitempty"`
	KeyserverValue  *string        `json:"keyserver,omitempty" validate:"omitempty"`
	PasswordValue   *string        `json:"password,omitempty" validate:"omitempty"`
	ResourceIDValue *DrmResourceID `json:"resource_id,omitempty" validate:"omitempty"`
	UserNameValue   *string        `json:"user_name,omitempty" validate:"omitempty"`
	VendorValue     string         `json:"vendor" validate:"required"`
	SystemsValue    []DrmSystem    `json:"systems,omitempty" validate:"omitempty"`
}

type DrmVendorKeyosImpl struct {
	ContentIDValue         *string        `json:"content_id,omitempty" validate:"omitempty"`
	EncryptionValue        *string        `json:"encryption,omitempty" validate:"omitempty"`
	EndUserCertValue       *string        `json:"end_user_cert,omitempty" validate:"omitempty"`
	EndUserPrivateKeyValue *string        `json:"end_user_private_key,omitempty" validate:"omitempty"`
	ExpiresValue           *int           `json:"expires,omitempty" validate:"omitempty"`
	KeyserverValue         *string        `json:"keyserver,omitempty" validate:"omitempty"`
	ResourceIDValue        *DrmResourceID `json:"resource_id,omitempty" validate:"omitempty"`
	UserkeyValue           *string        `json:"userkey,omitempty" validate:"omitempty"`
	VendorValue            string         `json:"vendor" validate:"required"`
}

type DrmVendorPallyconImpl struct {
	EncTokenValue   *string        `json:"enc_token,omitempty" validate:"omitempty"`
	EncryptionValue *string        `json:"encryption,omitempty" validate:"omitempty"`
	ExpiresValue    *int           `json:"expires,omitempty" validate:"omitempty"`
	IvValue         *string        `json:"iv,omitempty" validate:"omitempty"`
	KeyserverValue  *string        `json:"keyserver,omitempty" validate:"omitempty"`
	ResourceIDValue *DrmResourceID `json:"resource_id,omitempty" validate:"omitempty"`
	VendorValue     string         `json:"vendor" validate:"required"`
	SystemsValue    []DrmSystem    `json:"systems,omitempty" validate:"omitempty"`
}

type DrmVendorPlayreadyImpl struct {
	EncryptionValue *string        `json:"encryption,omitempty" validate:"omitempty"`
	ExpiresValue    *int           `json:"expires,omitempty" validate:"omitempty"`
	KeyseedValue    *string        `json:"keyseed,omitempty" validate:"omitempty"`
	KeyserverValue  *string        `json:"keyserver,omitempty" validate:"omitempty"`
	LaURLValue      *URL           `json:"la_url,omitempty" validate:"omitempty"`
	ResourceIDValue *DrmResourceID `json:"resource_id,omitempty" validate:"omitempty"`
	VendorValue     string         `json:"vendor" validate:"required"`
}

type DrmVendorSampleAesImpl struct {
	EncryptionValue *string        `json:"encryption,omitempty" validate:"omitempty"`
	ExpiresValue    *int           `json:"expires,omitempty" validate:"omitempty"`
	KeyserverValue  *string        `json:"keyserver,omitempty" validate:"omitempty"`
	ResourceIDValue *DrmResourceID `json:"resource_id,omitempty" validate:"omitempty"`
	VendorValue     string         `json:"vendor" validate:"required"`
}

type DrmVendorSampleAesIdentityImpl struct {
	IvValue     *string `json:"iv,omitempty" validate:"omitempty"`
	KeyValue    *string `json:"key,omitempty" validate:"omitempty"`
	URLValue    *string `json:"url,omitempty" validate:"omitempty"`
	VendorValue string  `json:"vendor" validate:"required"`
}

type DrmVendorSolocooImpl struct {
	EncryptionValue *string        `json:"encryption,omitempty" validate:"omitempty"`
	ExpiresValue    *int           `json:"expires,omitempty" validate:"omitempty"`
	FpValue         *string        `json:"fp,omitempty" validate:"omitempty"`
	KeyserverValue  *string        `json:"keyserver,omitempty" validate:"omitempty"`
	ResourceIDValue *DrmResourceID `json:"resource_id,omitempty" validate:"omitempty"`
	SecretValue     *string        `json:"secret,omitempty" validate:"omitempty"`
	SiteValue       *string        `json:"site,omitempty" validate:"omitempty"`
	VendorValue     string         `json:"vendor" validate:"required"`
}

type DrmVendorVerimatrixImpl struct {
	EncryptionValue    *string        `json:"encryption,omitempty" validate:"omitempty"`
	ExpiresValue       *int           `json:"expires,omitempty" validate:"omitempty"`
	KeyserverValue     *string        `json:"keyserver,omitempty" validate:"omitempty"`
	ResourceIDValue    *DrmResourceID `json:"resource_id,omitempty" validate:"omitempty"`
	UserKeyserverValue *string        `json:"user_keyserver,omitempty" validate:"omitempty"`
	VendorValue        string         `json:"vendor" validate:"required"`
}

type DrmVendorWidevineImpl struct {
	AesKeyValue     *string        `json:"aes_key,omitempty" validate:"omitempty"`
	EncryptionValue *string        `json:"encryption,omitempty" validate:"omitempty"`
	ExpiresValue    *int           `json:"expires,omitempty" validate:"omitempty"`
	IvValue         *string        `json:"iv,omitempty" validate:"omitempty"`
	KeyserverValue  *string        `json:"keyserver,omitempty" validate:"omitempty"`
	ResourceIDValue *DrmResourceID `json:"resource_id,omitempty" validate:"omitempty"`
	SignerValue     *string        `json:"signer,omitempty" validate:"omitempty"`
	VendorValue     string         `json:"vendor" validate:"required"`
}

// Required: name
type DvbCardConfigImpl struct {
	InputBitrateValue           *int              `json:"input_bitrate,omitempty" validate:"omitempty"`
	IntFreqValue                *int              `json:"int_freq,omitempty" validate:"omitempty"`
	BandwidthValue              *int              `json:"bandwidth,omitempty" validate:"omitempty"`
	CodeRateHpValue             *DvbFec           `json:"code_rate_hp,omitempty" validate:"omitempty"`
	CodeRateLpValue             *DvbFec           `json:"code_rate_lp,omitempty" validate:"omitempty"`
	CommentValue                *string           `json:"comment,omitempty" validate:"omitempty"`
	CompensateTimeDriftPpmValue *int              `json:"compensate_time_drift_ppm,omitempty" validate:"omitempty"`
	DeviceValue                 *int              `json:"device,omitempty" validate:"omitempty"`
	AdapterValue                *int              `json:"adapter,omitempty" validate:"omitempty"`
	FrequencyValue              *int              `json:"frequency,omitempty" validate:"omitempty"`
	FrontendValue               *int              `json:"frontend,omitempty" validate:"omitempty"`
	GainValue                   *int              `json:"gain,omitempty" validate:"omitempty"`
	GuardIntervalValue          *string           `json:"guard_interval,omitempty" validate:"omitempty"`
	HierarchyValue              *string           `json:"hierarchy,omitempty" validate:"omitempty"`
	AttenuatorValue             *int              `json:"attenuator,omitempty" validate:"omitempty"`
	HighBandValue               *bool             `json:"high_band,omitempty" validate:"omitempty"`
	DisabledValue               *bool             `json:"disabled,omitempty" validate:"omitempty"`
	HwValue                     *string           `json:"hw,omitempty" validate:"omitempty"`
	InterleaveValue             *int              `json:"interleave,omitempty" validate:"omitempty,min=0,max=15"`
	ModulationValue             *string           `json:"modulation,omitempty" validate:"omitempty"`
	VideoDeviceValue            *string           `json:"video_device,omitempty" validate:"omitempty"`
	PilotValue                  *string           `json:"pilot,omitempty" validate:"omitempty"`
	PlpStreamIDValue            *int              `json:"plp_stream_id,omitempty" validate:"omitempty"`
	PolarizationValue           *string           `json:"polarization,omitempty" validate:"omitempty"`
	PortValue                   *int              `json:"port,omitempty" validate:"omitempty"`
	RolloffValue                *string           `json:"rolloff,omitempty" validate:"omitempty"`
	SerialValue                 *int              `json:"serial,omitempty" validate:"omitempty"`
	StatsValue                  *DvbCardStatsImpl `json:"stats,omitempty" validate:"omitempty"`
	SymbolRateValue             *int              `json:"symbol_rate,omitempty" validate:"omitempty"`
	SystemValue                 *string           `json:"system,omitempty" validate:"omitempty"`
	TransmissionModeValue       *string           `json:"transmission_mode,omitempty" validate:"omitempty"`
	NameValue                   DvbCardName       `json:"name" validate:"required" openmetrics_label:"name"`
}

type DvbCardStatsImpl struct {
	BerValue         *int  `json:"ber,omitempty" validate:"omitempty"`
	HasCarrierValue  *bool `json:"has_carrier,omitempty" validate:"omitempty"`
	HasLockValue     *bool `json:"has_lock,omitempty" validate:"omitempty"`
	HasRateValue     *bool `json:"has_rate,omitempty" validate:"omitempty"`
	HasReinitValue   *bool `json:"has_reinit,omitempty" validate:"omitempty"`
	HasSignalValue   *bool `json:"has_signal,omitempty" validate:"omitempty"`
	HasSyncValue     *bool `json:"has_sync,omitempty" validate:"omitempty"`
	HasTimedoutValue *bool `json:"has_timedout,omitempty" validate:"omitempty"`
	HasViterbiValue  *bool `json:"has_viterbi,omitempty" validate:"omitempty"`
	SnrValue         *int  `json:"snr,omitempty" validate:"omitempty"`
	SnrRawValue      *int  `json:"snr_raw,omitempty" validate:"omitempty"`
	StrengthValue    *int  `json:"strength,omitempty" validate:"omitempty" openmetrics_metric:"dvb_card_strength"`
	StrengthRawValue *int  `json:"strength_raw,omitempty" validate:"omitempty"`
}

type DvrBaseConfigImpl struct {
	DiskUsageLimitValue     *Percent `json:"disk_usage_limit,omitempty" validate:"omitempty,min=0,max=100"`
	EpisodesExpirationValue *Seconds `json:"episodes_expiration,omitempty" validate:"omitempty"`
	ExpirationValue         *Seconds `json:"expiration,omitempty" validate:"omitempty"`
	StorageLimitValue       *Bytes   `json:"storage_limit,omitempty" validate:"omitempty"`
}

// This list of stats can be used to monitor health of invidiual disk in storage.
// There are several layers of indexes in internal database, here you can validate
// integrity of data.
type DvrCapacityStatsImpl struct {
	BlobsCountValue   *int     `json:"blobs_count,omitempty" validate:"omitempty" openmetrics_metric:"storage_blobs_count"`
	BlobsCountDbValue *int     `json:"blobs_count_db,omitempty" validate:"omitempty" openmetrics_metric:"storage_blobs_count_db"`
	SizeValue         *Bytes   `json:"size,omitempty" validate:"omitempty" openmetrics_metric:"storage_size"`
	UsageValue        *Percent `json:"usage,omitempty" validate:"omitempty,min=0,max=100" openmetrics_metric:"storage_usage"`
	UsedValue         *Bytes   `json:"used,omitempty" validate:"omitempty" openmetrics_metric:"storage_used"`
	UsedIndexValue    *Bytes   `json:"used_index,omitempty" validate:"omitempty" openmetrics_metric:"storage_used_index"`
}

type DvrConfigImpl struct {
	ActiveValue             *int                       `json:"active,omitempty" validate:"omitempty"`
	DiskUsageLimitValue     *Percent                   `json:"disk_usage_limit,omitempty" validate:"omitempty,min=0,max=100"`
	EpisodesExpirationValue *Seconds                   `json:"episodes_expiration,omitempty" validate:"omitempty"`
	ExpirationValue         *Seconds                   `json:"expiration,omitempty" validate:"omitempty"`
	IndexValue              *DiskPath                  `json:"index,omitempty" validate:"omitempty"`
	RaidValue               *DvrRaidLevel              `json:"raid,omitempty" validate:"omitempty"`
	StatsValue              *DvrStorageConfigStatsImpl `json:"stats,omitempty" validate:"omitempty"`
	StorageLimitValue       *Bytes                     `json:"storage_limit,omitempty" validate:"omitempty"`
	NameValue               DvrName                    `json:"name" validate:"required" openmetrics_label:"dvr_name"`
	RootValue               DvrURL                     `json:"root" validate:"required"`
	DisksValue              []*RaidDiskConfigImpl      `json:"disks,omitempty" validate:"omitempty"`
}

// Required: from, depth, ranges
type DvrInfoImpl struct {
	BytesValue    *Bytes          `json:"bytes,omitempty" validate:"omitempty"`
	DiskSizeValue *Bytes          `json:"disk_size,omitempty" validate:"omitempty"`
	DurationValue *Seconds        `json:"duration,omitempty" validate:"omitempty"`
	RangesValue   []*DvrRangeImpl `json:"ranges" validate:"required"`
	DepthValue    Seconds         `json:"depth" validate:"required"`
	FromValue     Utc             `json:"from" validate:"required,min=1e+09,max=1e+10"`
}

type DvrRangeImpl struct {
	ClosedAtValue *UtcMs   `json:"closed_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	DurationValue *Seconds `json:"duration,omitempty" validate:"omitempty"`
	FromValue     *Utc     `json:"from,omitempty" validate:"omitempty,min=1e+09,max=1e+10"`
	OpenedAtValue *UtcMs   `json:"opened_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
}

// Required: name, root
type DvrStorageConfigImpl struct {
	ActiveValue *int                       `json:"active,omitempty" validate:"omitempty"`
	IndexValue  *DiskPath                  `json:"index,omitempty" validate:"omitempty"`
	RaidValue   *DvrRaidLevel              `json:"raid,omitempty" validate:"omitempty"`
	StatsValue  *DvrStorageConfigStatsImpl `json:"stats,omitempty" validate:"omitempty"`
	NameValue   DvrName                    `json:"name" validate:"required" openmetrics_label:"dvr_name"`
	RootValue   DvrURL                     `json:"root" validate:"required"`
	DisksValue  []*RaidDiskConfigImpl      `json:"disks,omitempty" validate:"omitempty"`
}

// The runtime statistics about DVR.
type DvrStorageConfigStatsImpl struct {
	BlobsCountValue   *int                  `json:"blobs_count,omitempty" validate:"omitempty" openmetrics_metric:"storage_blobs_count"`
	BlobsCountDbValue *int                  `json:"blobs_count_db,omitempty" validate:"omitempty" openmetrics_metric:"storage_blobs_count_db"`
	ErrorsValue       *DvrStorageErrorsImpl `json:"errors,omitempty" validate:"omitempty"`
	SizeValue         *Bytes                `json:"size,omitempty" validate:"omitempty" openmetrics_metric:"storage_size"`
	UsageValue        *Percent              `json:"usage,omitempty" validate:"omitempty,min=0,max=100" openmetrics_metric:"storage_usage"`
	UsedValue         *Bytes                `json:"used,omitempty" validate:"omitempty" openmetrics_metric:"storage_used"`
	UsedIndexValue    *Bytes                `json:"used_index,omitempty" validate:"omitempty" openmetrics_metric:"storage_used_index"`
}

type DvrStorageErrorsImpl struct {
	CollapsedWriteCountValue *int `json:"collapsed_write_count,omitempty" validate:"omitempty"`
	DeleteErrorsValue        *int `json:"delete_errors,omitempty" validate:"omitempty"`
	DropWriteCountValue      *int `json:"drop_write_count,omitempty" validate:"omitempty"`
	ReadErrorsValue          *int `json:"read_errors,omitempty" validate:"omitempty"`
	WriteErrorsValue         *int `json:"write_errors,omitempty" validate:"omitempty"`
}

type DvrStorageStatsImpl struct {
	ErrorsValue *DvrStorageErrorsImpl `json:"errors,omitempty" validate:"omitempty"`
}

type ErrorImpl struct {
	CodeValue   *string           `json:"code,omitempty" validate:"omitempty"`
	IDValue     *string           `json:"id,omitempty" validate:"omitempty"`
	MetaValue   map[string]string `json:"meta,omitempty" validate:"omitempty"`
	SourceValue *ErrorSourceImpl  `json:"source,omitempty" validate:"omitempty"`
	StatusValue *string           `json:"status,omitempty" validate:"omitempty"`
	TitleValue  *string           `json:"title,omitempty" validate:"omitempty"`
}

type ErrorResponseImpl struct {
	ErrorsValue []*ErrorImpl `json:"errors,omitempty" validate:"omitempty"`
}

// an object containing references to the source of the error
type ErrorSourceImpl struct {
	ParameterValue *string `json:"parameter,omitempty" validate:"omitempty"`
	PointerValue   *string `json:"pointer,omitempty" validate:"omitempty"`
}

type EventImpl struct {
	PayloadValue     *string       `json:"payload,omitempty" validate:"omitempty"`
	QsValue          *string       `json:"qs,omitempty" validate:"omitempty"`
	UtcMsValue       *UtcMs        `json:"utc_ms,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	EventIDValue     *int          `json:"event_id,omitempty" validate:"omitempty"`
	IPValue          *IP           `json:"ip,omitempty" validate:"omitempty"`
	OperationIDValue *string       `json:"operation_id,omitempty" validate:"omitempty"`
	DurationValue    *Microseconds `json:"duration,omitempty" validate:"omitempty"`
	OriginatorValue  *string       `json:"originator,omitempty" validate:"omitempty"`
	CreatedAtValue   *DateTime     `json:"created_at,omitempty" validate:"omitempty"`
	PathValue        *string       `json:"path,omitempty" validate:"omitempty"`
	RequestIDValue   *string       `json:"request_id,omitempty" validate:"omitempty"`
	ServerValue      *string       `json:"server,omitempty" validate:"omitempty"`
	StatusValue      *int          `json:"status,omitempty" validate:"omitempty"`
	TraceIDValue     *UUID         `json:"trace_id,omitempty" validate:"omitempty"`
	UserAgentValue   *string       `json:"user_agent,omitempty" validate:"omitempty"`
	EventValue       string        `json:"event" validate:"required"`
}

type EventDefaultImpl struct {
	EventIDValue *int    `json:"event_id,omitempty" validate:"omitempty"`
	ServerValue  *string `json:"server,omitempty" validate:"omitempty"`
	TraceIDValue *UUID   `json:"trace_id,omitempty" validate:"omitempty"`
	UtcMsValue   *UtcMs  `json:"utc_ms,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
}

// Required: name, url
type EventSinkConfigImpl struct {
	ExtraValue         map[string]string     `json:"extra,omitempty" validate:"omitempty"`
	LevelValue         *Loglevel             `json:"level,omitempty" validate:"omitempty"`
	MaxDepthValue      *int                  `json:"max_depth,omitempty" validate:"omitempty"`
	MaxSizeValue       *Bytes                `json:"max_size,omitempty" validate:"omitempty"`
	ResendLimitValue   *int                  `json:"resend_limit,omitempty" validate:"omitempty"`
	ResendTimeoutValue *int                  `json:"resend_timeout,omitempty" validate:"omitempty"`
	ThrottleDelayValue *Seconds              `json:"throttle_delay,omitempty" validate:"omitempty"`
	NameValue          EventSinkName         `json:"name" validate:"required"`
	URLValue           string                `json:"url" validate:"required"`
	ExceptValue        []map[string][]string `json:"except,omitempty" validate:"omitempty"`
	OnlyValue          []map[string][]string `json:"only,omitempty" validate:"omitempty"`
}

type EventsListImpl struct {
	TimingValue         any          `json:"timing,omitempty" validate:"omitempty"`
	EstimatedCountValue *int         `json:"estimated_count,omitempty" validate:"omitempty"`
	NextValue           *string      `json:"next,omitempty" validate:"omitempty"`
	PrevValue           *string      `json:"prev,omitempty" validate:"omitempty"`
	EventsValue         []*EventImpl `json:"events,omitempty" validate:"omitempty"`
}

type FileProcessorConfigImpl struct {
	PathValue *DiskPath `json:"path,omitempty" validate:"omitempty"`
}

// Update camera firmware
// Required: image
type FirmwareUpdateImpl struct {
	ImageValue any                  `json:"image" validate:"required"`
	ProtoValue *FirmwareUpdateProto `json:"proto,omitempty" validate:"omitempty,oneof=iris isapi xm sputnik"`
}

type ForwardPortsConfigImpl struct {
	HandlerValue *string `json:"handler,omitempty" validate:"omitempty"`
	OptionsValue any     `json:"options,omitempty" validate:"omitempty"`
}

type GenrefStatusImpl struct {
	ExternalValue     *bool   `json:"external,omitempty" validate:"omitempty"`
	PortValue         *int    `json:"port,omitempty" validate:"omitempty"`
	VstdValue         *string `json:"vstd,omitempty" validate:"omitempty,oneof=pal 625i50 ntsc 525i29.97 525i29 720p23.98 720p23 720p24 720p25 720p29.97 720p29 720p30 720p50 720p59.94 720p59 720p60 1080p23.98 1080p23 1080p24 1080p25 1080p29.97 1080p29 1080p30 1080psf23.98 1080psf23 1080psf24 1080psf25 1080psf29.97 1080psf29 1080psf30 1080i50 1080i59.94 1080i60 1080p50 1080p50b 1080p59.94 1080p59 1080p59.94b 1080p59b 1080p60 1080p60b 2160p50 2160p50b 2160p59.94 2160p59 2160p59.94b 2160p59b 2160p60 2160p60b 2160p23 2160p24 2160p25 2160p29 2160p30"`
	VstdDetectedValue *string `json:"vstd_detected,omitempty" validate:"omitempty,oneof=pal 625i50 ntsc 525i29.97 525i29 720p23.98 720p23 720p24 720p25 720p29.97 720p29 720p30 720p50 720p59.94 720p59 720p60 1080p23.98 1080p23 1080p24 1080p25 1080p29.97 1080p29 1080p30 1080psf23.98 1080psf23 1080psf24 1080psf25 1080psf29.97 1080psf29 1080psf30 1080i50 1080i59.94 1080i60 1080p50 1080p50b 1080p59.94 1080p59 1080p59.94b 1080p59b 1080p60 1080p60b 2160p50 2160p50b 2160p59.94 2160p59 2160p59.94b 2160p59b 2160p60 2160p60b 2160p23 2160p24 2160p25 2160p29 2160p30"`
}

// Here are counters for h264/h265 decoder.
type H26xDecoderCountersImpl struct {
	DiscardedBrokenNalCountValue        *int `json:"discarded_broken_nal_count,omitempty" validate:"omitempty"`
	DiscardedFuCountValue               *int `json:"discarded_fu_count,omitempty" validate:"omitempty"`
	DiscardedNalCountValue              *int `json:"discarded_nal_count,omitempty" validate:"omitempty"`
	DiscardedNotAllowedNalCountValue    *int `json:"discarded_not_allowed_nal_count,omitempty" validate:"omitempty"`
	DiscardedSeiCountValue              *int `json:"discarded_sei_count,omitempty" validate:"omitempty"`
	FuEndThenMiddleWorkaroundCountValue *int `json:"fu_end_then_middle_workaround_count,omitempty" validate:"omitempty"`
	FuHasBothStartEndBitsCountValue     *int `json:"fu_has_both_start_end_bits_count,omitempty" validate:"omitempty"`
	FuPatternIsBrokenCountValue         *int `json:"fu_pattern_is_broken_count,omitempty" validate:"omitempty"`
	IncompleteNalCountValue             *int `json:"incomplete_nal_count,omitempty" validate:"omitempty"`
	InvalidSeiPayloadCountValue         *int `json:"invalid_sei_payload_count,omitempty" validate:"omitempty"`
	InvalidSeiSizeCountValue            *int `json:"invalid_sei_size_count,omitempty" validate:"omitempty"`
	InvalidSeiTypeCountValue            *int `json:"invalid_sei_type_count,omitempty" validate:"omitempty"`
	NalAggregationCountValue            *int `json:"nal_aggregation_count,omitempty" validate:"omitempty"`
	NalAudCountValue                    *int `json:"nal_aud_count,omitempty" validate:"omitempty"`
	NalCountValue                       *int `json:"nal_count,omitempty" validate:"omitempty"`
	NalFillerCountValue                 *int `json:"nal_filler_count,omitempty" validate:"omitempty"`
	NalFuCountValue                     *int `json:"nal_fu_count,omitempty" validate:"omitempty"`
	NalIdrCountValue                    *int `json:"nal_idr_count,omitempty" validate:"omitempty"`
	NalOtherCountValue                  *int `json:"nal_other_count,omitempty" validate:"omitempty"`
	NalPpsCountValue                    *int `json:"nal_pps_count,omitempty" validate:"omitempty"`
	NalSeiCountValue                    *int `json:"nal_sei_count,omitempty" validate:"omitempty"`
	NalSingleCountValue                 *int `json:"nal_single_count,omitempty" validate:"omitempty"`
	NalSliceCountValue                  *int `json:"nal_slice_count,omitempty" validate:"omitempty"`
	NalSpsCountValue                    *int `json:"nal_sps_count,omitempty" validate:"omitempty"`
	NalStapACountValue                  *int `json:"nal_stap_a_count,omitempty" validate:"omitempty"`
	NalVpsCountValue                    *int `json:"nal_vps_count,omitempty" validate:"omitempty"`
}

// Required: prefix, url
type HTTPProxyConfigImpl struct {
	MainpageValue *bool               `json:"mainpage,omitempty" validate:"omitempty"`
	PrefixValue   MediaName           `json:"prefix" validate:"required"`
	StatsValue    *HTTPProxyStatsImpl `json:"stats,omitempty" validate:"omitempty"`
	URLValue      URL                 `json:"url" validate:"required"`
}

type HTTPProxyStatsImpl struct {
	HTTP100Value              *int `json:"http_100,omitempty" validate:"omitempty" openmetrics_metric:"http_proxy_100"`
	HTTP200Value              *int `json:"http_200,omitempty" validate:"omitempty" openmetrics_metric:"http_proxy_200"`
	HTTP300Value              *int `json:"http_300,omitempty" validate:"omitempty" openmetrics_metric:"http_proxy_300"`
	HTTP400Value              *int `json:"http_400,omitempty" validate:"omitempty" openmetrics_metric:"http_proxy_400"`
	HTTP500Value              *int `json:"http_500,omitempty" validate:"omitempty" openmetrics_metric:"http_proxy_500"`
	ProtocolUpgradesValue     *int `json:"protocol_upgrades,omitempty" validate:"omitempty" openmetrics_metric:"http_proxy_protocol_upgrades"`
	ProxyErrorValue           *int `json:"proxy_error,omitempty" validate:"omitempty" openmetrics_metric:"http_proxy_error"`
	ProxyErrorConnectionValue *int `json:"proxy_error_connection,omitempty" validate:"omitempty" openmetrics_metric:"http_proxy_error_connection"`
	RequestsValue             *int `json:"requests,omitempty" validate:"omitempty" openmetrics_metric:"http_proxy_requests"`
	Time1000MsValue           *int `json:"time_1000ms,omitempty" validate:"omitempty" openmetrics_metric:"http_proxy_time_1000ms"`
	Time100MsValue            *int `json:"time_100ms,omitempty" validate:"omitempty" openmetrics_metric:"http_proxy_time_100ms"`
	Time5000MsValue           *int `json:"time_5000ms,omitempty" validate:"omitempty" openmetrics_metric:"http_proxy_time_5000ms"`
	Time500MsValue            *int `json:"time_500ms,omitempty" validate:"omitempty" openmetrics_metric:"http_proxy_time_500ms"`
	TimeLongmsValue           *int `json:"time_longms,omitempty" validate:"omitempty" openmetrics_metric:"http_proxy_time_longms"`
}

// Agent counters
type InputAgentCountersImpl struct {
	ErrorsBufferOverrunValue  *int `json:"errors_buffer_overrun,omitempty" validate:"omitempty"`
	ErrorsConnFailedValue     *int `json:"errors_conn_failed,omitempty" validate:"omitempty"`
	ErrorsInvalidRequestValue *int `json:"errors_invalid_request,omitempty" validate:"omitempty"`
	ErrorsOutOfMemoryValue    *int `json:"errors_out_of_memory,omitempty" validate:"omitempty"`
	ErrorsUnknownValue        *int `json:"errors_unknown,omitempty" validate:"omitempty"`
}

// Here are grouped different counters for sessions: generic and errors
type InputCountersImpl struct {
	ErrorsTSStuckRestartsValue  *int                             `json:"errors_ts_stuck_restarts,omitempty" validate:"omitempty"`
	FramesValue                 *int                             `json:"frames,omitempty" validate:"omitempty"`
	AgentValue                  *InputAgentCountersImpl          `json:"agent,omitempty" validate:"omitempty"`
	BytesValue                  *Bytes                           `json:"bytes,omitempty" validate:"omitempty" openmetrics_metric:"stream_input_bytes"`
	BytesDvrValue               *Bytes                           `json:"bytes_dvr,omitempty" validate:"omitempty"`
	InputSwitchesValue          *int                             `json:"input_switches,omitempty" validate:"omitempty"`
	ErrorsValue                 *int                             `json:"errors,omitempty" validate:"omitempty"`
	Errors403Value              *int                             `json:"errors_403,omitempty" validate:"omitempty"`
	Errors404Value              *int                             `json:"errors_404,omitempty" validate:"omitempty"`
	Errors500Value              *int                             `json:"errors_500,omitempty" validate:"omitempty"`
	ErrorsBrokenPayloadValue    *int                             `json:"errors_broken_payload,omitempty" validate:"omitempty"`
	ErrorsCrashedValue          *int                             `json:"errors_crashed,omitempty" validate:"omitempty"`
	ErrorsDecoderResetValue     *int                             `json:"errors_decoder_reset,omitempty" validate:"omitempty"`
	ErrorsDesyncValue           *int                             `json:"errors_desync,omitempty" validate:"omitempty"`
	ErrorsDroppedFramesValue    *int                             `json:"errors_dropped_frames,omitempty" validate:"omitempty"`
	ErrorsLostPacketsValue      *int                             `json:"errors_lost_packets,omitempty" validate:"omitempty"`
	ErrorsTSPatValue            *int                             `json:"errors_ts_pat,omitempty" validate:"omitempty"`
	ErrorsTSServiceLostValue    *int                             `json:"errors_ts_service_lost,omitempty" validate:"omitempty"`
	AdSplicesInsertedValue      *int                             `json:"ad_splices_inserted,omitempty" validate:"omitempty"`
	AdSplicesIngestedValue      *int                             `json:"ad_splices_ingested,omitempty" validate:"omitempty"`
	ErrorRateValue              *int                             `json:"error_rate,omitempty" validate:"omitempty"`
	InvalidSecondaryInputsValue *int                             `json:"invalid_secondary_inputs,omitempty" validate:"omitempty"`
	MediaInfoChangesValue       *int                             `json:"media_info_changes,omitempty" validate:"omitempty"`
	MotionDetectorValue         *InputMotionDetectorCountersImpl `json:"motion_detector,omitempty" validate:"omitempty"`
	NumSecNoDataValue           *Seconds                         `json:"num_sec_no_data,omitempty" validate:"omitempty"`
	NumSecOnPrimaryInputValue   *Seconds                         `json:"num_sec_on_primary_input,omitempty" validate:"omitempty"`
	NumSecOnSecondaryInputValue *Seconds                         `json:"num_sec_on_secondary_input,omitempty" validate:"omitempty"`
	ValidSecondaryInputsValue   *int                             `json:"valid_secondary_inputs,omitempty" validate:"omitempty"`
	ReorderCountValue           *int                             `json:"reorder_count,omitempty" validate:"omitempty"`
	ResyncCountDriftValue       *int                             `json:"resync_count_drift,omitempty" validate:"omitempty"`
	ResyncCountJumpValue        *int                             `json:"resync_count_jump,omitempty" validate:"omitempty"`
	ResyncCountNormalValue      *int                             `json:"resync_count_normal,omitempty" validate:"omitempty"`
	RetriesValue                *int                             `json:"retries,omitempty" validate:"omitempty"`
	SrtValue                    *InputSrtCountersImpl            `json:"srt,omitempty" validate:"omitempty"`
	SdiValue                    *InputSdiCountersImpl            `json:"sdi,omitempty" validate:"omitempty"`
	RTPChannelsValue            []*InputRTPCountersImpl          `json:"rtp_channels,omitempty" validate:"omitempty"`
	PidsValue                   []*InputPidCountersImpl          `json:"pids,omitempty" validate:"omitempty"`
}

// Specific counters to get insights on current state of getting events from cameras.
// Designed to be used by analyzers, monitoring and alerting tools
type InputMotionDetectorCountersImpl struct {
	EpisodesCountValue                  *int `json:"episodes_count,omitempty" validate:"omitempty"`
	ErrorsBrokenPayloadValue            *int `json:"errors_broken_payload,omitempty" validate:"omitempty"`
	ErrorsIncorrectTimeValuesCountValue *int `json:"errors_incorrect_time_values_count,omitempty" validate:"omitempty"`
	ErrorsNoAgentConnectedValue         *int `json:"errors_no_agent_connected,omitempty" validate:"omitempty"`
	ErrorsNoServiceCountValue           *int `json:"errors_no_service_count,omitempty" validate:"omitempty"`
	ErrorsNotAuthorizedCountValue       *int `json:"errors_not_authorized_count,omitempty" validate:"omitempty"`
	ErrorsURLUnreachableCountValue      *int `json:"errors_url_unreachable_count,omitempty" validate:"omitempty"`
	MotionDetectedCountValue            *int `json:"motion_detected_count,omitempty" validate:"omitempty"`
}

// Required: pid
type InputPidCountersImpl struct {
	ErrorsTSScrambledValue      *int `json:"errors_ts_scrambled,omitempty" validate:"omitempty"`
	PacketsValue                *int `json:"packets,omitempty" validate:"omitempty"`
	CorrectedBackwardPtsValue   *int `json:"corrected_backward_pts,omitempty" validate:"omitempty"`
	CrashedValue                *int `json:"crashed,omitempty" validate:"omitempty"`
	BrokenPesCountValue         *int `json:"broken_pes_count,omitempty" validate:"omitempty"`
	DiscardedBufferSumValue     *int `json:"discarded_buffer_sum,omitempty" validate:"omitempty"`
	DtsGoesBackwardsValue       *int `json:"dts_goes_backwards,omitempty" validate:"omitempty"`
	DtsJumpForwardValue         *int `json:"dts_jump_forward,omitempty" validate:"omitempty"`
	EmptyPacketsValue           *int `json:"empty_packets,omitempty" validate:"omitempty"`
	ErrorsAdaptationBrokenValue *int `json:"errors_adaptation_broken,omitempty" validate:"omitempty"`
	ErrorsPidLostValue          *int `json:"errors_pid_lost,omitempty" validate:"omitempty"`
	ErrorsTSCcValue             *int `json:"errors_ts_cc,omitempty" validate:"omitempty"`
	BrokenPesSumValue           *int `json:"broken_pes_sum,omitempty" validate:"omitempty"`
	TooLargeDtsJumpValue        *int `json:"too_large_dts_jump,omitempty" validate:"omitempty"`
	DiscardedBufferCountValue   *int `json:"discarded_buffer_count,omitempty" validate:"omitempty"`
	ErrorsTSTeiValue            *int `json:"errors_ts_tei,omitempty" validate:"omitempty"`
	FillersCountValue           *int `json:"fillers_count,omitempty" validate:"omitempty"`
	FillersSumValue             *int `json:"fillers_sum,omitempty" validate:"omitempty"`
	FramesValue                 *int `json:"frames,omitempty" validate:"omitempty"`
	ErrorsTSPmtValue            *int `json:"errors_ts_pmt,omitempty" validate:"omitempty"`
	PaddingPesCountValue        *int `json:"padding_pes_count,omitempty" validate:"omitempty"`
	PaddingPesSumValue          *int `json:"padding_pes_sum,omitempty" validate:"omitempty"`
	PcrResyncValue              *int `json:"pcr_resync,omitempty" validate:"omitempty"`
	ErrorsTSPsiChecksumValue    *int `json:"errors_ts_psi_checksum,omitempty" validate:"omitempty"`
	PnrValue                    *int `json:"pnr,omitempty" validate:"omitempty"`
	RepeatedFramesValue         *int `json:"repeated_frames,omitempty" validate:"omitempty"`
	TimeCorrectionsValue        *int `json:"time_corrections,omitempty" validate:"omitempty"`
	PidValue                    int  `json:"pid" validate:"required"`
}

type InputRTPCountersImpl struct {
	NalAudCountValue                    *int    `json:"nal_aud_count,omitempty" validate:"omitempty"`
	IncompleteNalCountValue             *int    `json:"incomplete_nal_count,omitempty" validate:"omitempty"`
	ContentValue                        *string `json:"content,omitempty" validate:"omitempty"`
	DiscardedBrokenNalCountValue        *int    `json:"discarded_broken_nal_count,omitempty" validate:"omitempty"`
	DiscardedFuCountValue               *int    `json:"discarded_fu_count,omitempty" validate:"omitempty"`
	DiscardedNalCountValue              *int    `json:"discarded_nal_count,omitempty" validate:"omitempty"`
	DiscardedNotAllowedNalCountValue    *int    `json:"discarded_not_allowed_nal_count,omitempty" validate:"omitempty"`
	DiscardedSeiCountValue              *int    `json:"discarded_sei_count,omitempty" validate:"omitempty"`
	ErrorsBrokenPayloadValue            *int    `json:"errors_broken_payload,omitempty" validate:"omitempty"`
	ErrorsDtsStuckValue                 *int    `json:"errors_dts_stuck,omitempty" validate:"omitempty"`
	ErrorsLostPacketsValue              *int    `json:"errors_lost_packets,omitempty" validate:"omitempty"`
	FramesValue                         *int    `json:"frames,omitempty" validate:"omitempty"`
	FuEndThenMiddleWorkaroundCountValue *int    `json:"fu_end_then_middle_workaround_count,omitempty" validate:"omitempty"`
	NalFillerCountValue                 *int    `json:"nal_filler_count,omitempty" validate:"omitempty"`
	FuPatternIsBrokenCountValue         *int    `json:"fu_pattern_is_broken_count,omitempty" validate:"omitempty"`
	NalCountValue                       *int    `json:"nal_count,omitempty" validate:"omitempty"`
	InvalidSeiPayloadCountValue         *int    `json:"invalid_sei_payload_count,omitempty" validate:"omitempty"`
	InvalidSeiSizeCountValue            *int    `json:"invalid_sei_size_count,omitempty" validate:"omitempty"`
	InvalidSeiTypeCountValue            *int    `json:"invalid_sei_type_count,omitempty" validate:"omitempty"`
	MarkerPacketsCountValue             *int    `json:"marker_packets_count,omitempty" validate:"omitempty"`
	NackCountValue                      *int    `json:"nack_count,omitempty" validate:"omitempty"`
	NalAggregationCountValue            *int    `json:"nal_aggregation_count,omitempty" validate:"omitempty"`
	TSStuckValue                        *int    `json:"ts_stuck,omitempty" validate:"omitempty"`
	BytesValue                          *int    `json:"bytes,omitempty" validate:"omitempty"`
	FuHasBothStartEndBitsCountValue     *int    `json:"fu_has_both_start_end_bits_count,omitempty" validate:"omitempty"`
	NalFuCountValue                     *int    `json:"nal_fu_count,omitempty" validate:"omitempty"`
	NalIdrCountValue                    *int    `json:"nal_idr_count,omitempty" validate:"omitempty"`
	NalOtherCountValue                  *int    `json:"nal_other_count,omitempty" validate:"omitempty"`
	NalPpsCountValue                    *int    `json:"nal_pps_count,omitempty" validate:"omitempty"`
	NalSeiCountValue                    *int    `json:"nal_sei_count,omitempty" validate:"omitempty"`
	NalSingleCountValue                 *int    `json:"nal_single_count,omitempty" validate:"omitempty"`
	NalSliceCountValue                  *int    `json:"nal_slice_count,omitempty" validate:"omitempty"`
	NalSpsCountValue                    *int    `json:"nal_sps_count,omitempty" validate:"omitempty"`
	NalStapACountValue                  *int    `json:"nal_stap_a_count,omitempty" validate:"omitempty"`
	NalVpsCountValue                    *int    `json:"nal_vps_count,omitempty" validate:"omitempty"`
	NoMarkerModeFlagValue               *bool   `json:"no_marker_mode_flag,omitempty" validate:"omitempty"`
	PtRejectCountValue                  *int    `json:"pt_reject_count,omitempty" validate:"omitempty"`
	PtRejectSumValue                    *int    `json:"pt_reject_sum,omitempty" validate:"omitempty"`
	RtcpPacketsValue                    *int    `json:"rtcp_packets,omitempty" validate:"omitempty"`
	RTPPacketsValue                     *int    `json:"rtp_packets,omitempty" validate:"omitempty"`
	SenderClockDeviationValue           *int    `json:"sender_clock_deviation,omitempty" validate:"omitempty"`
	SrTSStuckValue                      *int    `json:"sr_ts_stuck,omitempty" validate:"omitempty"`
	TSGoesBackwardsValue                *int    `json:"ts_goes_backwards,omitempty" validate:"omitempty"`
	TSJumpForwardValue                  *int    `json:"ts_jump_forward,omitempty" validate:"omitempty"`
	ChannelIDValue                      int     `json:"channel_id" validate:"required"`
}

// SDI,HDMI and other raw input counters
type InputSdiCountersImpl struct {
	AvgRecvDurationValue       *int `json:"avg_recv_duration,omitempty" validate:"omitempty"`
	CompensatedFramesValue     *int `json:"compensated_frames,omitempty" validate:"omitempty"`
	ErrorLostAudioValue        *int `json:"error_lost_audio,omitempty" validate:"omitempty"`
	ErrorsCpuStallValue        *int `json:"errors_cpu_stall,omitempty" validate:"omitempty"`
	ErrorsDuplicateValue       *int `json:"errors_duplicate,omitempty" validate:"omitempty"`
	ErrorsNoSignalValue        *int `json:"errors_no_signal,omitempty" validate:"omitempty"`
	ErrorsTSDuplicateValue     *int `json:"errors_ts_duplicate,omitempty" validate:"omitempty"`
	PeakDurationDeviationValue *int `json:"peak_duration_deviation,omitempty" validate:"omitempty"`
}

// SRT specific counters
type InputSrtCountersImpl struct {
	ErrorDroppedPacketsValue  *int `json:"error_dropped_packets,omitempty" validate:"omitempty"`
	ErrorLostPacketsValue     *int `json:"error_lost_packets,omitempty" validate:"omitempty"`
	LatencyValue              *int `json:"latency,omitempty" validate:"omitempty"`
	PacketsValue              *int `json:"packets,omitempty" validate:"omitempty"`
	RetransmittedPacketsValue *int `json:"retransmitted_packets,omitempty" validate:"omitempty"`
	RttValue                  *int `json:"rtt,omitempty" validate:"omitempty"`
}

type InputStatsImpl struct {
	InvalidSecondaryInputsValue *int                             `json:"invalid_secondary_inputs,omitempty" validate:"omitempty"`
	Errors403Value              *int                             `json:"errors_403,omitempty" validate:"omitempty"`
	AdSplicesInsertedValue      *int                             `json:"ad_splices_inserted,omitempty" validate:"omitempty"`
	AgentValue                  *InputAgentCountersImpl          `json:"agent,omitempty" validate:"omitempty"`
	BytesValue                  *Bytes                           `json:"bytes,omitempty" validate:"omitempty" openmetrics_metric:"stream_input_bytes"`
	BytesDvrValue               *Bytes                           `json:"bytes_dvr,omitempty" validate:"omitempty"`
	DivergentInputsValue        *bool                            `json:"divergent_inputs,omitempty" validate:"omitempty"`
	DvrInfoValue                *DvrInfoImpl                     `json:"dvr_info,omitempty" validate:"omitempty"`
	ErrorRateValue              *int                             `json:"error_rate,omitempty" validate:"omitempty"`
	ActiveValue                 *bool                            `json:"active,omitempty" validate:"omitempty"`
	InputSwitchesValue          *int                             `json:"input_switches,omitempty" validate:"omitempty"`
	Errors404Value              *int                             `json:"errors_404,omitempty" validate:"omitempty"`
	Errors500Value              *int                             `json:"errors_500,omitempty" validate:"omitempty"`
	ErrorsBrokenPayloadValue    *int                             `json:"errors_broken_payload,omitempty" validate:"omitempty"`
	ErrorsCrashedValue          *int                             `json:"errors_crashed,omitempty" validate:"omitempty"`
	ErrorsDecoderResetValue     *int                             `json:"errors_decoder_reset,omitempty" validate:"omitempty"`
	ErrorsDesyncValue           *int                             `json:"errors_desync,omitempty" validate:"omitempty"`
	ErrorsDroppedFramesValue    *int                             `json:"errors_dropped_frames,omitempty" validate:"omitempty"`
	ErrorsLostPacketsValue      *int                             `json:"errors_lost_packets,omitempty" validate:"omitempty"`
	ErrorsTSPatValue            *int                             `json:"errors_ts_pat,omitempty" validate:"omitempty"`
	ErrorsTSServiceLostValue    *int                             `json:"errors_ts_service_lost,omitempty" validate:"omitempty"`
	ErrorsTSStuckRestartsValue  *int                             `json:"errors_ts_stuck_restarts,omitempty" validate:"omitempty"`
	AdSplicesIngestedValue      *int                             `json:"ad_splices_ingested,omitempty" validate:"omitempty"`
	FramesValue                 *int                             `json:"frames,omitempty" validate:"omitempty"`
	ErrorsValue                 *int                             `json:"errors,omitempty" validate:"omitempty"`
	IPValue                     *string                          `json:"ip,omitempty" validate:"omitempty"`
	MediaInfoValue              *MediaInfoImpl                   `json:"media_info,omitempty" validate:"omitempty"`
	MediaInfoChangesValue       *int                             `json:"media_info_changes,omitempty" validate:"omitempty"`
	MotionDetectorValue         *InputMotionDetectorCountersImpl `json:"motion_detector,omitempty" validate:"omitempty"`
	NumSecNoDataValue           *Seconds                         `json:"num_sec_no_data,omitempty" validate:"omitempty"`
	NumSecOnPrimaryInputValue   *Seconds                         `json:"num_sec_on_primary_input,omitempty" validate:"omitempty"`
	NumSecOnSecondaryInputValue *Seconds                         `json:"num_sec_on_secondary_input,omitempty" validate:"omitempty"`
	OpenedAtValue               *UtcMs                           `json:"opened_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	ValidSecondaryInputsValue   *int                             `json:"valid_secondary_inputs,omitempty" validate:"omitempty"`
	ProtoValue                  *Protocol                        `json:"proto,omitempty" validate:"omitempty"`
	ReorderCountValue           *int                             `json:"reorder_count,omitempty" validate:"omitempty"`
	ResyncCountDriftValue       *int                             `json:"resync_count_drift,omitempty" validate:"omitempty"`
	ResyncCountJumpValue        *int                             `json:"resync_count_jump,omitempty" validate:"omitempty"`
	ResyncCountNormalValue      *int                             `json:"resync_count_normal,omitempty" validate:"omitempty"`
	RetriesValue                *int                             `json:"retries,omitempty" validate:"omitempty"`
	UserAgentValue              *string                          `json:"user_agent,omitempty" validate:"omitempty"`
	SdiValue                    *InputSdiCountersImpl            `json:"sdi,omitempty" validate:"omitempty"`
	SrtValue                    *InputSrtCountersImpl            `json:"srt,omitempty" validate:"omitempty"`
	TSDelayValue                *Ticks                           `json:"ts_delay,omitempty" validate:"omitempty"`
	URLValue                    *URL                             `json:"url,omitempty" validate:"omitempty"`
	TSDelayPerTracksValue       []Ticks                          `json:"ts_delay_per_tracks,omitempty" validate:"omitempty"`
	RTPChannelsValue            []*InputRTPCountersImpl          `json:"rtp_channels,omitempty" validate:"omitempty"`
	PidsValue                   []*InputPidCountersImpl          `json:"pids,omitempty" validate:"omitempty"`
}

type IptvConfigImpl struct {
	DatabaseValue *string `json:"database,omitempty" validate:"omitempty"`
}

type LetsencryptRequestImpl struct {
	DomainsValue []string `json:"domains,omitempty" validate:"omitempty"`
}

// Required: port
type ListenConfigImpl struct {
	AddressValue *string     `json:"address,omitempty" validate:"omitempty"`
	PortValue    NetworkPort `json:"port" validate:"required"`
}

type ListenHTTPConfigImpl struct {
	AddressValue *string     `json:"address,omitempty" validate:"omitempty"`
	PortValue    NetworkPort `json:"port" validate:"required"`
}

type ListenHTTPConfigParamsImpl struct {
}

type ListenersImpl struct {
	HTTPValue []*ListenHTTPConfigImpl `json:"http,omitempty" validate:"omitempty"`
}

type LoginInfoAdditionalImpl struct {
	AccessTokenValue  *string `json:"access_token,omitempty" validate:"omitempty"`
	RefreshTokenValue *string `json:"refresh_token,omitempty" validate:"omitempty"`
}

type LoginInfoBaseImpl struct {
	AccessTokenValue  *string `json:"access_token,omitempty" validate:"omitempty"`
	RefreshTokenValue *string `json:"refresh_token,omitempty" validate:"omitempty"`
}

// mail settings
// Required: sending_method
type MailBaseImpl struct {
	SenderValue        *MailBaseSenderImpl `json:"sender,omitempty" validate:"omitempty"`
	SendingMethodValue string              `json:"sending_method" validate:"required"`
}

// Information about the sender
type MailBaseSenderImpl struct {
	EmailValue *string `json:"email,omitempty" validate:"omitempty"`
	TitleValue *string `json:"title,omitempty" validate:"omitempty"`
}

type MailSendgridImpl struct {
	APIKeyValue        *string             `json:"api_key,omitempty" validate:"omitempty"`
	SenderValue        *MailBaseSenderImpl `json:"sender,omitempty" validate:"omitempty"`
	SendingMethodValue string              `json:"sending_method" validate:"required"`
}

type MailSmtpImpl struct {
	HostValue          *string             `json:"host,omitempty" validate:"omitempty"`
	LoginValue         *string             `json:"login,omitempty" validate:"omitempty"`
	PasswordValue      *string             `json:"password,omitempty" validate:"omitempty"`
	PortValue          *int                `json:"port,omitempty" validate:"omitempty"`
	SecurityValue      *MailSmtpSecurity   `json:"security,omitempty" validate:"omitempty,oneof=none tls starttls"`
	SenderValue        *MailBaseSenderImpl `json:"sender,omitempty" validate:"omitempty"`
	SendingMethodValue string              `json:"sending_method" validate:"required"`
}

type MailSpecImpl struct {
	APIKeyValue        *string             `json:"api_key,omitempty" validate:"omitempty"`
	HostValue          *string             `json:"host,omitempty" validate:"omitempty"`
	LoginValue         *string             `json:"login,omitempty" validate:"omitempty"`
	PasswordValue      *string             `json:"password,omitempty" validate:"omitempty"`
	PortValue          *int                `json:"port,omitempty" validate:"omitempty"`
	SecurityValue      *MailSmtpSecurity   `json:"security,omitempty" validate:"omitempty,oneof=none tls starttls"`
	SenderValue        *MailBaseSenderImpl `json:"sender,omitempty" validate:"omitempty"`
	SendingMethodValue string              `json:"sending_method" validate:"required"`
}

// Required: latitude, longitude
type MapSpecImpl struct {
	LatitudeValue  float64 `json:"latitude" validate:"required"`
	LongitudeValue float64 `json:"longitude" validate:"required"`
}

type MediaInfoImpl struct {
	DurationValue  *Ticks                     `json:"duration,omitempty" validate:"omitempty"`
	FlowTypeValue  *MediaInfoSpecificFlowType `json:"flow_type,omitempty" validate:"omitempty,oneof=file stream dvr_file dvr_stream"`
	ProgramIDValue *int                       `json:"program_id,omitempty" validate:"omitempty"`
	ProviderValue  *string                    `json:"provider,omitempty" validate:"omitempty"`
	StreamIDValue  *int                       `json:"stream_id,omitempty" validate:"omitempty"`
	TitleValue     *string                    `json:"title,omitempty" validate:"omitempty"`
	TracksValue    []*TrackInfoImpl           `json:"tracks,omitempty" validate:"omitempty"`
}

type MediaInfoCommonImpl struct {
	ProgramIDValue *int    `json:"program_id,omitempty" validate:"omitempty"`
	ProviderValue  *string `json:"provider,omitempty" validate:"omitempty"`
	StreamIDValue  *int    `json:"stream_id,omitempty" validate:"omitempty"`
	TitleValue     *string `json:"title,omitempty" validate:"omitempty"`
}

type MediaInfoSpecificImpl struct {
	DurationValue *Ticks                     `json:"duration,omitempty" validate:"omitempty"`
	FlowTypeValue *MediaInfoSpecificFlowType `json:"flow_type,omitempty" validate:"omitempty,oneof=file stream dvr_file dvr_stream"`
	TracksValue   []*TrackInfoImpl           `json:"tracks,omitempty" validate:"omitempty"`
}

type MultiplexerStatsImpl struct {
	LateTicksValue          *int                           `json:"late_ticks,omitempty" validate:"omitempty"`
	SysPacketsValue         *int                           `json:"sys_packets,omitempty" validate:"omitempty"`
	EpgProgramsValue        *int                           `json:"epg_programs,omitempty" validate:"omitempty"`
	PayloadValue            *Bytes                         `json:"payload,omitempty" validate:"omitempty" openmetrics_metric:"multiplexer_payload"`
	ErrorsXmltvParseValue   *int                           `json:"errors_xmltv_parse,omitempty" validate:"omitempty"`
	ExceededBytesValue      *Bytes                         `json:"exceeded_bytes,omitempty" validate:"omitempty"`
	ExceededFramesValue     *int                           `json:"exceeded_frames,omitempty" validate:"omitempty"`
	FillersValue            *int                           `json:"fillers,omitempty" validate:"omitempty" openmetrics_metric:"multiplexer_fillers"`
	EncodedValue            *Bytes                         `json:"encoded,omitempty" validate:"omitempty" openmetrics_metric:"multiplexer_encoded"`
	TSOverflowValue         *bool                          `json:"ts_overflow,omitempty" validate:"omitempty"`
	ErrorsXmltvFileValue    *int                           `json:"errors_xmltv_file,omitempty" validate:"omitempty"`
	TrimmedFramesValue      *int                           `json:"trimmed_frames,omitempty" validate:"omitempty" openmetrics_metric:"multiplexer_trimmed_frames"`
	StuffingValue           *int                           `json:"stuffing,omitempty" validate:"omitempty" openmetrics_metric:"multiplexer_stuffing"`
	BitrateValue            *Speed                         `json:"bitrate,omitempty" validate:"omitempty"`
	SysPayloadValue         *Bytes                         `json:"sys_payload,omitempty" validate:"omitempty"`
	SysStuffingPacketsValue *int                           `json:"sys_stuffing_packets,omitempty" validate:"omitempty"`
	TrimmedBytesValue       *Bytes                         `json:"trimmed_bytes,omitempty" validate:"omitempty" openmetrics_metric:"multiplexer_trimmed_bytes"`
	ProgramsValue           []*TransponderProgramStatsImpl `json:"programs,omitempty" validate:"omitempty"`
	PidsValue               []*PushPidCountersImpl         `json:"pids,omitempty" validate:"omitempty"`
}

type OnOffImpl struct {
	ModeValue *OnOffMode `json:"mode,omitempty" validate:"omitempty,oneof=on off"`
}

type OnOffAutoImpl struct {
	ModeValue *OnOffAutoMode `json:"mode,omitempty" validate:"omitempty,oneof=on off auto"`
}

// Required: id, title
type OrganizationBaseImpl struct {
	TitleValue string `json:"title" validate:"required"`
	IDValue    int    `json:"id" validate:"required"`
}

type OrganizationPermissionsImpl struct {
	CanEditPersonsListsValue *bool `json:"can_edit_persons_lists,omitempty" validate:"omitempty"`
	CanEditStreamsValue      *bool `json:"can_edit_streams,omitempty" validate:"omitempty"`
	CanEditUsersValue        *bool `json:"can_edit_users,omitempty" validate:"omitempty"`
	CanViewPersonsListsValue *bool `json:"can_view_persons_lists,omitempty" validate:"omitempty"`
	CanViewStatsValue        *bool `json:"can_view_stats,omitempty" validate:"omitempty"`
	CanViewStreamsValue      *bool `json:"can_view_streams,omitempty" validate:"omitempty"`
	IsMemberValue            *bool `json:"is_member,omitempty" validate:"omitempty"`
}

type OrganizationPresetImpl struct {
	PresetIDValue *int `json:"preset_id,omitempty" validate:"omitempty"`
}

type OrganizationStreamImpl struct {
	IDValue    *int    `json:"id,omitempty" validate:"omitempty"`
	TitleValue *string `json:"title,omitempty" validate:"omitempty"`
}

type OutputMpegtsPidsImpl struct {
	DefaultValue *string               `json:"default,omitempty" validate:"omitempty"`
	PcrValue     *int                  `json:"pcr,omitempty" validate:"omitempty"`
	PmtValue     *int                  `json:"pmt,omitempty" validate:"omitempty"`
	SdtValue     *int                  `json:"sdt,omitempty" validate:"omitempty"`
	MediaValue   []*TransponderPidImpl `json:"media,omitempty" validate:"omitempty"`
}

type PartitionStatsImpl struct {
	DeviceValue  *DiskDevice `json:"device,omitempty" validate:"omitempty" openmetrics_label:"device"`
	IoUtilValue  *Percent    `json:"io_util,omitempty" validate:"omitempty,min=0,max=100" openmetrics_metric:"device_io_util"`
	PathValue    *DiskPath   `json:"path,omitempty" validate:"omitempty" openmetrics_label:"path"`
	TotalMbValue *Megabytes  `json:"total_mb,omitempty" validate:"omitempty" openmetrics_metric:"partition_total_mb"`
	UsageValue   *Percent    `json:"usage,omitempty" validate:"omitempty,min=0,max=100" openmetrics_metric:"partition_usage"`
}

type PeerConfigImpl struct {
	APIURLValue       *URL           `json:"api_url,omitempty" validate:"omitempty"`
	ChannelLimitValue *int           `json:"channel_limit,omitempty" validate:"omitempty"`
	ClusterKeyValue   *string        `json:"cluster_key,omitempty" validate:"omitempty"`
	HostnameValue     *ServerName    `json:"hostname,omitempty" validate:"omitempty"`
	StatsValue        *PeerStatsImpl `json:"stats,omitempty" validate:"omitempty"`
}

type PeerStatsImpl struct {
	OutputKbitValue           *Speed                         `json:"output_kbit,omitempty" validate:"omitempty" openmetrics_metric:"server_output_bitrate"`
	TotalBandwidthValue       *Speed                         `json:"total_bandwidth,omitempty" validate:"omitempty"`
	ConfigErrorValue          *ConfigErrorStatusImpl         `json:"config_error,omitempty" validate:"omitempty"`
	ConfigExternalStatusValue *ConfigExternalErrorStatusImpl `json:"config_external_status,omitempty" validate:"omitempty"`
	VsaasRunningValue         *bool                          `json:"vsaas_running,omitempty" validate:"omitempty"`
	PredictionsValue          *PeerStatsPredictionsImpl      `json:"predictions,omitempty" validate:"omitempty"`
	ErrorValue                *string                        `json:"error,omitempty" validate:"omitempty"`
	HostnameValue             *string                        `json:"hostname,omitempty" validate:"omitempty"`
	IDValue                   *UUID                          `json:"id,omitempty" validate:"omitempty"`
	InputKbitValue            *Speed                         `json:"input_kbit,omitempty" validate:"omitempty" openmetrics_metric:"server_input_bitrate"`
	IsChassisValue            *bool                          `json:"is_chassis,omitempty" validate:"omitempty"`
	LicenseTxtValue           *string                        `json:"license_txt,omitempty" validate:"omitempty"`
	LicenseTypeValue          *LicenseType                   `json:"license_type,omitempty" validate:"omitempty"`
	MemoryUsageValue          *Percent                       `json:"memory_usage,omitempty" validate:"omitempty,min=0,max=100" openmetrics_metric:"server_memory_usage"`
	NextVersionValue          *ServerVersion                 `json:"next_version,omitempty" validate:"omitempty"`
	NowValue                  *UtcMs                         `json:"now,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	OnlineStreamsValue        *int                           `json:"online_streams,omitempty" validate:"omitempty" openmetrics_metric:"server_online_streams"`
	OpenedFilesValue          *int                           `json:"opened_files,omitempty" validate:"omitempty" openmetrics_metric:"server_opened_files"`
	BuildValue                *int                           `json:"build,omitempty" validate:"omitempty" openmetrics_label:"build"`
	VsaasBrandingValue        *bool                          `json:"vsaas_branding,omitempty" validate:"omitempty"`
	CpuUsageValue             *Percent                       `json:"cpu_usage,omitempty" validate:"omitempty,min=0,max=100" openmetrics_metric:"server_cpu_usage"`
	RproxyValue               *bool                          `json:"rproxy,omitempty" validate:"omitempty"`
	RproxyRunningValue        *bool                          `json:"rproxy_running,omitempty" validate:"omitempty"`
	SchedulerLoadValue        *Percent                       `json:"scheduler_load,omitempty" validate:"omitempty,min=0,max=100" openmetrics_metric:"server_scheduler_load"`
	ServerVersionValue        *ServerVersion                 `json:"server_version,omitempty" validate:"omitempty" openmetrics_label:"version"`
	StartedAtValue            *Utc                           `json:"started_at,omitempty" validate:"omitempty,min=1e+09,max=1e+10" openmetrics_metric:"server_started_at"`
	StreamerStatusValue       *ServerStatsStreamerStatus     `json:"streamer_status,omitempty" validate:"omitempty"`
	TextAlertsValue           map[string]string              `json:"text_alerts,omitempty" validate:"omitempty"`
	BandwidthUsageValue       *Percent                       `json:"bandwidth_usage,omitempty" validate:"omitempty,min=0,max=100"`
	TotalClientsValue         *int                           `json:"total_clients,omitempty" validate:"omitempty" openmetrics_metric:"server_total_clients"`
	TotalStreamsValue         *int                           `json:"total_streams,omitempty" validate:"omitempty"`
	TranscoderValue           *bool                          `json:"transcoder,omitempty" validate:"omitempty"`
	VsaasValue                *bool                          `json:"vsaas,omitempty" validate:"omitempty"`
	UptimeValue               *Seconds                       `json:"uptime,omitempty" validate:"omitempty"`
	TranscoderDevicesValue    []*TranscoderDeviceStatsImpl   `json:"transcoder_devices,omitempty" validate:"omitempty"`
	PartitionsValue           []*PartitionStatsImpl          `json:"partitions,omitempty" validate:"omitempty"`
	ConfigVersionValue        []int                          `json:"config_version,omitempty" validate:"omitempty"`
}

// Predictions of future stats based on the current state of the cluster.
type PeerStatsPredictionsImpl struct {
	DiskValue *CentralDiskPredictionsImpl `json:"disk,omitempty" validate:"omitempty"`
}

type PlayProtocolsSpecImpl struct {
	APIValue       *bool `json:"api,omitempty" validate:"omitempty"`
	CmafValue      *bool `json:"cmaf,omitempty" validate:"omitempty"`
	DashValue      *bool `json:"dash,omitempty" validate:"omitempty"`
	HlsValue       *bool `json:"hls,omitempty" validate:"omitempty"`
	JpegValue      *bool `json:"jpeg,omitempty" validate:"omitempty"`
	M4fValue       *bool `json:"m4f,omitempty" validate:"omitempty"`
	M4sValue       *bool `json:"m4s,omitempty" validate:"omitempty"`
	Mp4Value       *bool `json:"mp4,omitempty" validate:"omitempty"`
	MseldValue     *bool `json:"mseld,omitempty" validate:"omitempty"`
	MssValue       *bool `json:"mss,omitempty" validate:"omitempty"`
	PlayerValue    *bool `json:"player,omitempty" validate:"omitempty"`
	RtmpValue      *bool `json:"rtmp,omitempty" validate:"omitempty"`
	RtspValue      *bool `json:"rtsp,omitempty" validate:"omitempty"`
	ShoutcastValue *bool `json:"shoutcast,omitempty" validate:"omitempty"`
	SrtValue       *bool `json:"srt,omitempty" validate:"omitempty"`
	TshttpValue    *bool `json:"tshttp,omitempty" validate:"omitempty"`
	WebrtcValue    *bool `json:"webrtc,omitempty" validate:"omitempty"`
	WhitelistValue *bool `json:"whitelist,omitempty" validate:"omitempty"`
}

// Required: id, title
type PresetImpl struct {
	DeletedAtValue    *UtcMs                 `json:"deleted_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	DvrValue          *StreamDvrSpecImpl     `json:"dvr,omitempty" validate:"omitempty"`
	IsAdjustableValue *bool                  `json:"is_adjustable,omitempty" validate:"omitempty"`
	IsDefaultValue    *bool                  `json:"is_default,omitempty" validate:"omitempty"`
	LastChangeValue   *PresetLastChangeImpl  `json:"last_change,omitempty" validate:"omitempty"`
	LayoutRulesValue  *StreamZoneConfigImpl  `json:"layout_rules,omitempty" validate:"omitempty"`
	StatsValue        *PresetStatsImpl       `json:"stats,omitempty" validate:"omitempty"`
	VisionValue       *VisionSpecPresetsImpl `json:"vision,omitempty" validate:"omitempty"`
	TitleValue        string                 `json:"title" validate:"required"`
	IDValue           int                    `json:"id" validate:"required"`
}

type PresetLastChangeImpl struct {
	UpdatedAtValue *UtcMs                    `json:"updated_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	UserValue      *PresetLastChangeUserImpl `json:"user,omitempty" validate:"omitempty"`
}

// Information about the user who modified.
type PresetLastChangeUserImpl struct {
	IDValue   *int    `json:"id,omitempty" validate:"omitempty"`
	NameValue *string `json:"name,omitempty" validate:"omitempty"`
}

// Statistics of the preset.
type PresetStatsImpl struct {
	OrganizationsCountValue *int `json:"organizations_count,omitempty" validate:"omitempty"`
	StreamsCountValue       *int `json:"streams_count,omitempty" validate:"omitempty"`
}

type PresetsListImpl struct {
	TimingValue         any           `json:"timing,omitempty" validate:"omitempty"`
	EstimatedCountValue *int          `json:"estimated_count,omitempty" validate:"omitempty"`
	NextValue           *string       `json:"next,omitempty" validate:"omitempty"`
	PrevValue           *string       `json:"prev,omitempty" validate:"omitempty"`
	PresetsValue        []*PresetImpl `json:"presets,omitempty" validate:"omitempty"`
}

type PushCountersImpl struct {
	ErrorsStopOverloadedValue       *int                   `json:"errors_stop_overloaded,omitempty" validate:"omitempty"`
	ErrorsTlsValue                  *int                   `json:"errors_tls,omitempty" validate:"omitempty"`
	Errors401Value                  *int                   `json:"errors_401,omitempty" validate:"omitempty"`
	Errors403Value                  *int                   `json:"errors_403,omitempty" validate:"omitempty"`
	Errors404Value                  *int                   `json:"errors_404,omitempty" validate:"omitempty"`
	Errors409Value                  *int                   `json:"errors_409,omitempty" validate:"omitempty"`
	Errors500Value                  *int                   `json:"errors_500,omitempty" validate:"omitempty"`
	ErrorsAudioFrameDecodeValue     *int                   `json:"errors_audio_frame_decode,omitempty" validate:"omitempty"`
	ErrorsConnectionLostValue       *int                   `json:"errors_connection_lost,omitempty" validate:"omitempty"`
	ErrorsDeviceBufferOverflowValue *int                   `json:"errors_device_buffer_overflow,omitempty" validate:"omitempty"`
	ErrorsVideoFrameDecodeValue     *int                   `json:"errors_video_frame_decode,omitempty" validate:"omitempty"`
	ErrorsDroppedFramesValue        *int                   `json:"errors_dropped_frames,omitempty" validate:"omitempty"`
	ErrorsDroppedSegmentsValue      *int                   `json:"errors_dropped_segments,omitempty" validate:"omitempty"`
	ErrorsNoDestinationValue        *int                   `json:"errors_no_destination,omitempty" validate:"omitempty"`
	ErrorsNotAuthorizedValue        *int                   `json:"errors_not_authorized,omitempty" validate:"omitempty"`
	ErrorsRedirectLimitValue        *int                   `json:"errors_redirect_limit,omitempty" validate:"omitempty"`
	EncodedBytesValue               *Bytes                 `json:"encoded_bytes,omitempty" validate:"omitempty"`
	BytesValue                      *Bytes                 `json:"bytes,omitempty" validate:"omitempty"`
	ErrorsDeviceNotOpenedValue      *int                   `json:"errors_device_not_opened,omitempty" validate:"omitempty"`
	FramesValue                     *int                   `json:"frames,omitempty" validate:"omitempty"`
	GenlockStatusValue              *GenlockStatus         `json:"genlock_status,omitempty" validate:"omitempty"`
	GenrefStatusValue               *GenrefStatusImpl      `json:"genref_status,omitempty" validate:"omitempty"`
	OpenedAtValue                   *UtcMs                 `json:"opened_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	URLValue                        *InputURL              `json:"url,omitempty" validate:"omitempty"`
	PusherQueueExhaustedCountValue  *int                   `json:"pusher_queue_exhausted_count,omitempty" validate:"omitempty"`
	PusherRestartsValue             *int                   `json:"pusher_restarts,omitempty" validate:"omitempty"`
	ResentPacketsValue              *int                   `json:"resent_packets,omitempty" validate:"omitempty"`
	SegmentsValue                   *int                   `json:"segments,omitempty" validate:"omitempty"`
	StandbyStatusValue              *PusherStandbyStatus   `json:"standby_status,omitempty" validate:"omitempty"`
	StatusValue                     *PusherStatus          `json:"status,omitempty" validate:"omitempty"`
	SysFillersBytesValue            *Bytes                 `json:"sys_fillers_bytes,omitempty" validate:"omitempty"`
	SysPayloadBytesValue            *Bytes                 `json:"sys_payload_bytes,omitempty" validate:"omitempty"`
	SysStuffingPacketsValue         *int                   `json:"sys_stuffing_packets,omitempty" validate:"omitempty"`
	PidsValue                       []*PushPidCountersImpl `json:"pids,omitempty" validate:"omitempty"`
}

// Required: pid
type PushPidCountersImpl struct {
	FillersBytesValue            *Bytes        `json:"fillers_bytes,omitempty" validate:"omitempty"`
	ErrorsStartLateDtsValue      *int          `json:"errors_start_late_dts,omitempty" validate:"omitempty"`
	ErrorsDtsGoesBackwardValue   *int          `json:"errors_dts_goes_backward,omitempty" validate:"omitempty"`
	ErrorsDtsJumpsForwardValue   *int          `json:"errors_dts_jumps_forward,omitempty" validate:"omitempty"`
	ErrorsPidOffValue            *int          `json:"errors_pid_off,omitempty" validate:"omitempty"`
	ErrorsStartFutureDtsValue    *int          `json:"errors_start_future_dts,omitempty" validate:"omitempty"`
	FillersValue                 *Bytes        `json:"fillers,omitempty" validate:"omitempty" openmetrics_metric:"pid_fillers"`
	ErrorsUnconfiguredQueueValue *int          `json:"errors_unconfigured_queue,omitempty" validate:"omitempty"`
	ExceededBytesValue           *Bytes        `json:"exceeded_bytes,omitempty" validate:"omitempty"`
	ExceededFramesValue          *int          `json:"exceeded_frames,omitempty" validate:"omitempty"`
	ContentValue                 *FrameContent `json:"content,omitempty" validate:"omitempty"`
	FillerPacketsValue           *int          `json:"filler_packets,omitempty" validate:"omitempty"`
	PayloadValue                 *Bytes        `json:"payload,omitempty" validate:"omitempty" openmetrics_metric:"pid_payload"`
	MaxBufferValue               *Milliseconds `json:"max_buffer,omitempty" validate:"omitempty"`
	MinBufferValue               *Milliseconds `json:"min_buffer,omitempty" validate:"omitempty"`
	PacketsValue                 *int          `json:"packets,omitempty" validate:"omitempty"`
	BitrateValue                 *Speed        `json:"bitrate,omitempty" validate:"omitempty"`
	PayloadBytesValue            *Bytes        `json:"payload_bytes,omitempty" validate:"omitempty"`
	TrimmedFramesValue           *int          `json:"trimmed_frames,omitempty" validate:"omitempty"`
	PnrValue                     *int          `json:"pnr,omitempty" validate:"omitempty"`
	StuffingValue                *int          `json:"stuffing,omitempty" validate:"omitempty" openmetrics_metric:"pid_stuffing"`
	StuffingPacketsValue         *int          `json:"stuffing_packets,omitempty" validate:"omitempty"`
	TrimmedBytesValue            *Bytes        `json:"trimmed_bytes,omitempty" validate:"omitempty"`
	PidValue                     int           `json:"pid" validate:"required"`
}

// Required: channel_id
type RTPCountersBaseImpl struct {
	NackCountValue            *int    `json:"nack_count,omitempty" validate:"omitempty"`
	PtRejectCountValue        *int    `json:"pt_reject_count,omitempty" validate:"omitempty"`
	ContentValue              *string `json:"content,omitempty" validate:"omitempty"`
	NoMarkerModeFlagValue     *bool   `json:"no_marker_mode_flag,omitempty" validate:"omitempty"`
	ErrorsDtsStuckValue       *int    `json:"errors_dts_stuck,omitempty" validate:"omitempty"`
	ErrorsLostPacketsValue    *int    `json:"errors_lost_packets,omitempty" validate:"omitempty"`
	FramesValue               *int    `json:"frames,omitempty" validate:"omitempty"`
	MarkerPacketsCountValue   *int    `json:"marker_packets_count,omitempty" validate:"omitempty"`
	TSStuckValue              *int    `json:"ts_stuck,omitempty" validate:"omitempty"`
	BytesValue                *int    `json:"bytes,omitempty" validate:"omitempty"`
	ErrorsBrokenPayloadValue  *int    `json:"errors_broken_payload,omitempty" validate:"omitempty"`
	PtRejectSumValue          *int    `json:"pt_reject_sum,omitempty" validate:"omitempty"`
	RtcpPacketsValue          *int    `json:"rtcp_packets,omitempty" validate:"omitempty"`
	RTPPacketsValue           *int    `json:"rtp_packets,omitempty" validate:"omitempty"`
	SenderClockDeviationValue *int    `json:"sender_clock_deviation,omitempty" validate:"omitempty"`
	SrTSStuckValue            *int    `json:"sr_ts_stuck,omitempty" validate:"omitempty"`
	TSGoesBackwardsValue      *int    `json:"ts_goes_backwards,omitempty" validate:"omitempty"`
	TSJumpForwardValue        *int    `json:"ts_jump_forward,omitempty" validate:"omitempty"`
	ChannelIDValue            int     `json:"channel_id" validate:"required"`
}

// Required: path
type RaidDiskConfigImpl struct {
	ModeValue  *RaidDiskMode            `json:"mode,omitempty" validate:"omitempty"`
	StatsValue *RaidDiskConfigStatsImpl `json:"stats,omitempty" validate:"omitempty"`
	PathValue  DiskPath                 `json:"path" validate:"required" openmetrics_label:"disk"`
}

// The runtime statistics about RAID. The statistics shows the state of disks.
// Learn more in [Flussonic RAID for DVR](https://flussonic.com/doc/extend-video-storage-on-fly/#dvr-flussonic-raid-stats)
type RaidDiskConfigStatsImpl struct {
	BlobsCountValue       *int                `json:"blobs_count,omitempty" validate:"omitempty" openmetrics_metric:"storage_blobs_count"`
	BlobsCountDbValue     *int                `json:"blobs_count_db,omitempty" validate:"omitempty" openmetrics_metric:"storage_blobs_count_db"`
	ErrorsValue           *RaidDiskErrorsImpl `json:"errors,omitempty" validate:"omitempty"`
	IoUsageValue          *Percent            `json:"io_usage,omitempty" validate:"omitempty,min=0,max=100" openmetrics_metric:"raid_disk_io_usage"`
	MigrationEtaValue     *Utc                `json:"migration_eta,omitempty" validate:"omitempty,min=1e+09,max=1e+10"`
	MigrationSpeedValue   *Speed              `json:"migration_speed,omitempty" validate:"omitempty"`
	MigrationUpdatedValue *Utc                `json:"migration_updated,omitempty" validate:"omitempty,min=1e+09,max=1e+10"`
	ModeValue             *RaidDiskMode       `json:"mode,omitempty" validate:"omitempty"`
	MountedValue          *bool               `json:"mounted,omitempty" validate:"omitempty"`
	SizeValue             *Bytes              `json:"size,omitempty" validate:"omitempty" openmetrics_metric:"storage_size"`
	UsageValue            *Percent            `json:"usage,omitempty" validate:"omitempty,min=0,max=100" openmetrics_metric:"storage_usage"`
	UsedValue             *Bytes              `json:"used,omitempty" validate:"omitempty" openmetrics_metric:"storage_used"`
	UsedIndexValue        *Bytes              `json:"used_index,omitempty" validate:"omitempty" openmetrics_metric:"storage_used_index"`
}

type RaidDiskErrorsImpl struct {
	ConnectionTimeoutValue *int `json:"connection_timeout,omitempty" validate:"omitempty"`
	EaccesValue            *int `json:"eacces,omitempty" validate:"omitempty"`
	EagainValue            *int `json:"eagain,omitempty" validate:"omitempty"`
	EbusyValue             *int `json:"ebusy,omitempty" validate:"omitempty"`
	EconnrefusedValue      *int `json:"econnrefused,omitempty" validate:"omitempty"`
	EdquotValue            *int `json:"edquot,omitempty" validate:"omitempty"`
	EmfileValue            *int `json:"emfile,omitempty" validate:"omitempty"`
	EnodevValue            *int `json:"enodev,omitempty" validate:"omitempty"`
	EnoentValue            *int `json:"enoent,omitempty" validate:"omitempty"`
	EnospcValue            *int `json:"enospc,omitempty" validate:"omitempty"`
	ErofsValue             *int `json:"erofs,omitempty" validate:"omitempty"`
	NxdomainValue          *int `json:"nxdomain,omitempty" validate:"omitempty"`
	OtherValue             *int `json:"other,omitempty" validate:"omitempty"`
	SslErrorValue          *int `json:"ssl_error,omitempty" validate:"omitempty"`
}

type RaidDiskStatsImpl struct {
	ErrorsValue           *RaidDiskErrorsImpl `json:"errors,omitempty" validate:"omitempty"`
	IoUsageValue          *Percent            `json:"io_usage,omitempty" validate:"omitempty,min=0,max=100" openmetrics_metric:"raid_disk_io_usage"`
	MigrationEtaValue     *Utc                `json:"migration_eta,omitempty" validate:"omitempty,min=1e+09,max=1e+10"`
	MigrationSpeedValue   *Speed              `json:"migration_speed,omitempty" validate:"omitempty"`
	MigrationUpdatedValue *Utc                `json:"migration_updated,omitempty" validate:"omitempty,min=1e+09,max=1e+10"`
	ModeValue             *RaidDiskMode       `json:"mode,omitempty" validate:"omitempty"`
	MountedValue          *bool               `json:"mounted,omitempty" validate:"omitempty"`
}

// Required: streampoint_key
type RproxyConfigImpl struct {
	EndpointAuthValue   *string                            `json:"endpoint_auth,omitempty" validate:"omitempty"`
	ForwardPortsValue   map[string]*ForwardPortsConfigImpl `json:"forward_ports,omitempty" validate:"omitempty"`
	StreampointKeyValue string                             `json:"streampoint_key" validate:"required,min=1,max=256"`
}

type SensorImpl struct {
	BlacklightCompensationValue *OnOffImpl              `json:"blacklight_compensation,omitempty" validate:"omitempty"`
	BrightnessCorrectionValue   *Percent                `json:"brightness_correction,omitempty" validate:"omitempty,min=0,max=100"`
	ContrastCorrectionValue     *Percent                `json:"contrast_correction,omitempty" validate:"omitempty,min=0,max=100"`
	ImageOrientationValue       *SensorImageOrientation `json:"image_orientation,omitempty" validate:"omitempty,oneof=normal upside_down"`
	InfraredCutoffFilterValue   *OnOffAutoImpl          `json:"infrared_cutoff_filter,omitempty" validate:"omitempty"`
	SaturationValue             *Percent                `json:"saturation,omitempty" validate:"omitempty,min=0,max=100"`
	SharpnessValue              *Percent                `json:"sharpness,omitempty" validate:"omitempty,min=0,max=100"`
	WideDynamicRangeValue       *Percent                `json:"wide_dynamic_range,omitempty" validate:"omitempty,min=0,max=100"`
}

type ServerConfigBaseImpl struct {
	PulsedbValue        *DiskPath               `json:"pulsedb,omitempty" validate:"omitempty"`
	MetaValue           *string                 `json:"meta,omitempty" validate:"omitempty"`
	ClusterKeyValue     *string                 `json:"cluster_key,omitempty" validate:"omitempty"`
	EditAuthValue       *AdminCredentialsImpl   `json:"edit_auth,omitempty" validate:"omitempty"`
	GeoipValue          *DiskPath               `json:"geoip,omitempty" validate:"omitempty"`
	ListenersValue      *ListenersImpl          `json:"listeners,omitempty" validate:"omitempty"`
	LogRequestsValue    *bool                   `json:"log_requests,omitempty" validate:"omitempty"`
	SessionLogValue     *DiskPath               `json:"session_log,omitempty" validate:"omitempty"`
	WebrtcPublishValue  *WebrtcRouterConfigImpl `json:"webrtc_publish,omitempty" validate:"omitempty"`
	NvidiaMonitorValue  *bool                   `json:"nvidia_monitor,omitempty" validate:"omitempty"`
	AuthTokenValue      *AuthToken              `json:"auth_token,omitempty" validate:"omitempty"`
	WebrtcPlayValue     *WebrtcRouterConfigImpl `json:"webrtc_play,omitempty" validate:"omitempty"`
	LoglevelValue       *Loglevel               `json:"loglevel,omitempty" validate:"omitempty"`
	SrtValue            *ListenSpec             `json:"srt,omitempty" validate:"omitempty"`
	Srt2PlayValue       *SrtConfigImpl          `json:"srt2_play,omitempty" validate:"omitempty"`
	Srt2PublishValue    *SrtConfigImpl          `json:"srt2_publish,omitempty" validate:"omitempty"`
	SrtPlayValue        *SrtConfigImpl          `json:"srt_play,omitempty" validate:"omitempty"`
	SrtPublishValue     *SrtConfigImpl          `json:"srt_publish,omitempty" validate:"omitempty"`
	TotalBandwidthValue *Speed                  `json:"total_bandwidth,omitempty" validate:"omitempty"`
	URLPrefixValue      *URLPrefix              `json:"url_prefix,omitempty" validate:"omitempty"`
	ViewAuthValue       *AdminCredentialsImpl   `json:"view_auth,omitempty" validate:"omitempty"`
	APIAllowedFromValue []Cidr                  `json:"api_allowed_from,omitempty" validate:"omitempty"`
	ServerNamesValue    []*ServerNameConfigImpl `json:"server_names,omitempty" validate:"omitempty"`
}

type ServerConfigFullImpl struct {
	FileProcessorValue *FileProcessorConfigImpl `json:"file_processor,omitempty" validate:"omitempty"`
	VsaasValue         *VsaasConfigImpl         `json:"vsaas,omitempty" validate:"omitempty"`
	RproxyValue        *RproxyConfigImpl        `json:"rproxy,omitempty" validate:"omitempty"`
	CameraAlarmValue   *CameraAlarmConfigImpl   `json:"camera_alarm,omitempty" validate:"omitempty"`
	ChassisValue       *ChassisConfigImpl       `json:"chassis,omitempty" validate:"omitempty"`
	IptvValue          *IptvConfigImpl          `json:"iptv,omitempty" validate:"omitempty"`
	HTTPProxiesValue   []*HTTPProxyConfigImpl   `json:"http_proxies,omitempty" validate:"omitempty"`
	CachesValue        []*CacheConfigImpl       `json:"caches,omitempty" validate:"omitempty"`
	EventSinksValue    []*EventSinkConfigImpl   `json:"event_sinks,omitempty" validate:"omitempty"`
	DvbCardsValue      []*DvbCardConfigImpl     `json:"dvb_cards,omitempty" validate:"omitempty"`
	AuthBackendsValue  []*AuthBackendConfigImpl `json:"auth_backends,omitempty" validate:"omitempty"`
	DecklinksValue     []*DecklinkConfigImpl    `json:"decklinks,omitempty" validate:"omitempty"`
	PeersValue         []*PeerConfigImpl        `json:"peers,omitempty" validate:"omitempty"`
	DvrsValue          []*DvrConfigImpl         `json:"dvrs,omitempty" validate:"omitempty"`
	SourcesValue       []*SourceConfigImpl      `json:"sources,omitempty" validate:"omitempty"`
	StreamsValue       []*StreamConfigImpl      `json:"streams,omitempty" validate:"omitempty"`
	TemplatesValue     []*TemplateConfigImpl    `json:"templates,omitempty" validate:"omitempty"`
	TranspondersValue  []*TransponderConfigImpl `json:"transponders,omitempty" validate:"omitempty"`
	VodsValue          []*VodConfigImpl         `json:"vods,omitempty" validate:"omitempty"`
	BalancersValue     []*BalancerConfigImpl    `json:"balancers,omitempty" validate:"omitempty"`
}

// Required: domain
type ServerNameConfigImpl struct {
	DomainValue  string   `json:"domain" validate:"required"`
	AliasesValue []string `json:"aliases,omitempty" validate:"omitempty"`
}

type ServerStatsNetworkImpl struct {
	InputKbitValue     *Speed `json:"input_kbit,omitempty" validate:"omitempty" openmetrics_metric:"server_input_bitrate"`
	OnlineStreamsValue *int   `json:"online_streams,omitempty" validate:"omitempty" openmetrics_metric:"server_online_streams"`
	OpenedFilesValue   *int   `json:"opened_files,omitempty" validate:"omitempty" openmetrics_metric:"server_opened_files"`
	OutputKbitValue    *Speed `json:"output_kbit,omitempty" validate:"omitempty" openmetrics_metric:"server_output_bitrate"`
	TotalClientsValue  *int   `json:"total_clients,omitempty" validate:"omitempty" openmetrics_metric:"server_total_clients"`
	TotalStreamsValue  *int   `json:"total_streams,omitempty" validate:"omitempty"`
}

type ServerStatsStreamerImpl struct {
	TotalBandwidthValue       *Speed                         `json:"total_bandwidth,omitempty" validate:"omitempty"`
	UptimeValue               *Seconds                       `json:"uptime,omitempty" validate:"omitempty"`
	ConfigExternalStatusValue *ConfigExternalErrorStatusImpl `json:"config_external_status,omitempty" validate:"omitempty"`
	VsaasRunningValue         *bool                          `json:"vsaas_running,omitempty" validate:"omitempty"`
	CpuUsageValue             *Percent                       `json:"cpu_usage,omitempty" validate:"omitempty,min=0,max=100" openmetrics_metric:"server_cpu_usage"`
	HostnameValue             *string                        `json:"hostname,omitempty" validate:"omitempty"`
	IDValue                   *UUID                          `json:"id,omitempty" validate:"omitempty"`
	IsChassisValue            *bool                          `json:"is_chassis,omitempty" validate:"omitempty"`
	LicenseTxtValue           *string                        `json:"license_txt,omitempty" validate:"omitempty"`
	LicenseTypeValue          *LicenseType                   `json:"license_type,omitempty" validate:"omitempty"`
	MemoryUsageValue          *Percent                       `json:"memory_usage,omitempty" validate:"omitempty,min=0,max=100" openmetrics_metric:"server_memory_usage"`
	NextVersionValue          *ServerVersion                 `json:"next_version,omitempty" validate:"omitempty"`
	ConfigErrorValue          *ConfigErrorStatusImpl         `json:"config_error,omitempty" validate:"omitempty"`
	RproxyRunningValue        *bool                          `json:"rproxy_running,omitempty" validate:"omitempty"`
	VsaasBrandingValue        *bool                          `json:"vsaas_branding,omitempty" validate:"omitempty"`
	SchedulerLoadValue        *Percent                       `json:"scheduler_load,omitempty" validate:"omitempty,min=0,max=100" openmetrics_metric:"server_scheduler_load"`
	StreamerStatusValue       *ServerStatsStreamerStatus     `json:"streamer_status,omitempty" validate:"omitempty"`
	TextAlertsValue           map[string]string              `json:"text_alerts,omitempty" validate:"omitempty"`
	BandwidthUsageValue       *Percent                       `json:"bandwidth_usage,omitempty" validate:"omitempty,min=0,max=100"`
	TranscoderValue           *bool                          `json:"transcoder,omitempty" validate:"omitempty"`
	VsaasValue                *bool                          `json:"vsaas,omitempty" validate:"omitempty"`
	RproxyValue               *bool                          `json:"rproxy,omitempty" validate:"omitempty"`
	TranscoderDevicesValue    []*TranscoderDeviceStatsImpl   `json:"transcoder_devices,omitempty" validate:"omitempty"`
	PartitionsValue           []*PartitionStatsImpl          `json:"partitions,omitempty" validate:"omitempty"`
	ConfigVersionValue        []int                          `json:"config_version,omitempty" validate:"omitempty"`
}

type ServerStatsWhoamiImpl struct {
	BuildValue         *int           `json:"build,omitempty" validate:"omitempty" openmetrics_label:"build"`
	NowValue           *UtcMs         `json:"now,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	ServerVersionValue *ServerVersion `json:"server_version,omitempty" validate:"omitempty" openmetrics_label:"version"`
	StartedAtValue     *Utc           `json:"started_at,omitempty" validate:"omitempty,min=1e+09,max=1e+10" openmetrics_metric:"server_started_at"`
}

// Shared token are designed to provide access to the camera and its archive via a link.
// In the permission parameters, you can specify the access level that will be available for this token.
// Each token provides secure access to certain features of the system, including real-time viewing,
// recording and playback of archived data, tilt and zoom control,
// as well as the integration of advertising.
// Required: key, name
type SharedTokenImpl struct {
	KeyValue         string                       `json:"key" validate:"required"`
	MediaValue       *string                      `json:"media,omitempty" validate:"omitempty"`
	NameValue        string                       `json:"name" validate:"required"`
	PermissionsValue []*SharedTokenPermissionImpl `json:"permissions,omitempty" validate:"omitempty"`
}

type SharedTokenPermissionImpl struct {
	AdvertValue        *bool    `json:"advert,omitempty" validate:"omitempty"`
	DvrValue           *bool    `json:"dvr,omitempty" validate:"omitempty"`
	DvrDepthLimitValue *Seconds `json:"dvr_depth_limit,omitempty" validate:"omitempty,min=0"`
	ExportValue        *bool    `json:"export,omitempty" validate:"omitempty"`
	LiveValue          *bool    `json:"live,omitempty" validate:"omitempty"`
	PtzValue           *bool    `json:"ptz,omitempty" validate:"omitempty"`
}

type SharedTokensListImpl struct {
	TimingValue         any                `json:"timing,omitempty" validate:"omitempty"`
	EstimatedCountValue *int               `json:"estimated_count,omitempty" validate:"omitempty"`
	NextValue           *string            `json:"next,omitempty" validate:"omitempty"`
	PrevValue           *string            `json:"prev,omitempty" validate:"omitempty"`
	SharedTokensValue   []*SharedTokenImpl `json:"shared_tokens,omitempty" validate:"omitempty"`
}

type SourceConfigImpl struct {
	DvrValue    *StreamDvrSpecImpl  `json:"dvr,omitempty" validate:"omitempty"`
	LabelsValue map[string]UnixName `json:"labels,omitempty" validate:"omitempty,dive,min=1,max=40"`
	VisionValue *VisionSpecImpl     `json:"vision,omitempty" validate:"omitempty"`
	PushesValue []StreamPush        `json:"pushes,omitempty" validate:"omitempty"`
}

type SourceSpecificConfigImpl struct {
}

type SrtConfigImpl struct {
	PortValue    *ListenSpec `json:"port,omitempty" validate:"omitempty"`
	TimeoutValue any         `json:"timeout,omitempty" validate:"omitempty"`
}

type SrtConfigBaseImpl struct {
}

type StreamConfigImpl struct {
	LayoutValue                 *CentralStreamLayoutImpl      `json:"layout,omitempty" validate:"omitempty"`
	OrganizationIDValue         *int                          `json:"organization_id,omitempty" validate:"omitempty"`
	CommentValue                *string                       `json:"comment,omitempty" validate:"omitempty"`
	CoordinatesValue            *MapSpecImpl                  `json:"coordinates,omitempty" validate:"omitempty"`
	CreatedAtValue              *UtcMs                        `json:"created_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	DisabledValue               *bool                         `json:"disabled,omitempty" validate:"omitempty"`
	DomainValue                 *DomainBaseImpl               `json:"domain,omitempty" validate:"omitempty"`
	DvrValue                    *StreamDvrSpecImpl            `json:"dvr,omitempty" validate:"omitempty"`
	FirmwareUpdateDurationValue *Milliseconds                 `json:"firmware_update_duration,omitempty" validate:"omitempty"`
	FolderIDValue               *int                          `json:"folder_id,omitempty" validate:"omitempty"`
	VisionValue                 *VisionSpecImpl               `json:"vision,omitempty" validate:"omitempty"`
	LabelsValue                 map[string]UnixName           `json:"labels,omitempty" validate:"omitempty,dive,min=1,max=40"`
	LastChangeValue             *AuditLogRecordImpl           `json:"last_change,omitempty" validate:"omitempty"`
	LastEpisodeAtValue          *UtcMs                        `json:"last_episode_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	CanPublishValue             *bool                         `json:"can_publish,omitempty" validate:"omitempty"`
	AudioValue                  *WatcherStreamConfigAudioImpl `json:"audio,omitempty" validate:"omitempty"`
	PostalAddressValue          *string                       `json:"postal_address,omitempty" validate:"omitempty"`
	TitleValue                  *string                       `json:"title,omitempty" validate:"omitempty"`
	OnvifValue                  *StreamOnvifConfigImpl        `json:"onvif,omitempty" validate:"omitempty"`
	OrganizationValue           *OrganizationStreamImpl       `json:"organization,omitempty" validate:"omitempty"`
	LayoutRulesValue            *StreamZoneConfigImpl         `json:"layout_rules,omitempty" validate:"omitempty"`
	StatsValue                  *StreamStatsImpl              `json:"stats,omitempty" validate:"omitempty"`
	MapCoordinatesValue         *MapSpecImpl                  `json:"map_coordinates,omitempty" validate:"omitempty"`
	PresetValue                 *StreamPresetImpl             `json:"preset,omitempty" validate:"omitempty"`
	PresetIDValue               *int                          `json:"preset_id,omitempty" validate:"omitempty"`
	StaticValue                 *bool                         `json:"static,omitempty" validate:"omitempty"`
	NameValue                   MediaName                     `json:"name" validate:"required" openmetrics_label:"name"`
	PushesValue                 []StreamPush                  `json:"pushes,omitempty" validate:"omitempty"`
	PathValue                   []*StreamPathItemImpl         `json:"path,omitempty" validate:"omitempty"`
	InputsValue                 []StreamInput                 `json:"inputs,omitempty" validate:"omitempty"`
}

type StreamConfigAdditionalImpl struct {
	StatsValue *StreamStatsImpl `json:"stats,omitempty" validate:"omitempty"`
}

type StreamConfigBaseImpl struct {
	DisabledValue *bool `json:"disabled,omitempty" validate:"omitempty"`
	StaticValue   *bool `json:"static,omitempty" validate:"omitempty"`
}

type StreamConfigDeprecatedImpl struct {
}

type StreamConfigInputImpl struct {
	InputsValue []StreamInput `json:"inputs,omitempty" validate:"omitempty"`
}

type StreamConfigMediaImpl struct {
	DvrValue    *StreamDvrSpecImpl  `json:"dvr,omitempty" validate:"omitempty"`
	LabelsValue map[string]UnixName `json:"labels,omitempty" validate:"omitempty,dive,min=1,max=40"`
	PushesValue []StreamPush        `json:"pushes,omitempty" validate:"omitempty"`
}

type StreamConfigMultieditImpl struct {
	DvrValue         *StreamDvrSpecImpl    `json:"dvr,omitempty" validate:"omitempty"`
	LayoutRulesValue *StreamZoneConfigImpl `json:"layout_rules,omitempty" validate:"omitempty"`
	NameValue        *string               `json:"name,omitempty" validate:"omitempty"`
	PresetIDValue    *int                  `json:"preset_id,omitempty" validate:"omitempty"`
}

type StreamConfigOnpremisesImpl struct {
	VisionValue *VisionSpecImpl `json:"vision,omitempty" validate:"omitempty"`
}

// Required: name
type StreamConfigSpecificImpl struct {
	CommentValue *string   `json:"comment,omitempty" validate:"omitempty"`
	TitleValue   *string   `json:"title,omitempty" validate:"omitempty"`
	NameValue    MediaName `json:"name" validate:"required" openmetrics_label:"name"`
}

type StreamDvrSpecImpl struct {
	DiskUsageLimitValue     *Percent `json:"disk_usage_limit,omitempty" validate:"omitempty,min=0,max=100"`
	EpisodesExpirationValue *Seconds `json:"episodes_expiration,omitempty" validate:"omitempty"`
	ExpirationValue         *Seconds `json:"expiration,omitempty" validate:"omitempty"`
	RedundancyFactorValue   *int     `json:"redundancy_factor,omitempty" validate:"omitempty,min=0"`
	StorageLimitValue       *Bytes   `json:"storage_limit,omitempty" validate:"omitempty"`
}

type StreamDvrSpecificSpecImpl struct {
	RedundancyFactorValue *int `json:"redundancy_factor,omitempty" validate:"omitempty,min=0"`
}

type StreamInputBaseImpl struct {
	AllowIfValue                 *string           `json:"allow_if,omitempty" validate:"omitempty"`
	AudioTimeoutValue            *Seconds          `json:"audio_timeout,omitempty" validate:"omitempty"`
	CommentValue                 *string           `json:"comment,omitempty" validate:"omitempty"`
	DenyIfValue                  *string           `json:"deny_if,omitempty" validate:"omitempty"`
	FramesTimeoutValue           *int              `json:"frames_timeout,omitempty" validate:"omitempty"`
	HeadersValue                 map[string]string `json:"headers,omitempty" validate:"omitempty"`
	MaxRetryTimeoutValue         *Seconds          `json:"max_retry_timeout,omitempty" validate:"omitempty,min=1"`
	NoClientsReconnectDelayValue *int              `json:"no_clients_reconnect_delay,omitempty" validate:"omitempty"`
	OutputAudioValue             *OutputAudio      `json:"output_audio,omitempty" validate:"omitempty"`
	PriorityValue                *int              `json:"priority,omitempty" validate:"omitempty"`
	SourceTimeoutValue           any               `json:"source_timeout,omitempty" validate:"omitempty"`
	StatsValue                   *InputStatsImpl   `json:"stats,omitempty" validate:"omitempty"`
	TimeoutValue                 *int              `json:"timeout,omitempty" validate:"omitempty"`
	UserAgentValue               *string           `json:"user_agent,omitempty" validate:"omitempty"`
	ViaValue                     *AgentURL         `json:"via,omitempty" validate:"omitempty"`
	VideoTimeoutValue            *Seconds          `json:"video_timeout,omitempty" validate:"omitempty"`
}

type StreamInputFakeImpl struct {
	SourceTimeoutValue           any               `json:"source_timeout,omitempty" validate:"omitempty"`
	OutputAudioValue             *OutputAudio      `json:"output_audio,omitempty" validate:"omitempty"`
	PriorityValue                *int              `json:"priority,omitempty" validate:"omitempty"`
	CommentValue                 *string           `json:"comment,omitempty" validate:"omitempty"`
	AllowIfValue                 *string           `json:"allow_if,omitempty" validate:"omitempty"`
	FramesTimeoutValue           *int              `json:"frames_timeout,omitempty" validate:"omitempty"`
	HeadersValue                 map[string]string `json:"headers,omitempty" validate:"omitempty"`
	HeightValue                  *int              `json:"height,omitempty" validate:"omitempty"`
	MaxRetryTimeoutValue         *Seconds          `json:"max_retry_timeout,omitempty" validate:"omitempty,min=1"`
	BitrateValue                 *Speed            `json:"bitrate,omitempty" validate:"omitempty"`
	NoClientsReconnectDelayValue *int              `json:"no_clients_reconnect_delay,omitempty" validate:"omitempty"`
	DenyIfValue                  *string           `json:"deny_if,omitempty" validate:"omitempty"`
	AudioTimeoutValue            *Seconds          `json:"audio_timeout,omitempty" validate:"omitempty"`
	StatsValue                   *InputStatsImpl   `json:"stats,omitempty" validate:"omitempty"`
	TimeoutValue                 *int              `json:"timeout,omitempty" validate:"omitempty"`
	WidthValue                   *int              `json:"width,omitempty" validate:"omitempty"`
	UserAgentValue               *string           `json:"user_agent,omitempty" validate:"omitempty"`
	ViaValue                     *AgentURL         `json:"via,omitempty" validate:"omitempty"`
	VideoTimeoutValue            *Seconds          `json:"video_timeout,omitempty" validate:"omitempty"`
	URLValue                     InputURL          `json:"url" validate:"required"`
}

type StreamInputFileImpl struct {
	SourceTimeoutValue           any                                 `json:"source_timeout,omitempty" validate:"omitempty"`
	FramesTimeoutValue           *int                                `json:"frames_timeout,omitempty" validate:"omitempty"`
	PriorityValue                *int                                `json:"priority,omitempty" validate:"omitempty"`
	CommentValue                 *string                             `json:"comment,omitempty" validate:"omitempty"`
	DenyIfValue                  *string                             `json:"deny_if,omitempty" validate:"omitempty"`
	AllowIfValue                 *string                             `json:"allow_if,omitempty" validate:"omitempty"`
	HeadersValue                 map[string]string                   `json:"headers,omitempty" validate:"omitempty"`
	LanguagesValue               map[string]string                   `json:"languages,omitempty" validate:"omitempty"`
	MaxRetryTimeoutValue         *Seconds                            `json:"max_retry_timeout,omitempty" validate:"omitempty,min=1"`
	NoClientsReconnectDelayValue *int                                `json:"no_clients_reconnect_delay,omitempty" validate:"omitempty"`
	VideoTimeoutValue            *Seconds                            `json:"video_timeout,omitempty" validate:"omitempty"`
	ClosedCaptionsValue          map[string]string                   `json:"closed_captions,omitempty" validate:"omitempty"`
	ViaValue                     *AgentURL                           `json:"via,omitempty" validate:"omitempty"`
	OutputAudioValue             *OutputAudio                        `json:"output_audio,omitempty" validate:"omitempty"`
	Scte35Value                  *bool                               `json:"scte35,omitempty" validate:"omitempty"`
	AudioTimeoutValue            *Seconds                            `json:"audio_timeout,omitempty" validate:"omitempty"`
	StatsValue                   *InputStatsImpl                     `json:"stats,omitempty" validate:"omitempty"`
	SubtitlesValue               *StreamInputMpegtsSpecificSubtitles `json:"subtitles,omitempty" validate:"omitempty,oneof=drop accept ocr_replace ocr_add"`
	TimeoutValue                 *int                                `json:"timeout,omitempty" validate:"omitempty"`
	UserAgentValue               *string                             `json:"user_agent,omitempty" validate:"omitempty"`
	URLValue                     InputURL                            `json:"url" validate:"required"`
	PidsValue                    []int                               `json:"pids,omitempty" validate:"omitempty"`
	ProgramsValue                []int                               `json:"programs,omitempty" validate:"omitempty"`
}

type StreamInputMpegtsSpecificImpl struct {
	ClosedCaptionsValue map[string]string                   `json:"closed_captions,omitempty" validate:"omitempty"`
	LanguagesValue      map[string]string                   `json:"languages,omitempty" validate:"omitempty"`
	Scte35Value         *bool                               `json:"scte35,omitempty" validate:"omitempty"`
	SubtitlesValue      *StreamInputMpegtsSpecificSubtitles `json:"subtitles,omitempty" validate:"omitempty,oneof=drop accept ocr_replace ocr_add"`
	PidsValue           []int                               `json:"pids,omitempty" validate:"omitempty"`
	ProgramsValue       []int                               `json:"programs,omitempty" validate:"omitempty"`
}

type StreamInputPublishImpl struct {
	SourceTimeoutValue           any                                     `json:"source_timeout,omitempty" validate:"omitempty"`
	MinBitrateValue              *int                                    `json:"min_bitrate,omitempty" validate:"omitempty"`
	OutputAudioValue             *OutputAudio                            `json:"output_audio,omitempty" validate:"omitempty"`
	AbrLossLowerValue            *float64                                `json:"abr_loss_lower,omitempty" validate:"omitempty"`
	AbrLossUpperValue            *float64                                `json:"abr_loss_upper,omitempty" validate:"omitempty"`
	AbrMaxBitrateValue           *int                                    `json:"abr_max_bitrate,omitempty" validate:"omitempty"`
	AbrModeValue                 *int                                    `json:"abr_mode,omitempty" validate:"omitempty"`
	AbrStepdownValue             *float64                                `json:"abr_stepdown,omitempty" validate:"omitempty"`
	AbrStepupValue               *int                                    `json:"abr_stepup,omitempty" validate:"omitempty"`
	NoClientsReconnectDelayValue *int                                    `json:"no_clients_reconnect_delay,omitempty" validate:"omitempty"`
	AudioTimeoutValue            *Seconds                                `json:"audio_timeout,omitempty" validate:"omitempty"`
	CommentValue                 *string                                 `json:"comment,omitempty" validate:"omitempty"`
	DenyIfValue                  *string                                 `json:"deny_if,omitempty" validate:"omitempty"`
	FramesTimeoutValue           *int                                    `json:"frames_timeout,omitempty" validate:"omitempty"`
	HeadersValue                 map[string]string                       `json:"headers,omitempty" validate:"omitempty"`
	AbrDebugValue                *int                                    `json:"abr_debug,omitempty" validate:"omitempty"`
	MaxRetryTimeoutValue         *Seconds                                `json:"max_retry_timeout,omitempty" validate:"omitempty,min=1"`
	AllowIfValue                 *string                                 `json:"allow_if,omitempty" validate:"omitempty"`
	AbrCorrectionValue           *int                                    `json:"abr_correction,omitempty" validate:"omitempty"`
	PreferCodecValue             *WebrtcPreferVideoCodec                 `json:"prefer_codec,omitempty" validate:"omitempty"`
	PreferVideoCodecValue        *WebrtcPreferVideoCodec                 `json:"prefer_video_codec,omitempty" validate:"omitempty"`
	PriorityValue                *int                                    `json:"priority,omitempty" validate:"omitempty"`
	Scte35Value                  *bool                                   `json:"scte35,omitempty" validate:"omitempty"`
	AbrCyclesValue               *int                                    `json:"abr_cycles,omitempty" validate:"omitempty"`
	StatsValue                   *InputStatsImpl                         `json:"stats,omitempty" validate:"omitempty"`
	SubtitlesValue               *StreamInputSrtPublishSpecificSubtitles `json:"subtitles,omitempty" validate:"omitempty,oneof=drop accept ocr_replace ocr_add"`
	TimeoutValue                 *int                                    `json:"timeout,omitempty" validate:"omitempty"`
	TransportValue               *WebrtcTransport                        `json:"transport,omitempty" validate:"omitempty"`
	WebrtcAbrValue               *bool                                   `json:"webrtc_abr,omitempty" validate:"omitempty"`
	UserAgentValue               *string                                 `json:"user_agent,omitempty" validate:"omitempty"`
	ViaValue                     *AgentURL                               `json:"via,omitempty" validate:"omitempty"`
	VideoTimeoutValue            *Seconds                                `json:"video_timeout,omitempty" validate:"omitempty"`
	URLValue                     InputURL                                `json:"url" validate:"required"`
}

type StreamInputRtspImpl struct {
	SourceTimeoutValue           any               `json:"source_timeout,omitempty" validate:"omitempty"`
	OutputAudioValue             *OutputAudio      `json:"output_audio,omitempty" validate:"omitempty"`
	AudioTimeoutValue            *Seconds          `json:"audio_timeout,omitempty" validate:"omitempty"`
	DenyIfValue                  *string           `json:"deny_if,omitempty" validate:"omitempty"`
	FramesTimeoutValue           *int              `json:"frames_timeout,omitempty" validate:"omitempty"`
	HeadersValue                 map[string]string `json:"headers,omitempty" validate:"omitempty"`
	MaxRetryTimeoutValue         *Seconds          `json:"max_retry_timeout,omitempty" validate:"omitempty,min=1"`
	NoClientsReconnectDelayValue *int              `json:"no_clients_reconnect_delay,omitempty" validate:"omitempty"`
	AllowIfValue                 *string           `json:"allow_if,omitempty" validate:"omitempty"`
	CommentValue                 *string           `json:"comment,omitempty" validate:"omitempty"`
	PriorityValue                *int              `json:"priority,omitempty" validate:"omitempty"`
	RTPValue                     *string           `json:"rtp,omitempty" validate:"omitempty"`
	StatsValue                   *InputStatsImpl   `json:"stats,omitempty" validate:"omitempty"`
	TimeoutValue                 *int              `json:"timeout,omitempty" validate:"omitempty"`
	WaitRtcpValue                *bool             `json:"wait_rtcp,omitempty" validate:"omitempty"`
	UserAgentValue               *string           `json:"user_agent,omitempty" validate:"omitempty"`
	ViaValue                     *AgentURL         `json:"via,omitempty" validate:"omitempty"`
	VideoTimeoutValue            *Seconds          `json:"video_timeout,omitempty" validate:"omitempty"`
	URLValue                     InputURL          `json:"url" validate:"required"`
}

type StreamInputSrtPublishSpecificImpl struct {
	Scte35Value    *bool                                   `json:"scte35,omitempty" validate:"omitempty"`
	SubtitlesValue *StreamInputSrtPublishSpecificSubtitles `json:"subtitles,omitempty" validate:"omitempty,oneof=drop accept ocr_replace ocr_add"`
}

// Title: WebRTC
type StreamInputWebrtcPublishSpecificImpl struct {
	AbrCorrectionValue    *int                    `json:"abr_correction,omitempty" validate:"omitempty"`
	AbrCyclesValue        *int                    `json:"abr_cycles,omitempty" validate:"omitempty"`
	AbrDebugValue         *int                    `json:"abr_debug,omitempty" validate:"omitempty"`
	AbrLossLowerValue     *float64                `json:"abr_loss_lower,omitempty" validate:"omitempty"`
	AbrLossUpperValue     *float64                `json:"abr_loss_upper,omitempty" validate:"omitempty"`
	AbrMaxBitrateValue    *int                    `json:"abr_max_bitrate,omitempty" validate:"omitempty"`
	AbrModeValue          *int                    `json:"abr_mode,omitempty" validate:"omitempty"`
	AbrStepdownValue      *float64                `json:"abr_stepdown,omitempty" validate:"omitempty"`
	AbrStepupValue        *int                    `json:"abr_stepup,omitempty" validate:"omitempty"`
	MinBitrateValue       *int                    `json:"min_bitrate,omitempty" validate:"omitempty"`
	PreferCodecValue      *WebrtcPreferVideoCodec `json:"prefer_codec,omitempty" validate:"omitempty"`
	PreferVideoCodecValue *WebrtcPreferVideoCodec `json:"prefer_video_codec,omitempty" validate:"omitempty"`
	TransportValue        *WebrtcTransport        `json:"transport,omitempty" validate:"omitempty"`
	WebrtcAbrValue        *bool                   `json:"webrtc_abr,omitempty" validate:"omitempty"`
}

type StreamOnvifConfigImpl struct {
	PtzValue *bool   `json:"ptz,omitempty" validate:"omitempty"`
	URLValue *string `json:"url,omitempty" validate:"omitempty"`
}

type StreamPathItemImpl struct {
	IDValue    *int    `json:"id,omitempty" validate:"omitempty"`
	TitleValue *string `json:"title,omitempty" validate:"omitempty"`
}

type StreamPresetImpl struct {
	IDValue           *int    `json:"id,omitempty" validate:"omitempty"`
	IsAdjustableValue *bool   `json:"is_adjustable,omitempty" validate:"omitempty"`
	TitleValue        *string `json:"title,omitempty" validate:"omitempty"`
}

type StreamPushBaseImpl struct {
	CommentValue      *string           `json:"comment,omitempty" validate:"omitempty"`
	DisabledValue     *bool             `json:"disabled,omitempty" validate:"omitempty"`
	RetryLimitValue   *int              `json:"retry_limit,omitempty" validate:"omitempty"`
	RetryTimeoutValue *Seconds          `json:"retry_timeout,omitempty" validate:"omitempty"`
	StatsValue        *PushCountersImpl `json:"stats,omitempty" validate:"omitempty"`
	TimeoutValue      *Seconds          `json:"timeout,omitempty" validate:"omitempty"`
}

type StreamPushRtmpImpl struct {
	CommentValue      *string           `json:"comment,omitempty" validate:"omitempty"`
	DisabledValue     *bool             `json:"disabled,omitempty" validate:"omitempty"`
	RetryLimitValue   *int              `json:"retry_limit,omitempty" validate:"omitempty"`
	RetryTimeoutValue *Seconds          `json:"retry_timeout,omitempty" validate:"omitempty"`
	StatsValue        *PushCountersImpl `json:"stats,omitempty" validate:"omitempty"`
	TimeoutValue      *Seconds          `json:"timeout,omitempty" validate:"omitempty"`
	URLValue          InputURL          `json:"url" validate:"required"`
}

type StreamStatsImpl struct {
	AgentStatusValue       *string        `json:"agent_status,omitempty" validate:"omitempty"`
	AliveValue             *bool          `json:"alive,omitempty" validate:"omitempty"`
	BitrateValue           *Speed         `json:"bitrate,omitempty" validate:"omitempty" openmetrics_metric:"stream_bitrate"`
	BytesOutValue          *Bytes         `json:"bytes_out,omitempty" validate:"omitempty" openmetrics_metric:"stream_bytes_out"`
	CurrentAgentIDValue    *AgentID       `json:"current_agent_id,omitempty" validate:"omitempty"`
	DvrInfoValue           *DvrInfoImpl   `json:"dvr_info,omitempty" validate:"omitempty"`
	LastDtsAtValue         *UtcMs         `json:"last_dts_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	LifetimeValue          *Milliseconds  `json:"lifetime,omitempty" validate:"omitempty"`
	MediaInfoValue         *MediaInfoImpl `json:"media_info,omitempty" validate:"omitempty"`
	OnlineClientsValue     *ClientCount   `json:"online_clients,omitempty" validate:"omitempty" openmetrics_metric:"stream_online_clients"`
	PlaybackTokenValue     *string        `json:"playback_token,omitempty" validate:"omitempty"`
	PublishEndpointValue   *string        `json:"publish_endpoint,omitempty" validate:"omitempty"`
	StatusValue            *StreamStatus  `json:"status,omitempty" validate:"omitempty"`
	StreamingEndpointValue *string        `json:"streaming_endpoint,omitempty" validate:"omitempty"`
	TSDelayValue           *Ticks         `json:"ts_delay,omitempty" validate:"omitempty"`
}

type StreamZoneConfigImpl struct {
	PreferredZonesValue []string `json:"preferred_zones,omitempty" validate:"omitempty"`
	RequiredZonesValue  []string `json:"required_zones,omitempty" validate:"omitempty"`
}

type StreamerImpl struct {
	APIURLValue            *URL                      `json:"api_url,omitempty" validate:"omitempty"`
	ChannelLimitValue      *int                      `json:"channel_limit,omitempty" validate:"omitempty"`
	ClusterKeyValue        *string                   `json:"cluster_key,omitempty" validate:"omitempty"`
	ConfigValue            *StreamerConfigConfigImpl `json:"config,omitempty" validate:"omitempty"`
	DvrsValue              []*DvrConfigImpl          `json:"dvrs,omitempty" validate:"omitempty"`
	HostnameValue          *ServerName               `json:"hostname,omitempty" validate:"omitempty"`
	LabelsValue            map[string]UnixName       `json:"labels,omitempty" validate:"omitempty"`
	PrivatePayloadURLValue *URL                      `json:"private_payload_url,omitempty" validate:"omitempty"`
	PublicPayloadURLValue  *URL                      `json:"public_payload_url,omitempty" validate:"omitempty"`
	RoleValue              *CentralNodeRoleRole      `json:"role,omitempty" validate:"omitempty,oneof=streamer inference identification"`
	StatsValue             *PeerStatsImpl            `json:"stats,omitempty" validate:"omitempty"`
	TotalBandwidthValue    *Speed                    `json:"total_bandwidth,omitempty" validate:"omitempty"`
	ZonesValue             []string                  `json:"zones,omitempty" validate:"omitempty"`
}

type StreamerConfigImpl struct {
	APIURLValue            *URL                      `json:"api_url,omitempty" validate:"omitempty"`
	ChannelLimitValue      *int                      `json:"channel_limit,omitempty" validate:"omitempty"`
	ClusterKeyValue        *string                   `json:"cluster_key,omitempty" validate:"omitempty"`
	ConfigValue            *StreamerConfigConfigImpl `json:"config,omitempty" validate:"omitempty"`
	HostnameValue          *ServerName               `json:"hostname,omitempty" validate:"omitempty"`
	LabelsValue            map[string]UnixName       `json:"labels,omitempty" validate:"omitempty"`
	PrivatePayloadURLValue *URL                      `json:"private_payload_url,omitempty" validate:"omitempty"`
	PublicPayloadURLValue  *URL                      `json:"public_payload_url,omitempty" validate:"omitempty"`
	RoleValue              *CentralNodeRoleRole      `json:"role,omitempty" validate:"omitempty,oneof=streamer inference identification"`
	StatsValue             *PeerStatsImpl            `json:"stats,omitempty" validate:"omitempty"`
	TotalBandwidthValue    *Speed                    `json:"total_bandwidth,omitempty" validate:"omitempty"`
	DvrsValue              []*DvrConfigImpl          `json:"dvrs,omitempty" validate:"omitempty"`
}

// Flussonic Media Server configuration which will be provided to Streamer
type StreamerConfigConfigImpl struct {
	Srt2PublishValue    *SrtConfigImpl           `json:"srt2_publish,omitempty" validate:"omitempty"`
	SrtPlayValue        *SrtConfigImpl           `json:"srt_play,omitempty" validate:"omitempty"`
	AuthTokenValue      *AuthToken               `json:"auth_token,omitempty" validate:"omitempty"`
	WebrtcPublishValue  *WebrtcRouterConfigImpl  `json:"webrtc_publish,omitempty" validate:"omitempty"`
	WebrtcPlayValue     *WebrtcRouterConfigImpl  `json:"webrtc_play,omitempty" validate:"omitempty"`
	CameraAlarmValue    *CameraAlarmConfigImpl   `json:"camera_alarm,omitempty" validate:"omitempty"`
	ChassisValue        *ChassisConfigImpl       `json:"chassis,omitempty" validate:"omitempty"`
	ClusterKeyValue     *string                  `json:"cluster_key,omitempty" validate:"omitempty"`
	VsaasValue          *VsaasConfigImpl         `json:"vsaas,omitempty" validate:"omitempty"`
	ViewAuthValue       *AdminCredentialsImpl    `json:"view_auth,omitempty" validate:"omitempty"`
	URLPrefixValue      *URLPrefix               `json:"url_prefix,omitempty" validate:"omitempty"`
	EditAuthValue       *AdminCredentialsImpl    `json:"edit_auth,omitempty" validate:"omitempty"`
	TotalBandwidthValue *Speed                   `json:"total_bandwidth,omitempty" validate:"omitempty"`
	FileProcessorValue  *FileProcessorConfigImpl `json:"file_processor,omitempty" validate:"omitempty"`
	GeoipValue          *DiskPath                `json:"geoip,omitempty" validate:"omitempty"`
	SrtPublishValue     *SrtConfigImpl           `json:"srt_publish,omitempty" validate:"omitempty"`
	IptvValue           *IptvConfigImpl          `json:"iptv,omitempty" validate:"omitempty"`
	NvidiaMonitorValue  *bool                    `json:"nvidia_monitor,omitempty" validate:"omitempty"`
	LogRequestsValue    *bool                    `json:"log_requests,omitempty" validate:"omitempty"`
	LoglevelValue       *Loglevel                `json:"loglevel,omitempty" validate:"omitempty"`
	MetaValue           *string                  `json:"meta,omitempty" validate:"omitempty"`
	Srt2PlayValue       *SrtConfigImpl           `json:"srt2_play,omitempty" validate:"omitempty"`
	ListenersValue      *ListenersImpl           `json:"listeners,omitempty" validate:"omitempty"`
	PulsedbValue        *DiskPath                `json:"pulsedb,omitempty" validate:"omitempty"`
	RproxyValue         *RproxyConfigImpl        `json:"rproxy,omitempty" validate:"omitempty"`
	SrtValue            *ListenSpec              `json:"srt,omitempty" validate:"omitempty"`
	SessionLogValue     *DiskPath                `json:"session_log,omitempty" validate:"omitempty"`
	EventSinksValue     []*EventSinkConfigImpl   `json:"event_sinks,omitempty" validate:"omitempty"`
	TemplatesValue      []*TemplateConfigImpl    `json:"templates,omitempty" validate:"omitempty"`
	PeersValue          []*PeerConfigImpl        `json:"peers,omitempty" validate:"omitempty"`
	APIAllowedFromValue []Cidr                   `json:"api_allowed_from,omitempty" validate:"omitempty"`
	AuthBackendsValue   []*AuthBackendConfigImpl `json:"auth_backends,omitempty" validate:"omitempty"`
	HTTPProxiesValue    []*HTTPProxyConfigImpl   `json:"http_proxies,omitempty" validate:"omitempty"`
	ServerNamesValue    []*ServerNameConfigImpl  `json:"server_names,omitempty" validate:"omitempty"`
	StreamsValue        []*StreamConfigImpl      `json:"streams,omitempty" validate:"omitempty"`
	TranspondersValue   []*TransponderConfigImpl `json:"transponders,omitempty" validate:"omitempty"`
	SourcesValue        []*SourceConfigImpl      `json:"sources,omitempty" validate:"omitempty"`
	DvrsValue           []*DvrConfigImpl         `json:"dvrs,omitempty" validate:"omitempty"`
	DvbCardsValue       []*DvbCardConfigImpl     `json:"dvb_cards,omitempty" validate:"omitempty"`
	VodsValue           []*VodConfigImpl         `json:"vods,omitempty" validate:"omitempty"`
	DecklinksValue      []*DecklinkConfigImpl    `json:"decklinks,omitempty" validate:"omitempty"`
	CachesValue         []*CacheConfigImpl       `json:"caches,omitempty" validate:"omitempty"`
	BalancersValue      []*BalancerConfigImpl    `json:"balancers,omitempty" validate:"omitempty"`
}

type StreamerLayoutPredictionImpl struct {
	APIURLValue            *URL                      `json:"api_url,omitempty" validate:"omitempty"`
	ChannelLimitValue      *int                      `json:"channel_limit,omitempty" validate:"omitempty"`
	ClusterKeyValue        *string                   `json:"cluster_key,omitempty" validate:"omitempty"`
	ConfigValue            *StreamerConfigConfigImpl `json:"config,omitempty" validate:"omitempty"`
	DvrsValue              []*DvrConfigImpl          `json:"dvrs,omitempty" validate:"omitempty"`
	HostnameValue          *ServerName               `json:"hostname,omitempty" validate:"omitempty"`
	LabelsValue            map[string]UnixName       `json:"labels,omitempty" validate:"omitempty"`
	PrivatePayloadURLValue *URL                      `json:"private_payload_url,omitempty" validate:"omitempty"`
	PublicPayloadURLValue  *URL                      `json:"public_payload_url,omitempty" validate:"omitempty"`
	RoleValue              *CentralNodeRoleRole      `json:"role,omitempty" validate:"omitempty,oneof=streamer inference identification"`
	StatsValue             *PeerStatsImpl            `json:"stats,omitempty" validate:"omitempty"`
	TotalBandwidthValue    *Speed                    `json:"total_bandwidth,omitempty" validate:"omitempty"`
	ZonesValue             []string                  `json:"zones,omitempty" validate:"omitempty"`
}

type StreamersListImpl struct {
	TimingValue         any             `json:"timing,omitempty" validate:"omitempty"`
	EstimatedCountValue *int            `json:"estimated_count,omitempty" validate:"omitempty"`
	NextValue           *string         `json:"next,omitempty" validate:"omitempty"`
	PrevValue           *string         `json:"prev,omitempty" validate:"omitempty"`
	StreamersValue      []*StreamerImpl `json:"streamers,omitempty" validate:"omitempty"`
}

type StreamsListImpl struct {
	TimingValue         any                 `json:"timing,omitempty" validate:"omitempty"`
	EstimatedCountValue *int                `json:"estimated_count,omitempty" validate:"omitempty"`
	NextValue           *string             `json:"next,omitempty" validate:"omitempty"`
	PrevValue           *string             `json:"prev,omitempty" validate:"omitempty"`
	StreamsValue        []*StreamConfigImpl `json:"streams,omitempty" validate:"omitempty"`
}

// Array of streams with settings
type StreamsMultieditConfigImpl struct {
	StreamsValue []*StreamConfigMultieditImpl `json:"streams,omitempty" validate:"omitempty"`
}

// Array of streams with zone settings
type StreamsZoneSettingsImpl struct {
	StreamsValue []any `json:"streams,omitempty" validate:"omitempty"`
}

// System settings
type SystemConfigImpl struct {
	APIURLValue                   *URL           `json:"api_url,omitempty" validate:"omitempty"`
	CentralURLValue               *URL           `json:"central_url,omitempty" validate:"omitempty"`
	CustomAuthValue               *URL           `json:"custom_auth,omitempty" validate:"omitempty"`
	DatabaseValue                 *DatabaseImpl  `json:"database,omitempty" validate:"omitempty"`
	LicenseKeyValue               *string        `json:"license_key,omitempty" validate:"omitempty"`
	ListenersValue                *ListenersImpl `json:"listeners,omitempty" validate:"omitempty"`
	LoglevelValue                 *Loglevel      `json:"loglevel,omitempty" validate:"omitempty"`
	WatcherBruteForceTimeoutValue *int           `json:"watcher_brute_force_timeout,omitempty" validate:"omitempty"`
}

// Required: tag, hex
type TSDescriptorImpl struct {
	HexValue Hexbinary `json:"hex" validate:"required"`
	TagValue int       `json:"tag" validate:"required"`
}

type TSEitIntervalsImpl struct {
	ActualValue *int `json:"actual,omitempty" validate:"omitempty"`
	OtherValue  *int `json:"other,omitempty" validate:"omitempty"`
}

type TSTimeoutsImpl struct {
	MediaInfoValue   *int `json:"media_info,omitempty" validate:"omitempty"`
	ServiceTypeValue *int `json:"service_type,omitempty" validate:"omitempty"`
}

type TSVersionsImpl struct {
	CatValue *int `json:"cat,omitempty" validate:"omitempty"`
	NitValue *int `json:"nit,omitempty" validate:"omitempty"`
	PatValue *int `json:"pat,omitempty" validate:"omitempty"`
	PmtValue *int `json:"pmt,omitempty" validate:"omitempty"`
	PsiValue *int `json:"psi,omitempty" validate:"omitempty"`
	SdtValue *int `json:"sdt,omitempty" validate:"omitempty"`
}

type TemplateConfigImpl struct {
	DisabledValue *bool               `json:"disabled,omitempty" validate:"omitempty"`
	DvrValue      *StreamDvrSpecImpl  `json:"dvr,omitempty" validate:"omitempty"`
	LabelsValue   map[string]UnixName `json:"labels,omitempty" validate:"omitempty,dive,min=1,max=40"`
	StaticValue   *bool               `json:"static,omitempty" validate:"omitempty"`
	VisionValue   *VisionSpecImpl     `json:"vision,omitempty" validate:"omitempty"`
	InputsValue   []StreamInput       `json:"inputs,omitempty" validate:"omitempty"`
	PushesValue   []StreamPush        `json:"pushes,omitempty" validate:"omitempty"`
}

type TemplateConfigSpecificImpl struct {
}

type ThumbnailsSpecImpl struct {
	EnabledValue any `json:"enabled,omitempty" validate:"omitempty"`
}

type TlsCertificateImpl struct {
	CacertValue                     *CertificateInfoImpl   `json:"cacert,omitempty" validate:"omitempty"`
	CertValue                       *CertificateInfoImpl   `json:"cert,omitempty" validate:"omitempty"`
	PrivateKeyMatchCertificateValue *bool                  `json:"private_key_match_certificate,omitempty" validate:"omitempty"`
	FullchainValue                  []*CertificateInfoImpl `json:"fullchain,omitempty" validate:"omitempty"`
}

type TrackInfoImpl struct {
	TrackIDValue        any                   `json:"track_id,omitempty" validate:"omitempty"`
	LanguageValue       *string               `json:"language,omitempty" validate:"omitempty"`
	PixFmtValue         *FrameVideoPixFmt     `json:"pix_fmt,omitempty" validate:"omitempty"`
	BframesValue        *int                  `json:"bframes,omitempty" validate:"omitempty"`
	BitrateValue        *Speed                `json:"bitrate,omitempty" validate:"omitempty"`
	ChannelsValue       *int                  `json:"channels,omitempty" validate:"omitempty"`
	WidthValue          *Pixels               `json:"width,omitempty" validate:"omitempty"`
	CodecValue          *FrameCodec           `json:"codec,omitempty" validate:"omitempty"`
	AvgGopValue         *int                  `json:"avg_gop,omitempty" validate:"omitempty"`
	FPSValue            *float64              `json:"fps,omitempty" validate:"omitempty"`
	FrameDurationValue  *Ticks                `json:"frame_duration,omitempty" validate:"omitempty"`
	GopSizeValue        *int                  `json:"gop_size,omitempty" validate:"omitempty"`
	HeightValue         *Pixels               `json:"height,omitempty" validate:"omitempty"`
	IsProgressiveValue  *bool                 `json:"is_progressive,omitempty" validate:"omitempty"`
	AvgFPSValue         *float64              `json:"avg_fps,omitempty" validate:"omitempty"`
	BandwidthValue      *Speed                `json:"bandwidth,omitempty" validate:"omitempty"`
	LevelValue          *string               `json:"level,omitempty" validate:"omitempty"`
	LastGopValue        *int                  `json:"last_gop,omitempty" validate:"omitempty"`
	NumRefsFramesValue  *int                  `json:"num_refs_frames,omitempty" validate:"omitempty,min=0,max=32"`
	PidValue            *int                  `json:"pid,omitempty" validate:"omitempty"`
	LengthSizeValue     *int                  `json:"length_size,omitempty" validate:"omitempty"`
	PixelHeightValue    *Pixels               `json:"pixel_height,omitempty" validate:"omitempty"`
	PixelWidthValue     *Pixels               `json:"pixel_width,omitempty" validate:"omitempty"`
	ProfileValue        *string               `json:"profile,omitempty" validate:"omitempty"`
	SampleRateValue     *int                  `json:"sample_rate,omitempty" validate:"omitempty"`
	SarHeightValue      *int                  `json:"sar_height,omitempty" validate:"omitempty"`
	SarWidthValue       *int                  `json:"sar_width,omitempty" validate:"omitempty"`
	TitleValue          *string               `json:"title,omitempty" validate:"omitempty"`
	ContentValue        FrameContent          `json:"content" validate:"required"`
	ClosedCaptionsValue []*ClosedCaptionsImpl `json:"closed_captions,omitempty" validate:"omitempty"`
}

type TrackInfoApplicationImpl struct {
	TrackIDValue       any          `json:"track_id,omitempty" validate:"omitempty"`
	AvgFPSValue        *float64     `json:"avg_fps,omitempty" validate:"omitempty"`
	BandwidthValue     *Speed       `json:"bandwidth,omitempty" validate:"omitempty"`
	BitrateValue       *Speed       `json:"bitrate,omitempty" validate:"omitempty"`
	CodecValue         *FrameCodec  `json:"codec,omitempty" validate:"omitempty"`
	FrameDurationValue *Ticks       `json:"frame_duration,omitempty" validate:"omitempty"`
	LanguageValue      *string      `json:"language,omitempty" validate:"omitempty"`
	PidValue           *int         `json:"pid,omitempty" validate:"omitempty"`
	TitleValue         *string      `json:"title,omitempty" validate:"omitempty"`
	ContentValue       FrameContent `json:"content" validate:"required"`
}

type TrackInfoApplicationSpecificImpl struct {
	LanguageValue *string `json:"language,omitempty" validate:"omitempty"`
}

type TrackInfoAudioImpl struct {
	TrackIDValue       any          `json:"track_id,omitempty" validate:"omitempty"`
	AvgFPSValue        *float64     `json:"avg_fps,omitempty" validate:"omitempty"`
	BandwidthValue     *Speed       `json:"bandwidth,omitempty" validate:"omitempty"`
	BitrateValue       *Speed       `json:"bitrate,omitempty" validate:"omitempty"`
	ChannelsValue      *int         `json:"channels,omitempty" validate:"omitempty"`
	CodecValue         *FrameCodec  `json:"codec,omitempty" validate:"omitempty"`
	FrameDurationValue *Ticks       `json:"frame_duration,omitempty" validate:"omitempty"`
	LanguageValue      *string      `json:"language,omitempty" validate:"omitempty"`
	PidValue           *int         `json:"pid,omitempty" validate:"omitempty"`
	SampleRateValue    *int         `json:"sample_rate,omitempty" validate:"omitempty"`
	TitleValue         *string      `json:"title,omitempty" validate:"omitempty"`
	ContentValue       FrameContent `json:"content" validate:"required"`
}

type TrackInfoAudioSpecificImpl struct {
	ChannelsValue   *int    `json:"channels,omitempty" validate:"omitempty"`
	LanguageValue   *string `json:"language,omitempty" validate:"omitempty"`
	SampleRateValue *int    `json:"sample_rate,omitempty" validate:"omitempty"`
}

type TrackInfoBaseImpl struct {
	AvgFPSValue        *float64 `json:"avg_fps,omitempty" validate:"omitempty"`
	BandwidthValue     *Speed   `json:"bandwidth,omitempty" validate:"omitempty"`
	FrameDurationValue *Ticks   `json:"frame_duration,omitempty" validate:"omitempty"`
	TrackIDValue       any      `json:"track_id,omitempty" validate:"omitempty"`
}

// Required: content
type TrackInfoBaseConfigurableImpl struct {
	BitrateValue *Speed       `json:"bitrate,omitempty" validate:"omitempty"`
	PidValue     *int         `json:"pid,omitempty" validate:"omitempty"`
	TitleValue   *string      `json:"title,omitempty" validate:"omitempty"`
	ContentValue FrameContent `json:"content" validate:"required"`
}

type TrackInfoMetadataImpl struct {
	TrackIDValue       any          `json:"track_id,omitempty" validate:"omitempty"`
	AvgFPSValue        *float64     `json:"avg_fps,omitempty" validate:"omitempty"`
	BandwidthValue     *Speed       `json:"bandwidth,omitempty" validate:"omitempty"`
	BitrateValue       *Speed       `json:"bitrate,omitempty" validate:"omitempty"`
	CodecValue         *FrameCodec  `json:"codec,omitempty" validate:"omitempty"`
	FrameDurationValue *Ticks       `json:"frame_duration,omitempty" validate:"omitempty"`
	PidValue           *int         `json:"pid,omitempty" validate:"omitempty"`
	TitleValue         *string      `json:"title,omitempty" validate:"omitempty"`
	ContentValue       FrameContent `json:"content" validate:"required"`
}

type TrackInfoTextImpl struct {
	TrackIDValue       any          `json:"track_id,omitempty" validate:"omitempty"`
	AvgFPSValue        *float64     `json:"avg_fps,omitempty" validate:"omitempty"`
	BandwidthValue     *Speed       `json:"bandwidth,omitempty" validate:"omitempty"`
	BitrateValue       *Speed       `json:"bitrate,omitempty" validate:"omitempty"`
	CodecValue         *FrameCodec  `json:"codec,omitempty" validate:"omitempty"`
	FrameDurationValue *Ticks       `json:"frame_duration,omitempty" validate:"omitempty"`
	LanguageValue      *string      `json:"language,omitempty" validate:"omitempty"`
	PidValue           *int         `json:"pid,omitempty" validate:"omitempty"`
	TitleValue         *string      `json:"title,omitempty" validate:"omitempty"`
	ContentValue       FrameContent `json:"content" validate:"required"`
}

type TrackInfoTextSpecificImpl struct {
	LanguageValue *string `json:"language,omitempty" validate:"omitempty"`
}

type TrackInfoVideoImpl struct {
	TrackIDValue        any                   `json:"track_id,omitempty" validate:"omitempty"`
	IsProgressiveValue  *bool                 `json:"is_progressive,omitempty" validate:"omitempty"`
	SarWidthValue       *int                  `json:"sar_width,omitempty" validate:"omitempty"`
	BframesValue        *int                  `json:"bframes,omitempty" validate:"omitempty"`
	BitrateValue        *Speed                `json:"bitrate,omitempty" validate:"omitempty"`
	WidthValue          *Pixels               `json:"width,omitempty" validate:"omitempty"`
	CodecValue          *FrameCodec           `json:"codec,omitempty" validate:"omitempty"`
	AvgGopValue         *int                  `json:"avg_gop,omitempty" validate:"omitempty"`
	FPSValue            *float64              `json:"fps,omitempty" validate:"omitempty"`
	FrameDurationValue  *Ticks                `json:"frame_duration,omitempty" validate:"omitempty"`
	GopSizeValue        *int                  `json:"gop_size,omitempty" validate:"omitempty"`
	HeightValue         *Pixels               `json:"height,omitempty" validate:"omitempty"`
	AvgFPSValue         *float64              `json:"avg_fps,omitempty" validate:"omitempty"`
	BandwidthValue      *Speed                `json:"bandwidth,omitempty" validate:"omitempty"`
	LastGopValue        *int                  `json:"last_gop,omitempty" validate:"omitempty"`
	PixelHeightValue    *Pixels               `json:"pixel_height,omitempty" validate:"omitempty"`
	NumRefsFramesValue  *int                  `json:"num_refs_frames,omitempty" validate:"omitempty,min=0,max=32"`
	PidValue            *int                  `json:"pid,omitempty" validate:"omitempty"`
	PixFmtValue         *FrameVideoPixFmt     `json:"pix_fmt,omitempty" validate:"omitempty"`
	LevelValue          *string               `json:"level,omitempty" validate:"omitempty"`
	PixelWidthValue     *Pixels               `json:"pixel_width,omitempty" validate:"omitempty"`
	ProfileValue        *string               `json:"profile,omitempty" validate:"omitempty"`
	SarHeightValue      *int                  `json:"sar_height,omitempty" validate:"omitempty"`
	LengthSizeValue     *int                  `json:"length_size,omitempty" validate:"omitempty"`
	TitleValue          *string               `json:"title,omitempty" validate:"omitempty"`
	ContentValue        FrameContent          `json:"content" validate:"required"`
	ClosedCaptionsValue []*ClosedCaptionsImpl `json:"closed_captions,omitempty" validate:"omitempty"`
}

type TrackInfoVideoConfigurableImpl struct {
	BframesValue       *int              `json:"bframes,omitempty" validate:"omitempty"`
	FPSValue           *float64          `json:"fps,omitempty" validate:"omitempty"`
	GopSizeValue       *int              `json:"gop_size,omitempty" validate:"omitempty"`
	HeightValue        *Pixels           `json:"height,omitempty" validate:"omitempty"`
	LevelValue         *string           `json:"level,omitempty" validate:"omitempty"`
	NumRefsFramesValue *int              `json:"num_refs_frames,omitempty" validate:"omitempty,min=0,max=32"`
	PixFmtValue        *FrameVideoPixFmt `json:"pix_fmt,omitempty" validate:"omitempty"`
	PixelHeightValue   *Pixels           `json:"pixel_height,omitempty" validate:"omitempty"`
	PixelWidthValue    *Pixels           `json:"pixel_width,omitempty" validate:"omitempty"`
	ProfileValue       *string           `json:"profile,omitempty" validate:"omitempty"`
	SarHeightValue     *int              `json:"sar_height,omitempty" validate:"omitempty"`
	SarWidthValue      *int              `json:"sar_width,omitempty" validate:"omitempty"`
	WidthValue         *Pixels           `json:"width,omitempty" validate:"omitempty"`
}

type TrackInfoVideoSpecificImpl struct {
	AvgGopValue         *int                  `json:"avg_gop,omitempty" validate:"omitempty"`
	IsProgressiveValue  *bool                 `json:"is_progressive,omitempty" validate:"omitempty"`
	LastGopValue        *int                  `json:"last_gop,omitempty" validate:"omitempty"`
	LengthSizeValue     *int                  `json:"length_size,omitempty" validate:"omitempty"`
	ClosedCaptionsValue []*ClosedCaptionsImpl `json:"closed_captions,omitempty" validate:"omitempty"`
}

type TranscoderDeviceStatsImpl struct {
	CanInterlaceValue    *bool              `json:"can_interlace,omitempty" validate:"omitempty"`
	CanInternalValue     *bool              `json:"can_internal,omitempty" validate:"omitempty"`
	CanLogoValue         *bool              `json:"can_logo,omitempty" validate:"omitempty"`
	GpuDecValue          *int               `json:"gpu_dec,omitempty" validate:"omitempty"`
	GpuEncValue          *int               `json:"gpu_enc,omitempty" validate:"omitempty"`
	GpuSmValue           *int               `json:"gpu_sm,omitempty" validate:"omitempty"`
	GpuTempValue         *int               `json:"gpu_temp,omitempty" validate:"omitempty"`
	IDValue              *TcDeviceid        `json:"id,omitempty" validate:"omitempty"`
	MemfreeValue         *int               `json:"memFree,omitempty" validate:"omitempty"`
	MemtotalValue        *int               `json:"memTotal,omitempty" validate:"omitempty"`
	MemusedValue         *int               `json:"memUsed,omitempty" validate:"omitempty"`
	NameValue            *string            `json:"name,omitempty" validate:"omitempty"`
	ReconfigSupportValue *TcReconfigSupport `json:"reconfig_support,omitempty" validate:"omitempty"`
	TypeValue            *TranscoderDevice  `json:"type,omitempty" validate:"omitempty"`
}

// Required: name
type TransponderConfigImpl struct {
	VideoBufferValue       *int                         `json:"video_buffer,omitempty" validate:"omitempty"`
	EitValue               *TransponderEitImpl          `json:"eit,omitempty" validate:"omitempty"`
	NetworkIDValue         *int                         `json:"network_id,omitempty" validate:"omitempty"`
	NetworkNameValue       *string                      `json:"network_name,omitempty" validate:"omitempty"`
	OriginalNetworkIDValue *int                         `json:"original_network_id,omitempty" validate:"omitempty"`
	TimeoutsValue          *TSTimeoutsImpl              `json:"timeouts,omitempty" validate:"omitempty"`
	PrebufferValue         *Milliseconds                `json:"prebuffer,omitempty" validate:"omitempty"`
	BitrateValue           *Speed                       `json:"bitrate,omitempty" validate:"omitempty"`
	ProviderValue          *string                      `json:"provider,omitempty" validate:"omitempty"`
	VersionsValue          *TSVersionsImpl              `json:"versions,omitempty" validate:"omitempty"`
	StatsValue             *MultiplexerStatsImpl        `json:"stats,omitempty" validate:"omitempty"`
	TSStreamIDValue        *int                         `json:"ts_stream_id,omitempty" validate:"omitempty"`
	NameValue              MediaName                    `json:"name" validate:"required" openmetrics_label:"name"`
	ProgramsValue          []*TransponderProgramImpl    `json:"programs,omitempty" validate:"omitempty"`
	TSDescriptorsValue     []*TSDescriptorImpl          `json:"ts_descriptors,omitempty" validate:"omitempty"`
	TimeOffsetsValue       []*TransponderTimeOffsetImpl `json:"time_offsets,omitempty" validate:"omitempty"`
	PushesValue            []*TransponderPushImpl       `json:"pushes,omitempty" validate:"omitempty"`
	OthersValue            []*TransponderOtherImpl      `json:"others,omitempty" validate:"omitempty"`
}

type TransponderEitImpl struct {
	IntervalsPfValue       *TSEitIntervalsImpl `json:"intervals_pf,omitempty" validate:"omitempty"`
	IntervalsScheduleValue *TSEitIntervalsImpl `json:"intervals_schedule,omitempty" validate:"omitempty"`
	KeepEpgValue           *Seconds            `json:"keep_epg,omitempty" validate:"omitempty"`
	MaxBitrateValue        *MaxBitrate         `json:"max_bitrate,omitempty" validate:"omitempty"`
	XmltvURLValue          *string             `json:"xmltv_url,omitempty" validate:"omitempty"`
}

// Required: name
type TransponderOtherImpl struct {
	NameValue MediaName `json:"name" validate:"required"`
}

// Required: pid, content, track
type TransponderPidImpl struct {
	BitrateValue    *Speed               `json:"bitrate,omitempty" validate:"omitempty"`
	CodecValue      *FrameCodec          `json:"codec,omitempty" validate:"omitempty"`
	EsInfoValue     *Hexbinary           `json:"es_info,omitempty" validate:"omitempty"`
	StatsValue      *PushPidCountersImpl `json:"stats,omitempty" validate:"omitempty"`
	StreamTypeValue *int                 `json:"stream_type,omitempty" validate:"omitempty,min=1,max=255"`
	ContentValue    string               `json:"content" validate:"required"`
	PidValue        int                  `json:"pid" validate:"required" openmetrics_label:"pid"`
	TrackValue      int                  `json:"track" validate:"required"`
}

// Required: program_id
type TransponderProgramImpl struct {
	EitTitleValue    *string               `json:"eit_title,omitempty" validate:"omitempty"`
	LcnValue         *int                  `json:"lcn,omitempty" validate:"omitempty"`
	PidsValue        *OutputMpegtsPidsImpl `json:"pids,omitempty" validate:"omitempty"`
	ServiceTypeValue *TSServiceType        `json:"service_type,omitempty" validate:"omitempty"`
	SourceValue      *MediaName            `json:"source,omitempty" validate:"omitempty" openmetrics_label:"source"`
	TitleValue       *string               `json:"title,omitempty" validate:"omitempty"`
	ProgramIDValue   int                   `json:"program_id" validate:"required" openmetrics_label:"program_id"`
}

// Required: pnr
type TransponderProgramStatsImpl struct {
	ErrorsProgramResetValue    *int `json:"errors_program_reset,omitempty" validate:"omitempty"`
	ErrorsScte35AnnouncesValue *int `json:"errors_scte35_announces,omitempty" validate:"omitempty"`
	OutputDtsShiftChangedValue *int `json:"output_dts_shift_changed,omitempty" validate:"omitempty"`
	Scte35AnnouncesValue       *int `json:"scte35_announces,omitempty" validate:"omitempty"`
	PnrValue                   int  `json:"pnr" validate:"required"`
}

// Required: url
type TransponderPushImpl struct {
	MulticastLoopValue *bool             `json:"multicast_loop,omitempty" validate:"omitempty"`
	StandbyValue       *bool             `json:"standby,omitempty" validate:"omitempty"`
	StatsValue         *PushCountersImpl `json:"stats,omitempty" validate:"omitempty"`
	TosValue           *int              `json:"tos,omitempty" validate:"omitempty"`
	URLValue           string            `json:"url" validate:"required"`
}

// Required: country
type TransponderTimeOffsetImpl struct {
	LocalTimeOffsetValue *string `json:"local_time_offset,omitempty" validate:"omitempty"`
	NextTimeOffsetValue  *string `json:"next_time_offset,omitempty" validate:"omitempty"`
	RegionValue          *int    `json:"region,omitempty" validate:"omitempty"`
	TimeOfChangeValue    *int    `json:"time_of_change,omitempty" validate:"omitempty"`
	CountryValue         string  `json:"country" validate:"required"`
}

type UserImpl struct {
	LocaleValue        *ISO6391                          `json:"locale,omitempty" validate:"omitempty"`
	PhoneValue         *PhoneNumber                      `json:"phone,omitempty" validate:"omitempty"`
	DisabledValue      *bool                             `json:"disabled,omitempty" validate:"omitempty"`
	EmailValue         *Email                            `json:"email,omitempty" validate:"omitempty"`
	FullnameValue      *string                           `json:"fullname,omitempty" validate:"omitempty"`
	IDValue            *int                              `json:"id,omitempty" validate:"omitempty"`
	NameValue          *string                           `json:"name,omitempty" validate:"omitempty"`
	AccessLevelValue   *UserAdminAccessLevel             `json:"access_level,omitempty" validate:"omitempty,oneof=generic admin"`
	CreatedAtValue     *UtcMs                            `json:"created_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	NoteValue          *string                           `json:"note,omitempty" validate:"omitempty"`
	ReadonlyValue      *bool                             `json:"readonly,omitempty" validate:"omitempty"`
	PasswordValue      *string                           `json:"password,omitempty" validate:"omitempty"`
	MaxSessionsValue   *int                              `json:"max_sessions,omitempty" validate:"omitempty"`
	OrganizationsValue []*UserAdminOrganizationsItemImpl `json:"organizations,omitempty" validate:"omitempty"`
}

// User Parameters available from Admin API.
type UserAdminImpl struct {
	AccessLevelValue   *UserAdminAccessLevel             `json:"access_level,omitempty" validate:"omitempty,oneof=generic admin"`
	DisabledValue      *bool                             `json:"disabled,omitempty" validate:"omitempty"`
	IDValue            *int                              `json:"id,omitempty" validate:"omitempty"`
	ReadonlyValue      *bool                             `json:"readonly,omitempty" validate:"omitempty"`
	OrganizationsValue []*UserAdminOrganizationsItemImpl `json:"organizations,omitempty" validate:"omitempty"`
}

type UserAdminOrganizationsItemImpl struct {
	IDValue          *int                                 `json:"id,omitempty" validate:"omitempty"`
	OwnerValue       *UserAdminOrganizationsItemOwnerImpl `json:"owner,omitempty" validate:"omitempty"`
	PermissionsValue *OrganizationPermissionsImpl         `json:"permissions,omitempty" validate:"omitempty"`
	TitleValue       *string                              `json:"title,omitempty" validate:"omitempty"`
}

// Owner properties.
type UserAdminOrganizationsItemOwnerImpl struct {
	IDValue   *int    `json:"id,omitempty" validate:"omitempty"`
	NameValue *string `json:"name,omitempty" validate:"omitempty"`
}

// User parameters visible from Admin and Client APIs.
type UserBaseImpl struct {
	CreatedAtValue   *UtcMs       `json:"created_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	EmailValue       *Email       `json:"email,omitempty" validate:"omitempty"`
	FullnameValue    *string      `json:"fullname,omitempty" validate:"omitempty"`
	LocaleValue      *ISO6391     `json:"locale,omitempty" validate:"omitempty"`
	MaxSessionsValue *int         `json:"max_sessions,omitempty" validate:"omitempty"`
	NameValue        *string      `json:"name,omitempty" validate:"omitempty"`
	NoteValue        *string      `json:"note,omitempty" validate:"omitempty"`
	PasswordValue    *string      `json:"password,omitempty" validate:"omitempty"`
	PhoneValue       *PhoneNumber `json:"phone,omitempty" validate:"omitempty"`
}

type UserCreateImpl struct {
	LocaleValue         *ISO6391                          `json:"locale,omitempty" validate:"omitempty"`
	OrganizationIDValue *int                              `json:"organization_id,omitempty" validate:"omitempty"`
	DisabledValue       *bool                             `json:"disabled,omitempty" validate:"omitempty"`
	EmailValue          *Email                            `json:"email,omitempty" validate:"omitempty"`
	FullnameValue       *string                           `json:"fullname,omitempty" validate:"omitempty"`
	IDValue             *int                              `json:"id,omitempty" validate:"omitempty"`
	CreatedAtValue      *UtcMs                            `json:"created_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	NameValue           *string                           `json:"name,omitempty" validate:"omitempty"`
	AccessLevelValue    *UserAdminAccessLevel             `json:"access_level,omitempty" validate:"omitempty,oneof=generic admin"`
	NoteValue           *string                           `json:"note,omitempty" validate:"omitempty"`
	MaxSessionsValue    *int                              `json:"max_sessions,omitempty" validate:"omitempty"`
	ReadonlyValue       *bool                             `json:"readonly,omitempty" validate:"omitempty"`
	PasswordValue       *string                           `json:"password,omitempty" validate:"omitempty"`
	PhoneValue          *PhoneNumber                      `json:"phone,omitempty" validate:"omitempty"`
	OrganizationsValue  []*UserAdminOrganizationsItemImpl `json:"organizations,omitempty" validate:"omitempty"`
}

type UsersImpl struct {
	EstimatedCountValue *int        `json:"estimated_count,omitempty" validate:"omitempty"`
	NextValue           *string     `json:"next,omitempty" validate:"omitempty"`
	PrevValue           *string     `json:"prev,omitempty" validate:"omitempty"`
	TimingValue         any         `json:"timing,omitempty" validate:"omitempty"`
	UsersListValue      []*UserImpl `json:"users_list,omitempty" validate:"omitempty"`
}

type VisionAlertsImpl struct {
	LowQualityAtValue          *UtcMs `json:"low_quality_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	NotEnoughDetectionsAtValue *UtcMs `json:"not_enough_detections_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	SmallSizeAtValue           *UtcMs `json:"small_size_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
}

// Required: detector_type, region_id
type VisionDetectorConfigImpl struct {
	DetectorTypeValue      *VisionDetectorConfigDetectorTypeImpl      `json:"detector_type" validate:"required"`
	RegionCoordinatesValue *VisionDetectorConfigRegionCoordinatesImpl `json:"region_coordinates,omitempty" validate:"omitempty"`
	RegionTitleValue       *string                                    `json:"region_title,omitempty" validate:"omitempty"`
	StatsValue             *VisionDetectorStatsImpl                   `json:"stats,omitempty" validate:"omitempty"`
	RegionIDValue          string                                     `json:"region_id" validate:"required"`
}

type VisionDetectorConfigDetectorTypeImpl struct {
}

type VisionDetectorConfigRegionCoordinatesImpl struct {
}

type VisionDetectorStatsImpl struct {
	AlertsValue          *VisionAlertsImpl `json:"alerts,omitempty" validate:"omitempty"`
	LastDetectionAtValue *UtcMs            `json:"last_detection_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
}

// 2D point
// Required: x, y
type VisionPointImpl struct {
	XValue float64 `json:"x" validate:"required,min=0,max=1"`
	YValue float64 `json:"y" validate:"required,min=0,max=1"`
}

type VisionSpecImpl struct {
	AlgValue       *VisionSpecAlg              `json:"alg,omitempty" validate:"omitempty,oneof=faces plates"`
	AreasValue     *string                     `json:"areas,omitempty" validate:"omitempty"`
	DetectorsValue []*VisionDetectorConfigImpl `json:"detectors,omitempty" validate:"omitempty"`
}

type VisionSpecPresetsImpl struct {
	AlgValue *VisionSpecPresetsAlg `json:"alg,omitempty" validate:"omitempty,oneof=faces plates"`
}

type VodConfigImpl struct {
	PositionValue        *SortIndex             `json:"position,omitempty" validate:"omitempty"`
	ProtocolsValue       *PlayProtocolsSpecImpl `json:"protocols,omitempty" validate:"omitempty"`
	CacheValue           *CacheSpecImpl         `json:"cache,omitempty" validate:"omitempty"`
	DisabledValue        *bool                  `json:"disabled,omitempty" validate:"omitempty"`
	DownloadValue        *bool                  `json:"download,omitempty" validate:"omitempty"`
	DrmValue             *DrmSpecImpl           `json:"drm,omitempty" validate:"omitempty"`
	LogoValue            *WebLogoSpecImpl       `json:"logo,omitempty" validate:"omitempty"`
	OnPlayValue          *AuthSpecImpl          `json:"on_play,omitempty" validate:"omitempty"`
	AutoMbrValue         *bool                  `json:"auto_mbr,omitempty" validate:"omitempty"`
	AddAudioOnlyValue    *bool                  `json:"add_audio_only,omitempty" validate:"omitempty"`
	PrefixValue          *MediaName             `json:"prefix,omitempty" validate:"omitempty"`
	ProviderValue        *string                `json:"provider,omitempty" validate:"omitempty"`
	ReadQueueValue       *int                   `json:"read_queue,omitempty" validate:"omitempty"`
	SegmentDurationValue *Milliseconds          `json:"segment_duration,omitempty" validate:"omitempty"`
	URLPrefixValue       *URLPrefix             `json:"url_prefix,omitempty" validate:"omitempty"`
	ThumbnailsValue      *ThumbnailsSpecImpl    `json:"thumbnails,omitempty" validate:"omitempty"`
	TimeoutValue         *int                   `json:"timeout,omitempty" validate:"omitempty"`
	StoragesValue        []*VodStorageImpl      `json:"storages,omitempty" validate:"omitempty"`
}

type VodStorageImpl struct {
	ExtraValue map[string]string `json:"extra,omitempty" validate:"omitempty"`
	URLValue   *string           `json:"url,omitempty" validate:"omitempty"`
}

type VsaasConfigImpl struct {
	CentralURLValue *string `json:"central_url,omitempty" validate:"omitempty"`
	WatcherURLValue *string `json:"watcher_url,omitempty" validate:"omitempty"`
}

type WatcherAgentConfigImpl struct {
	IDValue      *string                `json:"id,omitempty" validate:"omitempty"`
	KeyValue     *string                `json:"key,omitempty" validate:"omitempty"`
	ModelValue   *string                `json:"model,omitempty" validate:"omitempty"`
	SerialValue  *string                `json:"serial,omitempty" validate:"omitempty"`
	StatsValue   *WatcherAgentStatsImpl `json:"stats,omitempty" validate:"omitempty"`
	StreamsValue []any                  `json:"streams,omitempty" validate:"omitempty"`
}

type WatcherAgentControlConnectionImpl struct {
	AliveValue           *bool   `json:"alive,omitempty" validate:"omitempty"`
	BytesFromServerValue *Bytes  `json:"bytes_from_server,omitempty" validate:"omitempty"`
	BytesToServerValue   *Bytes  `json:"bytes_to_server,omitempty" validate:"omitempty"`
	HostnameValue        *string `json:"hostname,omitempty" validate:"omitempty"`
	OpenedAtValue        *UtcMs  `json:"opened_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	StatusChangedAtValue *Utc    `json:"status_changed_at,omitempty" validate:"omitempty,min=1e+09,max=1e+10"`
}

type WatcherAgentDataConnectionsImpl struct {
	ConnectionsAttemptedValue *int `json:"connections_attempted,omitempty" validate:"omitempty"`
	ConnectionsCurrentValue   *int `json:"connections_current,omitempty" validate:"omitempty"`
	ConnectionsOpenedValue    *int `json:"connections_opened,omitempty" validate:"omitempty"`
}

type WatcherAgentStatsImpl struct {
	AgentTypeValue              *string                                     `json:"agent_type,omitempty" validate:"omitempty"`
	ConnectionsEstablishedValue *int                                        `json:"connections_established,omitempty" validate:"omitempty"`
	ConnectionsRequestedValue   *int                                        `json:"connections_requested,omitempty" validate:"omitempty"`
	EndpointConnectionValue     *WatcherAgentControlConnectionImpl          `json:"endpoint_connection,omitempty" validate:"omitempty"`
	LocalIPValue                *Ipv4                                       `json:"local_ip,omitempty" validate:"omitempty"`
	MacAddressValue             *string                                     `json:"mac_address,omitempty" validate:"omitempty"`
	PeerIPValue                 *Ipv4                                       `json:"peer_ip,omitempty" validate:"omitempty"`
	StreampointConnectionValue  *WatcherAgentStatsStreampointConnectionImpl `json:"streampoint_connection,omitempty" validate:"omitempty"`
	VersionValue                *string                                     `json:"version,omitempty" validate:"omitempty"`
}

// Parameters of the connection between Agent and its streampoint.
type WatcherAgentStatsStreampointConnectionImpl struct {
	AliveValue                *bool   `json:"alive,omitempty" validate:"omitempty"`
	BytesFromServerValue      *Bytes  `json:"bytes_from_server,omitempty" validate:"omitempty"`
	BytesToServerValue        *Bytes  `json:"bytes_to_server,omitempty" validate:"omitempty"`
	ConnectionsAttemptedValue *int    `json:"connections_attempted,omitempty" validate:"omitempty"`
	ConnectionsCurrentValue   *int    `json:"connections_current,omitempty" validate:"omitempty"`
	ConnectionsOpenedValue    *int    `json:"connections_opened,omitempty" validate:"omitempty"`
	HostnameValue             *string `json:"hostname,omitempty" validate:"omitempty"`
	OpenedAtValue             *UtcMs  `json:"opened_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	StatusChangedAtValue      *Utc    `json:"status_changed_at,omitempty" validate:"omitempty,min=1e+09,max=1e+10"`
}

type WatcherStatusImpl struct {
	ChecksValue     *WatcherStatusChecksImpl `json:"checks,omitempty" validate:"omitempty"`
	OperatorIDValue *int                     `json:"operator_id,omitempty" validate:"omitempty"`
}

// List of Watcher checks
type WatcherStatusChecksImpl struct {
	IsDomainAPIKeyMatchedValue *bool                                       `json:"is_domain_api_key_matched,omitempty" validate:"omitempty"`
	IsWatcherURLAvailableValue *bool                                       `json:"is_watcher_url_available,omitempty" validate:"omitempty"`
	IsWatcherURLMatchedValue   *bool                                       `json:"is_watcher_url_matched,omitempty" validate:"omitempty"`
	ErrorsDetailsValue         []*WatcherStatusChecksErrorsDetailsItemImpl `json:"errors_details,omitempty" validate:"omitempty"`
}

// Error details
type WatcherStatusChecksErrorsDetailsItemImpl struct {
	CheckValue *string `json:"check,omitempty" validate:"omitempty"`
	ErrorValue *string `json:"error,omitempty" validate:"omitempty"`
}

type WatcherStreamConfigImpl struct {
	LastEpisodeAtValue          *UtcMs                        `json:"last_episode_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	LayoutRulesValue            *StreamZoneConfigImpl         `json:"layout_rules,omitempty" validate:"omitempty"`
	CoordinatesValue            *MapSpecImpl                  `json:"coordinates,omitempty" validate:"omitempty"`
	LayoutValue                 *CentralStreamLayoutImpl      `json:"layout,omitempty" validate:"omitempty"`
	DomainValue                 *DomainBaseImpl               `json:"domain,omitempty" validate:"omitempty"`
	FirmwareUpdateDurationValue *Milliseconds                 `json:"firmware_update_duration,omitempty" validate:"omitempty"`
	FolderIDValue               *int                          `json:"folder_id,omitempty" validate:"omitempty"`
	LastChangeValue             *AuditLogRecordImpl           `json:"last_change,omitempty" validate:"omitempty"`
	CanPublishValue             *bool                         `json:"can_publish,omitempty" validate:"omitempty"`
	AudioValue                  *WatcherStreamConfigAudioImpl `json:"audio,omitempty" validate:"omitempty"`
	CreatedAtValue              *UtcMs                        `json:"created_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	MapCoordinatesValue         *MapSpecImpl                  `json:"map_coordinates,omitempty" validate:"omitempty"`
	OnvifValue                  *StreamOnvifConfigImpl        `json:"onvif,omitempty" validate:"omitempty"`
	OrganizationValue           *OrganizationStreamImpl       `json:"organization,omitempty" validate:"omitempty"`
	OrganizationIDValue         *int                          `json:"organization_id,omitempty" validate:"omitempty"`
	PresetIDValue               *int                          `json:"preset_id,omitempty" validate:"omitempty"`
	PostalAddressValue          *string                       `json:"postal_address,omitempty" validate:"omitempty"`
	PresetValue                 *StreamPresetImpl             `json:"preset,omitempty" validate:"omitempty"`
	PathValue                   []*StreamPathItemImpl         `json:"path,omitempty" validate:"omitempty"`
}

// Audio settings for the stream.
type WatcherStreamConfigAudioImpl struct {
	DisabledValue            *bool            `json:"disabled,omitempty" validate:"omitempty"`
	TranscodeAudioCodecValue *FrameAudioCodec `json:"transcode_audio_codec,omitempty" validate:"omitempty"`
}

type WebLogoSpecImpl struct {
	BottomValue *int `json:"bottom,omitempty" validate:"omitempty"`
	HeightValue *int `json:"height,omitempty" validate:"omitempty"`
	LeftValue   *int `json:"left,omitempty" validate:"omitempty"`
	RightValue  *int `json:"right,omitempty" validate:"omitempty"`
	TopValue    *int `json:"top,omitempty" validate:"omitempty"`
	WidthValue  *int `json:"width,omitempty" validate:"omitempty"`
}

// Required: ports
type WebrtcRouterConfigImpl struct {
	TransportValue *WebrtcTransport `json:"transport,omitempty" validate:"omitempty"`
	PortsValue     []int            `json:"ports" validate:"required"`
}

// Required: name
type ZoneImpl struct {
	CreatedValue     *CreationInfoImpl `json:"created,omitempty" validate:"omitempty"`
	IsDedicatedValue *bool             `json:"is_dedicated,omitempty" validate:"omitempty"`
	StatsValue       *ZoneStatsImpl    `json:"stats,omitempty" validate:"omitempty"`
	NameValue        UnixName          `json:"name" validate:"required"`
}

// Statistics of the zone.
type ZoneStatsImpl struct {
	PreferredStreamsCountValue *int     `json:"preferred_streams_count,omitempty" validate:"omitempty"`
	RequiredStreamsCountValue  *int     `json:"required_streams_count,omitempty" validate:"omitempty"`
	StreamersCountValue        *int     `json:"streamers_count,omitempty" validate:"omitempty"`
	StreamersValue             []string `json:"streamers,omitempty" validate:"omitempty"`
}

type ZonesListImpl struct {
	EstimatedCountValue *int        `json:"estimated_count,omitempty" validate:"omitempty"`
	NextValue           *string     `json:"next,omitempty" validate:"omitempty"`
	PrevValue           *string     `json:"prev,omitempty" validate:"omitempty"`
	TimingValue         any         `json:"timing,omitempty" validate:"omitempty"`
	ZonesValue          []*ZoneImpl `json:"zones,omitempty" validate:"omitempty"`
}

// NewAPICall creates a new APICall instance
func NewAPICall() APICall {
	return &APICallImpl{}
}

// Creation date and time
// Format: date_time (date_time)
// Example: 2021-01-30T08:30:00.432567Z
func (s APICallImpl) CreatedAt() *DateTime {
	return s.CreatedAtValue
}

// Creation date and time
// Format: date_time (date_time)
// Example: 2021-01-30T08:30:00.432567Z
func (s *APICallImpl) SetCreatedAt(v DateTime) APICall {
	if s == nil {
		return nil
	}
	s.CreatedAtValue = &v
	return s
}

// Microseconds that this request took
// Format: microseconds (microseconds)
func (s APICallImpl) Duration() *Microseconds {
	return s.DurationValue
}

// Microseconds that this request took
// Format: microseconds (microseconds)
func (s *APICallImpl) SetDuration(v Microseconds) APICall {
	if s == nil {
		return nil
	}
	s.DurationValue = &v
	return s
}

// IP address of the caller.
// Format: ip (ip)
// Example: 192.34.32.10
func (s APICallImpl) IP() *IP {
	return s.IPValue
}

// IP address of the caller.
// Format: ip (ip)
// Example: 192.34.32.10
func (s *APICallImpl) SetIP(v IP) APICall {
	if s == nil {
		return nil
	}
	s.IPValue = &v
	return s
}

// API method ID.
// Example: streams_list
func (s APICallImpl) OperationID() *string {
	return s.OperationIDValue
}

// API method ID.
// Example: streams_list
func (s *APICallImpl) SetOperationID(v string) APICall {
	if s == nil {
		return nil
	}
	s.OperationIDValue = &v
	return s
}

// The program produced the API call. Content of `X-Originator` header.
// Example: flussonic
func (s APICallImpl) Originator() *string {
	return s.OriginatorValue
}

// The program produced the API call. Content of `X-Originator` header.
// Example: flussonic
func (s *APICallImpl) SetOriginator(v string) APICall {
	if s == nil {
		return nil
	}
	s.OriginatorValue = &v
	return s
}

// Payload data transmitter in the API call.
func (s APICallImpl) Payload() *string {
	return s.PayloadValue
}

// Payload data transmitter in the API call.
func (s *APICallImpl) SetPayload(v string) APICall {
	if s == nil {
		return nil
	}
	s.PayloadValue = &v
	return s
}

// Internal request-id for this operation
func (s APICallImpl) RequestID() *string {
	return s.RequestIDValue
}

// Internal request-id for this operation
func (s *APICallImpl) SetRequestID(v string) APICall {
	if s == nil {
		return nil
	}
	s.RequestIDValue = &v
	return s
}

// Request status code.
func (s APICallImpl) Status() *int {
	return s.StatusValue
}

// Request status code.
func (s *APICallImpl) SetStatus(v int) APICall {
	if s == nil {
		return nil
	}
	s.StatusValue = &v
	return s
}

// The type of the device from which the API call was produced.
// Example: Flussonic 24.04
func (s APICallImpl) UserAgent() *string {
	return s.UserAgentValue
}

// The type of the device from which the API call was produced.
// Example: Flussonic 24.04
func (s *APICallImpl) SetUserAgent(v string) APICall {
	if s == nil {
		return nil
	}
	s.UserAgentValue = &v
	return s
}

// NewAPICallEvent creates a new APICallEvent instance
func NewAPICallEvent() APICallEvent {
	return &APICallEventImpl{}
}

// Creation date and time
// Format: date_time (date_time)
// Example: 2021-01-30T08:30:00.432567Z
func (s APICallEventImpl) CreatedAt() *DateTime {
	return s.CreatedAtValue
}

// Creation date and time
// Format: date_time (date_time)
// Example: 2021-01-30T08:30:00.432567Z
func (s *APICallEventImpl) SetCreatedAt(v DateTime) APICallEvent {
	if s == nil {
		return nil
	}
	s.CreatedAtValue = &v
	return s
}

// Microseconds that this request took
// Format: microseconds (microseconds)
func (s APICallEventImpl) Duration() *Microseconds {
	return s.DurationValue
}

// Microseconds that this request took
// Format: microseconds (microseconds)
func (s *APICallEventImpl) SetDuration(v Microseconds) APICallEvent {
	if s == nil {
		return nil
	}
	s.DurationValue = &v
	return s
}

// The api call.
func (s APICallEventImpl) Event() string {
	return s.EventValue
}

// The api call.
func (s *APICallEventImpl) SetEvent(v string) APICallEvent {
	if s == nil {
		return nil
	}
	s.EventValue = v
	return s
}

// Event identifier.
func (s APICallEventImpl) EventID() *int {
	return s.EventIDValue
}

// Event identifier.
func (s *APICallEventImpl) SetEventID(v int) APICallEvent {
	if s == nil {
		return nil
	}
	s.EventIDValue = &v
	return s
}

// IP address of the caller.
// Format: ip (ip)
// Example: 192.34.32.10
func (s APICallEventImpl) IP() *IP {
	return s.IPValue
}

// IP address of the caller.
// Format: ip (ip)
// Example: 192.34.32.10
func (s *APICallEventImpl) SetIP(v IP) APICallEvent {
	if s == nil {
		return nil
	}
	s.IPValue = &v
	return s
}

// API method ID.
// Example: streams_list
func (s APICallEventImpl) OperationID() *string {
	return s.OperationIDValue
}

// API method ID.
// Example: streams_list
func (s *APICallEventImpl) SetOperationID(v string) APICallEvent {
	if s == nil {
		return nil
	}
	s.OperationIDValue = &v
	return s
}

// The program produced the API call. Content of `X-Originator` header.
// Example: flussonic
func (s APICallEventImpl) Originator() *string {
	return s.OriginatorValue
}

// The program produced the API call. Content of `X-Originator` header.
// Example: flussonic
func (s *APICallEventImpl) SetOriginator(v string) APICallEvent {
	if s == nil {
		return nil
	}
	s.OriginatorValue = &v
	return s
}

// The api call path.
func (s APICallEventImpl) Path() *string {
	return s.PathValue
}

// The api call path.
func (s *APICallEventImpl) SetPath(v string) APICallEvent {
	if s == nil {
		return nil
	}
	s.PathValue = &v
	return s
}

// Payload data transmitter in the API call.
func (s APICallEventImpl) Payload() *string {
	return s.PayloadValue
}

// Payload data transmitter in the API call.
func (s *APICallEventImpl) SetPayload(v string) APICallEvent {
	if s == nil {
		return nil
	}
	s.PayloadValue = &v
	return s
}

// The api call query string.
func (s APICallEventImpl) Qs() *string {
	return s.QsValue
}

// The api call query string.
func (s *APICallEventImpl) SetQs(v string) APICallEvent {
	if s == nil {
		return nil
	}
	s.QsValue = &v
	return s
}

// Internal request-id for this operation
func (s APICallEventImpl) RequestID() *string {
	return s.RequestIDValue
}

// Internal request-id for this operation
func (s *APICallEventImpl) SetRequestID(v string) APICallEvent {
	if s == nil {
		return nil
	}
	s.RequestIDValue = &v
	return s
}

// Originator of event.
// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
// is configured as HTTP/HTTPS url.
// Example: flussonic.host
func (s APICallEventImpl) Server() *string {
	return s.ServerValue
}

// Originator of event.
// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
// is configured as HTTP/HTTPS url.
// Example: flussonic.host
func (s *APICallEventImpl) SetServer(v string) APICallEvent {
	if s == nil {
		return nil
	}
	s.ServerValue = &v
	return s
}

// Request status code.
func (s APICallEventImpl) Status() *int {
	return s.StatusValue
}

// Request status code.
func (s *APICallEventImpl) SetStatus(v int) APICallEvent {
	if s == nil {
		return nil
	}
	s.StatusValue = &v
	return s
}

// Unique identifier of the operation.
// You can use this field to search for events related to same operation.
// Value of this field is taken from the `X-Trace-Id` header.
// If `X-Trace-Id` header is not set, it will be generated automatically.
// Service will use the value of this field to make outgoing requests.
// Format: uuid (uuid)
// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
func (s APICallEventImpl) TraceID() *UUID {
	return s.TraceIDValue
}

// Unique identifier of the operation.
// You can use this field to search for events related to same operation.
// Value of this field is taken from the `X-Trace-Id` header.
// If `X-Trace-Id` header is not set, it will be generated automatically.
// Service will use the value of this field to make outgoing requests.
// Format: uuid (uuid)
// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
func (s *APICallEventImpl) SetTraceID(v UUID) APICallEvent {
	if s == nil {
		return nil
	}
	s.TraceIDValue = &v
	return s
}

// The type of the device from which the API call was produced.
// Example: Flussonic 24.04
func (s APICallEventImpl) UserAgent() *string {
	return s.UserAgentValue
}

// The type of the device from which the API call was produced.
// Example: Flussonic 24.04
func (s *APICallEventImpl) SetUserAgent(v string) APICallEvent {
	if s == nil {
		return nil
	}
	s.UserAgentValue = &v
	return s
}

// The time of the event registration on the server.
// Format: utc_ms (Unix timestamp in milliseconds)
func (s APICallEventImpl) UtcMs() *UtcMs {
	return s.UtcMsValue
}

// The time of the event registration on the server.
// Format: utc_ms (Unix timestamp in milliseconds)
func (s *APICallEventImpl) SetUtcMs(v UtcMs) APICallEvent {
	if s == nil {
		return nil
	}
	s.UtcMsValue = &v
	return s
}

// NewAdminCredentials creates a new AdminCredentials instance
func NewAdminCredentials() AdminCredentials {
	return &AdminCredentialsImpl{}
}

// Login
// Example: secretlogin
func (s AdminCredentialsImpl) Login() string {
	return s.LoginValue
}

// Login
// Example: secretlogin
func (s *AdminCredentialsImpl) SetLogin(v string) AdminCredentials {
	if s == nil {
		return nil
	}
	s.LoginValue = v
	return s
}

// Password
// Format: password (password)
// Example: passw
func (s AdminCredentialsImpl) Password() Password {
	return s.PasswordValue
}

// Password
// Format: password (password)
// Example: passw
func (s *AdminCredentialsImpl) SetPassword(v Password) AdminCredentials {
	if s == nil {
		return nil
	}
	s.PasswordValue = v
	return s
}

// NewAgent creates a new Agent instance
func NewAgent() Agent {
	return &AgentImpl{}
}

// Agent identifier
// Example: 1234567
func (s AgentImpl) ID() *string {
	return s.IDValue
}

// Agent identifier
// Example: 1234567
func (s *AgentImpl) SetID(v string) Agent {
	if s == nil {
		return nil
	}
	s.IDValue = &v
	return s
}

// Agent authentication key.
func (s AgentImpl) Key() *string {
	return s.KeyValue
}

// Agent authentication key.
func (s *AgentImpl) SetKey(v string) Agent {
	if s == nil {
		return nil
	}
	s.KeyValue = &v
	return s
}

// The model of the camera with [Agent](https://flussonic.com/doc/agent-with-watcher/).
func (s AgentImpl) Model() *string {
	return s.ModelValue
}

// The model of the camera with [Agent](https://flussonic.com/doc/agent-with-watcher/).
func (s *AgentImpl) SetModel(v string) Agent {
	if s == nil {
		return nil
	}
	s.ModelValue = &v
	return s
}

// The device (camera or router) serial number.
func (s AgentImpl) Serial() *string {
	return s.SerialValue
}

// The device (camera or router) serial number.
func (s *AgentImpl) SetSerial(v string) Agent {
	if s == nil {
		return nil
	}
	s.SerialValue = &v
	return s
}

// Agents's metrics and other statistical information.
func (s AgentImpl) Stats() WatcherAgentStats {
	return s.StatsValue
}

// Agents's metrics and other statistical information.
func (s *AgentImpl) SetStats(v WatcherAgentStats) Agent {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*WatcherAgentStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// List of streams info that have this agent in their inputs
func (s AgentImpl) Streams() []any {
	return s.StreamsValue
}

// List of streams info that have this agent in their inputs
func (s *AgentImpl) SetStreams(v []any) Agent {
	if s == nil {
		return nil
	}
	s.StreamsValue = v
	return s
}

// NewAgentConfigBase creates a new AgentConfigBase instance
func NewAgentConfigBase() AgentConfigBase {
	return &AgentConfigBaseImpl{}
}

// Agent identifier
// Example: 1234567
func (s AgentConfigBaseImpl) ID() *string {
	return s.IDValue
}

// Agent identifier
// Example: 1234567
func (s *AgentConfigBaseImpl) SetID(v string) AgentConfigBase {
	if s == nil {
		return nil
	}
	s.IDValue = &v
	return s
}

// Agent authentication key.
func (s AgentConfigBaseImpl) Key() *string {
	return s.KeyValue
}

// Agent authentication key.
func (s *AgentConfigBaseImpl) SetKey(v string) AgentConfigBase {
	if s == nil {
		return nil
	}
	s.KeyValue = &v
	return s
}

// The model of the camera with [Agent](https://flussonic.com/doc/agent-with-watcher/).
func (s AgentConfigBaseImpl) Model() *string {
	return s.ModelValue
}

// The model of the camera with [Agent](https://flussonic.com/doc/agent-with-watcher/).
func (s *AgentConfigBaseImpl) SetModel(v string) AgentConfigBase {
	if s == nil {
		return nil
	}
	s.ModelValue = &v
	return s
}

// The device (camera or router) serial number.
func (s AgentConfigBaseImpl) Serial() *string {
	return s.SerialValue
}

// The device (camera or router) serial number.
func (s *AgentConfigBaseImpl) SetSerial(v string) AgentConfigBase {
	if s == nil {
		return nil
	}
	s.SerialValue = &v
	return s
}

// Agents's metrics and other statistical information.
func (s AgentConfigBaseImpl) Stats() WatcherAgentStats {
	return s.StatsValue
}

// Agents's metrics and other statistical information.
func (s *AgentConfigBaseImpl) SetStats(v WatcherAgentStats) AgentConfigBase {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*WatcherAgentStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// NewAgentsList creates a new AgentsList instance
func NewAgentsList() AgentsList {
	return &AgentsListImpl{}
}

// The list of Agents fetched according to the query parameters.
func (s AgentsListImpl) Agents() []Agent {
	if s.AgentsValue == nil {
		return nil
	}
	result := make([]Agent, len(s.AgentsValue))
	for i, item := range s.AgentsValue {
		result[i] = item
	}
	return result
}

// The list of Agents fetched according to the query parameters.
func (s *AgentsListImpl) SetAgents(v []Agent) AgentsList {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*AgentImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*AgentImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.AgentsValue = impl
	}
	return s
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s AgentsListImpl) EstimatedCount() *int {
	return s.EstimatedCountValue
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s *AgentsListImpl) SetEstimatedCount(v int) AgentsList {
	if s == nil {
		return nil
	}
	s.EstimatedCountValue = &v
	return s
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s AgentsListImpl) Next() *string {
	return s.NextValue
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s *AgentsListImpl) SetNext(v string) AgentsList {
	if s == nil {
		return nil
	}
	s.NextValue = &v
	return s
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s AgentsListImpl) Prev() *string {
	return s.PrevValue
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s *AgentsListImpl) SetPrev(v string) AgentsList {
	if s == nil {
		return nil
	}
	s.PrevValue = &v
	return s
}

// An object with a list of different timings measured during this API call.
func (s AgentsListImpl) Timing() any {
	return s.TimingValue
}

// An object with a list of different timings measured during this API call.
func (s *AgentsListImpl) SetTiming(v any) AgentsList {
	if s == nil {
		return nil
	}
	s.TimingValue = v
	return s
}

// Collection returns the collection items from AgentsList
func (s AgentsListImpl) Collection() []Agent {
	return s.Agents()
}

// NewApikey creates a new Apikey instance
func NewApikey() Apikey {
	return &ApikeyImpl{}
}

// Apikey for users access via API.
func (s ApikeyImpl) Apikey() *string {
	return s.ApikeyValue
}

// Apikey for users access via API.
func (s *ApikeyImpl) SetApikey(v string) Apikey {
	if s == nil {
		return nil
	}
	s.ApikeyValue = &v
	return s
}

// NewAppearanceConfig creates a new AppearanceConfig instance
func NewAppearanceConfig() AppearanceConfig {
	return &AppearanceConfigImpl{}
}

// The interface colors.
func (s AppearanceConfigImpl) Colors() AppearanceConfigColors {
	return s.ColorsValue
}

// The interface colors.
func (s *AppearanceConfigImpl) SetColors(v AppearanceConfigColors) AppearanceConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*AppearanceConfigColorsImpl); ok {
		s.ColorsValue = impl
	}
	return s
}

// The favicon image.
// Format: byte (byte)
// Example: data:image/png;base64,<base64string>
func (s AppearanceConfigImpl) Favicon() *Byte {
	return s.FaviconValue
}

// The favicon image.
// Format: byte (byte)
// Example: data:image/png;base64,<base64string>
func (s *AppearanceConfigImpl) SetFavicon(v Byte) AppearanceConfig {
	if s == nil {
		return nil
	}
	s.FaviconValue = &v
	return s
}

// The logo image in the sidebar.
// Format: byte (byte)
// Example: data:image/png;base64,<base64string>
func (s AppearanceConfigImpl) Logo() *Byte {
	return s.LogoValue
}

// The logo image in the sidebar.
// Format: byte (byte)
// Example: data:image/png;base64,<base64string>
func (s *AppearanceConfigImpl) SetLogo(v Byte) AppearanceConfig {
	if s == nil {
		return nil
	}
	s.LogoValue = &v
	return s
}

// The logo image on the login page.
// Format: byte (byte)
// Example: data:image/jpg;base64,<base64string>
func (s AppearanceConfigImpl) LogoAuth() *Byte {
	return s.LogoAuthValue
}

// The logo image on the login page.
// Format: byte (byte)
// Example: data:image/jpg;base64,<base64string>
func (s *AppearanceConfigImpl) SetLogoAuth(v Byte) AppearanceConfig {
	if s == nil {
		return nil
	}
	s.LogoAuthValue = &v
	return s
}

// The custom page title.
// Example: My video site
func (s AppearanceConfigImpl) Title() *string {
	return s.TitleValue
}

// The custom page title.
// Example: My video site
func (s *AppearanceConfigImpl) SetTitle(v string) AppearanceConfig {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// NewAppearanceConfigColors creates a new AppearanceConfigColors instance
func NewAppearanceConfigColors() AppearanceConfigColors {
	return &AppearanceConfigColorsImpl{}
}

// The background color.
// Example: #f3f5f7
func (s AppearanceConfigColorsImpl) Background() *string {
	return s.BackgroundValue
}

// The background color.
// Example: #f3f5f7
func (s *AppearanceConfigColorsImpl) SetBackground(v string) AppearanceConfigColors {
	if s == nil {
		return nil
	}
	s.BackgroundValue = &v
	return s
}

// Primary color for interface elements like selection in the main menu, info icons, buttons, etc.
// Example: #444951
func (s AppearanceConfigColorsImpl) Primary() *string {
	return s.PrimaryValue
}

// Primary color for interface elements like selection in the main menu, info icons, buttons, etc.
// Example: #444951
func (s *AppearanceConfigColorsImpl) SetPrimary(v string) AppearanceConfigColors {
	if s == nil {
		return nil
	}
	s.PrimaryValue = &v
	return s
}

// Secondary color for obsolete interface elements like active tab.
// Example: #2469f2
func (s AppearanceConfigColorsImpl) Secondary() *string {
	return s.SecondaryValue
}

// Secondary color for obsolete interface elements like active tab.
// Example: #2469f2
func (s *AppearanceConfigColorsImpl) SetSecondary(v string) AppearanceConfigColors {
	if s == nil {
		return nil
	}
	s.SecondaryValue = &v
	return s
}

// NewAuditLogRecord creates a new AuditLogRecord instance
func NewAuditLogRecord() AuditLogRecord {
	return &AuditLogRecordImpl{}
}

// The time when the last changes were made.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s AuditLogRecordImpl) CreatedAt() *UtcMs {
	return s.CreatedAtValue
}

// The time when the last changes were made.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *AuditLogRecordImpl) SetCreatedAt(v UtcMs) AuditLogRecord {
	if s == nil {
		return nil
	}
	s.CreatedAtValue = &v
	return s
}

// Who initiated the last changes.
// Examples: admin
func (s AuditLogRecordImpl) User() *string {
	return s.UserValue
}

// Who initiated the last changes.
// Examples: admin
func (s *AuditLogRecordImpl) SetUser(v string) AuditLogRecord {
	if s == nil {
		return nil
	}
	s.UserValue = &v
	return s
}

// NewAuth creates a new Auth instance
func NewAuth() Auth {
	return &AuthImpl{}
}

// Username authentication
func (s AuthImpl) Login() *string {
	return s.LoginValue
}

// Username authentication
func (s *AuthImpl) SetLogin(v string) Auth {
	if s == nil {
		return nil
	}
	s.LoginValue = &v
	return s
}

// Password authentication
func (s AuthImpl) Password() *string {
	return s.PasswordValue
}

// Password authentication
func (s *AuthImpl) SetPassword(v string) Auth {
	if s == nil {
		return nil
	}
	s.PasswordValue = &v
	return s
}

// Service port on which Onvif/PSIA is accessible, default is 80
func (s AuthImpl) Port() *int {
	return s.PortValue
}

// Service port on which Onvif/PSIA is accessible, default is 80
func (s *AuthImpl) SetPort(v int) Auth {
	if s == nil {
		return nil
	}
	s.PortValue = &v
	return s
}

// NewAuthBackendConfig creates a new AuthBackendConfig instance
func NewAuthBackendConfig() AuthBackendConfig {
	return &AuthBackendConfigImpl{}
}

// Explicit list of countries (two-letter country codes according to ISO 3166-1) that have access to the content without any other checks.
// Flussonic uses the MaxMind GeoLite2 Country database to map a country to a block of IP addresses.
// New releases of GeoIP2 databases come out more often than the releases of Flussonic server, so sometimes the used database can become outdated.
// Therefore we recommend you to install a separate GeoIP2 library and set up Flussonic to use it.
// Example: [RU US]
func (s AuthBackendConfigImpl) AllowCountries() []string {
	return s.AllowCountriesValue
}

// Explicit list of countries (two-letter country codes according to ISO 3166-1) that have access to the content without any other checks.
// Flussonic uses the MaxMind GeoLite2 Country database to map a country to a block of IP addresses.
// New releases of GeoIP2 databases come out more often than the releases of Flussonic server, so sometimes the used database can become outdated.
// Therefore we recommend you to install a separate GeoIP2 library and set up Flussonic to use it.
// Example: [RU US]
func (s *AuthBackendConfigImpl) SetAllowCountries(v []string) AuthBackendConfig {
	if s == nil {
		return nil
	}
	s.AllowCountriesValue = v
	return s
}

// This option defines the default behavior when all backends are not responding (usually, because of errors in HTTP responses) and the session is not started yet.
// If this option is enabled, all clients or devices except those listed in `deny` option will have access to the content.
// If this option is disabled, all clients or devices except those listed in `allow` option will not have access to the content.
func (s AuthBackendConfigImpl) AllowDefault() *bool {
	return s.AllowDefaultValue
}

// This option defines the default behavior when all backends are not responding (usually, because of errors in HTTP responses) and the session is not started yet.
// If this option is enabled, all clients or devices except those listed in `deny` option will have access to the content.
// If this option is disabled, all clients or devices except those listed in `allow` option will not have access to the content.
func (s *AuthBackendConfigImpl) SetAllowDefault(v bool) AuthBackendConfig {
	if s == nil {
		return nil
	}
	s.AllowDefaultValue = &v
	return s
}

// Explicit list of IP-addresses or subnet masks that have access to the content without any other checks.
// Example: [127.0.0.1 10.10.0.0/24]
func (s AuthBackendConfigImpl) AllowIps() []string {
	return s.AllowIpsValue
}

// Explicit list of IP-addresses or subnet masks that have access to the content without any other checks.
// Example: [127.0.0.1 10.10.0.0/24]
func (s *AuthBackendConfigImpl) SetAllowIps(v []string) AuthBackendConfig {
	if s == nil {
		return nil
	}
	s.AllowIpsValue = v
	return s
}

// Explicit list of tokens that give access to the content without any other checks.
// Example: [test_token1 test_token2]
func (s AuthBackendConfigImpl) AllowTokens() []string {
	return s.AllowTokensValue
}

// Explicit list of tokens that give access to the content without any other checks.
// Example: [test_token1 test_token2]
func (s *AuthBackendConfigImpl) SetAllowTokens(v []string) AuthBackendConfig {
	if s == nil {
		return nil
	}
	s.AllowTokensValue = v
	return s
}

// Explicit list of user agents (set-top boxes or browsers) that have access to the content without any other checks.
// Example: [AppleWebKit/533.3 (KHTML, like Gecko) VLC/3.0.8 LibVLC/3.0.8]
func (s AuthBackendConfigImpl) AllowUas() []string {
	return s.AllowUasValue
}

// Explicit list of user agents (set-top boxes or browsers) that have access to the content without any other checks.
// Example: [AppleWebKit/533.3 (KHTML, like Gecko) VLC/3.0.8 LibVLC/3.0.8]
func (s *AuthBackendConfigImpl) SetAllowUas(v []string) AuthBackendConfig {
	if s == nil {
		return nil
	}
	s.AllowUasValue = v
	return s
}

// URL(s) of the HTTP backend(s).
func (s AuthBackendConfigImpl) Backends() []AuthBackendURL {
	if s.BackendsValue == nil {
		return nil
	}
	result := make([]AuthBackendURL, len(s.BackendsValue))
	for i, item := range s.BackendsValue {
		result[i] = item
	}
	return result
}

// URL(s) of the HTTP backend(s).
func (s *AuthBackendConfigImpl) SetBackends(v []AuthBackendURL) AuthBackendConfig {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*AuthBackendURLImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*AuthBackendURLImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.BackendsValue = impl
	}
	return s
}

// Explicit list of countries (two-letter country codes according to ISO 3166-1) that are banned from accessing the content.
// Flussonic uses the MaxMind GeoLite2 Country database to map a country to a block of IP addresses.
// New releases of GeoIP2 databases come out more often than the releases of Flussonic server, so sometimes the used database can become outdated.
// Therefore we recommend you to install a separate GeoIP2 library and set up Flussonic to use it.
// Example: [RU GB]
func (s AuthBackendConfigImpl) DenyCountries() []string {
	return s.DenyCountriesValue
}

// Explicit list of countries (two-letter country codes according to ISO 3166-1) that are banned from accessing the content.
// Flussonic uses the MaxMind GeoLite2 Country database to map a country to a block of IP addresses.
// New releases of GeoIP2 databases come out more often than the releases of Flussonic server, so sometimes the used database can become outdated.
// Therefore we recommend you to install a separate GeoIP2 library and set up Flussonic to use it.
// Example: [RU GB]
func (s *AuthBackendConfigImpl) SetDenyCountries(v []string) AuthBackendConfig {
	if s == nil {
		return nil
	}
	s.DenyCountriesValue = v
	return s
}

// Explicit list of IP-addresses or subnet masks that are banned from accessing the content.
// Example: [8.8.8.8 10.10.0.0/24]
func (s AuthBackendConfigImpl) DenyIps() []string {
	return s.DenyIpsValue
}

// Explicit list of IP-addresses or subnet masks that are banned from accessing the content.
// Example: [8.8.8.8 10.10.0.0/24]
func (s *AuthBackendConfigImpl) SetDenyIps(v []string) AuthBackendConfig {
	if s == nil {
		return nil
	}
	s.DenyIpsValue = v
	return s
}

// Explicit list of tokens that deny access to the content and stop any other checks.
// Example: [test_token3 test_token4]
func (s AuthBackendConfigImpl) DenyTokens() []string {
	return s.DenyTokensValue
}

// Explicit list of tokens that deny access to the content and stop any other checks.
// Example: [test_token3 test_token4]
func (s *AuthBackendConfigImpl) SetDenyTokens(v []string) AuthBackendConfig {
	if s == nil {
		return nil
	}
	s.DenyTokensValue = v
	return s
}

// The list of user agents (set-top boxes or browsers) that are banned from accessing the content.
// Example: [Mobile Safari/533.3 VLC/3.0.8 LibVLC/3.0.8]
func (s AuthBackendConfigImpl) DenyUas() []string {
	return s.DenyUasValue
}

// The list of user agents (set-top boxes or browsers) that are banned from accessing the content.
// Example: [Mobile Safari/533.3 VLC/3.0.8 LibVLC/3.0.8]
func (s *AuthBackendConfigImpl) SetDenyUas(v []string) AuthBackendConfig {
	if s == nil {
		return nil
	}
	s.DenyUasValue = v
	return s
}

// Globally unique [`auth_backend`](https://flussonic.com/doc/complex-authorization-with-backends/) name.
// Format: auth_backend_name (auth_backend_name)
func (s AuthBackendConfigImpl) Name() AuthBackendName {
	return s.NameValue
}

// Globally unique [`auth_backend`](https://flussonic.com/doc/complex-authorization-with-backends/) name.
// Format: auth_backend_name (auth_backend_name)
func (s *AuthBackendConfigImpl) SetName(v AuthBackendName) AuthBackendConfig {
	if s == nil {
		return nil
	}
	s.NameValue = v
	return s
}

// NewAuthBackendURL creates a new AuthBackendURL instance
func NewAuthBackendURL() AuthBackendURL {
	return &AuthBackendURLImpl{}
}

// The URL of an HTTP backend.
// Example: http://stalker-1.iptv.net/auth.php
func (s AuthBackendURLImpl) URL() string {
	return s.URLValue
}

// The URL of an HTTP backend.
// Example: http://stalker-1.iptv.net/auth.php
func (s *AuthBackendURLImpl) SetURL(v string) AuthBackendURL {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// NewAuthSpec creates a new AuthSpec instance
func NewAuthSpec() AuthSpec {
	return &AuthSpecImpl{}
}

// Explicit list of countries (two-letter country codes according to ISO 3166-1) that have access to the content without any other checks.
// Flussonic uses the MaxMind GeoLite2 Country database to map a country to a block of IP addresses.
// New releases of GeoIP2 databases come out more often than the releases of Flussonic server, so sometimes the used database can become outdated.
// Therefore we recommend you to install a separate GeoIP2 library and set up Flussonic to use it.
// Example: [US DE GB]
func (s AuthSpecImpl) AllowedCountries() []Iso3166 {
	return s.AllowedCountriesValue
}

// Explicit list of countries (two-letter country codes according to ISO 3166-1) that have access to the content without any other checks.
// Flussonic uses the MaxMind GeoLite2 Country database to map a country to a block of IP addresses.
// New releases of GeoIP2 databases come out more often than the releases of Flussonic server, so sometimes the used database can become outdated.
// Therefore we recommend you to install a separate GeoIP2 library and set up Flussonic to use it.
// Example: [US DE GB]
func (s *AuthSpecImpl) SetAllowedCountries(v []Iso3166) AuthSpec {
	if s == nil {
		return nil
	}
	s.AllowedCountriesValue = v
	return s
}

// Explicit list of countries (two-letter country codes according to ISO 3166-1) that are banned from accessing the content.
// Flussonic uses the MaxMind GeoLite2 Country database to map a country to a block of IP addresses.
// New releases of GeoIP2 databases come out more often than the releases of Flussonic server, so sometimes the used database can become outdated.
// Therefore we recommend you to install a separate GeoIP2 library and set up Flussonic to use it.
// Example: [US DE GB]
func (s AuthSpecImpl) DisallowedCountries() []Iso3166 {
	return s.DisallowedCountriesValue
}

// Explicit list of countries (two-letter country codes according to ISO 3166-1) that are banned from accessing the content.
// Flussonic uses the MaxMind GeoLite2 Country database to map a country to a block of IP addresses.
// New releases of GeoIP2 databases come out more often than the releases of Flussonic server, so sometimes the used database can become outdated.
// Therefore we recommend you to install a separate GeoIP2 library and set up Flussonic to use it.
// Example: [US DE GB]
func (s *AuthSpecImpl) SetDisallowedCountries(v []Iso3166) AuthSpec {
	if s == nil {
		return nil
	}
	s.DisallowedCountriesValue = v
	return s
}

// Specifying the domains, within which playing this video is allowed.
// This does not work for those clients that do not pass the value of Referer HTTP header.
// Example: [mycompany.com]
func (s AuthSpecImpl) Domains() []string {
	return s.DomainsValue
}

// Specifying the domains, within which playing this video is allowed.
// This does not work for those clients that do not pass the value of Referer HTTP header.
// Example: [mycompany.com]
func (s *AuthSpecImpl) SetDomains(v []string) AuthSpec {
	if s == nil {
		return nil
	}
	s.DomainsValue = v
	return s
}

// Some additional options.
func (s AuthSpecImpl) Extra() map[string]string {
	return s.ExtraValue
}

// Some additional options.
func (s *AuthSpecImpl) SetExtra(v map[string]string) AuthSpec {
	if s == nil {
		return nil
	}
	s.ExtraValue = v
	return s
}

// The maximal number of streams or files the user can view simultaneously.
// This limitation allows to prevent users from full restreaming to their servers.
// Example: 5000
func (s AuthSpecImpl) MaxSessions() *int {
	return s.MaxSessionsValue
}

// The maximal number of streams or files the user can view simultaneously.
// This limitation allows to prevent users from full restreaming to their servers.
// Example: 5000
func (s *AuthSpecImpl) SetMaxSessions(v int) AuthSpec {
	if s == nil {
		return nil
	}
	s.MaxSessionsValue = &v
	return s
}

// A list of keys to generate a session ID value, allowing to configure the authorization scheme
// which is a hash sum calculated as follows: `hash(name + ip + proto)`.
// This parameter allows to finish one session and start another one with the same authorization token.
// The keys `name`,`ip`, and `proto` are required.
// Example: [name token proto ip]
func (s AuthSpecImpl) SessionKeys() []SessionKey {
	return s.SessionKeysValue
}

// A list of keys to generate a session ID value, allowing to configure the authorization scheme
// which is a hash sum calculated as follows: `hash(name + ip + proto)`.
// This parameter allows to finish one session and start another one with the same authorization token.
// The keys `name`,`ip`, and `proto` are required.
// Example: [name token proto ip]
func (s *AuthSpecImpl) SetSessionKeys(v []SessionKey) AuthSpec {
	if s == nil {
		return nil
	}
	s.SessionKeysValue = v
	return s
}

// If this option is enabled and `max_sessions` limitation is used, the extra sessions are interrupted not immediately, but in 30 or 90 seconds.
// This can be useful for middlewares that cannot generate a new token for every new stream or file request
// and therefore need time to understand that all sessions are being used.
// Example: false
func (s AuthSpecImpl) SoftLimitation() *bool {
	return s.SoftLimitationValue
}

// If this option is enabled and `max_sessions` limitation is used, the extra sessions are interrupted not immediately, but in 30 or 90 seconds.
// This can be useful for middlewares that cannot generate a new token for every new stream or file request
// and therefore need time to understand that all sessions are being used.
// Example: false
func (s *AuthSpecImpl) SetSoftLimitation(v bool) AuthSpec {
	if s == nil {
		return nil
	}
	s.SoftLimitationValue = &v
	return s
}

// The URL of an HTTP backend.
// Example: http://middleware-address/auth/v2
func (s AuthSpecImpl) URL() *AuthURL {
	return s.URLValue
}

// The URL of an HTTP backend.
// Example: http://middleware-address/auth/v2
func (s *AuthSpecImpl) SetURL(v AuthURL) AuthSpec {
	if s == nil {
		return nil
	}
	s.URLValue = &v
	return s
}

// NewBalancerConfig creates a new BalancerConfig instance
func NewBalancerConfig() BalancerConfig {
	return &BalancerConfigImpl{}
}

// Balancing mode
func (s BalancerConfigImpl) Mode() *BalancerConfigMode {
	return s.ModeValue
}

// Balancing mode
func (s *BalancerConfigImpl) SetMode(v BalancerConfigMode) BalancerConfig {
	if s == nil {
		return nil
	}
	s.ModeValue = &v
	return s
}

// Globally unique balancer name.
// Format: media_name (media_name)
func (s BalancerConfigImpl) Name() *MediaName {
	return s.NameValue
}

// Globally unique balancer name.
// Format: media_name (media_name)
func (s *BalancerConfigImpl) SetName(v MediaName) BalancerConfig {
	if s == nil {
		return nil
	}
	s.NameValue = &v
	return s
}

// Balancer will distribute requests between these servers.
func (s BalancerConfigImpl) Servers() []BalancerServerConfig {
	if s.ServersValue == nil {
		return nil
	}
	result := make([]BalancerServerConfig, len(s.ServersValue))
	for i, item := range s.ServersValue {
		result[i] = item
	}
	return result
}

// Balancer will distribute requests between these servers.
func (s *BalancerConfigImpl) SetServers(v []BalancerServerConfig) BalancerConfig {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*BalancerServerConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*BalancerServerConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.ServersValue = impl
	}
	return s
}

// NewBalancerServerConfig creates a new BalancerServerConfig instance
func NewBalancerServerConfig() BalancerServerConfig {
	return &BalancerServerConfigImpl{}
}

// Client will be redirected to the peer if its IP belongs to one of these countries.
func (s BalancerServerConfigImpl) Countries() []Iso3166 {
	return s.CountriesValue
}

// Client will be redirected to the peer if its IP belongs to one of these countries.
func (s *BalancerServerConfigImpl) SetCountries(v []Iso3166) BalancerServerConfig {
	if s == nil {
		return nil
	}
	s.CountriesValue = v
	return s
}

// This flag allows to redirect a request to this peer if "countries" list not matched.
func (s BalancerServerConfigImpl) CountriesDefault() *bool {
	return s.CountriesDefaultValue
}

// This flag allows to redirect a request to this peer if "countries" list not matched.
func (s *BalancerServerConfigImpl) SetCountriesDefault(v bool) BalancerServerConfig {
	if s == nil {
		return nil
	}
	s.CountriesDefaultValue = &v
	return s
}

// Maximum allowed bitrate, request is redirecting if current bitrate is lower.
// Format: speed (speed)
func (s BalancerServerConfigImpl) MaxBitrate() *Speed {
	return s.MaxBitrateValue
}

// Maximum allowed bitrate, request is redirecting if current bitrate is lower.
// Format: speed (speed)
func (s *BalancerServerConfigImpl) SetMaxBitrate(v Speed) BalancerServerConfig {
	if s == nil {
		return nil
	}
	s.MaxBitrateValue = &v
	return s
}

// Hostname of the peer. Can refer to globally defined peer.
// Format: server_name (server_name)
func (s BalancerServerConfigImpl) Name() *ServerName {
	return s.NameValue
}

// Hostname of the peer. Can refer to globally defined peer.
// Format: server_name (server_name)
func (s *BalancerServerConfigImpl) SetName(v ServerName) BalancerServerConfig {
	if s == nil {
		return nil
	}
	s.NameValue = &v
	return s
}

// NewCacheConfig creates a new CacheConfig instance
func NewCacheConfig() CacheConfig {
	return &CacheConfigImpl{}
}

// A period (in seconds) back from the current moment during which the files are stored.
// As time goes, the files which are older than this period are being overridden by the later files.
// Format: seconds (seconds)
// Example: 604800
func (s CacheConfigImpl) Expiration() *Seconds {
	return s.ExpirationValue
}

// A period (in seconds) back from the current moment during which the files are stored.
// As time goes, the files which are older than this period are being overridden by the later files.
// Format: seconds (seconds)
// Example: 604800
func (s *CacheConfigImpl) SetExpiration(v Seconds) CacheConfig {
	if s == nil {
		return nil
	}
	s.ExpirationValue = &v
	return s
}

// The number of requests necessary for a file to be cached.
// Example: 3
func (s CacheConfigImpl) Misses() *int {
	return s.MissesValue
}

// The number of requests necessary for a file to be cached.
// Example: 3
func (s *CacheConfigImpl) SetMisses(v int) CacheConfig {
	if s == nil {
		return nil
	}
	s.MissesValue = &v
	return s
}

// Globally unique cache name.
// Format: cache_name (cache_name)
// Example: cache1
func (s CacheConfigImpl) Name() CacheName {
	return s.NameValue
}

// Globally unique cache name.
// Format: cache_name (cache_name)
// Example: cache1
func (s *CacheConfigImpl) SetName(v CacheName) CacheConfig {
	if s == nil {
		return nil
	}
	s.NameValue = v
	return s
}

// The path where the files from the cloud or HTTP are cached to speed up broadcasting.
// Format: disk_path (disk_path)
// Example: /storage/cache
func (s CacheConfigImpl) Path() *DiskPath {
	return s.PathValue
}

// The path where the files from the cloud or HTTP are cached to speed up broadcasting.
// Format: disk_path (disk_path)
// Example: /storage/cache
func (s *CacheConfigImpl) SetPath(v DiskPath) CacheConfig {
	if s == nil {
		return nil
	}
	s.PathValue = &v
	return s
}

// Maximum disk consumption in bytes.
// When this limit is reached, the oldest files will be overridden by later files.
// Format: bytes (bytes)
// Example: 400000
func (s CacheConfigImpl) StorageLimit() *Bytes {
	return s.StorageLimitValue
}

// Maximum disk consumption in bytes.
// When this limit is reached, the oldest files will be overridden by later files.
// Format: bytes (bytes)
// Example: 400000
func (s *CacheConfigImpl) SetStorageLimit(v Bytes) CacheConfig {
	if s == nil {
		return nil
	}
	s.StorageLimitValue = &v
	return s
}

// NewCacheSpec creates a new CacheSpec instance
func NewCacheSpec() CacheSpec {
	return &CacheSpecImpl{}
}

// A period (in seconds) back from the current moment during which the files are stored.
// As time goes, the files which are older than this period are being overridden by the later files.
// Format: seconds (seconds)
// Example: 3600
func (s CacheSpecImpl) Expiration() *Seconds {
	return s.ExpirationValue
}

// A period (in seconds) back from the current moment during which the files are stored.
// As time goes, the files which are older than this period are being overridden by the later files.
// Format: seconds (seconds)
// Example: 3600
func (s *CacheSpecImpl) SetExpiration(v Seconds) CacheSpec {
	if s == nil {
		return nil
	}
	s.ExpirationValue = &v
	return s
}

// The number of requests necessary for a file to be cached.
// Example: 3
func (s CacheSpecImpl) Misses() *int {
	return s.MissesValue
}

// The number of requests necessary for a file to be cached.
// Example: 3
func (s *CacheSpecImpl) SetMisses(v int) CacheSpec {
	if s == nil {
		return nil
	}
	s.MissesValue = &v
	return s
}

// The name of the cache.
// Format: cache_name (cache_name)
// Example: cache1
func (s CacheSpecImpl) Reference() *CacheName {
	return s.ReferenceValue
}

// The name of the cache.
// Format: cache_name (cache_name)
// Example: cache1
func (s *CacheSpecImpl) SetReference(v CacheName) CacheSpec {
	if s == nil {
		return nil
	}
	s.ReferenceValue = &v
	return s
}

// Maximum disk consumption in bytes.
// When this limit is reached, the oldest files will be overridden by later files.
// Format: bytes (bytes)
// Example: 400000
func (s CacheSpecImpl) StorageLimit() *Bytes {
	return s.StorageLimitValue
}

// Maximum disk consumption in bytes.
// When this limit is reached, the oldest files will be overridden by later files.
// Format: bytes (bytes)
// Example: 400000
func (s *CacheSpecImpl) SetStorageLimit(v Bytes) CacheSpec {
	if s == nil {
		return nil
	}
	s.StorageLimitValue = &v
	return s
}

// NewCameraAlarmConfig creates a new CameraAlarmConfig instance
func NewCameraAlarmConfig() CameraAlarmConfig {
	return &CameraAlarmConfigImpl{}
}

// The list of keywords in the e-mails that are considered alarms.
func (s CameraAlarmConfigImpl) Catch() []string {
	return s.CatchValue
}

// The list of keywords in the e-mails that are considered alarms.
func (s *CameraAlarmConfigImpl) SetCatch(v []string) CameraAlarmConfig {
	if s == nil {
		return nil
	}
	s.CatchValue = v
	return s
}

// The `smtp://` link to get camera alarms from.
func (s CameraAlarmConfigImpl) Listen() *ListenSpec {
	return s.ListenValue
}

// The `smtp://` link to get camera alarms from.
func (s *CameraAlarmConfigImpl) SetListen(v *ListenSpec) CameraAlarmConfig {
	if s == nil {
		return nil
	}
	s.ListenValue = v
	return s
}

// NewCameraConfig creates a new CameraConfig instance
func NewCameraConfig() CameraConfig {
	return &CameraConfigImpl{}
}

// Describes camera information.
func (s CameraConfigImpl) CameraInfo() any {
	return s.CameraInfoValue
}

// Describes camera information.
func (s *CameraConfigImpl) SetCameraInfo(v any) CameraConfig {
	if s == nil {
		return nil
	}
	s.CameraInfoValue = v
	return s
}

// These parameters allow optimizing media quality and performance based on device capabilities and network conditions.
func (s CameraConfigImpl) MediaQuality() any {
	return s.MediaQualityValue
}

// These parameters allow optimizing media quality and performance based on device capabilities and network conditions.
func (s *CameraConfigImpl) SetMediaQuality(v any) CameraConfig {
	if s == nil {
		return nil
	}
	s.MediaQualityValue = v
	return s
}

// Describes sensor configuration.
func (s CameraConfigImpl) Sensor() any {
	return s.SensorValue
}

// Describes sensor configuration.
func (s *CameraConfigImpl) SetSensor(v any) CameraConfig {
	if s == nil {
		return nil
	}
	s.SensorValue = v
	return s
}

// NewCameraInfo creates a new CameraInfo instance
func NewCameraInfo() CameraInfo {
	return &CameraInfoImpl{}
}

// Firmware version
func (s CameraInfoImpl) Firmware() *string {
	return s.FirmwareValue
}

// Firmware version
func (s *CameraInfoImpl) SetFirmware(v string) CameraInfo {
	if s == nil {
		return nil
	}
	s.FirmwareValue = &v
	return s
}

// Manufacturer name
func (s CameraInfoImpl) Manufacturer() *string {
	return s.ManufacturerValue
}

// Manufacturer name
func (s *CameraInfoImpl) SetManufacturer(v string) CameraInfo {
	if s == nil {
		return nil
	}
	s.ManufacturerValue = &v
	return s
}

// Model name
func (s CameraInfoImpl) Model() *string {
	return s.ModelValue
}

// Model name
func (s *CameraInfoImpl) SetModel(v string) CameraInfo {
	if s == nil {
		return nil
	}
	s.ModelValue = &v
	return s
}

// Serial number
func (s CameraInfoImpl) SerialNumber() *string {
	return s.SerialNumberValue
}

// Serial number
func (s *CameraInfoImpl) SetSerialNumber(v string) CameraInfo {
	if s == nil {
		return nil
	}
	s.SerialNumberValue = &v
	return s
}

// NewCameraTagWb creates a new CameraTagWb instance
func NewCameraTagWb() CameraTagWb {
	return &CameraTagWbImpl{}
}

// NewCentralDiskPredictions creates a new CentralDiskPredictions instance
func NewCentralDiskPredictions() CentralDiskPredictions {
	return &CentralDiskPredictionsImpl{}
}

// Estimated disk usage in percent.
// This value is estimated on the based on streamer disk space and current configurations of streams processed by the streamer,
// which specify the rate of data writing to disk by them and the duration of their data storage.
// Note: This value represents what percentage of the disk will be filled when all streams on the streamer reach the point where the disk is static.
// It can be greater than 100% if streamer can't store estimated amount of data.
// Format: percent (percent)
func (s CentralDiskPredictionsImpl) EstimatedDiskUsage() *Percent {
	return s.EstimatedDiskUsageValue
}

// Estimated disk usage in percent.
// This value is estimated on the based on streamer disk space and current configurations of streams processed by the streamer,
// which specify the rate of data writing to disk by them and the duration of their data storage.
// Note: This value represents what percentage of the disk will be filled when all streams on the streamer reach the point where the disk is static.
// It can be greater than 100% if streamer can't store estimated amount of data.
// Format: percent (percent)
func (s *CentralDiskPredictionsImpl) SetEstimatedDiskUsage(v Percent) CentralDiskPredictions {
	if s == nil {
		return nil
	}
	s.EstimatedDiskUsageValue = &v
	return s
}

// NewCentralNodeLayoutDecision creates a new CentralNodeLayoutDecision instance
func NewCentralNodeLayoutDecision() CentralNodeLayoutDecision {
	return &CentralNodeLayoutDecisionImpl{}
}

// Hostname of streamer
// Format: server_name (server_name)
// Example: streamer1.com
func (s CentralNodeLayoutDecisionImpl) Hostname() *ServerName {
	return s.HostnameValue
}

// Hostname of streamer
// Format: server_name (server_name)
// Example: streamer1.com
func (s *CentralNodeLayoutDecisionImpl) SetHostname(v ServerName) CentralNodeLayoutDecision {
	if s == nil {
		return nil
	}
	s.HostnameValue = &v
	return s
}

// This field is true if the stream can be layouted on this node.
// Example: false
func (s CentralNodeLayoutDecisionImpl) NodeDecision() *bool {
	return s.NodeDecisionValue
}

// This field is true if the stream can be layouted on this node.
// Example: false
func (s *CentralNodeLayoutDecisionImpl) SetNodeDecision(v bool) CentralNodeLayoutDecision {
	if s == nil {
		return nil
	}
	s.NodeDecisionValue = &v
	return s
}

// List of decision reasons explaining why the stream cannot be layouted on this node. This field may be empty if stream can be layouted on this node.
// Example: [stream_misses_node_required_labels node_misses_stream_required_labels node_channel_limit_exceeded]
func (s CentralNodeLayoutDecisionImpl) Reasons() []CentralNodeLayoutDecisionReason {
	return s.ReasonsValue
}

// List of decision reasons explaining why the stream cannot be layouted on this node. This field may be empty if stream can be layouted on this node.
// Example: [stream_misses_node_required_labels node_misses_stream_required_labels node_channel_limit_exceeded]
func (s *CentralNodeLayoutDecisionImpl) SetReasons(v []CentralNodeLayoutDecisionReason) CentralNodeLayoutDecision {
	if s == nil {
		return nil
	}
	s.ReasonsValue = v
	return s
}

// Role of node
func (s CentralNodeLayoutDecisionImpl) Role() *CentralNodeRoleRole {
	return s.RoleValue
}

// Role of node
func (s *CentralNodeLayoutDecisionImpl) SetRole(v CentralNodeRoleRole) CentralNodeLayoutDecision {
	if s == nil {
		return nil
	}
	s.RoleValue = &v
	return s
}

// NewCentralNodeRole creates a new CentralNodeRole instance
func NewCentralNodeRole() CentralNodeRole {
	return &CentralNodeRoleImpl{}
}

// Role of node
func (s CentralNodeRoleImpl) Role() *CentralNodeRoleRole {
	return s.RoleValue
}

// Role of node
func (s *CentralNodeRoleImpl) SetRole(v CentralNodeRoleRole) CentralNodeRole {
	if s == nil {
		return nil
	}
	s.RoleValue = &v
	return s
}

// NewCentralStreamLayout creates a new CentralStreamLayout instance
func NewCentralStreamLayout() CentralStreamLayout {
	return &CentralStreamLayoutImpl{}
}

// Reason why layout was changed
func (s CentralStreamLayoutImpl) ChangeReason() *CentralStreamLayoutChangeReason {
	return s.ChangeReasonValue
}

// Reason why layout was changed
func (s *CentralStreamLayoutImpl) SetChangeReason(v CentralStreamLayoutChangeReason) CentralStreamLayout {
	if s == nil {
		return nil
	}
	s.ChangeReasonValue = &v
	return s
}

// Time when the node change occurred
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s CentralStreamLayoutImpl) CreatedAt() *UtcMs {
	return s.CreatedAtValue
}

// Time when the node change occurred
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s *CentralStreamLayoutImpl) SetCreatedAt(v UtcMs) CentralStreamLayout {
	if s == nil {
		return nil
	}
	s.CreatedAtValue = &v
	return s
}

// Current nodes on which the dvr backup is saving
func (s CentralStreamLayoutImpl) DvrBackups() []ServerName {
	return s.DvrBackupsValue
}

// Current nodes on which the dvr backup is saving
func (s *CentralStreamLayoutImpl) SetDvrBackups(v []ServerName) CentralStreamLayout {
	if s == nil {
		return nil
	}
	s.DvrBackupsValue = v
	return s
}

// Hostname of current inference node on which stream analytics running.
// Format: server_name (server_name)
func (s CentralStreamLayoutImpl) Inference() *ServerName {
	return s.InferenceValue
}

// Hostname of current inference node on which stream analytics running.
// Format: server_name (server_name)
func (s *CentralStreamLayoutImpl) SetInference(v ServerName) CentralStreamLayout {
	if s == nil {
		return nil
	}
	s.InferenceValue = &v
	return s
}

// Hostname of current ingest on which the stream is being captured
// Format: server_name (server_name)
func (s CentralStreamLayoutImpl) Ingest() *ServerName {
	return s.IngestValue
}

// Hostname of current ingest on which the stream is being captured
// Format: server_name (server_name)
func (s *CentralStreamLayoutImpl) SetIngest(v ServerName) CentralStreamLayout {
	if s == nil {
		return nil
	}
	s.IngestValue = &v
	return s
}

// History of layout ingest. This field includes only 5 last records.
// This field is only returned with explicit `include_ingest_history=true` query param.
func (s CentralStreamLayoutImpl) IngestHistory() []CentralStreamLayoutBase {
	if s.IngestHistoryValue == nil {
		return nil
	}
	result := make([]CentralStreamLayoutBase, len(s.IngestHistoryValue))
	for i, item := range s.IngestHistoryValue {
		result[i] = item
	}
	return result
}

// History of layout ingest. This field includes only 5 last records.
// This field is only returned with explicit `include_ingest_history=true` query param.
func (s *CentralStreamLayoutImpl) SetIngestHistory(v []CentralStreamLayoutBase) CentralStreamLayout {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*CentralStreamLayoutBaseImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*CentralStreamLayoutBaseImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.IngestHistoryValue = impl
	}
	return s
}

// List of decisions made by [layouter](https://flussonic.com/doc/api/layouter/) for each node.
// These decisions are used to determine the final layout of the stream.
func (s CentralStreamLayoutImpl) NodeLayoutDecisions() []CentralNodeLayoutDecision {
	if s.NodeLayoutDecisionsValue == nil {
		return nil
	}
	result := make([]CentralNodeLayoutDecision, len(s.NodeLayoutDecisionsValue))
	for i, item := range s.NodeLayoutDecisionsValue {
		result[i] = item
	}
	return result
}

// List of decisions made by [layouter](https://flussonic.com/doc/api/layouter/) for each node.
// These decisions are used to determine the final layout of the stream.
func (s *CentralStreamLayoutImpl) SetNodeLayoutDecisions(v []CentralNodeLayoutDecision) CentralStreamLayout {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*CentralNodeLayoutDecisionImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*CentralNodeLayoutDecisionImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.NodeLayoutDecisionsValue = impl
	}
	return s
}

// Service or admin user who changed the layout of the stream using an API call.
func (s CentralStreamLayoutImpl) Originator() *CentralStreamLayoutOriginator {
	return s.OriginatorValue
}

// Service or admin user who changed the layout of the stream using an API call.
func (s *CentralStreamLayoutImpl) SetOriginator(v CentralStreamLayoutOriginator) CentralStreamLayout {
	if s == nil {
		return nil
	}
	s.OriginatorValue = &v
	return s
}

// NewCentralStreamLayoutBase creates a new CentralStreamLayoutBase instance
func NewCentralStreamLayoutBase() CentralStreamLayoutBase {
	return &CentralStreamLayoutBaseImpl{}
}

// Time when the node change occurred
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s CentralStreamLayoutBaseImpl) CreatedAt() *UtcMs {
	return s.CreatedAtValue
}

// Time when the node change occurred
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s *CentralStreamLayoutBaseImpl) SetCreatedAt(v UtcMs) CentralStreamLayoutBase {
	if s == nil {
		return nil
	}
	s.CreatedAtValue = &v
	return s
}

// Hostname of current ingest on which the stream is being captured
// Format: server_name (server_name)
func (s CentralStreamLayoutBaseImpl) Ingest() *ServerName {
	return s.IngestValue
}

// Hostname of current ingest on which the stream is being captured
// Format: server_name (server_name)
func (s *CentralStreamLayoutBaseImpl) SetIngest(v ServerName) CentralStreamLayoutBase {
	if s == nil {
		return nil
	}
	s.IngestValue = &v
	return s
}

// Service or admin user who changed the layout of the stream using an API call.
func (s CentralStreamLayoutBaseImpl) Originator() *CentralStreamLayoutOriginator {
	return s.OriginatorValue
}

// Service or admin user who changed the layout of the stream using an API call.
func (s *CentralStreamLayoutBaseImpl) SetOriginator(v CentralStreamLayoutOriginator) CentralStreamLayoutBase {
	if s == nil {
		return nil
	}
	s.OriginatorValue = &v
	return s
}

// NewCentralStreamLayoutListItem creates a new CentralStreamLayoutListItem instance
func NewCentralStreamLayoutListItem() CentralStreamLayoutListItem {
	return &CentralStreamLayoutListItemImpl{}
}

// Reason why layout was changed
func (s CentralStreamLayoutListItemImpl) ChangeReason() *CentralStreamLayoutChangeReason {
	return s.ChangeReasonValue
}

// Reason why layout was changed
func (s *CentralStreamLayoutListItemImpl) SetChangeReason(v CentralStreamLayoutChangeReason) CentralStreamLayoutListItem {
	if s == nil {
		return nil
	}
	s.ChangeReasonValue = &v
	return s
}

// Time when the node change occurred
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s CentralStreamLayoutListItemImpl) CreatedAt() *UtcMs {
	return s.CreatedAtValue
}

// Time when the node change occurred
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s *CentralStreamLayoutListItemImpl) SetCreatedAt(v UtcMs) CentralStreamLayoutListItem {
	if s == nil {
		return nil
	}
	s.CreatedAtValue = &v
	return s
}

// Current nodes on which the dvr backup is saving
func (s CentralStreamLayoutListItemImpl) DvrBackups() []ServerName {
	return s.DvrBackupsValue
}

// Current nodes on which the dvr backup is saving
func (s *CentralStreamLayoutListItemImpl) SetDvrBackups(v []ServerName) CentralStreamLayoutListItem {
	if s == nil {
		return nil
	}
	s.DvrBackupsValue = v
	return s
}

// Hostname of current inference node on which stream analytics running.
// Format: server_name (server_name)
func (s CentralStreamLayoutListItemImpl) Inference() *ServerName {
	return s.InferenceValue
}

// Hostname of current inference node on which stream analytics running.
// Format: server_name (server_name)
func (s *CentralStreamLayoutListItemImpl) SetInference(v ServerName) CentralStreamLayoutListItem {
	if s == nil {
		return nil
	}
	s.InferenceValue = &v
	return s
}

// Hostname of current ingest on which the stream is being captured
// Format: server_name (server_name)
func (s CentralStreamLayoutListItemImpl) Ingest() *ServerName {
	return s.IngestValue
}

// Hostname of current ingest on which the stream is being captured
// Format: server_name (server_name)
func (s *CentralStreamLayoutListItemImpl) SetIngest(v ServerName) CentralStreamLayoutListItem {
	if s == nil {
		return nil
	}
	s.IngestValue = &v
	return s
}

// History of layout ingest. This field includes only 5 last records.
// This field is only returned with explicit `include_ingest_history=true` query param.
func (s CentralStreamLayoutListItemImpl) IngestHistory() []CentralStreamLayoutBase {
	if s.IngestHistoryValue == nil {
		return nil
	}
	result := make([]CentralStreamLayoutBase, len(s.IngestHistoryValue))
	for i, item := range s.IngestHistoryValue {
		result[i] = item
	}
	return result
}

// History of layout ingest. This field includes only 5 last records.
// This field is only returned with explicit `include_ingest_history=true` query param.
func (s *CentralStreamLayoutListItemImpl) SetIngestHistory(v []CentralStreamLayoutBase) CentralStreamLayoutListItem {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*CentralStreamLayoutBaseImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*CentralStreamLayoutBaseImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.IngestHistoryValue = impl
	}
	return s
}

// Name of the stream
func (s CentralStreamLayoutListItemImpl) Name() *string {
	return s.NameValue
}

// Name of the stream
func (s *CentralStreamLayoutListItemImpl) SetName(v string) CentralStreamLayoutListItem {
	if s == nil {
		return nil
	}
	s.NameValue = &v
	return s
}

// List of decisions made by [layouter](https://flussonic.com/doc/api/layouter/) for each node.
// These decisions are used to determine the final layout of the stream.
func (s CentralStreamLayoutListItemImpl) NodeLayoutDecisions() []CentralNodeLayoutDecision {
	if s.NodeLayoutDecisionsValue == nil {
		return nil
	}
	result := make([]CentralNodeLayoutDecision, len(s.NodeLayoutDecisionsValue))
	for i, item := range s.NodeLayoutDecisionsValue {
		result[i] = item
	}
	return result
}

// List of decisions made by [layouter](https://flussonic.com/doc/api/layouter/) for each node.
// These decisions are used to determine the final layout of the stream.
func (s *CentralStreamLayoutListItemImpl) SetNodeLayoutDecisions(v []CentralNodeLayoutDecision) CentralStreamLayoutListItem {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*CentralNodeLayoutDecisionImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*CentralNodeLayoutDecisionImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.NodeLayoutDecisionsValue = impl
	}
	return s
}

// Service or admin user who changed the layout of the stream using an API call.
func (s CentralStreamLayoutListItemImpl) Originator() *CentralStreamLayoutOriginator {
	return s.OriginatorValue
}

// Service or admin user who changed the layout of the stream using an API call.
func (s *CentralStreamLayoutListItemImpl) SetOriginator(v CentralStreamLayoutOriginator) CentralStreamLayoutListItem {
	if s == nil {
		return nil
	}
	s.OriginatorValue = &v
	return s
}

// NewCentralStreamLayoutPrediction creates a new CentralStreamLayoutPrediction instance
func NewCentralStreamLayoutPrediction() CentralStreamLayoutPrediction {
	return &CentralStreamLayoutPredictionImpl{}
}

// List of streams layout changes
func (s CentralStreamLayoutPredictionImpl) Changes() []CentralStreamLayoutListItem {
	if s.ChangesValue == nil {
		return nil
	}
	result := make([]CentralStreamLayoutListItem, len(s.ChangesValue))
	for i, item := range s.ChangesValue {
		result[i] = item
	}
	return result
}

// List of streams layout changes
func (s *CentralStreamLayoutPredictionImpl) SetChanges(v []CentralStreamLayoutListItem) CentralStreamLayoutPrediction {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*CentralStreamLayoutListItemImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*CentralStreamLayoutListItemImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.ChangesValue = impl
	}
	return s
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s CentralStreamLayoutPredictionImpl) EstimatedCount() *int {
	return s.EstimatedCountValue
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s *CentralStreamLayoutPredictionImpl) SetEstimatedCount(v int) CentralStreamLayoutPrediction {
	if s == nil {
		return nil
	}
	s.EstimatedCountValue = &v
	return s
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s CentralStreamLayoutPredictionImpl) Next() *string {
	return s.NextValue
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s *CentralStreamLayoutPredictionImpl) SetNext(v string) CentralStreamLayoutPrediction {
	if s == nil {
		return nil
	}
	s.NextValue = &v
	return s
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s CentralStreamLayoutPredictionImpl) Prev() *string {
	return s.PrevValue
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s *CentralStreamLayoutPredictionImpl) SetPrev(v string) CentralStreamLayoutPrediction {
	if s == nil {
		return nil
	}
	s.PrevValue = &v
	return s
}

// An object with a list of different timings measured during this API call.
func (s CentralStreamLayoutPredictionImpl) Timing() any {
	return s.TimingValue
}

// An object with a list of different timings measured during this API call.
func (s *CentralStreamLayoutPredictionImpl) SetTiming(v any) CentralStreamLayoutPrediction {
	if s == nil {
		return nil
	}
	s.TimingValue = v
	return s
}

// Collection returns the collection items from CentralStreamLayoutPrediction
func (s CentralStreamLayoutPredictionImpl) Collection() []CentralStreamLayoutListItem {
	return s.Changes()
}

// NewCentralStreamLayouts creates a new CentralStreamLayouts instance
func NewCentralStreamLayouts() CentralStreamLayouts {
	return &CentralStreamLayoutsImpl{}
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s CentralStreamLayoutsImpl) EstimatedCount() *int {
	return s.EstimatedCountValue
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s *CentralStreamLayoutsImpl) SetEstimatedCount(v int) CentralStreamLayouts {
	if s == nil {
		return nil
	}
	s.EstimatedCountValue = &v
	return s
}

// List of streams layouts records according to the query parameters.
func (s CentralStreamLayoutsImpl) Layouts() []CentralStreamLayout {
	if s.LayoutsValue == nil {
		return nil
	}
	result := make([]CentralStreamLayout, len(s.LayoutsValue))
	for i, item := range s.LayoutsValue {
		result[i] = item
	}
	return result
}

// List of streams layouts records according to the query parameters.
func (s *CentralStreamLayoutsImpl) SetLayouts(v []CentralStreamLayout) CentralStreamLayouts {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*CentralStreamLayoutImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*CentralStreamLayoutImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.LayoutsValue = impl
	}
	return s
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s CentralStreamLayoutsImpl) Next() *string {
	return s.NextValue
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s *CentralStreamLayoutsImpl) SetNext(v string) CentralStreamLayouts {
	if s == nil {
		return nil
	}
	s.NextValue = &v
	return s
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s CentralStreamLayoutsImpl) Prev() *string {
	return s.PrevValue
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s *CentralStreamLayoutsImpl) SetPrev(v string) CentralStreamLayouts {
	if s == nil {
		return nil
	}
	s.PrevValue = &v
	return s
}

// An object with a list of different timings measured during this API call.
func (s CentralStreamLayoutsImpl) Timing() any {
	return s.TimingValue
}

// An object with a list of different timings measured during this API call.
func (s *CentralStreamLayoutsImpl) SetTiming(v any) CentralStreamLayouts {
	if s == nil {
		return nil
	}
	s.TimingValue = v
	return s
}

// Collection returns the collection items from CentralStreamLayouts
func (s CentralStreamLayoutsImpl) Collection() []CentralStreamLayout {
	return s.Layouts()
}

// NewCentralStreamerLayoutPrediction creates a new CentralStreamerLayoutPrediction instance
func NewCentralStreamerLayoutPrediction() CentralStreamerLayoutPrediction {
	return &CentralStreamerLayoutPredictionImpl{}
}

// Predicted layout based on changed properties of streamer grouped by hostname and role.
// The result does not contain unchanged streamers.
// If streamer config was not changed, the result will be empty.
func (s CentralStreamerLayoutPredictionImpl) Changes() []CentralStreamerLayoutPredictionItem {
	if s.ChangesValue == nil {
		return nil
	}
	result := make([]CentralStreamerLayoutPredictionItem, len(s.ChangesValue))
	for i, item := range s.ChangesValue {
		result[i] = item
	}
	return result
}

// Predicted layout based on changed properties of streamer grouped by hostname and role.
// The result does not contain unchanged streamers.
// If streamer config was not changed, the result will be empty.
func (s *CentralStreamerLayoutPredictionImpl) SetChanges(v []CentralStreamerLayoutPredictionItem) CentralStreamerLayoutPrediction {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*CentralStreamerLayoutPredictionItemImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*CentralStreamerLayoutPredictionItemImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.ChangesValue = impl
	}
	return s
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s CentralStreamerLayoutPredictionImpl) EstimatedCount() *int {
	return s.EstimatedCountValue
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s *CentralStreamerLayoutPredictionImpl) SetEstimatedCount(v int) CentralStreamerLayoutPrediction {
	if s == nil {
		return nil
	}
	s.EstimatedCountValue = &v
	return s
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s CentralStreamerLayoutPredictionImpl) Next() *string {
	return s.NextValue
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s *CentralStreamerLayoutPredictionImpl) SetNext(v string) CentralStreamerLayoutPrediction {
	if s == nil {
		return nil
	}
	s.NextValue = &v
	return s
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s CentralStreamerLayoutPredictionImpl) Prev() *string {
	return s.PrevValue
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s *CentralStreamerLayoutPredictionImpl) SetPrev(v string) CentralStreamerLayoutPrediction {
	if s == nil {
		return nil
	}
	s.PrevValue = &v
	return s
}

// An object with a list of different timings measured during this API call.
func (s CentralStreamerLayoutPredictionImpl) Timing() any {
	return s.TimingValue
}

// An object with a list of different timings measured during this API call.
func (s *CentralStreamerLayoutPredictionImpl) SetTiming(v any) CentralStreamerLayoutPrediction {
	if s == nil {
		return nil
	}
	s.TimingValue = v
	return s
}

// Collection returns the collection items from CentralStreamerLayoutPrediction
func (s CentralStreamerLayoutPredictionImpl) Collection() []CentralStreamerLayoutPredictionItem {
	return s.Changes()
}

// NewCentralStreamerLayoutPredictionItem creates a new CentralStreamerLayoutPredictionItem instance
func NewCentralStreamerLayoutPredictionItem() CentralStreamerLayoutPredictionItem {
	return &CentralStreamerLayoutPredictionItemImpl{}
}

// Number of streams assigned to the streamer after the layouter iteration.
// Example: 123
func (s CentralStreamerLayoutPredictionItemImpl) After() *int {
	return s.AfterValue
}

// Number of streams assigned to the streamer after the layouter iteration.
// Example: 123
func (s *CentralStreamerLayoutPredictionItemImpl) SetAfter(v int) CentralStreamerLayoutPredictionItem {
	if s == nil {
		return nil
	}
	s.AfterValue = &v
	return s
}

// Number of streams assigned to the streamer before the layouter iteration.
// Example: 321
func (s CentralStreamerLayoutPredictionItemImpl) Before() *int {
	return s.BeforeValue
}

// Number of streams assigned to the streamer before the layouter iteration.
// Example: 321
func (s *CentralStreamerLayoutPredictionItemImpl) SetBefore(v int) CentralStreamerLayoutPredictionItem {
	if s == nil {
		return nil
	}
	s.BeforeValue = &v
	return s
}

// `after - before` value.
// Example: 1
func (s CentralStreamerLayoutPredictionItemImpl) Delta() *int {
	return s.DeltaValue
}

// `after - before` value.
// Example: 1
func (s *CentralStreamerLayoutPredictionItemImpl) SetDelta(v int) CentralStreamerLayoutPredictionItem {
	if s == nil {
		return nil
	}
	s.DeltaValue = &v
	return s
}

// Hostname of streamer
// Format: server_name (server_name)
// Example: streamer1
func (s CentralStreamerLayoutPredictionItemImpl) Hostname() *ServerName {
	return s.HostnameValue
}

// Hostname of streamer
// Format: server_name (server_name)
// Example: streamer1
func (s *CentralStreamerLayoutPredictionItemImpl) SetHostname(v ServerName) CentralStreamerLayoutPredictionItem {
	if s == nil {
		return nil
	}
	s.HostnameValue = &v
	return s
}

// Layout role of streamer.
// Example: ingest
func (s CentralStreamerLayoutPredictionItemImpl) Role() *CentralStreamerLayoutPredictionItemRole {
	return s.RoleValue
}

// Layout role of streamer.
// Example: ingest
func (s *CentralStreamerLayoutPredictionItemImpl) SetRole(v CentralStreamerLayoutPredictionItemRole) CentralStreamerLayoutPredictionItem {
	if s == nil {
		return nil
	}
	s.RoleValue = &v
	return s
}

// NewCertificateInfo creates a new CertificateInfo instance
func NewCertificateInfo() CertificateInfo {
	return &CertificateInfoImpl{}
}

// One or more domains for which the certificate is issued.
func (s CertificateInfoImpl) Domains() []string {
	return s.DomainsValue
}

// One or more domains for which the certificate is issued.
func (s *CertificateInfoImpl) SetDomains(v []string) CertificateInfo {
	if s == nil {
		return nil
	}
	s.DomainsValue = v
	return s
}

// The name of the issuing authority.
func (s CertificateInfoImpl) IssuerName() *string {
	return s.IssuerNameValue
}

// The name of the issuing authority.
func (s *CertificateInfoImpl) SetIssuerName(v string) CertificateInfo {
	if s == nil {
		return nil
	}
	s.IssuerNameValue = &v
	return s
}

// End date of the certificate.
func (s CertificateInfoImpl) NotAfter() *int {
	return s.NotAfterValue
}

// End date of the certificate.
func (s *CertificateInfoImpl) SetNotAfter(v int) CertificateInfo {
	if s == nil {
		return nil
	}
	s.NotAfterValue = &v
	return s
}

// Start date of the certificate.
func (s CertificateInfoImpl) NotBefore() *int {
	return s.NotBeforeValue
}

// Start date of the certificate.
func (s *CertificateInfoImpl) SetNotBefore(v int) CertificateInfo {
	if s == nil {
		return nil
	}
	s.NotBeforeValue = &v
	return s
}

// Public key.
func (s CertificateInfoImpl) PublicKey() *string {
	return s.PublicKeyValue
}

// Public key.
func (s *CertificateInfoImpl) SetPublicKey(v string) CertificateInfo {
	if s == nil {
		return nil
	}
	s.PublicKeyValue = &v
	return s
}

// NewChassisConfig creates a new ChassisConfig instance
func NewChassisConfig() ChassisConfig {
	return &ChassisConfigImpl{}
}

// Private port for API requests to the chassis from coders.
func (s ChassisConfigImpl) APIPort() *ListenSpec {
	return s.APIPortValue
}

// Private port for API requests to the chassis from coders.
func (s *ChassisConfigImpl) SetAPIPort(v *ListenSpec) ChassisConfig {
	if s == nil {
		return nil
	}
	s.APIPortValue = v
	return s
}

// Shows if auto restart of coders when (re)starting chassis is enabled.
func (s ChassisConfigImpl) AutoReboot() *bool {
	return s.AutoRebootValue
}

// Shows if auto restart of coders when (re)starting chassis is enabled.
func (s *ChassisConfigImpl) SetAutoReboot(v bool) ChassisConfig {
	if s == nil {
		return nil
	}
	s.AutoRebootValue = &v
	return s
}

// If `default_gateway` parameters are set the individual interfaces config,
// this gateway is only used for checking license and updates.
// Otherwise, it is used as gateway for all traffic.
// Example: streaming
func (s ChassisConfigImpl) DefaultGatewayInterface() *string {
	return s.DefaultGatewayInterfaceValue
}

// If `default_gateway` parameters are set the individual interfaces config,
// this gateway is only used for checking license and updates.
// Otherwise, it is used as gateway for all traffic.
// Example: streaming
func (s *ChassisConfigImpl) SetDefaultGatewayInterface(v string) ChassisConfig {
	if s == nil {
		return nil
	}
	s.DefaultGatewayInterfaceValue = &v
	return s
}

// Network interface for automatic reception of IP address from DHCP server.
// This interface will be used for launching coders.
// Format: interface_name (interface_name)
func (s ChassisConfigImpl) DhcpdIface() *InterfaceName {
	return s.DhcpdIfaceValue
}

// Network interface for automatic reception of IP address from DHCP server.
// This interface will be used for launching coders.
// Format: interface_name (interface_name)
func (s *ChassisConfigImpl) SetDhcpdIface(v InterfaceName) ChassisConfig {
	if s == nil {
		return nil
	}
	s.DhcpdIfaceValue = &v
	return s
}

// Source port for DHCP requests.
func (s ChassisConfigImpl) DhcpdPort() *ListenSpec {
	return s.DhcpdPortValue
}

// Source port for DHCP requests.
func (s *ChassisConfigImpl) SetDhcpdPort(v *ListenSpec) ChassisConfig {
	if s == nil {
		return nil
	}
	s.DhcpdPortValue = v
	return s
}

// Destination port for DHCP requests.
func (s ChassisConfigImpl) DhcpdPortDest() *ListenSpec {
	return s.DhcpdPortDestValue
}

// Destination port for DHCP requests.
func (s *ChassisConfigImpl) SetDhcpdPortDest(v *ListenSpec) ChassisConfig {
	if s == nil {
		return nil
	}
	s.DhcpdPortDestValue = v
	return s
}

// Directory to boot the device from. This is also where the firmware is downloaded on updates.
// Format: disk_path (disk_path)
func (s ChassisConfigImpl) FirmwareBootDir() *DiskPath {
	return s.FirmwareBootDirValue
}

// Directory to boot the device from. This is also where the firmware is downloaded on updates.
// Format: disk_path (disk_path)
func (s *ChassisConfigImpl) SetFirmwareBootDir(v DiskPath) ChassisConfig {
	if s == nil {
		return nil
	}
	s.FirmwareBootDirValue = &v
	return s
}

// URL for downloading firmware.
// Format: url (url)
func (s ChassisConfigImpl) FirmwareHost() *URL {
	return s.FirmwareHostValue
}

// URL for downloading firmware.
// Format: url (url)
func (s *ChassisConfigImpl) SetFirmwareHost(v URL) ChassisConfig {
	if s == nil {
		return nil
	}
	s.FirmwareHostValue = &v
	return s
}

// Firmware version installed on the device.
func (s ChassisConfigImpl) FirmwareVersion() *string {
	return s.FirmwareVersionValue
}

// Firmware version installed on the device.
func (s *ChassisConfigImpl) SetFirmwareVersion(v string) ChassisConfig {
	if s == nil {
		return nil
	}
	s.FirmwareVersionValue = &v
	return s
}

// The name of the chassis server.
// Format: server_name (server_name)
// Example: coder1.example.com
func (s ChassisConfigImpl) Hostname() *ServerName {
	return s.HostnameValue
}

// The name of the chassis server.
// Format: server_name (server_name)
// Example: coder1.example.com
func (s *ChassisConfigImpl) SetHostname(v ServerName) ChassisConfig {
	if s == nil {
		return nil
	}
	s.HostnameValue = &v
	return s
}

// Shows if LCD monitor capabilities are enabled in the firmware.
func (s ChassisConfigImpl) Lcd() *bool {
	return s.LcdValue
}

// Shows if LCD monitor capabilities are enabled in the firmware.
func (s *ChassisConfigImpl) SetLcd(v bool) ChassisConfig {
	if s == nil {
		return nil
	}
	s.LcdValue = &v
	return s
}

// List of NTP server host names or IP addresses
func (s ChassisConfigImpl) NtpServers() []string {
	return s.NtpServersValue
}

// List of NTP server host names or IP addresses
func (s *ChassisConfigImpl) SetNtpServers(v []string) ChassisConfig {
	if s == nil {
		return nil
	}
	s.NtpServersValue = v
	return s
}

// Network interface for NTP daemon.
// Format: interface_name (interface_name)
func (s ChassisConfigImpl) NtpdIface() *InterfaceName {
	return s.NtpdIfaceValue
}

// Network interface for NTP daemon.
// Format: interface_name (interface_name)
func (s *ChassisConfigImpl) SetNtpdIface(v InterfaceName) ChassisConfig {
	if s == nil {
		return nil
	}
	s.NtpdIfaceValue = &v
	return s
}

// Port for NTP daemon.
func (s ChassisConfigImpl) NtpdPort() *ListenSpec {
	return s.NtpdPortValue
}

// Port for NTP daemon.
func (s *ChassisConfigImpl) SetNtpdPort(v *ListenSpec) ChassisConfig {
	if s == nil {
		return nil
	}
	s.NtpdPortValue = v
	return s
}

// Coder product name
func (s ChassisConfigImpl) ProductName() *ChassisProduct {
	return s.ProductNameValue
}

// Coder product name
func (s *ChassisConfigImpl) SetProductName(v ChassisProduct) ChassisConfig {
	if s == nil {
		return nil
	}
	s.ProductNameValue = &v
	return s
}

// Timeout for restarting coders.
func (s ChassisConfigImpl) RestartCoderTimeout() *int {
	return s.RestartCoderTimeoutValue
}

// Timeout for restarting coders.
func (s *ChassisConfigImpl) SetRestartCoderTimeout(v int) ChassisConfig {
	if s == nil {
		return nil
	}
	s.RestartCoderTimeoutValue = &v
	return s
}

// Statistics of the chassis connections.
func (s ChassisConfigImpl) Stats() ChassisStats {
	return s.StatsValue
}

// Statistics of the chassis connections.
func (s *ChassisConfigImpl) SetStats(v ChassisStats) ChassisConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ChassisStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// Port for TFTP used for loading program core to the coders.
func (s ChassisConfigImpl) TftpPort() *ListenSpec {
	return s.TftpPortValue
}

// Port for TFTP used for loading program core to the coders.
func (s *ChassisConfigImpl) SetTftpPort(v *ListenSpec) ChassisConfig {
	if s == nil {
		return nil
	}
	s.TftpPortValue = v
	return s
}

// TFTP root directory.
// Format: disk_path (disk_path)
func (s ChassisConfigImpl) TftpRoot() *DiskPath {
	return s.TftpRootValue
}

// TFTP root directory.
// Format: disk_path (disk_path)
func (s *ChassisConfigImpl) SetTftpRoot(v DiskPath) ChassisConfig {
	if s == nil {
		return nil
	}
	s.TftpRootValue = &v
	return s
}

// Update channel specified in the config file.
func (s ChassisConfigImpl) UpdateChannel() *string {
	return s.UpdateChannelValue
}

// Update channel specified in the config file.
func (s *ChassisConfigImpl) SetUpdateChannel(v string) ChassisConfig {
	if s == nil {
		return nil
	}
	s.UpdateChannelValue = &v
	return s
}

// NewChassisStats creates a new ChassisStats instance
func NewChassisStats() ChassisStats {
	return &ChassisStatsImpl{}
}

// MAC address of the manage0 interface.
func (s ChassisStatsImpl) HardwareID() *string {
	return s.HardwareIDValue
}

// MAC address of the manage0 interface.
func (s *ChassisStatsImpl) SetHardwareID(v string) ChassisStats {
	if s == nil {
		return nil
	}
	s.HardwareIDValue = &v
	return s
}

// Hostname of the server.
// Example: coder1.example.com
func (s ChassisStatsImpl) Hostname() *string {
	return s.HostnameValue
}

// Hostname of the server.
// Example: coder1.example.com
func (s *ChassisStatsImpl) SetHostname(v string) ChassisStats {
	if s == nil {
		return nil
	}
	s.HostnameValue = &v
	return s
}

// The chassis model name.
// Example: chassis_model
func (s ChassisStatsImpl) Model() *string {
	return s.ModelValue
}

// The chassis model name.
// Example: chassis_model
func (s *ChassisStatsImpl) SetModel(v string) ChassisStats {
	if s == nil {
		return nil
	}
	s.ModelValue = &v
	return s
}

// Deprecated field. Will be deleted at 24.10
// The latest available version of the firmware, if any. Deprecated. Last available version could be obtained from `chassis_firmwares_list`
func (s ChassisStatsImpl) NextVersion() *string {
	return s.NextVersionValue
}

// Deprecated field. Will be deleted at 24.10
// The latest available version of the firmware, if any. Deprecated. Last available version could be obtained from `chassis_firmwares_list`
func (s *ChassisStatsImpl) SetNextVersion(v string) ChassisStats {
	if s == nil {
		return nil
	}
	s.NextVersionValue = &v
	return s
}

// Whether a system clock synchronized with NTP server
func (s ChassisStatsImpl) NtpClockSynchronized() *bool {
	return s.NtpClockSynchronizedValue
}

// Whether a system clock synchronized with NTP server
func (s *ChassisStatsImpl) SetNtpClockSynchronized(v bool) ChassisStats {
	if s == nil {
		return nil
	}
	s.NtpClockSynchronizedValue = &v
	return s
}

// The serial number of the chassis.
// Example: 2174220024
func (s ChassisStatsImpl) SerialNumber() *string {
	return s.SerialNumberValue
}

// The serial number of the chassis.
// Example: 2174220024
func (s *ChassisStatsImpl) SetSerialNumber(v string) ChassisStats {
	if s == nil {
		return nil
	}
	s.SerialNumberValue = &v
	return s
}

// Chassis system time (in UTC milliseconds)
// Format: utc_ms (Unix timestamp in milliseconds)
func (s ChassisStatsImpl) SystemTime() *UtcMs {
	return s.SystemTimeValue
}

// Chassis system time (in UTC milliseconds)
// Format: utc_ms (Unix timestamp in milliseconds)
func (s *ChassisStatsImpl) SetSystemTime(v UtcMs) ChassisStats {
	if s == nil {
		return nil
	}
	s.SystemTimeValue = &v
	return s
}

// Deprecated field. Will be deleted at 24.10
// Full version number of the firmware. Deprecated. Version could be found at `chassis_config/firmware_version`
// Example: 21.09.1-234
func (s ChassisStatsImpl) Version() *string {
	return s.VersionValue
}

// Deprecated field. Will be deleted at 24.10
// Full version number of the firmware. Deprecated. Version could be found at `chassis_config/firmware_version`
// Example: 21.09.1-234
func (s *ChassisStatsImpl) SetVersion(v string) ChassisStats {
	if s == nil {
		return nil
	}
	s.VersionValue = &v
	return s
}

// NewClosedCaptions creates a new ClosedCaptions instance
func NewClosedCaptions() ClosedCaptions {
	return &ClosedCaptionsImpl{}
}

// Language of closed captions.
// Example: eng
func (s ClosedCaptionsImpl) Language() *string {
	return s.LanguageValue
}

// Language of closed captions.
// Example: eng
func (s *ClosedCaptionsImpl) SetLanguage(v string) ClosedCaptions {
	if s == nil {
		return nil
	}
	s.LanguageValue = &v
	return s
}

// Under what name the audio track will be displayed on the player.
// Example: English
func (s ClosedCaptionsImpl) Name() *string {
	return s.NameValue
}

// Under what name the audio track will be displayed on the player.
// Example: English
func (s *ClosedCaptionsImpl) SetName(v string) ClosedCaptions {
	if s == nil {
		return nil
	}
	s.NameValue = &v
	return s
}

// NewClusterHealthMetricsTotal creates a new ClusterHealthMetricsTotal instance
func NewClusterHealthMetricsTotal() ClusterHealthMetricsTotal {
	return &ClusterHealthMetricsTotalImpl{}
}

// Number of degraded entities
func (s ClusterHealthMetricsTotalImpl) Degradated() *int {
	return s.DegradatedValue
}

// Number of degraded entities
func (s *ClusterHealthMetricsTotalImpl) SetDegradated(v int) ClusterHealthMetricsTotal {
	if s == nil {
		return nil
	}
	s.DegradatedValue = &v
	return s
}

// Number of disabled entities
func (s ClusterHealthMetricsTotalImpl) Disabled() *int {
	return s.DisabledValue
}

// Number of disabled entities
func (s *ClusterHealthMetricsTotalImpl) SetDisabled(v int) ClusterHealthMetricsTotal {
	if s == nil {
		return nil
	}
	s.DisabledValue = &v
	return s
}

// Number of operational entities
func (s ClusterHealthMetricsTotalImpl) Operational() *int {
	return s.OperationalValue
}

// Number of operational entities
func (s *ClusterHealthMetricsTotalImpl) SetOperational(v int) ClusterHealthMetricsTotal {
	if s == nil {
		return nil
	}
	s.OperationalValue = &v
	return s
}

// Number of outage entities
func (s ClusterHealthMetricsTotalImpl) Outage() *int {
	return s.OutageValue
}

// Number of outage entities
func (s *ClusterHealthMetricsTotalImpl) SetOutage(v int) ClusterHealthMetricsTotal {
	if s == nil {
		return nil
	}
	s.OutageValue = &v
	return s
}

// Number of partial outage entities
func (s ClusterHealthMetricsTotalImpl) PartialOutage() *int {
	return s.PartialOutageValue
}

// Number of partial outage entities
func (s *ClusterHealthMetricsTotalImpl) SetPartialOutage(v int) ClusterHealthMetricsTotal {
	if s == nil {
		return nil
	}
	s.PartialOutageValue = &v
	return s
}

// Total number of entities
func (s ClusterHealthMetricsTotalImpl) Total() *int {
	return s.TotalValue
}

// Total number of entities
func (s *ClusterHealthMetricsTotalImpl) SetTotal(v int) ClusterHealthMetricsTotal {
	if s == nil {
		return nil
	}
	s.TotalValue = &v
	return s
}

// NewClusterHealthStats creates a new ClusterHealthStats instance
func NewClusterHealthStats() ClusterHealthStats {
	return &ClusterHealthStatsImpl{}
}

// Number of agents, grouped by status
func (s ClusterHealthStatsImpl) AgentMetricsTotal() ClusterHealthMetricsTotal {
	return s.AgentMetricsTotalValue
}

// Number of agents, grouped by status
func (s *ClusterHealthStatsImpl) SetAgentMetricsTotal(v ClusterHealthMetricsTotal) ClusterHealthStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ClusterHealthMetricsTotalImpl); ok {
		s.AgentMetricsTotalValue = impl
	}
	return s
}

// Metrics collection time
// Format: utc_ms (Unix timestamp in milliseconds)
func (s ClusterHealthStatsImpl) CollectedAt() *UtcMs {
	return s.CollectedAtValue
}

// Metrics collection time
// Format: utc_ms (Unix timestamp in milliseconds)
func (s *ClusterHealthStatsImpl) SetCollectedAt(v UtcMs) ClusterHealthStats {
	if s == nil {
		return nil
	}
	s.CollectedAtValue = &v
	return s
}

// Unique server ID generated on a first run.
// Format: uuid (uuid)
// Example: 123e4567-e89b-12d3-a456-426655440000
func (s ClusterHealthStatsImpl) ServerID() *UUID {
	return s.ServerIDValue
}

// Unique server ID generated on a first run.
// Format: uuid (uuid)
// Example: 123e4567-e89b-12d3-a456-426655440000
func (s *ClusterHealthStatsImpl) SetServerID(v UUID) ClusterHealthStats {
	if s == nil {
		return nil
	}
	s.ServerIDValue = &v
	return s
}

// Number of streams, grouped by status
func (s ClusterHealthStatsImpl) StreamMetricsTotal() ClusterHealthMetricsTotal {
	return s.StreamMetricsTotalValue
}

// Number of streams, grouped by status
func (s *ClusterHealthStatsImpl) SetStreamMetricsTotal(v ClusterHealthMetricsTotal) ClusterHealthStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ClusterHealthMetricsTotalImpl); ok {
		s.StreamMetricsTotalValue = impl
	}
	return s
}

// Cluster total bitrate metrics
func (s ClusterHealthStatsImpl) StreamerBitrateMetricsTotal() ClusterHealthStatsStreamerBitrateMetricsTotal {
	return s.StreamerBitrateMetricsTotalValue
}

// Cluster total bitrate metrics
func (s *ClusterHealthStatsImpl) SetStreamerBitrateMetricsTotal(v ClusterHealthStatsStreamerBitrateMetricsTotal) ClusterHealthStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ClusterHealthStatsStreamerBitrateMetricsTotalImpl); ok {
		s.StreamerBitrateMetricsTotalValue = impl
	}
	return s
}

// Streamer stats
func (s ClusterHealthStatsImpl) StreamerMetrics() []ClusterHealthStreamerStats {
	if s.StreamerMetricsValue == nil {
		return nil
	}
	result := make([]ClusterHealthStreamerStats, len(s.StreamerMetricsValue))
	for i, item := range s.StreamerMetricsValue {
		result[i] = item
	}
	return result
}

// Streamer stats
func (s *ClusterHealthStatsImpl) SetStreamerMetrics(v []ClusterHealthStreamerStats) ClusterHealthStats {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*ClusterHealthStreamerStatsImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*ClusterHealthStreamerStatsImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.StreamerMetricsValue = impl
	}
	return s
}

// Number of streamers, grouped by status
func (s ClusterHealthStatsImpl) StreamerMetricsTotal() ClusterHealthMetricsTotal {
	return s.StreamerMetricsTotalValue
}

// Number of streamers, grouped by status
func (s *ClusterHealthStatsImpl) SetStreamerMetricsTotal(v ClusterHealthMetricsTotal) ClusterHealthStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ClusterHealthMetricsTotalImpl); ok {
		s.StreamerMetricsTotalValue = impl
	}
	return s
}

// The running version of instance in format TAGCNUM. TAG is a five-digit number that contains the year number, month number, and version number. CNUM is a four-digit number that indicates the commit number. Number 240100023 represents version 24.01-23.
// Example: 2.40100023e+08
func (s ClusterHealthStatsImpl) Version() *int {
	return s.VersionValue
}

// The running version of instance in format TAGCNUM. TAG is a five-digit number that contains the year number, month number, and version number. CNUM is a four-digit number that indicates the commit number. Number 240100023 represents version 24.01-23.
// Example: 2.40100023e+08
func (s *ClusterHealthStatsImpl) SetVersion(v int) ClusterHealthStats {
	if s == nil {
		return nil
	}
	s.VersionValue = &v
	return s
}

// NewClusterHealthStatsStreamerBitrateMetricsTotal creates a new ClusterHealthStatsStreamerBitrateMetricsTotal instance
func NewClusterHealthStatsStreamerBitrateMetricsTotal() ClusterHealthStatsStreamerBitrateMetricsTotal {
	return &ClusterHealthStatsStreamerBitrateMetricsTotalImpl{}
}

// Current incoming speed (bitrate) of the data transmission over the network of all streamers.
// Format: speed (speed)
func (s ClusterHealthStatsStreamerBitrateMetricsTotalImpl) InputKbit() *Speed {
	return s.InputKbitValue
}

// Current incoming speed (bitrate) of the data transmission over the network of all streamers.
// Format: speed (speed)
func (s *ClusterHealthStatsStreamerBitrateMetricsTotalImpl) SetInputKbit(v Speed) ClusterHealthStatsStreamerBitrateMetricsTotal {
	if s == nil {
		return nil
	}
	s.InputKbitValue = &v
	return s
}

// Current outgoing speed (bitrate) of the data transmission over the network of all streamers.
// Format: speed (speed)
func (s ClusterHealthStatsStreamerBitrateMetricsTotalImpl) OutputKbit() *Speed {
	return s.OutputKbitValue
}

// Current outgoing speed (bitrate) of the data transmission over the network of all streamers.
// Format: speed (speed)
func (s *ClusterHealthStatsStreamerBitrateMetricsTotalImpl) SetOutputKbit(v Speed) ClusterHealthStatsStreamerBitrateMetricsTotal {
	if s == nil {
		return nil
	}
	s.OutputKbitValue = &v
	return s
}

// NewClusterHealthStreamerStats creates a new ClusterHealthStreamerStats instance
func NewClusterHealthStreamerStats() ClusterHealthStreamerStats {
	return &ClusterHealthStreamerStatsImpl{}
}

// Streamer agents info.
func (s ClusterHealthStreamerStatsImpl) AgentMetrics() ClusterHealthStreamerStatsAgentMetrics {
	return s.AgentMetricsValue
}

// Streamer agents info.
func (s *ClusterHealthStreamerStatsImpl) SetAgentMetrics(v ClusterHealthStreamerStatsAgentMetrics) ClusterHealthStreamerStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ClusterHealthStreamerStatsAgentMetricsImpl); ok {
		s.AgentMetricsValue = impl
	}
	return s
}

// Streamer config info.
func (s ClusterHealthStreamerStatsImpl) Config() ClusterHealthStreamerStatsConfig {
	return s.ConfigValue
}

// Streamer config info.
func (s *ClusterHealthStreamerStatsImpl) SetConfig(v ClusterHealthStreamerStatsConfig) ClusterHealthStreamerStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ClusterHealthStreamerStatsConfigImpl); ok {
		s.ConfigValue = impl
	}
	return s
}

// CPU usage info.
func (s ClusterHealthStreamerStatsImpl) Cpu() ClusterHealthStreamerStatsCpu {
	return s.CpuValue
}

// CPU usage info.
func (s *ClusterHealthStreamerStatsImpl) SetCpu(v ClusterHealthStreamerStatsCpu) ClusterHealthStreamerStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ClusterHealthStreamerStatsCpuImpl); ok {
		s.CpuValue = impl
	}
	return s
}

// Hostname of streamer.
// Format: server_name (server_name)
func (s ClusterHealthStreamerStatsImpl) Hostname() ServerName {
	return s.HostnameValue
}

// Hostname of streamer.
// Format: server_name (server_name)
func (s *ClusterHealthStreamerStatsImpl) SetHostname(v ServerName) ClusterHealthStreamerStats {
	if s == nil {
		return nil
	}
	s.HostnameValue = v
	return s
}

// Memory usage info.
func (s ClusterHealthStreamerStatsImpl) Memory() ClusterHealthStreamerStatsMemory {
	return s.MemoryValue
}

// Memory usage info.
func (s *ClusterHealthStreamerStatsImpl) SetMemory(v ClusterHealthStreamerStatsMemory) ClusterHealthStreamerStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ClusterHealthStreamerStatsMemoryImpl); ok {
		s.MemoryValue = impl
	}
	return s
}

// Network IO info.
func (s ClusterHealthStreamerStatsImpl) Network() ClusterHealthStreamerStatsNetwork {
	return s.NetworkValue
}

// Network IO info.
func (s *ClusterHealthStreamerStatsImpl) SetNetwork(v ClusterHealthStreamerStatsNetwork) ClusterHealthStreamerStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ClusterHealthStreamerStatsNetworkImpl); ok {
		s.NetworkValue = impl
	}
	return s
}

func (s ClusterHealthStreamerStatsImpl) Status() *ClusterHealthStatus {
	return s.StatusValue
}

func (s *ClusterHealthStreamerStatsImpl) SetStatus(v ClusterHealthStatus) ClusterHealthStreamerStats {
	if s == nil {
		return nil
	}
	s.StatusValue = &v
	return s
}

// Total disk usage info.
func (s ClusterHealthStreamerStatsImpl) Storage() ClusterHealthStreamerStatsStorage {
	return s.StorageValue
}

// Total disk usage info.
func (s *ClusterHealthStreamerStatsImpl) SetStorage(v ClusterHealthStreamerStatsStorage) ClusterHealthStreamerStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ClusterHealthStreamerStatsStorageImpl); ok {
		s.StorageValue = impl
	}
	return s
}

// Streamer streams info.
func (s ClusterHealthStreamerStatsImpl) StreamMetrics() ClusterHealthStreamerStatsStreamMetrics {
	return s.StreamMetricsValue
}

// Streamer streams info.
func (s *ClusterHealthStreamerStatsImpl) SetStreamMetrics(v ClusterHealthStreamerStatsStreamMetrics) ClusterHealthStreamerStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ClusterHealthStreamerStatsStreamMetricsImpl); ok {
		s.StreamMetricsValue = impl
	}
	return s
}

// The server uptime.
// Format: seconds (seconds)
// Example: 4.325502e+06
func (s ClusterHealthStreamerStatsImpl) Uptime() *Seconds {
	return s.UptimeValue
}

// The server uptime.
// Format: seconds (seconds)
// Example: 4.325502e+06
func (s *ClusterHealthStreamerStatsImpl) SetUptime(v Seconds) ClusterHealthStreamerStats {
	if s == nil {
		return nil
	}
	s.UptimeValue = &v
	return s
}

// NewClusterHealthStreamerStatsAgentMetrics creates a new ClusterHealthStreamerStatsAgentMetrics instance
func NewClusterHealthStreamerStatsAgentMetrics() ClusterHealthStreamerStatsAgentMetrics {
	return &ClusterHealthStreamerStatsAgentMetricsImpl{}
}

// Number of degraded entities
func (s ClusterHealthStreamerStatsAgentMetricsImpl) Degradated() *int {
	return s.DegradatedValue
}

// Number of degraded entities
func (s *ClusterHealthStreamerStatsAgentMetricsImpl) SetDegradated(v int) ClusterHealthStreamerStatsAgentMetrics {
	if s == nil {
		return nil
	}
	s.DegradatedValue = &v
	return s
}

// Number of disabled entities
func (s ClusterHealthStreamerStatsAgentMetricsImpl) Disabled() *int {
	return s.DisabledValue
}

// Number of disabled entities
func (s *ClusterHealthStreamerStatsAgentMetricsImpl) SetDisabled(v int) ClusterHealthStreamerStatsAgentMetrics {
	if s == nil {
		return nil
	}
	s.DisabledValue = &v
	return s
}

// Number of operational entities
func (s ClusterHealthStreamerStatsAgentMetricsImpl) Operational() *int {
	return s.OperationalValue
}

// Number of operational entities
func (s *ClusterHealthStreamerStatsAgentMetricsImpl) SetOperational(v int) ClusterHealthStreamerStatsAgentMetrics {
	if s == nil {
		return nil
	}
	s.OperationalValue = &v
	return s
}

// Number of outage entities
func (s ClusterHealthStreamerStatsAgentMetricsImpl) Outage() *int {
	return s.OutageValue
}

// Number of outage entities
func (s *ClusterHealthStreamerStatsAgentMetricsImpl) SetOutage(v int) ClusterHealthStreamerStatsAgentMetrics {
	if s == nil {
		return nil
	}
	s.OutageValue = &v
	return s
}

// Number of partial outage entities
func (s ClusterHealthStreamerStatsAgentMetricsImpl) PartialOutage() *int {
	return s.PartialOutageValue
}

// Number of partial outage entities
func (s *ClusterHealthStreamerStatsAgentMetricsImpl) SetPartialOutage(v int) ClusterHealthStreamerStatsAgentMetrics {
	if s == nil {
		return nil
	}
	s.PartialOutageValue = &v
	return s
}

func (s ClusterHealthStreamerStatsAgentMetricsImpl) Status() *ClusterHealthStatus {
	return s.StatusValue
}

func (s *ClusterHealthStreamerStatsAgentMetricsImpl) SetStatus(v ClusterHealthStatus) ClusterHealthStreamerStatsAgentMetrics {
	if s == nil {
		return nil
	}
	s.StatusValue = &v
	return s
}

// Total number of entities
func (s ClusterHealthStreamerStatsAgentMetricsImpl) Total() *int {
	return s.TotalValue
}

// Total number of entities
func (s *ClusterHealthStreamerStatsAgentMetricsImpl) SetTotal(v int) ClusterHealthStreamerStatsAgentMetrics {
	if s == nil {
		return nil
	}
	s.TotalValue = &v
	return s
}

// NewClusterHealthStreamerStatsConfig creates a new ClusterHealthStreamerStatsConfig instance
func NewClusterHealthStreamerStatsConfig() ClusterHealthStreamerStatsConfig {
	return &ClusterHealthStreamerStatsConfigImpl{}
}

func (s ClusterHealthStreamerStatsConfigImpl) Status() *ClusterHealthStatus {
	return s.StatusValue
}

func (s *ClusterHealthStreamerStatsConfigImpl) SetStatus(v ClusterHealthStatus) ClusterHealthStreamerStatsConfig {
	if s == nil {
		return nil
	}
	s.StatusValue = &v
	return s
}

// NewClusterHealthStreamerStatsCpu creates a new ClusterHealthStreamerStatsCpu instance
func NewClusterHealthStreamerStatsCpu() ClusterHealthStreamerStatsCpu {
	return &ClusterHealthStreamerStatsCpuImpl{}
}

func (s ClusterHealthStreamerStatsCpuImpl) Status() *ClusterHealthStatus {
	return s.StatusValue
}

func (s *ClusterHealthStreamerStatsCpuImpl) SetStatus(v ClusterHealthStatus) ClusterHealthStreamerStatsCpu {
	if s == nil {
		return nil
	}
	s.StatusValue = &v
	return s
}

// CPU usage on the server.
// Format: percent (percent)
// Example: 48
func (s ClusterHealthStreamerStatsCpuImpl) Usage() *Percent {
	return s.UsageValue
}

// CPU usage on the server.
// Format: percent (percent)
// Example: 48
func (s *ClusterHealthStreamerStatsCpuImpl) SetUsage(v Percent) ClusterHealthStreamerStatsCpu {
	if s == nil {
		return nil
	}
	s.UsageValue = &v
	return s
}

// NewClusterHealthStreamerStatsMemory creates a new ClusterHealthStreamerStatsMemory instance
func NewClusterHealthStreamerStatsMemory() ClusterHealthStreamerStatsMemory {
	return &ClusterHealthStreamerStatsMemoryImpl{}
}

func (s ClusterHealthStreamerStatsMemoryImpl) Status() *ClusterHealthStatus {
	return s.StatusValue
}

func (s *ClusterHealthStreamerStatsMemoryImpl) SetStatus(v ClusterHealthStatus) ClusterHealthStreamerStatsMemory {
	if s == nil {
		return nil
	}
	s.StatusValue = &v
	return s
}

// Memory usage on the server.
// Format: percent (percent)
// Example: 27
func (s ClusterHealthStreamerStatsMemoryImpl) Usage() *Percent {
	return s.UsageValue
}

// Memory usage on the server.
// Format: percent (percent)
// Example: 27
func (s *ClusterHealthStreamerStatsMemoryImpl) SetUsage(v Percent) ClusterHealthStreamerStatsMemory {
	if s == nil {
		return nil
	}
	s.UsageValue = &v
	return s
}

// NewClusterHealthStreamerStatsNetwork creates a new ClusterHealthStreamerStatsNetwork instance
func NewClusterHealthStreamerStatsNetwork() ClusterHealthStreamerStatsNetwork {
	return &ClusterHealthStreamerStatsNetworkImpl{}
}

// Inbound network info on the server.
func (s ClusterHealthStreamerStatsNetworkImpl) InKbit() ClusterHealthStreamerStatsNetworkInKbit {
	return s.InKbitValue
}

// Inbound network info on the server.
func (s *ClusterHealthStreamerStatsNetworkImpl) SetInKbit(v ClusterHealthStreamerStatsNetworkInKbit) ClusterHealthStreamerStatsNetwork {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ClusterHealthStreamerStatsNetworkInKbitImpl); ok {
		s.InKbitValue = impl
	}
	return s
}

// Outbound network info on the server.
func (s ClusterHealthStreamerStatsNetworkImpl) OutKbit() ClusterHealthStreamerStatsNetworkOutKbit {
	return s.OutKbitValue
}

// Outbound network info on the server.
func (s *ClusterHealthStreamerStatsNetworkImpl) SetOutKbit(v ClusterHealthStreamerStatsNetworkOutKbit) ClusterHealthStreamerStatsNetwork {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ClusterHealthStreamerStatsNetworkOutKbitImpl); ok {
		s.OutKbitValue = impl
	}
	return s
}

// NewClusterHealthStreamerStatsNetworkInKbit creates a new ClusterHealthStreamerStatsNetworkInKbit instance
func NewClusterHealthStreamerStatsNetworkInKbit() ClusterHealthStreamerStatsNetworkInKbit {
	return &ClusterHealthStreamerStatsNetworkInKbitImpl{}
}

func (s ClusterHealthStreamerStatsNetworkInKbitImpl) Status() *ClusterHealthStatus {
	return s.StatusValue
}

func (s *ClusterHealthStreamerStatsNetworkInKbitImpl) SetStatus(v ClusterHealthStatus) ClusterHealthStreamerStatsNetworkInKbit {
	if s == nil {
		return nil
	}
	s.StatusValue = &v
	return s
}

// Inbound network usage on the server.
// Format: speed (speed)
func (s ClusterHealthStreamerStatsNetworkInKbitImpl) Usage() *Speed {
	return s.UsageValue
}

// Inbound network usage on the server.
// Format: speed (speed)
func (s *ClusterHealthStreamerStatsNetworkInKbitImpl) SetUsage(v Speed) ClusterHealthStreamerStatsNetworkInKbit {
	if s == nil {
		return nil
	}
	s.UsageValue = &v
	return s
}

// NewClusterHealthStreamerStatsNetworkOutKbit creates a new ClusterHealthStreamerStatsNetworkOutKbit instance
func NewClusterHealthStreamerStatsNetworkOutKbit() ClusterHealthStreamerStatsNetworkOutKbit {
	return &ClusterHealthStreamerStatsNetworkOutKbitImpl{}
}

func (s ClusterHealthStreamerStatsNetworkOutKbitImpl) Status() *ClusterHealthStatus {
	return s.StatusValue
}

func (s *ClusterHealthStreamerStatsNetworkOutKbitImpl) SetStatus(v ClusterHealthStatus) ClusterHealthStreamerStatsNetworkOutKbit {
	if s == nil {
		return nil
	}
	s.StatusValue = &v
	return s
}

// Outbound network usage on the server.
// Format: speed (speed)
func (s ClusterHealthStreamerStatsNetworkOutKbitImpl) Usage() *Speed {
	return s.UsageValue
}

// Outbound network usage on the server.
// Format: speed (speed)
func (s *ClusterHealthStreamerStatsNetworkOutKbitImpl) SetUsage(v Speed) ClusterHealthStreamerStatsNetworkOutKbit {
	if s == nil {
		return nil
	}
	s.UsageValue = &v
	return s
}

// NewClusterHealthStreamerStatsStorage creates a new ClusterHealthStreamerStatsStorage instance
func NewClusterHealthStreamerStatsStorage() ClusterHealthStreamerStatsStorage {
	return &ClusterHealthStreamerStatsStorageImpl{}
}

func (s ClusterHealthStreamerStatsStorageImpl) Status() *ClusterHealthStatus {
	return s.StatusValue
}

func (s *ClusterHealthStreamerStatsStorageImpl) SetStatus(v ClusterHealthStatus) ClusterHealthStreamerStatsStorage {
	if s == nil {
		return nil
	}
	s.StatusValue = &v
	return s
}

// Total disk space usage on the server.
// Format: percent (percent)
// Example: 18
func (s ClusterHealthStreamerStatsStorageImpl) Usage() *Percent {
	return s.UsageValue
}

// Total disk space usage on the server.
// Format: percent (percent)
// Example: 18
func (s *ClusterHealthStreamerStatsStorageImpl) SetUsage(v Percent) ClusterHealthStreamerStatsStorage {
	if s == nil {
		return nil
	}
	s.UsageValue = &v
	return s
}

// NewClusterHealthStreamerStatsStreamMetrics creates a new ClusterHealthStreamerStatsStreamMetrics instance
func NewClusterHealthStreamerStatsStreamMetrics() ClusterHealthStreamerStatsStreamMetrics {
	return &ClusterHealthStreamerStatsStreamMetricsImpl{}
}

// Number of degraded entities
func (s ClusterHealthStreamerStatsStreamMetricsImpl) Degradated() *int {
	return s.DegradatedValue
}

// Number of degraded entities
func (s *ClusterHealthStreamerStatsStreamMetricsImpl) SetDegradated(v int) ClusterHealthStreamerStatsStreamMetrics {
	if s == nil {
		return nil
	}
	s.DegradatedValue = &v
	return s
}

// Number of disabled entities
func (s ClusterHealthStreamerStatsStreamMetricsImpl) Disabled() *int {
	return s.DisabledValue
}

// Number of disabled entities
func (s *ClusterHealthStreamerStatsStreamMetricsImpl) SetDisabled(v int) ClusterHealthStreamerStatsStreamMetrics {
	if s == nil {
		return nil
	}
	s.DisabledValue = &v
	return s
}

// Number of operational entities
func (s ClusterHealthStreamerStatsStreamMetricsImpl) Operational() *int {
	return s.OperationalValue
}

// Number of operational entities
func (s *ClusterHealthStreamerStatsStreamMetricsImpl) SetOperational(v int) ClusterHealthStreamerStatsStreamMetrics {
	if s == nil {
		return nil
	}
	s.OperationalValue = &v
	return s
}

// Number of outage entities
func (s ClusterHealthStreamerStatsStreamMetricsImpl) Outage() *int {
	return s.OutageValue
}

// Number of outage entities
func (s *ClusterHealthStreamerStatsStreamMetricsImpl) SetOutage(v int) ClusterHealthStreamerStatsStreamMetrics {
	if s == nil {
		return nil
	}
	s.OutageValue = &v
	return s
}

// Number of partial outage entities
func (s ClusterHealthStreamerStatsStreamMetricsImpl) PartialOutage() *int {
	return s.PartialOutageValue
}

// Number of partial outage entities
func (s *ClusterHealthStreamerStatsStreamMetricsImpl) SetPartialOutage(v int) ClusterHealthStreamerStatsStreamMetrics {
	if s == nil {
		return nil
	}
	s.PartialOutageValue = &v
	return s
}

func (s ClusterHealthStreamerStatsStreamMetricsImpl) Status() *ClusterHealthStatus {
	return s.StatusValue
}

func (s *ClusterHealthStreamerStatsStreamMetricsImpl) SetStatus(v ClusterHealthStatus) ClusterHealthStreamerStatsStreamMetrics {
	if s == nil {
		return nil
	}
	s.StatusValue = &v
	return s
}

// Total number of entities
func (s ClusterHealthStreamerStatsStreamMetricsImpl) Total() *int {
	return s.TotalValue
}

// Total number of entities
func (s *ClusterHealthStreamerStatsStreamMetricsImpl) SetTotal(v int) ClusterHealthStreamerStatsStreamMetrics {
	if s == nil {
		return nil
	}
	s.TotalValue = &v
	return s
}

// NewCollectionResponse creates a new CollectionResponse instance
func NewCollectionResponse() CollectionResponse {
	return &CollectionResponseImpl{}
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s CollectionResponseImpl) EstimatedCount() *int {
	return s.EstimatedCountValue
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s *CollectionResponseImpl) SetEstimatedCount(v int) CollectionResponse {
	if s == nil {
		return nil
	}
	s.EstimatedCountValue = &v
	return s
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s CollectionResponseImpl) Next() *string {
	return s.NextValue
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s *CollectionResponseImpl) SetNext(v string) CollectionResponse {
	if s == nil {
		return nil
	}
	s.NextValue = &v
	return s
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s CollectionResponseImpl) Prev() *string {
	return s.PrevValue
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s *CollectionResponseImpl) SetPrev(v string) CollectionResponse {
	if s == nil {
		return nil
	}
	s.PrevValue = &v
	return s
}

// An object with a list of different timings measured during this API call.
func (s CollectionResponseImpl) Timing() any {
	return s.TimingValue
}

// An object with a list of different timings measured during this API call.
func (s *CollectionResponseImpl) SetTiming(v any) CollectionResponse {
	if s == nil {
		return nil
	}
	s.TimingValue = v
	return s
}

// NewConfigErrorStatus creates a new ConfigErrorStatus instance
func NewConfigErrorStatus() ConfigErrorStatus {
	return &ConfigErrorStatusImpl{}
}

// The column number pointing to where the error was detected.
// Example: 20
func (s ConfigErrorStatusImpl) Col() *int {
	return s.ColValue
}

// The column number pointing to where the error was detected.
// Example: 20
func (s *ConfigErrorStatusImpl) SetCol(v int) ConfigErrorStatus {
	if s == nil {
		return nil
	}
	s.ColValue = &v
	return s
}

// Partial configuration that can be recovered if an error occurs.
func (s ConfigErrorStatusImpl) Config() any {
	return s.ConfigValue
}

// Partial configuration that can be recovered if an error occurs.
func (s *ConfigErrorStatusImpl) SetConfig(v any) ConfigErrorStatus {
	if s == nil {
		return nil
	}
	s.ConfigValue = v
	return s
}

// Some other details that may help to identify the error.
func (s ConfigErrorStatusImpl) Detail() any {
	return s.DetailValue
}

// Some other details that may help to identify the error.
func (s *ConfigErrorStatusImpl) SetDetail(v any) ConfigErrorStatus {
	if s == nil {
		return nil
	}
	s.DetailValue = v
	return s
}

// Short error description.
// Example: bad_url
func (s ConfigErrorStatusImpl) Error() *string {
	return s.ErrorValue
}

// Short error description.
// Example: bad_url
func (s *ConfigErrorStatusImpl) SetError(v string) ConfigErrorStatus {
	if s == nil {
		return nil
	}
	s.ErrorValue = &v
	return s
}

// Last column with something valid.
// Example: 5
func (s ConfigErrorStatusImpl) FirstErrorCol() *int {
	return s.FirstErrorColValue
}

// Last column with something valid.
// Example: 5
func (s *ConfigErrorStatusImpl) SetFirstErrorCol(v int) ConfigErrorStatus {
	if s == nil {
		return nil
	}
	s.FirstErrorColValue = &v
	return s
}

// If an error takes up to several lines, it is the first line where the error was detected.
// Example: 14
func (s ConfigErrorStatusImpl) FirstErrorLine() *int {
	return s.FirstErrorLineValue
}

// If an error takes up to several lines, it is the first line where the error was detected.
// Example: 14
func (s *ConfigErrorStatusImpl) SetFirstErrorLine(v int) ConfigErrorStatus {
	if s == nil {
		return nil
	}
	s.FirstErrorLineValue = &v
	return s
}

// Line number pointing to where an error was detected.
// Example: 15
func (s ConfigErrorStatusImpl) Line() *int {
	return s.LineValue
}

// Line number pointing to where an error was detected.
// Example: 15
func (s *ConfigErrorStatusImpl) SetLine(v int) ConfigErrorStatus {
	if s == nil {
		return nil
	}
	s.LineValue = &v
	return s
}

// Config path to the erroneous element.
// Example: [streams 0 inputs 0 url input_url]
func (s ConfigErrorStatusImpl) Path() []ConfigPathSegment {
	return s.PathValue
}

// Config path to the erroneous element.
// Example: [streams 0 inputs 0 url input_url]
func (s *ConfigErrorStatusImpl) SetPath(v []ConfigPathSegment) ConfigErrorStatus {
	if s == nil {
		return nil
	}
	s.PathValue = v
	return s
}

// NewConfigExternalErrorStatus creates a new ConfigExternalErrorStatus instance
func NewConfigExternalErrorStatus() ConfigExternalErrorStatus {
	return &ConfigExternalErrorStatusImpl{}
}

// HTTP response code
func (s ConfigExternalErrorStatusImpl) Code() *int {
	return s.CodeValue
}

// HTTP response code
func (s *ConfigExternalErrorStatusImpl) SetCode(v int) ConfigExternalErrorStatus {
	if s == nil {
		return nil
	}
	s.CodeValue = &v
	return s
}

// Detailed error description (optional)
func (s ConfigExternalErrorStatusImpl) Detail() *string {
	return s.DetailValue
}

// Detailed error description (optional)
func (s *ConfigExternalErrorStatusImpl) SetDetail(v string) ConfigExternalErrorStatus {
	if s == nil {
		return nil
	}
	s.DetailValue = &v
	return s
}

// Error description (optional)
// Example: invalid_authorization
func (s ConfigExternalErrorStatusImpl) Error() *string {
	return s.ErrorValue
}

// Error description (optional)
// Example: invalid_authorization
func (s *ConfigExternalErrorStatusImpl) SetError(v string) ConfigExternalErrorStatus {
	if s == nil {
		return nil
	}
	s.ErrorValue = &v
	return s
}

// Config path to the erroneous element.
// Example: [streams 0 inputs 0 url input_url]
func (s ConfigExternalErrorStatusImpl) Path() []ConfigPathSegment {
	return s.PathValue
}

// Config path to the erroneous element.
// Example: [streams 0 inputs 0 url input_url]
func (s *ConfigExternalErrorStatusImpl) SetPath(v []ConfigPathSegment) ConfigExternalErrorStatus {
	if s == nil {
		return nil
	}
	s.PathValue = v
	return s
}

func (s ConfigExternalErrorStatusImpl) Reason() *RequestErrorReason {
	return s.ReasonValue
}

func (s *ConfigExternalErrorStatusImpl) SetReason(v RequestErrorReason) ConfigExternalErrorStatus {
	if s == nil {
		return nil
	}
	s.ReasonValue = &v
	return s
}

// External config status
func (s ConfigExternalErrorStatusImpl) Status() *ConfigExternalErrorStatusStatus {
	return s.StatusValue
}

// External config status
func (s *ConfigExternalErrorStatusImpl) SetStatus(v ConfigExternalErrorStatusStatus) ConfigExternalErrorStatus {
	if s == nil {
		return nil
	}
	s.StatusValue = &v
	return s
}

// Conditions of the error occurrence.
func (s ConfigExternalErrorStatusImpl) While() *ConfigExternalErrorStatusWhile {
	return s.WhileValue
}

// Conditions of the error occurrence.
func (s *ConfigExternalErrorStatusImpl) SetWhile(v ConfigExternalErrorStatusWhile) ConfigExternalErrorStatus {
	if s == nil {
		return nil
	}
	s.WhileValue = &v
	return s
}

// NewCreationInfo creates a new CreationInfo instance
func NewCreationInfo() CreationInfo {
	return &CreationInfoImpl{}
}

// The time when the entity was created.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s CreationInfoImpl) CreatedAt() *UtcMs {
	return s.CreatedAtValue
}

// The time when the entity was created.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *CreationInfoImpl) SetCreatedAt(v UtcMs) CreationInfo {
	if s == nil {
		return nil
	}
	s.CreatedAtValue = &v
	return s
}

// Information about the user who created the entity.
func (s CreationInfoImpl) User() CreationInfoUser {
	return s.UserValue
}

// Information about the user who created the entity.
func (s *CreationInfoImpl) SetUser(v CreationInfoUser) CreationInfo {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*CreationInfoUserImpl); ok {
		s.UserValue = impl
	}
	return s
}

// NewCreationInfoUser creates a new CreationInfoUser instance
func NewCreationInfoUser() CreationInfoUser {
	return &CreationInfoUserImpl{}
}

// Identifier of the user.
// Example: 1
func (s CreationInfoUserImpl) ID() *int {
	return s.IDValue
}

// Identifier of the user.
// Example: 1
func (s *CreationInfoUserImpl) SetID(v int) CreationInfoUser {
	if s == nil {
		return nil
	}
	s.IDValue = &v
	return s
}

// User name(login).
// Example: admin
func (s CreationInfoUserImpl) Name() *string {
	return s.NameValue
}

// User name(login).
// Example: admin
func (s *CreationInfoUserImpl) SetName(v string) CreationInfoUser {
	if s == nil {
		return nil
	}
	s.NameValue = &v
	return s
}

// NewDatabase creates a new Database instance
func NewDatabase() Database {
	return &DatabaseImpl{}
}

// Connection string to PostgreSQL database.
// Format: `postgres://[user[:password]@][host][:port][/dbname][?param1=value1&...&paramN=valueN]`
// Allowed parameters:
// - `sslmode` - configuring SSL connection to the database.
// This parameter defines whether and how SSL should be used to connect to the database.
// Possible values include `disable`, `allow`, `prefer`, `require`, `verify-ca`, and `verify-full`.
// - `default_query_exec_mode` - if you use PgBouncer, it's necessary to set this parameter to `cache_describe`.
// Example: postgres://central:pass@localhost:5432/central_dev
func (s DatabaseImpl) URL() string {
	return s.URLValue
}

// Connection string to PostgreSQL database.
// Format: `postgres://[user[:password]@][host][:port][/dbname][?param1=value1&...&paramN=valueN]`
// Allowed parameters:
// - `sslmode` - configuring SSL connection to the database.
// This parameter defines whether and how SSL should be used to connect to the database.
// Possible values include `disable`, `allow`, `prefer`, `require`, `verify-ca`, and `verify-full`.
// - `default_query_exec_mode` - if you use PgBouncer, it's necessary to set this parameter to `cache_describe`.
// Example: postgres://central:pass@localhost:5432/central_dev
func (s *DatabaseImpl) SetURL(v string) Database {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// NewDecklinkConfig creates a new DecklinkConfig instance
func NewDecklinkConfig() DecklinkConfig {
	return &DecklinkConfigImpl{}
}

// The Decklink card name.
func (s DecklinkConfigImpl) Name() *DecklinkCardID {
	return s.NameValue
}

// The Decklink card name.
func (s *DecklinkConfigImpl) SetName(v *DecklinkCardID) DecklinkConfig {
	if s == nil {
		return nil
	}
	s.NameValue = v
	return s
}

// The Decklink card profile that allows choosing between input and output direction.
func (s DecklinkConfigImpl) Profile() *DecklinkConfigProfile {
	return s.ProfileValue
}

// The Decklink card profile that allows choosing between input and output direction.
func (s *DecklinkConfigImpl) SetProfile(v DecklinkConfigProfile) DecklinkConfig {
	if s == nil {
		return nil
	}
	s.ProfileValue = &v
	return s
}

// NewDomainBase creates a new DomainBase instance
func NewDomainBase() DomainBase {
	return &DomainBaseImpl{}
}

// Domain ID.
// Example: 123
func (s DomainBaseImpl) ID() *int {
	return s.IDValue
}

// Domain ID.
// Example: 123
func (s *DomainBaseImpl) SetID(v int) DomainBase {
	if s == nil {
		return nil
	}
	s.IDValue = &v
	return s
}

// The name of the domain.
// Example: domain1
func (s DomainBaseImpl) Title() *string {
	return s.TitleValue
}

// The name of the domain.
// Example: domain1
func (s *DomainBaseImpl) SetTitle(v string) DomainBase {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// NewDomainConfig creates a new DomainConfig instance
func NewDomainConfig() DomainConfig {
	return &DomainConfigImpl{}
}

// Appearance settings allow you to edit the colors, logos, favicon and other brand UI settings of your service.
func (s DomainConfigImpl) Appearance() AppearanceConfig {
	return s.AppearanceValue
}

// Appearance settings allow you to edit the colors, logos, favicon and other brand UI settings of your service.
func (s *DomainConfigImpl) SetAppearance(v AppearanceConfig) DomainConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*AppearanceConfigImpl); ok {
		s.AppearanceValue = impl
	}
	return s
}

func (s DomainConfigImpl) Mail() MailSpec {
	return s.MailValue
}

func (s *DomainConfigImpl) SetMail(v MailSpec) DomainConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*MailSpecImpl); ok {
		s.MailValue = impl
	}
	return s
}

// NewDrmBase creates a new DrmBase instance
func NewDrmBase() DrmBase {
	return &DrmBaseImpl{}
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s DrmBaseImpl) Encryption() *string {
	return s.EncryptionValue
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s *DrmBaseImpl) SetEncryption(v string) DrmBase {
	if s == nil {
		return nil
	}
	s.EncryptionValue = &v
	return s
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s DrmBaseImpl) Expires() *int {
	return s.ExpiresValue
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s *DrmBaseImpl) SetExpires(v int) DrmBase {
	if s == nil {
		return nil
	}
	s.ExpiresValue = &v
	return s
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s DrmBaseImpl) Keyserver() *string {
	return s.KeyserverValue
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s *DrmBaseImpl) SetKeyserver(v string) DrmBase {
	if s == nil {
		return nil
	}
	s.KeyserverValue = &v
	return s
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s DrmBaseImpl) ResourceID() *DrmResourceID {
	return s.ResourceIDValue
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s *DrmBaseImpl) SetResourceID(v DrmResourceID) DrmBase {
	if s == nil {
		return nil
	}
	s.ResourceIDValue = &v
	return s
}

// NewDrmCpixBase creates a new DrmCpixBase instance
func NewDrmCpixBase() DrmCpixBase {
	return &DrmCpixBaseImpl{}
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s DrmCpixBaseImpl) Encryption() *string {
	return s.EncryptionValue
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s *DrmCpixBaseImpl) SetEncryption(v string) DrmCpixBase {
	if s == nil {
		return nil
	}
	s.EncryptionValue = &v
	return s
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s DrmCpixBaseImpl) Expires() *int {
	return s.ExpiresValue
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s *DrmCpixBaseImpl) SetExpires(v int) DrmCpixBase {
	if s == nil {
		return nil
	}
	s.ExpiresValue = &v
	return s
}

// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
// It is employed only one time in any session.
// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
// Usually, IV is received from a DRM provider.
func (s DrmCpixBaseImpl) Iv() *string {
	return s.IvValue
}

// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
// It is employed only one time in any session.
// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
// Usually, IV is received from a DRM provider.
func (s *DrmCpixBaseImpl) SetIv(v string) DrmCpixBase {
	if s == nil {
		return nil
	}
	s.IvValue = &v
	return s
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s DrmCpixBaseImpl) Keyserver() *string {
	return s.KeyserverValue
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s *DrmCpixBaseImpl) SetKeyserver(v string) DrmCpixBase {
	if s == nil {
		return nil
	}
	s.KeyserverValue = &v
	return s
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s DrmCpixBaseImpl) ResourceID() *DrmResourceID {
	return s.ResourceIDValue
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s *DrmCpixBaseImpl) SetResourceID(v DrmResourceID) DrmCpixBase {
	if s == nil {
		return nil
	}
	s.ResourceIDValue = &v
	return s
}

// This parameter is used to specify applicable DRM systems.
// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
func (s DrmCpixBaseImpl) Systems() []DrmSystem {
	return s.SystemsValue
}

// This parameter is used to specify applicable DRM systems.
// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
func (s *DrmCpixBaseImpl) SetSystems(v []DrmSystem) DrmCpixBase {
	if s == nil {
		return nil
	}
	s.SystemsValue = v
	return s
}

// NewDrmEncKey creates a new DrmEncKey instance
func NewDrmEncKey() DrmEncKey {
	return &DrmEncKeyImpl{}
}

// Encryption Key in hex or file. Length must be 128 bit.
// Example: 0x76359e1212952a6db42b41eeb94ceb29
func (s DrmEncKeyImpl) Key() *string {
	return s.KeyValue
}

// Encryption Key in hex or file. Length must be 128 bit.
// Example: 0x76359e1212952a6db42b41eeb94ceb29
func (s *DrmEncKeyImpl) SetKey(v string) DrmEncKey {
	if s == nil {
		return nil
	}
	s.KeyValue = &v
	return s
}

// NewDrmEncKeyURL creates a new DrmEncKeyURL instance
func NewDrmEncKeyURL() DrmEncKeyURL {
	return &DrmEncKeyURLImpl{}
}

// Http link which specifies how to obtain the key. It is URI attribute of HLS manifest EXT-X-KEY method.
func (s DrmEncKeyURLImpl) URL() *string {
	return s.URLValue
}

// Http link which specifies how to obtain the key. It is URI attribute of HLS manifest EXT-X-KEY method.
func (s *DrmEncKeyURLImpl) SetURL(v string) DrmEncKeyURL {
	if s == nil {
		return nil
	}
	s.URLValue = &v
	return s
}

// NewDrmIv creates a new DrmIv instance
func NewDrmIv() DrmIv {
	return &DrmIvImpl{}
}

// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
// It is employed only one time in any session.
// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
// Usually, IV is received from a DRM provider.
func (s DrmIvImpl) Iv() *string {
	return s.IvValue
}

// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
// It is employed only one time in any session.
// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
// Usually, IV is received from a DRM provider.
func (s *DrmIvImpl) SetIv(v string) DrmIv {
	if s == nil {
		return nil
	}
	s.IvValue = &v
	return s
}

// NewDrmKeyosBase creates a new DrmKeyosBase instance
func NewDrmKeyosBase() DrmKeyosBase {
	return &DrmKeyosBaseImpl{}
}

// A unique identifier of the content, used for Widevine DRM.
// By default, it is equal to the stream name.
func (s DrmKeyosBaseImpl) ContentID() *string {
	return s.ContentIDValue
}

// A unique identifier of the content, used for Widevine DRM.
// By default, it is equal to the stream name.
func (s *DrmKeyosBaseImpl) SetContentID(v string) DrmKeyosBase {
	if s == nil {
		return nil
	}
	s.ContentIDValue = &v
	return s
}

// Path to end user certificate file.
func (s DrmKeyosBaseImpl) EndUserCert() *string {
	return s.EndUserCertValue
}

// Path to end user certificate file.
func (s *DrmKeyosBaseImpl) SetEndUserCert(v string) DrmKeyosBase {
	if s == nil {
		return nil
	}
	s.EndUserCertValue = &v
	return s
}

// Path to end user private key file
func (s DrmKeyosBaseImpl) EndUserPrivateKey() *string {
	return s.EndUserPrivateKeyValue
}

// Path to end user private key file
func (s *DrmKeyosBaseImpl) SetEndUserPrivateKey(v string) DrmKeyosBase {
	if s == nil {
		return nil
	}
	s.EndUserPrivateKeyValue = &v
	return s
}

// Deprecated field. Will be deleted at 25.04
// A unique identifier of the user
func (s DrmKeyosBaseImpl) Userkey() *string {
	return s.UserkeyValue
}

// Deprecated field. Will be deleted at 25.04
// A unique identifier of the user
func (s *DrmKeyosBaseImpl) SetUserkey(v string) DrmKeyosBase {
	if s == nil {
		return nil
	}
	s.UserkeyValue = &v
	return s
}

// NewDrmSpec creates a new DrmSpec instance
func NewDrmSpec() DrmSpec {
	return &DrmSpecImpl{}
}

// ID of the Irdeto DRM account.
func (s DrmSpecImpl) AccountID() *string {
	return s.AccountIDValue
}

// ID of the Irdeto DRM account.
func (s *DrmSpecImpl) SetAccountID(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.AccountIDValue = &v
	return s
}

// AES (Advanced Encryption Standard) key. Used for Widevine DRM.
func (s DrmSpecImpl) AesKey() *string {
	return s.AesKeyValue
}

// AES (Advanced Encryption Standard) key. Used for Widevine DRM.
func (s *DrmSpecImpl) SetAesKey(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.AesKeyValue = &v
	return s
}

// Authentication server for DRMtoday.
// Example: https://auth.drmtoday.com
func (s DrmSpecImpl) AuthServer() *string {
	return s.AuthServerValue
}

// Authentication server for DRMtoday.
// Example: https://auth.drmtoday.com
func (s *DrmSpecImpl) SetAuthServer(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.AuthServerValue = &v
	return s
}

// A unique identifier of the content, used for Widevine DRM.
// By default, it is equal to the stream name.
func (s DrmSpecImpl) ContentID() *string {
	return s.ContentIDValue
}

// A unique identifier of the content, used for Widevine DRM.
// By default, it is equal to the stream name.
func (s *DrmSpecImpl) SetContentID(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.ContentIDValue = &v
	return s
}

// The uuid of the CPIX/SPEKE ingest configuration
func (s DrmSpecImpl) CpixConfigID() *string {
	return s.CpixConfigIDValue
}

// The uuid of the CPIX/SPEKE ingest configuration
func (s *DrmSpecImpl) SetCpixConfigID(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.CpixConfigIDValue = &v
	return s
}

// An API authentication token that is generated when you sign up for the PallyCon service at https://login.pallycon.com/.
func (s DrmSpecImpl) EncToken() *string {
	return s.EncTokenValue
}

// An API authentication token that is generated when you sign up for the PallyCon service at https://login.pallycon.com/.
func (s *DrmSpecImpl) SetEncToken(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.EncTokenValue = &v
	return s
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s DrmSpecImpl) Encryption() *string {
	return s.EncryptionValue
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s *DrmSpecImpl) SetEncryption(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.EncryptionValue = &v
	return s
}

// Path to end user certificate file.
func (s DrmSpecImpl) EndUserCert() *string {
	return s.EndUserCertValue
}

// Path to end user certificate file.
func (s *DrmSpecImpl) SetEndUserCert(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.EndUserCertValue = &v
	return s
}

// Path to end user private key file
func (s DrmSpecImpl) EndUserPrivateKey() *string {
	return s.EndUserPrivateKeyValue
}

// Path to end user private key file
func (s *DrmSpecImpl) SetEndUserPrivateKey(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.EndUserPrivateKeyValue = &v
	return s
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s DrmSpecImpl) Expires() *int {
	return s.ExpiresValue
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s *DrmSpecImpl) SetExpires(v int) DrmSpec {
	if s == nil {
		return nil
	}
	s.ExpiresValue = &v
	return s
}

// Whether to use FairPlay system for key generation.
// If set to `false`, the requests for FairPlay encryption key are disabled.
func (s DrmSpecImpl) Fp() *string {
	return s.FpValue
}

// Whether to use FairPlay system for key generation.
// If set to `false`, the requests for FairPlay encryption key are disabled.
func (s *DrmSpecImpl) SetFp(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.FpValue = &v
	return s
}

// This parameter is used for encryption of HLS streams.
// For successful playback of an AES128 encrypted HLS streams on some modern devices (running on Tizen 5),
// set this pareameter to `false`.
func (s DrmSpecImpl) HlsExtXKeyIv() *bool {
	return s.HlsExtXKeyIvValue
}

// This parameter is used for encryption of HLS streams.
// For successful playback of an AES128 encrypted HLS streams on some modern devices (running on Tizen 5),
// set this pareameter to `false`.
func (s *DrmSpecImpl) SetHlsExtXKeyIv(v bool) DrmSpec {
	if s == nil {
		return nil
	}
	s.HlsExtXKeyIvValue = &v
	return s
}

// A hostname of Irdeto DRM key server.
func (s DrmSpecImpl) IcHost() *string {
	return s.IcHostValue
}

// A hostname of Irdeto DRM key server.
func (s *DrmSpecImpl) SetIcHost(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.IcHostValue = &v
	return s
}

// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
// It is employed only one time in any session.
// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
// Usually, IV is received from a DRM provider.
func (s DrmSpecImpl) Iv() *string {
	return s.IvValue
}

// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
// It is employed only one time in any session.
// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
// Usually, IV is received from a DRM provider.
func (s *DrmSpecImpl) SetIv(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.IvValue = &v
	return s
}

// Encryption Key in hex or file. Length must be 128 bit.
// Example: 0x76359e1212952a6db42b41eeb94ceb29
func (s DrmSpecImpl) Key() *string {
	return s.KeyValue
}

// Encryption Key in hex or file. Length must be 128 bit.
// Example: 0x76359e1212952a6db42b41eeb94ceb29
func (s *DrmSpecImpl) SetKey(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.KeyValue = &v
	return s
}

// An arbitrary Base64-encoded string of 30 bytes.
// It is necessary for PlayReady to create an encryption key.
func (s DrmSpecImpl) Keyseed() *string {
	return s.KeyseedValue
}

// An arbitrary Base64-encoded string of 30 bytes.
// It is necessary for PlayReady to create an encryption key.
func (s *DrmSpecImpl) SetKeyseed(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.KeyseedValue = &v
	return s
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s DrmSpecImpl) Keyserver() *string {
	return s.KeyserverValue
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s *DrmSpecImpl) SetKeyserver(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.KeyserverValue = &v
	return s
}

// License URL, used for PlayReady DRM.
// Format: url (url)
func (s DrmSpecImpl) LaURL() *URL {
	return s.LaURLValue
}

// License URL, used for PlayReady DRM.
// Format: url (url)
func (s *DrmSpecImpl) SetLaURL(v URL) DrmSpec {
	if s == nil {
		return nil
	}
	s.LaURLValue = &v
	return s
}

// Axinom Management Key
func (s DrmSpecImpl) ManagementKey() *string {
	return s.ManagementKeyValue
}

// Axinom Management Key
func (s *DrmSpecImpl) SetManagementKey(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.ManagementKeyValue = &v
	return s
}

// The uuid of the merchant at DRMtoday.
func (s DrmSpecImpl) MerchantID() *string {
	return s.MerchantIDValue
}

// The uuid of the merchant at DRMtoday.
func (s *DrmSpecImpl) SetMerchantID(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.MerchantIDValue = &v
	return s
}

// A password for API account./A password for authorization of a user on a key server.
func (s DrmSpecImpl) Password() *string {
	return s.PasswordValue
}

// A password for API account./A password for authorization of a user on a key server.
func (s *DrmSpecImpl) SetPassword(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.PasswordValue = &v
	return s
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s DrmSpecImpl) ResourceID() *DrmResourceID {
	return s.ResourceIDValue
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s *DrmSpecImpl) SetResourceID(v DrmResourceID) DrmSpec {
	if s == nil {
		return nil
	}
	s.ResourceIDValue = &v
	return s
}

// A part of the keyserver's URL: `https://SITE.solocoo.tv/SITEadmintools/papi/SECRET/method`.
func (s DrmSpecImpl) Secret() *string {
	return s.SecretValue
}

// A part of the keyserver's URL: `https://SITE.solocoo.tv/SITEadmintools/papi/SECRET/method`.
func (s *DrmSpecImpl) SetSecret(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.SecretValue = &v
	return s
}

// A unique ID of the signer.
// Flussonic uses it to connect to the key server when using test key for Widevine DRM.
func (s DrmSpecImpl) Signer() *string {
	return s.SignerValue
}

// A unique ID of the signer.
// Flussonic uses it to connect to the key server when using test key for Widevine DRM.
func (s *DrmSpecImpl) SetSigner(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.SignerValue = &v
	return s
}

// A part of the keyserver's URL: `https://SITE.solocoo.tv/SITEadmintools/papi/SECRET/method`.
func (s DrmSpecImpl) Site() *string {
	return s.SiteValue
}

// A part of the keyserver's URL: `https://SITE.solocoo.tv/SITEadmintools/papi/SECRET/method`.
func (s *DrmSpecImpl) SetSite(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.SiteValue = &v
	return s
}

// This parameter is used to specify applicable DRM systems.
// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
func (s DrmSpecImpl) Systems() []DrmSystem {
	return s.SystemsValue
}

// This parameter is used to specify applicable DRM systems.
// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
func (s *DrmSpecImpl) SetSystems(v []DrmSystem) DrmSpec {
	if s == nil {
		return nil
	}
	s.SystemsValue = v
	return s
}

// Axinom Tenant Id
func (s DrmSpecImpl) TenantID() *string {
	return s.TenantIDValue
}

// Axinom Tenant Id
func (s *DrmSpecImpl) SetTenantID(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.TenantIDValue = &v
	return s
}

// Http link which specifies how to obtain the key. It is URI attribute of HLS manifest EXT-X-KEY method.
func (s DrmSpecImpl) URL() *string {
	return s.URLValue
}

// Http link which specifies how to obtain the key. It is URI attribute of HLS manifest EXT-X-KEY method.
func (s *DrmSpecImpl) SetURL(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.URLValue = &v
	return s
}

// A user name for authorization of a user on a key server.
func (s DrmSpecImpl) User() *string {
	return s.UserValue
}

// A user name for authorization of a user on a key server.
func (s *DrmSpecImpl) SetUser(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.UserValue = &v
	return s
}

// The URL sent to the client for watching the content.
// Example: https://public-keyserver.mycompany.com
func (s DrmSpecImpl) UserKeyserver() *string {
	return s.UserKeyserverValue
}

// The URL sent to the client for watching the content.
// Example: https://public-keyserver.mycompany.com
func (s *DrmSpecImpl) SetUserKeyserver(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.UserKeyserverValue = &v
	return s
}

// A user name of the Irdeto DRM user.
func (s DrmSpecImpl) UserName() *string {
	return s.UserNameValue
}

// A user name of the Irdeto DRM user.
func (s *DrmSpecImpl) SetUserName(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.UserNameValue = &v
	return s
}

// A custom key server path
// Example: 12345/nks/conax
func (s DrmSpecImpl) UserPath() *string {
	return s.UserPathValue
}

// A custom key server path
// Example: 12345/nks/conax
func (s *DrmSpecImpl) SetUserPath(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.UserPathValue = &v
	return s
}

// Deprecated field. Will be deleted at 25.04
// A unique identifier of the user
func (s DrmSpecImpl) Userkey() *string {
	return s.UserkeyValue
}

// Deprecated field. Will be deleted at 25.04
// A unique identifier of the user
func (s *DrmSpecImpl) SetUserkey(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.UserkeyValue = &v
	return s
}

// The login name of an API account.
func (s DrmSpecImpl) Username() *string {
	return s.UsernameValue
}

// The login name of an API account.
func (s *DrmSpecImpl) SetUsername(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.UsernameValue = &v
	return s
}

// FIXME: Aes128
// /FIXME: Axinom
// /BuyDRM
// /Clear Key is a lightweight DRM mode, where decryption keys are provided directly to the player. Its easy to
// integrate (simple JSON key/KID), requires minimal infrastructure, and can work via a license URL or with
// client-embedded keys.
// /FIXME: Conax
// /FIXME: Cpix
// /FIXME: DRMtoday
// /FIXME: Ezdrm
// /FIXME: Ezdrm classic
// /FIXME: GS DRM
// /FIXME: Irdeto
// /KeyOs
// /FIXME: Pallycon
// /FIXME: Playready
// /FIXME: Sample AES
// /Sample AES which uses KEYFORMAT=identity. It allows to encrypt and decrypt content using clear text AES key.
// The identity value for KEYFORMAT should be used only for testing.
// /FIXME: Solocoo
// /FIXME: Verimatrix
// /FIXME: Widevine
func (s DrmSpecImpl) Vendor() string {
	return s.VendorValue
}

// FIXME: Aes128
// /FIXME: Axinom
// /BuyDRM
// /Clear Key is a lightweight DRM mode, where decryption keys are provided directly to the player. Its easy to
// integrate (simple JSON key/KID), requires minimal infrastructure, and can work via a license URL or with
// client-embedded keys.
// /FIXME: Conax
// /FIXME: Cpix
// /FIXME: DRMtoday
// /FIXME: Ezdrm
// /FIXME: Ezdrm classic
// /FIXME: GS DRM
// /FIXME: Irdeto
// /KeyOs
// /FIXME: Pallycon
// /FIXME: Playready
// /FIXME: Sample AES
// /Sample AES which uses KEYFORMAT=identity. It allows to encrypt and decrypt content using clear text AES key.
// The identity value for KEYFORMAT should be used only for testing.
// /FIXME: Solocoo
// /FIXME: Verimatrix
// /FIXME: Widevine
func (s *DrmSpecImpl) SetVendor(v string) DrmSpec {
	if s == nil {
		return nil
	}
	s.VendorValue = v
	return s
}

// NewDrmSystems creates a new DrmSystems instance
func NewDrmSystems() DrmSystems {
	return &DrmSystemsImpl{}
}

// This parameter is used to specify applicable DRM systems.
// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
func (s DrmSystemsImpl) Systems() []DrmSystem {
	return s.SystemsValue
}

// This parameter is used to specify applicable DRM systems.
// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
func (s *DrmSystemsImpl) SetSystems(v []DrmSystem) DrmSystems {
	if s == nil {
		return nil
	}
	s.SystemsValue = v
	return s
}

// NewDrmVendorAes128 creates a new DrmVendorAes128 instance
func NewDrmVendorAes128() DrmVendorAes128 {
	return &DrmVendorAes128Impl{}
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s DrmVendorAes128Impl) Encryption() *string {
	return s.EncryptionValue
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s *DrmVendorAes128Impl) SetEncryption(v string) DrmVendorAes128 {
	if s == nil {
		return nil
	}
	s.EncryptionValue = &v
	return s
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s DrmVendorAes128Impl) Expires() *int {
	return s.ExpiresValue
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s *DrmVendorAes128Impl) SetExpires(v int) DrmVendorAes128 {
	if s == nil {
		return nil
	}
	s.ExpiresValue = &v
	return s
}

// This parameter is used for encryption of HLS streams.
// For successful playback of an AES128 encrypted HLS streams on some modern devices (running on Tizen 5),
// set this pareameter to `false`.
func (s DrmVendorAes128Impl) HlsExtXKeyIv() *bool {
	return s.HlsExtXKeyIvValue
}

// This parameter is used for encryption of HLS streams.
// For successful playback of an AES128 encrypted HLS streams on some modern devices (running on Tizen 5),
// set this pareameter to `false`.
func (s *DrmVendorAes128Impl) SetHlsExtXKeyIv(v bool) DrmVendorAes128 {
	if s == nil {
		return nil
	}
	s.HlsExtXKeyIvValue = &v
	return s
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s DrmVendorAes128Impl) Keyserver() *string {
	return s.KeyserverValue
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s *DrmVendorAes128Impl) SetKeyserver(v string) DrmVendorAes128 {
	if s == nil {
		return nil
	}
	s.KeyserverValue = &v
	return s
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s DrmVendorAes128Impl) ResourceID() *DrmResourceID {
	return s.ResourceIDValue
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s *DrmVendorAes128Impl) SetResourceID(v DrmResourceID) DrmVendorAes128 {
	if s == nil {
		return nil
	}
	s.ResourceIDValue = &v
	return s
}

// FIXME: Aes128
func (s DrmVendorAes128Impl) Vendor() string {
	return s.VendorValue
}

// FIXME: Aes128
func (s *DrmVendorAes128Impl) SetVendor(v string) DrmVendorAes128 {
	if s == nil {
		return nil
	}
	s.VendorValue = v
	return s
}

// NewDrmVendorAxinom creates a new DrmVendorAxinom instance
func NewDrmVendorAxinom() DrmVendorAxinom {
	return &DrmVendorAxinomImpl{}
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s DrmVendorAxinomImpl) Encryption() *string {
	return s.EncryptionValue
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s *DrmVendorAxinomImpl) SetEncryption(v string) DrmVendorAxinom {
	if s == nil {
		return nil
	}
	s.EncryptionValue = &v
	return s
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s DrmVendorAxinomImpl) Expires() *int {
	return s.ExpiresValue
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s *DrmVendorAxinomImpl) SetExpires(v int) DrmVendorAxinom {
	if s == nil {
		return nil
	}
	s.ExpiresValue = &v
	return s
}

// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
// It is employed only one time in any session.
// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
// Usually, IV is received from a DRM provider.
func (s DrmVendorAxinomImpl) Iv() *string {
	return s.IvValue
}

// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
// It is employed only one time in any session.
// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
// Usually, IV is received from a DRM provider.
func (s *DrmVendorAxinomImpl) SetIv(v string) DrmVendorAxinom {
	if s == nil {
		return nil
	}
	s.IvValue = &v
	return s
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s DrmVendorAxinomImpl) Keyserver() *string {
	return s.KeyserverValue
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s *DrmVendorAxinomImpl) SetKeyserver(v string) DrmVendorAxinom {
	if s == nil {
		return nil
	}
	s.KeyserverValue = &v
	return s
}

// Axinom Management Key
func (s DrmVendorAxinomImpl) ManagementKey() *string {
	return s.ManagementKeyValue
}

// Axinom Management Key
func (s *DrmVendorAxinomImpl) SetManagementKey(v string) DrmVendorAxinom {
	if s == nil {
		return nil
	}
	s.ManagementKeyValue = &v
	return s
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s DrmVendorAxinomImpl) ResourceID() *DrmResourceID {
	return s.ResourceIDValue
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s *DrmVendorAxinomImpl) SetResourceID(v DrmResourceID) DrmVendorAxinom {
	if s == nil {
		return nil
	}
	s.ResourceIDValue = &v
	return s
}

// This parameter is used to specify applicable DRM systems.
// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
func (s DrmVendorAxinomImpl) Systems() []DrmSystem {
	return s.SystemsValue
}

// This parameter is used to specify applicable DRM systems.
// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
func (s *DrmVendorAxinomImpl) SetSystems(v []DrmSystem) DrmVendorAxinom {
	if s == nil {
		return nil
	}
	s.SystemsValue = v
	return s
}

// Axinom Tenant Id
func (s DrmVendorAxinomImpl) TenantID() *string {
	return s.TenantIDValue
}

// Axinom Tenant Id
func (s *DrmVendorAxinomImpl) SetTenantID(v string) DrmVendorAxinom {
	if s == nil {
		return nil
	}
	s.TenantIDValue = &v
	return s
}

// FIXME: Axinom
func (s DrmVendorAxinomImpl) Vendor() string {
	return s.VendorValue
}

// FIXME: Axinom
func (s *DrmVendorAxinomImpl) SetVendor(v string) DrmVendorAxinom {
	if s == nil {
		return nil
	}
	s.VendorValue = v
	return s
}

// NewDrmVendorBuydrm creates a new DrmVendorBuydrm instance
func NewDrmVendorBuydrm() DrmVendorBuydrm {
	return &DrmVendorBuydrmImpl{}
}

// A unique identifier of the content, used for Widevine DRM.
// By default, it is equal to the stream name.
func (s DrmVendorBuydrmImpl) ContentID() *string {
	return s.ContentIDValue
}

// A unique identifier of the content, used for Widevine DRM.
// By default, it is equal to the stream name.
func (s *DrmVendorBuydrmImpl) SetContentID(v string) DrmVendorBuydrm {
	if s == nil {
		return nil
	}
	s.ContentIDValue = &v
	return s
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s DrmVendorBuydrmImpl) Encryption() *string {
	return s.EncryptionValue
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s *DrmVendorBuydrmImpl) SetEncryption(v string) DrmVendorBuydrm {
	if s == nil {
		return nil
	}
	s.EncryptionValue = &v
	return s
}

// Path to end user certificate file.
func (s DrmVendorBuydrmImpl) EndUserCert() *string {
	return s.EndUserCertValue
}

// Path to end user certificate file.
func (s *DrmVendorBuydrmImpl) SetEndUserCert(v string) DrmVendorBuydrm {
	if s == nil {
		return nil
	}
	s.EndUserCertValue = &v
	return s
}

// Path to end user private key file
func (s DrmVendorBuydrmImpl) EndUserPrivateKey() *string {
	return s.EndUserPrivateKeyValue
}

// Path to end user private key file
func (s *DrmVendorBuydrmImpl) SetEndUserPrivateKey(v string) DrmVendorBuydrm {
	if s == nil {
		return nil
	}
	s.EndUserPrivateKeyValue = &v
	return s
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s DrmVendorBuydrmImpl) Expires() *int {
	return s.ExpiresValue
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s *DrmVendorBuydrmImpl) SetExpires(v int) DrmVendorBuydrm {
	if s == nil {
		return nil
	}
	s.ExpiresValue = &v
	return s
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s DrmVendorBuydrmImpl) Keyserver() *string {
	return s.KeyserverValue
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s *DrmVendorBuydrmImpl) SetKeyserver(v string) DrmVendorBuydrm {
	if s == nil {
		return nil
	}
	s.KeyserverValue = &v
	return s
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s DrmVendorBuydrmImpl) ResourceID() *DrmResourceID {
	return s.ResourceIDValue
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s *DrmVendorBuydrmImpl) SetResourceID(v DrmResourceID) DrmVendorBuydrm {
	if s == nil {
		return nil
	}
	s.ResourceIDValue = &v
	return s
}

// Deprecated field. Will be deleted at 25.04
// A unique identifier of the user
func (s DrmVendorBuydrmImpl) Userkey() *string {
	return s.UserkeyValue
}

// Deprecated field. Will be deleted at 25.04
// A unique identifier of the user
func (s *DrmVendorBuydrmImpl) SetUserkey(v string) DrmVendorBuydrm {
	if s == nil {
		return nil
	}
	s.UserkeyValue = &v
	return s
}

// BuyDRM
func (s DrmVendorBuydrmImpl) Vendor() string {
	return s.VendorValue
}

// BuyDRM
func (s *DrmVendorBuydrmImpl) SetVendor(v string) DrmVendorBuydrm {
	if s == nil {
		return nil
	}
	s.VendorValue = v
	return s
}

// NewDrmVendorClearkey creates a new DrmVendorClearkey instance
func NewDrmVendorClearkey() DrmVendorClearkey {
	return &DrmVendorClearkeyImpl{}
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s DrmVendorClearkeyImpl) Encryption() *string {
	return s.EncryptionValue
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s *DrmVendorClearkeyImpl) SetEncryption(v string) DrmVendorClearkey {
	if s == nil {
		return nil
	}
	s.EncryptionValue = &v
	return s
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s DrmVendorClearkeyImpl) Expires() *int {
	return s.ExpiresValue
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s *DrmVendorClearkeyImpl) SetExpires(v int) DrmVendorClearkey {
	if s == nil {
		return nil
	}
	s.ExpiresValue = &v
	return s
}

// Encryption Key in hex or file. Length must be 128 bit.
// Example: 0x76359e1212952a6db42b41eeb94ceb29
func (s DrmVendorClearkeyImpl) Key() *string {
	return s.KeyValue
}

// Encryption Key in hex or file. Length must be 128 bit.
// Example: 0x76359e1212952a6db42b41eeb94ceb29
func (s *DrmVendorClearkeyImpl) SetKey(v string) DrmVendorClearkey {
	if s == nil {
		return nil
	}
	s.KeyValue = &v
	return s
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s DrmVendorClearkeyImpl) Keyserver() *string {
	return s.KeyserverValue
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s *DrmVendorClearkeyImpl) SetKeyserver(v string) DrmVendorClearkey {
	if s == nil {
		return nil
	}
	s.KeyserverValue = &v
	return s
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s DrmVendorClearkeyImpl) ResourceID() *DrmResourceID {
	return s.ResourceIDValue
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s *DrmVendorClearkeyImpl) SetResourceID(v DrmResourceID) DrmVendorClearkey {
	if s == nil {
		return nil
	}
	s.ResourceIDValue = &v
	return s
}

// Clear Key is a lightweight DRM mode, where decryption keys are provided directly to the player. Its easy to
// integrate (simple JSON key/KID), requires minimal infrastructure, and can work via a license URL or with
// client-embedded keys.
func (s DrmVendorClearkeyImpl) Vendor() string {
	return s.VendorValue
}

// Clear Key is a lightweight DRM mode, where decryption keys are provided directly to the player. Its easy to
// integrate (simple JSON key/KID), requires minimal infrastructure, and can work via a license URL or with
// client-embedded keys.
func (s *DrmVendorClearkeyImpl) SetVendor(v string) DrmVendorClearkey {
	if s == nil {
		return nil
	}
	s.VendorValue = v
	return s
}

// NewDrmVendorConax creates a new DrmVendorConax instance
func NewDrmVendorConax() DrmVendorConax {
	return &DrmVendorConaxImpl{}
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s DrmVendorConaxImpl) Encryption() *string {
	return s.EncryptionValue
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s *DrmVendorConaxImpl) SetEncryption(v string) DrmVendorConax {
	if s == nil {
		return nil
	}
	s.EncryptionValue = &v
	return s
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s DrmVendorConaxImpl) Expires() *int {
	return s.ExpiresValue
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s *DrmVendorConaxImpl) SetExpires(v int) DrmVendorConax {
	if s == nil {
		return nil
	}
	s.ExpiresValue = &v
	return s
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s DrmVendorConaxImpl) Keyserver() *string {
	return s.KeyserverValue
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s *DrmVendorConaxImpl) SetKeyserver(v string) DrmVendorConax {
	if s == nil {
		return nil
	}
	s.KeyserverValue = &v
	return s
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s DrmVendorConaxImpl) ResourceID() *DrmResourceID {
	return s.ResourceIDValue
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s *DrmVendorConaxImpl) SetResourceID(v DrmResourceID) DrmVendorConax {
	if s == nil {
		return nil
	}
	s.ResourceIDValue = &v
	return s
}

// This parameter is used to specify applicable DRM systems.
// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
func (s DrmVendorConaxImpl) Systems() []DrmSystem {
	return s.SystemsValue
}

// This parameter is used to specify applicable DRM systems.
// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
func (s *DrmVendorConaxImpl) SetSystems(v []DrmSystem) DrmVendorConax {
	if s == nil {
		return nil
	}
	s.SystemsValue = v
	return s
}

// A custom key server path
// Example: 12345/nks/conax
func (s DrmVendorConaxImpl) UserPath() *string {
	return s.UserPathValue
}

// A custom key server path
// Example: 12345/nks/conax
func (s *DrmVendorConaxImpl) SetUserPath(v string) DrmVendorConax {
	if s == nil {
		return nil
	}
	s.UserPathValue = &v
	return s
}

// FIXME: Conax
func (s DrmVendorConaxImpl) Vendor() string {
	return s.VendorValue
}

// FIXME: Conax
func (s *DrmVendorConaxImpl) SetVendor(v string) DrmVendorConax {
	if s == nil {
		return nil
	}
	s.VendorValue = v
	return s
}

// NewDrmVendorCpix creates a new DrmVendorCpix instance
func NewDrmVendorCpix() DrmVendorCpix {
	return &DrmVendorCpixImpl{}
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s DrmVendorCpixImpl) Encryption() *string {
	return s.EncryptionValue
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s *DrmVendorCpixImpl) SetEncryption(v string) DrmVendorCpix {
	if s == nil {
		return nil
	}
	s.EncryptionValue = &v
	return s
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s DrmVendorCpixImpl) Expires() *int {
	return s.ExpiresValue
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s *DrmVendorCpixImpl) SetExpires(v int) DrmVendorCpix {
	if s == nil {
		return nil
	}
	s.ExpiresValue = &v
	return s
}

// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
// It is employed only one time in any session.
// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
// Usually, IV is received from a DRM provider.
func (s DrmVendorCpixImpl) Iv() *string {
	return s.IvValue
}

// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
// It is employed only one time in any session.
// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
// Usually, IV is received from a DRM provider.
func (s *DrmVendorCpixImpl) SetIv(v string) DrmVendorCpix {
	if s == nil {
		return nil
	}
	s.IvValue = &v
	return s
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s DrmVendorCpixImpl) Keyserver() *string {
	return s.KeyserverValue
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s *DrmVendorCpixImpl) SetKeyserver(v string) DrmVendorCpix {
	if s == nil {
		return nil
	}
	s.KeyserverValue = &v
	return s
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s DrmVendorCpixImpl) ResourceID() *DrmResourceID {
	return s.ResourceIDValue
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s *DrmVendorCpixImpl) SetResourceID(v DrmResourceID) DrmVendorCpix {
	if s == nil {
		return nil
	}
	s.ResourceIDValue = &v
	return s
}

// This parameter is used to specify applicable DRM systems.
// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
func (s DrmVendorCpixImpl) Systems() []DrmSystem {
	return s.SystemsValue
}

// This parameter is used to specify applicable DRM systems.
// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
func (s *DrmVendorCpixImpl) SetSystems(v []DrmSystem) DrmVendorCpix {
	if s == nil {
		return nil
	}
	s.SystemsValue = v
	return s
}

// FIXME: Cpix
func (s DrmVendorCpixImpl) Vendor() string {
	return s.VendorValue
}

// FIXME: Cpix
func (s *DrmVendorCpixImpl) SetVendor(v string) DrmVendorCpix {
	if s == nil {
		return nil
	}
	s.VendorValue = v
	return s
}

// NewDrmVendorDrmtoday creates a new DrmVendorDrmtoday instance
func NewDrmVendorDrmtoday() DrmVendorDrmtoday {
	return &DrmVendorDrmtodayImpl{}
}

// Authentication server for DRMtoday.
// Example: https://auth.drmtoday.com
func (s DrmVendorDrmtodayImpl) AuthServer() *string {
	return s.AuthServerValue
}

// Authentication server for DRMtoday.
// Example: https://auth.drmtoday.com
func (s *DrmVendorDrmtodayImpl) SetAuthServer(v string) DrmVendorDrmtoday {
	if s == nil {
		return nil
	}
	s.AuthServerValue = &v
	return s
}

// The uuid of the CPIX/SPEKE ingest configuration
func (s DrmVendorDrmtodayImpl) CpixConfigID() *string {
	return s.CpixConfigIDValue
}

// The uuid of the CPIX/SPEKE ingest configuration
func (s *DrmVendorDrmtodayImpl) SetCpixConfigID(v string) DrmVendorDrmtoday {
	if s == nil {
		return nil
	}
	s.CpixConfigIDValue = &v
	return s
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s DrmVendorDrmtodayImpl) Encryption() *string {
	return s.EncryptionValue
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s *DrmVendorDrmtodayImpl) SetEncryption(v string) DrmVendorDrmtoday {
	if s == nil {
		return nil
	}
	s.EncryptionValue = &v
	return s
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s DrmVendorDrmtodayImpl) Expires() *int {
	return s.ExpiresValue
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s *DrmVendorDrmtodayImpl) SetExpires(v int) DrmVendorDrmtoday {
	if s == nil {
		return nil
	}
	s.ExpiresValue = &v
	return s
}

// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
// It is employed only one time in any session.
// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
// Usually, IV is received from a DRM provider.
func (s DrmVendorDrmtodayImpl) Iv() *string {
	return s.IvValue
}

// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
// It is employed only one time in any session.
// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
// Usually, IV is received from a DRM provider.
func (s *DrmVendorDrmtodayImpl) SetIv(v string) DrmVendorDrmtoday {
	if s == nil {
		return nil
	}
	s.IvValue = &v
	return s
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s DrmVendorDrmtodayImpl) Keyserver() *string {
	return s.KeyserverValue
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s *DrmVendorDrmtodayImpl) SetKeyserver(v string) DrmVendorDrmtoday {
	if s == nil {
		return nil
	}
	s.KeyserverValue = &v
	return s
}

// The uuid of the merchant at DRMtoday.
func (s DrmVendorDrmtodayImpl) MerchantID() *string {
	return s.MerchantIDValue
}

// The uuid of the merchant at DRMtoday.
func (s *DrmVendorDrmtodayImpl) SetMerchantID(v string) DrmVendorDrmtoday {
	if s == nil {
		return nil
	}
	s.MerchantIDValue = &v
	return s
}

// A password for API account.
func (s DrmVendorDrmtodayImpl) Password() *string {
	return s.PasswordValue
}

// A password for API account.
func (s *DrmVendorDrmtodayImpl) SetPassword(v string) DrmVendorDrmtoday {
	if s == nil {
		return nil
	}
	s.PasswordValue = &v
	return s
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s DrmVendorDrmtodayImpl) ResourceID() *DrmResourceID {
	return s.ResourceIDValue
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s *DrmVendorDrmtodayImpl) SetResourceID(v DrmResourceID) DrmVendorDrmtoday {
	if s == nil {
		return nil
	}
	s.ResourceIDValue = &v
	return s
}

// This parameter is used to specify applicable DRM systems.
// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
func (s DrmVendorDrmtodayImpl) Systems() []DrmSystem {
	return s.SystemsValue
}

// This parameter is used to specify applicable DRM systems.
// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
func (s *DrmVendorDrmtodayImpl) SetSystems(v []DrmSystem) DrmVendorDrmtoday {
	if s == nil {
		return nil
	}
	s.SystemsValue = v
	return s
}

// The login name of an API account.
func (s DrmVendorDrmtodayImpl) Username() *string {
	return s.UsernameValue
}

// The login name of an API account.
func (s *DrmVendorDrmtodayImpl) SetUsername(v string) DrmVendorDrmtoday {
	if s == nil {
		return nil
	}
	s.UsernameValue = &v
	return s
}

// FIXME: DRMtoday
func (s DrmVendorDrmtodayImpl) Vendor() string {
	return s.VendorValue
}

// FIXME: DRMtoday
func (s *DrmVendorDrmtodayImpl) SetVendor(v string) DrmVendorDrmtoday {
	if s == nil {
		return nil
	}
	s.VendorValue = v
	return s
}

// NewDrmVendorEzdrm creates a new DrmVendorEzdrm instance
func NewDrmVendorEzdrm() DrmVendorEzdrm {
	return &DrmVendorEzdrmImpl{}
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s DrmVendorEzdrmImpl) Encryption() *string {
	return s.EncryptionValue
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s *DrmVendorEzdrmImpl) SetEncryption(v string) DrmVendorEzdrm {
	if s == nil {
		return nil
	}
	s.EncryptionValue = &v
	return s
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s DrmVendorEzdrmImpl) Expires() *int {
	return s.ExpiresValue
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s *DrmVendorEzdrmImpl) SetExpires(v int) DrmVendorEzdrm {
	if s == nil {
		return nil
	}
	s.ExpiresValue = &v
	return s
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s DrmVendorEzdrmImpl) Keyserver() *string {
	return s.KeyserverValue
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s *DrmVendorEzdrmImpl) SetKeyserver(v string) DrmVendorEzdrm {
	if s == nil {
		return nil
	}
	s.KeyserverValue = &v
	return s
}

// A password for authorization of a user on a key server.
func (s DrmVendorEzdrmImpl) Password() *string {
	return s.PasswordValue
}

// A password for authorization of a user on a key server.
func (s *DrmVendorEzdrmImpl) SetPassword(v string) DrmVendorEzdrm {
	if s == nil {
		return nil
	}
	s.PasswordValue = &v
	return s
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s DrmVendorEzdrmImpl) ResourceID() *DrmResourceID {
	return s.ResourceIDValue
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s *DrmVendorEzdrmImpl) SetResourceID(v DrmResourceID) DrmVendorEzdrm {
	if s == nil {
		return nil
	}
	s.ResourceIDValue = &v
	return s
}

// A user name for authorization of a user on a key server.
func (s DrmVendorEzdrmImpl) User() *string {
	return s.UserValue
}

// A user name for authorization of a user on a key server.
func (s *DrmVendorEzdrmImpl) SetUser(v string) DrmVendorEzdrm {
	if s == nil {
		return nil
	}
	s.UserValue = &v
	return s
}

// FIXME: Ezdrm
func (s DrmVendorEzdrmImpl) Vendor() string {
	return s.VendorValue
}

// FIXME: Ezdrm
func (s *DrmVendorEzdrmImpl) SetVendor(v string) DrmVendorEzdrm {
	if s == nil {
		return nil
	}
	s.VendorValue = v
	return s
}

// NewDrmVendorEzdrmClassic creates a new DrmVendorEzdrmClassic instance
func NewDrmVendorEzdrmClassic() DrmVendorEzdrmClassic {
	return &DrmVendorEzdrmClassicImpl{}
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s DrmVendorEzdrmClassicImpl) Encryption() *string {
	return s.EncryptionValue
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s *DrmVendorEzdrmClassicImpl) SetEncryption(v string) DrmVendorEzdrmClassic {
	if s == nil {
		return nil
	}
	s.EncryptionValue = &v
	return s
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s DrmVendorEzdrmClassicImpl) Expires() *int {
	return s.ExpiresValue
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s *DrmVendorEzdrmClassicImpl) SetExpires(v int) DrmVendorEzdrmClassic {
	if s == nil {
		return nil
	}
	s.ExpiresValue = &v
	return s
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s DrmVendorEzdrmClassicImpl) Keyserver() *string {
	return s.KeyserverValue
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s *DrmVendorEzdrmClassicImpl) SetKeyserver(v string) DrmVendorEzdrmClassic {
	if s == nil {
		return nil
	}
	s.KeyserverValue = &v
	return s
}

// A password for authorization of a user on a key server.
func (s DrmVendorEzdrmClassicImpl) Password() *string {
	return s.PasswordValue
}

// A password for authorization of a user on a key server.
func (s *DrmVendorEzdrmClassicImpl) SetPassword(v string) DrmVendorEzdrmClassic {
	if s == nil {
		return nil
	}
	s.PasswordValue = &v
	return s
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s DrmVendorEzdrmClassicImpl) ResourceID() *DrmResourceID {
	return s.ResourceIDValue
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s *DrmVendorEzdrmClassicImpl) SetResourceID(v DrmResourceID) DrmVendorEzdrmClassic {
	if s == nil {
		return nil
	}
	s.ResourceIDValue = &v
	return s
}

// A user name for authorization of a user on a key server.
func (s DrmVendorEzdrmClassicImpl) User() *string {
	return s.UserValue
}

// A user name for authorization of a user on a key server.
func (s *DrmVendorEzdrmClassicImpl) SetUser(v string) DrmVendorEzdrmClassic {
	if s == nil {
		return nil
	}
	s.UserValue = &v
	return s
}

// FIXME: Ezdrm classic
func (s DrmVendorEzdrmClassicImpl) Vendor() string {
	return s.VendorValue
}

// FIXME: Ezdrm classic
func (s *DrmVendorEzdrmClassicImpl) SetVendor(v string) DrmVendorEzdrmClassic {
	if s == nil {
		return nil
	}
	s.VendorValue = v
	return s
}

// NewDrmVendorGsdrm creates a new DrmVendorGsdrm instance
func NewDrmVendorGsdrm() DrmVendorGsdrm {
	return &DrmVendorGsdrmImpl{}
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s DrmVendorGsdrmImpl) Encryption() *string {
	return s.EncryptionValue
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s *DrmVendorGsdrmImpl) SetEncryption(v string) DrmVendorGsdrm {
	if s == nil {
		return nil
	}
	s.EncryptionValue = &v
	return s
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s DrmVendorGsdrmImpl) Expires() *int {
	return s.ExpiresValue
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s *DrmVendorGsdrmImpl) SetExpires(v int) DrmVendorGsdrm {
	if s == nil {
		return nil
	}
	s.ExpiresValue = &v
	return s
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s DrmVendorGsdrmImpl) Keyserver() *string {
	return s.KeyserverValue
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s *DrmVendorGsdrmImpl) SetKeyserver(v string) DrmVendorGsdrm {
	if s == nil {
		return nil
	}
	s.KeyserverValue = &v
	return s
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s DrmVendorGsdrmImpl) ResourceID() *DrmResourceID {
	return s.ResourceIDValue
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s *DrmVendorGsdrmImpl) SetResourceID(v DrmResourceID) DrmVendorGsdrm {
	if s == nil {
		return nil
	}
	s.ResourceIDValue = &v
	return s
}

// FIXME: GS DRM
func (s DrmVendorGsdrmImpl) Vendor() string {
	return s.VendorValue
}

// FIXME: GS DRM
func (s *DrmVendorGsdrmImpl) SetVendor(v string) DrmVendorGsdrm {
	if s == nil {
		return nil
	}
	s.VendorValue = v
	return s
}

// NewDrmVendorIrdeto creates a new DrmVendorIrdeto instance
func NewDrmVendorIrdeto() DrmVendorIrdeto {
	return &DrmVendorIrdetoImpl{}
}

// ID of the Irdeto DRM account.
func (s DrmVendorIrdetoImpl) AccountID() *string {
	return s.AccountIDValue
}

// ID of the Irdeto DRM account.
func (s *DrmVendorIrdetoImpl) SetAccountID(v string) DrmVendorIrdeto {
	if s == nil {
		return nil
	}
	s.AccountIDValue = &v
	return s
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s DrmVendorIrdetoImpl) Encryption() *string {
	return s.EncryptionValue
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s *DrmVendorIrdetoImpl) SetEncryption(v string) DrmVendorIrdeto {
	if s == nil {
		return nil
	}
	s.EncryptionValue = &v
	return s
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s DrmVendorIrdetoImpl) Expires() *int {
	return s.ExpiresValue
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s *DrmVendorIrdetoImpl) SetExpires(v int) DrmVendorIrdeto {
	if s == nil {
		return nil
	}
	s.ExpiresValue = &v
	return s
}

// A hostname of Irdeto DRM key server.
func (s DrmVendorIrdetoImpl) IcHost() *string {
	return s.IcHostValue
}

// A hostname of Irdeto DRM key server.
func (s *DrmVendorIrdetoImpl) SetIcHost(v string) DrmVendorIrdeto {
	if s == nil {
		return nil
	}
	s.IcHostValue = &v
	return s
}

// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
// It is employed only one time in any session.
// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
// Usually, IV is received from a DRM provider.
func (s DrmVendorIrdetoImpl) Iv() *string {
	return s.IvValue
}

// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
// It is employed only one time in any session.
// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
// Usually, IV is received from a DRM provider.
func (s *DrmVendorIrdetoImpl) SetIv(v string) DrmVendorIrdeto {
	if s == nil {
		return nil
	}
	s.IvValue = &v
	return s
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s DrmVendorIrdetoImpl) Keyserver() *string {
	return s.KeyserverValue
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s *DrmVendorIrdetoImpl) SetKeyserver(v string) DrmVendorIrdeto {
	if s == nil {
		return nil
	}
	s.KeyserverValue = &v
	return s
}

// A password for authorization of a user on a key server.
func (s DrmVendorIrdetoImpl) Password() *string {
	return s.PasswordValue
}

// A password for authorization of a user on a key server.
func (s *DrmVendorIrdetoImpl) SetPassword(v string) DrmVendorIrdeto {
	if s == nil {
		return nil
	}
	s.PasswordValue = &v
	return s
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s DrmVendorIrdetoImpl) ResourceID() *DrmResourceID {
	return s.ResourceIDValue
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s *DrmVendorIrdetoImpl) SetResourceID(v DrmResourceID) DrmVendorIrdeto {
	if s == nil {
		return nil
	}
	s.ResourceIDValue = &v
	return s
}

// This parameter is used to specify applicable DRM systems.
// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
func (s DrmVendorIrdetoImpl) Systems() []DrmSystem {
	return s.SystemsValue
}

// This parameter is used to specify applicable DRM systems.
// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
func (s *DrmVendorIrdetoImpl) SetSystems(v []DrmSystem) DrmVendorIrdeto {
	if s == nil {
		return nil
	}
	s.SystemsValue = v
	return s
}

// A user name of the Irdeto DRM user.
func (s DrmVendorIrdetoImpl) UserName() *string {
	return s.UserNameValue
}

// A user name of the Irdeto DRM user.
func (s *DrmVendorIrdetoImpl) SetUserName(v string) DrmVendorIrdeto {
	if s == nil {
		return nil
	}
	s.UserNameValue = &v
	return s
}

// FIXME: Irdeto
func (s DrmVendorIrdetoImpl) Vendor() string {
	return s.VendorValue
}

// FIXME: Irdeto
func (s *DrmVendorIrdetoImpl) SetVendor(v string) DrmVendorIrdeto {
	if s == nil {
		return nil
	}
	s.VendorValue = v
	return s
}

// NewDrmVendorKeyos creates a new DrmVendorKeyos instance
func NewDrmVendorKeyos() DrmVendorKeyos {
	return &DrmVendorKeyosImpl{}
}

// A unique identifier of the content, used for Widevine DRM.
// By default, it is equal to the stream name.
func (s DrmVendorKeyosImpl) ContentID() *string {
	return s.ContentIDValue
}

// A unique identifier of the content, used for Widevine DRM.
// By default, it is equal to the stream name.
func (s *DrmVendorKeyosImpl) SetContentID(v string) DrmVendorKeyos {
	if s == nil {
		return nil
	}
	s.ContentIDValue = &v
	return s
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s DrmVendorKeyosImpl) Encryption() *string {
	return s.EncryptionValue
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s *DrmVendorKeyosImpl) SetEncryption(v string) DrmVendorKeyos {
	if s == nil {
		return nil
	}
	s.EncryptionValue = &v
	return s
}

// Path to end user certificate file.
func (s DrmVendorKeyosImpl) EndUserCert() *string {
	return s.EndUserCertValue
}

// Path to end user certificate file.
func (s *DrmVendorKeyosImpl) SetEndUserCert(v string) DrmVendorKeyos {
	if s == nil {
		return nil
	}
	s.EndUserCertValue = &v
	return s
}

// Path to end user private key file
func (s DrmVendorKeyosImpl) EndUserPrivateKey() *string {
	return s.EndUserPrivateKeyValue
}

// Path to end user private key file
func (s *DrmVendorKeyosImpl) SetEndUserPrivateKey(v string) DrmVendorKeyos {
	if s == nil {
		return nil
	}
	s.EndUserPrivateKeyValue = &v
	return s
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s DrmVendorKeyosImpl) Expires() *int {
	return s.ExpiresValue
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s *DrmVendorKeyosImpl) SetExpires(v int) DrmVendorKeyos {
	if s == nil {
		return nil
	}
	s.ExpiresValue = &v
	return s
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s DrmVendorKeyosImpl) Keyserver() *string {
	return s.KeyserverValue
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s *DrmVendorKeyosImpl) SetKeyserver(v string) DrmVendorKeyos {
	if s == nil {
		return nil
	}
	s.KeyserverValue = &v
	return s
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s DrmVendorKeyosImpl) ResourceID() *DrmResourceID {
	return s.ResourceIDValue
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s *DrmVendorKeyosImpl) SetResourceID(v DrmResourceID) DrmVendorKeyos {
	if s == nil {
		return nil
	}
	s.ResourceIDValue = &v
	return s
}

// Deprecated field. Will be deleted at 25.04
// A unique identifier of the user
func (s DrmVendorKeyosImpl) Userkey() *string {
	return s.UserkeyValue
}

// Deprecated field. Will be deleted at 25.04
// A unique identifier of the user
func (s *DrmVendorKeyosImpl) SetUserkey(v string) DrmVendorKeyos {
	if s == nil {
		return nil
	}
	s.UserkeyValue = &v
	return s
}

// KeyOs
func (s DrmVendorKeyosImpl) Vendor() string {
	return s.VendorValue
}

// KeyOs
func (s *DrmVendorKeyosImpl) SetVendor(v string) DrmVendorKeyos {
	if s == nil {
		return nil
	}
	s.VendorValue = v
	return s
}

// NewDrmVendorPallycon creates a new DrmVendorPallycon instance
func NewDrmVendorPallycon() DrmVendorPallycon {
	return &DrmVendorPallyconImpl{}
}

// An API authentication token that is generated when you sign up for the PallyCon service at https://login.pallycon.com/.
func (s DrmVendorPallyconImpl) EncToken() *string {
	return s.EncTokenValue
}

// An API authentication token that is generated when you sign up for the PallyCon service at https://login.pallycon.com/.
func (s *DrmVendorPallyconImpl) SetEncToken(v string) DrmVendorPallycon {
	if s == nil {
		return nil
	}
	s.EncTokenValue = &v
	return s
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s DrmVendorPallyconImpl) Encryption() *string {
	return s.EncryptionValue
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s *DrmVendorPallyconImpl) SetEncryption(v string) DrmVendorPallycon {
	if s == nil {
		return nil
	}
	s.EncryptionValue = &v
	return s
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s DrmVendorPallyconImpl) Expires() *int {
	return s.ExpiresValue
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s *DrmVendorPallyconImpl) SetExpires(v int) DrmVendorPallycon {
	if s == nil {
		return nil
	}
	s.ExpiresValue = &v
	return s
}

// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
// It is employed only one time in any session.
// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
// Usually, IV is received from a DRM provider.
func (s DrmVendorPallyconImpl) Iv() *string {
	return s.IvValue
}

// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
// It is employed only one time in any session.
// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
// Usually, IV is received from a DRM provider.
func (s *DrmVendorPallyconImpl) SetIv(v string) DrmVendorPallycon {
	if s == nil {
		return nil
	}
	s.IvValue = &v
	return s
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s DrmVendorPallyconImpl) Keyserver() *string {
	return s.KeyserverValue
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s *DrmVendorPallyconImpl) SetKeyserver(v string) DrmVendorPallycon {
	if s == nil {
		return nil
	}
	s.KeyserverValue = &v
	return s
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s DrmVendorPallyconImpl) ResourceID() *DrmResourceID {
	return s.ResourceIDValue
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s *DrmVendorPallyconImpl) SetResourceID(v DrmResourceID) DrmVendorPallycon {
	if s == nil {
		return nil
	}
	s.ResourceIDValue = &v
	return s
}

// This parameter is used to specify applicable DRM systems.
// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
func (s DrmVendorPallyconImpl) Systems() []DrmSystem {
	return s.SystemsValue
}

// This parameter is used to specify applicable DRM systems.
// If you turned off some of the systems (FairPlay, PlayReady, or Widevine) you should specify the systems that remain in use.
func (s *DrmVendorPallyconImpl) SetSystems(v []DrmSystem) DrmVendorPallycon {
	if s == nil {
		return nil
	}
	s.SystemsValue = v
	return s
}

// FIXME: Pallycon
func (s DrmVendorPallyconImpl) Vendor() string {
	return s.VendorValue
}

// FIXME: Pallycon
func (s *DrmVendorPallyconImpl) SetVendor(v string) DrmVendorPallycon {
	if s == nil {
		return nil
	}
	s.VendorValue = v
	return s
}

// NewDrmVendorPlayready creates a new DrmVendorPlayready instance
func NewDrmVendorPlayready() DrmVendorPlayready {
	return &DrmVendorPlayreadyImpl{}
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s DrmVendorPlayreadyImpl) Encryption() *string {
	return s.EncryptionValue
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s *DrmVendorPlayreadyImpl) SetEncryption(v string) DrmVendorPlayready {
	if s == nil {
		return nil
	}
	s.EncryptionValue = &v
	return s
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s DrmVendorPlayreadyImpl) Expires() *int {
	return s.ExpiresValue
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s *DrmVendorPlayreadyImpl) SetExpires(v int) DrmVendorPlayready {
	if s == nil {
		return nil
	}
	s.ExpiresValue = &v
	return s
}

// An arbitrary Base64-encoded string of 30 bytes.
// It is necessary for PlayReady to create an encryption key.
func (s DrmVendorPlayreadyImpl) Keyseed() *string {
	return s.KeyseedValue
}

// An arbitrary Base64-encoded string of 30 bytes.
// It is necessary for PlayReady to create an encryption key.
func (s *DrmVendorPlayreadyImpl) SetKeyseed(v string) DrmVendorPlayready {
	if s == nil {
		return nil
	}
	s.KeyseedValue = &v
	return s
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s DrmVendorPlayreadyImpl) Keyserver() *string {
	return s.KeyserverValue
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s *DrmVendorPlayreadyImpl) SetKeyserver(v string) DrmVendorPlayready {
	if s == nil {
		return nil
	}
	s.KeyserverValue = &v
	return s
}

// License URL, used for PlayReady DRM.
// Format: url (url)
func (s DrmVendorPlayreadyImpl) LaURL() *URL {
	return s.LaURLValue
}

// License URL, used for PlayReady DRM.
// Format: url (url)
func (s *DrmVendorPlayreadyImpl) SetLaURL(v URL) DrmVendorPlayready {
	if s == nil {
		return nil
	}
	s.LaURLValue = &v
	return s
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s DrmVendorPlayreadyImpl) ResourceID() *DrmResourceID {
	return s.ResourceIDValue
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s *DrmVendorPlayreadyImpl) SetResourceID(v DrmResourceID) DrmVendorPlayready {
	if s == nil {
		return nil
	}
	s.ResourceIDValue = &v
	return s
}

// FIXME: Playready
func (s DrmVendorPlayreadyImpl) Vendor() string {
	return s.VendorValue
}

// FIXME: Playready
func (s *DrmVendorPlayreadyImpl) SetVendor(v string) DrmVendorPlayready {
	if s == nil {
		return nil
	}
	s.VendorValue = v
	return s
}

// NewDrmVendorSampleAes creates a new DrmVendorSampleAes instance
func NewDrmVendorSampleAes() DrmVendorSampleAes {
	return &DrmVendorSampleAesImpl{}
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s DrmVendorSampleAesImpl) Encryption() *string {
	return s.EncryptionValue
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s *DrmVendorSampleAesImpl) SetEncryption(v string) DrmVendorSampleAes {
	if s == nil {
		return nil
	}
	s.EncryptionValue = &v
	return s
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s DrmVendorSampleAesImpl) Expires() *int {
	return s.ExpiresValue
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s *DrmVendorSampleAesImpl) SetExpires(v int) DrmVendorSampleAes {
	if s == nil {
		return nil
	}
	s.ExpiresValue = &v
	return s
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s DrmVendorSampleAesImpl) Keyserver() *string {
	return s.KeyserverValue
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s *DrmVendorSampleAesImpl) SetKeyserver(v string) DrmVendorSampleAes {
	if s == nil {
		return nil
	}
	s.KeyserverValue = &v
	return s
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s DrmVendorSampleAesImpl) ResourceID() *DrmResourceID {
	return s.ResourceIDValue
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s *DrmVendorSampleAesImpl) SetResourceID(v DrmResourceID) DrmVendorSampleAes {
	if s == nil {
		return nil
	}
	s.ResourceIDValue = &v
	return s
}

// FIXME: Sample AES
func (s DrmVendorSampleAesImpl) Vendor() string {
	return s.VendorValue
}

// FIXME: Sample AES
func (s *DrmVendorSampleAesImpl) SetVendor(v string) DrmVendorSampleAes {
	if s == nil {
		return nil
	}
	s.VendorValue = v
	return s
}

// NewDrmVendorSampleAesIdentity creates a new DrmVendorSampleAesIdentity instance
func NewDrmVendorSampleAesIdentity() DrmVendorSampleAesIdentity {
	return &DrmVendorSampleAesIdentityImpl{}
}

// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
// It is employed only one time in any session.
// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
// Usually, IV is received from a DRM provider.
func (s DrmVendorSampleAesIdentityImpl) Iv() *string {
	return s.IvValue
}

// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
// It is employed only one time in any session.
// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
// Usually, IV is received from a DRM provider.
func (s *DrmVendorSampleAesIdentityImpl) SetIv(v string) DrmVendorSampleAesIdentity {
	if s == nil {
		return nil
	}
	s.IvValue = &v
	return s
}

// Encryption Key in hex or file. Length must be 128 bit.
// Example: 0x76359e1212952a6db42b41eeb94ceb29
func (s DrmVendorSampleAesIdentityImpl) Key() *string {
	return s.KeyValue
}

// Encryption Key in hex or file. Length must be 128 bit.
// Example: 0x76359e1212952a6db42b41eeb94ceb29
func (s *DrmVendorSampleAesIdentityImpl) SetKey(v string) DrmVendorSampleAesIdentity {
	if s == nil {
		return nil
	}
	s.KeyValue = &v
	return s
}

// Http link which specifies how to obtain the key. It is URI attribute of HLS manifest EXT-X-KEY method.
func (s DrmVendorSampleAesIdentityImpl) URL() *string {
	return s.URLValue
}

// Http link which specifies how to obtain the key. It is URI attribute of HLS manifest EXT-X-KEY method.
func (s *DrmVendorSampleAesIdentityImpl) SetURL(v string) DrmVendorSampleAesIdentity {
	if s == nil {
		return nil
	}
	s.URLValue = &v
	return s
}

// Sample AES which uses KEYFORMAT=identity. It allows to encrypt and decrypt content using clear text AES key.
// The identity value for KEYFORMAT should be used only for testing.
func (s DrmVendorSampleAesIdentityImpl) Vendor() string {
	return s.VendorValue
}

// Sample AES which uses KEYFORMAT=identity. It allows to encrypt and decrypt content using clear text AES key.
// The identity value for KEYFORMAT should be used only for testing.
func (s *DrmVendorSampleAesIdentityImpl) SetVendor(v string) DrmVendorSampleAesIdentity {
	if s == nil {
		return nil
	}
	s.VendorValue = v
	return s
}

// NewDrmVendorSolocoo creates a new DrmVendorSolocoo instance
func NewDrmVendorSolocoo() DrmVendorSolocoo {
	return &DrmVendorSolocooImpl{}
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s DrmVendorSolocooImpl) Encryption() *string {
	return s.EncryptionValue
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s *DrmVendorSolocooImpl) SetEncryption(v string) DrmVendorSolocoo {
	if s == nil {
		return nil
	}
	s.EncryptionValue = &v
	return s
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s DrmVendorSolocooImpl) Expires() *int {
	return s.ExpiresValue
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s *DrmVendorSolocooImpl) SetExpires(v int) DrmVendorSolocoo {
	if s == nil {
		return nil
	}
	s.ExpiresValue = &v
	return s
}

// Whether to use FairPlay system for key generation.
// If set to `false`, the requests for FairPlay encryption key are disabled.
func (s DrmVendorSolocooImpl) Fp() *string {
	return s.FpValue
}

// Whether to use FairPlay system for key generation.
// If set to `false`, the requests for FairPlay encryption key are disabled.
func (s *DrmVendorSolocooImpl) SetFp(v string) DrmVendorSolocoo {
	if s == nil {
		return nil
	}
	s.FpValue = &v
	return s
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s DrmVendorSolocooImpl) Keyserver() *string {
	return s.KeyserverValue
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s *DrmVendorSolocooImpl) SetKeyserver(v string) DrmVendorSolocoo {
	if s == nil {
		return nil
	}
	s.KeyserverValue = &v
	return s
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s DrmVendorSolocooImpl) ResourceID() *DrmResourceID {
	return s.ResourceIDValue
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s *DrmVendorSolocooImpl) SetResourceID(v DrmResourceID) DrmVendorSolocoo {
	if s == nil {
		return nil
	}
	s.ResourceIDValue = &v
	return s
}

// A part of the keyserver's URL: `https://SITE.solocoo.tv/SITEadmintools/papi/SECRET/method`.
func (s DrmVendorSolocooImpl) Secret() *string {
	return s.SecretValue
}

// A part of the keyserver's URL: `https://SITE.solocoo.tv/SITEadmintools/papi/SECRET/method`.
func (s *DrmVendorSolocooImpl) SetSecret(v string) DrmVendorSolocoo {
	if s == nil {
		return nil
	}
	s.SecretValue = &v
	return s
}

// A part of the keyserver's URL: `https://SITE.solocoo.tv/SITEadmintools/papi/SECRET/method`.
func (s DrmVendorSolocooImpl) Site() *string {
	return s.SiteValue
}

// A part of the keyserver's URL: `https://SITE.solocoo.tv/SITEadmintools/papi/SECRET/method`.
func (s *DrmVendorSolocooImpl) SetSite(v string) DrmVendorSolocoo {
	if s == nil {
		return nil
	}
	s.SiteValue = &v
	return s
}

// FIXME: Solocoo
func (s DrmVendorSolocooImpl) Vendor() string {
	return s.VendorValue
}

// FIXME: Solocoo
func (s *DrmVendorSolocooImpl) SetVendor(v string) DrmVendorSolocoo {
	if s == nil {
		return nil
	}
	s.VendorValue = v
	return s
}

// NewDrmVendorVerimatrix creates a new DrmVendorVerimatrix instance
func NewDrmVendorVerimatrix() DrmVendorVerimatrix {
	return &DrmVendorVerimatrixImpl{}
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s DrmVendorVerimatrixImpl) Encryption() *string {
	return s.EncryptionValue
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s *DrmVendorVerimatrixImpl) SetEncryption(v string) DrmVendorVerimatrix {
	if s == nil {
		return nil
	}
	s.EncryptionValue = &v
	return s
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s DrmVendorVerimatrixImpl) Expires() *int {
	return s.ExpiresValue
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s *DrmVendorVerimatrixImpl) SetExpires(v int) DrmVendorVerimatrix {
	if s == nil {
		return nil
	}
	s.ExpiresValue = &v
	return s
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s DrmVendorVerimatrixImpl) Keyserver() *string {
	return s.KeyserverValue
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s *DrmVendorVerimatrixImpl) SetKeyserver(v string) DrmVendorVerimatrix {
	if s == nil {
		return nil
	}
	s.KeyserverValue = &v
	return s
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s DrmVendorVerimatrixImpl) ResourceID() *DrmResourceID {
	return s.ResourceIDValue
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s *DrmVendorVerimatrixImpl) SetResourceID(v DrmResourceID) DrmVendorVerimatrix {
	if s == nil {
		return nil
	}
	s.ResourceIDValue = &v
	return s
}

// The URL sent to the client for watching the content.
// Example: https://public-keyserver.mycompany.com
func (s DrmVendorVerimatrixImpl) UserKeyserver() *string {
	return s.UserKeyserverValue
}

// The URL sent to the client for watching the content.
// Example: https://public-keyserver.mycompany.com
func (s *DrmVendorVerimatrixImpl) SetUserKeyserver(v string) DrmVendorVerimatrix {
	if s == nil {
		return nil
	}
	s.UserKeyserverValue = &v
	return s
}

// FIXME: Verimatrix
func (s DrmVendorVerimatrixImpl) Vendor() string {
	return s.VendorValue
}

// FIXME: Verimatrix
func (s *DrmVendorVerimatrixImpl) SetVendor(v string) DrmVendorVerimatrix {
	if s == nil {
		return nil
	}
	s.VendorValue = v
	return s
}

// NewDrmVendorWidevine creates a new DrmVendorWidevine instance
func NewDrmVendorWidevine() DrmVendorWidevine {
	return &DrmVendorWidevineImpl{}
}

// AES (Advanced Encryption Standard) key. Used for Widevine DRM.
func (s DrmVendorWidevineImpl) AesKey() *string {
	return s.AesKeyValue
}

// AES (Advanced Encryption Standard) key. Used for Widevine DRM.
func (s *DrmVendorWidevineImpl) SetAesKey(v string) DrmVendorWidevine {
	if s == nil {
		return nil
	}
	s.AesKeyValue = &v
	return s
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s DrmVendorWidevineImpl) Encryption() *string {
	return s.EncryptionValue
}

// If this parameter is set to `full`, all frames are encrypted.
// If it is set to `sparse` (or empty), only the keyframes are encrypted.
// By default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access.
// It also reduces the power consumption, when decrypting on the client side.
// However, some Smart TVs and STBs require all frames to be encrypted.
func (s *DrmVendorWidevineImpl) SetEncryption(v string) DrmVendorWidevine {
	if s == nil {
		return nil
	}
	s.EncryptionValue = &v
	return s
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s DrmVendorWidevineImpl) Expires() *int {
	return s.ExpiresValue
}

// Key rotation interval, in minutes.
// By default, Flussonic does not rotate enryption keys.
// Specify this parameter to enable encryption key rotation and thus to provide a better securtiy.
func (s *DrmVendorWidevineImpl) SetExpires(v int) DrmVendorWidevine {
	if s == nil {
		return nil
	}
	s.ExpiresValue = &v
	return s
}

// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
// It is employed only one time in any session.
// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
// Usually, IV is received from a DRM provider.
func (s DrmVendorWidevineImpl) Iv() *string {
	return s.IvValue
}

// Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption.
// It is employed only one time in any session.
// The use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher.
// Usually, IV is received from a DRM provider.
func (s *DrmVendorWidevineImpl) SetIv(v string) DrmVendorWidevine {
	if s == nil {
		return nil
	}
	s.IvValue = &v
	return s
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s DrmVendorWidevineImpl) Keyserver() *string {
	return s.KeyserverValue
}

// DRM key server.
// Example: https://keyserver1.mycompany.com
func (s *DrmVendorWidevineImpl) SetKeyserver(v string) DrmVendorWidevine {
	if s == nil {
		return nil
	}
	s.KeyserverValue = &v
	return s
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s DrmVendorWidevineImpl) ResourceID() *DrmResourceID {
	return s.ResourceIDValue
}

// The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.
// The DRM system keeps track of viewing each resource by clients.
// A resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming.
// It is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.
// Format: drm_resource_id (drm_resource_id)
// Example: L2sItm6
func (s *DrmVendorWidevineImpl) SetResourceID(v DrmResourceID) DrmVendorWidevine {
	if s == nil {
		return nil
	}
	s.ResourceIDValue = &v
	return s
}

// A unique ID of the signer.
// Flussonic uses it to connect to the key server when using test key for Widevine DRM.
func (s DrmVendorWidevineImpl) Signer() *string {
	return s.SignerValue
}

// A unique ID of the signer.
// Flussonic uses it to connect to the key server when using test key for Widevine DRM.
func (s *DrmVendorWidevineImpl) SetSigner(v string) DrmVendorWidevine {
	if s == nil {
		return nil
	}
	s.SignerValue = &v
	return s
}

// FIXME: Widevine
func (s DrmVendorWidevineImpl) Vendor() string {
	return s.VendorValue
}

// FIXME: Widevine
func (s *DrmVendorWidevineImpl) SetVendor(v string) DrmVendorWidevine {
	if s == nil {
		return nil
	}
	s.VendorValue = v
	return s
}

// NewDvbCardConfig creates a new DvbCardConfig instance
func NewDvbCardConfig() DvbCardConfig {
	return &DvbCardConfigImpl{}
}

// Adapter number.
// Example: 16
func (s DvbCardConfigImpl) Adapter() *int {
	return s.AdapterValue
}

// Adapter number.
// Example: 16
func (s *DvbCardConfigImpl) SetAdapter(v int) DvbCardConfig {
	if s == nil {
		return nil
	}
	s.AdapterValue = &v
	return s
}

// Attenuation of the signal level. Takes values from 0 to 10.
func (s DvbCardConfigImpl) Attenuator() *int {
	return s.AttenuatorValue
}

// Attenuation of the signal level. Takes values from 0 to 10.
func (s *DvbCardConfigImpl) SetAttenuator(v int) DvbCardConfig {
	if s == nil {
		return nil
	}
	s.AttenuatorValue = &v
	return s
}

// Bandwidth, in Hz.
// Example: 6e+06
func (s DvbCardConfigImpl) Bandwidth() *int {
	return s.BandwidthValue
}

// Bandwidth, in Hz.
// Example: 6e+06
func (s *DvbCardConfigImpl) SetBandwidth(v int) DvbCardConfig {
	if s == nil {
		return nil
	}
	s.BandwidthValue = &v
	return s
}

// High priority stream code rate.
func (s DvbCardConfigImpl) CodeRateHp() *DvbFec {
	return s.CodeRateHpValue
}

// High priority stream code rate.
func (s *DvbCardConfigImpl) SetCodeRateHp(v DvbFec) DvbCardConfig {
	if s == nil {
		return nil
	}
	s.CodeRateHpValue = &v
	return s
}

// Low priority stream code rate.
func (s DvbCardConfigImpl) CodeRateLp() *DvbFec {
	return s.CodeRateLpValue
}

// Low priority stream code rate.
func (s *DvbCardConfigImpl) SetCodeRateLp(v DvbFec) DvbCardConfig {
	if s == nil {
		return nil
	}
	s.CodeRateLpValue = &v
	return s
}

// Any text comment.
func (s DvbCardConfigImpl) Comment() *string {
	return s.CommentValue
}

// Any text comment.
func (s *DvbCardConfigImpl) SetComment(v string) DvbCardConfig {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Max source's internal clock drift to compensate, rounding to six decimal places.
func (s DvbCardConfigImpl) CompensateTimeDriftPpm() *int {
	return s.CompensateTimeDriftPpmValue
}

// Max source's internal clock drift to compensate, rounding to six decimal places.
func (s *DvbCardConfigImpl) SetCompensateTimeDriftPpm(v int) DvbCardConfig {
	if s == nil {
		return nil
	}
	s.CompensateTimeDriftPpmValue = &v
	return s
}

// Modulator number in adapter.
func (s DvbCardConfigImpl) Device() *int {
	return s.DeviceValue
}

// Modulator number in adapter.
func (s *DvbCardConfigImpl) SetDevice(v int) DvbCardConfig {
	if s == nil {
		return nil
	}
	s.DeviceValue = &v
	return s
}

// Whether this DVB card is disabled.
// Example: false
func (s DvbCardConfigImpl) Disabled() *bool {
	return s.DisabledValue
}

// Whether this DVB card is disabled.
// Example: false
func (s *DvbCardConfigImpl) SetDisabled(v bool) DvbCardConfig {
	if s == nil {
		return nil
	}
	s.DisabledValue = &v
	return s
}

// The carrier frequency of the transponder for this channel, in Hz.
// Example: 11606
func (s DvbCardConfigImpl) Frequency() *int {
	return s.FrequencyValue
}

// The carrier frequency of the transponder for this channel, in Hz.
// Example: 11606
func (s *DvbCardConfigImpl) SetFrequency(v int) DvbCardConfig {
	if s == nil {
		return nil
	}
	s.FrequencyValue = &v
	return s
}

// Frontend number.
func (s DvbCardConfigImpl) Frontend() *int {
	return s.FrontendValue
}

// Frontend number.
func (s *DvbCardConfigImpl) SetFrontend(v int) DvbCardConfig {
	if s == nil {
		return nil
	}
	s.FrontendValue = &v
	return s
}

// Adjust the output gain to the specified value in dB.
func (s DvbCardConfigImpl) Gain() *int {
	return s.GainValue
}

// Adjust the output gain to the specified value in dB.
func (s *DvbCardConfigImpl) SetGain(v int) DvbCardConfig {
	if s == nil {
		return nil
	}
	s.GainValue = &v
	return s
}

// The mode of inserting a guard interval - a padding separating transmissions so that they do not interfere with each other.
// Example: 1_16
func (s DvbCardConfigImpl) GuardInterval() *string {
	return s.GuardIntervalValue
}

// The mode of inserting a guard interval - a padding separating transmissions so that they do not interfere with each other.
// Example: 1_16
func (s *DvbCardConfigImpl) SetGuardInterval(v string) DvbCardConfig {
	if s == nil {
		return nil
	}
	s.GuardIntervalValue = &v
	return s
}

// Constellation ratio for hierarchical transmission.
func (s DvbCardConfigImpl) Hierarchy() *string {
	return s.HierarchyValue
}

// Constellation ratio for hierarchical transmission.
func (s *DvbCardConfigImpl) SetHierarchy(v string) DvbCardConfig {
	if s == nil {
		return nil
	}
	s.HierarchyValue = &v
	return s
}

// Whether high frequency band is used.
func (s DvbCardConfigImpl) HighBand() *bool {
	return s.HighBandValue
}

// Whether high frequency band is used.
func (s *DvbCardConfigImpl) SetHighBand(v bool) DvbCardConfig {
	if s == nil {
		return nil
	}
	s.HighBandValue = &v
	return s
}

// Adapter card hardware type.
// Example: dvb
func (s DvbCardConfigImpl) Hw() *string {
	return s.HwValue
}

// Adapter card hardware type.
// Example: dvb
func (s *DvbCardConfigImpl) SetHw(v string) DvbCardConfig {
	if s == nil {
		return nil
	}
	s.HwValue = &v
	return s
}

// Input bitrate, in Mbps.
func (s DvbCardConfigImpl) InputBitrate() *int {
	return s.InputBitrateValue
}

// Input bitrate, in Mbps.
func (s *DvbCardConfigImpl) SetInputBitrate(v int) DvbCardConfig {
	if s == nil {
		return nil
	}
	s.InputBitrateValue = &v
	return s
}

// Base frequency, in MHz.
func (s DvbCardConfigImpl) IntFreq() *int {
	return s.IntFreqValue
}

// Base frequency, in MHz.
func (s *DvbCardConfigImpl) SetIntFreq(v int) DvbCardConfig {
	if s == nil {
		return nil
	}
	s.IntFreqValue = &v
	return s
}

// Use interleaver.
// The interlaver disperses sequence of bits in bit stream to minimize effect of burst errors during transmission.
func (s DvbCardConfigImpl) Interleave() *int {
	return s.InterleaveValue
}

// Use interleaver.
// The interlaver disperses sequence of bits in bit stream to minimize effect of burst errors during transmission.
func (s *DvbCardConfigImpl) SetInterleave(v int) DvbCardConfig {
	if s == nil {
		return nil
	}
	s.InterleaveValue = &v
	return s
}

// DVB-C modulation method.
// Example: auto
func (s DvbCardConfigImpl) Modulation() *string {
	return s.ModulationValue
}

// DVB-C modulation method.
// Example: auto
func (s *DvbCardConfigImpl) SetModulation(v string) DvbCardConfig {
	if s == nil {
		return nil
	}
	s.ModulationValue = &v
	return s
}

// DVB card name.
// Format: dvb_card_name (dvb_card_name)
// Example: a16
func (s DvbCardConfigImpl) Name() DvbCardName {
	return s.NameValue
}

// DVB card name.
// Format: dvb_card_name (dvb_card_name)
// Example: a16
func (s *DvbCardConfigImpl) SetName(v DvbCardName) DvbCardConfig {
	if s == nil {
		return nil
	}
	s.NameValue = v
	return s
}

// Enable, disable, or autodetect pilot tones.
// Example: auto
func (s DvbCardConfigImpl) Pilot() *string {
	return s.PilotValue
}

// Enable, disable, or autodetect pilot tones.
// Example: auto
func (s *DvbCardConfigImpl) SetPilot(v string) DvbCardConfig {
	if s == nil {
		return nil
	}
	s.PilotValue = &v
	return s
}

// PLP stream selector. Used in DVB-T2.
func (s DvbCardConfigImpl) PlpStreamID() *int {
	return s.PlpStreamIDValue
}

// PLP stream selector. Used in DVB-T2.
func (s *DvbCardConfigImpl) SetPlpStreamID(v int) DvbCardConfig {
	if s == nil {
		return nil
	}
	s.PlpStreamIDValue = &v
	return s
}

// Polarization of the transponder for this channel.
// The supported values are:
// * `v`- vertical linear polarization,
// * `h` - horizontal linear polarization,
// * `r` - right-hand circular polarization,
// * `l` - left-hand circular polarization.
// Example: v
func (s DvbCardConfigImpl) Polarization() *string {
	return s.PolarizationValue
}

// Polarization of the transponder for this channel.
// The supported values are:
// * `v`- vertical linear polarization,
// * `h` - horizontal linear polarization,
// * `r` - right-hand circular polarization,
// * `l` - left-hand circular polarization.
// Example: v
func (s *DvbCardConfigImpl) SetPolarization(v string) DvbCardConfig {
	if s == nil {
		return nil
	}
	s.PolarizationValue = &v
	return s
}

// Port number, used for capturing from DekTec ASI cards.
func (s DvbCardConfigImpl) Port() *int {
	return s.PortValue
}

// Port number, used for capturing from DekTec ASI cards.
func (s *DvbCardConfigImpl) SetPort(v int) DvbCardConfig {
	if s == nil {
		return nil
	}
	s.PortValue = &v
	return s
}

// Rolloff factor, in %.
// It is used to estimate bandwidth, together with symbol rate.
func (s DvbCardConfigImpl) Rolloff() *string {
	return s.RolloffValue
}

// Rolloff factor, in %.
// It is used to estimate bandwidth, together with symbol rate.
func (s *DvbCardConfigImpl) SetRolloff(v string) DvbCardConfig {
	if s == nil {
		return nil
	}
	s.RolloffValue = &v
	return s
}

// Serial number of the card, used for capturing from DekTec ASI cards.
func (s DvbCardConfigImpl) Serial() *int {
	return s.SerialValue
}

// Serial number of the card, used for capturing from DekTec ASI cards.
func (s *DvbCardConfigImpl) SetSerial(v int) DvbCardConfig {
	if s == nil {
		return nil
	}
	s.SerialValue = &v
	return s
}

// Statistic information about the captured signal.
func (s DvbCardConfigImpl) Stats() DvbCardStats {
	return s.StatsValue
}

// Statistic information about the captured signal.
func (s *DvbCardConfigImpl) SetStats(v DvbCardStats) DvbCardConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*DvbCardStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// The symbol rate of the transponder, in symbols per second.
// A symbol is a pulse in digital baseband transmission.
// Example: 27500
func (s DvbCardConfigImpl) SymbolRate() *int {
	return s.SymbolRateValue
}

// The symbol rate of the transponder, in symbols per second.
// A symbol is a pulse in digital baseband transmission.
// Example: 27500
func (s *DvbCardConfigImpl) SetSymbolRate(v int) DvbCardConfig {
	if s == nil {
		return nil
	}
	s.SymbolRateValue = &v
	return s
}

// Adapter type. Different systems are supported besides DVB, as the configuring is similar.
func (s DvbCardConfigImpl) System() *string {
	return s.SystemValue
}

// Adapter type. Different systems are supported besides DVB, as the configuring is similar.
func (s *DvbCardConfigImpl) SetSystem(v string) DvbCardConfig {
	if s == nil {
		return nil
	}
	s.SystemValue = &v
	return s
}

// DVB transmission mode.
func (s DvbCardConfigImpl) TransmissionMode() *string {
	return s.TransmissionModeValue
}

// DVB transmission mode.
func (s *DvbCardConfigImpl) SetTransmissionMode(v string) DvbCardConfig {
	if s == nil {
		return nil
	}
	s.TransmissionModeValue = &v
	return s
}

// The video device to capture video from Stream Labs SDI/ASI cards.
// It is actually a path to a device file created on the disk by Video4Linux.
// Example: /dev/video0
func (s DvbCardConfigImpl) VideoDevice() *string {
	return s.VideoDeviceValue
}

// The video device to capture video from Stream Labs SDI/ASI cards.
// It is actually a path to a device file created on the disk by Video4Linux.
// Example: /dev/video0
func (s *DvbCardConfigImpl) SetVideoDevice(v string) DvbCardConfig {
	if s == nil {
		return nil
	}
	s.VideoDeviceValue = &v
	return s
}

// NewDvbCardStats creates a new DvbCardStats instance
func NewDvbCardStats() DvbCardStats {
	return &DvbCardStatsImpl{}
}

// Bit error rate. It is the percent of bit errors from total number of transferred bits.
// Example: 5
func (s DvbCardStatsImpl) Ber() *int {
	return s.BerValue
}

// Bit error rate. It is the percent of bit errors from total number of transferred bits.
// Example: 5
func (s *DvbCardStatsImpl) SetBer(v int) DvbCardStats {
	if s == nil {
		return nil
	}
	s.BerValue = &v
	return s
}

// Carrier detected in signal.
// Example: true
func (s DvbCardStatsImpl) HasCarrier() *bool {
	return s.HasCarrierValue
}

// Carrier detected in signal.
// Example: true
func (s *DvbCardStatsImpl) SetHasCarrier(v bool) DvbCardStats {
	if s == nil {
		return nil
	}
	s.HasCarrierValue = &v
	return s
}

// DVB signal was successfully locked.
// Example: true
func (s DvbCardStatsImpl) HasLock() *bool {
	return s.HasLockValue
}

// DVB signal was successfully locked.
// Example: true
func (s *DvbCardStatsImpl) SetHasLock(v bool) DvbCardStats {
	if s == nil {
		return nil
	}
	s.HasLockValue = &v
	return s
}

// Input rate is sufficient (900 bps or greater). Used for capturing from DekTec ASI cards.
// Example: true
func (s DvbCardStatsImpl) HasRate() *bool {
	return s.HasRateValue
}

// Input rate is sufficient (900 bps or greater). Used for capturing from DekTec ASI cards.
// Example: true
func (s *DvbCardStatsImpl) SetHasRate(v bool) DvbCardStats {
	if s == nil {
		return nil
	}
	s.HasRateValue = &v
	return s
}

// The frontend was reinitialized, the application is recommended to reset DiSEqC, tone and parameters.
// Example: false
func (s DvbCardStatsImpl) HasReinit() *bool {
	return s.HasReinitValue
}

// The frontend was reinitialized, the application is recommended to reset DiSEqC, tone and parameters.
// Example: false
func (s *DvbCardStatsImpl) SetHasReinit(v bool) DvbCardStats {
	if s == nil {
		return nil
	}
	s.HasReinitValue = &v
	return s
}

// Whether a signal is detected above the normal noise level.
// Example: true
func (s DvbCardStatsImpl) HasSignal() *bool {
	return s.HasSignalValue
}

// Whether a signal is detected above the normal noise level.
// Example: true
func (s *DvbCardStatsImpl) SetHasSignal(v bool) DvbCardStats {
	if s == nil {
		return nil
	}
	s.HasSignalValue = &v
	return s
}

// Synchronization bytes detected.
// Example: true
func (s DvbCardStatsImpl) HasSync() *bool {
	return s.HasSyncValue
}

// Synchronization bytes detected.
// Example: true
func (s *DvbCardStatsImpl) SetHasSync(v bool) DvbCardStats {
	if s == nil {
		return nil
	}
	s.HasSyncValue = &v
	return s
}

// The signal was not locked within the last about 2 seconds.
// Example: false
func (s DvbCardStatsImpl) HasTimedout() *bool {
	return s.HasTimedoutValue
}

// The signal was not locked within the last about 2 seconds.
// Example: false
func (s *DvbCardStatsImpl) SetHasTimedout(v bool) DvbCardStats {
	if s == nil {
		return nil
	}
	s.HasTimedoutValue = &v
	return s
}

// DVB signal was locked at Viterbi decoder stage.
// Example: true
func (s DvbCardStatsImpl) HasViterbi() *bool {
	return s.HasViterbiValue
}

// DVB signal was locked at Viterbi decoder stage.
// Example: true
func (s *DvbCardStatsImpl) SetHasViterbi(v bool) DvbCardStats {
	if s == nil {
		return nil
	}
	s.HasViterbiValue = &v
	return s
}

// Signal-noise ratio, in percent. It is the ratio of signal power to the noise power.
// Example: 1
func (s DvbCardStatsImpl) Snr() *int {
	return s.SnrValue
}

// Signal-noise ratio, in percent. It is the ratio of signal power to the noise power.
// Example: 1
func (s *DvbCardStatsImpl) SetSnr(v int) DvbCardStats {
	if s == nil {
		return nil
	}
	s.SnrValue = &v
	return s
}

// Signal-noise ratio, as a raw 16-bit number received from DVB API. It is the ratio of signal power to the noise power.
// Example: 894
func (s DvbCardStatsImpl) SnrRaw() *int {
	return s.SnrRawValue
}

// Signal-noise ratio, as a raw 16-bit number received from DVB API. It is the ratio of signal power to the noise power.
// Example: 894
func (s *DvbCardStatsImpl) SetSnrRaw(v int) DvbCardStats {
	if s == nil {
		return nil
	}
	s.SnrRawValue = &v
	return s
}

// Signal strength, in percent.
// Example: 95
func (s DvbCardStatsImpl) Strength() *int {
	return s.StrengthValue
}

// Signal strength, in percent.
// Example: 95
func (s *DvbCardStatsImpl) SetStrength(v int) DvbCardStats {
	if s == nil {
		return nil
	}
	s.StrengthValue = &v
	return s
}

// Signal strength, as a raw 16-bit number received from DVB API.
// Example: 62446
func (s DvbCardStatsImpl) StrengthRaw() *int {
	return s.StrengthRawValue
}

// Signal strength, as a raw 16-bit number received from DVB API.
// Example: 62446
func (s *DvbCardStatsImpl) SetStrengthRaw(v int) DvbCardStats {
	if s == nil {
		return nil
	}
	s.StrengthRawValue = &v
	return s
}

// NewDvrBaseConfig creates a new DvrBaseConfig instance
func NewDvrBaseConfig() DvrBaseConfig {
	return &DvrBaseConfigImpl{}
}

// Maximum disk consumption in percents. When this limit is reached,
// the oldest segment of the recording will be overridden by later data.
// It important to understand that this is not a "per-stream" option, this option means
// that cleaning of this stream will be triggered if overall disk usage reaches this number.
// If you have all streams with configuration 98% and one stream with 95%, it will be permanently
// empty.
// Format: percent (percent)
// Example: 98
func (s DvrBaseConfigImpl) DiskUsageLimit() *Percent {
	return s.DiskUsageLimitValue
}

// Maximum disk consumption in percents. When this limit is reached,
// the oldest segment of the recording will be overridden by later data.
// It important to understand that this is not a "per-stream" option, this option means
// that cleaning of this stream will be triggered if overall disk usage reaches this number.
// If you have all streams with configuration 98% and one stream with 95%, it will be permanently
// empty.
// Format: percent (percent)
// Example: 98
func (s *DvrBaseConfigImpl) SetDiskUsageLimit(v Percent) DvrBaseConfig {
	if s == nil {
		return nil
	}
	s.DiskUsageLimitValue = &v
	return s
}

// Additional archive depth in seconds for episodes. If set, episodes and their corresponding DVR record
// will be saved for `expiration + episodes_expiration` seconds.
// The archive clean-up within `[expiration, expiration+episodes_expiration]` seconds of the
// recording performed depending on [external_episodes_list](https://flussonic.com/doc/api/config-external/#tag/dvr/operation/external_episodes_list)
// response of `episodes_url`.
// Anything older than `expiration+episodes_expiration` seconds will
// be cleaned even if `episodes_url` does not respond.
// Format: seconds (seconds)
// Examples: 6.048e+06
func (s DvrBaseConfigImpl) EpisodesExpiration() *Seconds {
	return s.EpisodesExpirationValue
}

// Additional archive depth in seconds for episodes. If set, episodes and their corresponding DVR record
// will be saved for `expiration + episodes_expiration` seconds.
// The archive clean-up within `[expiration, expiration+episodes_expiration]` seconds of the
// recording performed depending on [external_episodes_list](https://flussonic.com/doc/api/config-external/#tag/dvr/operation/external_episodes_list)
// response of `episodes_url`.
// Anything older than `expiration+episodes_expiration` seconds will
// be cleaned even if `episodes_url` does not respond.
// Format: seconds (seconds)
// Examples: 6.048e+06
func (s *DvrBaseConfigImpl) SetEpisodesExpiration(v Seconds) DvrBaseConfig {
	if s == nil {
		return nil
	}
	s.EpisodesExpirationValue = &v
	return s
}

// Archive depth - a period (in seconds) back from the current moment during which the
// contigious part of archive is stored.
// As time goes, the parts of the recording which are older than the archive depth are deleted.
// If you have option `episodes_expiration` enabled, then some parts of DVR that are
// locked by episode signalling mechanism may be kept more than this `expiration` depth.
// If `episodes_url` does not respond, the archive clean-up by `expiration` is not performed;
// only the archive with expired episodes (`episodes_expiration`) is cleaned up until the `episodes_url` restores.
// Format: seconds (seconds)
// Examples: 604800
func (s DvrBaseConfigImpl) Expiration() *Seconds {
	return s.ExpirationValue
}

// Archive depth - a period (in seconds) back from the current moment during which the
// contigious part of archive is stored.
// As time goes, the parts of the recording which are older than the archive depth are deleted.
// If you have option `episodes_expiration` enabled, then some parts of DVR that are
// locked by episode signalling mechanism may be kept more than this `expiration` depth.
// If `episodes_url` does not respond, the archive clean-up by `expiration` is not performed;
// only the archive with expired episodes (`episodes_expiration`) is cleaned up until the `episodes_url` restores.
// Format: seconds (seconds)
// Examples: 604800
func (s *DvrBaseConfigImpl) SetExpiration(v Seconds) DvrBaseConfig {
	if s == nil {
		return nil
	}
	s.ExpirationValue = &v
	return s
}

// Maximum disk consumption in bytes. When this limit is reached,
// the oldest segment of the recording will be overridden by later data.
// This option affects both continuous recording and locked episodes (see `episodes_url`).
// If `episodes_url` does not respond, the archive clean-up by `storage_limit` is not performed
// to avoid deleting the recordings that should not be deleted.
// Format: bytes (bytes)
// Example: 4e+11
func (s DvrBaseConfigImpl) StorageLimit() *Bytes {
	return s.StorageLimitValue
}

// Maximum disk consumption in bytes. When this limit is reached,
// the oldest segment of the recording will be overridden by later data.
// This option affects both continuous recording and locked episodes (see `episodes_url`).
// If `episodes_url` does not respond, the archive clean-up by `storage_limit` is not performed
// to avoid deleting the recordings that should not be deleted.
// Format: bytes (bytes)
// Example: 4e+11
func (s *DvrBaseConfigImpl) SetStorageLimit(v Bytes) DvrBaseConfig {
	if s == nil {
		return nil
	}
	s.StorageLimitValue = &v
	return s
}

// NewDvrCapacityStats creates a new DvrCapacityStats instance
func NewDvrCapacityStats() DvrCapacityStats {
	return &DvrCapacityStatsImpl{}
}

// The number of blobs on the disk that are enlisted in individual stream indexes.
// It must be equal to blobs_count_db and can be different in case of software
// or hardware errors.
func (s DvrCapacityStatsImpl) BlobsCount() *int {
	return s.BlobsCountValue
}

// The number of blobs on the disk that are enlisted in individual stream indexes.
// It must be equal to blobs_count_db and can be different in case of software
// or hardware errors.
func (s *DvrCapacityStatsImpl) SetBlobsCount(v int) DvrCapacityStats {
	if s == nil {
		return nil
	}
	s.BlobsCountValue = &v
	return s
}

// The number of blobs on the disk according to centralized Raid DB that is
// used to allocate blobs across whole storage.
func (s DvrCapacityStatsImpl) BlobsCountDb() *int {
	return s.BlobsCountDbValue
}

// The number of blobs on the disk according to centralized Raid DB that is
// used to allocate blobs across whole storage.
func (s *DvrCapacityStatsImpl) SetBlobsCountDb(v int) DvrCapacityStats {
	if s == nil {
		return nil
	}
	s.BlobsCountDbValue = &v
	return s
}

// Disk capacity in bytes.
// Format: bytes (bytes)
func (s DvrCapacityStatsImpl) Size() *Bytes {
	return s.SizeValue
}

// Disk capacity in bytes.
// Format: bytes (bytes)
func (s *DvrCapacityStatsImpl) SetSize(v Bytes) DvrCapacityStats {
	if s == nil {
		return nil
	}
	s.SizeValue = &v
	return s
}

// Disk utilization percentage.
// Format: percent (percent)
func (s DvrCapacityStatsImpl) Usage() *Percent {
	return s.UsageValue
}

// Disk utilization percentage.
// Format: percent (percent)
func (s *DvrCapacityStatsImpl) SetUsage(v Percent) DvrCapacityStats {
	if s == nil {
		return nil
	}
	s.UsageValue = &v
	return s
}

// Used disk space in bytes according to linux metrics. It must be equal (almost equal) to
// `used_index`. If it differs more than in 1%, then it means that there are lot of unknown files.
// If this disk is used exclusively for Raid, then it may mean that some blobs are lost from
// database and repairing is required.
// Format: bytes (bytes)
func (s DvrCapacityStatsImpl) Used() *Bytes {
	return s.UsedValue
}

// Used disk space in bytes according to linux metrics. It must be equal (almost equal) to
// `used_index`. If it differs more than in 1%, then it means that there are lot of unknown files.
// If this disk is used exclusively for Raid, then it may mean that some blobs are lost from
// database and repairing is required.
// Format: bytes (bytes)
func (s *DvrCapacityStatsImpl) SetUsed(v Bytes) DvrCapacityStats {
	if s == nil {
		return nil
	}
	s.UsedValue = &v
	return s
}

// Used disk space in bytes according to internal database index.
// Format: bytes (bytes)
func (s DvrCapacityStatsImpl) UsedIndex() *Bytes {
	return s.UsedIndexValue
}

// Used disk space in bytes according to internal database index.
// Format: bytes (bytes)
func (s *DvrCapacityStatsImpl) SetUsedIndex(v Bytes) DvrCapacityStats {
	if s == nil {
		return nil
	}
	s.UsedIndexValue = &v
	return s
}

// NewDvrConfig creates a new DvrConfig instance
func NewDvrConfig() DvrConfig {
	return &DvrConfigImpl{}
}

// The number of disks to write the archive.
func (s DvrConfigImpl) Active() *int {
	return s.ActiveValue
}

// The number of disks to write the archive.
func (s *DvrConfigImpl) SetActive(v int) DvrConfig {
	if s == nil {
		return nil
	}
	s.ActiveValue = &v
	return s
}

// Maximum disk consumption in percents. When this limit is reached,
// the oldest segment of the recording will be overridden by later data.
// It important to understand that this is not a "per-stream" option, this option means
// that cleaning of this stream will be triggered if overall disk usage reaches this number.
// If you have all streams with configuration 98% and one stream with 95%, it will be permanently
// empty.
// Format: percent (percent)
// Example: 98
func (s DvrConfigImpl) DiskUsageLimit() *Percent {
	return s.DiskUsageLimitValue
}

// Maximum disk consumption in percents. When this limit is reached,
// the oldest segment of the recording will be overridden by later data.
// It important to understand that this is not a "per-stream" option, this option means
// that cleaning of this stream will be triggered if overall disk usage reaches this number.
// If you have all streams with configuration 98% and one stream with 95%, it will be permanently
// empty.
// Format: percent (percent)
// Example: 98
func (s *DvrConfigImpl) SetDiskUsageLimit(v Percent) DvrConfig {
	if s == nil {
		return nil
	}
	s.DiskUsageLimitValue = &v
	return s
}

// RAID disks mounted on the server.
func (s DvrConfigImpl) Disks() []RaidDiskConfig {
	if s.DisksValue == nil {
		return nil
	}
	result := make([]RaidDiskConfig, len(s.DisksValue))
	for i, item := range s.DisksValue {
		result[i] = item
	}
	return result
}

// RAID disks mounted on the server.
func (s *DvrConfigImpl) SetDisks(v []RaidDiskConfig) DvrConfig {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*RaidDiskConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*RaidDiskConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.DisksValue = impl
	}
	return s
}

// Additional archive depth in seconds for episodes. If set, episodes and their corresponding DVR record
// will be saved for `expiration + episodes_expiration` seconds.
// The archive clean-up within `[expiration, expiration+episodes_expiration]` seconds of the
// recording performed depending on [external_episodes_list](https://flussonic.com/doc/api/config-external/#tag/dvr/operation/external_episodes_list)
// response of `episodes_url`.
// Anything older than `expiration+episodes_expiration` seconds will
// be cleaned even if `episodes_url` does not respond.
// Format: seconds (seconds)
// Examples: 6.048e+06
func (s DvrConfigImpl) EpisodesExpiration() *Seconds {
	return s.EpisodesExpirationValue
}

// Additional archive depth in seconds for episodes. If set, episodes and their corresponding DVR record
// will be saved for `expiration + episodes_expiration` seconds.
// The archive clean-up within `[expiration, expiration+episodes_expiration]` seconds of the
// recording performed depending on [external_episodes_list](https://flussonic.com/doc/api/config-external/#tag/dvr/operation/external_episodes_list)
// response of `episodes_url`.
// Anything older than `expiration+episodes_expiration` seconds will
// be cleaned even if `episodes_url` does not respond.
// Format: seconds (seconds)
// Examples: 6.048e+06
func (s *DvrConfigImpl) SetEpisodesExpiration(v Seconds) DvrConfig {
	if s == nil {
		return nil
	}
	s.EpisodesExpirationValue = &v
	return s
}

// Archive depth - a period (in seconds) back from the current moment during which the
// contigious part of archive is stored.
// As time goes, the parts of the recording which are older than the archive depth are deleted.
// If you have option `episodes_expiration` enabled, then some parts of DVR that are
// locked by episode signalling mechanism may be kept more than this `expiration` depth.
// If `episodes_url` does not respond, the archive clean-up by `expiration` is not performed;
// only the archive with expired episodes (`episodes_expiration`) is cleaned up until the `episodes_url` restores.
// Format: seconds (seconds)
// Examples: 604800
func (s DvrConfigImpl) Expiration() *Seconds {
	return s.ExpirationValue
}

// Archive depth - a period (in seconds) back from the current moment during which the
// contigious part of archive is stored.
// As time goes, the parts of the recording which are older than the archive depth are deleted.
// If you have option `episodes_expiration` enabled, then some parts of DVR that are
// locked by episode signalling mechanism may be kept more than this `expiration` depth.
// If `episodes_url` does not respond, the archive clean-up by `expiration` is not performed;
// only the archive with expired episodes (`episodes_expiration`) is cleaned up until the `episodes_url` restores.
// Format: seconds (seconds)
// Examples: 604800
func (s *DvrConfigImpl) SetExpiration(v Seconds) DvrConfig {
	if s == nil {
		return nil
	}
	s.ExpirationValue = &v
	return s
}

// A directory on an SSD disk where the data will be cached.
// Format: disk_path (disk_path)
func (s DvrConfigImpl) Index() *DiskPath {
	return s.IndexValue
}

// A directory on an SSD disk where the data will be cached.
// Format: disk_path (disk_path)
func (s *DvrConfigImpl) SetIndex(v DiskPath) DvrConfig {
	if s == nil {
		return nil
	}
	s.IndexValue = &v
	return s
}

// DVR configuration name.
// Format: dvr_name (dvr_name)
func (s DvrConfigImpl) Name() DvrName {
	return s.NameValue
}

// DVR configuration name.
// Format: dvr_name (dvr_name)
func (s *DvrConfigImpl) SetName(v DvrName) DvrConfig {
	if s == nil {
		return nil
	}
	s.NameValue = v
	return s
}

// This value is present if RAID (redundant array of independent disks) is enabled. Learn more in [Flussonic RAID for DVR](https://flussonic.com/doc/extend-video-storage-on-fly/).
func (s DvrConfigImpl) Raid() *DvrRaidLevel {
	return s.RaidValue
}

// This value is present if RAID (redundant array of independent disks) is enabled. Learn more in [Flussonic RAID for DVR](https://flussonic.com/doc/extend-video-storage-on-fly/).
func (s *DvrConfigImpl) SetRaid(v DvrRaidLevel) DvrConfig {
	if s == nil {
		return nil
	}
	s.RaidValue = &v
	return s
}

// A path where the DVR archive is stored.
// Format: dvr_url (dvr_url)
func (s DvrConfigImpl) Root() DvrURL {
	return s.RootValue
}

// A path where the DVR archive is stored.
// Format: dvr_url (dvr_url)
func (s *DvrConfigImpl) SetRoot(v DvrURL) DvrConfig {
	if s == nil {
		return nil
	}
	s.RootValue = v
	return s
}

// The runtime statistics about DVR.
func (s DvrConfigImpl) Stats() DvrStorageConfigStats {
	return s.StatsValue
}

// The runtime statistics about DVR.
func (s *DvrConfigImpl) SetStats(v DvrStorageConfigStats) DvrConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*DvrStorageConfigStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// Maximum disk consumption in bytes. When this limit is reached,
// the oldest segment of the recording will be overridden by later data.
// This option affects both continuous recording and locked episodes (see `episodes_url`).
// If `episodes_url` does not respond, the archive clean-up by `storage_limit` is not performed
// to avoid deleting the recordings that should not be deleted.
// Format: bytes (bytes)
// Example: 4e+11
func (s DvrConfigImpl) StorageLimit() *Bytes {
	return s.StorageLimitValue
}

// Maximum disk consumption in bytes. When this limit is reached,
// the oldest segment of the recording will be overridden by later data.
// This option affects both continuous recording and locked episodes (see `episodes_url`).
// If `episodes_url` does not respond, the archive clean-up by `storage_limit` is not performed
// to avoid deleting the recordings that should not be deleted.
// Format: bytes (bytes)
// Example: 4e+11
func (s *DvrConfigImpl) SetStorageLimit(v Bytes) DvrConfig {
	if s == nil {
		return nil
	}
	s.StorageLimitValue = &v
	return s
}

// NewDvrInfo creates a new DvrInfo instance
func NewDvrInfo() DvrInfo {
	return &DvrInfoImpl{}
}

// The size of the recorded archive.
// Format: bytes (bytes)
// Example: 1.296e+11
func (s DvrInfoImpl) Bytes() *Bytes {
	return s.BytesValue
}

// The size of the recorded archive.
// Format: bytes (bytes)
// Example: 1.296e+11
func (s *DvrInfoImpl) SetBytes(v Bytes) DvrInfo {
	if s == nil {
		return nil
	}
	s.BytesValue = &v
	return s
}

// The time interval between the start of the *first* recording segment and the end of the *last* one.
// Format: seconds (seconds)
// Example: 259200
func (s DvrInfoImpl) Depth() Seconds {
	return s.DepthValue
}

// The time interval between the start of the *first* recording segment and the end of the *last* one.
// Format: seconds (seconds)
// Example: 259200
func (s *DvrInfoImpl) SetDepth(v Seconds) DvrInfo {
	if s == nil {
		return nil
	}
	s.DepthValue = v
	return s
}

// Deprecated field. Will be deleted at 25.07
// The size of the recorded archive. Please, use bytes instead.
// Format: bytes (bytes)
// Example: 1.099511627776e+12
func (s DvrInfoImpl) DiskSize() *Bytes {
	return s.DiskSizeValue
}

// Deprecated field. Will be deleted at 25.07
// The size of the recorded archive. Please, use bytes instead.
// Format: bytes (bytes)
// Example: 1.099511627776e+12
func (s *DvrInfoImpl) SetDiskSize(v Bytes) DvrInfo {
	if s == nil {
		return nil
	}
	s.DiskSizeValue = &v
	return s
}

// A total duration of the recorded segments, excluding recording gaps.
// It can be smaller than depth if you have gaps.
// Format: seconds (seconds)
// Example: 172800
func (s DvrInfoImpl) Duration() *Seconds {
	return s.DurationValue
}

// A total duration of the recorded segments, excluding recording gaps.
// It can be smaller than depth if you have gaps.
// Format: seconds (seconds)
// Example: 172800
func (s *DvrInfoImpl) SetDuration(v Seconds) DvrInfo {
	if s == nil {
		return nil
	}
	s.DurationValue = &v
	return s
}

// The UTC timestamp of the first recording in this archive.
// Format: utc (Unix timestamp in seconds)
// Example: 1.641045644e+09
func (s DvrInfoImpl) From() Utc {
	return s.FromValue
}

// The UTC timestamp of the first recording in this archive.
// Format: utc (Unix timestamp in seconds)
// Example: 1.641045644e+09
func (s *DvrInfoImpl) SetFrom(v Utc) DvrInfo {
	if s == nil {
		return nil
	}
	s.FromValue = v
	return s
}

// Deprecated field. Will be deleted at 24.09
// The list of DVR ranges. The param is replaced with `ranges_list` method.
func (s DvrInfoImpl) Ranges() []DvrRange {
	if s.RangesValue == nil {
		return nil
	}
	result := make([]DvrRange, len(s.RangesValue))
	for i, item := range s.RangesValue {
		result[i] = item
	}
	return result
}

// Deprecated field. Will be deleted at 24.09
// The list of DVR ranges. The param is replaced with `ranges_list` method.
func (s *DvrInfoImpl) SetRanges(v []DvrRange) DvrInfo {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*DvrRangeImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*DvrRangeImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.RangesValue = impl
	}
	return s
}

// NewDvrRange creates a new DvrRange instance
func NewDvrRange() DvrRange {
	return &DvrRangeImpl{}
}

// The the of the last recorded data.
// Please notice that closed_at could be changed. There are two reasons.
// - Cleaner process reduced data. Read [more](https://flussonic.com/doc/api/reference/#tag/stream/operation/stream_get/response%7Cdvr%7Cepisodes_url).
// - Recording is still working. Near real-time value means that DVR is active at the moment.
// This is a replacement for `duration` field
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s DvrRangeImpl) ClosedAt() *UtcMs {
	return s.ClosedAtValue
}

// The the of the last recorded data.
// Please notice that closed_at could be changed. There are two reasons.
// - Cleaner process reduced data. Read [more](https://flussonic.com/doc/api/reference/#tag/stream/operation/stream_get/response%7Cdvr%7Cepisodes_url).
// - Recording is still working. Near real-time value means that DVR is active at the moment.
// This is a replacement for `duration` field
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *DvrRangeImpl) SetClosedAt(v UtcMs) DvrRange {
	if s == nil {
		return nil
	}
	s.ClosedAtValue = &v
	return s
}

// Deprecated field. Will be deleted at 24.11
// The duration of the recorded DVR range.
// Use closed_at instead of this field.
// Format: seconds (seconds)
// Example: 28800
func (s DvrRangeImpl) Duration() *Seconds {
	return s.DurationValue
}

// Deprecated field. Will be deleted at 24.11
// The duration of the recorded DVR range.
// Use closed_at instead of this field.
// Format: seconds (seconds)
// Example: 28800
func (s *DvrRangeImpl) SetDuration(v Seconds) DvrRange {
	if s == nil {
		return nil
	}
	s.DurationValue = &v
	return s
}

// Deprecated field. Will be deleted at 24.11
// The beginning of the recorded DVR range. Use opened_at instead.
// Mention that opened_at has milliseconds
// Format: utc (Unix timestamp in seconds)
// Example: 1.525186456e+09
func (s DvrRangeImpl) From() *Utc {
	return s.FromValue
}

// Deprecated field. Will be deleted at 24.11
// The beginning of the recorded DVR range. Use opened_at instead.
// Mention that opened_at has milliseconds
// Format: utc (Unix timestamp in seconds)
// Example: 1.525186456e+09
func (s *DvrRangeImpl) SetFrom(v Utc) DvrRange {
	if s == nil {
		return nil
	}
	s.FromValue = &v
	return s
}

// The time when this range was started. Naming is standard for whole flussonic ecosystem.
// Is a replacement for field `from`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s DvrRangeImpl) OpenedAt() *UtcMs {
	return s.OpenedAtValue
}

// The time when this range was started. Naming is standard for whole flussonic ecosystem.
// Is a replacement for field `from`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *DvrRangeImpl) SetOpenedAt(v UtcMs) DvrRange {
	if s == nil {
		return nil
	}
	s.OpenedAtValue = &v
	return s
}

// NewDvrStorageConfig creates a new DvrStorageConfig instance
func NewDvrStorageConfig() DvrStorageConfig {
	return &DvrStorageConfigImpl{}
}

// The number of disks to write the archive.
func (s DvrStorageConfigImpl) Active() *int {
	return s.ActiveValue
}

// The number of disks to write the archive.
func (s *DvrStorageConfigImpl) SetActive(v int) DvrStorageConfig {
	if s == nil {
		return nil
	}
	s.ActiveValue = &v
	return s
}

// RAID disks mounted on the server.
func (s DvrStorageConfigImpl) Disks() []RaidDiskConfig {
	if s.DisksValue == nil {
		return nil
	}
	result := make([]RaidDiskConfig, len(s.DisksValue))
	for i, item := range s.DisksValue {
		result[i] = item
	}
	return result
}

// RAID disks mounted on the server.
func (s *DvrStorageConfigImpl) SetDisks(v []RaidDiskConfig) DvrStorageConfig {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*RaidDiskConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*RaidDiskConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.DisksValue = impl
	}
	return s
}

// A directory on an SSD disk where the data will be cached.
// Format: disk_path (disk_path)
func (s DvrStorageConfigImpl) Index() *DiskPath {
	return s.IndexValue
}

// A directory on an SSD disk where the data will be cached.
// Format: disk_path (disk_path)
func (s *DvrStorageConfigImpl) SetIndex(v DiskPath) DvrStorageConfig {
	if s == nil {
		return nil
	}
	s.IndexValue = &v
	return s
}

// DVR configuration name.
// Format: dvr_name (dvr_name)
func (s DvrStorageConfigImpl) Name() DvrName {
	return s.NameValue
}

// DVR configuration name.
// Format: dvr_name (dvr_name)
func (s *DvrStorageConfigImpl) SetName(v DvrName) DvrStorageConfig {
	if s == nil {
		return nil
	}
	s.NameValue = v
	return s
}

// This value is present if RAID (redundant array of independent disks) is enabled. Learn more in [Flussonic RAID for DVR](https://flussonic.com/doc/extend-video-storage-on-fly/).
func (s DvrStorageConfigImpl) Raid() *DvrRaidLevel {
	return s.RaidValue
}

// This value is present if RAID (redundant array of independent disks) is enabled. Learn more in [Flussonic RAID for DVR](https://flussonic.com/doc/extend-video-storage-on-fly/).
func (s *DvrStorageConfigImpl) SetRaid(v DvrRaidLevel) DvrStorageConfig {
	if s == nil {
		return nil
	}
	s.RaidValue = &v
	return s
}

// A path where the DVR archive is stored.
// Format: dvr_url (dvr_url)
func (s DvrStorageConfigImpl) Root() DvrURL {
	return s.RootValue
}

// A path where the DVR archive is stored.
// Format: dvr_url (dvr_url)
func (s *DvrStorageConfigImpl) SetRoot(v DvrURL) DvrStorageConfig {
	if s == nil {
		return nil
	}
	s.RootValue = v
	return s
}

// The runtime statistics about DVR.
func (s DvrStorageConfigImpl) Stats() DvrStorageConfigStats {
	return s.StatsValue
}

// The runtime statistics about DVR.
func (s *DvrStorageConfigImpl) SetStats(v DvrStorageConfigStats) DvrStorageConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*DvrStorageConfigStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// NewDvrStorageConfigStats creates a new DvrStorageConfigStats instance
func NewDvrStorageConfigStats() DvrStorageConfigStats {
	return &DvrStorageConfigStatsImpl{}
}

// The number of blobs on the disk that are enlisted in individual stream indexes.
// It must be equal to blobs_count_db and can be different in case of software
// or hardware errors.
func (s DvrStorageConfigStatsImpl) BlobsCount() *int {
	return s.BlobsCountValue
}

// The number of blobs on the disk that are enlisted in individual stream indexes.
// It must be equal to blobs_count_db and can be different in case of software
// or hardware errors.
func (s *DvrStorageConfigStatsImpl) SetBlobsCount(v int) DvrStorageConfigStats {
	if s == nil {
		return nil
	}
	s.BlobsCountValue = &v
	return s
}

// The number of blobs on the disk according to centralized Raid DB that is
// used to allocate blobs across whole storage.
func (s DvrStorageConfigStatsImpl) BlobsCountDb() *int {
	return s.BlobsCountDbValue
}

// The number of blobs on the disk according to centralized Raid DB that is
// used to allocate blobs across whole storage.
func (s *DvrStorageConfigStatsImpl) SetBlobsCountDb(v int) DvrStorageConfigStats {
	if s == nil {
		return nil
	}
	s.BlobsCountDbValue = &v
	return s
}

// The runtime DVR errors.
func (s DvrStorageConfigStatsImpl) Errors() DvrStorageErrors {
	return s.ErrorsValue
}

// The runtime DVR errors.
func (s *DvrStorageConfigStatsImpl) SetErrors(v DvrStorageErrors) DvrStorageConfigStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*DvrStorageErrorsImpl); ok {
		s.ErrorsValue = impl
	}
	return s
}

// Disk capacity in bytes.
// Format: bytes (bytes)
func (s DvrStorageConfigStatsImpl) Size() *Bytes {
	return s.SizeValue
}

// Disk capacity in bytes.
// Format: bytes (bytes)
func (s *DvrStorageConfigStatsImpl) SetSize(v Bytes) DvrStorageConfigStats {
	if s == nil {
		return nil
	}
	s.SizeValue = &v
	return s
}

// Disk utilization percentage.
// Format: percent (percent)
func (s DvrStorageConfigStatsImpl) Usage() *Percent {
	return s.UsageValue
}

// Disk utilization percentage.
// Format: percent (percent)
func (s *DvrStorageConfigStatsImpl) SetUsage(v Percent) DvrStorageConfigStats {
	if s == nil {
		return nil
	}
	s.UsageValue = &v
	return s
}

// Used disk space in bytes according to linux metrics. It must be equal (almost equal) to
// `used_index`. If it differs more than in 1%, then it means that there are lot of unknown files.
// If this disk is used exclusively for Raid, then it may mean that some blobs are lost from
// database and repairing is required.
// Format: bytes (bytes)
func (s DvrStorageConfigStatsImpl) Used() *Bytes {
	return s.UsedValue
}

// Used disk space in bytes according to linux metrics. It must be equal (almost equal) to
// `used_index`. If it differs more than in 1%, then it means that there are lot of unknown files.
// If this disk is used exclusively for Raid, then it may mean that some blobs are lost from
// database and repairing is required.
// Format: bytes (bytes)
func (s *DvrStorageConfigStatsImpl) SetUsed(v Bytes) DvrStorageConfigStats {
	if s == nil {
		return nil
	}
	s.UsedValue = &v
	return s
}

// Used disk space in bytes according to internal database index.
// Format: bytes (bytes)
func (s DvrStorageConfigStatsImpl) UsedIndex() *Bytes {
	return s.UsedIndexValue
}

// Used disk space in bytes according to internal database index.
// Format: bytes (bytes)
func (s *DvrStorageConfigStatsImpl) SetUsedIndex(v Bytes) DvrStorageConfigStats {
	if s == nil {
		return nil
	}
	s.UsedIndexValue = &v
	return s
}

// NewDvrStorageErrors creates a new DvrStorageErrors instance
func NewDvrStorageErrors() DvrStorageErrors {
	return &DvrStorageErrorsImpl{}
}

// Total number of collapsed segments while writing to the archive. Collapsed segments are pack of segments written together occur due to lack of storage performance.
func (s DvrStorageErrorsImpl) CollapsedWriteCount() *int {
	return s.CollapsedWriteCountValue
}

// Total number of collapsed segments while writing to the archive. Collapsed segments are pack of segments written together occur due to lack of storage performance.
func (s *DvrStorageErrorsImpl) SetCollapsedWriteCount(v int) DvrStorageErrors {
	if s == nil {
		return nil
	}
	s.CollapsedWriteCountValue = &v
	return s
}

// Total number of errors while deleting from the archive.
func (s DvrStorageErrorsImpl) DeleteErrors() *int {
	return s.DeleteErrorsValue
}

// Total number of errors while deleting from the archive.
func (s *DvrStorageErrorsImpl) SetDeleteErrors(v int) DvrStorageErrors {
	if s == nil {
		return nil
	}
	s.DeleteErrorsValue = &v
	return s
}

// Total number of dropped segments while writing to the archive.
func (s DvrStorageErrorsImpl) DropWriteCount() *int {
	return s.DropWriteCountValue
}

// Total number of dropped segments while writing to the archive.
func (s *DvrStorageErrorsImpl) SetDropWriteCount(v int) DvrStorageErrors {
	if s == nil {
		return nil
	}
	s.DropWriteCountValue = &v
	return s
}

// Total number of errors while reading the archive.
func (s DvrStorageErrorsImpl) ReadErrors() *int {
	return s.ReadErrorsValue
}

// Total number of errors while reading the archive.
func (s *DvrStorageErrorsImpl) SetReadErrors(v int) DvrStorageErrors {
	if s == nil {
		return nil
	}
	s.ReadErrorsValue = &v
	return s
}

// Total number of errors while writing to the archive.
func (s DvrStorageErrorsImpl) WriteErrors() *int {
	return s.WriteErrorsValue
}

// Total number of errors while writing to the archive.
func (s *DvrStorageErrorsImpl) SetWriteErrors(v int) DvrStorageErrors {
	if s == nil {
		return nil
	}
	s.WriteErrorsValue = &v
	return s
}

// NewDvrStorageStats creates a new DvrStorageStats instance
func NewDvrStorageStats() DvrStorageStats {
	return &DvrStorageStatsImpl{}
}

// The runtime DVR errors.
func (s DvrStorageStatsImpl) Errors() DvrStorageErrors {
	return s.ErrorsValue
}

// The runtime DVR errors.
func (s *DvrStorageStatsImpl) SetErrors(v DvrStorageErrors) DvrStorageStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*DvrStorageErrorsImpl); ok {
		s.ErrorsValue = impl
	}
	return s
}

// NewError creates a new Error instance
func NewError() Error {
	return &ErrorImpl{}
}

// an application-specific error code, expressed as a string value
func (s ErrorImpl) Code() *string {
	return s.CodeValue
}

// an application-specific error code, expressed as a string value
func (s *ErrorImpl) SetCode(v string) Error {
	if s == nil {
		return nil
	}
	s.CodeValue = &v
	return s
}

// a unique identifier for this particular occurrence of the problem
func (s ErrorImpl) ID() *string {
	return s.IDValue
}

// a unique identifier for this particular occurrence of the problem
func (s *ErrorImpl) SetID(v string) Error {
	if s == nil {
		return nil
	}
	s.IDValue = &v
	return s
}

// a meta object containing non-standard meta-information about the error.
func (s ErrorImpl) Meta() map[string]string {
	return s.MetaValue
}

// a meta object containing non-standard meta-information about the error.
func (s *ErrorImpl) SetMeta(v map[string]string) Error {
	if s == nil {
		return nil
	}
	s.MetaValue = v
	return s
}

// an object containing references to the source of the error
func (s ErrorImpl) Source() ErrorSource {
	return s.SourceValue
}

// an object containing references to the source of the error
func (s *ErrorImpl) SetSource(v ErrorSource) Error {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ErrorSourceImpl); ok {
		s.SourceValue = impl
	}
	return s
}

// the HTTP status code applicable to this problem, expressed as a string value
func (s ErrorImpl) Status() *string {
	return s.StatusValue
}

// the HTTP status code applicable to this problem, expressed as a string value
func (s *ErrorImpl) SetStatus(v string) Error {
	if s == nil {
		return nil
	}
	s.StatusValue = &v
	return s
}

// a short, human-readable summary of the problem that SHOULD NOT change from
// occurrence to occurrence of the problem, except for purposes of localization
func (s ErrorImpl) Title() *string {
	return s.TitleValue
}

// a short, human-readable summary of the problem that SHOULD NOT change from
// occurrence to occurrence of the problem, except for purposes of localization
func (s *ErrorImpl) SetTitle(v string) Error {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// NewErrorResponse creates a new ErrorResponse instance
func NewErrorResponse() ErrorResponse {
	return &ErrorResponseImpl{}
}

// List of structured errors
func (s ErrorResponseImpl) Errors() []Error {
	if s.ErrorsValue == nil {
		return nil
	}
	result := make([]Error, len(s.ErrorsValue))
	for i, item := range s.ErrorsValue {
		result[i] = item
	}
	return result
}

// List of structured errors
func (s *ErrorResponseImpl) SetErrors(v []Error) ErrorResponse {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*ErrorImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*ErrorImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.ErrorsValue = impl
	}
	return s
}

// NewErrorSource creates a new ErrorSource instance
func NewErrorSource() ErrorSource {
	return &ErrorSourceImpl{}
}

// a string indicating which URI query parameter caused the error.
func (s ErrorSourceImpl) Parameter() *string {
	return s.ParameterValue
}

// a string indicating which URI query parameter caused the error.
func (s *ErrorSourceImpl) SetParameter(v string) ErrorSource {
	if s == nil {
		return nil
	}
	s.ParameterValue = &v
	return s
}

// a JSON Pointer [RFC6901] to the associated entity in the request document
// [e.g. `"/data"` for a primary data object, or `"/data/attributes/title"` for a specific attribute].
func (s ErrorSourceImpl) Pointer() *string {
	return s.PointerValue
}

// a JSON Pointer [RFC6901] to the associated entity in the request document
// [e.g. `"/data"` for a primary data object, or `"/data/attributes/title"` for a specific attribute].
func (s *ErrorSourceImpl) SetPointer(v string) ErrorSource {
	if s == nil {
		return nil
	}
	s.PointerValue = &v
	return s
}

// NewEvent creates a new Event instance
func NewEvent() Event {
	return &EventImpl{}
}

// Creation date and time
// Format: date_time (date_time)
// Example: 2021-01-30T08:30:00.432567Z
func (s EventImpl) CreatedAt() *DateTime {
	return s.CreatedAtValue
}

// Creation date and time
// Format: date_time (date_time)
// Example: 2021-01-30T08:30:00.432567Z
func (s *EventImpl) SetCreatedAt(v DateTime) Event {
	if s == nil {
		return nil
	}
	s.CreatedAtValue = &v
	return s
}

// Microseconds that this request took
// Format: microseconds (microseconds)
func (s EventImpl) Duration() *Microseconds {
	return s.DurationValue
}

// Microseconds that this request took
// Format: microseconds (microseconds)
func (s *EventImpl) SetDuration(v Microseconds) Event {
	if s == nil {
		return nil
	}
	s.DurationValue = &v
	return s
}

// The api call.
func (s EventImpl) Event() string {
	return s.EventValue
}

// The api call.
func (s *EventImpl) SetEvent(v string) Event {
	if s == nil {
		return nil
	}
	s.EventValue = v
	return s
}

// Event identifier.
func (s EventImpl) EventID() *int {
	return s.EventIDValue
}

// Event identifier.
func (s *EventImpl) SetEventID(v int) Event {
	if s == nil {
		return nil
	}
	s.EventIDValue = &v
	return s
}

// IP address of the caller.
// Format: ip (ip)
// Example: 192.34.32.10
func (s EventImpl) IP() *IP {
	return s.IPValue
}

// IP address of the caller.
// Format: ip (ip)
// Example: 192.34.32.10
func (s *EventImpl) SetIP(v IP) Event {
	if s == nil {
		return nil
	}
	s.IPValue = &v
	return s
}

// API method ID.
// Example: streams_list
func (s EventImpl) OperationID() *string {
	return s.OperationIDValue
}

// API method ID.
// Example: streams_list
func (s *EventImpl) SetOperationID(v string) Event {
	if s == nil {
		return nil
	}
	s.OperationIDValue = &v
	return s
}

// The program produced the API call. Content of `X-Originator` header.
// Example: flussonic
func (s EventImpl) Originator() *string {
	return s.OriginatorValue
}

// The program produced the API call. Content of `X-Originator` header.
// Example: flussonic
func (s *EventImpl) SetOriginator(v string) Event {
	if s == nil {
		return nil
	}
	s.OriginatorValue = &v
	return s
}

// The api call path.
func (s EventImpl) Path() *string {
	return s.PathValue
}

// The api call path.
func (s *EventImpl) SetPath(v string) Event {
	if s == nil {
		return nil
	}
	s.PathValue = &v
	return s
}

// Payload data transmitter in the API call.
func (s EventImpl) Payload() *string {
	return s.PayloadValue
}

// Payload data transmitter in the API call.
func (s *EventImpl) SetPayload(v string) Event {
	if s == nil {
		return nil
	}
	s.PayloadValue = &v
	return s
}

// The api call query string.
func (s EventImpl) Qs() *string {
	return s.QsValue
}

// The api call query string.
func (s *EventImpl) SetQs(v string) Event {
	if s == nil {
		return nil
	}
	s.QsValue = &v
	return s
}

// Internal request-id for this operation
func (s EventImpl) RequestID() *string {
	return s.RequestIDValue
}

// Internal request-id for this operation
func (s *EventImpl) SetRequestID(v string) Event {
	if s == nil {
		return nil
	}
	s.RequestIDValue = &v
	return s
}

// Originator of event.
// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
// is configured as HTTP/HTTPS url.
// Example: flussonic.host
func (s EventImpl) Server() *string {
	return s.ServerValue
}

// Originator of event.
// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
// is configured as HTTP/HTTPS url.
// Example: flussonic.host
func (s *EventImpl) SetServer(v string) Event {
	if s == nil {
		return nil
	}
	s.ServerValue = &v
	return s
}

// Request status code.
func (s EventImpl) Status() *int {
	return s.StatusValue
}

// Request status code.
func (s *EventImpl) SetStatus(v int) Event {
	if s == nil {
		return nil
	}
	s.StatusValue = &v
	return s
}

// Unique identifier of the operation.
// You can use this field to search for events related to same operation.
// Value of this field is taken from the `X-Trace-Id` header.
// If `X-Trace-Id` header is not set, it will be generated automatically.
// Service will use the value of this field to make outgoing requests.
// Format: uuid (uuid)
// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
func (s EventImpl) TraceID() *UUID {
	return s.TraceIDValue
}

// Unique identifier of the operation.
// You can use this field to search for events related to same operation.
// Value of this field is taken from the `X-Trace-Id` header.
// If `X-Trace-Id` header is not set, it will be generated automatically.
// Service will use the value of this field to make outgoing requests.
// Format: uuid (uuid)
// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
func (s *EventImpl) SetTraceID(v UUID) Event {
	if s == nil {
		return nil
	}
	s.TraceIDValue = &v
	return s
}

// The type of the device from which the API call was produced.
// Example: Flussonic 24.04
func (s EventImpl) UserAgent() *string {
	return s.UserAgentValue
}

// The type of the device from which the API call was produced.
// Example: Flussonic 24.04
func (s *EventImpl) SetUserAgent(v string) Event {
	if s == nil {
		return nil
	}
	s.UserAgentValue = &v
	return s
}

// The time of the event registration on the server.
// Format: utc_ms (Unix timestamp in milliseconds)
func (s EventImpl) UtcMs() *UtcMs {
	return s.UtcMsValue
}

// The time of the event registration on the server.
// Format: utc_ms (Unix timestamp in milliseconds)
func (s *EventImpl) SetUtcMs(v UtcMs) Event {
	if s == nil {
		return nil
	}
	s.UtcMsValue = &v
	return s
}

// NewEventDefault creates a new EventDefault instance
func NewEventDefault() EventDefault {
	return &EventDefaultImpl{}
}

// Event identifier.
func (s EventDefaultImpl) EventID() *int {
	return s.EventIDValue
}

// Event identifier.
func (s *EventDefaultImpl) SetEventID(v int) EventDefault {
	if s == nil {
		return nil
	}
	s.EventIDValue = &v
	return s
}

// Originator of event.
// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
// is configured as HTTP/HTTPS url.
// Example: flussonic.host
func (s EventDefaultImpl) Server() *string {
	return s.ServerValue
}

// Originator of event.
// This field is present if [event_sink.url](https://flussonic.com/doc/api/reference/#tag/events/operation/event_sink_get/response%7Curl)
// is configured as HTTP/HTTPS url.
// Example: flussonic.host
func (s *EventDefaultImpl) SetServer(v string) EventDefault {
	if s == nil {
		return nil
	}
	s.ServerValue = &v
	return s
}

// Unique identifier of the operation.
// You can use this field to search for events related to same operation.
// Value of this field is taken from the `X-Trace-Id` header.
// If `X-Trace-Id` header is not set, it will be generated automatically.
// Service will use the value of this field to make outgoing requests.
// Format: uuid (uuid)
// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
func (s EventDefaultImpl) TraceID() *UUID {
	return s.TraceIDValue
}

// Unique identifier of the operation.
// You can use this field to search for events related to same operation.
// Value of this field is taken from the `X-Trace-Id` header.
// If `X-Trace-Id` header is not set, it will be generated automatically.
// Service will use the value of this field to make outgoing requests.
// Format: uuid (uuid)
// Example: 05cec7ee-fbd0-11ed-be56-0242ac120002
func (s *EventDefaultImpl) SetTraceID(v UUID) EventDefault {
	if s == nil {
		return nil
	}
	s.TraceIDValue = &v
	return s
}

// The time of the event registration on the server.
// Format: utc_ms (Unix timestamp in milliseconds)
func (s EventDefaultImpl) UtcMs() *UtcMs {
	return s.UtcMsValue
}

// The time of the event registration on the server.
// Format: utc_ms (Unix timestamp in milliseconds)
func (s *EventDefaultImpl) SetUtcMs(v UtcMs) EventDefault {
	if s == nil {
		return nil
	}
	s.UtcMsValue = &v
	return s
}

// NewEventSinkConfig creates a new EventSinkConfig instance
func NewEventSinkConfig() EventSinkConfig {
	return &EventSinkConfigImpl{}
}

// If specified, only the events that match **every** filter in the filter set will not be be passed to the event sink target.
// That is, if even one of the conditions is not satisfied, an event will be processed.
// Each filter (condition) has several possible values. For an event to satisfy the condition,
// an event should match **any** of the specified values, not all of them.
// Examples: [map[event:[stream_stopped, stream_started, source_*]]]
func (s EventSinkConfigImpl) Except() []map[string][]string {
	return s.ExceptValue
}

// If specified, only the events that match **every** filter in the filter set will not be be passed to the event sink target.
// That is, if even one of the conditions is not satisfied, an event will be processed.
// Each filter (condition) has several possible values. For an event to satisfy the condition,
// an event should match **any** of the specified values, not all of them.
// Examples: [map[event:[stream_stopped, stream_started, source_*]]]
func (s *EventSinkConfigImpl) SetExcept(v []map[string][]string) EventSinkConfig {
	if s == nil {
		return nil
	}
	s.ExceptValue = v
	return s
}

// Some additional options.
func (s EventSinkConfigImpl) Extra() map[string]string {
	return s.ExtraValue
}

// Some additional options.
func (s *EventSinkConfigImpl) SetExtra(v map[string]string) EventSinkConfig {
	if s == nil {
		return nil
	}
	s.ExtraValue = v
	return s
}

// Specify logging level for this sink. Anything more verbose than it will not get into this sink.
func (s EventSinkConfigImpl) Level() *Loglevel {
	return s.LevelValue
}

// Specify logging level for this sink. Anything more verbose than it will not get into this sink.
func (s *EventSinkConfigImpl) SetLevel(v Loglevel) EventSinkConfig {
	if s == nil {
		return nil
	}
	s.LevelValue = &v
	return s
}

// Maximal number of log files with events (JSON or text) that can be stored on a disk.
// When this limit is reached, log rotation is performed: the oldest files will be overridden by later data.
// Example: 100
func (s EventSinkConfigImpl) MaxDepth() *int {
	return s.MaxDepthValue
}

// Maximal number of log files with events (JSON or text) that can be stored on a disk.
// When this limit is reached, log rotation is performed: the oldest files will be overridden by later data.
// Example: 100
func (s *EventSinkConfigImpl) SetMaxDepth(v int) EventSinkConfig {
	if s == nil {
		return nil
	}
	s.MaxDepthValue = &v
	return s
}

// Maximum size of a log file.
// When this limit is reached, log rotation is performed: the oldest events will be overridden by later data.
// Format: bytes (bytes)
// Example: 10000
func (s EventSinkConfigImpl) MaxSize() *Bytes {
	return s.MaxSizeValue
}

// Maximum size of a log file.
// When this limit is reached, log rotation is performed: the oldest events will be overridden by later data.
// Format: bytes (bytes)
// Example: 10000
func (s *EventSinkConfigImpl) SetMaxSize(v Bytes) EventSinkConfig {
	if s == nil {
		return nil
	}
	s.MaxSizeValue = &v
	return s
}

// Globally unique event sink name.
// Format: event_sink_name (event_sink_name)
// Example: my_json_sink
func (s EventSinkConfigImpl) Name() EventSinkName {
	return s.NameValue
}

// Globally unique event sink name.
// Format: event_sink_name (event_sink_name)
// Example: my_json_sink
func (s *EventSinkConfigImpl) SetName(v EventSinkName) EventSinkConfig {
	if s == nil {
		return nil
	}
	s.NameValue = v
	return s
}

// If specified, only the events that match **every** filter in the filter set will be passed to the event sink target.
// That is, if even one of the conditions is not satisfied, an event will **not** be processed.
// Each filter (condition) has several possible values. For an event to satisfy the condition,
// an event should match **any** of the specified values, not all of them.
// Examples: [map[event:[listener_start], group:[system_overloaded]]]
func (s EventSinkConfigImpl) Only() []map[string][]string {
	return s.OnlyValue
}

// If specified, only the events that match **every** filter in the filter set will be passed to the event sink target.
// That is, if even one of the conditions is not satisfied, an event will **not** be processed.
// Each filter (condition) has several possible values. For an event to satisfy the condition,
// an event should match **any** of the specified values, not all of them.
// Examples: [map[event:[listener_start], group:[system_overloaded]]]
func (s *EventSinkConfigImpl) SetOnly(v []map[string][]string) EventSinkConfig {
	if s == nil {
		return nil
	}
	s.OnlyValue = v
	return s
}

// If an error occurs (`HTTP 500` or any other error), then *Flussonic* will try to buffer events and send them later.
// The option defines the **number** of events to keep in memory for further delivery.
// The default value is `unlimited`.
// Example: 1000
func (s EventSinkConfigImpl) ResendLimit() *int {
	return s.ResendLimitValue
}

// If an error occurs (`HTTP 500` or any other error), then *Flussonic* will try to buffer events and send them later.
// The option defines the **number** of events to keep in memory for further delivery.
// The default value is `unlimited`.
// Example: 1000
func (s *EventSinkConfigImpl) SetResendLimit(v int) EventSinkConfig {
	if s == nil {
		return nil
	}
	s.ResendLimitValue = &v
	return s
}

// How often *Flussonic* will try to resend non-confirmed events to the handler (in seconds).
// Example: 10
func (s EventSinkConfigImpl) ResendTimeout() *int {
	return s.ResendTimeoutValue
}

// How often *Flussonic* will try to resend non-confirmed events to the handler (in seconds).
// Example: 10
func (s *EventSinkConfigImpl) SetResendTimeout(v int) EventSinkConfig {
	if s == nil {
		return nil
	}
	s.ResendTimeoutValue = &v
	return s
}

// The delay (in seconds) before sending an event to the sink after saving it into the buffer.
// This parameter allows to lower frequency of sending events.
// If there are more than 100 events in the buffer, all of them will be sent to the sink without any delay.
// Format: seconds (seconds)
// Example: 1
func (s EventSinkConfigImpl) ThrottleDelay() *Seconds {
	return s.ThrottleDelayValue
}

// The delay (in seconds) before sending an event to the sink after saving it into the buffer.
// This parameter allows to lower frequency of sending events.
// If there are more than 100 events in the buffer, all of them will be sent to the sink without any delay.
// Format: seconds (seconds)
// Example: 1
func (s *EventSinkConfigImpl) SetThrottleDelay(v Seconds) EventSinkConfig {
	if s == nil {
		return nil
	}
	s.ThrottleDelayValue = &v
	return s
}

// Path where events are sent.
// * For event handler, it is the URL of an HTTP handler or the path to a lua script:  `http://URL`, `https://URL`, or `path_to_lua_script.lua`.
// * For event logging, it is the path to a log file (human-readable text file or JSON): `log://path_to_log_file.log` or `jsonlog://path_to_log_file.json`.
// Pattern: ^(log|jsonlog|http|https)://.+$|^pid://<[0-9]+\.[0-9]+\.[0-9]+>$
// Example: jsonlog:///var/log/events-json.log
func (s EventSinkConfigImpl) URL() string {
	return s.URLValue
}

// Path where events are sent.
// * For event handler, it is the URL of an HTTP handler or the path to a lua script:  `http://URL`, `https://URL`, or `path_to_lua_script.lua`.
// * For event logging, it is the path to a log file (human-readable text file or JSON): `log://path_to_log_file.log` or `jsonlog://path_to_log_file.json`.
// Pattern: ^(log|jsonlog|http|https)://.+$|^pid://<[0-9]+\.[0-9]+\.[0-9]+>$
// Example: jsonlog:///var/log/events-json.log
func (s *EventSinkConfigImpl) SetURL(v string) EventSinkConfig {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// NewEventsList creates a new EventsList instance
func NewEventsList() EventsList {
	return &EventsListImpl{}
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s EventsListImpl) EstimatedCount() *int {
	return s.EstimatedCountValue
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s *EventsListImpl) SetEstimatedCount(v int) EventsList {
	if s == nil {
		return nil
	}
	s.EstimatedCountValue = &v
	return s
}

// List of events
func (s EventsListImpl) Events() []Event {
	if s.EventsValue == nil {
		return nil
	}
	result := make([]Event, len(s.EventsValue))
	for i, item := range s.EventsValue {
		result[i] = item
	}
	return result
}

// List of events
func (s *EventsListImpl) SetEvents(v []Event) EventsList {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*EventImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*EventImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.EventsValue = impl
	}
	return s
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s EventsListImpl) Next() *string {
	return s.NextValue
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s *EventsListImpl) SetNext(v string) EventsList {
	if s == nil {
		return nil
	}
	s.NextValue = &v
	return s
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s EventsListImpl) Prev() *string {
	return s.PrevValue
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s *EventsListImpl) SetPrev(v string) EventsList {
	if s == nil {
		return nil
	}
	s.PrevValue = &v
	return s
}

// An object with a list of different timings measured during this API call.
func (s EventsListImpl) Timing() any {
	return s.TimingValue
}

// An object with a list of different timings measured during this API call.
func (s *EventsListImpl) SetTiming(v any) EventsList {
	if s == nil {
		return nil
	}
	s.TimingValue = v
	return s
}

// Collection returns the collection items from EventsList
func (s EventsListImpl) Collection() []Event {
	return s.Events()
}

// NewFileProcessorConfig creates a new FileProcessorConfig instance
func NewFileProcessorConfig() FileProcessorConfig {
	return &FileProcessorConfigImpl{}
}

// The directory where Flussonic puts output files.
// Format: disk_path (disk_path)
func (s FileProcessorConfigImpl) Path() *DiskPath {
	return s.PathValue
}

// The directory where Flussonic puts output files.
// Format: disk_path (disk_path)
func (s *FileProcessorConfigImpl) SetPath(v DiskPath) FileProcessorConfig {
	if s == nil {
		return nil
	}
	s.PathValue = &v
	return s
}

// NewFirmwareUpdate creates a new FirmwareUpdate instance
func NewFirmwareUpdate() FirmwareUpdate {
	return &FirmwareUpdateImpl{}
}

// Image for updating camera. Documentation for updating cameras: https://flussonic.com/doc/flussonic-home-v1/#upgrade.
// Format: binary (binary)
// Example: b'DL'
func (s FirmwareUpdateImpl) Image() any {
	return s.ImageValue
}

// Image for updating camera. Documentation for updating cameras: https://flussonic.com/doc/flussonic-home-v1/#upgrade.
// Format: binary (binary)
// Example: b'DL'
func (s *FirmwareUpdateImpl) SetImage(v any) FirmwareUpdate {
	if s == nil {
		return nil
	}
	s.ImageValue = v
	return s
}

// Protocol for connecting to camera.
// Example: iris
func (s FirmwareUpdateImpl) Proto() *FirmwareUpdateProto {
	return s.ProtoValue
}

// Protocol for connecting to camera.
// Example: iris
func (s *FirmwareUpdateImpl) SetProto(v FirmwareUpdateProto) FirmwareUpdate {
	if s == nil {
		return nil
	}
	s.ProtoValue = &v
	return s
}

// NewForwardPortsConfig creates a new ForwardPortsConfig instance
func NewForwardPortsConfig() ForwardPortsConfig {
	return &ForwardPortsConfigImpl{}
}

// The handler name.
func (s ForwardPortsConfigImpl) Handler() *string {
	return s.HandlerValue
}

// The handler name.
func (s *ForwardPortsConfigImpl) SetHandler(v string) ForwardPortsConfig {
	if s == nil {
		return nil
	}
	s.HandlerValue = &v
	return s
}

// The handler options.
func (s ForwardPortsConfigImpl) Options() any {
	return s.OptionsValue
}

// The handler options.
func (s *ForwardPortsConfigImpl) SetOptions(v any) ForwardPortsConfig {
	if s == nil {
		return nil
	}
	s.OptionsValue = v
	return s
}

// NewGenrefStatus creates a new GenrefStatus instance
func NewGenrefStatus() GenrefStatus {
	return &GenrefStatusImpl{}
}

// If true genref port is a physical port, else genref port is a virtual port (internal clock-lock feature).
func (s GenrefStatusImpl) External() *bool {
	return s.ExternalValue
}

// If true genref port is a physical port, else genref port is a virtual port (internal clock-lock feature).
func (s *GenrefStatusImpl) SetExternal(v bool) GenrefStatus {
	if s == nil {
		return nil
	}
	s.ExternalValue = &v
	return s
}

// Detected genref input port number.
func (s GenrefStatusImpl) Port() *int {
	return s.PortValue
}

// Detected genref input port number.
func (s *GenrefStatusImpl) SetPort(v int) GenrefStatus {
	if s == nil {
		return nil
	}
	s.PortValue = &v
	return s
}

// Configured reference signal video standard.
func (s GenrefStatusImpl) Vstd() *string {
	return s.VstdValue
}

// Configured reference signal video standard.
func (s *GenrefStatusImpl) SetVstd(v string) GenrefStatus {
	if s == nil {
		return nil
	}
	s.VstdValue = &v
	return s
}

// Detected (actual) reference signal video standard.
func (s GenrefStatusImpl) VstdDetected() *string {
	return s.VstdDetectedValue
}

// Detected (actual) reference signal video standard.
func (s *GenrefStatusImpl) SetVstdDetected(v string) GenrefStatus {
	if s == nil {
		return nil
	}
	s.VstdDetectedValue = &v
	return s
}

// NewH26xDecoderCounters creates a new H26xDecoderCounters instance
func NewH26xDecoderCounters() H26xDecoderCounters {
	return &H26xDecoderCountersImpl{}
}

// Number of NAL units, which `forbidden_zero_bit` is set to one.
func (s H26xDecoderCountersImpl) DiscardedBrokenNalCount() *int {
	return s.DiscardedBrokenNalCountValue
}

// Number of NAL units, which `forbidden_zero_bit` is set to one.
func (s *H26xDecoderCountersImpl) SetDiscardedBrokenNalCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.DiscardedBrokenNalCountValue = &v
	return s
}

// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
// This counter shows number of discarded `Fragmentation Units`
func (s H26xDecoderCountersImpl) DiscardedFuCount() *int {
	return s.DiscardedFuCountValue
}

// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
// This counter shows number of discarded `Fragmentation Units`
func (s *H26xDecoderCountersImpl) SetDiscardedFuCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.DiscardedFuCountValue = &v
	return s
}

// Number of discarded NAL units.
func (s H26xDecoderCountersImpl) DiscardedNalCount() *int {
	return s.DiscardedNalCountValue
}

// Number of discarded NAL units.
func (s *H26xDecoderCountersImpl) SetDiscardedNalCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.DiscardedNalCountValue = &v
	return s
}

// Number of NAL units, which type is not allowed in `non-interleaved packetization mode`.
func (s H26xDecoderCountersImpl) DiscardedNotAllowedNalCount() *int {
	return s.DiscardedNotAllowedNalCountValue
}

// Number of NAL units, which type is not allowed in `non-interleaved packetization mode`.
func (s *H26xDecoderCountersImpl) SetDiscardedNotAllowedNalCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.DiscardedNotAllowedNalCountValue = &v
	return s
}

// Number of discarded `SEI` NAL units
func (s H26xDecoderCountersImpl) DiscardedSeiCount() *int {
	return s.DiscardedSeiCountValue
}

// Number of discarded `SEI` NAL units
func (s *H26xDecoderCountersImpl) SetDiscardedSeiCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.DiscardedSeiCountValue = &v
	return s
}

// There is workaround to not interrupt `FU` sequence if `end-FU` followed by `middle-FU`.
// This counter shows how many time the workaround was applied.
func (s H26xDecoderCountersImpl) FuEndThenMiddleWorkaroundCount() *int {
	return s.FuEndThenMiddleWorkaroundCountValue
}

// There is workaround to not interrupt `FU` sequence if `end-FU` followed by `middle-FU`.
// This counter shows how many time the workaround was applied.
func (s *H26xDecoderCountersImpl) SetFuEndThenMiddleWorkaroundCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.FuEndThenMiddleWorkaroundCountValue = &v
	return s
}

// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
// This counter shows number of `Fragmentation Units` which `Start bit` and `End bit` are set to one in the same `FU` header
func (s H26xDecoderCountersImpl) FuHasBothStartEndBitsCount() *int {
	return s.FuHasBothStartEndBitsCountValue
}

// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
// This counter shows number of `Fragmentation Units` which `Start bit` and `End bit` are set to one in the same `FU` header
func (s *H26xDecoderCountersImpl) SetFuHasBothStartEndBitsCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.FuHasBothStartEndBitsCountValue = &v
	return s
}

// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
// `Fragmentation Units` pattern must have a `Start FU`, `End FU` and could have `FUs` between these ones.
// This counter indicates how many times pattern was broken.
func (s H26xDecoderCountersImpl) FuPatternIsBrokenCount() *int {
	return s.FuPatternIsBrokenCountValue
}

// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
// `Fragmentation Units` pattern must have a `Start FU`, `End FU` and could have `FUs` between these ones.
// This counter indicates how many times pattern was broken.
func (s *H26xDecoderCountersImpl) SetFuPatternIsBrokenCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.FuPatternIsBrokenCountValue = &v
	return s
}

// NAL deframentation could be interrupted by unexpected NAL or broken/incomplete packet.
// If NAL deframentation is interrupted then incomplete fragment of NAL is not discarded and used in decoding process.
// This counter indicates how many incomplete NALs were used.
func (s H26xDecoderCountersImpl) IncompleteNalCount() *int {
	return s.IncompleteNalCountValue
}

// NAL deframentation could be interrupted by unexpected NAL or broken/incomplete packet.
// If NAL deframentation is interrupted then incomplete fragment of NAL is not discarded and used in decoding process.
// This counter indicates how many incomplete NALs were used.
func (s *H26xDecoderCountersImpl) SetIncompleteNalCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.IncompleteNalCountValue = &v
	return s
}

// Number of `SEI` NAL units with bad payload
func (s H26xDecoderCountersImpl) InvalidSeiPayloadCount() *int {
	return s.InvalidSeiPayloadCountValue
}

// Number of `SEI` NAL units with bad payload
func (s *H26xDecoderCountersImpl) SetInvalidSeiPayloadCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.InvalidSeiPayloadCountValue = &v
	return s
}

// Number of `SEI` NAL units with invalid size
func (s H26xDecoderCountersImpl) InvalidSeiSizeCount() *int {
	return s.InvalidSeiSizeCountValue
}

// Number of `SEI` NAL units with invalid size
func (s *H26xDecoderCountersImpl) SetInvalidSeiSizeCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.InvalidSeiSizeCountValue = &v
	return s
}

// Number of `SEI` NAL units with invalid type
func (s H26xDecoderCountersImpl) InvalidSeiTypeCount() *int {
	return s.InvalidSeiTypeCountValue
}

// Number of `SEI` NAL units with invalid type
func (s *H26xDecoderCountersImpl) SetInvalidSeiTypeCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.InvalidSeiTypeCountValue = &v
	return s
}

// How many NAL `AGGREGATION` units handled by this decoder.
func (s H26xDecoderCountersImpl) NalAggregationCount() *int {
	return s.NalAggregationCountValue
}

// How many NAL `AGGREGATION` units handled by this decoder.
func (s *H26xDecoderCountersImpl) SetNalAggregationCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.NalAggregationCountValue = &v
	return s
}

// How many NAL `AUD` units handled by this decoder.
func (s H26xDecoderCountersImpl) NalAudCount() *int {
	return s.NalAudCountValue
}

// How many NAL `AUD` units handled by this decoder.
func (s *H26xDecoderCountersImpl) SetNalAudCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.NalAudCountValue = &v
	return s
}

// How many NAL units handled by this decoder.
func (s H26xDecoderCountersImpl) NalCount() *int {
	return s.NalCountValue
}

// How many NAL units handled by this decoder.
func (s *H26xDecoderCountersImpl) SetNalCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.NalCountValue = &v
	return s
}

// How many NAL `FILLER` units handled by this decoder.
func (s H26xDecoderCountersImpl) NalFillerCount() *int {
	return s.NalFillerCountValue
}

// How many NAL `FILLER` units handled by this decoder.
func (s *H26xDecoderCountersImpl) SetNalFillerCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.NalFillerCountValue = &v
	return s
}

// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
// This counter shows how many `Fragmentation Units` handled by this decoder.
func (s H26xDecoderCountersImpl) NalFuCount() *int {
	return s.NalFuCountValue
}

// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
// This counter shows how many `Fragmentation Units` handled by this decoder.
func (s *H26xDecoderCountersImpl) SetNalFuCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.NalFuCountValue = &v
	return s
}

// How many NAL `IDR` units handled by this decoder.
func (s H26xDecoderCountersImpl) NalIdrCount() *int {
	return s.NalIdrCountValue
}

// How many NAL `IDR` units handled by this decoder.
func (s *H26xDecoderCountersImpl) SetNalIdrCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.NalIdrCountValue = &v
	return s
}

// How many other NAL units handled by this decoder.
func (s H26xDecoderCountersImpl) NalOtherCount() *int {
	return s.NalOtherCountValue
}

// How many other NAL units handled by this decoder.
func (s *H26xDecoderCountersImpl) SetNalOtherCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.NalOtherCountValue = &v
	return s
}

// How many NAL `PPS` units handled by this decoder.
func (s H26xDecoderCountersImpl) NalPpsCount() *int {
	return s.NalPpsCountValue
}

// How many NAL `PPS` units handled by this decoder.
func (s *H26xDecoderCountersImpl) SetNalPpsCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.NalPpsCountValue = &v
	return s
}

// How many NAL `SEI` units handled by this decoder.
func (s H26xDecoderCountersImpl) NalSeiCount() *int {
	return s.NalSeiCountValue
}

// How many NAL `SEI` units handled by this decoder.
func (s *H26xDecoderCountersImpl) SetNalSeiCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.NalSeiCountValue = &v
	return s
}

// How many NAL `SINGLE` units handled by this decoder.
func (s H26xDecoderCountersImpl) NalSingleCount() *int {
	return s.NalSingleCountValue
}

// How many NAL `SINGLE` units handled by this decoder.
func (s *H26xDecoderCountersImpl) SetNalSingleCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.NalSingleCountValue = &v
	return s
}

// How many NAL `SLICE` units handled by this decoder.
func (s H26xDecoderCountersImpl) NalSliceCount() *int {
	return s.NalSliceCountValue
}

// How many NAL `SLICE` units handled by this decoder.
func (s *H26xDecoderCountersImpl) SetNalSliceCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.NalSliceCountValue = &v
	return s
}

// How many NAL `SPS` units handled by this decoder.
func (s H26xDecoderCountersImpl) NalSpsCount() *int {
	return s.NalSpsCountValue
}

// How many NAL `SPS` units handled by this decoder.
func (s *H26xDecoderCountersImpl) SetNalSpsCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.NalSpsCountValue = &v
	return s
}

// How many NAL `STAP_A` units handled by this decoder.
func (s H26xDecoderCountersImpl) NalStapACount() *int {
	return s.NalStapACountValue
}

// How many NAL `STAP_A` units handled by this decoder.
func (s *H26xDecoderCountersImpl) SetNalStapACount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.NalStapACountValue = &v
	return s
}

// How many NAL `VPS` units handled by this decoder.
func (s H26xDecoderCountersImpl) NalVpsCount() *int {
	return s.NalVpsCountValue
}

// How many NAL `VPS` units handled by this decoder.
func (s *H26xDecoderCountersImpl) SetNalVpsCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.NalVpsCountValue = &v
	return s
}

// NewHTTPProxyConfig creates a new HTTPProxyConfig instance
func NewHTTPProxyConfig() HTTPProxyConfig {
	return &HTTPProxyConfigImpl{}
}

// If this flag is set, then streamer will redirect from "/" to this proxy configuration.
func (s HTTPProxyConfigImpl) Mainpage() *bool {
	return s.MainpageValue
}

// If this flag is set, then streamer will redirect from "/" to this proxy configuration.
func (s *HTTPProxyConfigImpl) SetMainpage(v bool) HTTPProxyConfig {
	if s == nil {
		return nil
	}
	s.MainpageValue = &v
	return s
}

// HTTP prefix that will be intercepted by this http proxy configuration
// Format: media_name (media_name)
func (s HTTPProxyConfigImpl) Prefix() MediaName {
	return s.PrefixValue
}

// HTTP prefix that will be intercepted by this http proxy configuration
// Format: media_name (media_name)
func (s *HTTPProxyConfigImpl) SetPrefix(v MediaName) HTTPProxyConfig {
	if s == nil {
		return nil
	}
	s.PrefixValue = v
	return s
}

// The runtime statistics about http proxy
func (s HTTPProxyConfigImpl) Stats() HTTPProxyStats {
	return s.StatsValue
}

// The runtime statistics about http proxy
func (s *HTTPProxyConfigImpl) SetStats(v HTTPProxyStats) HTTPProxyConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*HTTPProxyStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// Upstream url
// Format: url (url)
func (s HTTPProxyConfigImpl) URL() URL {
	return s.URLValue
}

// Upstream url
// Format: url (url)
func (s *HTTPProxyConfigImpl) SetURL(v URL) HTTPProxyConfig {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// NewHTTPProxyStats creates a new HTTPProxyStats instance
func NewHTTPProxyStats() HTTPProxyStats {
	return &HTTPProxyStatsImpl{}
}

// Number of requests with HTTP code 1xx (e.g. protocol upgrades)
// Example: 1000
func (s HTTPProxyStatsImpl) HTTP100() *int {
	return s.HTTP100Value
}

// Number of requests with HTTP code 1xx (e.g. protocol upgrades)
// Example: 1000
func (s *HTTPProxyStatsImpl) SetHTTP100(v int) HTTPProxyStats {
	if s == nil {
		return nil
	}
	s.HTTP100Value = &v
	return s
}

// Number of requests with HTTP code 2xx
// Example: 1000
func (s HTTPProxyStatsImpl) HTTP200() *int {
	return s.HTTP200Value
}

// Number of requests with HTTP code 2xx
// Example: 1000
func (s *HTTPProxyStatsImpl) SetHTTP200(v int) HTTPProxyStats {
	if s == nil {
		return nil
	}
	s.HTTP200Value = &v
	return s
}

// Number of requests with HTTP code 3xx
// Example: 10
func (s HTTPProxyStatsImpl) HTTP300() *int {
	return s.HTTP300Value
}

// Number of requests with HTTP code 3xx
// Example: 10
func (s *HTTPProxyStatsImpl) SetHTTP300(v int) HTTPProxyStats {
	if s == nil {
		return nil
	}
	s.HTTP300Value = &v
	return s
}

// Number of requests with HTTP code 4xx
// Example: 10
func (s HTTPProxyStatsImpl) HTTP400() *int {
	return s.HTTP400Value
}

// Number of requests with HTTP code 4xx
// Example: 10
func (s *HTTPProxyStatsImpl) SetHTTP400(v int) HTTPProxyStats {
	if s == nil {
		return nil
	}
	s.HTTP400Value = &v
	return s
}

// Number of requests with HTTP code 5xx
// Example: 10
func (s HTTPProxyStatsImpl) HTTP500() *int {
	return s.HTTP500Value
}

// Number of requests with HTTP code 5xx
// Example: 10
func (s *HTTPProxyStatsImpl) SetHTTP500(v int) HTTPProxyStats {
	if s == nil {
		return nil
	}
	s.HTTP500Value = &v
	return s
}

// Total number of requests with protocol upgrade (e.g. websocket)
// Example: 1000
func (s HTTPProxyStatsImpl) ProtocolUpgrades() *int {
	return s.ProtocolUpgradesValue
}

// Total number of requests with protocol upgrade (e.g. websocket)
// Example: 1000
func (s *HTTPProxyStatsImpl) SetProtocolUpgrades(v int) HTTPProxyStats {
	if s == nil {
		return nil
	}
	s.ProtocolUpgradesValue = &v
	return s
}

// Number of requests with error on proxy itself
// Example: 10
func (s HTTPProxyStatsImpl) ProxyError() *int {
	return s.ProxyErrorValue
}

// Number of requests with error on proxy itself
// Example: 10
func (s *HTTPProxyStatsImpl) SetProxyError(v int) HTTPProxyStats {
	if s == nil {
		return nil
	}
	s.ProxyErrorValue = &v
	return s
}

// Number of requests with connection errors - econnrefused, etc
// Example: 10
func (s HTTPProxyStatsImpl) ProxyErrorConnection() *int {
	return s.ProxyErrorConnectionValue
}

// Number of requests with connection errors - econnrefused, etc
// Example: 10
func (s *HTTPProxyStatsImpl) SetProxyErrorConnection(v int) HTTPProxyStats {
	if s == nil {
		return nil
	}
	s.ProxyErrorConnectionValue = &v
	return s
}

// Total number of requests this prefix received
// Example: 1000
func (s HTTPProxyStatsImpl) Requests() *int {
	return s.RequestsValue
}

// Total number of requests this prefix received
// Example: 1000
func (s *HTTPProxyStatsImpl) SetRequests(v int) HTTPProxyStats {
	if s == nil {
		return nil
	}
	s.RequestsValue = &v
	return s
}

// Number of API calls that took more than 500ms and less than 1s
// Example: 2
func (s HTTPProxyStatsImpl) Time1000Ms() *int {
	return s.Time1000MsValue
}

// Number of API calls that took more than 500ms and less than 1s
// Example: 2
func (s *HTTPProxyStatsImpl) SetTime1000Ms(v int) HTTPProxyStats {
	if s == nil {
		return nil
	}
	s.Time1000MsValue = &v
	return s
}

// Number of API calls that took less than 100ms
// Example: 10
func (s HTTPProxyStatsImpl) Time100Ms() *int {
	return s.Time100MsValue
}

// Number of API calls that took less than 100ms
// Example: 10
func (s *HTTPProxyStatsImpl) SetTime100Ms(v int) HTTPProxyStats {
	if s == nil {
		return nil
	}
	s.Time100MsValue = &v
	return s
}

// Number of API calls that took more than 1s and less than 5s
// Example: 2
func (s HTTPProxyStatsImpl) Time5000Ms() *int {
	return s.Time5000MsValue
}

// Number of API calls that took more than 1s and less than 5s
// Example: 2
func (s *HTTPProxyStatsImpl) SetTime5000Ms(v int) HTTPProxyStats {
	if s == nil {
		return nil
	}
	s.Time5000MsValue = &v
	return s
}

// Number of API calls that took more than 100ms and less than 500ms
// Example: 5
func (s HTTPProxyStatsImpl) Time500Ms() *int {
	return s.Time500MsValue
}

// Number of API calls that took more than 100ms and less than 500ms
// Example: 5
func (s *HTTPProxyStatsImpl) SetTime500Ms(v int) HTTPProxyStats {
	if s == nil {
		return nil
	}
	s.Time500MsValue = &v
	return s
}

// Number of API calls that took more than 5s
// Example: 1
func (s HTTPProxyStatsImpl) TimeLongms() *int {
	return s.TimeLongmsValue
}

// Number of API calls that took more than 5s
// Example: 1
func (s *HTTPProxyStatsImpl) SetTimeLongms(v int) HTTPProxyStats {
	if s == nil {
		return nil
	}
	s.TimeLongmsValue = &v
	return s
}

// NewInputAgentCounters creates a new InputAgentCounters instance
func NewInputAgentCounters() InputAgentCounters {
	return &InputAgentCountersImpl{}
}

// These errors indicate that the agent does not have enough buffer size to handle outgoing traffic.
func (s InputAgentCountersImpl) ErrorsBufferOverrun() *int {
	return s.ErrorsBufferOverrunValue
}

// These errors indicate that the agent does not have enough buffer size to handle outgoing traffic.
func (s *InputAgentCountersImpl) SetErrorsBufferOverrun(v int) InputAgentCounters {
	if s == nil {
		return nil
	}
	s.ErrorsBufferOverrunValue = &v
	return s
}

// The agent was unable to open the requested connection. These errors may indicate problems opening the TCP socket on the agent or the remote host is unreacheable.
func (s InputAgentCountersImpl) ErrorsConnFailed() *int {
	return s.ErrorsConnFailedValue
}

// The agent was unable to open the requested connection. These errors may indicate problems opening the TCP socket on the agent or the remote host is unreacheable.
func (s *InputAgentCountersImpl) SetErrorsConnFailed(v int) InputAgentCounters {
	if s == nil {
		return nil
	}
	s.ErrorsConnFailedValue = &v
	return s
}

// These errors indicate that the agent is receiving invalid requests.
func (s InputAgentCountersImpl) ErrorsInvalidRequest() *int {
	return s.ErrorsInvalidRequestValue
}

// These errors indicate that the agent is receiving invalid requests.
func (s *InputAgentCountersImpl) SetErrorsInvalidRequest(v int) InputAgentCounters {
	if s == nil {
		return nil
	}
	s.ErrorsInvalidRequestValue = &v
	return s
}

// These errors indicate that the agent does not have enough memory to establish a connection to the remote host.
func (s InputAgentCountersImpl) ErrorsOutOfMemory() *int {
	return s.ErrorsOutOfMemoryValue
}

// These errors indicate that the agent does not have enough memory to establish a connection to the remote host.
func (s *InputAgentCountersImpl) SetErrorsOutOfMemory(v int) InputAgentCounters {
	if s == nil {
		return nil
	}
	s.ErrorsOutOfMemoryValue = &v
	return s
}

// Unknown errors counter.
func (s InputAgentCountersImpl) ErrorsUnknown() *int {
	return s.ErrorsUnknownValue
}

// Unknown errors counter.
func (s *InputAgentCountersImpl) SetErrorsUnknown(v int) InputAgentCounters {
	if s == nil {
		return nil
	}
	s.ErrorsUnknownValue = &v
	return s
}

// NewInputCounters creates a new InputCounters instance
func NewInputCounters() InputCounters {
	return &InputCountersImpl{}
}

// How many Ad markers passed to this stream from the inputs.
func (s InputCountersImpl) AdSplicesIngested() *int {
	return s.AdSplicesIngestedValue
}

// How many Ad markers passed to this stream from the inputs.
func (s *InputCountersImpl) SetAdSplicesIngested(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.AdSplicesIngestedValue = &v
	return s
}

// How many Ad markers inserted to this stream by user.
func (s InputCountersImpl) AdSplicesInserted() *int {
	return s.AdSplicesInsertedValue
}

// How many Ad markers inserted to this stream by user.
func (s *InputCountersImpl) SetAdSplicesInserted(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.AdSplicesInsertedValue = &v
	return s
}

func (s InputCountersImpl) Agent() InputAgentCounters {
	return s.AgentValue
}

func (s *InputCountersImpl) SetAgent(v InputAgentCounters) InputCounters {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputAgentCountersImpl); ok {
		s.AgentValue = impl
	}
	return s
}

// Number of bytes received by this stream from live sources.
// It will be counted before transcoding and will sum all inputs working together.
// Format: bytes (bytes)
func (s InputCountersImpl) Bytes() *Bytes {
	return s.BytesValue
}

// Number of bytes received by this stream from live sources.
// It will be counted before transcoding and will sum all inputs working together.
// Format: bytes (bytes)
func (s *InputCountersImpl) SetBytes(v Bytes) InputCounters {
	if s == nil {
		return nil
	}
	s.BytesValue = &v
	return s
}

// Number of bytes received by this stream when downloading from remote DVR.
// Format: bytes (bytes)
func (s InputCountersImpl) BytesDvr() *Bytes {
	return s.BytesDvrValue
}

// Number of bytes received by this stream when downloading from remote DVR.
// Format: bytes (bytes)
func (s *InputCountersImpl) SetBytesDvr(v Bytes) InputCounters {
	if s == nil {
		return nil
	}
	s.BytesDvrValue = &v
	return s
}

// Sum of all other specific errors in the last minute
// Example: 0
func (s InputCountersImpl) ErrorRate() *int {
	return s.ErrorRateValue
}

// Sum of all other specific errors in the last minute
// Example: 0
func (s *InputCountersImpl) SetErrorRate(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.ErrorRateValue = &v
	return s
}

// Sum of all other specific errors. Can be used for triggering alert on any error
// Example: 0
func (s InputCountersImpl) Errors() *int {
	return s.ErrorsValue
}

// Sum of all other specific errors. Can be used for triggering alert on any error
// Example: 0
func (s *InputCountersImpl) SetErrors(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.ErrorsValue = &v
	return s
}

// How many times we've got 403 (eaccess).
func (s InputCountersImpl) Errors403() *int {
	return s.Errors403Value
}

// How many times we've got 403 (eaccess).
func (s *InputCountersImpl) SetErrors403(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.Errors403Value = &v
	return s
}

// How many times we've got 404 (enoent).
func (s InputCountersImpl) Errors404() *int {
	return s.Errors404Value
}

// How many times we've got 404 (enoent).
func (s *InputCountersImpl) SetErrors404(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.Errors404Value = &v
	return s
}

// How many times we've got 500 (backend error).
func (s InputCountersImpl) Errors500() *int {
	return s.Errors500Value
}

// How many times we've got 500 (backend error).
func (s *InputCountersImpl) SetErrors500(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.Errors500Value = &v
	return s
}

// Demultiplexing was done right, but content is broken.
func (s InputCountersImpl) ErrorsBrokenPayload() *int {
	return s.ErrorsBrokenPayloadValue
}

// Demultiplexing was done right, but content is broken.
func (s *InputCountersImpl) SetErrorsBrokenPayload(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.ErrorsBrokenPayloadValue = &v
	return s
}

// How many times input was restarted due to internal crash.
// This may happen due to unhandled input.
func (s InputCountersImpl) ErrorsCrashed() *int {
	return s.ErrorsCrashedValue
}

// How many times input was restarted due to internal crash.
// This may happen due to unhandled input.
func (s *InputCountersImpl) SetErrorsCrashed(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.ErrorsCrashedValue = &v
	return s
}

// Decoder reset count due to abnormal DTS change. Can happen in MPEG-TS, RTP.
func (s InputCountersImpl) ErrorsDecoderReset() *int {
	return s.ErrorsDecoderResetValue
}

// Decoder reset count due to abnormal DTS change. Can happen in MPEG-TS, RTP.
func (s *InputCountersImpl) SetErrorsDecoderReset(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.ErrorsDecoderResetValue = &v
	return s
}

// This can be used as a `TS_sync_loss` - how many times MPEG-TS sync was lost.
// Also this counter refers to RTSP desync, when camera starts dropping TCP data and
// we have to find packet boundaries.
// Here we write count of such resynchronizations.
func (s InputCountersImpl) ErrorsDesync() *int {
	return s.ErrorsDesyncValue
}

// This can be used as a `TS_sync_loss` - how many times MPEG-TS sync was lost.
// Also this counter refers to RTSP desync, when camera starts dropping TCP data and
// we have to find packet boundaries.
// Here we write count of such resynchronizations.
func (s *InputCountersImpl) SetErrorsDesync(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.ErrorsDesyncValue = &v
	return s
}

// Dropped frames count due timestamp adjustment.
func (s InputCountersImpl) ErrorsDroppedFrames() *int {
	return s.ErrorsDroppedFramesValue
}

// Dropped frames count due timestamp adjustment.
func (s *InputCountersImpl) SetErrorsDroppedFrames(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.ErrorsDroppedFramesValue = &v
	return s
}

// RTP, MPEG-TS or other protocols have enough information to tell how many packets were lost
func (s InputCountersImpl) ErrorsLostPackets() *int {
	return s.ErrorsLostPacketsValue
}

// RTP, MPEG-TS or other protocols have enough information to tell how many packets were lost
func (s *InputCountersImpl) SetErrorsLostPackets(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.ErrorsLostPacketsValue = &v
	return s
}

// how many times PAT was missing during 0,5 seconds or pid 0 misses PAT
// `PAT_error`
func (s InputCountersImpl) ErrorsTSPat() *int {
	return s.ErrorsTSPatValue
}

// how many times PAT was missing during 0,5 seconds or pid 0 misses PAT
// `PAT_error`
func (s *InputCountersImpl) SetErrorsTSPat(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.ErrorsTSPatValue = &v
	return s
}

// How many times have received PAT that was missing required service (program)
func (s InputCountersImpl) ErrorsTSServiceLost() *int {
	return s.ErrorsTSServiceLostValue
}

// How many times have received PAT that was missing required service (program)
func (s *InputCountersImpl) SetErrorsTSServiceLost(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.ErrorsTSServiceLostValue = &v
	return s
}

// Number of connection restarts to fix ts_stuck issue. Can happen in RTSP.
func (s InputCountersImpl) ErrorsTSStuckRestarts() *int {
	return s.ErrorsTSStuckRestartsValue
}

// Number of connection restarts to fix ts_stuck issue. Can happen in RTSP.
func (s *InputCountersImpl) SetErrorsTSStuckRestarts(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.ErrorsTSStuckRestartsValue = &v
	return s
}

// Number of frames passed to this stream from the inputs.
func (s InputCountersImpl) Frames() *int {
	return s.FramesValue
}

// Number of frames passed to this stream from the inputs.
func (s *InputCountersImpl) SetFrames(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.FramesValue = &v
	return s
}

// Aggregated: how many times this stream has switched between different inputs.
// Individual input: number of times switched to this input.
func (s InputCountersImpl) InputSwitches() *int {
	return s.InputSwitchesValue
}

// Aggregated: how many times this stream has switched between different inputs.
// Individual input: number of times switched to this input.
func (s *InputCountersImpl) SetInputSwitches(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.InputSwitchesValue = &v
	return s
}

// Number of secondary inputs that have some problems.
// Example: 0
func (s InputCountersImpl) InvalidSecondaryInputs() *int {
	return s.InvalidSecondaryInputsValue
}

// Number of secondary inputs that have some problems.
// Example: 0
func (s *InputCountersImpl) SetInvalidSecondaryInputs(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.InvalidSecondaryInputsValue = &v
	return s
}

// Indicates, how often does media_info changes
func (s InputCountersImpl) MediaInfoChanges() *int {
	return s.MediaInfoChangesValue
}

// Indicates, how often does media_info changes
func (s *InputCountersImpl) SetMediaInfoChanges(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.MediaInfoChangesValue = &v
	return s
}

func (s InputCountersImpl) MotionDetector() InputMotionDetectorCounters {
	return s.MotionDetectorValue
}

func (s *InputCountersImpl) SetMotionDetector(v InputMotionDetectorCounters) InputCounters {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputMotionDetectorCountersImpl); ok {
		s.MotionDetectorValue = impl
	}
	return s
}

// How many seconds has this stream had no frames.
// Format: seconds (seconds)
func (s InputCountersImpl) NumSecNoData() *Seconds {
	return s.NumSecNoDataValue
}

// How many seconds has this stream had no frames.
// Format: seconds (seconds)
func (s *InputCountersImpl) SetNumSecNoData(v Seconds) InputCounters {
	if s == nil {
		return nil
	}
	s.NumSecNoDataValue = &v
	return s
}

// How many seconds has this stream played from primary input.
// Format: seconds (seconds)
func (s InputCountersImpl) NumSecOnPrimaryInput() *Seconds {
	return s.NumSecOnPrimaryInputValue
}

// How many seconds has this stream played from primary input.
// Format: seconds (seconds)
func (s *InputCountersImpl) SetNumSecOnPrimaryInput(v Seconds) InputCounters {
	if s == nil {
		return nil
	}
	s.NumSecOnPrimaryInputValue = &v
	return s
}

// How many seconds has this stream played from secondary inputs.
// Format: seconds (seconds)
func (s InputCountersImpl) NumSecOnSecondaryInput() *Seconds {
	return s.NumSecOnSecondaryInputValue
}

// How many seconds has this stream played from secondary inputs.
// Format: seconds (seconds)
func (s *InputCountersImpl) SetNumSecOnSecondaryInput(v Seconds) InputCounters {
	if s == nil {
		return nil
	}
	s.NumSecOnSecondaryInputValue = &v
	return s
}

// Per pid statistics calculated for MPEG-TS input
func (s InputCountersImpl) Pids() []InputPidCounters {
	if s.PidsValue == nil {
		return nil
	}
	result := make([]InputPidCounters, len(s.PidsValue))
	for i, item := range s.PidsValue {
		result[i] = item
	}
	return result
}

// Per pid statistics calculated for MPEG-TS input
func (s *InputCountersImpl) SetPids(v []InputPidCounters) InputCounters {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*InputPidCountersImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*InputPidCountersImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.PidsValue = impl
	}
	return s
}

// Source may send frames not in the order they should be played. It will be catched and reordered.
// This counter indicates how many times did it happened.
func (s InputCountersImpl) ReorderCount() *int {
	return s.ReorderCountValue
}

// Source may send frames not in the order they should be played. It will be catched and reordered.
// This counter indicates how many times did it happened.
func (s *InputCountersImpl) SetReorderCount(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.ReorderCountValue = &v
	return s
}

// Source may send frames timestamps faster or slower than realtime.
// Live stream will catch it and resync. This counter indicates how many times did it happened.
func (s InputCountersImpl) ResyncCountDrift() *int {
	return s.ResyncCountDriftValue
}

// Source may send frames timestamps faster or slower than realtime.
// Live stream will catch it and resync. This counter indicates how many times did it happened.
func (s *InputCountersImpl) SetResyncCountDrift(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.ResyncCountDriftValue = &v
	return s
}

// Source may change timestamps without any signalling. This counter indicates how bad is the source
func (s InputCountersImpl) ResyncCountJump() *int {
	return s.ResyncCountJumpValue
}

// Source may change timestamps without any signalling. This counter indicates how bad is the source
func (s *InputCountersImpl) SetResyncCountJump(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.ResyncCountJumpValue = &v
	return s
}

// Stream timestamps are synchronized with real time. This counter tells, how many times
// it was syncronized after source reconnect.
func (s InputCountersImpl) ResyncCountNormal() *int {
	return s.ResyncCountNormalValue
}

// Stream timestamps are synchronized with real time. This counter tells, how many times
// it was syncronized after source reconnect.
func (s *InputCountersImpl) SetResyncCountNormal(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.ResyncCountNormalValue = &v
	return s
}

// How many times has this stream retried to connect to source
func (s InputCountersImpl) Retries() *int {
	return s.RetriesValue
}

// How many times has this stream retried to connect to source
func (s *InputCountersImpl) SetRetries(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.RetriesValue = &v
	return s
}

// Per channel statistics calculated for RTP input
func (s InputCountersImpl) RTPChannels() []InputRTPCounters {
	if s.RTPChannelsValue == nil {
		return nil
	}
	result := make([]InputRTPCounters, len(s.RTPChannelsValue))
	for i, item := range s.RTPChannelsValue {
		result[i] = item
	}
	return result
}

// Per channel statistics calculated for RTP input
func (s *InputCountersImpl) SetRTPChannels(v []InputRTPCounters) InputCounters {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*InputRTPCountersImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*InputRTPCountersImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.RTPChannelsValue = impl
	}
	return s
}

func (s InputCountersImpl) Sdi() InputSdiCounters {
	return s.SdiValue
}

func (s *InputCountersImpl) SetSdi(v InputSdiCounters) InputCounters {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputSdiCountersImpl); ok {
		s.SdiValue = impl
	}
	return s
}

func (s InputCountersImpl) Srt() InputSrtCounters {
	return s.SrtValue
}

func (s *InputCountersImpl) SetSrt(v InputSrtCounters) InputCounters {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputSrtCountersImpl); ok {
		s.SrtValue = impl
	}
	return s
}

// Number of secondary inputs that have no problems.
// Example: 2
func (s InputCountersImpl) ValidSecondaryInputs() *int {
	return s.ValidSecondaryInputsValue
}

// Number of secondary inputs that have no problems.
// Example: 2
func (s *InputCountersImpl) SetValidSecondaryInputs(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.ValidSecondaryInputsValue = &v
	return s
}

// NewInputMotionDetectorCounters creates a new InputMotionDetectorCounters instance
func NewInputMotionDetectorCounters() InputMotionDetectorCounters {
	return &InputMotionDetectorCountersImpl{}
}

// Number of collected episodes.
func (s InputMotionDetectorCountersImpl) EpisodesCount() *int {
	return s.EpisodesCountValue
}

// Number of collected episodes.
func (s *InputMotionDetectorCountersImpl) SetEpisodesCount(v int) InputMotionDetectorCounters {
	if s == nil {
		return nil
	}
	s.EpisodesCountValue = &v
	return s
}

// Number of responses with broken content.
func (s InputMotionDetectorCountersImpl) ErrorsBrokenPayload() *int {
	return s.ErrorsBrokenPayloadValue
}

// Number of responses with broken content.
func (s *InputMotionDetectorCountersImpl) SetErrorsBrokenPayload(v int) InputMotionDetectorCounters {
	if s == nil {
		return nil
	}
	s.ErrorsBrokenPayloadValue = &v
	return s
}

// `ONVIF Event Handling Test Specification` says that valid values for `CurrentTime` and `TerminationTime` are
// `TerminationTime >= CurrentTime + InitialTerminationTime`.
// How many responses did not met the condition.
func (s InputMotionDetectorCountersImpl) ErrorsIncorrectTimeValuesCount() *int {
	return s.ErrorsIncorrectTimeValuesCountValue
}

// `ONVIF Event Handling Test Specification` says that valid values for `CurrentTime` and `TerminationTime` are
// `TerminationTime >= CurrentTime + InitialTerminationTime`.
// How many responses did not met the condition.
func (s *InputMotionDetectorCountersImpl) SetErrorsIncorrectTimeValuesCount(v int) InputMotionDetectorCounters {
	if s == nil {
		return nil
	}
	s.ErrorsIncorrectTimeValuesCountValue = &v
	return s
}

// Number of failed request attempts because of no agent connected.
func (s InputMotionDetectorCountersImpl) ErrorsNoAgentConnected() *int {
	return s.ErrorsNoAgentConnectedValue
}

// Number of failed request attempts because of no agent connected.
func (s *InputMotionDetectorCountersImpl) SetErrorsNoAgentConnected(v int) InputMotionDetectorCounters {
	if s == nil {
		return nil
	}
	s.ErrorsNoAgentConnectedValue = &v
	return s
}

// Number of attempts to request disabled or unsupported ONVIF service
func (s InputMotionDetectorCountersImpl) ErrorsNoServiceCount() *int {
	return s.ErrorsNoServiceCountValue
}

// Number of attempts to request disabled or unsupported ONVIF service
func (s *InputMotionDetectorCountersImpl) SetErrorsNoServiceCount(v int) InputMotionDetectorCounters {
	if s == nil {
		return nil
	}
	s.ErrorsNoServiceCountValue = &v
	return s
}

// Number of not authorized requests
func (s InputMotionDetectorCountersImpl) ErrorsNotAuthorizedCount() *int {
	return s.ErrorsNotAuthorizedCountValue
}

// Number of not authorized requests
func (s *InputMotionDetectorCountersImpl) SetErrorsNotAuthorizedCount(v int) InputMotionDetectorCounters {
	if s == nil {
		return nil
	}
	s.ErrorsNotAuthorizedCountValue = &v
	return s
}

// Number of failed requests because of bad url or network issues.
func (s InputMotionDetectorCountersImpl) ErrorsURLUnreachableCount() *int {
	return s.ErrorsURLUnreachableCountValue
}

// Number of failed requests because of bad url or network issues.
func (s *InputMotionDetectorCountersImpl) SetErrorsURLUnreachableCount(v int) InputMotionDetectorCounters {
	if s == nil {
		return nil
	}
	s.ErrorsURLUnreachableCountValue = &v
	return s
}

// Number of detected motions.
func (s InputMotionDetectorCountersImpl) MotionDetectedCount() *int {
	return s.MotionDetectedCountValue
}

// Number of detected motions.
func (s *InputMotionDetectorCountersImpl) SetMotionDetectedCount(v int) InputMotionDetectorCounters {
	if s == nil {
		return nil
	}
	s.MotionDetectedCountValue = &v
	return s
}

// NewInputPidCounters creates a new InputPidCounters instance
func NewInputPidCounters() InputPidCounters {
	return &InputPidCountersImpl{}
}

// How many PES packets were started not from startcode
func (s InputPidCountersImpl) BrokenPesCount() *int {
	return s.BrokenPesCountValue
}

// How many PES packets were started not from startcode
func (s *InputPidCountersImpl) SetBrokenPesCount(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.BrokenPesCountValue = &v
	return s
}

// How many bytes were discarded due to lack of PES startcode
func (s InputPidCountersImpl) BrokenPesSum() *int {
	return s.BrokenPesSumValue
}

// How many bytes were discarded due to lack of PES startcode
func (s *InputPidCountersImpl) SetBrokenPesSum(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.BrokenPesSumValue = &v
	return s
}

// How many times PTS was less than PCR or previous PTS
func (s InputPidCountersImpl) CorrectedBackwardPts() *int {
	return s.CorrectedBackwardPtsValue
}

// How many times PTS was less than PCR or previous PTS
func (s *InputPidCountersImpl) SetCorrectedBackwardPts(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.CorrectedBackwardPtsValue = &v
	return s
}

// Unhandled crashes inside mpegts decoding process due
func (s InputPidCountersImpl) Crashed() *int {
	return s.CrashedValue
}

// Unhandled crashes inside mpegts decoding process due
func (s *InputPidCountersImpl) SetCrashed(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.CrashedValue = &v
	return s
}

// How many times was discarded too big ES buffer without making a frame of it
func (s InputPidCountersImpl) DiscardedBufferCount() *int {
	return s.DiscardedBufferCountValue
}

// How many times was discarded too big ES buffer without making a frame of it
func (s *InputPidCountersImpl) SetDiscardedBufferCount(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.DiscardedBufferCountValue = &v
	return s
}

// How many bytes were lost due to discarding ES buffer
func (s InputPidCountersImpl) DiscardedBufferSum() *int {
	return s.DiscardedBufferSumValue
}

// How many bytes were lost due to discarding ES buffer
func (s *InputPidCountersImpl) SetDiscardedBufferSum(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.DiscardedBufferSumValue = &v
	return s
}

// Time on this PID jumped back from reference PTS and it was not a roll over zero
func (s InputPidCountersImpl) DtsGoesBackwards() *int {
	return s.DtsGoesBackwardsValue
}

// Time on this PID jumped back from reference PTS and it was not a roll over zero
func (s *InputPidCountersImpl) SetDtsGoesBackwards(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.DtsGoesBackwardsValue = &v
	return s
}

// Time on this PID jumped forward too far away from reference PTS
func (s InputPidCountersImpl) DtsJumpForward() *int {
	return s.DtsJumpForwardValue
}

// Time on this PID jumped forward too far away from reference PTS
func (s *InputPidCountersImpl) SetDtsJumpForward(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.DtsJumpForwardValue = &v
	return s
}

// Packets without payload and adaptation field
func (s InputPidCountersImpl) EmptyPackets() *int {
	return s.EmptyPacketsValue
}

// Packets without payload and adaptation field
func (s *InputPidCountersImpl) SetEmptyPackets(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.EmptyPacketsValue = &v
	return s
}

// Packets with adaptation field larger than packet size
func (s InputPidCountersImpl) ErrorsAdaptationBroken() *int {
	return s.ErrorsAdaptationBrokenValue
}

// Packets with adaptation field larger than packet size
func (s *InputPidCountersImpl) SetErrorsAdaptationBroken(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.ErrorsAdaptationBrokenValue = &v
	return s
}

// How many times pid has been lost
func (s InputPidCountersImpl) ErrorsPidLost() *int {
	return s.ErrorsPidLostValue
}

// How many times pid has been lost
func (s *InputPidCountersImpl) SetErrorsPidLost(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.ErrorsPidLostValue = &v
	return s
}

// how many MPEG-TS packets were received with non-contigious contiuity counters.
// `Continuity_count_error`
// Example: 0
func (s InputPidCountersImpl) ErrorsTSCc() *int {
	return s.ErrorsTSCcValue
}

// how many MPEG-TS packets were received with non-contigious contiuity counters.
// `Continuity_count_error`
// Example: 0
func (s *InputPidCountersImpl) SetErrorsTSCc(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.ErrorsTSCcValue = &v
	return s
}

// how many times PMT was not received after 0,5 seconds
// `PMT_error`
func (s InputPidCountersImpl) ErrorsTSPmt() *int {
	return s.ErrorsTSPmtValue
}

// how many times PMT was not received after 0,5 seconds
// `PMT_error`
func (s *InputPidCountersImpl) SetErrorsTSPmt(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.ErrorsTSPmtValue = &v
	return s
}

// How many times have received PSI entry with broken checksum
// `CRC_error`
func (s InputPidCountersImpl) ErrorsTSPsiChecksum() *int {
	return s.ErrorsTSPsiChecksumValue
}

// How many times have received PSI entry with broken checksum
// `CRC_error`
func (s *InputPidCountersImpl) SetErrorsTSPsiChecksum(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.ErrorsTSPsiChecksumValue = &v
	return s
}

// Amount of scrambled TS packets
func (s InputPidCountersImpl) ErrorsTSScrambled() *int {
	return s.ErrorsTSScrambledValue
}

// Amount of scrambled TS packets
func (s *InputPidCountersImpl) SetErrorsTSScrambled(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.ErrorsTSScrambledValue = &v
	return s
}

// How many MPEG-TS packets with Transport Error Indicator were received
// `Transport_error`, 2.1
func (s InputPidCountersImpl) ErrorsTSTei() *int {
	return s.ErrorsTSTeiValue
}

// How many MPEG-TS packets with Transport Error Indicator were received
// `Transport_error`, 2.1
func (s *InputPidCountersImpl) SetErrorsTSTei(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.ErrorsTSTeiValue = &v
	return s
}

// How many H264(5) NAL fillers were seen in the input
func (s InputPidCountersImpl) FillersCount() *int {
	return s.FillersCountValue
}

// How many H264(5) NAL fillers were seen in the input
func (s *InputPidCountersImpl) SetFillersCount(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.FillersCountValue = &v
	return s
}

// How many bytes were seen in NAL fillers
func (s InputPidCountersImpl) FillersSum() *int {
	return s.FillersSumValue
}

// How many bytes were seen in NAL fillers
func (s *InputPidCountersImpl) SetFillersSum(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.FillersSumValue = &v
	return s
}

// Frame count on this pid
func (s InputPidCountersImpl) Frames() *int {
	return s.FramesValue
}

// Frame count on this pid
func (s *InputPidCountersImpl) SetFrames(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.FramesValue = &v
	return s
}

// How many MPEG-TS packets with 188 bytes on this pid received
func (s InputPidCountersImpl) Packets() *int {
	return s.PacketsValue
}

// How many MPEG-TS packets with 188 bytes on this pid received
func (s *InputPidCountersImpl) SetPackets(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.PacketsValue = &v
	return s
}

// How many PES packets were on the Padding streamId
func (s InputPidCountersImpl) PaddingPesCount() *int {
	return s.PaddingPesCountValue
}

// How many PES packets were on the Padding streamId
func (s *InputPidCountersImpl) SetPaddingPesCount(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.PaddingPesCountValue = &v
	return s
}

// How many bytes were in PES packets on the Padding streamId
func (s InputPidCountersImpl) PaddingPesSum() *int {
	return s.PaddingPesSumValue
}

// How many bytes were in PES packets on the Padding streamId
func (s *InputPidCountersImpl) SetPaddingPesSum(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.PaddingPesSumValue = &v
	return s
}

// If PTS is drifting away from PCR, it can be resynchronized with PCR. This is a resync count
func (s InputPidCountersImpl) PcrResync() *int {
	return s.PcrResyncValue
}

// If PTS is drifting away from PCR, it can be resynchronized with PCR. This is a resync count
func (s *InputPidCountersImpl) SetPcrResync(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.PcrResyncValue = &v
	return s
}

// Related MPEG-TS pid with following problems
func (s InputPidCountersImpl) Pid() int {
	return s.PidValue
}

// Related MPEG-TS pid with following problems
func (s *InputPidCountersImpl) SetPid(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.PidValue = v
	return s
}

// What program does have this pid
func (s InputPidCountersImpl) Pnr() *int {
	return s.PnrValue
}

// What program does have this pid
func (s *InputPidCountersImpl) SetPnr(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.PnrValue = &v
	return s
}

// In case of CC error last frame can be repeated. This is a count of repeated frames
func (s InputPidCountersImpl) RepeatedFrames() *int {
	return s.RepeatedFramesValue
}

// In case of CC error last frame can be repeated. This is a count of repeated frames
func (s *InputPidCountersImpl) SetRepeatedFrames(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.RepeatedFramesValue = &v
	return s
}

// Jumps of timestamps inside a MPEG-TS stream
func (s InputPidCountersImpl) TimeCorrections() *int {
	return s.TimeCorrectionsValue
}

// Jumps of timestamps inside a MPEG-TS stream
func (s *InputPidCountersImpl) SetTimeCorrections(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.TimeCorrectionsValue = &v
	return s
}

// Jump of the PTS was so big from previous, that had to flush all frames and restart parsing
func (s InputPidCountersImpl) TooLargeDtsJump() *int {
	return s.TooLargeDtsJumpValue
}

// Jump of the PTS was so big from previous, that had to flush all frames and restart parsing
func (s *InputPidCountersImpl) SetTooLargeDtsJump(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.TooLargeDtsJumpValue = &v
	return s
}

// NewInputRTPCounters creates a new InputRTPCounters instance
func NewInputRTPCounters() InputRTPCounters {
	return &InputRTPCountersImpl{}
}

// How many bytes received for this channel
func (s InputRTPCountersImpl) Bytes() *int {
	return s.BytesValue
}

// How many bytes received for this channel
func (s *InputRTPCountersImpl) SetBytes(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.BytesValue = &v
	return s
}

// RTP channel number
// Example: 0
func (s InputRTPCountersImpl) ChannelID() int {
	return s.ChannelIDValue
}

// RTP channel number
// Example: 0
func (s *InputRTPCountersImpl) SetChannelID(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.ChannelIDValue = v
	return s
}

// Content of the track transmitted in the channel
// Example: video
func (s InputRTPCountersImpl) Content() *string {
	return s.ContentValue
}

// Content of the track transmitted in the channel
// Example: video
func (s *InputRTPCountersImpl) SetContent(v string) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.ContentValue = &v
	return s
}

// Number of NAL units, which `forbidden_zero_bit` is set to one.
func (s InputRTPCountersImpl) DiscardedBrokenNalCount() *int {
	return s.DiscardedBrokenNalCountValue
}

// Number of NAL units, which `forbidden_zero_bit` is set to one.
func (s *InputRTPCountersImpl) SetDiscardedBrokenNalCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.DiscardedBrokenNalCountValue = &v
	return s
}

// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
// This counter shows number of discarded `Fragmentation Units`
func (s InputRTPCountersImpl) DiscardedFuCount() *int {
	return s.DiscardedFuCountValue
}

// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
// This counter shows number of discarded `Fragmentation Units`
func (s *InputRTPCountersImpl) SetDiscardedFuCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.DiscardedFuCountValue = &v
	return s
}

// Number of discarded NAL units.
func (s InputRTPCountersImpl) DiscardedNalCount() *int {
	return s.DiscardedNalCountValue
}

// Number of discarded NAL units.
func (s *InputRTPCountersImpl) SetDiscardedNalCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.DiscardedNalCountValue = &v
	return s
}

// Number of NAL units, which type is not allowed in `non-interleaved packetization mode`.
func (s InputRTPCountersImpl) DiscardedNotAllowedNalCount() *int {
	return s.DiscardedNotAllowedNalCountValue
}

// Number of NAL units, which type is not allowed in `non-interleaved packetization mode`.
func (s *InputRTPCountersImpl) SetDiscardedNotAllowedNalCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.DiscardedNotAllowedNalCountValue = &v
	return s
}

// Number of discarded `SEI` NAL units
func (s InputRTPCountersImpl) DiscardedSeiCount() *int {
	return s.DiscardedSeiCountValue
}

// Number of discarded `SEI` NAL units
func (s *InputRTPCountersImpl) SetDiscardedSeiCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.DiscardedSeiCountValue = &v
	return s
}

// Demultiplexing was done right, but content is broken.
func (s InputRTPCountersImpl) ErrorsBrokenPayload() *int {
	return s.ErrorsBrokenPayloadValue
}

// Demultiplexing was done right, but content is broken.
func (s *InputRTPCountersImpl) SetErrorsBrokenPayload(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.ErrorsBrokenPayloadValue = &v
	return s
}

// Number of frames which dts is same as previous frame dts.
func (s InputRTPCountersImpl) ErrorsDtsStuck() *int {
	return s.ErrorsDtsStuckValue
}

// Number of frames which dts is same as previous frame dts.
func (s *InputRTPCountersImpl) SetErrorsDtsStuck(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.ErrorsDtsStuckValue = &v
	return s
}

// RTP have enough information to tell how many packets were lost
func (s InputRTPCountersImpl) ErrorsLostPackets() *int {
	return s.ErrorsLostPacketsValue
}

// RTP have enough information to tell how many packets were lost
func (s *InputRTPCountersImpl) SetErrorsLostPackets(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.ErrorsLostPacketsValue = &v
	return s
}

// How many frames received for this channel
func (s InputRTPCountersImpl) Frames() *int {
	return s.FramesValue
}

// How many frames received for this channel
func (s *InputRTPCountersImpl) SetFrames(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.FramesValue = &v
	return s
}

// There is workaround to not interrupt `FU` sequence if `end-FU` followed by `middle-FU`.
// This counter shows how many time the workaround was applied.
func (s InputRTPCountersImpl) FuEndThenMiddleWorkaroundCount() *int {
	return s.FuEndThenMiddleWorkaroundCountValue
}

// There is workaround to not interrupt `FU` sequence if `end-FU` followed by `middle-FU`.
// This counter shows how many time the workaround was applied.
func (s *InputRTPCountersImpl) SetFuEndThenMiddleWorkaroundCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.FuEndThenMiddleWorkaroundCountValue = &v
	return s
}

// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
// This counter shows number of `Fragmentation Units` which `Start bit` and `End bit` are set to one in the same `FU` header
func (s InputRTPCountersImpl) FuHasBothStartEndBitsCount() *int {
	return s.FuHasBothStartEndBitsCountValue
}

// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
// This counter shows number of `Fragmentation Units` which `Start bit` and `End bit` are set to one in the same `FU` header
func (s *InputRTPCountersImpl) SetFuHasBothStartEndBitsCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.FuHasBothStartEndBitsCountValue = &v
	return s
}

// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
// `Fragmentation Units` pattern must have a `Start FU`, `End FU` and could have `FUs` between these ones.
// This counter indicates how many times pattern was broken.
func (s InputRTPCountersImpl) FuPatternIsBrokenCount() *int {
	return s.FuPatternIsBrokenCountValue
}

// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
// `Fragmentation Units` pattern must have a `Start FU`, `End FU` and could have `FUs` between these ones.
// This counter indicates how many times pattern was broken.
func (s *InputRTPCountersImpl) SetFuPatternIsBrokenCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.FuPatternIsBrokenCountValue = &v
	return s
}

// NAL deframentation could be interrupted by unexpected NAL or broken/incomplete packet.
// If NAL deframentation is interrupted then incomplete fragment of NAL is not discarded and used in decoding process.
// This counter indicates how many incomplete NALs were used.
func (s InputRTPCountersImpl) IncompleteNalCount() *int {
	return s.IncompleteNalCountValue
}

// NAL deframentation could be interrupted by unexpected NAL or broken/incomplete packet.
// If NAL deframentation is interrupted then incomplete fragment of NAL is not discarded and used in decoding process.
// This counter indicates how many incomplete NALs were used.
func (s *InputRTPCountersImpl) SetIncompleteNalCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.IncompleteNalCountValue = &v
	return s
}

// Number of `SEI` NAL units with bad payload
func (s InputRTPCountersImpl) InvalidSeiPayloadCount() *int {
	return s.InvalidSeiPayloadCountValue
}

// Number of `SEI` NAL units with bad payload
func (s *InputRTPCountersImpl) SetInvalidSeiPayloadCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.InvalidSeiPayloadCountValue = &v
	return s
}

// Number of `SEI` NAL units with invalid size
func (s InputRTPCountersImpl) InvalidSeiSizeCount() *int {
	return s.InvalidSeiSizeCountValue
}

// Number of `SEI` NAL units with invalid size
func (s *InputRTPCountersImpl) SetInvalidSeiSizeCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.InvalidSeiSizeCountValue = &v
	return s
}

// Number of `SEI` NAL units with invalid type
func (s InputRTPCountersImpl) InvalidSeiTypeCount() *int {
	return s.InvalidSeiTypeCountValue
}

// Number of `SEI` NAL units with invalid type
func (s *InputRTPCountersImpl) SetInvalidSeiTypeCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.InvalidSeiTypeCountValue = &v
	return s
}

// Number of RTP packets which marker bit is set to one.
func (s InputRTPCountersImpl) MarkerPacketsCount() *int {
	return s.MarkerPacketsCountValue
}

// Number of RTP packets which marker bit is set to one.
func (s *InputRTPCountersImpl) SetMarkerPacketsCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.MarkerPacketsCountValue = &v
	return s
}

// How many NACK messages are sent for this channel
func (s InputRTPCountersImpl) NackCount() *int {
	return s.NackCountValue
}

// How many NACK messages are sent for this channel
func (s *InputRTPCountersImpl) SetNackCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.NackCountValue = &v
	return s
}

// How many NAL `AGGREGATION` units handled by this decoder.
func (s InputRTPCountersImpl) NalAggregationCount() *int {
	return s.NalAggregationCountValue
}

// How many NAL `AGGREGATION` units handled by this decoder.
func (s *InputRTPCountersImpl) SetNalAggregationCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.NalAggregationCountValue = &v
	return s
}

// How many NAL `AUD` units handled by this decoder.
func (s InputRTPCountersImpl) NalAudCount() *int {
	return s.NalAudCountValue
}

// How many NAL `AUD` units handled by this decoder.
func (s *InputRTPCountersImpl) SetNalAudCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.NalAudCountValue = &v
	return s
}

// How many NAL units handled by this decoder.
func (s InputRTPCountersImpl) NalCount() *int {
	return s.NalCountValue
}

// How many NAL units handled by this decoder.
func (s *InputRTPCountersImpl) SetNalCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.NalCountValue = &v
	return s
}

// How many NAL `FILLER` units handled by this decoder.
func (s InputRTPCountersImpl) NalFillerCount() *int {
	return s.NalFillerCountValue
}

// How many NAL `FILLER` units handled by this decoder.
func (s *InputRTPCountersImpl) SetNalFillerCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.NalFillerCountValue = &v
	return s
}

// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
// This counter shows how many `Fragmentation Units` handled by this decoder.
func (s InputRTPCountersImpl) NalFuCount() *int {
	return s.NalFuCountValue
}

// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
// This counter shows how many `Fragmentation Units` handled by this decoder.
func (s *InputRTPCountersImpl) SetNalFuCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.NalFuCountValue = &v
	return s
}

// How many NAL `IDR` units handled by this decoder.
func (s InputRTPCountersImpl) NalIdrCount() *int {
	return s.NalIdrCountValue
}

// How many NAL `IDR` units handled by this decoder.
func (s *InputRTPCountersImpl) SetNalIdrCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.NalIdrCountValue = &v
	return s
}

// How many other NAL units handled by this decoder.
func (s InputRTPCountersImpl) NalOtherCount() *int {
	return s.NalOtherCountValue
}

// How many other NAL units handled by this decoder.
func (s *InputRTPCountersImpl) SetNalOtherCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.NalOtherCountValue = &v
	return s
}

// How many NAL `PPS` units handled by this decoder.
func (s InputRTPCountersImpl) NalPpsCount() *int {
	return s.NalPpsCountValue
}

// How many NAL `PPS` units handled by this decoder.
func (s *InputRTPCountersImpl) SetNalPpsCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.NalPpsCountValue = &v
	return s
}

// How many NAL `SEI` units handled by this decoder.
func (s InputRTPCountersImpl) NalSeiCount() *int {
	return s.NalSeiCountValue
}

// How many NAL `SEI` units handled by this decoder.
func (s *InputRTPCountersImpl) SetNalSeiCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.NalSeiCountValue = &v
	return s
}

// How many NAL `SINGLE` units handled by this decoder.
func (s InputRTPCountersImpl) NalSingleCount() *int {
	return s.NalSingleCountValue
}

// How many NAL `SINGLE` units handled by this decoder.
func (s *InputRTPCountersImpl) SetNalSingleCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.NalSingleCountValue = &v
	return s
}

// How many NAL `SLICE` units handled by this decoder.
func (s InputRTPCountersImpl) NalSliceCount() *int {
	return s.NalSliceCountValue
}

// How many NAL `SLICE` units handled by this decoder.
func (s *InputRTPCountersImpl) SetNalSliceCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.NalSliceCountValue = &v
	return s
}

// How many NAL `SPS` units handled by this decoder.
func (s InputRTPCountersImpl) NalSpsCount() *int {
	return s.NalSpsCountValue
}

// How many NAL `SPS` units handled by this decoder.
func (s *InputRTPCountersImpl) SetNalSpsCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.NalSpsCountValue = &v
	return s
}

// How many NAL `STAP_A` units handled by this decoder.
func (s InputRTPCountersImpl) NalStapACount() *int {
	return s.NalStapACountValue
}

// How many NAL `STAP_A` units handled by this decoder.
func (s *InputRTPCountersImpl) SetNalStapACount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.NalStapACountValue = &v
	return s
}

// How many NAL `VPS` units handled by this decoder.
func (s InputRTPCountersImpl) NalVpsCount() *int {
	return s.NalVpsCountValue
}

// How many NAL `VPS` units handled by this decoder.
func (s *InputRTPCountersImpl) SetNalVpsCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.NalVpsCountValue = &v
	return s
}

// If no marker bit packet is received after 400 RTP packets then decoder switches to `no_marker_mode` and
// makes frame on each timecode change.
// This flag shows if decoder works in `no_marker_mode`.
func (s InputRTPCountersImpl) NoMarkerModeFlag() *bool {
	return s.NoMarkerModeFlagValue
}

// If no marker bit packet is received after 400 RTP packets then decoder switches to `no_marker_mode` and
// makes frame on each timecode change.
// This flag shows if decoder works in `no_marker_mode`.
func (s *InputRTPCountersImpl) SetNoMarkerModeFlag(v bool) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.NoMarkerModeFlagValue = &v
	return s
}

// Number of rtp packets rejected due to wrong payload type
func (s InputRTPCountersImpl) PtRejectCount() *int {
	return s.PtRejectCountValue
}

// Number of rtp packets rejected due to wrong payload type
func (s *InputRTPCountersImpl) SetPtRejectCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.PtRejectCountValue = &v
	return s
}

// Total size of rejected packets due to wrong payload type (pt_reject_count) rtp packets
func (s InputRTPCountersImpl) PtRejectSum() *int {
	return s.PtRejectSumValue
}

// Total size of rejected packets due to wrong payload type (pt_reject_count) rtp packets
func (s *InputRTPCountersImpl) SetPtRejectSum(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.PtRejectSumValue = &v
	return s
}

// How many RTCP packets received for this channel
func (s InputRTPCountersImpl) RtcpPackets() *int {
	return s.RtcpPacketsValue
}

// How many RTCP packets received for this channel
func (s *InputRTPCountersImpl) SetRtcpPackets(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.RtcpPacketsValue = &v
	return s
}

// How many RTP packets received for this channel
func (s InputRTPCountersImpl) RTPPackets() *int {
	return s.RTPPacketsValue
}

// How many RTP packets received for this channel
func (s *InputRTPCountersImpl) SetRTPPackets(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.RTPPacketsValue = &v
	return s
}

// Sender wallclock deviation from server time in ms. Positive value means that sender time is ahead of server time.
func (s InputRTPCountersImpl) SenderClockDeviation() *int {
	return s.SenderClockDeviationValue
}

// Sender wallclock deviation from server time in ms. Positive value means that sender time is ahead of server time.
func (s *InputRTPCountersImpl) SetSenderClockDeviation(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.SenderClockDeviationValue = &v
	return s
}

// Number of rtcp SR packets which `RTP timestamp` is equal to the previous rtcp SR packet `RTP timestamp`.
func (s InputRTPCountersImpl) SrTSStuck() *int {
	return s.SrTSStuckValue
}

// Number of rtcp SR packets which `RTP timestamp` is equal to the previous rtcp SR packet `RTP timestamp`.
func (s *InputRTPCountersImpl) SetSrTSStuck(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.SrTSStuckValue = &v
	return s
}

// Time on this channel is jumped back from reference wallclock.
func (s InputRTPCountersImpl) TSGoesBackwards() *int {
	return s.TSGoesBackwardsValue
}

// Time on this channel is jumped back from reference wallclock.
func (s *InputRTPCountersImpl) SetTSGoesBackwards(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.TSGoesBackwardsValue = &v
	return s
}

// Time on this channel is jumped forward from reference wallclock.
func (s InputRTPCountersImpl) TSJumpForward() *int {
	return s.TSJumpForwardValue
}

// Time on this channel is jumped forward from reference wallclock.
func (s *InputRTPCountersImpl) SetTSJumpForward(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.TSJumpForwardValue = &v
	return s
}

// https://datatracker.ietf.org/doc/html/rfc6184#section-4.1
// access unit: A set of NAL units always containing a primary coded picture.  In addition to the primary coded
// picture, an access unit may also contain one or more redundant coded pictures or other NAL units not containing
// slices or slice data partitions of a coded picture.  The decoding of an access unit always results in a
// decoded picture.
// There is `marker bit` in RTP packet which is set for the very last packet of the access unit indicated by the RTP timestamp.
// It is protocol violation if received RTP packet has the same timestamp as previous marker bit packet.
// This counter is a number of RTP packets which `RTP timestamp` is equal to previous RTP marker bit packet.
func (s InputRTPCountersImpl) TSStuck() *int {
	return s.TSStuckValue
}

// https://datatracker.ietf.org/doc/html/rfc6184#section-4.1
// access unit: A set of NAL units always containing a primary coded picture.  In addition to the primary coded
// picture, an access unit may also contain one or more redundant coded pictures or other NAL units not containing
// slices or slice data partitions of a coded picture.  The decoding of an access unit always results in a
// decoded picture.
// There is `marker bit` in RTP packet which is set for the very last packet of the access unit indicated by the RTP timestamp.
// It is protocol violation if received RTP packet has the same timestamp as previous marker bit packet.
// This counter is a number of RTP packets which `RTP timestamp` is equal to previous RTP marker bit packet.
func (s *InputRTPCountersImpl) SetTSStuck(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.TSStuckValue = &v
	return s
}

// NewInputSdiCounters creates a new InputSdiCounters instance
func NewInputSdiCounters() InputSdiCounters {
	return &InputSdiCountersImpl{}
}

// Gauge of average duration of incoming frame calculated in real time.
func (s InputSdiCountersImpl) AvgRecvDuration() *int {
	return s.AvgRecvDurationValue
}

// Gauge of average duration of incoming frame calculated in real time.
func (s *InputSdiCountersImpl) SetAvgRecvDuration(v int) InputSdiCounters {
	if s == nil {
		return nil
	}
	s.AvgRecvDurationValue = &v
	return s
}

// Frames injected to fix client-side SDI stream drift.
func (s InputSdiCountersImpl) CompensatedFrames() *int {
	return s.CompensatedFramesValue
}

// Frames injected to fix client-side SDI stream drift.
func (s *InputSdiCountersImpl) SetCompensatedFrames(v int) InputSdiCounters {
	if s == nil {
		return nil
	}
	s.CompensatedFramesValue = &v
	return s
}

// Counter of configured audio sdi channels without samples or non valid.
func (s InputSdiCountersImpl) ErrorLostAudio() *int {
	return s.ErrorLostAudioValue
}

// Counter of configured audio sdi channels without samples or non valid.
func (s *InputSdiCountersImpl) SetErrorLostAudio(v int) InputSdiCounters {
	if s == nil {
		return nil
	}
	s.ErrorLostAudioValue = &v
	return s
}

// The frame was dropped due to too high CPU load.
func (s InputSdiCountersImpl) ErrorsCpuStall() *int {
	return s.ErrorsCpuStallValue
}

// The frame was dropped due to too high CPU load.
func (s *InputSdiCountersImpl) SetErrorsCpuStall(v int) InputSdiCounters {
	if s == nil {
		return nil
	}
	s.ErrorsCpuStallValue = &v
	return s
}

// Frame data is duplicated from previous frame because the input was too slow.
func (s InputSdiCountersImpl) ErrorsDuplicate() *int {
	return s.ErrorsDuplicateValue
}

// Frame data is duplicated from previous frame because the input was too slow.
func (s *InputSdiCountersImpl) SetErrorsDuplicate(v int) InputSdiCounters {
	if s == nil {
		return nil
	}
	s.ErrorsDuplicateValue = &v
	return s
}

// Frames dropped due to 'No signal'.
func (s InputSdiCountersImpl) ErrorsNoSignal() *int {
	return s.ErrorsNoSignalValue
}

// Frames dropped due to 'No signal'.
func (s *InputSdiCountersImpl) SetErrorsNoSignal(v int) InputSdiCounters {
	if s == nil {
		return nil
	}
	s.ErrorsNoSignalValue = &v
	return s
}

// Frame time is the same as the previous frame.
func (s InputSdiCountersImpl) ErrorsTSDuplicate() *int {
	return s.ErrorsTSDuplicateValue
}

// Frame time is the same as the previous frame.
func (s *InputSdiCountersImpl) SetErrorsTSDuplicate(v int) InputSdiCounters {
	if s == nil {
		return nil
	}
	s.ErrorsTSDuplicateValue = &v
	return s
}

// Gauge of maximum deviation from the estimated frame duration.
func (s InputSdiCountersImpl) PeakDurationDeviation() *int {
	return s.PeakDurationDeviationValue
}

// Gauge of maximum deviation from the estimated frame duration.
func (s *InputSdiCountersImpl) SetPeakDurationDeviation(v int) InputSdiCounters {
	if s == nil {
		return nil
	}
	s.PeakDurationDeviationValue = &v
	return s
}

// NewInputSrtCounters creates a new InputSrtCounters instance
func NewInputSrtCounters() InputSrtCounters {
	return &InputSrtCountersImpl{}
}

// How many SRT packets were dropped by various reasons
func (s InputSrtCountersImpl) ErrorDroppedPackets() *int {
	return s.ErrorDroppedPacketsValue
}

// How many SRT packets were dropped by various reasons
func (s *InputSrtCountersImpl) SetErrorDroppedPackets(v int) InputSrtCounters {
	if s == nil {
		return nil
	}
	s.ErrorDroppedPacketsValue = &v
	return s
}

// How many SRT packets were lost
func (s InputSrtCountersImpl) ErrorLostPackets() *int {
	return s.ErrorLostPacketsValue
}

// How many SRT packets were lost
func (s *InputSrtCountersImpl) SetErrorLostPackets(v int) InputSrtCounters {
	if s == nil {
		return nil
	}
	s.ErrorLostPacketsValue = &v
	return s
}

// Receiver buffering delay
func (s InputSrtCountersImpl) Latency() *int {
	return s.LatencyValue
}

// Receiver buffering delay
func (s *InputSrtCountersImpl) SetLatency(v int) InputSrtCounters {
	if s == nil {
		return nil
	}
	s.LatencyValue = &v
	return s
}

// Total incoming SRT packets counter
func (s InputSrtCountersImpl) Packets() *int {
	return s.PacketsValue
}

// Total incoming SRT packets counter
func (s *InputSrtCountersImpl) SetPackets(v int) InputSrtCounters {
	if s == nil {
		return nil
	}
	s.PacketsValue = &v
	return s
}

// How many packets were retransmitted
func (s InputSrtCountersImpl) RetransmittedPackets() *int {
	return s.RetransmittedPacketsValue
}

// How many packets were retransmitted
func (s *InputSrtCountersImpl) SetRetransmittedPackets(v int) InputSrtCounters {
	if s == nil {
		return nil
	}
	s.RetransmittedPacketsValue = &v
	return s
}

// Round-trip time
func (s InputSrtCountersImpl) Rtt() *int {
	return s.RttValue
}

// Round-trip time
func (s *InputSrtCountersImpl) SetRtt(v int) InputSrtCounters {
	if s == nil {
		return nil
	}
	s.RttValue = &v
	return s
}

// NewInputStats creates a new InputStats instance
func NewInputStats() InputStats {
	return &InputStatsImpl{}
}

// Whether this input is selected as active for the stream.
// Example: true
func (s InputStatsImpl) Active() *bool {
	return s.ActiveValue
}

// Whether this input is selected as active for the stream.
// Example: true
func (s *InputStatsImpl) SetActive(v bool) InputStats {
	if s == nil {
		return nil
	}
	s.ActiveValue = &v
	return s
}

// How many Ad markers passed to this stream from the inputs.
func (s InputStatsImpl) AdSplicesIngested() *int {
	return s.AdSplicesIngestedValue
}

// How many Ad markers passed to this stream from the inputs.
func (s *InputStatsImpl) SetAdSplicesIngested(v int) InputStats {
	if s == nil {
		return nil
	}
	s.AdSplicesIngestedValue = &v
	return s
}

// How many Ad markers inserted to this stream by user.
func (s InputStatsImpl) AdSplicesInserted() *int {
	return s.AdSplicesInsertedValue
}

// How many Ad markers inserted to this stream by user.
func (s *InputStatsImpl) SetAdSplicesInserted(v int) InputStats {
	if s == nil {
		return nil
	}
	s.AdSplicesInsertedValue = &v
	return s
}

func (s InputStatsImpl) Agent() InputAgentCounters {
	return s.AgentValue
}

func (s *InputStatsImpl) SetAgent(v InputAgentCounters) InputStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputAgentCountersImpl); ok {
		s.AgentValue = impl
	}
	return s
}

// Number of bytes received by this stream from live sources.
// It will be counted before transcoding and will sum all inputs working together.
// Format: bytes (bytes)
func (s InputStatsImpl) Bytes() *Bytes {
	return s.BytesValue
}

// Number of bytes received by this stream from live sources.
// It will be counted before transcoding and will sum all inputs working together.
// Format: bytes (bytes)
func (s *InputStatsImpl) SetBytes(v Bytes) InputStats {
	if s == nil {
		return nil
	}
	s.BytesValue = &v
	return s
}

// Number of bytes received by this stream when downloading from remote DVR.
// Format: bytes (bytes)
func (s InputStatsImpl) BytesDvr() *Bytes {
	return s.BytesDvrValue
}

// Number of bytes received by this stream when downloading from remote DVR.
// Format: bytes (bytes)
func (s *InputStatsImpl) SetBytesDvr(v Bytes) InputStats {
	if s == nil {
		return nil
	}
	s.BytesDvrValue = &v
	return s
}

// Indicates that the stream sources have different track sets, which may cause switching problems. The list of tracks to be compared is obtained only when the sources are checked or started, until then the stream is considered normal.
func (s InputStatsImpl) DivergentInputs() *bool {
	return s.DivergentInputsValue
}

// Indicates that the stream sources have different track sets, which may cause switching problems. The list of tracks to be compared is obtained only when the sources are checked or started, until then the stream is considered normal.
func (s *InputStatsImpl) SetDivergentInputs(v bool) InputStats {
	if s == nil {
		return nil
	}
	s.DivergentInputsValue = &v
	return s
}

// Information about DVR that this input has
func (s InputStatsImpl) DvrInfo() DvrInfo {
	return s.DvrInfoValue
}

// Information about DVR that this input has
func (s *InputStatsImpl) SetDvrInfo(v DvrInfo) InputStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*DvrInfoImpl); ok {
		s.DvrInfoValue = impl
	}
	return s
}

// Sum of all other specific errors in the last minute
// Example: 0
func (s InputStatsImpl) ErrorRate() *int {
	return s.ErrorRateValue
}

// Sum of all other specific errors in the last minute
// Example: 0
func (s *InputStatsImpl) SetErrorRate(v int) InputStats {
	if s == nil {
		return nil
	}
	s.ErrorRateValue = &v
	return s
}

// Sum of all other specific errors. Can be used for triggering alert on any error
// Example: 0
func (s InputStatsImpl) Errors() *int {
	return s.ErrorsValue
}

// Sum of all other specific errors. Can be used for triggering alert on any error
// Example: 0
func (s *InputStatsImpl) SetErrors(v int) InputStats {
	if s == nil {
		return nil
	}
	s.ErrorsValue = &v
	return s
}

// How many times we've got 403 (eaccess).
func (s InputStatsImpl) Errors403() *int {
	return s.Errors403Value
}

// How many times we've got 403 (eaccess).
func (s *InputStatsImpl) SetErrors403(v int) InputStats {
	if s == nil {
		return nil
	}
	s.Errors403Value = &v
	return s
}

// How many times we've got 404 (enoent).
func (s InputStatsImpl) Errors404() *int {
	return s.Errors404Value
}

// How many times we've got 404 (enoent).
func (s *InputStatsImpl) SetErrors404(v int) InputStats {
	if s == nil {
		return nil
	}
	s.Errors404Value = &v
	return s
}

// How many times we've got 500 (backend error).
func (s InputStatsImpl) Errors500() *int {
	return s.Errors500Value
}

// How many times we've got 500 (backend error).
func (s *InputStatsImpl) SetErrors500(v int) InputStats {
	if s == nil {
		return nil
	}
	s.Errors500Value = &v
	return s
}

// Demultiplexing was done right, but content is broken.
func (s InputStatsImpl) ErrorsBrokenPayload() *int {
	return s.ErrorsBrokenPayloadValue
}

// Demultiplexing was done right, but content is broken.
func (s *InputStatsImpl) SetErrorsBrokenPayload(v int) InputStats {
	if s == nil {
		return nil
	}
	s.ErrorsBrokenPayloadValue = &v
	return s
}

// How many times input was restarted due to internal crash.
// This may happen due to unhandled input.
func (s InputStatsImpl) ErrorsCrashed() *int {
	return s.ErrorsCrashedValue
}

// How many times input was restarted due to internal crash.
// This may happen due to unhandled input.
func (s *InputStatsImpl) SetErrorsCrashed(v int) InputStats {
	if s == nil {
		return nil
	}
	s.ErrorsCrashedValue = &v
	return s
}

// Decoder reset count due to abnormal DTS change. Can happen in MPEG-TS, RTP.
func (s InputStatsImpl) ErrorsDecoderReset() *int {
	return s.ErrorsDecoderResetValue
}

// Decoder reset count due to abnormal DTS change. Can happen in MPEG-TS, RTP.
func (s *InputStatsImpl) SetErrorsDecoderReset(v int) InputStats {
	if s == nil {
		return nil
	}
	s.ErrorsDecoderResetValue = &v
	return s
}

// This can be used as a `TS_sync_loss` - how many times MPEG-TS sync was lost.
// Also this counter refers to RTSP desync, when camera starts dropping TCP data and
// we have to find packet boundaries.
// Here we write count of such resynchronizations.
func (s InputStatsImpl) ErrorsDesync() *int {
	return s.ErrorsDesyncValue
}

// This can be used as a `TS_sync_loss` - how many times MPEG-TS sync was lost.
// Also this counter refers to RTSP desync, when camera starts dropping TCP data and
// we have to find packet boundaries.
// Here we write count of such resynchronizations.
func (s *InputStatsImpl) SetErrorsDesync(v int) InputStats {
	if s == nil {
		return nil
	}
	s.ErrorsDesyncValue = &v
	return s
}

// Dropped frames count due timestamp adjustment.
func (s InputStatsImpl) ErrorsDroppedFrames() *int {
	return s.ErrorsDroppedFramesValue
}

// Dropped frames count due timestamp adjustment.
func (s *InputStatsImpl) SetErrorsDroppedFrames(v int) InputStats {
	if s == nil {
		return nil
	}
	s.ErrorsDroppedFramesValue = &v
	return s
}

// RTP, MPEG-TS or other protocols have enough information to tell how many packets were lost
func (s InputStatsImpl) ErrorsLostPackets() *int {
	return s.ErrorsLostPacketsValue
}

// RTP, MPEG-TS or other protocols have enough information to tell how many packets were lost
func (s *InputStatsImpl) SetErrorsLostPackets(v int) InputStats {
	if s == nil {
		return nil
	}
	s.ErrorsLostPacketsValue = &v
	return s
}

// how many times PAT was missing during 0,5 seconds or pid 0 misses PAT
// `PAT_error`
func (s InputStatsImpl) ErrorsTSPat() *int {
	return s.ErrorsTSPatValue
}

// how many times PAT was missing during 0,5 seconds or pid 0 misses PAT
// `PAT_error`
func (s *InputStatsImpl) SetErrorsTSPat(v int) InputStats {
	if s == nil {
		return nil
	}
	s.ErrorsTSPatValue = &v
	return s
}

// How many times have received PAT that was missing required service (program)
func (s InputStatsImpl) ErrorsTSServiceLost() *int {
	return s.ErrorsTSServiceLostValue
}

// How many times have received PAT that was missing required service (program)
func (s *InputStatsImpl) SetErrorsTSServiceLost(v int) InputStats {
	if s == nil {
		return nil
	}
	s.ErrorsTSServiceLostValue = &v
	return s
}

// Number of connection restarts to fix ts_stuck issue. Can happen in RTSP.
func (s InputStatsImpl) ErrorsTSStuckRestarts() *int {
	return s.ErrorsTSStuckRestartsValue
}

// Number of connection restarts to fix ts_stuck issue. Can happen in RTSP.
func (s *InputStatsImpl) SetErrorsTSStuckRestarts(v int) InputStats {
	if s == nil {
		return nil
	}
	s.ErrorsTSStuckRestartsValue = &v
	return s
}

// Number of frames passed to this stream from the inputs.
func (s InputStatsImpl) Frames() *int {
	return s.FramesValue
}

// Number of frames passed to this stream from the inputs.
func (s *InputStatsImpl) SetFrames(v int) InputStats {
	if s == nil {
		return nil
	}
	s.FramesValue = &v
	return s
}

// Aggregated: how many times this stream has switched between different inputs.
// Individual input: number of times switched to this input.
func (s InputStatsImpl) InputSwitches() *int {
	return s.InputSwitchesValue
}

// Aggregated: how many times this stream has switched between different inputs.
// Individual input: number of times switched to this input.
func (s *InputStatsImpl) SetInputSwitches(v int) InputStats {
	if s == nil {
		return nil
	}
	s.InputSwitchesValue = &v
	return s
}

// Number of secondary inputs that have some problems.
// Example: 0
func (s InputStatsImpl) InvalidSecondaryInputs() *int {
	return s.InvalidSecondaryInputsValue
}

// Number of secondary inputs that have some problems.
// Example: 0
func (s *InputStatsImpl) SetInvalidSecondaryInputs(v int) InputStats {
	if s == nil {
		return nil
	}
	s.InvalidSecondaryInputsValue = &v
	return s
}

// IP address of the connected peer.
// Example: 172.16.25.73
func (s InputStatsImpl) IP() *string {
	return s.IPValue
}

// IP address of the connected peer.
// Example: 172.16.25.73
func (s *InputStatsImpl) SetIP(v string) InputStats {
	if s == nil {
		return nil
	}
	s.IPValue = &v
	return s
}

// Technical description of the input content.
func (s InputStatsImpl) MediaInfo() MediaInfo {
	return s.MediaInfoValue
}

// Technical description of the input content.
func (s *InputStatsImpl) SetMediaInfo(v MediaInfo) InputStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*MediaInfoImpl); ok {
		s.MediaInfoValue = impl
	}
	return s
}

// Indicates, how often does media_info changes
func (s InputStatsImpl) MediaInfoChanges() *int {
	return s.MediaInfoChangesValue
}

// Indicates, how often does media_info changes
func (s *InputStatsImpl) SetMediaInfoChanges(v int) InputStats {
	if s == nil {
		return nil
	}
	s.MediaInfoChangesValue = &v
	return s
}

func (s InputStatsImpl) MotionDetector() InputMotionDetectorCounters {
	return s.MotionDetectorValue
}

func (s *InputStatsImpl) SetMotionDetector(v InputMotionDetectorCounters) InputStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputMotionDetectorCountersImpl); ok {
		s.MotionDetectorValue = impl
	}
	return s
}

// How many seconds has this stream had no frames.
// Format: seconds (seconds)
func (s InputStatsImpl) NumSecNoData() *Seconds {
	return s.NumSecNoDataValue
}

// How many seconds has this stream had no frames.
// Format: seconds (seconds)
func (s *InputStatsImpl) SetNumSecNoData(v Seconds) InputStats {
	if s == nil {
		return nil
	}
	s.NumSecNoDataValue = &v
	return s
}

// How many seconds has this stream played from primary input.
// Format: seconds (seconds)
func (s InputStatsImpl) NumSecOnPrimaryInput() *Seconds {
	return s.NumSecOnPrimaryInputValue
}

// How many seconds has this stream played from primary input.
// Format: seconds (seconds)
func (s *InputStatsImpl) SetNumSecOnPrimaryInput(v Seconds) InputStats {
	if s == nil {
		return nil
	}
	s.NumSecOnPrimaryInputValue = &v
	return s
}

// How many seconds has this stream played from secondary inputs.
// Format: seconds (seconds)
func (s InputStatsImpl) NumSecOnSecondaryInput() *Seconds {
	return s.NumSecOnSecondaryInputValue
}

// How many seconds has this stream played from secondary inputs.
// Format: seconds (seconds)
func (s *InputStatsImpl) SetNumSecOnSecondaryInput(v Seconds) InputStats {
	if s == nil {
		return nil
	}
	s.NumSecOnSecondaryInputValue = &v
	return s
}

// The time when this session was created.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s InputStatsImpl) OpenedAt() *UtcMs {
	return s.OpenedAtValue
}

// The time when this session was created.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s *InputStatsImpl) SetOpenedAt(v UtcMs) InputStats {
	if s == nil {
		return nil
	}
	s.OpenedAtValue = &v
	return s
}

// Per pid statistics calculated for MPEG-TS input
func (s InputStatsImpl) Pids() []InputPidCounters {
	if s.PidsValue == nil {
		return nil
	}
	result := make([]InputPidCounters, len(s.PidsValue))
	for i, item := range s.PidsValue {
		result[i] = item
	}
	return result
}

// Per pid statistics calculated for MPEG-TS input
func (s *InputStatsImpl) SetPids(v []InputPidCounters) InputStats {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*InputPidCountersImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*InputPidCountersImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.PidsValue = impl
	}
	return s
}

// Protocol used for the data transmission in the session.
// Example: dash
func (s InputStatsImpl) Proto() *Protocol {
	return s.ProtoValue
}

// Protocol used for the data transmission in the session.
// Example: dash
func (s *InputStatsImpl) SetProto(v Protocol) InputStats {
	if s == nil {
		return nil
	}
	s.ProtoValue = &v
	return s
}

// Source may send frames not in the order they should be played. It will be catched and reordered.
// This counter indicates how many times did it happened.
func (s InputStatsImpl) ReorderCount() *int {
	return s.ReorderCountValue
}

// Source may send frames not in the order they should be played. It will be catched and reordered.
// This counter indicates how many times did it happened.
func (s *InputStatsImpl) SetReorderCount(v int) InputStats {
	if s == nil {
		return nil
	}
	s.ReorderCountValue = &v
	return s
}

// Source may send frames timestamps faster or slower than realtime.
// Live stream will catch it and resync. This counter indicates how many times did it happened.
func (s InputStatsImpl) ResyncCountDrift() *int {
	return s.ResyncCountDriftValue
}

// Source may send frames timestamps faster or slower than realtime.
// Live stream will catch it and resync. This counter indicates how many times did it happened.
func (s *InputStatsImpl) SetResyncCountDrift(v int) InputStats {
	if s == nil {
		return nil
	}
	s.ResyncCountDriftValue = &v
	return s
}

// Source may change timestamps without any signalling. This counter indicates how bad is the source
func (s InputStatsImpl) ResyncCountJump() *int {
	return s.ResyncCountJumpValue
}

// Source may change timestamps without any signalling. This counter indicates how bad is the source
func (s *InputStatsImpl) SetResyncCountJump(v int) InputStats {
	if s == nil {
		return nil
	}
	s.ResyncCountJumpValue = &v
	return s
}

// Stream timestamps are synchronized with real time. This counter tells, how many times
// it was syncronized after source reconnect.
func (s InputStatsImpl) ResyncCountNormal() *int {
	return s.ResyncCountNormalValue
}

// Stream timestamps are synchronized with real time. This counter tells, how many times
// it was syncronized after source reconnect.
func (s *InputStatsImpl) SetResyncCountNormal(v int) InputStats {
	if s == nil {
		return nil
	}
	s.ResyncCountNormalValue = &v
	return s
}

// How many times has this stream retried to connect to source
func (s InputStatsImpl) Retries() *int {
	return s.RetriesValue
}

// How many times has this stream retried to connect to source
func (s *InputStatsImpl) SetRetries(v int) InputStats {
	if s == nil {
		return nil
	}
	s.RetriesValue = &v
	return s
}

// Per channel statistics calculated for RTP input
func (s InputStatsImpl) RTPChannels() []InputRTPCounters {
	if s.RTPChannelsValue == nil {
		return nil
	}
	result := make([]InputRTPCounters, len(s.RTPChannelsValue))
	for i, item := range s.RTPChannelsValue {
		result[i] = item
	}
	return result
}

// Per channel statistics calculated for RTP input
func (s *InputStatsImpl) SetRTPChannels(v []InputRTPCounters) InputStats {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*InputRTPCountersImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*InputRTPCountersImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.RTPChannelsValue = impl
	}
	return s
}

func (s InputStatsImpl) Sdi() InputSdiCounters {
	return s.SdiValue
}

func (s *InputStatsImpl) SetSdi(v InputSdiCounters) InputStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputSdiCountersImpl); ok {
		s.SdiValue = impl
	}
	return s
}

func (s InputStatsImpl) Srt() InputSrtCounters {
	return s.SrtValue
}

func (s *InputStatsImpl) SetSrt(v InputSrtCounters) InputStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputSrtCountersImpl); ok {
		s.SrtValue = impl
	}
	return s
}

// The time period during which no frames were received from the stream's input.
// Format: ticks (ticks)
// Example: 1284
func (s InputStatsImpl) TSDelay() *Ticks {
	return s.TSDelayValue
}

// The time period during which no frames were received from the stream's input.
// Format: ticks (ticks)
// Example: 1284
func (s *InputStatsImpl) SetTSDelay(v Ticks) InputStats {
	if s == nil {
		return nil
	}
	s.TSDelayValue = &v
	return s
}

// The time period during which no frames were received per each track according to `media_info`
// Example: [1284]
func (s InputStatsImpl) TSDelayPerTracks() []Ticks {
	return s.TSDelayPerTracksValue
}

// The time period during which no frames were received per each track according to `media_info`
// Example: [1284]
func (s *InputStatsImpl) SetTSDelayPerTracks(v []Ticks) InputStats {
	if s == nil {
		return nil
	}
	s.TSDelayPerTracksValue = v
	return s
}

// Deprecated field. Will be deleted at 25.03
// Final URL after redirects.
// Deprecated because was never actually used.
// Format: url (url)
// Example: udp://239.0.0.1:1234
func (s InputStatsImpl) URL() *URL {
	return s.URLValue
}

// Deprecated field. Will be deleted at 25.03
// Final URL after redirects.
// Deprecated because was never actually used.
// Format: url (url)
// Example: udp://239.0.0.1:1234
func (s *InputStatsImpl) SetURL(v URL) InputStats {
	if s == nil {
		return nil
	}
	s.URLValue = &v
	return s
}

// Client's user agent for selected protocol.
// Example: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML. like Gecko) Chrome/90.0.4430.72 Safari/537.36
func (s InputStatsImpl) UserAgent() *string {
	return s.UserAgentValue
}

// Client's user agent for selected protocol.
// Example: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML. like Gecko) Chrome/90.0.4430.72 Safari/537.36
func (s *InputStatsImpl) SetUserAgent(v string) InputStats {
	if s == nil {
		return nil
	}
	s.UserAgentValue = &v
	return s
}

// Number of secondary inputs that have no problems.
// Example: 2
func (s InputStatsImpl) ValidSecondaryInputs() *int {
	return s.ValidSecondaryInputsValue
}

// Number of secondary inputs that have no problems.
// Example: 2
func (s *InputStatsImpl) SetValidSecondaryInputs(v int) InputStats {
	if s == nil {
		return nil
	}
	s.ValidSecondaryInputsValue = &v
	return s
}

// NewIptvConfig creates a new IptvConfig instance
func NewIptvConfig() IptvConfig {
	return &IptvConfigImpl{}
}

// DB connection string.
func (s IptvConfigImpl) Database() *string {
	return s.DatabaseValue
}

// DB connection string.
func (s *IptvConfigImpl) SetDatabase(v string) IptvConfig {
	if s == nil {
		return nil
	}
	s.DatabaseValue = &v
	return s
}

// NewLetsencryptRequest creates a new LetsencryptRequest instance
func NewLetsencryptRequest() LetsencryptRequest {
	return &LetsencryptRequestImpl{}
}

// One or more domain names to issue the Let's Encrypt certificate for.
func (s LetsencryptRequestImpl) Domains() []string {
	return s.DomainsValue
}

// One or more domain names to issue the Let's Encrypt certificate for.
func (s *LetsencryptRequestImpl) SetDomains(v []string) LetsencryptRequest {
	if s == nil {
		return nil
	}
	s.DomainsValue = v
	return s
}

// NewListenConfig creates a new ListenConfig instance
func NewListenConfig() ListenConfig {
	return &ListenConfigImpl{}
}

// Network address that will be used for listening.
// Example: 10.0.35.1
func (s ListenConfigImpl) Address() *string {
	return s.AddressValue
}

// Network address that will be used for listening.
// Example: 10.0.35.1
func (s *ListenConfigImpl) SetAddress(v string) ListenConfig {
	if s == nil {
		return nil
	}
	s.AddressValue = &v
	return s
}

// Port that will be used for listening.
// Format: network_port (network_port)
// Example: 80
func (s ListenConfigImpl) Port() NetworkPort {
	return s.PortValue
}

// Port that will be used for listening.
// Format: network_port (network_port)
// Example: 80
func (s *ListenConfigImpl) SetPort(v NetworkPort) ListenConfig {
	if s == nil {
		return nil
	}
	s.PortValue = v
	return s
}

// NewListenHTTPConfig creates a new ListenHTTPConfig instance
func NewListenHTTPConfig() ListenHTTPConfig {
	return &ListenHTTPConfigImpl{}
}

// Network address that will be used for listening.
// Example: 10.0.35.1
func (s ListenHTTPConfigImpl) Address() *string {
	return s.AddressValue
}

// Network address that will be used for listening.
// Example: 10.0.35.1
func (s *ListenHTTPConfigImpl) SetAddress(v string) ListenHTTPConfig {
	if s == nil {
		return nil
	}
	s.AddressValue = &v
	return s
}

// Port that will be used for listening.
// Format: network_port (network_port)
// Example: 80
func (s ListenHTTPConfigImpl) Port() NetworkPort {
	return s.PortValue
}

// Port that will be used for listening.
// Format: network_port (network_port)
// Example: 80
func (s *ListenHTTPConfigImpl) SetPort(v NetworkPort) ListenHTTPConfig {
	if s == nil {
		return nil
	}
	s.PortValue = v
	return s
}

// NewListenHTTPConfigParams creates a new ListenHTTPConfigParams instance
func NewListenHTTPConfigParams() ListenHTTPConfigParams {
	return &ListenHTTPConfigParamsImpl{}
}

// NewListeners creates a new Listeners instance
func NewListeners() Listeners {
	return &ListenersImpl{}
}

// List of HTTP ports or `host:port` pairs that will be used for listening.
// Examples: [map[api:false, port:80]]
func (s ListenersImpl) HTTP() []ListenHTTPConfig {
	if s.HTTPValue == nil {
		return nil
	}
	result := make([]ListenHTTPConfig, len(s.HTTPValue))
	for i, item := range s.HTTPValue {
		result[i] = item
	}
	return result
}

// List of HTTP ports or `host:port` pairs that will be used for listening.
// Examples: [map[api:false, port:80]]
func (s *ListenersImpl) SetHTTP(v []ListenHTTPConfig) Listeners {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*ListenHTTPConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*ListenHTTPConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.HTTPValue = impl
	}
	return s
}

// NewLoginInfoAdditional creates a new LoginInfoAdditional instance
func NewLoginInfoAdditional() LoginInfoAdditional {
	return &LoginInfoAdditionalImpl{}
}

// A JWT token with a limited lifetime duration. JWT algorithm is RS256.
// Example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
func (s LoginInfoAdditionalImpl) AccessToken() *string {
	return s.AccessTokenValue
}

// A JWT token with a limited lifetime duration. JWT algorithm is RS256.
// Example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
func (s *LoginInfoAdditionalImpl) SetAccessToken(v string) LoginInfoAdditional {
	if s == nil {
		return nil
	}
	s.AccessTokenValue = &v
	return s
}

// A token used to get a new access_token after expiration.
// It works with `/login` request only.
// Example: 3637e790-5530-11ed-bdc3-0242ac120002
func (s LoginInfoAdditionalImpl) RefreshToken() *string {
	return s.RefreshTokenValue
}

// A token used to get a new access_token after expiration.
// It works with `/login` request only.
// Example: 3637e790-5530-11ed-bdc3-0242ac120002
func (s *LoginInfoAdditionalImpl) SetRefreshToken(v string) LoginInfoAdditional {
	if s == nil {
		return nil
	}
	s.RefreshTokenValue = &v
	return s
}

// NewLoginInfoBase creates a new LoginInfoBase instance
func NewLoginInfoBase() LoginInfoBase {
	return &LoginInfoBaseImpl{}
}

// A JWT token with a limited lifetime duration. JWT algorithm is RS256.
// Example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
func (s LoginInfoBaseImpl) AccessToken() *string {
	return s.AccessTokenValue
}

// A JWT token with a limited lifetime duration. JWT algorithm is RS256.
// Example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
func (s *LoginInfoBaseImpl) SetAccessToken(v string) LoginInfoBase {
	if s == nil {
		return nil
	}
	s.AccessTokenValue = &v
	return s
}

// A token used to get a new access_token after expiration.
// It works with `/login` request only.
// Example: 3637e790-5530-11ed-bdc3-0242ac120002
func (s LoginInfoBaseImpl) RefreshToken() *string {
	return s.RefreshTokenValue
}

// A token used to get a new access_token after expiration.
// It works with `/login` request only.
// Example: 3637e790-5530-11ed-bdc3-0242ac120002
func (s *LoginInfoBaseImpl) SetRefreshToken(v string) LoginInfoBase {
	if s == nil {
		return nil
	}
	s.RefreshTokenValue = &v
	return s
}

// NewMailBase creates a new MailBase instance
func NewMailBase() MailBase {
	return &MailBaseImpl{}
}

// Information about the sender
func (s MailBaseImpl) Sender() MailBaseSender {
	return s.SenderValue
}

// Information about the sender
func (s *MailBaseImpl) SetSender(v MailBaseSender) MailBase {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*MailBaseSenderImpl); ok {
		s.SenderValue = impl
	}
	return s
}

// the method of sending messages by mail
// Example: SMTP
func (s MailBaseImpl) SendingMethod() string {
	return s.SendingMethodValue
}

// the method of sending messages by mail
// Example: SMTP
func (s *MailBaseImpl) SetSendingMethod(v string) MailBase {
	if s == nil {
		return nil
	}
	s.SendingMethodValue = v
	return s
}

// NewMailBaseSender creates a new MailBaseSender instance
func NewMailBaseSender() MailBaseSender {
	return &MailBaseSenderImpl{}
}

// sender email
// Example: watcher@someserver.com
func (s MailBaseSenderImpl) Email() *string {
	return s.EmailValue
}

// sender email
// Example: watcher@someserver.com
func (s *MailBaseSenderImpl) SetEmail(v string) MailBaseSender {
	if s == nil {
		return nil
	}
	s.EmailValue = &v
	return s
}

// sender title
// Example: Flussonic Watcher
func (s MailBaseSenderImpl) Title() *string {
	return s.TitleValue
}

// sender title
// Example: Flussonic Watcher
func (s *MailBaseSenderImpl) SetTitle(v string) MailBaseSender {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// NewMailSendgrid creates a new MailSendgrid instance
func NewMailSendgrid() MailSendgrid {
	return &MailSendgridImpl{}
}

// api key for SendGrid
func (s MailSendgridImpl) APIKey() *string {
	return s.APIKeyValue
}

// api key for SendGrid
func (s *MailSendgridImpl) SetAPIKey(v string) MailSendgrid {
	if s == nil {
		return nil
	}
	s.APIKeyValue = &v
	return s
}

// Information about the sender
func (s MailSendgridImpl) Sender() MailBaseSender {
	return s.SenderValue
}

// Information about the sender
func (s *MailSendgridImpl) SetSender(v MailBaseSender) MailSendgrid {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*MailBaseSenderImpl); ok {
		s.SenderValue = impl
	}
	return s
}

// the method of sending messages by mail
// Example: SMTP
func (s MailSendgridImpl) SendingMethod() string {
	return s.SendingMethodValue
}

// the method of sending messages by mail
// Example: SMTP
func (s *MailSendgridImpl) SetSendingMethod(v string) MailSendgrid {
	if s == nil {
		return nil
	}
	s.SendingMethodValue = v
	return s
}

// NewMailSmtp creates a new MailSmtp instance
func NewMailSmtp() MailSmtp {
	return &MailSmtpImpl{}
}

// smtp server host
func (s MailSmtpImpl) Host() *string {
	return s.HostValue
}

// smtp server host
func (s *MailSmtpImpl) SetHost(v string) MailSmtp {
	if s == nil {
		return nil
	}
	s.HostValue = &v
	return s
}

// login for smtp server
func (s MailSmtpImpl) Login() *string {
	return s.LoginValue
}

// login for smtp server
func (s *MailSmtpImpl) SetLogin(v string) MailSmtp {
	if s == nil {
		return nil
	}
	s.LoginValue = &v
	return s
}

// password for smtp server
func (s MailSmtpImpl) Password() *string {
	return s.PasswordValue
}

// password for smtp server
func (s *MailSmtpImpl) SetPassword(v string) MailSmtp {
	if s == nil {
		return nil
	}
	s.PasswordValue = &v
	return s
}

// port for smtp server
func (s MailSmtpImpl) Port() *int {
	return s.PortValue
}

// port for smtp server
func (s *MailSmtpImpl) SetPort(v int) MailSmtp {
	if s == nil {
		return nil
	}
	s.PortValue = &v
	return s
}

// connecting to the server using TLS/STARTTLS
func (s MailSmtpImpl) Security() *MailSmtpSecurity {
	return s.SecurityValue
}

// connecting to the server using TLS/STARTTLS
func (s *MailSmtpImpl) SetSecurity(v MailSmtpSecurity) MailSmtp {
	if s == nil {
		return nil
	}
	s.SecurityValue = &v
	return s
}

// Information about the sender
func (s MailSmtpImpl) Sender() MailBaseSender {
	return s.SenderValue
}

// Information about the sender
func (s *MailSmtpImpl) SetSender(v MailBaseSender) MailSmtp {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*MailBaseSenderImpl); ok {
		s.SenderValue = impl
	}
	return s
}

// the method of sending messages by mail
// Example: SMTP
func (s MailSmtpImpl) SendingMethod() string {
	return s.SendingMethodValue
}

// the method of sending messages by mail
// Example: SMTP
func (s *MailSmtpImpl) SetSendingMethod(v string) MailSmtp {
	if s == nil {
		return nil
	}
	s.SendingMethodValue = v
	return s
}

// NewMailSpec creates a new MailSpec instance
func NewMailSpec() MailSpec {
	return &MailSpecImpl{}
}

// api key for SendGrid
func (s MailSpecImpl) APIKey() *string {
	return s.APIKeyValue
}

// api key for SendGrid
func (s *MailSpecImpl) SetAPIKey(v string) MailSpec {
	if s == nil {
		return nil
	}
	s.APIKeyValue = &v
	return s
}

// smtp server host
func (s MailSpecImpl) Host() *string {
	return s.HostValue
}

// smtp server host
func (s *MailSpecImpl) SetHost(v string) MailSpec {
	if s == nil {
		return nil
	}
	s.HostValue = &v
	return s
}

// login for smtp server
func (s MailSpecImpl) Login() *string {
	return s.LoginValue
}

// login for smtp server
func (s *MailSpecImpl) SetLogin(v string) MailSpec {
	if s == nil {
		return nil
	}
	s.LoginValue = &v
	return s
}

// password for smtp server
func (s MailSpecImpl) Password() *string {
	return s.PasswordValue
}

// password for smtp server
func (s *MailSpecImpl) SetPassword(v string) MailSpec {
	if s == nil {
		return nil
	}
	s.PasswordValue = &v
	return s
}

// port for smtp server
func (s MailSpecImpl) Port() *int {
	return s.PortValue
}

// port for smtp server
func (s *MailSpecImpl) SetPort(v int) MailSpec {
	if s == nil {
		return nil
	}
	s.PortValue = &v
	return s
}

// connecting to the server using TLS/STARTTLS
func (s MailSpecImpl) Security() *MailSmtpSecurity {
	return s.SecurityValue
}

// connecting to the server using TLS/STARTTLS
func (s *MailSpecImpl) SetSecurity(v MailSmtpSecurity) MailSpec {
	if s == nil {
		return nil
	}
	s.SecurityValue = &v
	return s
}

// Information about the sender
func (s MailSpecImpl) Sender() MailBaseSender {
	return s.SenderValue
}

// Information about the sender
func (s *MailSpecImpl) SetSender(v MailBaseSender) MailSpec {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*MailBaseSenderImpl); ok {
		s.SenderValue = impl
	}
	return s
}

// the method of sending messages by mail
// Example: SMTP
func (s MailSpecImpl) SendingMethod() string {
	return s.SendingMethodValue
}

// the method of sending messages by mail
// Example: SMTP
func (s *MailSpecImpl) SetSendingMethod(v string) MailSpec {
	if s == nil {
		return nil
	}
	s.SendingMethodValue = v
	return s
}

// NewMapSpec creates a new MapSpec instance
func NewMapSpec() MapSpec {
	return &MapSpecImpl{}
}

// Geographic latitude.
// Example: 55.7512
func (s MapSpecImpl) Latitude() float64 {
	return s.LatitudeValue
}

// Geographic latitude.
// Example: 55.7512
func (s *MapSpecImpl) SetLatitude(v float64) MapSpec {
	if s == nil {
		return nil
	}
	s.LatitudeValue = v
	return s
}

// Geographic longitude.
// Example: 37.6184
func (s MapSpecImpl) Longitude() float64 {
	return s.LongitudeValue
}

// Geographic longitude.
// Example: 37.6184
func (s *MapSpecImpl) SetLongitude(v float64) MapSpec {
	if s == nil {
		return nil
	}
	s.LongitudeValue = v
	return s
}

// NewMediaInfo creates a new MediaInfo instance
func NewMediaInfo() MediaInfo {
	return &MediaInfoImpl{}
}

// Duration of the media, if applicable.
// Format: ticks (ticks)
func (s MediaInfoImpl) Duration() *Ticks {
	return s.DurationValue
}

// Duration of the media, if applicable.
// Format: ticks (ticks)
func (s *MediaInfoImpl) SetDuration(v Ticks) MediaInfo {
	if s == nil {
		return nil
	}
	s.DurationValue = &v
	return s
}

// Whether it is a file with a finite start and end time or a live stream.
// Example: stream
func (s MediaInfoImpl) FlowType() *MediaInfoSpecificFlowType {
	return s.FlowTypeValue
}

// Whether it is a file with a finite start and end time or a live stream.
// Example: stream
func (s *MediaInfoImpl) SetFlowType(v MediaInfoSpecificFlowType) MediaInfo {
	if s == nil {
		return nil
	}
	s.FlowTypeValue = &v
	return s
}

// The program ID for MPEG TS streams.
// Example: 110
func (s MediaInfoImpl) ProgramID() *int {
	return s.ProgramIDValue
}

// The program ID for MPEG TS streams.
// Example: 110
func (s *MediaInfoImpl) SetProgramID(v int) MediaInfo {
	if s == nil {
		return nil
	}
	s.ProgramIDValue = &v
	return s
}

// The media provider of this content.
// Example: Netflix
func (s MediaInfoImpl) Provider() *string {
	return s.ProviderValue
}

// The media provider of this content.
// Example: Netflix
func (s *MediaInfoImpl) SetProvider(v string) MediaInfo {
	if s == nil {
		return nil
	}
	s.ProviderValue = &v
	return s
}

// The identifier of the transport stream for MPEG TS streams.
// Example: 253
func (s MediaInfoImpl) StreamID() *int {
	return s.StreamIDValue
}

// The identifier of the transport stream for MPEG TS streams.
// Example: 253
func (s *MediaInfoImpl) SetStreamID(v int) MediaInfo {
	if s == nil {
		return nil
	}
	s.StreamIDValue = &v
	return s
}

// Human-readable title of the media.
// Example: Bunny
func (s MediaInfoImpl) Title() *string {
	return s.TitleValue
}

// Human-readable title of the media.
// Example: Bunny
func (s *MediaInfoImpl) SetTitle(v string) MediaInfo {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// Information about available tracks (video, audio, or text).
func (s MediaInfoImpl) Tracks() []TrackInfo {
	if s.TracksValue == nil {
		return nil
	}
	result := make([]TrackInfo, len(s.TracksValue))
	for i, item := range s.TracksValue {
		result[i] = item
	}
	return result
}

// Information about available tracks (video, audio, or text).
func (s *MediaInfoImpl) SetTracks(v []TrackInfo) MediaInfo {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*TrackInfoImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*TrackInfoImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.TracksValue = impl
	}
	return s
}

// NewMediaInfoCommon creates a new MediaInfoCommon instance
func NewMediaInfoCommon() MediaInfoCommon {
	return &MediaInfoCommonImpl{}
}

// The program ID for MPEG TS streams.
// Example: 110
func (s MediaInfoCommonImpl) ProgramID() *int {
	return s.ProgramIDValue
}

// The program ID for MPEG TS streams.
// Example: 110
func (s *MediaInfoCommonImpl) SetProgramID(v int) MediaInfoCommon {
	if s == nil {
		return nil
	}
	s.ProgramIDValue = &v
	return s
}

// The media provider of this content.
// Example: Netflix
func (s MediaInfoCommonImpl) Provider() *string {
	return s.ProviderValue
}

// The media provider of this content.
// Example: Netflix
func (s *MediaInfoCommonImpl) SetProvider(v string) MediaInfoCommon {
	if s == nil {
		return nil
	}
	s.ProviderValue = &v
	return s
}

// The identifier of the transport stream for MPEG TS streams.
// Example: 253
func (s MediaInfoCommonImpl) StreamID() *int {
	return s.StreamIDValue
}

// The identifier of the transport stream for MPEG TS streams.
// Example: 253
func (s *MediaInfoCommonImpl) SetStreamID(v int) MediaInfoCommon {
	if s == nil {
		return nil
	}
	s.StreamIDValue = &v
	return s
}

// Human-readable title of the media.
// Example: Bunny
func (s MediaInfoCommonImpl) Title() *string {
	return s.TitleValue
}

// Human-readable title of the media.
// Example: Bunny
func (s *MediaInfoCommonImpl) SetTitle(v string) MediaInfoCommon {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// NewMediaInfoSpecific creates a new MediaInfoSpecific instance
func NewMediaInfoSpecific() MediaInfoSpecific {
	return &MediaInfoSpecificImpl{}
}

// Duration of the media, if applicable.
// Format: ticks (ticks)
func (s MediaInfoSpecificImpl) Duration() *Ticks {
	return s.DurationValue
}

// Duration of the media, if applicable.
// Format: ticks (ticks)
func (s *MediaInfoSpecificImpl) SetDuration(v Ticks) MediaInfoSpecific {
	if s == nil {
		return nil
	}
	s.DurationValue = &v
	return s
}

// Whether it is a file with a finite start and end time or a live stream.
// Example: stream
func (s MediaInfoSpecificImpl) FlowType() *MediaInfoSpecificFlowType {
	return s.FlowTypeValue
}

// Whether it is a file with a finite start and end time or a live stream.
// Example: stream
func (s *MediaInfoSpecificImpl) SetFlowType(v MediaInfoSpecificFlowType) MediaInfoSpecific {
	if s == nil {
		return nil
	}
	s.FlowTypeValue = &v
	return s
}

// Information about available tracks (video, audio, or text).
func (s MediaInfoSpecificImpl) Tracks() []TrackInfo {
	if s.TracksValue == nil {
		return nil
	}
	result := make([]TrackInfo, len(s.TracksValue))
	for i, item := range s.TracksValue {
		result[i] = item
	}
	return result
}

// Information about available tracks (video, audio, or text).
func (s *MediaInfoSpecificImpl) SetTracks(v []TrackInfo) MediaInfoSpecific {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*TrackInfoImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*TrackInfoImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.TracksValue = impl
	}
	return s
}

// NewMultiplexerStats creates a new MultiplexerStats instance
func NewMultiplexerStats() MultiplexerStats {
	return &MultiplexerStatsImpl{}
}

// Bitrate of the MPTS stream, configured or autotuned.
// Format: speed (speed)
func (s MultiplexerStatsImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// Bitrate of the MPTS stream, configured or autotuned.
// Format: speed (speed)
func (s *MultiplexerStatsImpl) SetBitrate(v Speed) MultiplexerStats {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// The encoded bytes count.
// Format: bytes (bytes)
func (s MultiplexerStatsImpl) Encoded() *Bytes {
	return s.EncodedValue
}

// The encoded bytes count.
// Format: bytes (bytes)
func (s *MultiplexerStatsImpl) SetEncoded(v Bytes) MultiplexerStats {
	if s == nil {
		return nil
	}
	s.EncodedValue = &v
	return s
}

// Number of programs for which EPG is transmitted.
func (s MultiplexerStatsImpl) EpgPrograms() *int {
	return s.EpgProgramsValue
}

// Number of programs for which EPG is transmitted.
func (s *MultiplexerStatsImpl) SetEpgPrograms(v int) MultiplexerStats {
	if s == nil {
		return nil
	}
	s.EpgProgramsValue = &v
	return s
}

// Number of XMLTV file read errors.
func (s MultiplexerStatsImpl) ErrorsXmltvFile() *int {
	return s.ErrorsXmltvFileValue
}

// Number of XMLTV file read errors.
func (s *MultiplexerStatsImpl) SetErrorsXmltvFile(v int) MultiplexerStats {
	if s == nil {
		return nil
	}
	s.ErrorsXmltvFileValue = &v
	return s
}

// Number of XMLTV parse errors.
func (s MultiplexerStatsImpl) ErrorsXmltvParse() *int {
	return s.ErrorsXmltvParseValue
}

// Number of XMLTV parse errors.
func (s *MultiplexerStatsImpl) SetErrorsXmltvParse(v int) MultiplexerStats {
	if s == nil {
		return nil
	}
	s.ErrorsXmltvParseValue = &v
	return s
}

// The number of bytes exceeding the allocated bandwidth.
// Format: bytes (bytes)
func (s MultiplexerStatsImpl) ExceededBytes() *Bytes {
	return s.ExceededBytesValue
}

// The number of bytes exceeding the allocated bandwidth.
// Format: bytes (bytes)
func (s *MultiplexerStatsImpl) SetExceededBytes(v Bytes) MultiplexerStats {
	if s == nil {
		return nil
	}
	s.ExceededBytesValue = &v
	return s
}

// The number of PES packets with an instant bitrate boost.
func (s MultiplexerStatsImpl) ExceededFrames() *int {
	return s.ExceededFramesValue
}

// The number of PES packets with an instant bitrate boost.
func (s *MultiplexerStatsImpl) SetExceededFrames(v int) MultiplexerStats {
	if s == nil {
		return nil
	}
	s.ExceededFramesValue = &v
	return s
}

// The filler packets count.
func (s MultiplexerStatsImpl) Fillers() *int {
	return s.FillersValue
}

// The filler packets count.
func (s *MultiplexerStatsImpl) SetFillers(v int) MultiplexerStats {
	if s == nil {
		return nil
	}
	s.FillersValue = &v
	return s
}

// Encoder is too slow events counter
func (s MultiplexerStatsImpl) LateTicks() *int {
	return s.LateTicksValue
}

// Encoder is too slow events counter
func (s *MultiplexerStatsImpl) SetLateTicks(v int) MultiplexerStats {
	if s == nil {
		return nil
	}
	s.LateTicksValue = &v
	return s
}

// The payload bytes count.
// Format: bytes (bytes)
func (s MultiplexerStatsImpl) Payload() *Bytes {
	return s.PayloadValue
}

// The payload bytes count.
// Format: bytes (bytes)
func (s *MultiplexerStatsImpl) SetPayload(v Bytes) MultiplexerStats {
	if s == nil {
		return nil
	}
	s.PayloadValue = &v
	return s
}

// Per pid statistics for MPEG-TS encoding
func (s MultiplexerStatsImpl) Pids() []PushPidCounters {
	if s.PidsValue == nil {
		return nil
	}
	result := make([]PushPidCounters, len(s.PidsValue))
	for i, item := range s.PidsValue {
		result[i] = item
	}
	return result
}

// Per pid statistics for MPEG-TS encoding
func (s *MultiplexerStatsImpl) SetPids(v []PushPidCounters) MultiplexerStats {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*PushPidCountersImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*PushPidCountersImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.PidsValue = impl
	}
	return s
}

// Per pid statistics for MPEG-TS encoding
func (s MultiplexerStatsImpl) Programs() []TransponderProgramStats {
	if s.ProgramsValue == nil {
		return nil
	}
	result := make([]TransponderProgramStats, len(s.ProgramsValue))
	for i, item := range s.ProgramsValue {
		result[i] = item
	}
	return result
}

// Per pid statistics for MPEG-TS encoding
func (s *MultiplexerStatsImpl) SetPrograms(v []TransponderProgramStats) MultiplexerStats {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*TransponderProgramStatsImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*TransponderProgramStatsImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.ProgramsValue = impl
	}
	return s
}

// The stuff packets count.
func (s MultiplexerStatsImpl) Stuffing() *int {
	return s.StuffingValue
}

// The stuff packets count.
func (s *MultiplexerStatsImpl) SetStuffing(v int) MultiplexerStats {
	if s == nil {
		return nil
	}
	s.StuffingValue = &v
	return s
}

// Number of system traffic packets
func (s MultiplexerStatsImpl) SysPackets() *int {
	return s.SysPacketsValue
}

// Number of system traffic packets
func (s *MultiplexerStatsImpl) SetSysPackets(v int) MultiplexerStats {
	if s == nil {
		return nil
	}
	s.SysPacketsValue = &v
	return s
}

// Counts payload bytes for system traffic, including PSI tables and raw bypass.
// Format: bytes (bytes)
func (s MultiplexerStatsImpl) SysPayload() *Bytes {
	return s.SysPayloadValue
}

// Counts payload bytes for system traffic, including PSI tables and raw bypass.
// Format: bytes (bytes)
func (s *MultiplexerStatsImpl) SetSysPayload(v Bytes) MultiplexerStats {
	if s == nil {
		return nil
	}
	s.SysPayloadValue = &v
	return s
}

// Number of NULL packets (PID 0x1FFF) inserted when no data was scheduled on any PID.
func (s MultiplexerStatsImpl) SysStuffingPackets() *int {
	return s.SysStuffingPacketsValue
}

// Number of NULL packets (PID 0x1FFF) inserted when no data was scheduled on any PID.
func (s *MultiplexerStatsImpl) SetSysStuffingPackets(v int) MultiplexerStats {
	if s == nil {
		return nil
	}
	s.SysStuffingPacketsValue = &v
	return s
}

// The trimmed bytes count.
// Format: bytes (bytes)
func (s MultiplexerStatsImpl) TrimmedBytes() *Bytes {
	return s.TrimmedBytesValue
}

// The trimmed bytes count.
// Format: bytes (bytes)
func (s *MultiplexerStatsImpl) SetTrimmedBytes(v Bytes) MultiplexerStats {
	if s == nil {
		return nil
	}
	s.TrimmedBytesValue = &v
	return s
}

// The trimmed frames count.
func (s MultiplexerStatsImpl) TrimmedFrames() *int {
	return s.TrimmedFramesValue
}

// The trimmed frames count.
func (s *MultiplexerStatsImpl) SetTrimmedFrames(v int) MultiplexerStats {
	if s == nil {
		return nil
	}
	s.TrimmedFramesValue = &v
	return s
}

// Is TS overflowed. True if no stuffing at last time.
func (s MultiplexerStatsImpl) TSOverflow() *bool {
	return s.TSOverflowValue
}

// Is TS overflowed. True if no stuffing at last time.
func (s *MultiplexerStatsImpl) SetTSOverflow(v bool) MultiplexerStats {
	if s == nil {
		return nil
	}
	s.TSOverflowValue = &v
	return s
}

// NewOnOff creates a new OnOff instance
func NewOnOff() OnOff {
	return &OnOffImpl{}
}

func (s OnOffImpl) Mode() *OnOffMode {
	return s.ModeValue
}

func (s *OnOffImpl) SetMode(v OnOffMode) OnOff {
	if s == nil {
		return nil
	}
	s.ModeValue = &v
	return s
}

// NewOnOffAuto creates a new OnOffAuto instance
func NewOnOffAuto() OnOffAuto {
	return &OnOffAutoImpl{}
}

func (s OnOffAutoImpl) Mode() *OnOffAutoMode {
	return s.ModeValue
}

func (s *OnOffAutoImpl) SetMode(v OnOffAutoMode) OnOffAuto {
	if s == nil {
		return nil
	}
	s.ModeValue = &v
	return s
}

// NewOrganizationBase creates a new OrganizationBase instance
func NewOrganizationBase() OrganizationBase {
	return &OrganizationBaseImpl{}
}

// Organization identifier.
// Example: 7
func (s OrganizationBaseImpl) ID() int {
	return s.IDValue
}

// Organization identifier.
// Example: 7
func (s *OrganizationBaseImpl) SetID(v int) OrganizationBase {
	if s == nil {
		return nil
	}
	s.IDValue = v
	return s
}

// Human-readable name of the organization.
// Example: Example LLC
func (s OrganizationBaseImpl) Title() string {
	return s.TitleValue
}

// Human-readable name of the organization.
// Example: Example LLC
func (s *OrganizationBaseImpl) SetTitle(v string) OrganizationBase {
	if s == nil {
		return nil
	}
	s.TitleValue = v
	return s
}

// NewOrganizationPermissions creates a new OrganizationPermissions instance
func NewOrganizationPermissions() OrganizationPermissions {
	return &OrganizationPermissionsImpl{}
}

// An indicator of whether the user has control over the persons list in organization.
// Example: true
func (s OrganizationPermissionsImpl) CanEditPersonsLists() *bool {
	return s.CanEditPersonsListsValue
}

// An indicator of whether the user has control over the persons list in organization.
// Example: true
func (s *OrganizationPermissionsImpl) SetCanEditPersonsLists(v bool) OrganizationPermissions {
	if s == nil {
		return nil
	}
	s.CanEditPersonsListsValue = &v
	return s
}

// An indicator of whether the user has control over the streams.
// Example: true
func (s OrganizationPermissionsImpl) CanEditStreams() *bool {
	return s.CanEditStreamsValue
}

// An indicator of whether the user has control over the streams.
// Example: true
func (s *OrganizationPermissionsImpl) SetCanEditStreams(v bool) OrganizationPermissions {
	if s == nil {
		return nil
	}
	s.CanEditStreamsValue = &v
	return s
}

// An indicator of whether the user has control over the users.
// Example: true
func (s OrganizationPermissionsImpl) CanEditUsers() *bool {
	return s.CanEditUsersValue
}

// An indicator of whether the user has control over the users.
// Example: true
func (s *OrganizationPermissionsImpl) SetCanEditUsers(v bool) OrganizationPermissions {
	if s == nil {
		return nil
	}
	s.CanEditUsersValue = &v
	return s
}

// An indicator of whether the user can view persons list in organization.
// Example: true
func (s OrganizationPermissionsImpl) CanViewPersonsLists() *bool {
	return s.CanViewPersonsListsValue
}

// An indicator of whether the user can view persons list in organization.
// Example: true
func (s *OrganizationPermissionsImpl) SetCanViewPersonsLists(v bool) OrganizationPermissions {
	if s == nil {
		return nil
	}
	s.CanViewPersonsListsValue = &v
	return s
}

// An indicator of whether the user can view statistics of organization.
// Example: true
func (s OrganizationPermissionsImpl) CanViewStats() *bool {
	return s.CanViewStatsValue
}

// An indicator of whether the user can view statistics of organization.
// Example: true
func (s *OrganizationPermissionsImpl) SetCanViewStats(v bool) OrganizationPermissions {
	if s == nil {
		return nil
	}
	s.CanViewStatsValue = &v
	return s
}

// An indicator of whether the user can view the streams.
// Example: true
func (s OrganizationPermissionsImpl) CanViewStreams() *bool {
	return s.CanViewStreamsValue
}

// An indicator of whether the user can view the streams.
// Example: true
func (s *OrganizationPermissionsImpl) SetCanViewStreams(v bool) OrganizationPermissions {
	if s == nil {
		return nil
	}
	s.CanViewStreamsValue = &v
	return s
}

// Is the user a member of the organization.
// Example: true
func (s OrganizationPermissionsImpl) IsMember() *bool {
	return s.IsMemberValue
}

// Is the user a member of the organization.
// Example: true
func (s *OrganizationPermissionsImpl) SetIsMember(v bool) OrganizationPermissions {
	if s == nil {
		return nil
	}
	s.IsMemberValue = &v
	return s
}

// NewOrganizationPreset creates a new OrganizationPreset instance
func NewOrganizationPreset() OrganizationPreset {
	return &OrganizationPresetImpl{}
}

// Preset identifier
// Example: 7
func (s OrganizationPresetImpl) PresetID() *int {
	return s.PresetIDValue
}

// Preset identifier
// Example: 7
func (s *OrganizationPresetImpl) SetPresetID(v int) OrganizationPreset {
	if s == nil {
		return nil
	}
	s.PresetIDValue = &v
	return s
}

// NewOrganizationStream creates a new OrganizationStream instance
func NewOrganizationStream() OrganizationStream {
	return &OrganizationStreamImpl{}
}

// ID of the organization. Only organization owner or domain administrator could change it.
// Example: 9
func (s OrganizationStreamImpl) ID() *int {
	return s.IDValue
}

// ID of the organization. Only organization owner or domain administrator could change it.
// Example: 9
func (s *OrganizationStreamImpl) SetID(v int) OrganizationStream {
	if s == nil {
		return nil
	}
	s.IDValue = &v
	return s
}

// Title of the organization.
// Example: Organization 1
func (s OrganizationStreamImpl) Title() *string {
	return s.TitleValue
}

// Title of the organization.
// Example: Organization 1
func (s *OrganizationStreamImpl) SetTitle(v string) OrganizationStream {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// NewOutputMpegtsPids creates a new OutputMpegtsPids instance
func NewOutputMpegtsPids() OutputMpegtsPids {
	return &OutputMpegtsPidsImpl{}
}

// The default algorithm of selecting PID for a track.
// * `auto`: track PID = PMT PID + track ID,
// where PMT PID is the PID of Program Map Table and track ID is a number of the track set by Flussonic
// (usually, all video tracks and then all audio tracks are numbered starting from 1).
// * `increment`: track PID = previous track PID + 1.
func (s OutputMpegtsPidsImpl) Default() *string {
	return s.DefaultValue
}

// The default algorithm of selecting PID for a track.
// * `auto`: track PID = PMT PID + track ID,
// where PMT PID is the PID of Program Map Table and track ID is a number of the track set by Flussonic
// (usually, all video tracks and then all audio tracks are numbered starting from 1).
// * `increment`: track PID = previous track PID + 1.
func (s *OutputMpegtsPidsImpl) SetDefault(v string) OutputMpegtsPids {
	if s == nil {
		return nil
	}
	s.DefaultValue = &v
	return s
}

// Information about a particular media track.
func (s OutputMpegtsPidsImpl) Media() []TransponderPid {
	if s.MediaValue == nil {
		return nil
	}
	result := make([]TransponderPid, len(s.MediaValue))
	for i, item := range s.MediaValue {
		result[i] = item
	}
	return result
}

// Information about a particular media track.
func (s *OutputMpegtsPidsImpl) SetMedia(v []TransponderPid) OutputMpegtsPids {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*TransponderPidImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*TransponderPidImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.MediaValue = impl
	}
	return s
}

// PID of the elementary stream that contains PCR (Program Clock Reference) in the outgoing MPEG-TS stream.
// PCR is the time label used for synchronization of a stream playback with real time.
// Additionally, for DVB streams it is used for managing a decoder and its buffer.
// In this case, PCR gives a signal to the frames with DTS<PCR to be sent to the decoder from the buffer.
// This mechanism allows to compensate different sizes of frames: if a frame is too big to be played in time with a specified FPS, the frames from the buffer are played.
func (s OutputMpegtsPidsImpl) Pcr() *int {
	return s.PcrValue
}

// PID of the elementary stream that contains PCR (Program Clock Reference) in the outgoing MPEG-TS stream.
// PCR is the time label used for synchronization of a stream playback with real time.
// Additionally, for DVB streams it is used for managing a decoder and its buffer.
// In this case, PCR gives a signal to the frames with DTS<PCR to be sent to the decoder from the buffer.
// This mechanism allows to compensate different sizes of frames: if a frame is too big to be played in time with a specified FPS, the frames from the buffer are played.
func (s *OutputMpegtsPidsImpl) SetPcr(v int) OutputMpegtsPids {
	if s == nil {
		return nil
	}
	s.PcrValue = &v
	return s
}

// PID  of the elementary stream that contains Program Map Table (PMT) in the outgoing MPEG-TS stream.
// PMT contains the description of each program and lists the PIDs of elementary streams associated with that program.
// For instance, a transport stream used in digital television might contain three programs, to represent three television channels.
// Suppose each channel consists of one video stream, one or two audio streams, and any necessary metadata.
// A receiver wishing to decode one of the three channels merely has to decode the payloads of each PID associated with its program.
// It can discard the contents of all other PIDs.
func (s OutputMpegtsPidsImpl) Pmt() *int {
	return s.PmtValue
}

// PID  of the elementary stream that contains Program Map Table (PMT) in the outgoing MPEG-TS stream.
// PMT contains the description of each program and lists the PIDs of elementary streams associated with that program.
// For instance, a transport stream used in digital television might contain three programs, to represent three television channels.
// Suppose each channel consists of one video stream, one or two audio streams, and any necessary metadata.
// A receiver wishing to decode one of the three channels merely has to decode the payloads of each PID associated with its program.
// It can discard the contents of all other PIDs.
func (s *OutputMpegtsPidsImpl) SetPmt(v int) OutputMpegtsPids {
	if s == nil {
		return nil
	}
	s.PmtValue = &v
	return s
}

// PID  of the elementary stream that contains Service Description Table (SDT) in the outgoing MPEG-TS stream.
// SDT provides information about services contained in MPEG-TS stream.
func (s OutputMpegtsPidsImpl) Sdt() *int {
	return s.SdtValue
}

// PID  of the elementary stream that contains Service Description Table (SDT) in the outgoing MPEG-TS stream.
// SDT provides information about services contained in MPEG-TS stream.
func (s *OutputMpegtsPidsImpl) SetSdt(v int) OutputMpegtsPids {
	if s == nil {
		return nil
	}
	s.SdtValue = &v
	return s
}

// NewPartitionStats creates a new PartitionStats instance
func NewPartitionStats() PartitionStats {
	return &PartitionStatsImpl{}
}

// The block device or file related to a mount path.
// Format: disk_device (disk_device)
// Example: sda1
func (s PartitionStatsImpl) Device() *DiskDevice {
	return s.DeviceValue
}

// The block device or file related to a mount path.
// Format: disk_device (disk_device)
// Example: sda1
func (s *PartitionStatsImpl) SetDevice(v DiskDevice) PartitionStats {
	if s == nil {
		return nil
	}
	s.DeviceValue = &v
	return s
}

// Percentage of IO utilization for device related to a mount path.
// Format: percent (percent)
// Example: 42
func (s PartitionStatsImpl) IoUtil() *Percent {
	return s.IoUtilValue
}

// Percentage of IO utilization for device related to a mount path.
// Format: percent (percent)
// Example: 42
func (s *PartitionStatsImpl) SetIoUtil(v Percent) PartitionStats {
	if s == nil {
		return nil
	}
	s.IoUtilValue = &v
	return s
}

// Mount path.
// Format: disk_path (disk_path)
// Example: _var_lib_docker_overlay2_3684778579db0a4d418fdc1a8a6953b680ab92d179a7d6f9506710d073095e36_merged
func (s PartitionStatsImpl) Path() *DiskPath {
	return s.PathValue
}

// Mount path.
// Format: disk_path (disk_path)
// Example: _var_lib_docker_overlay2_3684778579db0a4d418fdc1a8a6953b680ab92d179a7d6f9506710d073095e36_merged
func (s *PartitionStatsImpl) SetPath(v DiskPath) PartitionStats {
	if s == nil {
		return nil
	}
	s.PathValue = &v
	return s
}

// Total number of megabytes shown by the OS for this partition.
// Format: megabytes (megabytes)
// Example: 45423
func (s PartitionStatsImpl) TotalMb() *Megabytes {
	return s.TotalMbValue
}

// Total number of megabytes shown by the OS for this partition.
// Format: megabytes (megabytes)
// Example: 45423
func (s *PartitionStatsImpl) SetTotalMb(v Megabytes) PartitionStats {
	if s == nil {
		return nil
	}
	s.TotalMbValue = &v
	return s
}

// Percentage of usage of this partition.
// Format: percent (percent)
// Example: 30
func (s PartitionStatsImpl) Usage() *Percent {
	return s.UsageValue
}

// Percentage of usage of this partition.
// Format: percent (percent)
// Example: 30
func (s *PartitionStatsImpl) SetUsage(v Percent) PartitionStats {
	if s == nil {
		return nil
	}
	s.UsageValue = &v
	return s
}

// NewPeerConfig creates a new PeerConfig instance
func NewPeerConfig() PeerConfig {
	return &PeerConfigImpl{}
}

// The URL for provisioning of configuration from the managing server to the streamer.
// This URL does not have to be public but must be accessible from the managing server.
// The API URL can also be used as Public and/or Private payload URL if they are not set.
// When used as Public payload URL, the API URL shall be public to allow playback from this streamer.
// Format: url (url)
// Example: http://streamer.local:8080
func (s PeerConfigImpl) APIURL() *URL {
	return s.APIURLValue
}

// The URL for provisioning of configuration from the managing server to the streamer.
// This URL does not have to be public but must be accessible from the managing server.
// The API URL can also be used as Public and/or Private payload URL if they are not set.
// When used as Public payload URL, the API URL shall be public to allow playback from this streamer.
// Format: url (url)
// Example: http://streamer.local:8080
func (s *PeerConfigImpl) SetAPIURL(v URL) PeerConfig {
	if s == nil {
		return nil
	}
	s.APIURLValue = &v
	return s
}

// Maximal number of streams.
// Example: 5
func (s PeerConfigImpl) ChannelLimit() *int {
	return s.ChannelLimitValue
}

// Maximal number of streams.
// Example: 5
func (s *PeerConfigImpl) SetChannelLimit(v int) PeerConfig {
	if s == nil {
		return nil
	}
	s.ChannelLimitValue = &v
	return s
}

// The key for authorization for inter-Flussonic connections.
// All cluster peers should have the same cluster key.
// Example: xS6i6Q3DCc5nEvnu
func (s PeerConfigImpl) ClusterKey() *string {
	return s.ClusterKeyValue
}

// The key for authorization for inter-Flussonic connections.
// All cluster peers should have the same cluster key.
// Example: xS6i6Q3DCc5nEvnu
func (s *PeerConfigImpl) SetClusterKey(v string) PeerConfig {
	if s == nil {
		return nil
	}
	s.ClusterKeyValue = &v
	return s
}

// Streamer's identifier in the cluster.
// The managing server may try using this hostname to access the streamer
// if API URL is not specified.
// Format: server_name (server_name)
// Example: peer.example.com
func (s PeerConfigImpl) Hostname() *ServerName {
	return s.HostnameValue
}

// Streamer's identifier in the cluster.
// The managing server may try using this hostname to access the streamer
// if API URL is not specified.
// Format: server_name (server_name)
// Example: peer.example.com
func (s *PeerConfigImpl) SetHostname(v ServerName) PeerConfig {
	if s == nil {
		return nil
	}
	s.HostnameValue = &v
	return s
}

// Statistics on peers in the cluster.
func (s PeerConfigImpl) Stats() PeerStats {
	return s.StatsValue
}

// Statistics on peers in the cluster.
func (s *PeerConfigImpl) SetStats(v PeerStats) PeerConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*PeerStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// NewPeerStats creates a new PeerStats instance
func NewPeerStats() PeerStats {
	return &PeerStatsImpl{}
}

// Outbound bandwidth usage (load balancing in `usage` mode is based on this value).
// Format: percent (percent)
// Example: 67
func (s PeerStatsImpl) BandwidthUsage() *Percent {
	return s.BandwidthUsageValue
}

// Outbound bandwidth usage (load balancing in `usage` mode is based on this value).
// Format: percent (percent)
// Example: 67
func (s *PeerStatsImpl) SetBandwidthUsage(v Percent) PeerStats {
	if s == nil {
		return nil
	}
	s.BandwidthUsageValue = &v
	return s
}

// Build version
func (s PeerStatsImpl) Build() *int {
	return s.BuildValue
}

// Build version
func (s *PeerStatsImpl) SetBuild(v int) PeerStats {
	if s == nil {
		return nil
	}
	s.BuildValue = &v
	return s
}

// Information about errors in the config file.
func (s PeerStatsImpl) ConfigError() ConfigErrorStatus {
	return s.ConfigErrorValue
}

// Information about errors in the config file.
func (s *PeerStatsImpl) SetConfigError(v ConfigErrorStatus) PeerStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ConfigErrorStatusImpl); ok {
		s.ConfigErrorValue = impl
	}
	return s
}

// Information about current external config status
func (s PeerStatsImpl) ConfigExternalStatus() ConfigExternalErrorStatus {
	return s.ConfigExternalStatusValue
}

// Information about current external config status
func (s *PeerStatsImpl) SetConfigExternalStatus(v ConfigExternalErrorStatus) PeerStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ConfigExternalErrorStatusImpl); ok {
		s.ConfigExternalStatusValue = impl
	}
	return s
}

// Current runtime version of config. We do not declare exact structure, but we promise
// that it will be always comparable and increasing (if server has proper NTP configuration, of course).
// Right now it is a tuple of server start time and incrementing version of config.
// Example: [1.636709231e+09 4]
func (s PeerStatsImpl) ConfigVersion() []int {
	return s.ConfigVersionValue
}

// Current runtime version of config. We do not declare exact structure, but we promise
// that it will be always comparable and increasing (if server has proper NTP configuration, of course).
// Right now it is a tuple of server start time and incrementing version of config.
// Example: [1.636709231e+09 4]
func (s *PeerStatsImpl) SetConfigVersion(v []int) PeerStats {
	if s == nil {
		return nil
	}
	s.ConfigVersionValue = v
	return s
}

// CPU usage on the server.
// Format: percent (percent)
// Example: 48
func (s PeerStatsImpl) CpuUsage() *Percent {
	return s.CpuUsageValue
}

// CPU usage on the server.
// Format: percent (percent)
// Example: 48
func (s *PeerStatsImpl) SetCpuUsage(v Percent) PeerStats {
	if s == nil {
		return nil
	}
	s.CpuUsageValue = &v
	return s
}

// Description of an error, if any.
func (s PeerStatsImpl) Error() *string {
	return s.ErrorValue
}

// Description of an error, if any.
func (s *PeerStatsImpl) SetError(v string) PeerStats {
	if s == nil {
		return nil
	}
	s.ErrorValue = &v
	return s
}

// Hostname of your server. Please, use FQDN, do not leave your Linux misconfigured.
// Example: openapi.flussonic.com
func (s PeerStatsImpl) Hostname() *string {
	return s.HostnameValue
}

// Hostname of your server. Please, use FQDN, do not leave your Linux misconfigured.
// Example: openapi.flussonic.com
func (s *PeerStatsImpl) SetHostname(v string) PeerStats {
	if s == nil {
		return nil
	}
	s.HostnameValue = &v
	return s
}

// Unique runtime ID of this instance. Updated with the restart.
// Format: uuid (uuid)
// Example: 61893b15-75b2-4fcb-b4cf-ae1dd0858ea2
func (s PeerStatsImpl) ID() *UUID {
	return s.IDValue
}

// Unique runtime ID of this instance. Updated with the restart.
// Format: uuid (uuid)
// Example: 61893b15-75b2-4fcb-b4cf-ae1dd0858ea2
func (s *PeerStatsImpl) SetID(v UUID) PeerStats {
	if s == nil {
		return nil
	}
	s.IDValue = &v
	return s
}

// Current incoming speed (bitrate) of the data transmission over the network.
// Format: speed (speed)
// Example: 400300
func (s PeerStatsImpl) InputKbit() *Speed {
	return s.InputKbitValue
}

// Current incoming speed (bitrate) of the data transmission over the network.
// Format: speed (speed)
// Example: 400300
func (s *PeerStatsImpl) SetInputKbit(v Speed) PeerStats {
	if s == nil {
		return nil
	}
	s.InputKbitValue = &v
	return s
}

// The flag shows if Flussonic runs on Flussonic Coder.
func (s PeerStatsImpl) IsChassis() *bool {
	return s.IsChassisValue
}

// The flag shows if Flussonic runs on Flussonic Coder.
func (s *PeerStatsImpl) SetIsChassis(v bool) PeerStats {
	if s == nil {
		return nil
	}
	s.IsChassisValue = &v
	return s
}

// The code of the license applied on the server.
// Example: uO8v12HJhNXVj5gM
func (s PeerStatsImpl) LicenseTxt() *string {
	return s.LicenseTxtValue
}

// The code of the license applied on the server.
// Example: uO8v12HJhNXVj5gM
func (s *PeerStatsImpl) SetLicenseTxt(v string) PeerStats {
	if s == nil {
		return nil
	}
	s.LicenseTxtValue = &v
	return s
}

// The license type.
func (s PeerStatsImpl) LicenseType() *LicenseType {
	return s.LicenseTypeValue
}

// The license type.
func (s *PeerStatsImpl) SetLicenseType(v LicenseType) PeerStats {
	if s == nil {
		return nil
	}
	s.LicenseTypeValue = &v
	return s
}

// Memory usage on the server.
// Format: percent (percent)
// Example: 27
func (s PeerStatsImpl) MemoryUsage() *Percent {
	return s.MemoryUsageValue
}

// Memory usage on the server.
// Format: percent (percent)
// Example: 27
func (s *PeerStatsImpl) SetMemoryUsage(v Percent) PeerStats {
	if s == nil {
		return nil
	}
	s.MemoryUsageValue = &v
	return s
}

// Notification about a newer version in the repository.
// Format: server_version (server_version)
// Example: 22.01
func (s PeerStatsImpl) NextVersion() *ServerVersion {
	return s.NextVersionValue
}

// Notification about a newer version in the repository.
// Format: server_version (server_version)
// Example: 22.01
func (s *PeerStatsImpl) SetNextVersion(v ServerVersion) PeerStats {
	if s == nil {
		return nil
	}
	s.NextVersionValue = &v
	return s
}

// Current response time
// Format: utc_ms (Unix timestamp in milliseconds)
func (s PeerStatsImpl) Now() *UtcMs {
	return s.NowValue
}

// Current response time
// Format: utc_ms (Unix timestamp in milliseconds)
func (s *PeerStatsImpl) SetNow(v UtcMs) PeerStats {
	if s == nil {
		return nil
	}
	s.NowValue = &v
	return s
}

// The number of streams that are ready to be served to the clients.
// Example: 27
func (s PeerStatsImpl) OnlineStreams() *int {
	return s.OnlineStreamsValue
}

// The number of streams that are ready to be served to the clients.
// Example: 27
func (s *PeerStatsImpl) SetOnlineStreams(v int) PeerStats {
	if s == nil {
		return nil
	}
	s.OnlineStreamsValue = &v
	return s
}

// The number of opened files.
// Example: 5
func (s PeerStatsImpl) OpenedFiles() *int {
	return s.OpenedFilesValue
}

// The number of opened files.
// Example: 5
func (s *PeerStatsImpl) SetOpenedFiles(v int) PeerStats {
	if s == nil {
		return nil
	}
	s.OpenedFilesValue = &v
	return s
}

// Current outgoing speed (bitrate) of the data transmission over the network.
// Format: speed (speed)
// Example: 500400
func (s PeerStatsImpl) OutputKbit() *Speed {
	return s.OutputKbitValue
}

// Current outgoing speed (bitrate) of the data transmission over the network.
// Format: speed (speed)
// Example: 500400
func (s *PeerStatsImpl) SetOutputKbit(v Speed) PeerStats {
	if s == nil {
		return nil
	}
	s.OutputKbitValue = &v
	return s
}

// The list of disk partitions on the server.
func (s PeerStatsImpl) Partitions() []PartitionStats {
	if s.PartitionsValue == nil {
		return nil
	}
	result := make([]PartitionStats, len(s.PartitionsValue))
	for i, item := range s.PartitionsValue {
		result[i] = item
	}
	return result
}

// The list of disk partitions on the server.
func (s *PeerStatsImpl) SetPartitions(v []PartitionStats) PeerStats {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*PartitionStatsImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*PartitionStatsImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.PartitionsValue = impl
	}
	return s
}

// Predictions of future stats based on the current state of the cluster.
func (s PeerStatsImpl) Predictions() PeerStatsPredictions {
	return s.PredictionsValue
}

// Predictions of future stats based on the current state of the cluster.
func (s *PeerStatsImpl) SetPredictions(v PeerStatsPredictions) PeerStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*PeerStatsPredictionsImpl); ok {
		s.PredictionsValue = impl
	}
	return s
}

// Shows if rproxy is configured.
func (s PeerStatsImpl) Rproxy() *bool {
	return s.RproxyValue
}

// Shows if rproxy is configured.
func (s *PeerStatsImpl) SetRproxy(v bool) PeerStats {
	if s == nil {
		return nil
	}
	s.RproxyValue = &v
	return s
}

// Shows if rproxy is running.
func (s PeerStatsImpl) RproxyRunning() *bool {
	return s.RproxyRunningValue
}

// Shows if rproxy is running.
func (s *PeerStatsImpl) SetRproxyRunning(v bool) PeerStats {
	if s == nil {
		return nil
	}
	s.RproxyRunningValue = &v
	return s
}

// Erlang scheduler load.
// Format: percent (percent)
// Example: 40
func (s PeerStatsImpl) SchedulerLoad() *Percent {
	return s.SchedulerLoadValue
}

// Erlang scheduler load.
// Format: percent (percent)
// Example: 40
func (s *PeerStatsImpl) SetSchedulerLoad(v Percent) PeerStats {
	if s == nil {
		return nil
	}
	s.SchedulerLoadValue = &v
	return s
}

// Package version of the server. Might be simple a number of release like 21.11 or longer if you have a rolling release installed.
// Format: server_version (server_version)
// Example: 23.04
func (s PeerStatsImpl) ServerVersion() *ServerVersion {
	return s.ServerVersionValue
}

// Package version of the server. Might be simple a number of release like 21.11 or longer if you have a rolling release installed.
// Format: server_version (server_version)
// Example: 23.04
func (s *PeerStatsImpl) SetServerVersion(v ServerVersion) PeerStats {
	if s == nil {
		return nil
	}
	s.ServerVersionValue = &v
	return s
}

// Boot time of this instance.
// Format: utc (Unix timestamp in seconds)
// Example: 1.639337825e+09
func (s PeerStatsImpl) StartedAt() *Utc {
	return s.StartedAtValue
}

// Boot time of this instance.
// Format: utc (Unix timestamp in seconds)
// Example: 1.639337825e+09
func (s *PeerStatsImpl) SetStartedAt(v Utc) PeerStats {
	if s == nil {
		return nil
	}
	s.StartedAtValue = &v
	return s
}

// *Flussonic* will always try to start even if there are severe errors that do not
// allow functioning.
// `starting` status means you should wait for some time (not more than
// a minute).
// `running` status means all configuration was loaded. However, the status does not provide
// an information about your streams and the quality of provided service.
// All other statuses mean there are some severe problems on the server
// that cannot be repaired by Flussonic itself.
func (s PeerStatsImpl) StreamerStatus() *ServerStatsStreamerStatus {
	return s.StreamerStatusValue
}

// *Flussonic* will always try to start even if there are severe errors that do not
// allow functioning.
// `starting` status means you should wait for some time (not more than
// a minute).
// `running` status means all configuration was loaded. However, the status does not provide
// an information about your streams and the quality of provided service.
// All other statuses mean there are some severe problems on the server
// that cannot be repaired by Flussonic itself.
func (s *PeerStatsImpl) SetStreamerStatus(v ServerStatsStreamerStatus) PeerStats {
	if s == nil {
		return nil
	}
	s.StreamerStatusValue = &v
	return s
}

// Human-readable format of errors and alerts that need to be fixed.
// Provided by some *Flussonic* subsystems.
func (s PeerStatsImpl) TextAlerts() map[string]string {
	return s.TextAlertsValue
}

// Human-readable format of errors and alerts that need to be fixed.
// Provided by some *Flussonic* subsystems.
func (s *PeerStatsImpl) SetTextAlerts(v map[string]string) PeerStats {
	if s == nil {
		return nil
	}
	s.TextAlertsValue = v
	return s
}

// Deprecated field. Will be deleted at 22.03
// Total server bandwidth.
// Format: speed (speed)
func (s PeerStatsImpl) TotalBandwidth() *Speed {
	return s.TotalBandwidthValue
}

// Deprecated field. Will be deleted at 22.03
// Total server bandwidth.
// Format: speed (speed)
func (s *PeerStatsImpl) SetTotalBandwidth(v Speed) PeerStats {
	if s == nil {
		return nil
	}
	s.TotalBandwidthValue = &v
	return s
}

// The number of clients receiving the streams from the server at the moment of request.
// Example: 2040
func (s PeerStatsImpl) TotalClients() *int {
	return s.TotalClientsValue
}

// The number of clients receiving the streams from the server at the moment of request.
// Example: 2040
func (s *PeerStatsImpl) SetTotalClients(v int) PeerStats {
	if s == nil {
		return nil
	}
	s.TotalClientsValue = &v
	return s
}

// The number of streams created on the server.
// Example: 45
func (s PeerStatsImpl) TotalStreams() *int {
	return s.TotalStreamsValue
}

// The number of streams created on the server.
// Example: 45
func (s *PeerStatsImpl) SetTotalStreams(v int) PeerStats {
	if s == nil {
		return nil
	}
	s.TotalStreamsValue = &v
	return s
}

// Shows if the server's CPU can be used for transcoding
// (i.e. if the `flussonic-transcoder` package is installed on the server).
func (s PeerStatsImpl) Transcoder() *bool {
	return s.TranscoderValue
}

// Shows if the server's CPU can be used for transcoding
// (i.e. if the `flussonic-transcoder` package is installed on the server).
func (s *PeerStatsImpl) SetTranscoder(v bool) PeerStats {
	if s == nil {
		return nil
	}
	s.TranscoderValue = &v
	return s
}

// Statistics on the devices used for transcoding.
func (s PeerStatsImpl) TranscoderDevices() []TranscoderDeviceStats {
	if s.TranscoderDevicesValue == nil {
		return nil
	}
	result := make([]TranscoderDeviceStats, len(s.TranscoderDevicesValue))
	for i, item := range s.TranscoderDevicesValue {
		result[i] = item
	}
	return result
}

// Statistics on the devices used for transcoding.
func (s *PeerStatsImpl) SetTranscoderDevices(v []TranscoderDeviceStats) PeerStats {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*TranscoderDeviceStatsImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*TranscoderDeviceStatsImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.TranscoderDevicesValue = impl
	}
	return s
}

// The server uptime.
// Format: seconds (seconds)
// Example: 4.325502e+06
func (s PeerStatsImpl) Uptime() *Seconds {
	return s.UptimeValue
}

// The server uptime.
// Format: seconds (seconds)
// Example: 4.325502e+06
func (s *PeerStatsImpl) SetUptime(v Seconds) PeerStats {
	if s == nil {
		return nil
	}
	s.UptimeValue = &v
	return s
}

// Shows if Flussonic Watcher is enabled in the license.
func (s PeerStatsImpl) Vsaas() *bool {
	return s.VsaasValue
}

// Shows if Flussonic Watcher is enabled in the license.
func (s *PeerStatsImpl) SetVsaas(v bool) PeerStats {
	if s == nil {
		return nil
	}
	s.VsaasValue = &v
	return s
}

// Shows if Watcher branding is enabled in the license.
func (s PeerStatsImpl) VsaasBranding() *bool {
	return s.VsaasBrandingValue
}

// Shows if Watcher branding is enabled in the license.
func (s *PeerStatsImpl) SetVsaasBranding(v bool) PeerStats {
	if s == nil {
		return nil
	}
	s.VsaasBrandingValue = &v
	return s
}

// Shows if Watcher is currently running.
func (s PeerStatsImpl) VsaasRunning() *bool {
	return s.VsaasRunningValue
}

// Shows if Watcher is currently running.
func (s *PeerStatsImpl) SetVsaasRunning(v bool) PeerStats {
	if s == nil {
		return nil
	}
	s.VsaasRunningValue = &v
	return s
}

// NewPeerStatsPredictions creates a new PeerStatsPredictions instance
func NewPeerStatsPredictions() PeerStatsPredictions {
	return &PeerStatsPredictionsImpl{}
}

func (s PeerStatsPredictionsImpl) Disk() CentralDiskPredictions {
	return s.DiskValue
}

func (s *PeerStatsPredictionsImpl) SetDisk(v CentralDiskPredictions) PeerStatsPredictions {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*CentralDiskPredictionsImpl); ok {
		s.DiskValue = impl
	}
	return s
}

// NewPlayProtocolsSpec creates a new PlayProtocolsSpec instance
func NewPlayProtocolsSpec() PlayProtocolsSpec {
	return &PlayProtocolsSpecImpl{}
}

// Whether to allow or deny API requests, depending on the `whitelist` properties.
func (s PlayProtocolsSpecImpl) API() *bool {
	return s.APIValue
}

// Whether to allow or deny API requests, depending on the `whitelist` properties.
func (s *PlayProtocolsSpecImpl) SetAPI(v bool) PlayProtocolsSpec {
	if s == nil {
		return nil
	}
	s.APIValue = &v
	return s
}

// Whether to allow or deny an LL-HLS stream playback, depending on the `whitelist` properties.
func (s PlayProtocolsSpecImpl) Cmaf() *bool {
	return s.CmafValue
}

// Whether to allow or deny an LL-HLS stream playback, depending on the `whitelist` properties.
func (s *PlayProtocolsSpecImpl) SetCmaf(v bool) PlayProtocolsSpec {
	if s == nil {
		return nil
	}
	s.CmafValue = &v
	return s
}

// Whether to allow or deny a DASH stream playback, depending on the `whitelist` properties.
func (s PlayProtocolsSpecImpl) Dash() *bool {
	return s.DashValue
}

// Whether to allow or deny a DASH stream playback, depending on the `whitelist` properties.
func (s *PlayProtocolsSpecImpl) SetDash(v bool) PlayProtocolsSpec {
	if s == nil {
		return nil
	}
	s.DashValue = &v
	return s
}

// Whether to allow or deny an HLS stream playback, depending on the `whitelist` properties.
func (s PlayProtocolsSpecImpl) Hls() *bool {
	return s.HlsValue
}

// Whether to allow or deny an HLS stream playback, depending on the `whitelist` properties.
func (s *PlayProtocolsSpecImpl) SetHls(v bool) PlayProtocolsSpec {
	if s == nil {
		return nil
	}
	s.HlsValue = &v
	return s
}

// Whether to allow or deny delivering JPEG thumbnails over HTTP(S), depending on the `whitelist` properties.
func (s PlayProtocolsSpecImpl) Jpeg() *bool {
	return s.JpegValue
}

// Whether to allow or deny delivering JPEG thumbnails over HTTP(S), depending on the `whitelist` properties.
func (s *PlayProtocolsSpecImpl) SetJpeg(v bool) PlayProtocolsSpec {
	if s == nil {
		return nil
	}
	s.JpegValue = &v
	return s
}

// Whether to allow or deny an M4F stream playback, depending on the `whitelist` properties.
func (s PlayProtocolsSpecImpl) M4f() *bool {
	return s.M4fValue
}

// Whether to allow or deny an M4F stream playback, depending on the `whitelist` properties.
func (s *PlayProtocolsSpecImpl) SetM4f(v bool) PlayProtocolsSpec {
	if s == nil {
		return nil
	}
	s.M4fValue = &v
	return s
}

// Whether to allow or deny an M4S stream playback, depending on the `whitelist` properties.
func (s PlayProtocolsSpecImpl) M4s() *bool {
	return s.M4sValue
}

// Whether to allow or deny an M4S stream playback, depending on the `whitelist` properties.
func (s *PlayProtocolsSpecImpl) SetM4s(v bool) PlayProtocolsSpec {
	if s == nil {
		return nil
	}
	s.M4sValue = &v
	return s
}

// Whether to allow or deny an MP4 file download over HTTP(S), depending on the `whitelist` properties.
// Used to export DVR segment(s) in MP4 file.
func (s PlayProtocolsSpecImpl) Mp4() *bool {
	return s.Mp4Value
}

// Whether to allow or deny an MP4 file download over HTTP(S), depending on the `whitelist` properties.
// Used to export DVR segment(s) in MP4 file.
func (s *PlayProtocolsSpecImpl) SetMp4(v bool) PlayProtocolsSpec {
	if s == nil {
		return nil
	}
	s.Mp4Value = &v
	return s
}

// Whether to allow or deny an MSE-LD stream playback, depending on the `whitelist` properties.
func (s PlayProtocolsSpecImpl) Mseld() *bool {
	return s.MseldValue
}

// Whether to allow or deny an MSE-LD stream playback, depending on the `whitelist` properties.
func (s *PlayProtocolsSpecImpl) SetMseld(v bool) PlayProtocolsSpec {
	if s == nil {
		return nil
	}
	s.MseldValue = &v
	return s
}

// Whether to allow or deny an MSS stream playback, depending on the `whitelist` properties.
func (s PlayProtocolsSpecImpl) Mss() *bool {
	return s.MssValue
}

// Whether to allow or deny an MSS stream playback, depending on the `whitelist` properties.
func (s *PlayProtocolsSpecImpl) SetMss(v bool) PlayProtocolsSpec {
	if s == nil {
		return nil
	}
	s.MssValue = &v
	return s
}

// Whether to allow or deny playback in embed.html, depending on the `whitelist` properties.
func (s PlayProtocolsSpecImpl) Player() *bool {
	return s.PlayerValue
}

// Whether to allow or deny playback in embed.html, depending on the `whitelist` properties.
func (s *PlayProtocolsSpecImpl) SetPlayer(v bool) PlayProtocolsSpec {
	if s == nil {
		return nil
	}
	s.PlayerValue = &v
	return s
}

// Whether to allow or deny an RTMP stream playback, depending on the `whitelist` properties.
func (s PlayProtocolsSpecImpl) Rtmp() *bool {
	return s.RtmpValue
}

// Whether to allow or deny an RTMP stream playback, depending on the `whitelist` properties.
func (s *PlayProtocolsSpecImpl) SetRtmp(v bool) PlayProtocolsSpec {
	if s == nil {
		return nil
	}
	s.RtmpValue = &v
	return s
}

// Whether to allow or deny an RTSP stream playback, depending on the `whitelist` properties.
func (s PlayProtocolsSpecImpl) Rtsp() *bool {
	return s.RtspValue
}

// Whether to allow or deny an RTSP stream playback, depending on the `whitelist` properties.
func (s *PlayProtocolsSpecImpl) SetRtsp(v bool) PlayProtocolsSpec {
	if s == nil {
		return nil
	}
	s.RtspValue = &v
	return s
}

// Whether to allow or deny a SHOUTcast/Icecast stream playback, depending on the `whitelist` properties.
func (s PlayProtocolsSpecImpl) Shoutcast() *bool {
	return s.ShoutcastValue
}

// Whether to allow or deny a SHOUTcast/Icecast stream playback, depending on the `whitelist` properties.
func (s *PlayProtocolsSpecImpl) SetShoutcast(v bool) PlayProtocolsSpec {
	if s == nil {
		return nil
	}
	s.ShoutcastValue = &v
	return s
}

// Whether to allow or deny an SRT stream playback, depending on the `whitelist` properties.
func (s PlayProtocolsSpecImpl) Srt() *bool {
	return s.SrtValue
}

// Whether to allow or deny an SRT stream playback, depending on the `whitelist` properties.
func (s *PlayProtocolsSpecImpl) SetSrt(v bool) PlayProtocolsSpec {
	if s == nil {
		return nil
	}
	s.SrtValue = &v
	return s
}

// Whether to allow or deny an MPEG-TS stream playback over HTTP(S), depending on the `whitelist` properties.
func (s PlayProtocolsSpecImpl) Tshttp() *bool {
	return s.TshttpValue
}

// Whether to allow or deny an MPEG-TS stream playback over HTTP(S), depending on the `whitelist` properties.
func (s *PlayProtocolsSpecImpl) SetTshttp(v bool) PlayProtocolsSpec {
	if s == nil {
		return nil
	}
	s.TshttpValue = &v
	return s
}

// Whether to allow or deny an WebRTC stream playback, depending on the `whitelist` properties.
func (s PlayProtocolsSpecImpl) Webrtc() *bool {
	return s.WebrtcValue
}

// Whether to allow or deny an WebRTC stream playback, depending on the `whitelist` properties.
func (s *PlayProtocolsSpecImpl) SetWebrtc(v bool) PlayProtocolsSpec {
	if s == nil {
		return nil
	}
	s.WebrtcValue = &v
	return s
}

// - If set to `True`, server **allows** a playback only for listed protocols;
// - If set to `False`, server **forbids** a playback only for listed protocols;
func (s PlayProtocolsSpecImpl) Whitelist() *bool {
	return s.WhitelistValue
}

// - If set to `True`, server **allows** a playback only for listed protocols;
// - If set to `False`, server **forbids** a playback only for listed protocols;
func (s *PlayProtocolsSpecImpl) SetWhitelist(v bool) PlayProtocolsSpec {
	if s == nil {
		return nil
	}
	s.WhitelistValue = &v
	return s
}

// NewPreset creates a new Preset instance
func NewPreset() Preset {
	return &PresetImpl{}
}

// When this preset was marked as deleted
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637095014573e+12
func (s PresetImpl) DeletedAt() *UtcMs {
	return s.DeletedAtValue
}

// When this preset was marked as deleted
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637095014573e+12
func (s *PresetImpl) SetDeletedAt(v UtcMs) Preset {
	if s == nil {
		return nil
	}
	s.DeletedAtValue = &v
	return s
}

// DVR configuration
func (s PresetImpl) Dvr() StreamDvrSpec {
	return s.DvrValue
}

// DVR configuration
func (s *PresetImpl) SetDvr(v StreamDvrSpec) Preset {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*StreamDvrSpecImpl); ok {
		s.DvrValue = impl
	}
	return s
}

// Preset identifier
// Example: 7
func (s PresetImpl) ID() int {
	return s.IDValue
}

// Preset identifier
// Example: 7
func (s *PresetImpl) SetID(v int) Preset {
	if s == nil {
		return nil
	}
	s.IDValue = v
	return s
}

// Shows if the preset is adjustable.
// ```is_adjustable``` is needed for a situation where presets are managed by external billing.
// If ```is_adjustable: true``` user can change camera settings meanwhile using this preset.
// If ```is_adjustable: false``` user can not change camera settings meanwhile using this preset.
// If the camera has a non-adjustable presets, the DVR and analytics parameters from PUT requests will not be applied.
// In this case, either make the preset adjustable, or change the preset itself to achieve the required configuration.
// Example: true
func (s PresetImpl) IsAdjustable() *bool {
	return s.IsAdjustableValue
}

// Shows if the preset is adjustable.
// ```is_adjustable``` is needed for a situation where presets are managed by external billing.
// If ```is_adjustable: true``` user can change camera settings meanwhile using this preset.
// If ```is_adjustable: false``` user can not change camera settings meanwhile using this preset.
// If the camera has a non-adjustable presets, the DVR and analytics parameters from PUT requests will not be applied.
// In this case, either make the preset adjustable, or change the preset itself to achieve the required configuration.
// Example: true
func (s *PresetImpl) SetIsAdjustable(v bool) Preset {
	if s == nil {
		return nil
	}
	s.IsAdjustableValue = &v
	return s
}

// Shows if the preset is available in all Organizations.
func (s PresetImpl) IsDefault() *bool {
	return s.IsDefaultValue
}

// Shows if the preset is available in all Organizations.
func (s *PresetImpl) SetIsDefault(v bool) Preset {
	if s == nil {
		return nil
	}
	s.IsDefaultValue = &v
	return s
}

// Information about the latest changes made to the preset configuration.
func (s PresetImpl) LastChange() PresetLastChange {
	return s.LastChangeValue
}

// Information about the latest changes made to the preset configuration.
func (s *PresetImpl) SetLastChange(v PresetLastChange) Preset {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*PresetLastChangeImpl); ok {
		s.LastChangeValue = impl
	}
	return s
}

// Zone configuration that will be applied to all new cameras when this preset is selected.
// If at least one zone with the specified name does not exist at the time of camera creation, the camera creation will fail.
// This field does not follow adjustable or non-adjustable rules.
// This zone configuration will be applied only to new cameras.
// When updating layout_rules in a preset, cameras linked to this preset will not update their layout_rules.
func (s PresetImpl) LayoutRules() StreamZoneConfig {
	return s.LayoutRulesValue
}

// Zone configuration that will be applied to all new cameras when this preset is selected.
// If at least one zone with the specified name does not exist at the time of camera creation, the camera creation will fail.
// This field does not follow adjustable or non-adjustable rules.
// This zone configuration will be applied only to new cameras.
// When updating layout_rules in a preset, cameras linked to this preset will not update their layout_rules.
func (s *PresetImpl) SetLayoutRules(v StreamZoneConfig) Preset {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*StreamZoneConfigImpl); ok {
		s.LayoutRulesValue = impl
	}
	return s
}

// Statistics of the preset.
func (s PresetImpl) Stats() PresetStats {
	return s.StatsValue
}

// Statistics of the preset.
func (s *PresetImpl) SetStats(v PresetStats) Preset {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*PresetStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// Human-readable name of the preset.
// Example: Example preset name
func (s PresetImpl) Title() string {
	return s.TitleValue
}

// Human-readable name of the preset.
// Example: Example preset name
func (s *PresetImpl) SetTitle(v string) Preset {
	if s == nil {
		return nil
	}
	s.TitleValue = v
	return s
}

// Vision configuration
func (s PresetImpl) Vision() VisionSpecPresets {
	return s.VisionValue
}

// Vision configuration
func (s *PresetImpl) SetVision(v VisionSpecPresets) Preset {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionSpecPresetsImpl); ok {
		s.VisionValue = impl
	}
	return s
}

// NewPresetLastChange creates a new PresetLastChange instance
func NewPresetLastChange() PresetLastChange {
	return &PresetLastChangeImpl{}
}

// The time when the last changes were made.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.672531199e+12
func (s PresetLastChangeImpl) UpdatedAt() *UtcMs {
	return s.UpdatedAtValue
}

// The time when the last changes were made.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.672531199e+12
func (s *PresetLastChangeImpl) SetUpdatedAt(v UtcMs) PresetLastChange {
	if s == nil {
		return nil
	}
	s.UpdatedAtValue = &v
	return s
}

// Information about the user who modified.
func (s PresetLastChangeImpl) User() PresetLastChangeUser {
	return s.UserValue
}

// Information about the user who modified.
func (s *PresetLastChangeImpl) SetUser(v PresetLastChangeUser) PresetLastChange {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*PresetLastChangeUserImpl); ok {
		s.UserValue = impl
	}
	return s
}

// NewPresetLastChangeUser creates a new PresetLastChangeUser instance
func NewPresetLastChangeUser() PresetLastChangeUser {
	return &PresetLastChangeUserImpl{}
}

// Identifier of the user.
// Example: 1
func (s PresetLastChangeUserImpl) ID() *int {
	return s.IDValue
}

// Identifier of the user.
// Example: 1
func (s *PresetLastChangeUserImpl) SetID(v int) PresetLastChangeUser {
	if s == nil {
		return nil
	}
	s.IDValue = &v
	return s
}

// User name (login)
// Example: admin
func (s PresetLastChangeUserImpl) Name() *string {
	return s.NameValue
}

// User name (login)
// Example: admin
func (s *PresetLastChangeUserImpl) SetName(v string) PresetLastChangeUser {
	if s == nil {
		return nil
	}
	s.NameValue = &v
	return s
}

// NewPresetStats creates a new PresetStats instance
func NewPresetStats() PresetStats {
	return &PresetStatsImpl{}
}

// Count of organizations are currently using this preset.
// Example: 12
func (s PresetStatsImpl) OrganizationsCount() *int {
	return s.OrganizationsCountValue
}

// Count of organizations are currently using this preset.
// Example: 12
func (s *PresetStatsImpl) SetOrganizationsCount(v int) PresetStats {
	if s == nil {
		return nil
	}
	s.OrganizationsCountValue = &v
	return s
}

// Count of streams are currently using this preset.
// Example: 12
func (s PresetStatsImpl) StreamsCount() *int {
	return s.StreamsCountValue
}

// Count of streams are currently using this preset.
// Example: 12
func (s *PresetStatsImpl) SetStreamsCount(v int) PresetStats {
	if s == nil {
		return nil
	}
	s.StreamsCountValue = &v
	return s
}

// NewPresetsList creates a new PresetsList instance
func NewPresetsList() PresetsList {
	return &PresetsListImpl{}
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s PresetsListImpl) EstimatedCount() *int {
	return s.EstimatedCountValue
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s *PresetsListImpl) SetEstimatedCount(v int) PresetsList {
	if s == nil {
		return nil
	}
	s.EstimatedCountValue = &v
	return s
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s PresetsListImpl) Next() *string {
	return s.NextValue
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s *PresetsListImpl) SetNext(v string) PresetsList {
	if s == nil {
		return nil
	}
	s.NextValue = &v
	return s
}

// List of presets.
func (s PresetsListImpl) Presets() []Preset {
	if s.PresetsValue == nil {
		return nil
	}
	result := make([]Preset, len(s.PresetsValue))
	for i, item := range s.PresetsValue {
		result[i] = item
	}
	return result
}

// List of presets.
func (s *PresetsListImpl) SetPresets(v []Preset) PresetsList {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*PresetImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*PresetImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.PresetsValue = impl
	}
	return s
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s PresetsListImpl) Prev() *string {
	return s.PrevValue
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s *PresetsListImpl) SetPrev(v string) PresetsList {
	if s == nil {
		return nil
	}
	s.PrevValue = &v
	return s
}

// An object with a list of different timings measured during this API call.
func (s PresetsListImpl) Timing() any {
	return s.TimingValue
}

// An object with a list of different timings measured during this API call.
func (s *PresetsListImpl) SetTiming(v any) PresetsList {
	if s == nil {
		return nil
	}
	s.TimingValue = v
	return s
}

// Collection returns the collection items from PresetsList
func (s PresetsListImpl) Collection() []Preset {
	return s.Presets()
}

// NewPushCounters creates a new PushCounters instance
func NewPushCounters() PushCounters {
	return &PushCountersImpl{}
}

// Total amount of bytes sent since the pusher was created.
// Format: bytes (bytes)
func (s PushCountersImpl) Bytes() *Bytes {
	return s.BytesValue
}

// Total amount of bytes sent since the pusher was created.
// Format: bytes (bytes)
func (s *PushCountersImpl) SetBytes(v Bytes) PushCounters {
	if s == nil {
		return nil
	}
	s.BytesValue = &v
	return s
}

// The encoded bytes count.
// Format: bytes (bytes)
func (s PushCountersImpl) EncodedBytes() *Bytes {
	return s.EncodedBytesValue
}

// The encoded bytes count.
// Format: bytes (bytes)
func (s *PushCountersImpl) SetEncodedBytes(v Bytes) PushCounters {
	if s == nil {
		return nil
	}
	s.EncodedBytesValue = &v
	return s
}

// How many times we've got 401 (unauthorized).
func (s PushCountersImpl) Errors401() *int {
	return s.Errors401Value
}

// How many times we've got 401 (unauthorized).
func (s *PushCountersImpl) SetErrors401(v int) PushCounters {
	if s == nil {
		return nil
	}
	s.Errors401Value = &v
	return s
}

// How many times we've got 403 (forbidden).
func (s PushCountersImpl) Errors403() *int {
	return s.Errors403Value
}

// How many times we've got 403 (forbidden).
func (s *PushCountersImpl) SetErrors403(v int) PushCounters {
	if s == nil {
		return nil
	}
	s.Errors403Value = &v
	return s
}

// How many times we've got 404 (enoent).
func (s PushCountersImpl) Errors404() *int {
	return s.Errors404Value
}

// How many times we've got 404 (enoent).
func (s *PushCountersImpl) SetErrors404(v int) PushCounters {
	if s == nil {
		return nil
	}
	s.Errors404Value = &v
	return s
}

// How many times we've got 409 (double_publish_denied).
func (s PushCountersImpl) Errors409() *int {
	return s.Errors409Value
}

// How many times we've got 409 (double_publish_denied).
func (s *PushCountersImpl) SetErrors409(v int) PushCounters {
	if s == nil {
		return nil
	}
	s.Errors409Value = &v
	return s
}

// How many times we've got 500 (server_error).
func (s PushCountersImpl) Errors500() *int {
	return s.Errors500Value
}

// How many times we've got 500 (server_error).
func (s *PushCountersImpl) SetErrors500(v int) PushCounters {
	if s == nil {
		return nil
	}
	s.Errors500Value = &v
	return s
}

// Number of errors during of audio frame decoding to raw format.
func (s PushCountersImpl) ErrorsAudioFrameDecode() *int {
	return s.ErrorsAudioFrameDecodeValue
}

// Number of errors during of audio frame decoding to raw format.
func (s *PushCountersImpl) SetErrorsAudioFrameDecode(v int) PushCounters {
	if s == nil {
		return nil
	}
	s.ErrorsAudioFrameDecodeValue = &v
	return s
}

// How many times pusher unexpectedly lost connection with peer
func (s PushCountersImpl) ErrorsConnectionLost() *int {
	return s.ErrorsConnectionLostValue
}

// How many times pusher unexpectedly lost connection with peer
func (s *PushCountersImpl) SetErrorsConnectionLost(v int) PushCounters {
	if s == nil {
		return nil
	}
	s.ErrorsConnectionLostValue = &v
	return s
}

// How many times internal device buffer was overflowed.
func (s PushCountersImpl) ErrorsDeviceBufferOverflow() *int {
	return s.ErrorsDeviceBufferOverflowValue
}

// How many times internal device buffer was overflowed.
func (s *PushCountersImpl) SetErrorsDeviceBufferOverflow(v int) PushCounters {
	if s == nil {
		return nil
	}
	s.ErrorsDeviceBufferOverflowValue = &v
	return s
}

// How much times pusher was unable to open (attach to) device for pushing
func (s PushCountersImpl) ErrorsDeviceNotOpened() *int {
	return s.ErrorsDeviceNotOpenedValue
}

// How much times pusher was unable to open (attach to) device for pushing
func (s *PushCountersImpl) SetErrorsDeviceNotOpened(v int) PushCounters {
	if s == nil {
		return nil
	}
	s.ErrorsDeviceNotOpenedValue = &v
	return s
}

// Number of dropped frames
func (s PushCountersImpl) ErrorsDroppedFrames() *int {
	return s.ErrorsDroppedFramesValue
}

// Number of dropped frames
func (s *PushCountersImpl) SetErrorsDroppedFrames(v int) PushCounters {
	if s == nil {
		return nil
	}
	s.ErrorsDroppedFramesValue = &v
	return s
}

// Number of dropped segments
func (s PushCountersImpl) ErrorsDroppedSegments() *int {
	return s.ErrorsDroppedSegmentsValue
}

// Number of dropped segments
func (s *PushCountersImpl) SetErrorsDroppedSegments(v int) PushCounters {
	if s == nil {
		return nil
	}
	s.ErrorsDroppedSegmentsValue = &v
	return s
}

// How many times pusher did not establish connection because of destination peer is not reached
func (s PushCountersImpl) ErrorsNoDestination() *int {
	return s.ErrorsNoDestinationValue
}

// How many times pusher did not establish connection because of destination peer is not reached
func (s *PushCountersImpl) SetErrorsNoDestination(v int) PushCounters {
	if s == nil {
		return nil
	}
	s.ErrorsNoDestinationValue = &v
	return s
}

// How many times pusher did not establish connection because of missing or wrong credentials
func (s PushCountersImpl) ErrorsNotAuthorized() *int {
	return s.ErrorsNotAuthorizedValue
}

// How many times pusher did not establish connection because of missing or wrong credentials
func (s *PushCountersImpl) SetErrorsNotAuthorized(v int) PushCounters {
	if s == nil {
		return nil
	}
	s.ErrorsNotAuthorizedValue = &v
	return s
}

// How many times pusher was stopped because of redirect limit is reached
func (s PushCountersImpl) ErrorsRedirectLimit() *int {
	return s.ErrorsRedirectLimitValue
}

// How many times pusher was stopped because of redirect limit is reached
func (s *PushCountersImpl) SetErrorsRedirectLimit(v int) PushCounters {
	if s == nil {
		return nil
	}
	s.ErrorsRedirectLimitValue = &v
	return s
}

// How many times pusher was stopped due to overload
func (s PushCountersImpl) ErrorsStopOverloaded() *int {
	return s.ErrorsStopOverloadedValue
}

// How many times pusher was stopped due to overload
func (s *PushCountersImpl) SetErrorsStopOverloaded(v int) PushCounters {
	if s == nil {
		return nil
	}
	s.ErrorsStopOverloadedValue = &v
	return s
}

// How many times pusher got TLS errors.
func (s PushCountersImpl) ErrorsTls() *int {
	return s.ErrorsTlsValue
}

// How many times pusher got TLS errors.
func (s *PushCountersImpl) SetErrorsTls(v int) PushCounters {
	if s == nil {
		return nil
	}
	s.ErrorsTlsValue = &v
	return s
}

// Number of errors during of video frame decoding to raw format.
func (s PushCountersImpl) ErrorsVideoFrameDecode() *int {
	return s.ErrorsVideoFrameDecodeValue
}

// Number of errors during of video frame decoding to raw format.
func (s *PushCountersImpl) SetErrorsVideoFrameDecode(v int) PushCounters {
	if s == nil {
		return nil
	}
	s.ErrorsVideoFrameDecodeValue = &v
	return s
}

// Number of frames sent by this pusher.
func (s PushCountersImpl) Frames() *int {
	return s.FramesValue
}

// Number of frames sent by this pusher.
func (s *PushCountersImpl) SetFrames(v int) PushCounters {
	if s == nil {
		return nil
	}
	s.FramesValue = &v
	return s
}

// SDI card output clock-lock state.
func (s PushCountersImpl) GenlockStatus() *GenlockStatus {
	return s.GenlockStatusValue
}

// SDI card output clock-lock state.
func (s *PushCountersImpl) SetGenlockStatus(v GenlockStatus) PushCounters {
	if s == nil {
		return nil
	}
	s.GenlockStatusValue = &v
	return s
}

// SDI card reference port (Ref In Port) status.
func (s PushCountersImpl) GenrefStatus() GenrefStatus {
	return s.GenrefStatusValue
}

// SDI card reference port (Ref In Port) status.
func (s *PushCountersImpl) SetGenrefStatus(v GenrefStatus) PushCounters {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*GenrefStatusImpl); ok {
		s.GenrefStatusValue = impl
	}
	return s
}

// The time in milliseconds when the pusher instance was created.
// Format: utc_ms (Unix timestamp in milliseconds)
func (s PushCountersImpl) OpenedAt() *UtcMs {
	return s.OpenedAtValue
}

// The time in milliseconds when the pusher instance was created.
// Format: utc_ms (Unix timestamp in milliseconds)
func (s *PushCountersImpl) SetOpenedAt(v UtcMs) PushCounters {
	if s == nil {
		return nil
	}
	s.OpenedAtValue = &v
	return s
}

// Per pid statistics for MPEG-TS encoding calculated for the pusher
func (s PushCountersImpl) Pids() []PushPidCounters {
	if s.PidsValue == nil {
		return nil
	}
	result := make([]PushPidCounters, len(s.PidsValue))
	for i, item := range s.PidsValue {
		result[i] = item
	}
	return result
}

// Per pid statistics for MPEG-TS encoding calculated for the pusher
func (s *PushCountersImpl) SetPids(v []PushPidCounters) PushCounters {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*PushPidCountersImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*PushPidCountersImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.PidsValue = impl
	}
	return s
}

// How many times there were no data to push in pusher queue
func (s PushCountersImpl) PusherQueueExhaustedCount() *int {
	return s.PusherQueueExhaustedCountValue
}

// How many times there were no data to push in pusher queue
func (s *PushCountersImpl) SetPusherQueueExhaustedCount(v int) PushCounters {
	if s == nil {
		return nil
	}
	s.PusherQueueExhaustedCountValue = &v
	return s
}

// How many times pusher was restarted
func (s PushCountersImpl) PusherRestarts() *int {
	return s.PusherRestartsValue
}

// How many times pusher was restarted
func (s *PushCountersImpl) SetPusherRestarts(v int) PushCounters {
	if s == nil {
		return nil
	}
	s.PusherRestartsValue = &v
	return s
}

// Number of retries since the last successful push.
func (s PushCountersImpl) ResentPackets() *int {
	return s.ResentPacketsValue
}

// Number of retries since the last successful push.
func (s *PushCountersImpl) SetResentPackets(v int) PushCounters {
	if s == nil {
		return nil
	}
	s.ResentPacketsValue = &v
	return s
}

// Number of segments sent by this pusher.
func (s PushCountersImpl) Segments() *int {
	return s.SegmentsValue
}

// Number of segments sent by this pusher.
func (s *PushCountersImpl) SetSegments(v int) PushCounters {
	if s == nil {
		return nil
	}
	s.SegmentsValue = &v
	return s
}

// State of the standby push.
func (s PushCountersImpl) StandbyStatus() *PusherStandbyStatus {
	return s.StandbyStatusValue
}

// State of the standby push.
func (s *PushCountersImpl) SetStandbyStatus(v PusherStandbyStatus) PushCounters {
	if s == nil {
		return nil
	}
	s.StandbyStatusValue = &v
	return s
}

// State of the push session.
func (s PushCountersImpl) Status() *PusherStatus {
	return s.StatusValue
}

// State of the push session.
func (s *PushCountersImpl) SetStatus(v *PusherStatus) PushCounters {
	if s == nil {
		return nil
	}
	s.StatusValue = v
	return s
}

// Deprecated field. Will be deleted at 26.03
// The fillers bytes count for system traffic. Currently this field is always zero.
// Format: bytes (bytes)
func (s PushCountersImpl) SysFillersBytes() *Bytes {
	return s.SysFillersBytesValue
}

// Deprecated field. Will be deleted at 26.03
// The fillers bytes count for system traffic. Currently this field is always zero.
// Format: bytes (bytes)
func (s *PushCountersImpl) SetSysFillersBytes(v Bytes) PushCounters {
	if s == nil {
		return nil
	}
	s.SysFillersBytesValue = &v
	return s
}

// The payload bytes count for system traffic.
// Format: bytes (bytes)
func (s PushCountersImpl) SysPayloadBytes() *Bytes {
	return s.SysPayloadBytesValue
}

// The payload bytes count for system traffic.
// Format: bytes (bytes)
func (s *PushCountersImpl) SetSysPayloadBytes(v Bytes) PushCounters {
	if s == nil {
		return nil
	}
	s.SysPayloadBytesValue = &v
	return s
}

// The stuff packets count for system traffic.
func (s PushCountersImpl) SysStuffingPackets() *int {
	return s.SysStuffingPacketsValue
}

// The stuff packets count for system traffic.
func (s *PushCountersImpl) SetSysStuffingPackets(v int) PushCounters {
	if s == nil {
		return nil
	}
	s.SysStuffingPacketsValue = &v
	return s
}

// Obfuscated URL where to push to
// Format: input_url (input_url)
func (s PushCountersImpl) URL() *InputURL {
	return s.URLValue
}

// Obfuscated URL where to push to
// Format: input_url (input_url)
func (s *PushCountersImpl) SetURL(v InputURL) PushCounters {
	if s == nil {
		return nil
	}
	s.URLValue = &v
	return s
}

// NewPushPidCounters creates a new PushPidCounters instance
func NewPushPidCounters() PushPidCounters {
	return &PushPidCountersImpl{}
}

// Bitrate on this PID, configured or autotuned.
// Format: speed (speed)
func (s PushPidCountersImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// Bitrate on this PID, configured or autotuned.
// Format: speed (speed)
func (s *PushPidCountersImpl) SetBitrate(v Speed) PushPidCounters {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// Content of the track (e.g. audio, video, text).
func (s PushPidCountersImpl) Content() *FrameContent {
	return s.ContentValue
}

// Content of the track (e.g. audio, video, text).
func (s *PushPidCountersImpl) SetContent(v FrameContent) PushPidCounters {
	if s == nil {
		return nil
	}
	s.ContentValue = &v
	return s
}

// Number of times a frame was dropped on this PID due to DTS going backward.
// Each such event currently triggers a full program reset.
func (s PushPidCountersImpl) ErrorsDtsGoesBackward() *int {
	return s.ErrorsDtsGoesBackwardValue
}

// Number of times a frame was dropped on this PID due to DTS going backward.
// Each such event currently triggers a full program reset.
func (s *PushPidCountersImpl) SetErrorsDtsGoesBackward(v int) PushPidCounters {
	if s == nil {
		return nil
	}
	s.ErrorsDtsGoesBackwardValue = &v
	return s
}

// Number of times a frame was dropped on this PID due to a forward DTS jump.
// Each such event currently triggers a full program reset.
func (s PushPidCountersImpl) ErrorsDtsJumpsForward() *int {
	return s.ErrorsDtsJumpsForwardValue
}

// Number of times a frame was dropped on this PID due to a forward DTS jump.
// Each such event currently triggers a full program reset.
func (s *PushPidCountersImpl) SetErrorsDtsJumpsForward(v int) PushPidCounters {
	if s == nil {
		return nil
	}
	s.ErrorsDtsJumpsForwardValue = &v
	return s
}

// Number of times this PID was dropped from the output multiplexed stream (e.g., due to prebuffer exhaustion).
func (s PushPidCountersImpl) ErrorsPidOff() *int {
	return s.ErrorsPidOffValue
}

// Number of times this PID was dropped from the output multiplexed stream (e.g., due to prebuffer exhaustion).
func (s *PushPidCountersImpl) SetErrorsPidOff(v int) PushPidCounters {
	if s == nil {
		return nil
	}
	s.ErrorsPidOffValue = &v
	return s
}

// Number of PID start errors caused by DTS values too far in the future.
// Each such event currently triggers a full program reset.
func (s PushPidCountersImpl) ErrorsStartFutureDts() *int {
	return s.ErrorsStartFutureDtsValue
}

// Number of PID start errors caused by DTS values too far in the future.
// Each such event currently triggers a full program reset.
func (s *PushPidCountersImpl) SetErrorsStartFutureDts(v int) PushPidCounters {
	if s == nil {
		return nil
	}
	s.ErrorsStartFutureDtsValue = &v
	return s
}

// Number of PID start errors caused by late DTS.
// Each such event currently triggers a full program reset.
func (s PushPidCountersImpl) ErrorsStartLateDts() *int {
	return s.ErrorsStartLateDtsValue
}

// Number of PID start errors caused by late DTS.
// Each such event currently triggers a full program reset.
func (s *PushPidCountersImpl) SetErrorsStartLateDts(v int) PushPidCounters {
	if s == nil {
		return nil
	}
	s.ErrorsStartLateDtsValue = &v
	return s
}

// Number of times a frame was received on an unconfigured PID.
// Usually occurs after reconfiguration.
func (s PushPidCountersImpl) ErrorsUnconfiguredQueue() *int {
	return s.ErrorsUnconfiguredQueueValue
}

// Number of times a frame was received on an unconfigured PID.
// Usually occurs after reconfiguration.
func (s *PushPidCountersImpl) SetErrorsUnconfiguredQueue(v int) PushPidCounters {
	if s == nil {
		return nil
	}
	s.ErrorsUnconfiguredQueueValue = &v
	return s
}

// The number of bytes exceeding the allocated bandwidth.
// Format: bytes (bytes)
func (s PushPidCountersImpl) ExceededBytes() *Bytes {
	return s.ExceededBytesValue
}

// The number of bytes exceeding the allocated bandwidth.
// Format: bytes (bytes)
func (s *PushPidCountersImpl) SetExceededBytes(v Bytes) PushPidCounters {
	if s == nil {
		return nil
	}
	s.ExceededBytesValue = &v
	return s
}

// The number of PES packets with an instant bitrate boost.
func (s PushPidCountersImpl) ExceededFrames() *int {
	return s.ExceededFramesValue
}

// The number of PES packets with an instant bitrate boost.
func (s *PushPidCountersImpl) SetExceededFrames(v int) PushPidCounters {
	if s == nil {
		return nil
	}
	s.ExceededFramesValue = &v
	return s
}

// How many MPEG-TS packets with NAL fillers on this PID produced.
func (s PushPidCountersImpl) FillerPackets() *int {
	return s.FillerPacketsValue
}

// How many MPEG-TS packets with NAL fillers on this PID produced.
func (s *PushPidCountersImpl) SetFillerPackets(v int) PushPidCounters {
	if s == nil {
		return nil
	}
	s.FillerPacketsValue = &v
	return s
}

// Deprecated field. Will be deleted at 25.11
// The filler bytes count.
// Use `filler_packets` instead.
// Format: bytes (bytes)
func (s PushPidCountersImpl) Fillers() *Bytes {
	return s.FillersValue
}

// Deprecated field. Will be deleted at 25.11
// The filler bytes count.
// Use `filler_packets` instead.
// Format: bytes (bytes)
func (s *PushPidCountersImpl) SetFillers(v Bytes) PushPidCounters {
	if s == nil {
		return nil
	}
	s.FillersValue = &v
	return s
}

// Deprecated field. Will be deleted at 25.11
// How many bytes were seen in NAL fillers.
// Use `filler_packets` instead.
// Format: bytes (bytes)
func (s PushPidCountersImpl) FillersBytes() *Bytes {
	return s.FillersBytesValue
}

// Deprecated field. Will be deleted at 25.11
// How many bytes were seen in NAL fillers.
// Use `filler_packets` instead.
// Format: bytes (bytes)
func (s *PushPidCountersImpl) SetFillersBytes(v Bytes) PushPidCounters {
	if s == nil {
		return nil
	}
	s.FillersBytesValue = &v
	return s
}

// Highest recorded level of the TS buffer.
// With too big values the HRD buffer may be filling up completely (overflow).
// Format: milliseconds (milliseconds)
func (s PushPidCountersImpl) MaxBuffer() *Milliseconds {
	return s.MaxBufferValue
}

// Highest recorded level of the TS buffer.
// With too big values the HRD buffer may be filling up completely (overflow).
// Format: milliseconds (milliseconds)
func (s *PushPidCountersImpl) SetMaxBuffer(v Milliseconds) PushPidCounters {
	if s == nil {
		return nil
	}
	s.MaxBufferValue = &v
	return s
}

// Lowest recorded level of the TS buffer.
// With too small values the HRD buffer may be completely empty (underflow).
// Format: milliseconds (milliseconds)
func (s PushPidCountersImpl) MinBuffer() *Milliseconds {
	return s.MinBufferValue
}

// Lowest recorded level of the TS buffer.
// With too small values the HRD buffer may be completely empty (underflow).
// Format: milliseconds (milliseconds)
func (s *PushPidCountersImpl) SetMinBuffer(v Milliseconds) PushPidCounters {
	if s == nil {
		return nil
	}
	s.MinBufferValue = &v
	return s
}

// How many MPEG-TS packets with 188 bytes on this PID produced.
func (s PushPidCountersImpl) Packets() *int {
	return s.PacketsValue
}

// How many MPEG-TS packets with 188 bytes on this PID produced.
func (s *PushPidCountersImpl) SetPackets(v int) PushPidCounters {
	if s == nil {
		return nil
	}
	s.PacketsValue = &v
	return s
}

// Deprecated field. Will be deleted at 25.11
// The payload bytes count.
// Use `payload_bytes` instead.
// Format: bytes (bytes)
func (s PushPidCountersImpl) Payload() *Bytes {
	return s.PayloadValue
}

// Deprecated field. Will be deleted at 25.11
// The payload bytes count.
// Use `payload_bytes` instead.
// Format: bytes (bytes)
func (s *PushPidCountersImpl) SetPayload(v Bytes) PushPidCounters {
	if s == nil {
		return nil
	}
	s.PayloadValue = &v
	return s
}

// The payload bytes count.
// Format: bytes (bytes)
func (s PushPidCountersImpl) PayloadBytes() *Bytes {
	return s.PayloadBytesValue
}

// The payload bytes count.
// Format: bytes (bytes)
func (s *PushPidCountersImpl) SetPayloadBytes(v Bytes) PushPidCounters {
	if s == nil {
		return nil
	}
	s.PayloadBytesValue = &v
	return s
}

// Related MPEG-TS PID.
func (s PushPidCountersImpl) Pid() int {
	return s.PidValue
}

// Related MPEG-TS PID.
func (s *PushPidCountersImpl) SetPid(v int) PushPidCounters {
	if s == nil {
		return nil
	}
	s.PidValue = v
	return s
}

// Program ID this PID belongs to.
func (s PushPidCountersImpl) Pnr() *int {
	return s.PnrValue
}

// Program ID this PID belongs to.
func (s *PushPidCountersImpl) SetPnr(v int) PushPidCounters {
	if s == nil {
		return nil
	}
	s.PnrValue = &v
	return s
}

// Deprecated field. Will be deleted at 25.11
// The stuff packets count.
// Use `stuffing_packets` instead.
func (s PushPidCountersImpl) Stuffing() *int {
	return s.StuffingValue
}

// Deprecated field. Will be deleted at 25.11
// The stuff packets count.
// Use `stuffing_packets` instead.
func (s *PushPidCountersImpl) SetStuffing(v int) PushPidCounters {
	if s == nil {
		return nil
	}
	s.StuffingValue = &v
	return s
}

// How many NULL packets (PID 0x1FFF) inserted when no data is scheduled on this PID.
func (s PushPidCountersImpl) StuffingPackets() *int {
	return s.StuffingPacketsValue
}

// How many NULL packets (PID 0x1FFF) inserted when no data is scheduled on this PID.
func (s *PushPidCountersImpl) SetStuffingPackets(v int) PushPidCounters {
	if s == nil {
		return nil
	}
	s.StuffingPacketsValue = &v
	return s
}

// The trimmed bytes count.
// Format: bytes (bytes)
func (s PushPidCountersImpl) TrimmedBytes() *Bytes {
	return s.TrimmedBytesValue
}

// The trimmed bytes count.
// Format: bytes (bytes)
func (s *PushPidCountersImpl) SetTrimmedBytes(v Bytes) PushPidCounters {
	if s == nil {
		return nil
	}
	s.TrimmedBytesValue = &v
	return s
}

// The trimmed PES packets count.
func (s PushPidCountersImpl) TrimmedFrames() *int {
	return s.TrimmedFramesValue
}

// The trimmed PES packets count.
func (s *PushPidCountersImpl) SetTrimmedFrames(v int) PushPidCounters {
	if s == nil {
		return nil
	}
	s.TrimmedFramesValue = &v
	return s
}

// NewRTPCountersBase creates a new RTPCountersBase instance
func NewRTPCountersBase() RTPCountersBase {
	return &RTPCountersBaseImpl{}
}

// How many bytes received for this channel
func (s RTPCountersBaseImpl) Bytes() *int {
	return s.BytesValue
}

// How many bytes received for this channel
func (s *RTPCountersBaseImpl) SetBytes(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.BytesValue = &v
	return s
}

// RTP channel number
// Example: 0
func (s RTPCountersBaseImpl) ChannelID() int {
	return s.ChannelIDValue
}

// RTP channel number
// Example: 0
func (s *RTPCountersBaseImpl) SetChannelID(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.ChannelIDValue = v
	return s
}

// Content of the track transmitted in the channel
// Example: video
func (s RTPCountersBaseImpl) Content() *string {
	return s.ContentValue
}

// Content of the track transmitted in the channel
// Example: video
func (s *RTPCountersBaseImpl) SetContent(v string) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.ContentValue = &v
	return s
}

// Demultiplexing was done right, but content is broken.
func (s RTPCountersBaseImpl) ErrorsBrokenPayload() *int {
	return s.ErrorsBrokenPayloadValue
}

// Demultiplexing was done right, but content is broken.
func (s *RTPCountersBaseImpl) SetErrorsBrokenPayload(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.ErrorsBrokenPayloadValue = &v
	return s
}

// Number of frames which dts is same as previous frame dts.
func (s RTPCountersBaseImpl) ErrorsDtsStuck() *int {
	return s.ErrorsDtsStuckValue
}

// Number of frames which dts is same as previous frame dts.
func (s *RTPCountersBaseImpl) SetErrorsDtsStuck(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.ErrorsDtsStuckValue = &v
	return s
}

// RTP have enough information to tell how many packets were lost
func (s RTPCountersBaseImpl) ErrorsLostPackets() *int {
	return s.ErrorsLostPacketsValue
}

// RTP have enough information to tell how many packets were lost
func (s *RTPCountersBaseImpl) SetErrorsLostPackets(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.ErrorsLostPacketsValue = &v
	return s
}

// How many frames received for this channel
func (s RTPCountersBaseImpl) Frames() *int {
	return s.FramesValue
}

// How many frames received for this channel
func (s *RTPCountersBaseImpl) SetFrames(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.FramesValue = &v
	return s
}

// Number of RTP packets which marker bit is set to one.
func (s RTPCountersBaseImpl) MarkerPacketsCount() *int {
	return s.MarkerPacketsCountValue
}

// Number of RTP packets which marker bit is set to one.
func (s *RTPCountersBaseImpl) SetMarkerPacketsCount(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.MarkerPacketsCountValue = &v
	return s
}

// How many NACK messages are sent for this channel
func (s RTPCountersBaseImpl) NackCount() *int {
	return s.NackCountValue
}

// How many NACK messages are sent for this channel
func (s *RTPCountersBaseImpl) SetNackCount(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.NackCountValue = &v
	return s
}

// If no marker bit packet is received after 400 RTP packets then decoder switches to `no_marker_mode` and
// makes frame on each timecode change.
// This flag shows if decoder works in `no_marker_mode`.
func (s RTPCountersBaseImpl) NoMarkerModeFlag() *bool {
	return s.NoMarkerModeFlagValue
}

// If no marker bit packet is received after 400 RTP packets then decoder switches to `no_marker_mode` and
// makes frame on each timecode change.
// This flag shows if decoder works in `no_marker_mode`.
func (s *RTPCountersBaseImpl) SetNoMarkerModeFlag(v bool) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.NoMarkerModeFlagValue = &v
	return s
}

// Number of rtp packets rejected due to wrong payload type
func (s RTPCountersBaseImpl) PtRejectCount() *int {
	return s.PtRejectCountValue
}

// Number of rtp packets rejected due to wrong payload type
func (s *RTPCountersBaseImpl) SetPtRejectCount(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.PtRejectCountValue = &v
	return s
}

// Total size of rejected packets due to wrong payload type (pt_reject_count) rtp packets
func (s RTPCountersBaseImpl) PtRejectSum() *int {
	return s.PtRejectSumValue
}

// Total size of rejected packets due to wrong payload type (pt_reject_count) rtp packets
func (s *RTPCountersBaseImpl) SetPtRejectSum(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.PtRejectSumValue = &v
	return s
}

// How many RTCP packets received for this channel
func (s RTPCountersBaseImpl) RtcpPackets() *int {
	return s.RtcpPacketsValue
}

// How many RTCP packets received for this channel
func (s *RTPCountersBaseImpl) SetRtcpPackets(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.RtcpPacketsValue = &v
	return s
}

// How many RTP packets received for this channel
func (s RTPCountersBaseImpl) RTPPackets() *int {
	return s.RTPPacketsValue
}

// How many RTP packets received for this channel
func (s *RTPCountersBaseImpl) SetRTPPackets(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.RTPPacketsValue = &v
	return s
}

// Sender wallclock deviation from server time in ms. Positive value means that sender time is ahead of server time.
func (s RTPCountersBaseImpl) SenderClockDeviation() *int {
	return s.SenderClockDeviationValue
}

// Sender wallclock deviation from server time in ms. Positive value means that sender time is ahead of server time.
func (s *RTPCountersBaseImpl) SetSenderClockDeviation(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.SenderClockDeviationValue = &v
	return s
}

// Number of rtcp SR packets which `RTP timestamp` is equal to the previous rtcp SR packet `RTP timestamp`.
func (s RTPCountersBaseImpl) SrTSStuck() *int {
	return s.SrTSStuckValue
}

// Number of rtcp SR packets which `RTP timestamp` is equal to the previous rtcp SR packet `RTP timestamp`.
func (s *RTPCountersBaseImpl) SetSrTSStuck(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.SrTSStuckValue = &v
	return s
}

// Time on this channel is jumped back from reference wallclock.
func (s RTPCountersBaseImpl) TSGoesBackwards() *int {
	return s.TSGoesBackwardsValue
}

// Time on this channel is jumped back from reference wallclock.
func (s *RTPCountersBaseImpl) SetTSGoesBackwards(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.TSGoesBackwardsValue = &v
	return s
}

// Time on this channel is jumped forward from reference wallclock.
func (s RTPCountersBaseImpl) TSJumpForward() *int {
	return s.TSJumpForwardValue
}

// Time on this channel is jumped forward from reference wallclock.
func (s *RTPCountersBaseImpl) SetTSJumpForward(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.TSJumpForwardValue = &v
	return s
}

// https://datatracker.ietf.org/doc/html/rfc6184#section-4.1
// access unit: A set of NAL units always containing a primary coded picture.  In addition to the primary coded
// picture, an access unit may also contain one or more redundant coded pictures or other NAL units not containing
// slices or slice data partitions of a coded picture.  The decoding of an access unit always results in a
// decoded picture.
// There is `marker bit` in RTP packet which is set for the very last packet of the access unit indicated by the RTP timestamp.
// It is protocol violation if received RTP packet has the same timestamp as previous marker bit packet.
// This counter is a number of RTP packets which `RTP timestamp` is equal to previous RTP marker bit packet.
func (s RTPCountersBaseImpl) TSStuck() *int {
	return s.TSStuckValue
}

// https://datatracker.ietf.org/doc/html/rfc6184#section-4.1
// access unit: A set of NAL units always containing a primary coded picture.  In addition to the primary coded
// picture, an access unit may also contain one or more redundant coded pictures or other NAL units not containing
// slices or slice data partitions of a coded picture.  The decoding of an access unit always results in a
// decoded picture.
// There is `marker bit` in RTP packet which is set for the very last packet of the access unit indicated by the RTP timestamp.
// It is protocol violation if received RTP packet has the same timestamp as previous marker bit packet.
// This counter is a number of RTP packets which `RTP timestamp` is equal to previous RTP marker bit packet.
func (s *RTPCountersBaseImpl) SetTSStuck(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.TSStuckValue = &v
	return s
}

// NewRaidDiskConfig creates a new RaidDiskConfig instance
func NewRaidDiskConfig() RaidDiskConfig {
	return &RaidDiskConfigImpl{}
}

// The mode of using the disk.
// Example: keep
func (s RaidDiskConfigImpl) Mode() *RaidDiskMode {
	return s.ModeValue
}

// The mode of using the disk.
// Example: keep
func (s *RaidDiskConfigImpl) SetMode(v RaidDiskMode) RaidDiskConfig {
	if s == nil {
		return nil
	}
	s.ModeValue = &v
	return s
}

// The path to a mounted disk.
// Format: disk_path (disk_path)
// Example: volume1
func (s RaidDiskConfigImpl) Path() DiskPath {
	return s.PathValue
}

// The path to a mounted disk.
// Format: disk_path (disk_path)
// Example: volume1
func (s *RaidDiskConfigImpl) SetPath(v DiskPath) RaidDiskConfig {
	if s == nil {
		return nil
	}
	s.PathValue = v
	return s
}

// The runtime statistics about RAID. The statistics shows the state of disks.
// Learn more in [Flussonic RAID for DVR](https://flussonic.com/doc/extend-video-storage-on-fly/#dvr-flussonic-raid-stats)
func (s RaidDiskConfigImpl) Stats() RaidDiskConfigStats {
	return s.StatsValue
}

// The runtime statistics about RAID. The statistics shows the state of disks.
// Learn more in [Flussonic RAID for DVR](https://flussonic.com/doc/extend-video-storage-on-fly/#dvr-flussonic-raid-stats)
func (s *RaidDiskConfigImpl) SetStats(v RaidDiskConfigStats) RaidDiskConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*RaidDiskConfigStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// NewRaidDiskConfigStats creates a new RaidDiskConfigStats instance
func NewRaidDiskConfigStats() RaidDiskConfigStats {
	return &RaidDiskConfigStatsImpl{}
}

// The number of blobs on the disk that are enlisted in individual stream indexes.
// It must be equal to blobs_count_db and can be different in case of software
// or hardware errors.
func (s RaidDiskConfigStatsImpl) BlobsCount() *int {
	return s.BlobsCountValue
}

// The number of blobs on the disk that are enlisted in individual stream indexes.
// It must be equal to blobs_count_db and can be different in case of software
// or hardware errors.
func (s *RaidDiskConfigStatsImpl) SetBlobsCount(v int) RaidDiskConfigStats {
	if s == nil {
		return nil
	}
	s.BlobsCountValue = &v
	return s
}

// The number of blobs on the disk according to centralized Raid DB that is
// used to allocate blobs across whole storage.
func (s RaidDiskConfigStatsImpl) BlobsCountDb() *int {
	return s.BlobsCountDbValue
}

// The number of blobs on the disk according to centralized Raid DB that is
// used to allocate blobs across whole storage.
func (s *RaidDiskConfigStatsImpl) SetBlobsCountDb(v int) RaidDiskConfigStats {
	if s == nil {
		return nil
	}
	s.BlobsCountDbValue = &v
	return s
}

// Errors of using the disk.
func (s RaidDiskConfigStatsImpl) Errors() RaidDiskErrors {
	return s.ErrorsValue
}

// Errors of using the disk.
func (s *RaidDiskConfigStatsImpl) SetErrors(v RaidDiskErrors) RaidDiskConfigStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*RaidDiskErrorsImpl); ok {
		s.ErrorsValue = impl
	}
	return s
}

// Disk I/O utilization percentage from `/proc/devstat`.
// Format: percent (percent)
func (s RaidDiskConfigStatsImpl) IoUsage() *Percent {
	return s.IoUsageValue
}

// Disk I/O utilization percentage from `/proc/devstat`.
// Format: percent (percent)
func (s *RaidDiskConfigStatsImpl) SetIoUsage(v Percent) RaidDiskConfigStats {
	if s == nil {
		return nil
	}
	s.IoUsageValue = &v
	return s
}

// The estimated migration end time, in UTC seconds.
// Format: utc (Unix timestamp in seconds)
func (s RaidDiskConfigStatsImpl) MigrationEta() *Utc {
	return s.MigrationEtaValue
}

// The estimated migration end time, in UTC seconds.
// Format: utc (Unix timestamp in seconds)
func (s *RaidDiskConfigStatsImpl) SetMigrationEta(v Utc) RaidDiskConfigStats {
	if s == nil {
		return nil
	}
	s.MigrationEtaValue = &v
	return s
}

// The speed of copying the last blob, in bytes per second.
// Format: speed (speed)
func (s RaidDiskConfigStatsImpl) MigrationSpeed() *Speed {
	return s.MigrationSpeedValue
}

// The speed of copying the last blob, in bytes per second.
// Format: speed (speed)
func (s *RaidDiskConfigStatsImpl) SetMigrationSpeed(v Speed) RaidDiskConfigStats {
	if s == nil {
		return nil
	}
	s.MigrationSpeedValue = &v
	return s
}

// The time when the values of `migration_speed` and `migration_eta` were last updated.
// Format: utc (Unix timestamp in seconds)
func (s RaidDiskConfigStatsImpl) MigrationUpdated() *Utc {
	return s.MigrationUpdatedValue
}

// The time when the values of `migration_speed` and `migration_eta` were last updated.
// Format: utc (Unix timestamp in seconds)
func (s *RaidDiskConfigStatsImpl) SetMigrationUpdated(v Utc) RaidDiskConfigStats {
	if s == nil {
		return nil
	}
	s.MigrationUpdatedValue = &v
	return s
}

// The mode of using the disk.
// Example: keep
func (s RaidDiskConfigStatsImpl) Mode() *RaidDiskMode {
	return s.ModeValue
}

// The mode of using the disk.
// Example: keep
func (s *RaidDiskConfigStatsImpl) SetMode(v RaidDiskMode) RaidDiskConfigStats {
	if s == nil {
		return nil
	}
	s.ModeValue = &v
	return s
}

// Whether the disk is mounted correctly.
func (s RaidDiskConfigStatsImpl) Mounted() *bool {
	return s.MountedValue
}

// Whether the disk is mounted correctly.
func (s *RaidDiskConfigStatsImpl) SetMounted(v bool) RaidDiskConfigStats {
	if s == nil {
		return nil
	}
	s.MountedValue = &v
	return s
}

// Disk capacity in bytes.
// Format: bytes (bytes)
func (s RaidDiskConfigStatsImpl) Size() *Bytes {
	return s.SizeValue
}

// Disk capacity in bytes.
// Format: bytes (bytes)
func (s *RaidDiskConfigStatsImpl) SetSize(v Bytes) RaidDiskConfigStats {
	if s == nil {
		return nil
	}
	s.SizeValue = &v
	return s
}

// Disk utilization percentage.
// Format: percent (percent)
func (s RaidDiskConfigStatsImpl) Usage() *Percent {
	return s.UsageValue
}

// Disk utilization percentage.
// Format: percent (percent)
func (s *RaidDiskConfigStatsImpl) SetUsage(v Percent) RaidDiskConfigStats {
	if s == nil {
		return nil
	}
	s.UsageValue = &v
	return s
}

// Used disk space in bytes according to linux metrics. It must be equal (almost equal) to
// `used_index`. If it differs more than in 1%, then it means that there are lot of unknown files.
// If this disk is used exclusively for Raid, then it may mean that some blobs are lost from
// database and repairing is required.
// Format: bytes (bytes)
func (s RaidDiskConfigStatsImpl) Used() *Bytes {
	return s.UsedValue
}

// Used disk space in bytes according to linux metrics. It must be equal (almost equal) to
// `used_index`. If it differs more than in 1%, then it means that there are lot of unknown files.
// If this disk is used exclusively for Raid, then it may mean that some blobs are lost from
// database and repairing is required.
// Format: bytes (bytes)
func (s *RaidDiskConfigStatsImpl) SetUsed(v Bytes) RaidDiskConfigStats {
	if s == nil {
		return nil
	}
	s.UsedValue = &v
	return s
}

// Used disk space in bytes according to internal database index.
// Format: bytes (bytes)
func (s RaidDiskConfigStatsImpl) UsedIndex() *Bytes {
	return s.UsedIndexValue
}

// Used disk space in bytes according to internal database index.
// Format: bytes (bytes)
func (s *RaidDiskConfigStatsImpl) SetUsedIndex(v Bytes) RaidDiskConfigStats {
	if s == nil {
		return nil
	}
	s.UsedIndexValue = &v
	return s
}

// NewRaidDiskErrors creates a new RaidDiskErrors instance
func NewRaidDiskErrors() RaidDiskErrors {
	return &RaidDiskErrorsImpl{}
}

// Total number of connection timeout errors
// Example: 1
func (s RaidDiskErrorsImpl) ConnectionTimeout() *int {
	return s.ConnectionTimeoutValue
}

// Total number of connection timeout errors
// Example: 1
func (s *RaidDiskErrorsImpl) SetConnectionTimeout(v int) RaidDiskErrors {
	if s == nil {
		return nil
	}
	s.ConnectionTimeoutValue = &v
	return s
}

// Total number of permission denied errors
// Example: 1
func (s RaidDiskErrorsImpl) Eacces() *int {
	return s.EaccesValue
}

// Total number of permission denied errors
// Example: 1
func (s *RaidDiskErrorsImpl) SetEacces(v int) RaidDiskErrors {
	if s == nil {
		return nil
	}
	s.EaccesValue = &v
	return s
}

// Total number of temporarily unavailable errors
// Example: 1
func (s RaidDiskErrorsImpl) Eagain() *int {
	return s.EagainValue
}

// Total number of temporarily unavailable errors
// Example: 1
func (s *RaidDiskErrorsImpl) SetEagain(v int) RaidDiskErrors {
	if s == nil {
		return nil
	}
	s.EagainValue = &v
	return s
}

// Total number of file busy errors
// Example: 1
func (s RaidDiskErrorsImpl) Ebusy() *int {
	return s.EbusyValue
}

// Total number of file busy errors
// Example: 1
func (s *RaidDiskErrorsImpl) SetEbusy(v int) RaidDiskErrors {
	if s == nil {
		return nil
	}
	s.EbusyValue = &v
	return s
}

// Total number of connection refused errors
// Example: 1
func (s RaidDiskErrorsImpl) Econnrefused() *int {
	return s.EconnrefusedValue
}

// Total number of connection refused errors
// Example: 1
func (s *RaidDiskErrorsImpl) SetEconnrefused(v int) RaidDiskErrors {
	if s == nil {
		return nil
	}
	s.EconnrefusedValue = &v
	return s
}

// Total number of disk quota exceeded errors
// Example: 1
func (s RaidDiskErrorsImpl) Edquot() *int {
	return s.EdquotValue
}

// Total number of disk quota exceeded errors
// Example: 1
func (s *RaidDiskErrorsImpl) SetEdquot(v int) RaidDiskErrors {
	if s == nil {
		return nil
	}
	s.EdquotValue = &v
	return s
}

// Total number of too many open files errors
// Example: 1
func (s RaidDiskErrorsImpl) Emfile() *int {
	return s.EmfileValue
}

// Total number of too many open files errors
// Example: 1
func (s *RaidDiskErrorsImpl) SetEmfile(v int) RaidDiskErrors {
	if s == nil {
		return nil
	}
	s.EmfileValue = &v
	return s
}

// Total number of no such device errors
// Example: 1
func (s RaidDiskErrorsImpl) Enodev() *int {
	return s.EnodevValue
}

// Total number of no such device errors
// Example: 1
func (s *RaidDiskErrorsImpl) SetEnodev(v int) RaidDiskErrors {
	if s == nil {
		return nil
	}
	s.EnodevValue = &v
	return s
}

// Total number of no such file or directory errors
// Example: 1
func (s RaidDiskErrorsImpl) Enoent() *int {
	return s.EnoentValue
}

// Total number of no such file or directory errors
// Example: 1
func (s *RaidDiskErrorsImpl) SetEnoent(v int) RaidDiskErrors {
	if s == nil {
		return nil
	}
	s.EnoentValue = &v
	return s
}

// Total number of no space left on device errors
// Example: 1
func (s RaidDiskErrorsImpl) Enospc() *int {
	return s.EnospcValue
}

// Total number of no space left on device errors
// Example: 1
func (s *RaidDiskErrorsImpl) SetEnospc(v int) RaidDiskErrors {
	if s == nil {
		return nil
	}
	s.EnospcValue = &v
	return s
}

// Total number of read-only file system errors
// Example: 1
func (s RaidDiskErrorsImpl) Erofs() *int {
	return s.ErofsValue
}

// Total number of read-only file system errors
// Example: 1
func (s *RaidDiskErrorsImpl) SetErofs(v int) RaidDiskErrors {
	if s == nil {
		return nil
	}
	s.ErofsValue = &v
	return s
}

// Total number of non-existing domain errors
// Example: 1
func (s RaidDiskErrorsImpl) Nxdomain() *int {
	return s.NxdomainValue
}

// Total number of non-existing domain errors
// Example: 1
func (s *RaidDiskErrorsImpl) SetNxdomain(v int) RaidDiskErrors {
	if s == nil {
		return nil
	}
	s.NxdomainValue = &v
	return s
}

// Total number of other errors
// Example: 1
func (s RaidDiskErrorsImpl) Other() *int {
	return s.OtherValue
}

// Total number of other errors
// Example: 1
func (s *RaidDiskErrorsImpl) SetOther(v int) RaidDiskErrors {
	if s == nil {
		return nil
	}
	s.OtherValue = &v
	return s
}

// Total number of SSL errors
// Example: 1
func (s RaidDiskErrorsImpl) SslError() *int {
	return s.SslErrorValue
}

// Total number of SSL errors
// Example: 1
func (s *RaidDiskErrorsImpl) SetSslError(v int) RaidDiskErrors {
	if s == nil {
		return nil
	}
	s.SslErrorValue = &v
	return s
}

// NewRaidDiskStats creates a new RaidDiskStats instance
func NewRaidDiskStats() RaidDiskStats {
	return &RaidDiskStatsImpl{}
}

// Errors of using the disk.
func (s RaidDiskStatsImpl) Errors() RaidDiskErrors {
	return s.ErrorsValue
}

// Errors of using the disk.
func (s *RaidDiskStatsImpl) SetErrors(v RaidDiskErrors) RaidDiskStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*RaidDiskErrorsImpl); ok {
		s.ErrorsValue = impl
	}
	return s
}

// Disk I/O utilization percentage from `/proc/devstat`.
// Format: percent (percent)
func (s RaidDiskStatsImpl) IoUsage() *Percent {
	return s.IoUsageValue
}

// Disk I/O utilization percentage from `/proc/devstat`.
// Format: percent (percent)
func (s *RaidDiskStatsImpl) SetIoUsage(v Percent) RaidDiskStats {
	if s == nil {
		return nil
	}
	s.IoUsageValue = &v
	return s
}

// The estimated migration end time, in UTC seconds.
// Format: utc (Unix timestamp in seconds)
func (s RaidDiskStatsImpl) MigrationEta() *Utc {
	return s.MigrationEtaValue
}

// The estimated migration end time, in UTC seconds.
// Format: utc (Unix timestamp in seconds)
func (s *RaidDiskStatsImpl) SetMigrationEta(v Utc) RaidDiskStats {
	if s == nil {
		return nil
	}
	s.MigrationEtaValue = &v
	return s
}

// The speed of copying the last blob, in bytes per second.
// Format: speed (speed)
func (s RaidDiskStatsImpl) MigrationSpeed() *Speed {
	return s.MigrationSpeedValue
}

// The speed of copying the last blob, in bytes per second.
// Format: speed (speed)
func (s *RaidDiskStatsImpl) SetMigrationSpeed(v Speed) RaidDiskStats {
	if s == nil {
		return nil
	}
	s.MigrationSpeedValue = &v
	return s
}

// The time when the values of `migration_speed` and `migration_eta` were last updated.
// Format: utc (Unix timestamp in seconds)
func (s RaidDiskStatsImpl) MigrationUpdated() *Utc {
	return s.MigrationUpdatedValue
}

// The time when the values of `migration_speed` and `migration_eta` were last updated.
// Format: utc (Unix timestamp in seconds)
func (s *RaidDiskStatsImpl) SetMigrationUpdated(v Utc) RaidDiskStats {
	if s == nil {
		return nil
	}
	s.MigrationUpdatedValue = &v
	return s
}

// The mode of using the disk.
// Example: keep
func (s RaidDiskStatsImpl) Mode() *RaidDiskMode {
	return s.ModeValue
}

// The mode of using the disk.
// Example: keep
func (s *RaidDiskStatsImpl) SetMode(v RaidDiskMode) RaidDiskStats {
	if s == nil {
		return nil
	}
	s.ModeValue = &v
	return s
}

// Whether the disk is mounted correctly.
func (s RaidDiskStatsImpl) Mounted() *bool {
	return s.MountedValue
}

// Whether the disk is mounted correctly.
func (s *RaidDiskStatsImpl) SetMounted(v bool) RaidDiskStats {
	if s == nil {
		return nil
	}
	s.MountedValue = &v
	return s
}

// NewRproxyConfig creates a new RproxyConfig instance
func NewRproxyConfig() RproxyConfig {
	return &RproxyConfigImpl{}
}

// Path to authorization backend on the endpoint to check if the Agents are allowed to connect.
func (s RproxyConfigImpl) EndpointAuth() *string {
	return s.EndpointAuthValue
}

// Path to authorization backend on the endpoint to check if the Agents are allowed to connect.
func (s *RproxyConfigImpl) SetEndpointAuth(v string) RproxyConfig {
	if s == nil {
		return nil
	}
	s.EndpointAuthValue = &v
	return s
}

// Configuration of port handlers.
func (s RproxyConfigImpl) ForwardPorts() map[string]ForwardPortsConfig {
	if s.ForwardPortsValue == nil {
		return nil
	}
	result := make(map[string]ForwardPortsConfig)
	for k, val := range s.ForwardPortsValue {
		result[k] = val
	}
	return result
}

// Configuration of port handlers.
func (s *RproxyConfigImpl) SetForwardPorts(v map[string]ForwardPortsConfig) RproxyConfig {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make(map[string]*ForwardPortsConfigImpl)
		for k, val := range v {
			if valImpl, ok := val.(*ForwardPortsConfigImpl); ok {
				impl[k] = valImpl
			}
		}
		s.ForwardPortsValue = impl
	}
	return s
}

// The streamer ID key.
func (s RproxyConfigImpl) StreampointKey() string {
	return s.StreampointKeyValue
}

// The streamer ID key.
func (s *RproxyConfigImpl) SetStreampointKey(v string) RproxyConfig {
	if s == nil {
		return nil
	}
	s.StreampointKeyValue = v
	return s
}

// NewSensor creates a new Sensor instance
func NewSensor() Sensor {
	return &SensorImpl{}
}

// Image blacklight compensation correction
func (s SensorImpl) BlacklightCompensation() OnOff {
	return s.BlacklightCompensationValue
}

// Image blacklight compensation correction
func (s *SensorImpl) SetBlacklightCompensation(v OnOff) Sensor {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*OnOffImpl); ok {
		s.BlacklightCompensationValue = impl
	}
	return s
}

// Image brightness correction.
// The value is indicated as a percentage from 0 to 100.
// Format: percent (percent)
func (s SensorImpl) BrightnessCorrection() *Percent {
	return s.BrightnessCorrectionValue
}

// Image brightness correction.
// The value is indicated as a percentage from 0 to 100.
// Format: percent (percent)
func (s *SensorImpl) SetBrightnessCorrection(v Percent) Sensor {
	if s == nil {
		return nil
	}
	s.BrightnessCorrectionValue = &v
	return s
}

// Image contrast correction.
// The value is indicated as a percentage from 0 to 100.
// Format: percent (percent)
func (s SensorImpl) ContrastCorrection() *Percent {
	return s.ContrastCorrectionValue
}

// Image contrast correction.
// The value is indicated as a percentage from 0 to 100.
// Format: percent (percent)
func (s *SensorImpl) SetContrastCorrection(v Percent) Sensor {
	if s == nil {
		return nil
	}
	s.ContrastCorrectionValue = &v
	return s
}

// Installation position of the camera
func (s SensorImpl) ImageOrientation() *SensorImageOrientation {
	return s.ImageOrientationValue
}

// Installation position of the camera
func (s *SensorImpl) SetImageOrientation(v SensorImageOrientation) Sensor {
	if s == nil {
		return nil
	}
	s.ImageOrientationValue = &v
	return s
}

// Infrared cut-of filter
func (s SensorImpl) InfraredCutoffFilter() OnOffAuto {
	return s.InfraredCutoffFilterValue
}

// Infrared cut-of filter
func (s *SensorImpl) SetInfraredCutoffFilter(v OnOffAuto) Sensor {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*OnOffAutoImpl); ok {
		s.InfraredCutoffFilterValue = impl
	}
	return s
}

// Image saturation correction.
// The value is indicated as a percentage from 0 to 100.
// Format: percent (percent)
func (s SensorImpl) Saturation() *Percent {
	return s.SaturationValue
}

// Image saturation correction.
// The value is indicated as a percentage from 0 to 100.
// Format: percent (percent)
func (s *SensorImpl) SetSaturation(v Percent) Sensor {
	if s == nil {
		return nil
	}
	s.SaturationValue = &v
	return s
}

// Sharpness / edges contrast enhancement level.
// The value is indicated as a percentage from 0 to 100.
// Format: percent (percent)
func (s SensorImpl) Sharpness() *Percent {
	return s.SharpnessValue
}

// Sharpness / edges contrast enhancement level.
// The value is indicated as a percentage from 0 to 100.
// Format: percent (percent)
func (s *SensorImpl) SetSharpness(v Percent) Sensor {
	if s == nil {
		return nil
	}
	s.SharpnessValue = &v
	return s
}

// Image wide dynamic range correction.
// The value is indicated as a percentage from 0 to 100.
// Format: percent (percent)
func (s SensorImpl) WideDynamicRange() *Percent {
	return s.WideDynamicRangeValue
}

// Image wide dynamic range correction.
// The value is indicated as a percentage from 0 to 100.
// Format: percent (percent)
func (s *SensorImpl) SetWideDynamicRange(v Percent) Sensor {
	if s == nil {
		return nil
	}
	s.WideDynamicRangeValue = &v
	return s
}

// NewServerConfigBase creates a new ServerConfigBase instance
func NewServerConfigBase() ServerConfigBase {
	return &ServerConfigBaseImpl{}
}

// The list of allowed subnets to accept API requests from.
func (s ServerConfigBaseImpl) APIAllowedFrom() []Cidr {
	return s.APIAllowedFromValue
}

// The list of allowed subnets to accept API requests from.
func (s *ServerConfigBaseImpl) SetAPIAllowedFrom(v []Cidr) ServerConfigBase {
	if s == nil {
		return nil
	}
	s.APIAllowedFromValue = v
	return s
}

// Configure key name of query string key-value pair for token authentication
func (s ServerConfigBaseImpl) AuthToken() *AuthToken {
	return s.AuthTokenValue
}

// Configure key name of query string key-value pair for token authentication
func (s *ServerConfigBaseImpl) SetAuthToken(v AuthToken) ServerConfigBase {
	if s == nil {
		return nil
	}
	s.AuthTokenValue = &v
	return s
}

// The cluster key to unite several servers with the same key into a cluster.
// Example: xS6i6Q3DCc5nEvnu
func (s ServerConfigBaseImpl) ClusterKey() *string {
	return s.ClusterKeyValue
}

// The cluster key to unite several servers with the same key into a cluster.
// Example: xS6i6Q3DCc5nEvnu
func (s *ServerConfigBaseImpl) SetClusterKey(v string) ServerConfigBase {
	if s == nil {
		return nil
	}
	s.ClusterKeyValue = &v
	return s
}

// Credentials for administrator access to the server.
func (s ServerConfigBaseImpl) EditAuth() AdminCredentials {
	return s.EditAuthValue
}

// Credentials for administrator access to the server.
func (s *ServerConfigBaseImpl) SetEditAuth(v AdminCredentials) ServerConfigBase {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*AdminCredentialsImpl); ok {
		s.EditAuthValue = impl
	}
	return s
}

// Use your own GeoIP database.
// Format: disk_path (disk_path)
// Example: /usr/share/GeoIP/GeoLite2-City.mmdb
func (s ServerConfigBaseImpl) Geoip() *DiskPath {
	return s.GeoipValue
}

// Use your own GeoIP database.
// Format: disk_path (disk_path)
// Example: /usr/share/GeoIP/GeoLite2-City.mmdb
func (s *ServerConfigBaseImpl) SetGeoip(v DiskPath) ServerConfigBase {
	if s == nil {
		return nil
	}
	s.GeoipValue = &v
	return s
}

// The configuration of network listeners.
func (s ServerConfigBaseImpl) Listeners() Listeners {
	return s.ListenersValue
}

// The configuration of network listeners.
func (s *ServerConfigBaseImpl) SetListeners(v Listeners) ServerConfigBase {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ListenersImpl); ok {
		s.ListenersValue = impl
	}
	return s
}

// Enables logging of requests for streams (manifests, segments) and API request.
func (s ServerConfigBaseImpl) LogRequests() *bool {
	return s.LogRequestsValue
}

// Enables logging of requests for streams (manifests, segments) and API request.
func (s *ServerConfigBaseImpl) SetLogRequests(v bool) ServerConfigBase {
	if s == nil {
		return nil
	}
	s.LogRequestsValue = &v
	return s
}

// Raise loglevel to debug if needed.
// Example: error
func (s ServerConfigBaseImpl) Loglevel() *Loglevel {
	return s.LoglevelValue
}

// Raise loglevel to debug if needed.
// Example: error
func (s *ServerConfigBaseImpl) SetLoglevel(v Loglevel) ServerConfigBase {
	if s == nil {
		return nil
	}
	s.LoglevelValue = &v
	return s
}

// Some additional options of the server.
// Example: {"role": "transcoder"}
func (s ServerConfigBaseImpl) Meta() *string {
	return s.MetaValue
}

// Some additional options of the server.
// Example: {"role": "transcoder"}
func (s *ServerConfigBaseImpl) SetMeta(v string) ServerConfigBase {
	if s == nil {
		return nil
	}
	s.MetaValue = &v
	return s
}

// Deprecated field. Will be deleted at 25.11
// Enables saving statistics on Nvidia performance.
// Example: true
func (s ServerConfigBaseImpl) NvidiaMonitor() *bool {
	return s.NvidiaMonitorValue
}

// Deprecated field. Will be deleted at 25.11
// Enables saving statistics on Nvidia performance.
// Example: true
func (s *ServerConfigBaseImpl) SetNvidiaMonitor(v bool) ServerConfigBase {
	if s == nil {
		return nil
	}
	s.NvidiaMonitorValue = &v
	return s
}

// Directory to store Pulse statistics.
// Format: disk_path (disk_path)
// Example: /var/run/flussonic/pulsedb
func (s ServerConfigBaseImpl) Pulsedb() *DiskPath {
	return s.PulsedbValue
}

// Directory to store Pulse statistics.
// Format: disk_path (disk_path)
// Example: /var/run/flussonic/pulsedb
func (s *ServerConfigBaseImpl) SetPulsedb(v DiskPath) ServerConfigBase {
	if s == nil {
		return nil
	}
	s.PulsedbValue = &v
	return s
}

// The configuration of server domain name and aliases
func (s ServerConfigBaseImpl) ServerNames() []ServerNameConfig {
	if s.ServerNamesValue == nil {
		return nil
	}
	result := make([]ServerNameConfig, len(s.ServerNamesValue))
	for i, item := range s.ServerNamesValue {
		result[i] = item
	}
	return result
}

// The configuration of server domain name and aliases
func (s *ServerConfigBaseImpl) SetServerNames(v []ServerNameConfig) ServerConfigBase {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*ServerNameConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*ServerNameConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.ServerNamesValue = impl
	}
	return s
}

// Deprecated field. Will be deleted at 26.01
// Directory to store the session log.
// Format: disk_path (disk_path)
// Example: /var/run/flussonic/session_log
func (s ServerConfigBaseImpl) SessionLog() *DiskPath {
	return s.SessionLogValue
}

// Deprecated field. Will be deleted at 26.01
// Directory to store the session log.
// Format: disk_path (disk_path)
// Example: /var/run/flussonic/session_log
func (s *ServerConfigBaseImpl) SetSessionLog(v DiskPath) ServerConfigBase {
	if s == nil {
		return nil
	}
	s.SessionLogValue = &v
	return s
}

// Global SRT listening port. It is possible to use a single port for playback and publishing, but it is not compatible with clients.
// Consider configuring separate ports for playback and publishing for each stream.
func (s ServerConfigBaseImpl) Srt() *ListenSpec {
	return s.SrtValue
}

// Global SRT listening port. It is possible to use a single port for playback and publishing, but it is not compatible with clients.
// Consider configuring separate ports for playback and publishing for each stream.
func (s *ServerConfigBaseImpl) SetSrt(v *ListenSpec) ServerConfigBase {
	if s == nil {
		return nil
	}
	s.SrtValue = v
	return s
}

// SRT2 play configuration with single-port mode. Not supported by many clients, better use per-stream mode.
func (s ServerConfigBaseImpl) Srt2Play() SrtConfig {
	return s.Srt2PlayValue
}

// SRT2 play configuration with single-port mode. Not supported by many clients, better use per-stream mode.
func (s *ServerConfigBaseImpl) SetSrt2Play(v SrtConfig) ServerConfigBase {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*SrtConfigImpl); ok {
		s.Srt2PlayValue = impl
	}
	return s
}

// SRT2 publish configuration with single-port mode. Not supported by many clients, better use per-stream mode.
func (s ServerConfigBaseImpl) Srt2Publish() SrtConfig {
	return s.Srt2PublishValue
}

// SRT2 publish configuration with single-port mode. Not supported by many clients, better use per-stream mode.
func (s *ServerConfigBaseImpl) SetSrt2Publish(v SrtConfig) ServerConfigBase {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*SrtConfigImpl); ok {
		s.Srt2PublishValue = impl
	}
	return s
}

// SRT play configuration with single-port mode. Not supported by many clients, better use per-stream mode.
func (s ServerConfigBaseImpl) SrtPlay() SrtConfig {
	return s.SrtPlayValue
}

// SRT play configuration with single-port mode. Not supported by many clients, better use per-stream mode.
func (s *ServerConfigBaseImpl) SetSrtPlay(v SrtConfig) ServerConfigBase {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*SrtConfigImpl); ok {
		s.SrtPlayValue = impl
	}
	return s
}

// SRT publish configuration with single-port mode. Not supported by many clients, better use per-stream mode.
func (s ServerConfigBaseImpl) SrtPublish() SrtConfig {
	return s.SrtPublishValue
}

// SRT publish configuration with single-port mode. Not supported by many clients, better use per-stream mode.
func (s *ServerConfigBaseImpl) SetSrtPublish(v SrtConfig) ServerConfigBase {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*SrtConfigImpl); ok {
		s.SrtPublishValue = impl
	}
	return s
}

// Total server bandwidth.
// Format: speed (speed)
// Example: 1e+09
func (s ServerConfigBaseImpl) TotalBandwidth() *Speed {
	return s.TotalBandwidthValue
}

// Total server bandwidth.
// Format: speed (speed)
// Example: 1e+09
func (s *ServerConfigBaseImpl) SetTotalBandwidth(v Speed) ServerConfigBase {
	if s == nil {
		return nil
	}
	s.TotalBandwidthValue = &v
	return s
}

// This option applies to HLS and DASH protocols, for all streams on the server.
// The addresses of individual segments within a segment-based playlist will start with the specified prefix.
// This setting is available in the global part of the config file as well as locally for any individual stream.
// When specified at the stream level, it is only valid for this particular stream.
func (s ServerConfigBaseImpl) URLPrefix() *URLPrefix {
	return s.URLPrefixValue
}

// This option applies to HLS and DASH protocols, for all streams on the server.
// The addresses of individual segments within a segment-based playlist will start with the specified prefix.
// This setting is available in the global part of the config file as well as locally for any individual stream.
// When specified at the stream level, it is only valid for this particular stream.
func (s *ServerConfigBaseImpl) SetURLPrefix(v *URLPrefix) ServerConfigBase {
	if s == nil {
		return nil
	}
	s.URLPrefixValue = v
	return s
}

// Credentials for access to readonly API functions like getting streams info, status, and statistics.
func (s ServerConfigBaseImpl) ViewAuth() AdminCredentials {
	return s.ViewAuthValue
}

// Credentials for access to readonly API functions like getting streams info, status, and statistics.
func (s *ServerConfigBaseImpl) SetViewAuth(v AdminCredentials) ServerConfigBase {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*AdminCredentialsImpl); ok {
		s.ViewAuthValue = impl
	}
	return s
}

// Global WebRTC ports configuration for playback (via WHEP - WebRTC HTTP egress protocol).
func (s ServerConfigBaseImpl) WebrtcPlay() WebrtcRouterConfig {
	return s.WebrtcPlayValue
}

// Global WebRTC ports configuration for playback (via WHEP - WebRTC HTTP egress protocol).
func (s *ServerConfigBaseImpl) SetWebrtcPlay(v WebrtcRouterConfig) ServerConfigBase {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*WebrtcRouterConfigImpl); ok {
		s.WebrtcPlayValue = impl
	}
	return s
}

// Global WebRTC ports configuration for publishing (via WHIP - WebRTC HTTP ingestion protocol).
func (s ServerConfigBaseImpl) WebrtcPublish() WebrtcRouterConfig {
	return s.WebrtcPublishValue
}

// Global WebRTC ports configuration for publishing (via WHIP - WebRTC HTTP ingestion protocol).
func (s *ServerConfigBaseImpl) SetWebrtcPublish(v WebrtcRouterConfig) ServerConfigBase {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*WebrtcRouterConfigImpl); ok {
		s.WebrtcPublishValue = impl
	}
	return s
}

// NewServerConfigFull creates a new ServerConfigFull instance
func NewServerConfigFull() ServerConfigFull {
	return &ServerConfigFullImpl{}
}

// The configuration of auth backends
func (s ServerConfigFullImpl) AuthBackends() []AuthBackendConfig {
	if s.AuthBackendsValue == nil {
		return nil
	}
	result := make([]AuthBackendConfig, len(s.AuthBackendsValue))
	for i, item := range s.AuthBackendsValue {
		result[i] = item
	}
	return result
}

// The configuration of auth backends
func (s *ServerConfigFullImpl) SetAuthBackends(v []AuthBackendConfig) ServerConfigFull {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*AuthBackendConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*AuthBackendConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.AuthBackendsValue = impl
	}
	return s
}

// The configuration of the balancers.
func (s ServerConfigFullImpl) Balancers() []BalancerConfig {
	if s.BalancersValue == nil {
		return nil
	}
	result := make([]BalancerConfig, len(s.BalancersValue))
	for i, item := range s.BalancersValue {
		result[i] = item
	}
	return result
}

// The configuration of the balancers.
func (s *ServerConfigFullImpl) SetBalancers(v []BalancerConfig) ServerConfigFull {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*BalancerConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*BalancerConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.BalancersValue = impl
	}
	return s
}

// The configuration of the cache.
func (s ServerConfigFullImpl) Caches() []CacheConfig {
	if s.CachesValue == nil {
		return nil
	}
	result := make([]CacheConfig, len(s.CachesValue))
	for i, item := range s.CachesValue {
		result[i] = item
	}
	return result
}

// The configuration of the cache.
func (s *ServerConfigFullImpl) SetCaches(v []CacheConfig) ServerConfigFull {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*CacheConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*CacheConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.CachesValue = impl
	}
	return s
}

// The configuration of the camera alarms.
func (s ServerConfigFullImpl) CameraAlarm() CameraAlarmConfig {
	return s.CameraAlarmValue
}

// The configuration of the camera alarms.
func (s *ServerConfigFullImpl) SetCameraAlarm(v CameraAlarmConfig) ServerConfigFull {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*CameraAlarmConfigImpl); ok {
		s.CameraAlarmValue = impl
	}
	return s
}

// The configuration of the chassis.
func (s ServerConfigFullImpl) Chassis() ChassisConfig {
	return s.ChassisValue
}

// The configuration of the chassis.
func (s *ServerConfigFullImpl) SetChassis(v ChassisConfig) ServerConfigFull {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ChassisConfigImpl); ok {
		s.ChassisValue = impl
	}
	return s
}

// Configuration of decklink SDI capture cards
func (s ServerConfigFullImpl) Decklinks() []DecklinkConfig {
	if s.DecklinksValue == nil {
		return nil
	}
	result := make([]DecklinkConfig, len(s.DecklinksValue))
	for i, item := range s.DecklinksValue {
		result[i] = item
	}
	return result
}

// Configuration of decklink SDI capture cards
func (s *ServerConfigFullImpl) SetDecklinks(v []DecklinkConfig) ServerConfigFull {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*DecklinkConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*DecklinkConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.DecklinksValue = impl
	}
	return s
}

// The configuration of the DVB cards.
func (s ServerConfigFullImpl) DvbCards() []DvbCardConfig {
	if s.DvbCardsValue == nil {
		return nil
	}
	result := make([]DvbCardConfig, len(s.DvbCardsValue))
	for i, item := range s.DvbCardsValue {
		result[i] = item
	}
	return result
}

// The configuration of the DVB cards.
func (s *ServerConfigFullImpl) SetDvbCards(v []DvbCardConfig) ServerConfigFull {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*DvbCardConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*DvbCardConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.DvbCardsValue = impl
	}
	return s
}

// The configuration of the DVRs
func (s ServerConfigFullImpl) Dvrs() []DvrConfig {
	if s.DvrsValue == nil {
		return nil
	}
	result := make([]DvrConfig, len(s.DvrsValue))
	for i, item := range s.DvrsValue {
		result[i] = item
	}
	return result
}

// The configuration of the DVRs
func (s *ServerConfigFullImpl) SetDvrs(v []DvrConfig) ServerConfigFull {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*DvrConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*DvrConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.DvrsValue = impl
	}
	return s
}

// The configuration of event notifications
func (s ServerConfigFullImpl) EventSinks() []EventSinkConfig {
	if s.EventSinksValue == nil {
		return nil
	}
	result := make([]EventSinkConfig, len(s.EventSinksValue))
	for i, item := range s.EventSinksValue {
		result[i] = item
	}
	return result
}

// The configuration of event notifications
func (s *ServerConfigFullImpl) SetEventSinks(v []EventSinkConfig) ServerConfigFull {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*EventSinkConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*EventSinkConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.EventSinksValue = impl
	}
	return s
}

// The configuration of the file processor.
func (s ServerConfigFullImpl) FileProcessor() FileProcessorConfig {
	return s.FileProcessorValue
}

// The configuration of the file processor.
func (s *ServerConfigFullImpl) SetFileProcessor(v FileProcessorConfig) ServerConfigFull {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*FileProcessorConfigImpl); ok {
		s.FileProcessorValue = impl
	}
	return s
}

// List of HTTP prefixes that can be handled via call to remote http server
func (s ServerConfigFullImpl) HTTPProxies() []HTTPProxyConfig {
	if s.HTTPProxiesValue == nil {
		return nil
	}
	result := make([]HTTPProxyConfig, len(s.HTTPProxiesValue))
	for i, item := range s.HTTPProxiesValue {
		result[i] = item
	}
	return result
}

// List of HTTP prefixes that can be handled via call to remote http server
func (s *ServerConfigFullImpl) SetHTTPProxies(v []HTTPProxyConfig) ServerConfigFull {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*HTTPProxyConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*HTTPProxyConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.HTTPProxiesValue = impl
	}
	return s
}

// The configuration of the IPTV
func (s ServerConfigFullImpl) Iptv() IptvConfig {
	return s.IptvValue
}

// The configuration of the IPTV
func (s *ServerConfigFullImpl) SetIptv(v IptvConfig) ServerConfigFull {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*IptvConfigImpl); ok {
		s.IptvValue = impl
	}
	return s
}

// The configuration of peers in the cluster.
func (s ServerConfigFullImpl) Peers() []PeerConfig {
	if s.PeersValue == nil {
		return nil
	}
	result := make([]PeerConfig, len(s.PeersValue))
	for i, item := range s.PeersValue {
		result[i] = item
	}
	return result
}

// The configuration of peers in the cluster.
func (s *ServerConfigFullImpl) SetPeers(v []PeerConfig) ServerConfigFull {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*PeerConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*PeerConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.PeersValue = impl
	}
	return s
}

// The configuration of the port forwarding.
func (s ServerConfigFullImpl) Rproxy() RproxyConfig {
	return s.RproxyValue
}

// The configuration of the port forwarding.
func (s *ServerConfigFullImpl) SetRproxy(v RproxyConfig) ServerConfigFull {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*RproxyConfigImpl); ok {
		s.RproxyValue = impl
	}
	return s
}

// The configuration of the video sources.
func (s ServerConfigFullImpl) Sources() []SourceConfig {
	if s.SourcesValue == nil {
		return nil
	}
	result := make([]SourceConfig, len(s.SourcesValue))
	for i, item := range s.SourcesValue {
		result[i] = item
	}
	return result
}

// The configuration of the video sources.
func (s *ServerConfigFullImpl) SetSources(v []SourceConfig) ServerConfigFull {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*SourceConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*SourceConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.SourcesValue = impl
	}
	return s
}

// The configuration of the streams.
func (s ServerConfigFullImpl) Streams() []StreamConfig {
	if s.StreamsValue == nil {
		return nil
	}
	result := make([]StreamConfig, len(s.StreamsValue))
	for i, item := range s.StreamsValue {
		result[i] = item
	}
	return result
}

// The configuration of the streams.
func (s *ServerConfigFullImpl) SetStreams(v []StreamConfig) ServerConfigFull {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*StreamConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*StreamConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.StreamsValue = impl
	}
	return s
}

// The configuration of the templates.
func (s ServerConfigFullImpl) Templates() []TemplateConfig {
	if s.TemplatesValue == nil {
		return nil
	}
	result := make([]TemplateConfig, len(s.TemplatesValue))
	for i, item := range s.TemplatesValue {
		result[i] = item
	}
	return result
}

// The configuration of the templates.
func (s *ServerConfigFullImpl) SetTemplates(v []TemplateConfig) ServerConfigFull {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*TemplateConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*TemplateConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.TemplatesValue = impl
	}
	return s
}

// The configuration of the transponders.
func (s ServerConfigFullImpl) Transponders() []TransponderConfig {
	if s.TranspondersValue == nil {
		return nil
	}
	result := make([]TransponderConfig, len(s.TranspondersValue))
	for i, item := range s.TranspondersValue {
		result[i] = item
	}
	return result
}

// The configuration of the transponders.
func (s *ServerConfigFullImpl) SetTransponders(v []TransponderConfig) ServerConfigFull {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*TransponderConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*TransponderConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.TranspondersValue = impl
	}
	return s
}

// The configuration of VODs
func (s ServerConfigFullImpl) Vods() []VodConfig {
	if s.VodsValue == nil {
		return nil
	}
	result := make([]VodConfig, len(s.VodsValue))
	for i, item := range s.VodsValue {
		result[i] = item
	}
	return result
}

// The configuration of VODs
func (s *ServerConfigFullImpl) SetVods(v []VodConfig) ServerConfigFull {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*VodConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*VodConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.VodsValue = impl
	}
	return s
}

// The configuration of the video surveillance subsystem.
func (s ServerConfigFullImpl) Vsaas() VsaasConfig {
	return s.VsaasValue
}

// The configuration of the video surveillance subsystem.
func (s *ServerConfigFullImpl) SetVsaas(v VsaasConfig) ServerConfigFull {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VsaasConfigImpl); ok {
		s.VsaasValue = impl
	}
	return s
}

// NewServerNameConfig creates a new ServerNameConfig instance
func NewServerNameConfig() ServerNameConfig {
	return &ServerNameConfigImpl{}
}

// List of domain aliases, used together with the primary name to issue ssl certs
// Example: [s1.streamer.local s2.streamer.local]
func (s ServerNameConfigImpl) Aliases() []string {
	return s.AliasesValue
}

// List of domain aliases, used together with the primary name to issue ssl certs
// Example: [s1.streamer.local s2.streamer.local]
func (s *ServerNameConfigImpl) SetAliases(v []string) ServerNameConfig {
	if s == nil {
		return nil
	}
	s.AliasesValue = v
	return s
}

// Domain names to issue ssl certificates for
// Example: streamer.local
func (s ServerNameConfigImpl) Domain() string {
	return s.DomainValue
}

// Domain names to issue ssl certificates for
// Example: streamer.local
func (s *ServerNameConfigImpl) SetDomain(v string) ServerNameConfig {
	if s == nil {
		return nil
	}
	s.DomainValue = v
	return s
}

// NewServerStatsNetwork creates a new ServerStatsNetwork instance
func NewServerStatsNetwork() ServerStatsNetwork {
	return &ServerStatsNetworkImpl{}
}

// Current incoming speed (bitrate) of the data transmission over the network.
// Format: speed (speed)
// Example: 400300
func (s ServerStatsNetworkImpl) InputKbit() *Speed {
	return s.InputKbitValue
}

// Current incoming speed (bitrate) of the data transmission over the network.
// Format: speed (speed)
// Example: 400300
func (s *ServerStatsNetworkImpl) SetInputKbit(v Speed) ServerStatsNetwork {
	if s == nil {
		return nil
	}
	s.InputKbitValue = &v
	return s
}

// The number of streams that are ready to be served to the clients.
// Example: 27
func (s ServerStatsNetworkImpl) OnlineStreams() *int {
	return s.OnlineStreamsValue
}

// The number of streams that are ready to be served to the clients.
// Example: 27
func (s *ServerStatsNetworkImpl) SetOnlineStreams(v int) ServerStatsNetwork {
	if s == nil {
		return nil
	}
	s.OnlineStreamsValue = &v
	return s
}

// The number of opened files.
// Example: 5
func (s ServerStatsNetworkImpl) OpenedFiles() *int {
	return s.OpenedFilesValue
}

// The number of opened files.
// Example: 5
func (s *ServerStatsNetworkImpl) SetOpenedFiles(v int) ServerStatsNetwork {
	if s == nil {
		return nil
	}
	s.OpenedFilesValue = &v
	return s
}

// Current outgoing speed (bitrate) of the data transmission over the network.
// Format: speed (speed)
// Example: 500400
func (s ServerStatsNetworkImpl) OutputKbit() *Speed {
	return s.OutputKbitValue
}

// Current outgoing speed (bitrate) of the data transmission over the network.
// Format: speed (speed)
// Example: 500400
func (s *ServerStatsNetworkImpl) SetOutputKbit(v Speed) ServerStatsNetwork {
	if s == nil {
		return nil
	}
	s.OutputKbitValue = &v
	return s
}

// The number of clients receiving the streams from the server at the moment of request.
// Example: 2040
func (s ServerStatsNetworkImpl) TotalClients() *int {
	return s.TotalClientsValue
}

// The number of clients receiving the streams from the server at the moment of request.
// Example: 2040
func (s *ServerStatsNetworkImpl) SetTotalClients(v int) ServerStatsNetwork {
	if s == nil {
		return nil
	}
	s.TotalClientsValue = &v
	return s
}

// The number of streams created on the server.
// Example: 45
func (s ServerStatsNetworkImpl) TotalStreams() *int {
	return s.TotalStreamsValue
}

// The number of streams created on the server.
// Example: 45
func (s *ServerStatsNetworkImpl) SetTotalStreams(v int) ServerStatsNetwork {
	if s == nil {
		return nil
	}
	s.TotalStreamsValue = &v
	return s
}

// NewServerStatsStreamer creates a new ServerStatsStreamer instance
func NewServerStatsStreamer() ServerStatsStreamer {
	return &ServerStatsStreamerImpl{}
}

// Outbound bandwidth usage (load balancing in `usage` mode is based on this value).
// Format: percent (percent)
// Example: 67
func (s ServerStatsStreamerImpl) BandwidthUsage() *Percent {
	return s.BandwidthUsageValue
}

// Outbound bandwidth usage (load balancing in `usage` mode is based on this value).
// Format: percent (percent)
// Example: 67
func (s *ServerStatsStreamerImpl) SetBandwidthUsage(v Percent) ServerStatsStreamer {
	if s == nil {
		return nil
	}
	s.BandwidthUsageValue = &v
	return s
}

// Information about errors in the config file.
func (s ServerStatsStreamerImpl) ConfigError() ConfigErrorStatus {
	return s.ConfigErrorValue
}

// Information about errors in the config file.
func (s *ServerStatsStreamerImpl) SetConfigError(v ConfigErrorStatus) ServerStatsStreamer {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ConfigErrorStatusImpl); ok {
		s.ConfigErrorValue = impl
	}
	return s
}

// Information about current external config status
func (s ServerStatsStreamerImpl) ConfigExternalStatus() ConfigExternalErrorStatus {
	return s.ConfigExternalStatusValue
}

// Information about current external config status
func (s *ServerStatsStreamerImpl) SetConfigExternalStatus(v ConfigExternalErrorStatus) ServerStatsStreamer {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ConfigExternalErrorStatusImpl); ok {
		s.ConfigExternalStatusValue = impl
	}
	return s
}

// Current runtime version of config. We do not declare exact structure, but we promise
// that it will be always comparable and increasing (if server has proper NTP configuration, of course).
// Right now it is a tuple of server start time and incrementing version of config.
// Example: [1.636709231e+09 4]
func (s ServerStatsStreamerImpl) ConfigVersion() []int {
	return s.ConfigVersionValue
}

// Current runtime version of config. We do not declare exact structure, but we promise
// that it will be always comparable and increasing (if server has proper NTP configuration, of course).
// Right now it is a tuple of server start time and incrementing version of config.
// Example: [1.636709231e+09 4]
func (s *ServerStatsStreamerImpl) SetConfigVersion(v []int) ServerStatsStreamer {
	if s == nil {
		return nil
	}
	s.ConfigVersionValue = v
	return s
}

// CPU usage on the server.
// Format: percent (percent)
// Example: 48
func (s ServerStatsStreamerImpl) CpuUsage() *Percent {
	return s.CpuUsageValue
}

// CPU usage on the server.
// Format: percent (percent)
// Example: 48
func (s *ServerStatsStreamerImpl) SetCpuUsage(v Percent) ServerStatsStreamer {
	if s == nil {
		return nil
	}
	s.CpuUsageValue = &v
	return s
}

// Hostname of your server. Please, use FQDN, do not leave your Linux misconfigured.
// Example: openapi.flussonic.com
func (s ServerStatsStreamerImpl) Hostname() *string {
	return s.HostnameValue
}

// Hostname of your server. Please, use FQDN, do not leave your Linux misconfigured.
// Example: openapi.flussonic.com
func (s *ServerStatsStreamerImpl) SetHostname(v string) ServerStatsStreamer {
	if s == nil {
		return nil
	}
	s.HostnameValue = &v
	return s
}

// Unique runtime ID of this instance. Updated with the restart.
// Format: uuid (uuid)
// Example: 61893b15-75b2-4fcb-b4cf-ae1dd0858ea2
func (s ServerStatsStreamerImpl) ID() *UUID {
	return s.IDValue
}

// Unique runtime ID of this instance. Updated with the restart.
// Format: uuid (uuid)
// Example: 61893b15-75b2-4fcb-b4cf-ae1dd0858ea2
func (s *ServerStatsStreamerImpl) SetID(v UUID) ServerStatsStreamer {
	if s == nil {
		return nil
	}
	s.IDValue = &v
	return s
}

// The flag shows if Flussonic runs on Flussonic Coder.
func (s ServerStatsStreamerImpl) IsChassis() *bool {
	return s.IsChassisValue
}

// The flag shows if Flussonic runs on Flussonic Coder.
func (s *ServerStatsStreamerImpl) SetIsChassis(v bool) ServerStatsStreamer {
	if s == nil {
		return nil
	}
	s.IsChassisValue = &v
	return s
}

// The code of the license applied on the server.
// Example: uO8v12HJhNXVj5gM
func (s ServerStatsStreamerImpl) LicenseTxt() *string {
	return s.LicenseTxtValue
}

// The code of the license applied on the server.
// Example: uO8v12HJhNXVj5gM
func (s *ServerStatsStreamerImpl) SetLicenseTxt(v string) ServerStatsStreamer {
	if s == nil {
		return nil
	}
	s.LicenseTxtValue = &v
	return s
}

// The license type.
func (s ServerStatsStreamerImpl) LicenseType() *LicenseType {
	return s.LicenseTypeValue
}

// The license type.
func (s *ServerStatsStreamerImpl) SetLicenseType(v LicenseType) ServerStatsStreamer {
	if s == nil {
		return nil
	}
	s.LicenseTypeValue = &v
	return s
}

// Memory usage on the server.
// Format: percent (percent)
// Example: 27
func (s ServerStatsStreamerImpl) MemoryUsage() *Percent {
	return s.MemoryUsageValue
}

// Memory usage on the server.
// Format: percent (percent)
// Example: 27
func (s *ServerStatsStreamerImpl) SetMemoryUsage(v Percent) ServerStatsStreamer {
	if s == nil {
		return nil
	}
	s.MemoryUsageValue = &v
	return s
}

// Notification about a newer version in the repository.
// Format: server_version (server_version)
// Example: 22.01
func (s ServerStatsStreamerImpl) NextVersion() *ServerVersion {
	return s.NextVersionValue
}

// Notification about a newer version in the repository.
// Format: server_version (server_version)
// Example: 22.01
func (s *ServerStatsStreamerImpl) SetNextVersion(v ServerVersion) ServerStatsStreamer {
	if s == nil {
		return nil
	}
	s.NextVersionValue = &v
	return s
}

// The list of disk partitions on the server.
func (s ServerStatsStreamerImpl) Partitions() []PartitionStats {
	if s.PartitionsValue == nil {
		return nil
	}
	result := make([]PartitionStats, len(s.PartitionsValue))
	for i, item := range s.PartitionsValue {
		result[i] = item
	}
	return result
}

// The list of disk partitions on the server.
func (s *ServerStatsStreamerImpl) SetPartitions(v []PartitionStats) ServerStatsStreamer {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*PartitionStatsImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*PartitionStatsImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.PartitionsValue = impl
	}
	return s
}

// Shows if rproxy is configured.
func (s ServerStatsStreamerImpl) Rproxy() *bool {
	return s.RproxyValue
}

// Shows if rproxy is configured.
func (s *ServerStatsStreamerImpl) SetRproxy(v bool) ServerStatsStreamer {
	if s == nil {
		return nil
	}
	s.RproxyValue = &v
	return s
}

// Shows if rproxy is running.
func (s ServerStatsStreamerImpl) RproxyRunning() *bool {
	return s.RproxyRunningValue
}

// Shows if rproxy is running.
func (s *ServerStatsStreamerImpl) SetRproxyRunning(v bool) ServerStatsStreamer {
	if s == nil {
		return nil
	}
	s.RproxyRunningValue = &v
	return s
}

// Erlang scheduler load.
// Format: percent (percent)
// Example: 40
func (s ServerStatsStreamerImpl) SchedulerLoad() *Percent {
	return s.SchedulerLoadValue
}

// Erlang scheduler load.
// Format: percent (percent)
// Example: 40
func (s *ServerStatsStreamerImpl) SetSchedulerLoad(v Percent) ServerStatsStreamer {
	if s == nil {
		return nil
	}
	s.SchedulerLoadValue = &v
	return s
}

// *Flussonic* will always try to start even if there are severe errors that do not
// allow functioning.
// `starting` status means you should wait for some time (not more than
// a minute).
// `running` status means all configuration was loaded. However, the status does not provide
// an information about your streams and the quality of provided service.
// All other statuses mean there are some severe problems on the server
// that cannot be repaired by Flussonic itself.
func (s ServerStatsStreamerImpl) StreamerStatus() *ServerStatsStreamerStatus {
	return s.StreamerStatusValue
}

// *Flussonic* will always try to start even if there are severe errors that do not
// allow functioning.
// `starting` status means you should wait for some time (not more than
// a minute).
// `running` status means all configuration was loaded. However, the status does not provide
// an information about your streams and the quality of provided service.
// All other statuses mean there are some severe problems on the server
// that cannot be repaired by Flussonic itself.
func (s *ServerStatsStreamerImpl) SetStreamerStatus(v ServerStatsStreamerStatus) ServerStatsStreamer {
	if s == nil {
		return nil
	}
	s.StreamerStatusValue = &v
	return s
}

// Human-readable format of errors and alerts that need to be fixed.
// Provided by some *Flussonic* subsystems.
func (s ServerStatsStreamerImpl) TextAlerts() map[string]string {
	return s.TextAlertsValue
}

// Human-readable format of errors and alerts that need to be fixed.
// Provided by some *Flussonic* subsystems.
func (s *ServerStatsStreamerImpl) SetTextAlerts(v map[string]string) ServerStatsStreamer {
	if s == nil {
		return nil
	}
	s.TextAlertsValue = v
	return s
}

// Deprecated field. Will be deleted at 22.03
// Total server bandwidth.
// Format: speed (speed)
func (s ServerStatsStreamerImpl) TotalBandwidth() *Speed {
	return s.TotalBandwidthValue
}

// Deprecated field. Will be deleted at 22.03
// Total server bandwidth.
// Format: speed (speed)
func (s *ServerStatsStreamerImpl) SetTotalBandwidth(v Speed) ServerStatsStreamer {
	if s == nil {
		return nil
	}
	s.TotalBandwidthValue = &v
	return s
}

// Shows if the server's CPU can be used for transcoding
// (i.e. if the `flussonic-transcoder` package is installed on the server).
func (s ServerStatsStreamerImpl) Transcoder() *bool {
	return s.TranscoderValue
}

// Shows if the server's CPU can be used for transcoding
// (i.e. if the `flussonic-transcoder` package is installed on the server).
func (s *ServerStatsStreamerImpl) SetTranscoder(v bool) ServerStatsStreamer {
	if s == nil {
		return nil
	}
	s.TranscoderValue = &v
	return s
}

// Statistics on the devices used for transcoding.
func (s ServerStatsStreamerImpl) TranscoderDevices() []TranscoderDeviceStats {
	if s.TranscoderDevicesValue == nil {
		return nil
	}
	result := make([]TranscoderDeviceStats, len(s.TranscoderDevicesValue))
	for i, item := range s.TranscoderDevicesValue {
		result[i] = item
	}
	return result
}

// Statistics on the devices used for transcoding.
func (s *ServerStatsStreamerImpl) SetTranscoderDevices(v []TranscoderDeviceStats) ServerStatsStreamer {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*TranscoderDeviceStatsImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*TranscoderDeviceStatsImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.TranscoderDevicesValue = impl
	}
	return s
}

// The server uptime.
// Format: seconds (seconds)
// Example: 4.325502e+06
func (s ServerStatsStreamerImpl) Uptime() *Seconds {
	return s.UptimeValue
}

// The server uptime.
// Format: seconds (seconds)
// Example: 4.325502e+06
func (s *ServerStatsStreamerImpl) SetUptime(v Seconds) ServerStatsStreamer {
	if s == nil {
		return nil
	}
	s.UptimeValue = &v
	return s
}

// Shows if Flussonic Watcher is enabled in the license.
func (s ServerStatsStreamerImpl) Vsaas() *bool {
	return s.VsaasValue
}

// Shows if Flussonic Watcher is enabled in the license.
func (s *ServerStatsStreamerImpl) SetVsaas(v bool) ServerStatsStreamer {
	if s == nil {
		return nil
	}
	s.VsaasValue = &v
	return s
}

// Shows if Watcher branding is enabled in the license.
func (s ServerStatsStreamerImpl) VsaasBranding() *bool {
	return s.VsaasBrandingValue
}

// Shows if Watcher branding is enabled in the license.
func (s *ServerStatsStreamerImpl) SetVsaasBranding(v bool) ServerStatsStreamer {
	if s == nil {
		return nil
	}
	s.VsaasBrandingValue = &v
	return s
}

// Shows if Watcher is currently running.
func (s ServerStatsStreamerImpl) VsaasRunning() *bool {
	return s.VsaasRunningValue
}

// Shows if Watcher is currently running.
func (s *ServerStatsStreamerImpl) SetVsaasRunning(v bool) ServerStatsStreamer {
	if s == nil {
		return nil
	}
	s.VsaasRunningValue = &v
	return s
}

// NewServerStatsWhoami creates a new ServerStatsWhoami instance
func NewServerStatsWhoami() ServerStatsWhoami {
	return &ServerStatsWhoamiImpl{}
}

// Build version
func (s ServerStatsWhoamiImpl) Build() *int {
	return s.BuildValue
}

// Build version
func (s *ServerStatsWhoamiImpl) SetBuild(v int) ServerStatsWhoami {
	if s == nil {
		return nil
	}
	s.BuildValue = &v
	return s
}

// Current response time
// Format: utc_ms (Unix timestamp in milliseconds)
func (s ServerStatsWhoamiImpl) Now() *UtcMs {
	return s.NowValue
}

// Current response time
// Format: utc_ms (Unix timestamp in milliseconds)
func (s *ServerStatsWhoamiImpl) SetNow(v UtcMs) ServerStatsWhoami {
	if s == nil {
		return nil
	}
	s.NowValue = &v
	return s
}

// Package version of the server. Might be simple a number of release like 21.11 or longer if you have a rolling release installed.
// Format: server_version (server_version)
// Example: 23.04
func (s ServerStatsWhoamiImpl) ServerVersion() *ServerVersion {
	return s.ServerVersionValue
}

// Package version of the server. Might be simple a number of release like 21.11 or longer if you have a rolling release installed.
// Format: server_version (server_version)
// Example: 23.04
func (s *ServerStatsWhoamiImpl) SetServerVersion(v ServerVersion) ServerStatsWhoami {
	if s == nil {
		return nil
	}
	s.ServerVersionValue = &v
	return s
}

// Boot time of this instance.
// Format: utc (Unix timestamp in seconds)
// Example: 1.639337825e+09
func (s ServerStatsWhoamiImpl) StartedAt() *Utc {
	return s.StartedAtValue
}

// Boot time of this instance.
// Format: utc (Unix timestamp in seconds)
// Example: 1.639337825e+09
func (s *ServerStatsWhoamiImpl) SetStartedAt(v Utc) ServerStatsWhoami {
	if s == nil {
		return nil
	}
	s.StartedAtValue = &v
	return s
}

// NewSharedToken creates a new SharedToken instance
func NewSharedToken() SharedToken {
	return &SharedTokenImpl{}
}

// Unique secret string
// Example: IJCo3KGLBf6NAqMCGgHf5gNhpl9
func (s SharedTokenImpl) Key() string {
	return s.KeyValue
}

// Unique secret string
// Example: IJCo3KGLBf6NAqMCGgHf5gNhpl9
func (s *SharedTokenImpl) SetKey(v string) SharedToken {
	if s == nil {
		return nil
	}
	s.KeyValue = v
	return s
}

// Stream that this shared token provides access to.
// Examples: cam1-abcdef
func (s SharedTokenImpl) Media() *string {
	return s.MediaValue
}

// Stream that this shared token provides access to.
// Examples: cam1-abcdef
func (s *SharedTokenImpl) SetMedia(v string) SharedToken {
	if s == nil {
		return nil
	}
	s.MediaValue = &v
	return s
}

// Unique name of the token that can be used to distinguish tokens
// Examples: root
func (s SharedTokenImpl) Name() string {
	return s.NameValue
}

// Unique name of the token that can be used to distinguish tokens
// Examples: root
func (s *SharedTokenImpl) SetName(v string) SharedToken {
	if s == nil {
		return nil
	}
	s.NameValue = v
	return s
}

// List of independent permissions, available for this shared token
func (s SharedTokenImpl) Permissions() []SharedTokenPermission {
	if s.PermissionsValue == nil {
		return nil
	}
	result := make([]SharedTokenPermission, len(s.PermissionsValue))
	for i, item := range s.PermissionsValue {
		result[i] = item
	}
	return result
}

// List of independent permissions, available for this shared token
func (s *SharedTokenImpl) SetPermissions(v []SharedTokenPermission) SharedToken {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*SharedTokenPermissionImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*SharedTokenPermissionImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.PermissionsValue = impl
	}
	return s
}

// NewSharedTokenPermission creates a new SharedTokenPermission instance
func NewSharedTokenPermission() SharedTokenPermission {
	return &SharedTokenPermissionImpl{}
}

// The advertising access allows you to show advertisements to viewers during viewing.
// Advertising works only in live mode.
func (s SharedTokenPermissionImpl) Advert() *bool {
	return s.AdvertValue
}

// The advertising access allows you to show advertisements to viewers during viewing.
// Advertising works only in live mode.
func (s *SharedTokenPermissionImpl) SetAdvert(v bool) SharedTokenPermission {
	if s == nil {
		return nil
	}
	s.AdvertValue = &v
	return s
}

// The DVR access allows the archive and play recordings of past broadcasts.
func (s SharedTokenPermissionImpl) Dvr() *bool {
	return s.DvrValue
}

// The DVR access allows the archive and play recordings of past broadcasts.
func (s *SharedTokenPermissionImpl) SetDvr(v bool) SharedTokenPermission {
	if s == nil {
		return nil
	}
	s.DvrValue = &v
	return s
}

// The dvr depth limit allows to:
// Set the maximum recording depth, which determines how far back recorded materials can be viewed.
// Manage access to archived data, ensuring security and control over who can access records.
// Format: seconds (seconds)
// Example: 3600
func (s SharedTokenPermissionImpl) DvrDepthLimit() *Seconds {
	return s.DvrDepthLimitValue
}

// The dvr depth limit allows to:
// Set the maximum recording depth, which determines how far back recorded materials can be viewed.
// Manage access to archived data, ensuring security and control over who can access records.
// Format: seconds (seconds)
// Example: 3600
func (s *SharedTokenPermissionImpl) SetDvrDepthLimit(v Seconds) SharedTokenPermission {
	if s == nil {
		return nil
	}
	s.DvrDepthLimitValue = &v
	return s
}

// The export access allows you to export the dvr to a file.
func (s SharedTokenPermissionImpl) Export() *bool {
	return s.ExportValue
}

// The export access allows you to export the dvr to a file.
func (s *SharedTokenPermissionImpl) SetExport(v bool) SharedTokenPermission {
	if s == nil {
		return nil
	}
	s.ExportValue = &v
	return s
}

// The live access token allows you to watch videos in real time.
func (s SharedTokenPermissionImpl) Live() *bool {
	return s.LiveValue
}

// The live access token allows you to watch videos in real time.
func (s *SharedTokenPermissionImpl) SetLive(v bool) SharedTokenPermission {
	if s == nil {
		return nil
	}
	s.LiveValue = &v
	return s
}

// The PTZ access allows to control the tilt and zoom of the camera.
// Change the position and focus of the camera during the broadcast.
func (s SharedTokenPermissionImpl) Ptz() *bool {
	return s.PtzValue
}

// The PTZ access allows to control the tilt and zoom of the camera.
// Change the position and focus of the camera during the broadcast.
func (s *SharedTokenPermissionImpl) SetPtz(v bool) SharedTokenPermission {
	if s == nil {
		return nil
	}
	s.PtzValue = &v
	return s
}

// NewSharedTokensList creates a new SharedTokensList instance
func NewSharedTokensList() SharedTokensList {
	return &SharedTokensListImpl{}
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s SharedTokensListImpl) EstimatedCount() *int {
	return s.EstimatedCountValue
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s *SharedTokensListImpl) SetEstimatedCount(v int) SharedTokensList {
	if s == nil {
		return nil
	}
	s.EstimatedCountValue = &v
	return s
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s SharedTokensListImpl) Next() *string {
	return s.NextValue
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s *SharedTokensListImpl) SetNext(v string) SharedTokensList {
	if s == nil {
		return nil
	}
	s.NextValue = &v
	return s
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s SharedTokensListImpl) Prev() *string {
	return s.PrevValue
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s *SharedTokensListImpl) SetPrev(v string) SharedTokensList {
	if s == nil {
		return nil
	}
	s.PrevValue = &v
	return s
}

// List of available shared tokens
func (s SharedTokensListImpl) SharedTokens() []SharedToken {
	if s.SharedTokensValue == nil {
		return nil
	}
	result := make([]SharedToken, len(s.SharedTokensValue))
	for i, item := range s.SharedTokensValue {
		result[i] = item
	}
	return result
}

// List of available shared tokens
func (s *SharedTokensListImpl) SetSharedTokens(v []SharedToken) SharedTokensList {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*SharedTokenImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*SharedTokenImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.SharedTokensValue = impl
	}
	return s
}

// An object with a list of different timings measured during this API call.
func (s SharedTokensListImpl) Timing() any {
	return s.TimingValue
}

// An object with a list of different timings measured during this API call.
func (s *SharedTokensListImpl) SetTiming(v any) SharedTokensList {
	if s == nil {
		return nil
	}
	s.TimingValue = v
	return s
}

// Collection returns the collection items from SharedTokensList
func (s SharedTokensListImpl) Collection() []SharedToken {
	return s.SharedTokens()
}

// NewSourceConfig creates a new SourceConfig instance
func NewSourceConfig() SourceConfig {
	return &SourceConfigImpl{}
}

// DVR configuraton.
func (s SourceConfigImpl) Dvr() StreamDvrSpec {
	return s.DvrValue
}

// DVR configuraton.
func (s *SourceConfigImpl) SetDvr(v StreamDvrSpec) SourceConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*StreamDvrSpecImpl); ok {
		s.DvrValue = impl
	}
	return s
}

// Stream labels in key value format.
// Key is a string in unix_name format (alphanumeric characters, underscores, hyphens and periods).
func (s SourceConfigImpl) Labels() map[string]UnixName {
	return s.LabelsValue
}

// Stream labels in key value format.
// Key is a string in unix_name format (alphanumeric characters, underscores, hyphens and periods).
func (s *SourceConfigImpl) SetLabels(v map[string]UnixName) SourceConfig {
	if s == nil {
		return nil
	}
	s.LabelsValue = v
	return s
}

// A list of pushes. When a server initiates the connection and sends a stream
// to other server(s), it is called a `push`.
func (s SourceConfigImpl) Pushes() []StreamPush {
	return s.PushesValue
}

// A list of pushes. When a server initiates the connection and sends a stream
// to other server(s), it is called a `push`.
func (s *SourceConfigImpl) SetPushes(v []StreamPush) SourceConfig {
	if s == nil {
		return nil
	}
	s.PushesValue = v
	return s
}

// Video analytics parameters.
func (s SourceConfigImpl) Vision() VisionSpec {
	return s.VisionValue
}

// Video analytics parameters.
func (s *SourceConfigImpl) SetVision(v VisionSpec) SourceConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionSpecImpl); ok {
		s.VisionValue = impl
	}
	return s
}

// NewSourceSpecificConfig creates a new SourceSpecificConfig instance
func NewSourceSpecificConfig() SourceSpecificConfig {
	return &SourceSpecificConfigImpl{}
}

// NewSrtConfig creates a new SrtConfig instance
func NewSrtConfig() SrtConfig {
	return &SrtConfigImpl{}
}

// Listening port or a `host:port` pair for the SRT configuration.
// Must be unique on the whole server.
// Example: 9050
func (s SrtConfigImpl) Port() *ListenSpec {
	return s.PortValue
}

// Listening port or a `host:port` pair for the SRT configuration.
// Must be unique on the whole server.
// Example: 9050
func (s *SrtConfigImpl) SetPort(v *ListenSpec) SrtConfig {
	if s == nil {
		return nil
	}
	s.PortValue = v
	return s
}

// Data transmission timeout in seconds.
// If set to `false` then data transmission time is unlimited. This is a defalut behavior.
// Example: 10
func (s SrtConfigImpl) Timeout() any {
	return s.TimeoutValue
}

// Data transmission timeout in seconds.
// If set to `false` then data transmission time is unlimited. This is a defalut behavior.
// Example: 10
func (s *SrtConfigImpl) SetTimeout(v any) SrtConfig {
	if s == nil {
		return nil
	}
	s.TimeoutValue = v
	return s
}

// NewSrtConfigBase creates a new SrtConfigBase instance
func NewSrtConfigBase() SrtConfigBase {
	return &SrtConfigBaseImpl{}
}

// NewStreamConfig creates a new StreamConfig instance
func NewStreamConfig() StreamConfig {
	return &StreamConfigImpl{}
}

// Audio settings for the stream.
func (s StreamConfigImpl) Audio() WatcherStreamConfigAudio {
	return s.AudioValue
}

// Audio settings for the stream.
func (s *StreamConfigImpl) SetAudio(v WatcherStreamConfigAudio) StreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*WatcherStreamConfigAudioImpl); ok {
		s.AudioValue = impl
	}
	return s
}

// A publishable stream.
// Example: false
func (s StreamConfigImpl) CanPublish() *bool {
	return s.CanPublishValue
}

// A publishable stream.
// Example: false
func (s *StreamConfigImpl) SetCanPublish(v bool) StreamConfig {
	if s == nil {
		return nil
	}
	s.CanPublishValue = &v
	return s
}

// Human-readable description of the stream.
// Example: This is a test stream
func (s StreamConfigImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the stream.
// Example: This is a test stream
func (s *StreamConfigImpl) SetComment(v string) StreamConfig {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Camera coordinates on a map or a floor plan.
func (s StreamConfigImpl) Coordinates() MapSpec {
	return s.CoordinatesValue
}

// Camera coordinates on a map or a floor plan.
func (s *StreamConfigImpl) SetCoordinates(v MapSpec) StreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*MapSpecImpl); ok {
		s.CoordinatesValue = impl
	}
	return s
}

// The date and time when the steam was created.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.672531199e+12
func (s StreamConfigImpl) CreatedAt() *UtcMs {
	return s.CreatedAtValue
}

// The date and time when the steam was created.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.672531199e+12
func (s *StreamConfigImpl) SetCreatedAt(v UtcMs) StreamConfig {
	if s == nil {
		return nil
	}
	s.CreatedAtValue = &v
	return s
}

// Whether a stream is disabled. Disabled streams are inactive and do not run.
// Displayed only with the API calls.
// Example: false
func (s StreamConfigImpl) Disabled() *bool {
	return s.DisabledValue
}

// Whether a stream is disabled. Disabled streams are inactive and do not run.
// Displayed only with the API calls.
// Example: false
func (s *StreamConfigImpl) SetDisabled(v bool) StreamConfig {
	if s == nil {
		return nil
	}
	s.DisabledValue = &v
	return s
}

// Domain the stream belongs to.
func (s StreamConfigImpl) Domain() DomainBase {
	return s.DomainValue
}

// Domain the stream belongs to.
func (s *StreamConfigImpl) SetDomain(v DomainBase) StreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*DomainBaseImpl); ok {
		s.DomainValue = impl
	}
	return s
}

// DVR configuraton.
func (s StreamConfigImpl) Dvr() StreamDvrSpec {
	return s.DvrValue
}

// DVR configuraton.
func (s *StreamConfigImpl) SetDvr(v StreamDvrSpec) StreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*StreamDvrSpecImpl); ok {
		s.DvrValue = impl
	}
	return s
}

// Duration of the firmware update. If this field is present, the update process is ongoing.
// Format: milliseconds (milliseconds)
func (s StreamConfigImpl) FirmwareUpdateDuration() *Milliseconds {
	return s.FirmwareUpdateDurationValue
}

// Duration of the firmware update. If this field is present, the update process is ongoing.
// Format: milliseconds (milliseconds)
func (s *StreamConfigImpl) SetFirmwareUpdateDuration(v Milliseconds) StreamConfig {
	if s == nil {
		return nil
	}
	s.FirmwareUpdateDurationValue = &v
	return s
}

// Folder identificator.
func (s StreamConfigImpl) FolderID() *int {
	return s.FolderIDValue
}

// Folder identificator.
func (s *StreamConfigImpl) SetFolderID(v int) StreamConfig {
	if s == nil {
		return nil
	}
	s.FolderIDValue = &v
	return s
}

// List of stream inputs.
// ***Important:*** A stream without any inputs can receive video frames **only** if backup file is specified.
func (s StreamConfigImpl) Inputs() []StreamInput {
	return s.InputsValue
}

// List of stream inputs.
// ***Important:*** A stream without any inputs can receive video frames **only** if backup file is specified.
func (s *StreamConfigImpl) SetInputs(v []StreamInput) StreamConfig {
	if s == nil {
		return nil
	}
	s.InputsValue = v
	return s
}

// Stream labels in key value format.
// Key is a string in unix_name format (alphanumeric characters, underscores, hyphens and periods).
func (s StreamConfigImpl) Labels() map[string]UnixName {
	return s.LabelsValue
}

// Stream labels in key value format.
// Key is a string in unix_name format (alphanumeric characters, underscores, hyphens and periods).
func (s *StreamConfigImpl) SetLabels(v map[string]UnixName) StreamConfig {
	if s == nil {
		return nil
	}
	s.LabelsValue = v
	return s
}

// Information about the latest changes made to the camera configuration.
func (s StreamConfigImpl) LastChange() AuditLogRecord {
	return s.LastChangeValue
}

// Information about the latest changes made to the camera configuration.
func (s *StreamConfigImpl) SetLastChange(v AuditLogRecord) StreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*AuditLogRecordImpl); ok {
		s.LastChangeValue = impl
	}
	return s
}

// The time when the last episode occurred.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s StreamConfigImpl) LastEpisodeAt() *UtcMs {
	return s.LastEpisodeAtValue
}

// The time when the last episode occurred.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *StreamConfigImpl) SetLastEpisodeAt(v UtcMs) StreamConfig {
	if s == nil {
		return nil
	}
	s.LastEpisodeAtValue = &v
	return s
}

// Layouts information
func (s StreamConfigImpl) Layout() CentralStreamLayout {
	return s.LayoutValue
}

// Layouts information
func (s *StreamConfigImpl) SetLayout(v CentralStreamLayout) StreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*CentralStreamLayoutImpl); ok {
		s.LayoutValue = impl
	}
	return s
}

// Rules of layout.
func (s StreamConfigImpl) LayoutRules() StreamZoneConfig {
	return s.LayoutRulesValue
}

// Rules of layout.
func (s *StreamConfigImpl) SetLayoutRules(v StreamZoneConfig) StreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*StreamZoneConfigImpl); ok {
		s.LayoutRulesValue = impl
	}
	return s
}

// Deprecated field. Will be deleted at 24.12
// Camera coordinates on a map or a floor plan. Deprecated. Use coordinates instead.
func (s StreamConfigImpl) MapCoordinates() MapSpec {
	return s.MapCoordinatesValue
}

// Deprecated field. Will be deleted at 24.12
// Camera coordinates on a map or a floor plan. Deprecated. Use coordinates instead.
func (s *StreamConfigImpl) SetMapCoordinates(v MapSpec) StreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*MapSpecImpl); ok {
		s.MapCoordinatesValue = impl
	}
	return s
}

// Globally unique stream name.
// Note that the name could not be changed after the stream is created.
// Format: media_name (media_name)
// Examples: Decklink-Stream, Dektec-Stream, hockey1, mylive/bunny, test_stream
func (s StreamConfigImpl) Name() MediaName {
	return s.NameValue
}

// Globally unique stream name.
// Note that the name could not be changed after the stream is created.
// Format: media_name (media_name)
// Examples: Decklink-Stream, Dektec-Stream, hockey1, mylive/bunny, test_stream
func (s *StreamConfigImpl) SetName(v MediaName) StreamConfig {
	if s == nil {
		return nil
	}
	s.NameValue = v
	return s
}

// Onvif configuration
func (s StreamConfigImpl) Onvif() StreamOnvifConfig {
	return s.OnvifValue
}

// Onvif configuration
func (s *StreamConfigImpl) SetOnvif(v StreamOnvifConfig) StreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*StreamOnvifConfigImpl); ok {
		s.OnvifValue = impl
	}
	return s
}

// Organization the stream belongs to.
func (s StreamConfigImpl) Organization() OrganizationStream {
	return s.OrganizationValue
}

// Organization the stream belongs to.
func (s *StreamConfigImpl) SetOrganization(v OrganizationStream) StreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*OrganizationStreamImpl); ok {
		s.OrganizationValue = impl
	}
	return s
}

// Deprecated field. Will be deleted at 25.11
// ID of the organization the stream belongs to.
// Only organization owner or domain administrator could change it.
// Example: 9
func (s StreamConfigImpl) OrganizationID() *int {
	return s.OrganizationIDValue
}

// Deprecated field. Will be deleted at 25.11
// ID of the organization the stream belongs to.
// Only organization owner or domain administrator could change it.
// Example: 9
func (s *StreamConfigImpl) SetOrganizationID(v int) StreamConfig {
	if s == nil {
		return nil
	}
	s.OrganizationIDValue = &v
	return s
}

// Contains path to stream as a list.
// Each item of the list can be interpreted as a node in a folders tree.
func (s StreamConfigImpl) Path() []StreamPathItem {
	if s.PathValue == nil {
		return nil
	}
	result := make([]StreamPathItem, len(s.PathValue))
	for i, item := range s.PathValue {
		result[i] = item
	}
	return result
}

// Contains path to stream as a list.
// Each item of the list can be interpreted as a node in a folders tree.
func (s *StreamConfigImpl) SetPath(v []StreamPathItem) StreamConfig {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*StreamPathItemImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*StreamPathItemImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.PathValue = impl
	}
	return s
}

// Camera adress on a map.
func (s StreamConfigImpl) PostalAddress() *string {
	return s.PostalAddressValue
}

// Camera adress on a map.
func (s *StreamConfigImpl) SetPostalAddress(v string) StreamConfig {
	if s == nil {
		return nil
	}
	s.PostalAddressValue = &v
	return s
}

// Preset settings.
func (s StreamConfigImpl) Preset() StreamPreset {
	return s.PresetValue
}

// Preset settings.
func (s *StreamConfigImpl) SetPreset(v StreamPreset) StreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*StreamPresetImpl); ok {
		s.PresetValue = impl
	}
	return s
}

// Deprecated field. Will be deleted at 26.01
// Preset identificator.
func (s StreamConfigImpl) PresetID() *int {
	return s.PresetIDValue
}

// Deprecated field. Will be deleted at 26.01
// Preset identificator.
func (s *StreamConfigImpl) SetPresetID(v int) StreamConfig {
	if s == nil {
		return nil
	}
	s.PresetIDValue = &v
	return s
}

// A list of pushes. When a server initiates the connection and sends a stream
// to other server(s), it is called a `push`.
func (s StreamConfigImpl) Pushes() []StreamPush {
	return s.PushesValue
}

// A list of pushes. When a server initiates the connection and sends a stream
// to other server(s), it is called a `push`.
func (s *StreamConfigImpl) SetPushes(v []StreamPush) StreamConfig {
	if s == nil {
		return nil
	}
	s.PushesValue = v
	return s
}

// Whether a stream is `static` or not.
// If set to `True` the server will try to keep this stream running even if
// there are no viewers or errors encountered.
// Streamer restarts *all* `static` streams even if any internal errors occur
// and the `static` streams crash.
// Example: true
func (s StreamConfigImpl) Static() *bool {
	return s.StaticValue
}

// Whether a stream is `static` or not.
// If set to `True` the server will try to keep this stream running even if
// there are no viewers or errors encountered.
// Streamer restarts *all* `static` streams even if any internal errors occur
// and the `static` streams crash.
// Example: true
func (s *StreamConfigImpl) SetStatic(v bool) StreamConfig {
	if s == nil {
		return nil
	}
	s.StaticValue = &v
	return s
}

// Stream's metrics and other statistical information.
func (s StreamConfigImpl) Stats() StreamStats {
	return s.StatsValue
}

// Stream's metrics and other statistical information.
func (s *StreamConfigImpl) SetStats(v StreamStats) StreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*StreamStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// Human-readable title of the stream. Provided for SDT MPEG-TS table or
// SDP RTSP title parameter.
// Example: Hockey channel
func (s StreamConfigImpl) Title() *string {
	return s.TitleValue
}

// Human-readable title of the stream. Provided for SDT MPEG-TS table or
// SDP RTSP title parameter.
// Example: Hockey channel
func (s *StreamConfigImpl) SetTitle(v string) StreamConfig {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// Video analytics parameters.
func (s StreamConfigImpl) Vision() VisionSpec {
	return s.VisionValue
}

// Video analytics parameters.
func (s *StreamConfigImpl) SetVision(v VisionSpec) StreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionSpecImpl); ok {
		s.VisionValue = impl
	}
	return s
}

// NewStreamConfigAdditional creates a new StreamConfigAdditional instance
func NewStreamConfigAdditional() StreamConfigAdditional {
	return &StreamConfigAdditionalImpl{}
}

// Stream's metrics and other statistical information.
func (s StreamConfigAdditionalImpl) Stats() StreamStats {
	return s.StatsValue
}

// Stream's metrics and other statistical information.
func (s *StreamConfigAdditionalImpl) SetStats(v StreamStats) StreamConfigAdditional {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*StreamStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// NewStreamConfigBase creates a new StreamConfigBase instance
func NewStreamConfigBase() StreamConfigBase {
	return &StreamConfigBaseImpl{}
}

// Whether a stream is disabled. Disabled streams are inactive and do not run.
// Displayed only with the API calls.
// Example: false
func (s StreamConfigBaseImpl) Disabled() *bool {
	return s.DisabledValue
}

// Whether a stream is disabled. Disabled streams are inactive and do not run.
// Displayed only with the API calls.
// Example: false
func (s *StreamConfigBaseImpl) SetDisabled(v bool) StreamConfigBase {
	if s == nil {
		return nil
	}
	s.DisabledValue = &v
	return s
}

// Whether a stream is `static` or not.
// If set to `True` the server will try to keep this stream running even if
// there are no viewers or errors encountered.
// Streamer restarts *all* `static` streams even if any internal errors occur
// and the `static` streams crash.
// Example: true
func (s StreamConfigBaseImpl) Static() *bool {
	return s.StaticValue
}

// Whether a stream is `static` or not.
// If set to `True` the server will try to keep this stream running even if
// there are no viewers or errors encountered.
// Streamer restarts *all* `static` streams even if any internal errors occur
// and the `static` streams crash.
// Example: true
func (s *StreamConfigBaseImpl) SetStatic(v bool) StreamConfigBase {
	if s == nil {
		return nil
	}
	s.StaticValue = &v
	return s
}

// NewStreamConfigDeprecated creates a new StreamConfigDeprecated instance
func NewStreamConfigDeprecated() StreamConfigDeprecated {
	return &StreamConfigDeprecatedImpl{}
}

// NewStreamConfigInput creates a new StreamConfigInput instance
func NewStreamConfigInput() StreamConfigInput {
	return &StreamConfigInputImpl{}
}

// List of stream inputs.
// ***Important:*** A stream without any inputs can receive video frames **only** if backup file is specified.
func (s StreamConfigInputImpl) Inputs() []StreamInput {
	return s.InputsValue
}

// List of stream inputs.
// ***Important:*** A stream without any inputs can receive video frames **only** if backup file is specified.
func (s *StreamConfigInputImpl) SetInputs(v []StreamInput) StreamConfigInput {
	if s == nil {
		return nil
	}
	s.InputsValue = v
	return s
}

// NewStreamConfigMedia creates a new StreamConfigMedia instance
func NewStreamConfigMedia() StreamConfigMedia {
	return &StreamConfigMediaImpl{}
}

// DVR configuraton.
func (s StreamConfigMediaImpl) Dvr() StreamDvrSpec {
	return s.DvrValue
}

// DVR configuraton.
func (s *StreamConfigMediaImpl) SetDvr(v StreamDvrSpec) StreamConfigMedia {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*StreamDvrSpecImpl); ok {
		s.DvrValue = impl
	}
	return s
}

// Stream labels in key value format.
// Key is a string in unix_name format (alphanumeric characters, underscores, hyphens and periods).
func (s StreamConfigMediaImpl) Labels() map[string]UnixName {
	return s.LabelsValue
}

// Stream labels in key value format.
// Key is a string in unix_name format (alphanumeric characters, underscores, hyphens and periods).
func (s *StreamConfigMediaImpl) SetLabels(v map[string]UnixName) StreamConfigMedia {
	if s == nil {
		return nil
	}
	s.LabelsValue = v
	return s
}

// A list of pushes. When a server initiates the connection and sends a stream
// to other server(s), it is called a `push`.
func (s StreamConfigMediaImpl) Pushes() []StreamPush {
	return s.PushesValue
}

// A list of pushes. When a server initiates the connection and sends a stream
// to other server(s), it is called a `push`.
func (s *StreamConfigMediaImpl) SetPushes(v []StreamPush) StreamConfigMedia {
	if s == nil {
		return nil
	}
	s.PushesValue = v
	return s
}

// NewStreamConfigMultiedit creates a new StreamConfigMultiedit instance
func NewStreamConfigMultiedit() StreamConfigMultiedit {
	return &StreamConfigMultieditImpl{}
}

// DVR configuration.
func (s StreamConfigMultieditImpl) Dvr() StreamDvrSpec {
	return s.DvrValue
}

// DVR configuration.
func (s *StreamConfigMultieditImpl) SetDvr(v StreamDvrSpec) StreamConfigMultiedit {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*StreamDvrSpecImpl); ok {
		s.DvrValue = impl
	}
	return s
}

// Rules of layout.
func (s StreamConfigMultieditImpl) LayoutRules() StreamZoneConfig {
	return s.LayoutRulesValue
}

// Rules of layout.
func (s *StreamConfigMultieditImpl) SetLayoutRules(v StreamZoneConfig) StreamConfigMultiedit {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*StreamZoneConfigImpl); ok {
		s.LayoutRulesValue = impl
	}
	return s
}

// Stream name
func (s StreamConfigMultieditImpl) Name() *string {
	return s.NameValue
}

// Stream name
func (s *StreamConfigMultieditImpl) SetName(v string) StreamConfigMultiedit {
	if s == nil {
		return nil
	}
	s.NameValue = &v
	return s
}

// Preset identificator.
func (s StreamConfigMultieditImpl) PresetID() *int {
	return s.PresetIDValue
}

// Preset identificator.
func (s *StreamConfigMultieditImpl) SetPresetID(v int) StreamConfigMultiedit {
	if s == nil {
		return nil
	}
	s.PresetIDValue = &v
	return s
}

// NewStreamConfigOnpremises creates a new StreamConfigOnpremises instance
func NewStreamConfigOnpremises() StreamConfigOnpremises {
	return &StreamConfigOnpremisesImpl{}
}

// Video analytics parameters.
func (s StreamConfigOnpremisesImpl) Vision() VisionSpec {
	return s.VisionValue
}

// Video analytics parameters.
func (s *StreamConfigOnpremisesImpl) SetVision(v VisionSpec) StreamConfigOnpremises {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionSpecImpl); ok {
		s.VisionValue = impl
	}
	return s
}

// NewStreamConfigSpecific creates a new StreamConfigSpecific instance
func NewStreamConfigSpecific() StreamConfigSpecific {
	return &StreamConfigSpecificImpl{}
}

// Human-readable description of the stream.
// Example: This is a test stream
func (s StreamConfigSpecificImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the stream.
// Example: This is a test stream
func (s *StreamConfigSpecificImpl) SetComment(v string) StreamConfigSpecific {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Globally unique stream name.
// Note that the name could not be changed after the stream is created.
// Format: media_name (media_name)
// Examples: Decklink-Stream, Dektec-Stream, hockey1, mylive/bunny, test_stream
func (s StreamConfigSpecificImpl) Name() MediaName {
	return s.NameValue
}

// Globally unique stream name.
// Note that the name could not be changed after the stream is created.
// Format: media_name (media_name)
// Examples: Decklink-Stream, Dektec-Stream, hockey1, mylive/bunny, test_stream
func (s *StreamConfigSpecificImpl) SetName(v MediaName) StreamConfigSpecific {
	if s == nil {
		return nil
	}
	s.NameValue = v
	return s
}

// Human-readable title of the stream. Provided for SDT MPEG-TS table or
// SDP RTSP title parameter.
// Example: Hockey channel
func (s StreamConfigSpecificImpl) Title() *string {
	return s.TitleValue
}

// Human-readable title of the stream. Provided for SDT MPEG-TS table or
// SDP RTSP title parameter.
// Example: Hockey channel
func (s *StreamConfigSpecificImpl) SetTitle(v string) StreamConfigSpecific {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// NewStreamDvrSpec creates a new StreamDvrSpec instance
func NewStreamDvrSpec() StreamDvrSpec {
	return &StreamDvrSpecImpl{}
}

// Maximum disk consumption in percents. When this limit is reached,
// the oldest segment of the recording will be overridden by later data.
// It important to understand that this is not a "per-stream" option, this option means
// that cleaning of this stream will be triggered if overall disk usage reaches this number.
// If you have all streams with configuration 98% and one stream with 95%, it will be permanently
// empty.
// Format: percent (percent)
// Example: 98
func (s StreamDvrSpecImpl) DiskUsageLimit() *Percent {
	return s.DiskUsageLimitValue
}

// Maximum disk consumption in percents. When this limit is reached,
// the oldest segment of the recording will be overridden by later data.
// It important to understand that this is not a "per-stream" option, this option means
// that cleaning of this stream will be triggered if overall disk usage reaches this number.
// If you have all streams with configuration 98% and one stream with 95%, it will be permanently
// empty.
// Format: percent (percent)
// Example: 98
func (s *StreamDvrSpecImpl) SetDiskUsageLimit(v Percent) StreamDvrSpec {
	if s == nil {
		return nil
	}
	s.DiskUsageLimitValue = &v
	return s
}

// Additional archive depth in seconds for episodes. If set, episodes and their corresponding DVR record
// will be saved for `expiration + episodes_expiration` seconds.
// The archive clean-up within `[expiration, expiration+episodes_expiration]` seconds of the
// recording performed depending on [external_episodes_list](https://flussonic.com/doc/api/config-external/#tag/dvr/operation/external_episodes_list)
// response of `episodes_url`.
// Anything older than `expiration+episodes_expiration` seconds will
// be cleaned even if `episodes_url` does not respond.
// Format: seconds (seconds)
// Examples: 6.048e+06
func (s StreamDvrSpecImpl) EpisodesExpiration() *Seconds {
	return s.EpisodesExpirationValue
}

// Additional archive depth in seconds for episodes. If set, episodes and their corresponding DVR record
// will be saved for `expiration + episodes_expiration` seconds.
// The archive clean-up within `[expiration, expiration+episodes_expiration]` seconds of the
// recording performed depending on [external_episodes_list](https://flussonic.com/doc/api/config-external/#tag/dvr/operation/external_episodes_list)
// response of `episodes_url`.
// Anything older than `expiration+episodes_expiration` seconds will
// be cleaned even if `episodes_url` does not respond.
// Format: seconds (seconds)
// Examples: 6.048e+06
func (s *StreamDvrSpecImpl) SetEpisodesExpiration(v Seconds) StreamDvrSpec {
	if s == nil {
		return nil
	}
	s.EpisodesExpirationValue = &v
	return s
}

// Archive depth - a period (in seconds) back from the current moment during which the
// contigious part of archive is stored.
// As time goes, the parts of the recording which are older than the archive depth are deleted.
// If you have option `episodes_expiration` enabled, then some parts of DVR that are
// locked by episode signalling mechanism may be kept more than this `expiration` depth.
// If `episodes_url` does not respond, the archive clean-up by `expiration` is not performed;
// only the archive with expired episodes (`episodes_expiration`) is cleaned up until the `episodes_url` restores.
// Format: seconds (seconds)
// Examples: 604800
func (s StreamDvrSpecImpl) Expiration() *Seconds {
	return s.ExpirationValue
}

// Archive depth - a period (in seconds) back from the current moment during which the
// contigious part of archive is stored.
// As time goes, the parts of the recording which are older than the archive depth are deleted.
// If you have option `episodes_expiration` enabled, then some parts of DVR that are
// locked by episode signalling mechanism may be kept more than this `expiration` depth.
// If `episodes_url` does not respond, the archive clean-up by `expiration` is not performed;
// only the archive with expired episodes (`episodes_expiration`) is cleaned up until the `episodes_url` restores.
// Format: seconds (seconds)
// Examples: 604800
func (s *StreamDvrSpecImpl) SetExpiration(v Seconds) StreamDvrSpec {
	if s == nil {
		return nil
	}
	s.ExpirationValue = &v
	return s
}

// How many servers will contain a copy of the DVR archive.
// You can find more information [here](https://flussonic.com/doc/api/layouter/#tag/stream/operation/streams_list/response%7Cstreams%7Cdvr%7Credundancy_factor)
// Example: 1
func (s StreamDvrSpecImpl) RedundancyFactor() *int {
	return s.RedundancyFactorValue
}

// How many servers will contain a copy of the DVR archive.
// You can find more information [here](https://flussonic.com/doc/api/layouter/#tag/stream/operation/streams_list/response%7Cstreams%7Cdvr%7Credundancy_factor)
// Example: 1
func (s *StreamDvrSpecImpl) SetRedundancyFactor(v int) StreamDvrSpec {
	if s == nil {
		return nil
	}
	s.RedundancyFactorValue = &v
	return s
}

// Maximum disk consumption in bytes. When this limit is reached,
// the oldest segment of the recording will be overridden by later data.
// This option affects both continuous recording and locked episodes (see `episodes_url`).
// If `episodes_url` does not respond, the archive clean-up by `storage_limit` is not performed
// to avoid deleting the recordings that should not be deleted.
// Format: bytes (bytes)
// Example: 4e+11
func (s StreamDvrSpecImpl) StorageLimit() *Bytes {
	return s.StorageLimitValue
}

// Maximum disk consumption in bytes. When this limit is reached,
// the oldest segment of the recording will be overridden by later data.
// This option affects both continuous recording and locked episodes (see `episodes_url`).
// If `episodes_url` does not respond, the archive clean-up by `storage_limit` is not performed
// to avoid deleting the recordings that should not be deleted.
// Format: bytes (bytes)
// Example: 4e+11
func (s *StreamDvrSpecImpl) SetStorageLimit(v Bytes) StreamDvrSpec {
	if s == nil {
		return nil
	}
	s.StorageLimitValue = &v
	return s
}

// NewStreamDvrSpecificSpec creates a new StreamDvrSpecificSpec instance
func NewStreamDvrSpecificSpec() StreamDvrSpecificSpec {
	return &StreamDvrSpecificSpecImpl{}
}

// How many servers will contain a copy of the DVR archive.
// You can find more information [here](https://flussonic.com/doc/api/layouter/#tag/stream/operation/streams_list/response%7Cstreams%7Cdvr%7Credundancy_factor)
// Example: 1
func (s StreamDvrSpecificSpecImpl) RedundancyFactor() *int {
	return s.RedundancyFactorValue
}

// How many servers will contain a copy of the DVR archive.
// You can find more information [here](https://flussonic.com/doc/api/layouter/#tag/stream/operation/streams_list/response%7Cstreams%7Cdvr%7Credundancy_factor)
// Example: 1
func (s *StreamDvrSpecificSpecImpl) SetRedundancyFactor(v int) StreamDvrSpecificSpec {
	if s == nil {
		return nil
	}
	s.RedundancyFactorValue = &v
	return s
}

// NewStreamInputBase creates a new StreamInputBase instance
func NewStreamInputBase() StreamInputBase {
	return &StreamInputBaseImpl{}
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s StreamInputBaseImpl) AllowIf() *string {
	return s.AllowIfValue
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s *StreamInputBaseImpl) SetAllowIf(v string) StreamInputBase {
	if s == nil {
		return nil
	}
	s.AllowIfValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputBaseImpl) AudioTimeout() *Seconds {
	return s.AudioTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputBaseImpl) SetAudioTimeout(v Seconds) StreamInputBase {
	if s == nil {
		return nil
	}
	s.AudioTimeoutValue = &v
	return s
}

// Human-readable description of the input.
// Example: This is a test input
func (s StreamInputBaseImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the input.
// Example: This is a test input
func (s *StreamInputBaseImpl) SetComment(v string) StreamInputBase {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s StreamInputBaseImpl) DenyIf() *string {
	return s.DenyIfValue
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s *StreamInputBaseImpl) SetDenyIf(v string) StreamInputBase {
	if s == nil {
		return nil
	}
	s.DenyIfValue = &v
	return s
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s StreamInputBaseImpl) FramesTimeout() *int {
	return s.FramesTimeoutValue
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s *StreamInputBaseImpl) SetFramesTimeout(v int) StreamInputBase {
	if s == nil {
		return nil
	}
	s.FramesTimeoutValue = &v
	return s
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s StreamInputBaseImpl) Headers() map[string]string {
	return s.HeadersValue
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s *StreamInputBaseImpl) SetHeaders(v map[string]string) StreamInputBase {
	if s == nil {
		return nil
	}
	s.HeadersValue = v
	return s
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s StreamInputBaseImpl) MaxRetryTimeout() *Seconds {
	return s.MaxRetryTimeoutValue
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s *StreamInputBaseImpl) SetMaxRetryTimeout(v Seconds) StreamInputBase {
	if s == nil {
		return nil
	}
	s.MaxRetryTimeoutValue = &v
	return s
}

// Skip input start if the stream has no clients.
func (s StreamInputBaseImpl) NoClientsReconnectDelay() *int {
	return s.NoClientsReconnectDelayValue
}

// Skip input start if the stream has no clients.
func (s *StreamInputBaseImpl) SetNoClientsReconnectDelay(v int) StreamInputBase {
	if s == nil {
		return nil
	}
	s.NoClientsReconnectDelayValue = &v
	return s
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s StreamInputBaseImpl) OutputAudio() *OutputAudio {
	return s.OutputAudioValue
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s *StreamInputBaseImpl) SetOutputAudio(v OutputAudio) StreamInputBase {
	if s == nil {
		return nil
	}
	s.OutputAudioValue = &v
	return s
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s StreamInputBaseImpl) Priority() *int {
	return s.PriorityValue
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s *StreamInputBaseImpl) SetPriority(v int) StreamInputBase {
	if s == nil {
		return nil
	}
	s.PriorityValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s StreamInputBaseImpl) SourceTimeout() any {
	return s.SourceTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s *StreamInputBaseImpl) SetSourceTimeout(v any) StreamInputBase {
	if s == nil {
		return nil
	}
	s.SourceTimeoutValue = v
	return s
}

// Detailed runtime information about the input.
func (s StreamInputBaseImpl) Stats() InputStats {
	return s.StatsValue
}

// Detailed runtime information about the input.
func (s *StreamInputBaseImpl) SetStats(v InputStats) StreamInputBase {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s StreamInputBaseImpl) Timeout() *int {
	return s.TimeoutValue
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s *StreamInputBaseImpl) SetTimeout(v int) StreamInputBase {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// User agent. Can be modified if a protocol allows it.
func (s StreamInputBaseImpl) UserAgent() *string {
	return s.UserAgentValue
}

// User agent. Can be modified if a protocol allows it.
func (s *StreamInputBaseImpl) SetUserAgent(v string) StreamInputBase {
	if s == nil {
		return nil
	}
	s.UserAgentValue = &v
	return s
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s StreamInputBaseImpl) Via() *AgentURL {
	return s.ViaValue
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s *StreamInputBaseImpl) SetVia(v AgentURL) StreamInputBase {
	if s == nil {
		return nil
	}
	s.ViaValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputBaseImpl) VideoTimeout() *Seconds {
	return s.VideoTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputBaseImpl) SetVideoTimeout(v Seconds) StreamInputBase {
	if s == nil {
		return nil
	}
	s.VideoTimeoutValue = &v
	return s
}

// NewStreamInputFake creates a new StreamInputFake instance
func NewStreamInputFake() StreamInputFake {
	return &StreamInputFakeImpl{}
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s StreamInputFakeImpl) AllowIf() *string {
	return s.AllowIfValue
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s *StreamInputFakeImpl) SetAllowIf(v string) StreamInputFake {
	if s == nil {
		return nil
	}
	s.AllowIfValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputFakeImpl) AudioTimeout() *Seconds {
	return s.AudioTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputFakeImpl) SetAudioTimeout(v Seconds) StreamInputFake {
	if s == nil {
		return nil
	}
	s.AudioTimeoutValue = &v
	return s
}

// Bitrate of an artificially created test video stream.
// Applicable to the `fake://fake` URL.
// Format: speed (speed)
func (s StreamInputFakeImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// Bitrate of an artificially created test video stream.
// Applicable to the `fake://fake` URL.
// Format: speed (speed)
func (s *StreamInputFakeImpl) SetBitrate(v Speed) StreamInputFake {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// Human-readable description of the input.
// Example: This is a test input
func (s StreamInputFakeImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the input.
// Example: This is a test input
func (s *StreamInputFakeImpl) SetComment(v string) StreamInputFake {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s StreamInputFakeImpl) DenyIf() *string {
	return s.DenyIfValue
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s *StreamInputFakeImpl) SetDenyIf(v string) StreamInputFake {
	if s == nil {
		return nil
	}
	s.DenyIfValue = &v
	return s
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s StreamInputFakeImpl) FramesTimeout() *int {
	return s.FramesTimeoutValue
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s *StreamInputFakeImpl) SetFramesTimeout(v int) StreamInputFake {
	if s == nil {
		return nil
	}
	s.FramesTimeoutValue = &v
	return s
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s StreamInputFakeImpl) Headers() map[string]string {
	return s.HeadersValue
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s *StreamInputFakeImpl) SetHeaders(v map[string]string) StreamInputFake {
	if s == nil {
		return nil
	}
	s.HeadersValue = v
	return s
}

// Height of an artificially created test video stream.
// Applicable to the `fake://fake` URL.
func (s StreamInputFakeImpl) Height() *int {
	return s.HeightValue
}

// Height of an artificially created test video stream.
// Applicable to the `fake://fake` URL.
func (s *StreamInputFakeImpl) SetHeight(v int) StreamInputFake {
	if s == nil {
		return nil
	}
	s.HeightValue = &v
	return s
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s StreamInputFakeImpl) MaxRetryTimeout() *Seconds {
	return s.MaxRetryTimeoutValue
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s *StreamInputFakeImpl) SetMaxRetryTimeout(v Seconds) StreamInputFake {
	if s == nil {
		return nil
	}
	s.MaxRetryTimeoutValue = &v
	return s
}

// Skip input start if the stream has no clients.
func (s StreamInputFakeImpl) NoClientsReconnectDelay() *int {
	return s.NoClientsReconnectDelayValue
}

// Skip input start if the stream has no clients.
func (s *StreamInputFakeImpl) SetNoClientsReconnectDelay(v int) StreamInputFake {
	if s == nil {
		return nil
	}
	s.NoClientsReconnectDelayValue = &v
	return s
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s StreamInputFakeImpl) OutputAudio() *OutputAudio {
	return s.OutputAudioValue
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s *StreamInputFakeImpl) SetOutputAudio(v OutputAudio) StreamInputFake {
	if s == nil {
		return nil
	}
	s.OutputAudioValue = &v
	return s
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s StreamInputFakeImpl) Priority() *int {
	return s.PriorityValue
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s *StreamInputFakeImpl) SetPriority(v int) StreamInputFake {
	if s == nil {
		return nil
	}
	s.PriorityValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s StreamInputFakeImpl) SourceTimeout() any {
	return s.SourceTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s *StreamInputFakeImpl) SetSourceTimeout(v any) StreamInputFake {
	if s == nil {
		return nil
	}
	s.SourceTimeoutValue = v
	return s
}

// Detailed runtime information about the input.
func (s StreamInputFakeImpl) Stats() InputStats {
	return s.StatsValue
}

// Detailed runtime information about the input.
func (s *StreamInputFakeImpl) SetStats(v InputStats) StreamInputFake {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s StreamInputFakeImpl) Timeout() *int {
	return s.TimeoutValue
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s *StreamInputFakeImpl) SetTimeout(v int) StreamInputFake {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// URL to get a demo stream.
// Format: input_url (input_url)
// Pattern: ^fake://.*$
// Example: fake://fake
func (s StreamInputFakeImpl) URL() InputURL {
	return s.URLValue
}

// URL to get a demo stream.
// Format: input_url (input_url)
// Pattern: ^fake://.*$
// Example: fake://fake
func (s *StreamInputFakeImpl) SetURL(v InputURL) StreamInputFake {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// User agent. Can be modified if a protocol allows it.
func (s StreamInputFakeImpl) UserAgent() *string {
	return s.UserAgentValue
}

// User agent. Can be modified if a protocol allows it.
func (s *StreamInputFakeImpl) SetUserAgent(v string) StreamInputFake {
	if s == nil {
		return nil
	}
	s.UserAgentValue = &v
	return s
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s StreamInputFakeImpl) Via() *AgentURL {
	return s.ViaValue
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s *StreamInputFakeImpl) SetVia(v AgentURL) StreamInputFake {
	if s == nil {
		return nil
	}
	s.ViaValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputFakeImpl) VideoTimeout() *Seconds {
	return s.VideoTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputFakeImpl) SetVideoTimeout(v Seconds) StreamInputFake {
	if s == nil {
		return nil
	}
	s.VideoTimeoutValue = &v
	return s
}

// Width of an artificially created test video stream.
// Applicable to the `fake://fake` URL.
func (s StreamInputFakeImpl) Width() *int {
	return s.WidthValue
}

// Width of an artificially created test video stream.
// Applicable to the `fake://fake` URL.
func (s *StreamInputFakeImpl) SetWidth(v int) StreamInputFake {
	if s == nil {
		return nil
	}
	s.WidthValue = &v
	return s
}

// NewStreamInputFile creates a new StreamInputFile instance
func NewStreamInputFile() StreamInputFile {
	return &StreamInputFileImpl{}
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s StreamInputFileImpl) AllowIf() *string {
	return s.AllowIfValue
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s *StreamInputFileImpl) SetAllowIf(v string) StreamInputFile {
	if s == nil {
		return nil
	}
	s.AllowIfValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputFileImpl) AudioTimeout() *Seconds {
	return s.AudioTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputFileImpl) SetAudioTimeout(v Seconds) StreamInputFile {
	if s == nil {
		return nil
	}
	s.AudioTimeoutValue = &v
	return s
}

// The rules for handling the closed captions.
func (s StreamInputFileImpl) ClosedCaptions() map[string]string {
	return s.ClosedCaptionsValue
}

// The rules for handling the closed captions.
func (s *StreamInputFileImpl) SetClosedCaptions(v map[string]string) StreamInputFile {
	if s == nil {
		return nil
	}
	s.ClosedCaptionsValue = v
	return s
}

// Human-readable description of the input.
// Example: This is a test input
func (s StreamInputFileImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the input.
// Example: This is a test input
func (s *StreamInputFileImpl) SetComment(v string) StreamInputFile {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s StreamInputFileImpl) DenyIf() *string {
	return s.DenyIfValue
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s *StreamInputFileImpl) SetDenyIf(v string) StreamInputFile {
	if s == nil {
		return nil
	}
	s.DenyIfValue = &v
	return s
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s StreamInputFileImpl) FramesTimeout() *int {
	return s.FramesTimeoutValue
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s *StreamInputFileImpl) SetFramesTimeout(v int) StreamInputFile {
	if s == nil {
		return nil
	}
	s.FramesTimeoutValue = &v
	return s
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s StreamInputFileImpl) Headers() map[string]string {
	return s.HeadersValue
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s *StreamInputFileImpl) SetHeaders(v map[string]string) StreamInputFile {
	if s == nil {
		return nil
	}
	s.HeadersValue = v
	return s
}

// An array of MPEG-TS language descriptors in format `[{key: track, value: language}]`
func (s StreamInputFileImpl) Languages() map[string]string {
	return s.LanguagesValue
}

// An array of MPEG-TS language descriptors in format `[{key: track, value: language}]`
func (s *StreamInputFileImpl) SetLanguages(v map[string]string) StreamInputFile {
	if s == nil {
		return nil
	}
	s.LanguagesValue = v
	return s
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s StreamInputFileImpl) MaxRetryTimeout() *Seconds {
	return s.MaxRetryTimeoutValue
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s *StreamInputFileImpl) SetMaxRetryTimeout(v Seconds) StreamInputFile {
	if s == nil {
		return nil
	}
	s.MaxRetryTimeoutValue = &v
	return s
}

// Skip input start if the stream has no clients.
func (s StreamInputFileImpl) NoClientsReconnectDelay() *int {
	return s.NoClientsReconnectDelayValue
}

// Skip input start if the stream has no clients.
func (s *StreamInputFileImpl) SetNoClientsReconnectDelay(v int) StreamInputFile {
	if s == nil {
		return nil
	}
	s.NoClientsReconnectDelayValue = &v
	return s
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s StreamInputFileImpl) OutputAudio() *OutputAudio {
	return s.OutputAudioValue
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s *StreamInputFileImpl) SetOutputAudio(v OutputAudio) StreamInputFile {
	if s == nil {
		return nil
	}
	s.OutputAudioValue = &v
	return s
}

// Choose a specific PID to ingest from an MPEG-TS stream.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Example: [211]
func (s StreamInputFileImpl) Pids() []int {
	return s.PidsValue
}

// Choose a specific PID to ingest from an MPEG-TS stream.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Example: [211]
func (s *StreamInputFileImpl) SetPids(v []int) StreamInputFile {
	if s == nil {
		return nil
	}
	s.PidsValue = v
	return s
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s StreamInputFileImpl) Priority() *int {
	return s.PriorityValue
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s *StreamInputFileImpl) SetPriority(v int) StreamInputFile {
	if s == nil {
		return nil
	}
	s.PriorityValue = &v
	return s
}

// Choose a program to ingest from an MPEG-TS stream.
// Example: [1]
func (s StreamInputFileImpl) Programs() []int {
	return s.ProgramsValue
}

// Choose a program to ingest from an MPEG-TS stream.
// Example: [1]
func (s *StreamInputFileImpl) SetPrograms(v []int) StreamInputFile {
	if s == nil {
		return nil
	}
	s.ProgramsValue = v
	return s
}

// Deprecated field. Will be deleted at 23.09
// This option disables processing of SCTE-35 markers from an MPEG-TS input stream.
// Deprecated since 22.12.
// Available ways to disable processing of SCTE-35 markers:
// 1. pids option to select tracks without SCTE-35 markers
// 2. hls_scte35 option from stream_config_media for hls output
// 3. performing appropriate tuning pids in the transponder
// Example: true
func (s StreamInputFileImpl) Scte35() *bool {
	return s.Scte35Value
}

// Deprecated field. Will be deleted at 23.09
// This option disables processing of SCTE-35 markers from an MPEG-TS input stream.
// Deprecated since 22.12.
// Available ways to disable processing of SCTE-35 markers:
// 1. pids option to select tracks without SCTE-35 markers
// 2. hls_scte35 option from stream_config_media for hls output
// 3. performing appropriate tuning pids in the transponder
// Example: true
func (s *StreamInputFileImpl) SetScte35(v bool) StreamInputFile {
	if s == nil {
		return nil
	}
	s.Scte35Value = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s StreamInputFileImpl) SourceTimeout() any {
	return s.SourceTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s *StreamInputFileImpl) SetSourceTimeout(v any) StreamInputFile {
	if s == nil {
		return nil
	}
	s.SourceTimeoutValue = v
	return s
}

// Detailed runtime information about the input.
func (s StreamInputFileImpl) Stats() InputStats {
	return s.StatsValue
}

// Detailed runtime information about the input.
func (s *StreamInputFileImpl) SetStats(v InputStats) StreamInputFile {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// Deprecated field. Will be deleted at 25.03
// This configuration is deprecated. Use `dvbocr` configuration field in stream.
// This parameter allows to manage subtitles in an output stream.
// Example: drop
func (s StreamInputFileImpl) Subtitles() *StreamInputMpegtsSpecificSubtitles {
	return s.SubtitlesValue
}

// Deprecated field. Will be deleted at 25.03
// This configuration is deprecated. Use `dvbocr` configuration field in stream.
// This parameter allows to manage subtitles in an output stream.
// Example: drop
func (s *StreamInputFileImpl) SetSubtitles(v StreamInputMpegtsSpecificSubtitles) StreamInputFile {
	if s == nil {
		return nil
	}
	s.SubtitlesValue = &v
	return s
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s StreamInputFileImpl) Timeout() *int {
	return s.TimeoutValue
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s *StreamInputFileImpl) SetTimeout(v int) StreamInputFile {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// URL to get a stream from file.
// Format: input_url (input_url)
// Pattern: ^file://.*$
// Example: file://vod/bunny.mp4
func (s StreamInputFileImpl) URL() InputURL {
	return s.URLValue
}

// URL to get a stream from file.
// Format: input_url (input_url)
// Pattern: ^file://.*$
// Example: file://vod/bunny.mp4
func (s *StreamInputFileImpl) SetURL(v InputURL) StreamInputFile {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// User agent. Can be modified if a protocol allows it.
func (s StreamInputFileImpl) UserAgent() *string {
	return s.UserAgentValue
}

// User agent. Can be modified if a protocol allows it.
func (s *StreamInputFileImpl) SetUserAgent(v string) StreamInputFile {
	if s == nil {
		return nil
	}
	s.UserAgentValue = &v
	return s
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s StreamInputFileImpl) Via() *AgentURL {
	return s.ViaValue
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s *StreamInputFileImpl) SetVia(v AgentURL) StreamInputFile {
	if s == nil {
		return nil
	}
	s.ViaValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputFileImpl) VideoTimeout() *Seconds {
	return s.VideoTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputFileImpl) SetVideoTimeout(v Seconds) StreamInputFile {
	if s == nil {
		return nil
	}
	s.VideoTimeoutValue = &v
	return s
}

// NewStreamInputMpegtsSpecific creates a new StreamInputMpegtsSpecific instance
func NewStreamInputMpegtsSpecific() StreamInputMpegtsSpecific {
	return &StreamInputMpegtsSpecificImpl{}
}

// The rules for handling the closed captions.
func (s StreamInputMpegtsSpecificImpl) ClosedCaptions() map[string]string {
	return s.ClosedCaptionsValue
}

// The rules for handling the closed captions.
func (s *StreamInputMpegtsSpecificImpl) SetClosedCaptions(v map[string]string) StreamInputMpegtsSpecific {
	if s == nil {
		return nil
	}
	s.ClosedCaptionsValue = v
	return s
}

// An array of MPEG-TS language descriptors in format `[{key: track, value: language}]`
func (s StreamInputMpegtsSpecificImpl) Languages() map[string]string {
	return s.LanguagesValue
}

// An array of MPEG-TS language descriptors in format `[{key: track, value: language}]`
func (s *StreamInputMpegtsSpecificImpl) SetLanguages(v map[string]string) StreamInputMpegtsSpecific {
	if s == nil {
		return nil
	}
	s.LanguagesValue = v
	return s
}

// Choose a specific PID to ingest from an MPEG-TS stream.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Example: [211]
func (s StreamInputMpegtsSpecificImpl) Pids() []int {
	return s.PidsValue
}

// Choose a specific PID to ingest from an MPEG-TS stream.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Example: [211]
func (s *StreamInputMpegtsSpecificImpl) SetPids(v []int) StreamInputMpegtsSpecific {
	if s == nil {
		return nil
	}
	s.PidsValue = v
	return s
}

// Choose a program to ingest from an MPEG-TS stream.
// Example: [1]
func (s StreamInputMpegtsSpecificImpl) Programs() []int {
	return s.ProgramsValue
}

// Choose a program to ingest from an MPEG-TS stream.
// Example: [1]
func (s *StreamInputMpegtsSpecificImpl) SetPrograms(v []int) StreamInputMpegtsSpecific {
	if s == nil {
		return nil
	}
	s.ProgramsValue = v
	return s
}

// Deprecated field. Will be deleted at 23.09
// This option disables processing of SCTE-35 markers from an MPEG-TS input stream.
// Deprecated since 22.12.
// Available ways to disable processing of SCTE-35 markers:
// 1. pids option to select tracks without SCTE-35 markers
// 2. hls_scte35 option from stream_config_media for hls output
// 3. performing appropriate tuning pids in the transponder
// Example: true
func (s StreamInputMpegtsSpecificImpl) Scte35() *bool {
	return s.Scte35Value
}

// Deprecated field. Will be deleted at 23.09
// This option disables processing of SCTE-35 markers from an MPEG-TS input stream.
// Deprecated since 22.12.
// Available ways to disable processing of SCTE-35 markers:
// 1. pids option to select tracks without SCTE-35 markers
// 2. hls_scte35 option from stream_config_media for hls output
// 3. performing appropriate tuning pids in the transponder
// Example: true
func (s *StreamInputMpegtsSpecificImpl) SetScte35(v bool) StreamInputMpegtsSpecific {
	if s == nil {
		return nil
	}
	s.Scte35Value = &v
	return s
}

// Deprecated field. Will be deleted at 25.03
// This configuration is deprecated. Use `dvbocr` configuration field in stream.
// This parameter allows to manage subtitles in an output stream.
// Example: drop
func (s StreamInputMpegtsSpecificImpl) Subtitles() *StreamInputMpegtsSpecificSubtitles {
	return s.SubtitlesValue
}

// Deprecated field. Will be deleted at 25.03
// This configuration is deprecated. Use `dvbocr` configuration field in stream.
// This parameter allows to manage subtitles in an output stream.
// Example: drop
func (s *StreamInputMpegtsSpecificImpl) SetSubtitles(v StreamInputMpegtsSpecificSubtitles) StreamInputMpegtsSpecific {
	if s == nil {
		return nil
	}
	s.SubtitlesValue = &v
	return s
}

// NewStreamInputPublish creates a new StreamInputPublish instance
func NewStreamInputPublish() StreamInputPublish {
	return &StreamInputPublishImpl{}
}

// The correction between the target bitrate (Receiver Estimated Maximum Bitrate, calculated in Flussonic) and browser bitrate, in kbit/s.
// Flussonic sends the target bitrate to the browser from which the publication is carried out so that the browser adjusts the bitrate of the publication by this value.
// The default value is 300 kbit/s.
// Example: 200
func (s StreamInputPublishImpl) AbrCorrection() *int {
	return s.AbrCorrectionValue
}

// The correction between the target bitrate (Receiver Estimated Maximum Bitrate, calculated in Flussonic) and browser bitrate, in kbit/s.
// Flussonic sends the target bitrate to the browser from which the publication is carried out so that the browser adjusts the bitrate of the publication by this value.
// The default value is 300 kbit/s.
// Example: 200
func (s *StreamInputPublishImpl) SetAbrCorrection(v int) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.AbrCorrectionValue = &v
	return s
}

// The number of cycles of bitrate auto-adjustment.
// After the specified number of auto-adjustment cycles passes, Flussonic considers the bitrate to be optimal, and it is no longer analyzed.
// By default, `abr_cycles`=5.
// If `abr_cycles`=0, the adjustment process takes place all the time while the publication lasts.
// Example: 3
func (s StreamInputPublishImpl) AbrCycles() *int {
	return s.AbrCyclesValue
}

// The number of cycles of bitrate auto-adjustment.
// After the specified number of auto-adjustment cycles passes, Flussonic considers the bitrate to be optimal, and it is no longer analyzed.
// By default, `abr_cycles`=5.
// If `abr_cycles`=0, the adjustment process takes place all the time while the publication lasts.
// Example: 3
func (s *StreamInputPublishImpl) SetAbrCycles(v int) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.AbrCyclesValue = &v
	return s
}

// Whether adaptive bitrate process is logged.
// Example: 1
func (s StreamInputPublishImpl) AbrDebug() *int {
	return s.AbrDebugValue
}

// Whether adaptive bitrate process is logged.
// Example: 1
func (s *StreamInputPublishImpl) SetAbrDebug(v int) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.AbrDebugValue = &v
	return s
}

// The lower limit of packet loss. When it is reached, Flussonic raises the bitrate.
// That is, if packet loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup` percent.
// Example: 2
func (s StreamInputPublishImpl) AbrLossLower() *float64 {
	return s.AbrLossLowerValue
}

// The lower limit of packet loss. When it is reached, Flussonic raises the bitrate.
// That is, if packet loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup` percent.
// Example: 2
func (s *StreamInputPublishImpl) SetAbrLossLower(v float64) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.AbrLossLowerValue = &v
	return s
}

// The upper limit of packet loss. When it is reached, Flussonic reduces the bitrate.
// That is, if packet loss is greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.
// Example: 10
func (s StreamInputPublishImpl) AbrLossUpper() *float64 {
	return s.AbrLossUpperValue
}

// The upper limit of packet loss. When it is reached, Flussonic reduces the bitrate.
// That is, if packet loss is greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.
// Example: 10
func (s *StreamInputPublishImpl) SetAbrLossUpper(v float64) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.AbrLossUpperValue = &v
	return s
}

// Maximum bitrate for adjustment process, in kbit/s.
// Flussonic will keep the publication bitrate equal or below of the specified value.
// Example: 1000
func (s StreamInputPublishImpl) AbrMaxBitrate() *int {
	return s.AbrMaxBitrateValue
}

// Maximum bitrate for adjustment process, in kbit/s.
// Flussonic will keep the publication bitrate equal or below of the specified value.
// Example: 1000
func (s *StreamInputPublishImpl) SetAbrMaxBitrate(v int) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.AbrMaxBitrateValue = &v
	return s
}

// The algorithm for determining the need to change the bitrate of the published stream and for calculating the target bitrate.
// Two options are possible:
// * `abr_mode=0` - This mode takes into account the packet losses, target bitrate, browser bitrate and the number of auto-adjustment cycles.
// * `abr_mode=1` - This mode considers only packet losses and target bitrate.
// Example: 1
func (s StreamInputPublishImpl) AbrMode() *int {
	return s.AbrModeValue
}

// The algorithm for determining the need to change the bitrate of the published stream and for calculating the target bitrate.
// Two options are possible:
// * `abr_mode=0` - This mode takes into account the packet losses, target bitrate, browser bitrate and the number of auto-adjustment cycles.
// * `abr_mode=1` - This mode considers only packet losses and target bitrate.
// Example: 1
func (s *StreamInputPublishImpl) SetAbrMode(v int) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.AbrModeValue = &v
	return s
}

// A step of reducing the bitrate to the minimum.
// If packet losses are greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.
func (s StreamInputPublishImpl) AbrStepdown() *float64 {
	return s.AbrStepdownValue
}

// A step of reducing the bitrate to the minimum.
// If packet losses are greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.
func (s *StreamInputPublishImpl) SetAbrStepdown(v float64) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.AbrStepdownValue = &v
	return s
}

// Increment step for raising the bitrate to the maximum, in percent. The default step is 30%.
// If the loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup percent`.
func (s StreamInputPublishImpl) AbrStepup() *int {
	return s.AbrStepupValue
}

// Increment step for raising the bitrate to the maximum, in percent. The default step is 30%.
// If the loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup percent`.
func (s *StreamInputPublishImpl) SetAbrStepup(v int) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.AbrStepupValue = &v
	return s
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s StreamInputPublishImpl) AllowIf() *string {
	return s.AllowIfValue
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s *StreamInputPublishImpl) SetAllowIf(v string) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.AllowIfValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputPublishImpl) AudioTimeout() *Seconds {
	return s.AudioTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputPublishImpl) SetAudioTimeout(v Seconds) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.AudioTimeoutValue = &v
	return s
}

// Human-readable description of the input.
// Example: This is a test input
func (s StreamInputPublishImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the input.
// Example: This is a test input
func (s *StreamInputPublishImpl) SetComment(v string) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s StreamInputPublishImpl) DenyIf() *string {
	return s.DenyIfValue
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s *StreamInputPublishImpl) SetDenyIf(v string) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.DenyIfValue = &v
	return s
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s StreamInputPublishImpl) FramesTimeout() *int {
	return s.FramesTimeoutValue
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s *StreamInputPublishImpl) SetFramesTimeout(v int) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.FramesTimeoutValue = &v
	return s
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s StreamInputPublishImpl) Headers() map[string]string {
	return s.HeadersValue
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s *StreamInputPublishImpl) SetHeaders(v map[string]string) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.HeadersValue = v
	return s
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s StreamInputPublishImpl) MaxRetryTimeout() *Seconds {
	return s.MaxRetryTimeoutValue
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s *StreamInputPublishImpl) SetMaxRetryTimeout(v Seconds) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.MaxRetryTimeoutValue = &v
	return s
}

// The minimum bitrate threshold, in kbit/s. The default value is 100 kbit/s.
// Example: 150
func (s StreamInputPublishImpl) MinBitrate() *int {
	return s.MinBitrateValue
}

// The minimum bitrate threshold, in kbit/s. The default value is 100 kbit/s.
// Example: 150
func (s *StreamInputPublishImpl) SetMinBitrate(v int) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.MinBitrateValue = &v
	return s
}

// Skip input start if the stream has no clients.
func (s StreamInputPublishImpl) NoClientsReconnectDelay() *int {
	return s.NoClientsReconnectDelayValue
}

// Skip input start if the stream has no clients.
func (s *StreamInputPublishImpl) SetNoClientsReconnectDelay(v int) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.NoClientsReconnectDelayValue = &v
	return s
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s StreamInputPublishImpl) OutputAudio() *OutputAudio {
	return s.OutputAudioValue
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s *StreamInputPublishImpl) SetOutputAudio(v OutputAudio) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.OutputAudioValue = &v
	return s
}

// Deprecated field. Will be deleted at 24.11
// Choose one of the listed video codecs at the start of the publication via WebRTC.
// Example: av1
func (s StreamInputPublishImpl) PreferCodec() *WebrtcPreferVideoCodec {
	return s.PreferCodecValue
}

// Deprecated field. Will be deleted at 24.11
// Choose one of the listed video codecs at the start of the publication via WebRTC.
// Example: av1
func (s *StreamInputPublishImpl) SetPreferCodec(v WebrtcPreferVideoCodec) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.PreferCodecValue = &v
	return s
}

// Prefer one of the listed video codecs at the start of the publication via WebRTC.
// Example: av1
func (s StreamInputPublishImpl) PreferVideoCodec() *WebrtcPreferVideoCodec {
	return s.PreferVideoCodecValue
}

// Prefer one of the listed video codecs at the start of the publication via WebRTC.
// Example: av1
func (s *StreamInputPublishImpl) SetPreferVideoCodec(v WebrtcPreferVideoCodec) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.PreferVideoCodecValue = &v
	return s
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s StreamInputPublishImpl) Priority() *int {
	return s.PriorityValue
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s *StreamInputPublishImpl) SetPriority(v int) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.PriorityValue = &v
	return s
}

// This option disables processing of SCTE-35 markers from SRT input stream.
// Example: true
func (s StreamInputPublishImpl) Scte35() *bool {
	return s.Scte35Value
}

// This option disables processing of SCTE-35 markers from SRT input stream.
// Example: true
func (s *StreamInputPublishImpl) SetScte35(v bool) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.Scte35Value = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s StreamInputPublishImpl) SourceTimeout() any {
	return s.SourceTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s *StreamInputPublishImpl) SetSourceTimeout(v any) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.SourceTimeoutValue = v
	return s
}

// Detailed runtime information about the input.
func (s StreamInputPublishImpl) Stats() InputStats {
	return s.StatsValue
}

// Detailed runtime information about the input.
func (s *StreamInputPublishImpl) SetStats(v InputStats) StreamInputPublish {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// Deprecated field. Will be deleted at 25.03
// This configuration is deprecated. Use `dvbocr` configuration field in stream.
// This parameter allows to manage subtitles in an output stream.
// Example: drop
func (s StreamInputPublishImpl) Subtitles() *StreamInputSrtPublishSpecificSubtitles {
	return s.SubtitlesValue
}

// Deprecated field. Will be deleted at 25.03
// This configuration is deprecated. Use `dvbocr` configuration field in stream.
// This parameter allows to manage subtitles in an output stream.
// Example: drop
func (s *StreamInputPublishImpl) SetSubtitles(v StreamInputSrtPublishSpecificSubtitles) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.SubtitlesValue = &v
	return s
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s StreamInputPublishImpl) Timeout() *int {
	return s.TimeoutValue
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s *StreamInputPublishImpl) SetTimeout(v int) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// Choose the prefered transport of the publication via WebRTC: UDP or TCP.
// Example: udp
func (s StreamInputPublishImpl) Transport() *WebrtcTransport {
	return s.TransportValue
}

// Choose the prefered transport of the publication via WebRTC: UDP or TCP.
// Example: udp
func (s *StreamInputPublishImpl) SetTransport(v WebrtcTransport) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.TransportValue = &v
	return s
}

// The publish:// URL used to indicate where this stream started in publish mode.
// You can publish videos to Flussonic using the following URLs:
// __RTSP__: rtsp://FLUSSONIC-IP/stream_name
// __HTTP MPEG-TS__: http://FLUSSONIC-IP/stream_name/mpegts
// __RTMP__: rtmp://flussonic-ip/published or rtmp://flussonic-ip/static/published
// __WebRTC__: http://FLUSSONIC-IP/stream_name/whip
// __SRT__: srt://FLUSSONIC-IP:SRT_PORT?streamid=#!::r=STREAM_NAME,m=publish
// Format: input_url (input_url)
// Pattern: ^publish://.*$
// Example: publish://
func (s StreamInputPublishImpl) URL() InputURL {
	return s.URLValue
}

// The publish:// URL used to indicate where this stream started in publish mode.
// You can publish videos to Flussonic using the following URLs:
// __RTSP__: rtsp://FLUSSONIC-IP/stream_name
// __HTTP MPEG-TS__: http://FLUSSONIC-IP/stream_name/mpegts
// __RTMP__: rtmp://flussonic-ip/published or rtmp://flussonic-ip/static/published
// __WebRTC__: http://FLUSSONIC-IP/stream_name/whip
// __SRT__: srt://FLUSSONIC-IP:SRT_PORT?streamid=#!::r=STREAM_NAME,m=publish
// Format: input_url (input_url)
// Pattern: ^publish://.*$
// Example: publish://
func (s *StreamInputPublishImpl) SetURL(v InputURL) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// User agent. Can be modified if a protocol allows it.
func (s StreamInputPublishImpl) UserAgent() *string {
	return s.UserAgentValue
}

// User agent. Can be modified if a protocol allows it.
func (s *StreamInputPublishImpl) SetUserAgent(v string) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.UserAgentValue = &v
	return s
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s StreamInputPublishImpl) Via() *AgentURL {
	return s.ViaValue
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s *StreamInputPublishImpl) SetVia(v AgentURL) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.ViaValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputPublishImpl) VideoTimeout() *Seconds {
	return s.VideoTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputPublishImpl) SetVideoTimeout(v Seconds) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.VideoTimeoutValue = &v
	return s
}

// Whether the adaptive bitrate mechanism is used for WebRTC publications.
// Example: true
func (s StreamInputPublishImpl) WebrtcAbr() *bool {
	return s.WebrtcAbrValue
}

// Whether the adaptive bitrate mechanism is used for WebRTC publications.
// Example: true
func (s *StreamInputPublishImpl) SetWebrtcAbr(v bool) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.WebrtcAbrValue = &v
	return s
}

// NewStreamInputRtsp creates a new StreamInputRtsp instance
func NewStreamInputRtsp() StreamInputRtsp {
	return &StreamInputRtspImpl{}
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s StreamInputRtspImpl) AllowIf() *string {
	return s.AllowIfValue
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s *StreamInputRtspImpl) SetAllowIf(v string) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.AllowIfValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputRtspImpl) AudioTimeout() *Seconds {
	return s.AudioTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputRtspImpl) SetAudioTimeout(v Seconds) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.AudioTimeoutValue = &v
	return s
}

// Human-readable description of the input.
// Example: This is a test input
func (s StreamInputRtspImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the input.
// Example: This is a test input
func (s *StreamInputRtspImpl) SetComment(v string) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s StreamInputRtspImpl) DenyIf() *string {
	return s.DenyIfValue
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s *StreamInputRtspImpl) SetDenyIf(v string) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.DenyIfValue = &v
	return s
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s StreamInputRtspImpl) FramesTimeout() *int {
	return s.FramesTimeoutValue
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s *StreamInputRtspImpl) SetFramesTimeout(v int) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.FramesTimeoutValue = &v
	return s
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s StreamInputRtspImpl) Headers() map[string]string {
	return s.HeadersValue
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s *StreamInputRtspImpl) SetHeaders(v map[string]string) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.HeadersValue = v
	return s
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s StreamInputRtspImpl) MaxRetryTimeout() *Seconds {
	return s.MaxRetryTimeoutValue
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s *StreamInputRtspImpl) SetMaxRetryTimeout(v Seconds) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.MaxRetryTimeoutValue = &v
	return s
}

// Skip input start if the stream has no clients.
func (s StreamInputRtspImpl) NoClientsReconnectDelay() *int {
	return s.NoClientsReconnectDelayValue
}

// Skip input start if the stream has no clients.
func (s *StreamInputRtspImpl) SetNoClientsReconnectDelay(v int) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.NoClientsReconnectDelayValue = &v
	return s
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s StreamInputRtspImpl) OutputAudio() *OutputAudio {
	return s.OutputAudioValue
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s *StreamInputRtspImpl) SetOutputAudio(v OutputAudio) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.OutputAudioValue = &v
	return s
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s StreamInputRtspImpl) Priority() *int {
	return s.PriorityValue
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s *StreamInputRtspImpl) SetPriority(v int) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.PriorityValue = &v
	return s
}

// Whether to force UDP to capture a video from RTSP cameras.
func (s StreamInputRtspImpl) RTP() *string {
	return s.RTPValue
}

// Whether to force UDP to capture a video from RTSP cameras.
func (s *StreamInputRtspImpl) SetRTP(v string) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.RTPValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s StreamInputRtspImpl) SourceTimeout() any {
	return s.SourceTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s *StreamInputRtspImpl) SetSourceTimeout(v any) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.SourceTimeoutValue = v
	return s
}

// Detailed runtime information about the input.
func (s StreamInputRtspImpl) Stats() InputStats {
	return s.StatsValue
}

// Detailed runtime information about the input.
func (s *StreamInputRtspImpl) SetStats(v InputStats) StreamInputRtsp {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s StreamInputRtspImpl) Timeout() *int {
	return s.TimeoutValue
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s *StreamInputRtspImpl) SetTimeout(v int) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// URL to connect to the RTSP source and get the stream.
// Format: input_url (input_url)
// Pattern: ^(rtsp|rtsps|rtsp-udp|rtsp2)://.*$
// Examples: rtsp-udp://remote.host.com/example, rtsp2://remote.host.com/example, rtsp://remote.host.com/example, rtsps://remote.host.com/example
func (s StreamInputRtspImpl) URL() InputURL {
	return s.URLValue
}

// URL to connect to the RTSP source and get the stream.
// Format: input_url (input_url)
// Pattern: ^(rtsp|rtsps|rtsp-udp|rtsp2)://.*$
// Examples: rtsp-udp://remote.host.com/example, rtsp2://remote.host.com/example, rtsp://remote.host.com/example, rtsps://remote.host.com/example
func (s *StreamInputRtspImpl) SetURL(v InputURL) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// User agent. Can be modified if a protocol allows it.
func (s StreamInputRtspImpl) UserAgent() *string {
	return s.UserAgentValue
}

// User agent. Can be modified if a protocol allows it.
func (s *StreamInputRtspImpl) SetUserAgent(v string) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.UserAgentValue = &v
	return s
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s StreamInputRtspImpl) Via() *AgentURL {
	return s.ViaValue
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s *StreamInputRtspImpl) SetVia(v AgentURL) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.ViaValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputRtspImpl) VideoTimeout() *Seconds {
	return s.VideoTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputRtspImpl) SetVideoTimeout(v Seconds) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.VideoTimeoutValue = &v
	return s
}

// Whether to wait for the full RTP time synchronization before the processing of frames from the RTSP camera.
func (s StreamInputRtspImpl) WaitRtcp() *bool {
	return s.WaitRtcpValue
}

// Whether to wait for the full RTP time synchronization before the processing of frames from the RTSP camera.
func (s *StreamInputRtspImpl) SetWaitRtcp(v bool) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.WaitRtcpValue = &v
	return s
}

// NewStreamInputSrtPublishSpecific creates a new StreamInputSrtPublishSpecific instance
func NewStreamInputSrtPublishSpecific() StreamInputSrtPublishSpecific {
	return &StreamInputSrtPublishSpecificImpl{}
}

// This option disables processing of SCTE-35 markers from SRT input stream.
// Example: true
func (s StreamInputSrtPublishSpecificImpl) Scte35() *bool {
	return s.Scte35Value
}

// This option disables processing of SCTE-35 markers from SRT input stream.
// Example: true
func (s *StreamInputSrtPublishSpecificImpl) SetScte35(v bool) StreamInputSrtPublishSpecific {
	if s == nil {
		return nil
	}
	s.Scte35Value = &v
	return s
}

// Deprecated field. Will be deleted at 25.03
// This configuration is deprecated. Use `dvbocr` configuration field in stream.
// This parameter allows to manage subtitles in an output stream.
// Example: drop
func (s StreamInputSrtPublishSpecificImpl) Subtitles() *StreamInputSrtPublishSpecificSubtitles {
	return s.SubtitlesValue
}

// Deprecated field. Will be deleted at 25.03
// This configuration is deprecated. Use `dvbocr` configuration field in stream.
// This parameter allows to manage subtitles in an output stream.
// Example: drop
func (s *StreamInputSrtPublishSpecificImpl) SetSubtitles(v StreamInputSrtPublishSpecificSubtitles) StreamInputSrtPublishSpecific {
	if s == nil {
		return nil
	}
	s.SubtitlesValue = &v
	return s
}

// NewStreamInputWebrtcPublishSpecific creates a new StreamInputWebrtcPublishSpecific instance
func NewStreamInputWebrtcPublishSpecific() StreamInputWebrtcPublishSpecific {
	return &StreamInputWebrtcPublishSpecificImpl{}
}

// The correction between the target bitrate (Receiver Estimated Maximum Bitrate, calculated in Flussonic) and browser bitrate, in kbit/s.
// Flussonic sends the target bitrate to the browser from which the publication is carried out so that the browser adjusts the bitrate of the publication by this value.
// The default value is 300 kbit/s.
// Example: 200
func (s StreamInputWebrtcPublishSpecificImpl) AbrCorrection() *int {
	return s.AbrCorrectionValue
}

// The correction between the target bitrate (Receiver Estimated Maximum Bitrate, calculated in Flussonic) and browser bitrate, in kbit/s.
// Flussonic sends the target bitrate to the browser from which the publication is carried out so that the browser adjusts the bitrate of the publication by this value.
// The default value is 300 kbit/s.
// Example: 200
func (s *StreamInputWebrtcPublishSpecificImpl) SetAbrCorrection(v int) StreamInputWebrtcPublishSpecific {
	if s == nil {
		return nil
	}
	s.AbrCorrectionValue = &v
	return s
}

// The number of cycles of bitrate auto-adjustment.
// After the specified number of auto-adjustment cycles passes, Flussonic considers the bitrate to be optimal, and it is no longer analyzed.
// By default, `abr_cycles`=5.
// If `abr_cycles`=0, the adjustment process takes place all the time while the publication lasts.
// Example: 3
func (s StreamInputWebrtcPublishSpecificImpl) AbrCycles() *int {
	return s.AbrCyclesValue
}

// The number of cycles of bitrate auto-adjustment.
// After the specified number of auto-adjustment cycles passes, Flussonic considers the bitrate to be optimal, and it is no longer analyzed.
// By default, `abr_cycles`=5.
// If `abr_cycles`=0, the adjustment process takes place all the time while the publication lasts.
// Example: 3
func (s *StreamInputWebrtcPublishSpecificImpl) SetAbrCycles(v int) StreamInputWebrtcPublishSpecific {
	if s == nil {
		return nil
	}
	s.AbrCyclesValue = &v
	return s
}

// Whether adaptive bitrate process is logged.
// Example: 1
func (s StreamInputWebrtcPublishSpecificImpl) AbrDebug() *int {
	return s.AbrDebugValue
}

// Whether adaptive bitrate process is logged.
// Example: 1
func (s *StreamInputWebrtcPublishSpecificImpl) SetAbrDebug(v int) StreamInputWebrtcPublishSpecific {
	if s == nil {
		return nil
	}
	s.AbrDebugValue = &v
	return s
}

// The lower limit of packet loss. When it is reached, Flussonic raises the bitrate.
// That is, if packet loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup` percent.
// Example: 2
func (s StreamInputWebrtcPublishSpecificImpl) AbrLossLower() *float64 {
	return s.AbrLossLowerValue
}

// The lower limit of packet loss. When it is reached, Flussonic raises the bitrate.
// That is, if packet loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup` percent.
// Example: 2
func (s *StreamInputWebrtcPublishSpecificImpl) SetAbrLossLower(v float64) StreamInputWebrtcPublishSpecific {
	if s == nil {
		return nil
	}
	s.AbrLossLowerValue = &v
	return s
}

// The upper limit of packet loss. When it is reached, Flussonic reduces the bitrate.
// That is, if packet loss is greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.
// Example: 10
func (s StreamInputWebrtcPublishSpecificImpl) AbrLossUpper() *float64 {
	return s.AbrLossUpperValue
}

// The upper limit of packet loss. When it is reached, Flussonic reduces the bitrate.
// That is, if packet loss is greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.
// Example: 10
func (s *StreamInputWebrtcPublishSpecificImpl) SetAbrLossUpper(v float64) StreamInputWebrtcPublishSpecific {
	if s == nil {
		return nil
	}
	s.AbrLossUpperValue = &v
	return s
}

// Maximum bitrate for adjustment process, in kbit/s.
// Flussonic will keep the publication bitrate equal or below of the specified value.
// Example: 1000
func (s StreamInputWebrtcPublishSpecificImpl) AbrMaxBitrate() *int {
	return s.AbrMaxBitrateValue
}

// Maximum bitrate for adjustment process, in kbit/s.
// Flussonic will keep the publication bitrate equal or below of the specified value.
// Example: 1000
func (s *StreamInputWebrtcPublishSpecificImpl) SetAbrMaxBitrate(v int) StreamInputWebrtcPublishSpecific {
	if s == nil {
		return nil
	}
	s.AbrMaxBitrateValue = &v
	return s
}

// The algorithm for determining the need to change the bitrate of the published stream and for calculating the target bitrate.
// Two options are possible:
// * `abr_mode=0` - This mode takes into account the packet losses, target bitrate, browser bitrate and the number of auto-adjustment cycles.
// * `abr_mode=1` - This mode considers only packet losses and target bitrate.
// Example: 1
func (s StreamInputWebrtcPublishSpecificImpl) AbrMode() *int {
	return s.AbrModeValue
}

// The algorithm for determining the need to change the bitrate of the published stream and for calculating the target bitrate.
// Two options are possible:
// * `abr_mode=0` - This mode takes into account the packet losses, target bitrate, browser bitrate and the number of auto-adjustment cycles.
// * `abr_mode=1` - This mode considers only packet losses and target bitrate.
// Example: 1
func (s *StreamInputWebrtcPublishSpecificImpl) SetAbrMode(v int) StreamInputWebrtcPublishSpecific {
	if s == nil {
		return nil
	}
	s.AbrModeValue = &v
	return s
}

// A step of reducing the bitrate to the minimum.
// If packet losses are greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.
func (s StreamInputWebrtcPublishSpecificImpl) AbrStepdown() *float64 {
	return s.AbrStepdownValue
}

// A step of reducing the bitrate to the minimum.
// If packet losses are greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.
func (s *StreamInputWebrtcPublishSpecificImpl) SetAbrStepdown(v float64) StreamInputWebrtcPublishSpecific {
	if s == nil {
		return nil
	}
	s.AbrStepdownValue = &v
	return s
}

// Increment step for raising the bitrate to the maximum, in percent. The default step is 30%.
// If the loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup percent`.
func (s StreamInputWebrtcPublishSpecificImpl) AbrStepup() *int {
	return s.AbrStepupValue
}

// Increment step for raising the bitrate to the maximum, in percent. The default step is 30%.
// If the loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup percent`.
func (s *StreamInputWebrtcPublishSpecificImpl) SetAbrStepup(v int) StreamInputWebrtcPublishSpecific {
	if s == nil {
		return nil
	}
	s.AbrStepupValue = &v
	return s
}

// The minimum bitrate threshold, in kbit/s. The default value is 100 kbit/s.
// Example: 150
func (s StreamInputWebrtcPublishSpecificImpl) MinBitrate() *int {
	return s.MinBitrateValue
}

// The minimum bitrate threshold, in kbit/s. The default value is 100 kbit/s.
// Example: 150
func (s *StreamInputWebrtcPublishSpecificImpl) SetMinBitrate(v int) StreamInputWebrtcPublishSpecific {
	if s == nil {
		return nil
	}
	s.MinBitrateValue = &v
	return s
}

// Deprecated field. Will be deleted at 24.11
// Choose one of the listed video codecs at the start of the publication via WebRTC.
// Example: av1
func (s StreamInputWebrtcPublishSpecificImpl) PreferCodec() *WebrtcPreferVideoCodec {
	return s.PreferCodecValue
}

// Deprecated field. Will be deleted at 24.11
// Choose one of the listed video codecs at the start of the publication via WebRTC.
// Example: av1
func (s *StreamInputWebrtcPublishSpecificImpl) SetPreferCodec(v WebrtcPreferVideoCodec) StreamInputWebrtcPublishSpecific {
	if s == nil {
		return nil
	}
	s.PreferCodecValue = &v
	return s
}

// Prefer one of the listed video codecs at the start of the publication via WebRTC.
// Example: av1
func (s StreamInputWebrtcPublishSpecificImpl) PreferVideoCodec() *WebrtcPreferVideoCodec {
	return s.PreferVideoCodecValue
}

// Prefer one of the listed video codecs at the start of the publication via WebRTC.
// Example: av1
func (s *StreamInputWebrtcPublishSpecificImpl) SetPreferVideoCodec(v WebrtcPreferVideoCodec) StreamInputWebrtcPublishSpecific {
	if s == nil {
		return nil
	}
	s.PreferVideoCodecValue = &v
	return s
}

// Choose the prefered transport of the publication via WebRTC: UDP or TCP.
// Example: udp
func (s StreamInputWebrtcPublishSpecificImpl) Transport() *WebrtcTransport {
	return s.TransportValue
}

// Choose the prefered transport of the publication via WebRTC: UDP or TCP.
// Example: udp
func (s *StreamInputWebrtcPublishSpecificImpl) SetTransport(v WebrtcTransport) StreamInputWebrtcPublishSpecific {
	if s == nil {
		return nil
	}
	s.TransportValue = &v
	return s
}

// Whether the adaptive bitrate mechanism is used for WebRTC publications.
// Example: true
func (s StreamInputWebrtcPublishSpecificImpl) WebrtcAbr() *bool {
	return s.WebrtcAbrValue
}

// Whether the adaptive bitrate mechanism is used for WebRTC publications.
// Example: true
func (s *StreamInputWebrtcPublishSpecificImpl) SetWebrtcAbr(v bool) StreamInputWebrtcPublishSpecific {
	if s == nil {
		return nil
	}
	s.WebrtcAbrValue = &v
	return s
}

// NewStreamOnvifConfig creates a new StreamOnvifConfig instance
func NewStreamOnvifConfig() StreamOnvifConfig {
	return &StreamOnvifConfigImpl{}
}

// Shows if PTZ control should be enabled for the camera.
// The PTZ function must be supported and enabled on the ONVIF camera
// in order to be able to actually control PTZ from Watcher or your UI.
func (s StreamOnvifConfigImpl) Ptz() *bool {
	return s.PtzValue
}

// Shows if PTZ control should be enabled for the camera.
// The PTZ function must be supported and enabled on the ONVIF camera
// in order to be able to actually control PTZ from Watcher or your UI.
func (s *StreamOnvifConfigImpl) SetPtz(v bool) StreamOnvifConfig {
	if s == nil {
		return nil
	}
	s.PtzValue = &v
	return s
}

// The URL that Watcher uses for exchanging data with the camera via ONVIF.
// This URL usually can be found in the manual for your camera.
func (s StreamOnvifConfigImpl) URL() *string {
	return s.URLValue
}

// The URL that Watcher uses for exchanging data with the camera via ONVIF.
// This URL usually can be found in the manual for your camera.
func (s *StreamOnvifConfigImpl) SetURL(v string) StreamOnvifConfig {
	if s == nil {
		return nil
	}
	s.URLValue = &v
	return s
}

// NewStreamPathItem creates a new StreamPathItem instance
func NewStreamPathItem() StreamPathItem {
	return &StreamPathItemImpl{}
}

// ID of the path item the stream is included in.
func (s StreamPathItemImpl) ID() *int {
	return s.IDValue
}

// ID of the path item the stream is included in.
func (s *StreamPathItemImpl) SetID(v int) StreamPathItem {
	if s == nil {
		return nil
	}
	s.IDValue = &v
	return s
}

// Title of path item the stream is included in.
func (s StreamPathItemImpl) Title() *string {
	return s.TitleValue
}

// Title of path item the stream is included in.
func (s *StreamPathItemImpl) SetTitle(v string) StreamPathItem {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// NewStreamPreset creates a new StreamPreset instance
func NewStreamPreset() StreamPreset {
	return &StreamPresetImpl{}
}

// Preset identificator.
func (s StreamPresetImpl) ID() *int {
	return s.IDValue
}

// Preset identificator.
func (s *StreamPresetImpl) SetID(v int) StreamPreset {
	if s == nil {
		return nil
	}
	s.IDValue = &v
	return s
}

// Shows if the preset is adjustable.
// ```is_adjustable``` is needed for a situation where presets are managed by external billing.
// If ```is_adjustable: true``` user can change camera settings meanwhile using this preset.
// If ```is_adjustable: false``` user can not change camera settings meanwhile using this preset.
// If the camera has a non-adjustable presets, the DVR and analytics parameters from PUT requests will not be applied.
// In this case, either make the preset adjustable, or change the preset itself to achieve the required configuration.
// Example: true
func (s StreamPresetImpl) IsAdjustable() *bool {
	return s.IsAdjustableValue
}

// Shows if the preset is adjustable.
// ```is_adjustable``` is needed for a situation where presets are managed by external billing.
// If ```is_adjustable: true``` user can change camera settings meanwhile using this preset.
// If ```is_adjustable: false``` user can not change camera settings meanwhile using this preset.
// If the camera has a non-adjustable presets, the DVR and analytics parameters from PUT requests will not be applied.
// In this case, either make the preset adjustable, or change the preset itself to achieve the required configuration.
// Example: true
func (s *StreamPresetImpl) SetIsAdjustable(v bool) StreamPreset {
	if s == nil {
		return nil
	}
	s.IsAdjustableValue = &v
	return s
}

// Human-readable name of the preset.
// Example: Example preset name
func (s StreamPresetImpl) Title() *string {
	return s.TitleValue
}

// Human-readable name of the preset.
// Example: Example preset name
func (s *StreamPresetImpl) SetTitle(v string) StreamPreset {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// NewStreamPushBase creates a new StreamPushBase instance
func NewStreamPushBase() StreamPushBase {
	return &StreamPushBaseImpl{}
}

// Human-readable description of the pusher.
// Example: This is a test push
func (s StreamPushBaseImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the pusher.
// Example: This is a test push
func (s *StreamPushBaseImpl) SetComment(v string) StreamPushBase {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Disable pushing the stream.
// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
// In this way, the URL and other settings of a disabled stream remain in Flussonic.
func (s StreamPushBaseImpl) Disabled() *bool {
	return s.DisabledValue
}

// Disable pushing the stream.
// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
// In this way, the URL and other settings of a disabled stream remain in Flussonic.
func (s *StreamPushBaseImpl) SetDisabled(v bool) StreamPushBase {
	if s == nil {
		return nil
	}
	s.DisabledValue = &v
	return s
}

// The maximum number of times *Flussonic* retries to push the stream.
func (s StreamPushBaseImpl) RetryLimit() *int {
	return s.RetryLimitValue
}

// The maximum number of times *Flussonic* retries to push the stream.
func (s *StreamPushBaseImpl) SetRetryLimit(v int) StreamPushBase {
	if s == nil {
		return nil
	}
	s.RetryLimitValue = &v
	return s
}

// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
// It is an interval in seconds, 5 seconds by default.
// You can increase this value to reduce server load.
// Format: seconds (seconds)
// Example: 7
func (s StreamPushBaseImpl) RetryTimeout() *Seconds {
	return s.RetryTimeoutValue
}

// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
// It is an interval in seconds, 5 seconds by default.
// You can increase this value to reduce server load.
// Format: seconds (seconds)
// Example: 7
func (s *StreamPushBaseImpl) SetRetryTimeout(v Seconds) StreamPushBase {
	if s == nil {
		return nil
	}
	s.RetryTimeoutValue = &v
	return s
}

// Detailed runtime information about the push.
func (s StreamPushBaseImpl) Stats() PushCounters {
	return s.StatsValue
}

// Detailed runtime information about the push.
func (s *StreamPushBaseImpl) SetStats(v PushCounters) StreamPushBase {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*PushCountersImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
// Format: seconds (seconds)
// Example: 10
func (s StreamPushBaseImpl) Timeout() *Seconds {
	return s.TimeoutValue
}

// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
// Format: seconds (seconds)
// Example: 10
func (s *StreamPushBaseImpl) SetTimeout(v Seconds) StreamPushBase {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// NewStreamPushRtmp creates a new StreamPushRtmp instance
func NewStreamPushRtmp() StreamPushRtmp {
	return &StreamPushRtmpImpl{}
}

// Human-readable description of the pusher.
// Example: This is a test push
func (s StreamPushRtmpImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the pusher.
// Example: This is a test push
func (s *StreamPushRtmpImpl) SetComment(v string) StreamPushRtmp {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Disable pushing the stream.
// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
// In this way, the URL and other settings of a disabled stream remain in Flussonic.
func (s StreamPushRtmpImpl) Disabled() *bool {
	return s.DisabledValue
}

// Disable pushing the stream.
// Temporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it.
// In this way, the URL and other settings of a disabled stream remain in Flussonic.
func (s *StreamPushRtmpImpl) SetDisabled(v bool) StreamPushRtmp {
	if s == nil {
		return nil
	}
	s.DisabledValue = &v
	return s
}

// The maximum number of times *Flussonic* retries to push the stream.
func (s StreamPushRtmpImpl) RetryLimit() *int {
	return s.RetryLimitValue
}

// The maximum number of times *Flussonic* retries to push the stream.
func (s *StreamPushRtmpImpl) SetRetryLimit(v int) StreamPushRtmp {
	if s == nil {
		return nil
	}
	s.RetryLimitValue = &v
	return s
}

// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
// It is an interval in seconds, 5 seconds by default.
// You can increase this value to reduce server load.
// Format: seconds (seconds)
// Example: 7
func (s StreamPushRtmpImpl) RetryTimeout() *Seconds {
	return s.RetryTimeoutValue
}

// How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline.
// It is an interval in seconds, 5 seconds by default.
// You can increase this value to reduce server load.
// Format: seconds (seconds)
// Example: 7
func (s *StreamPushRtmpImpl) SetRetryTimeout(v Seconds) StreamPushRtmp {
	if s == nil {
		return nil
	}
	s.RetryTimeoutValue = &v
	return s
}

// Detailed runtime information about the push.
func (s StreamPushRtmpImpl) Stats() PushCounters {
	return s.StatsValue
}

// Detailed runtime information about the push.
func (s *StreamPushRtmpImpl) SetStats(v PushCounters) StreamPushRtmp {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*PushCountersImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
// Format: seconds (seconds)
// Example: 10
func (s StreamPushRtmpImpl) Timeout() *Seconds {
	return s.TimeoutValue
}

// Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.
// Format: seconds (seconds)
// Example: 10
func (s *StreamPushRtmpImpl) SetTimeout(v Seconds) StreamPushRtmp {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// RTMP URL where to push.
// You can publish to RTMP servers. Usually it is a social network streaming.
// Format: input_url (input_url)
// Pattern: ^rtmps?://.*$
// Examples: rtmp://your-server.com/app/stream1
func (s StreamPushRtmpImpl) URL() InputURL {
	return s.URLValue
}

// RTMP URL where to push.
// You can publish to RTMP servers. Usually it is a social network streaming.
// Format: input_url (input_url)
// Pattern: ^rtmps?://.*$
// Examples: rtmp://your-server.com/app/stream1
func (s *StreamPushRtmpImpl) SetURL(v InputURL) StreamPushRtmp {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// NewStreamStats creates a new StreamStats instance
func NewStreamStats() StreamStats {
	return &StreamStatsImpl{}
}

// The status of the Agent serving the stream.
func (s StreamStatsImpl) AgentStatus() *string {
	return s.AgentStatusValue
}

// The status of the Agent serving the stream.
func (s *StreamStatsImpl) SetAgentStatus(v string) StreamStats {
	if s == nil {
		return nil
	}
	s.AgentStatusValue = &v
	return s
}

// Becomes `false` when `ts_delay` > 12000 (= 12 seconds)
// Example: true
func (s StreamStatsImpl) Alive() *bool {
	return s.AliveValue
}

// Becomes `false` when `ts_delay` > 12000 (= 12 seconds)
// Example: true
func (s *StreamStatsImpl) SetAlive(v bool) StreamStats {
	if s == nil {
		return nil
	}
	s.AliveValue = &v
	return s
}

// Stream bitrate.
// Format: speed (speed)
// Example: 186
func (s StreamStatsImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// Stream bitrate.
// Format: speed (speed)
// Example: 186
func (s *StreamStatsImpl) SetBitrate(v Speed) StreamStats {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// The amount of stream data sent to the clients.
// Format: bytes (bytes)
// Example: 0
func (s StreamStatsImpl) BytesOut() *Bytes {
	return s.BytesOutValue
}

// The amount of stream data sent to the clients.
// Format: bytes (bytes)
// Example: 0
func (s *StreamStatsImpl) SetBytesOut(v Bytes) StreamStats {
	if s == nil {
		return nil
	}
	s.BytesOutValue = &v
	return s
}

// The identifier of the Agent that is currently serving the stream.
// Format: agent_id (agent_id)
func (s StreamStatsImpl) CurrentAgentID() *AgentID {
	return s.CurrentAgentIDValue
}

// The identifier of the Agent that is currently serving the stream.
// Format: agent_id (agent_id)
func (s *StreamStatsImpl) SetCurrentAgentID(v AgentID) StreamStats {
	if s == nil {
		return nil
	}
	s.CurrentAgentIDValue = &v
	return s
}

// The information about the recorded DVR archive.
func (s StreamStatsImpl) DvrInfo() DvrInfo {
	return s.DvrInfoValue
}

// The information about the recorded DVR archive.
func (s *StreamStatsImpl) SetDvrInfo(v DvrInfo) StreamStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*DvrInfoImpl); ok {
		s.DvrInfoValue = impl
	}
	return s
}

// The time when the last time frame was sent to the stream output (in UTC).
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.636383841974e+12
func (s StreamStatsImpl) LastDtsAt() *UtcMs {
	return s.LastDtsAtValue
}

// The time when the last time frame was sent to the stream output (in UTC).
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.636383841974e+12
func (s *StreamStatsImpl) SetLastDtsAt(v UtcMs) StreamStats {
	if s == nil {
		return nil
	}
	s.LastDtsAtValue = &v
	return s
}

// The time period in seconds during which the stream is being captured.
// Can be calculated from `opened_at`
// Format: milliseconds (milliseconds)
// Example: 71977
func (s StreamStatsImpl) Lifetime() *Milliseconds {
	return s.LifetimeValue
}

// The time period in seconds during which the stream is being captured.
// Can be calculated from `opened_at`
// Format: milliseconds (milliseconds)
// Example: 71977
func (s *StreamStatsImpl) SetLifetime(v Milliseconds) StreamStats {
	if s == nil {
		return nil
	}
	s.LifetimeValue = &v
	return s
}

// Technical information about the output media content.
func (s StreamStatsImpl) MediaInfo() MediaInfo {
	return s.MediaInfoValue
}

// Technical information about the output media content.
func (s *StreamStatsImpl) SetMediaInfo(v MediaInfo) StreamStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*MediaInfoImpl); ok {
		s.MediaInfoValue = impl
	}
	return s
}

// Deprecated field. Will be deleted at 25.04
// The number of clients receiving the stream.
// Use play.play_opened_sessions instead
// Format: client_count (client_count)
// Example: 3
func (s StreamStatsImpl) OnlineClients() *ClientCount {
	return s.OnlineClientsValue
}

// Deprecated field. Will be deleted at 25.04
// The number of clients receiving the stream.
// Use play.play_opened_sessions instead
// Format: client_count (client_count)
// Example: 3
func (s *StreamStatsImpl) SetOnlineClients(v ClientCount) StreamStats {
	if s == nil {
		return nil
	}
	s.OnlineClientsValue = &v
	return s
}

// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
// Example: onetime_token
func (s StreamStatsImpl) PlaybackToken() *string {
	return s.PlaybackTokenValue
}

// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
// Example: onetime_token
func (s *StreamStatsImpl) SetPlaybackToken(v string) StreamStats {
	if s == nil {
		return nil
	}
	s.PlaybackTokenValue = &v
	return s
}

// Publish endpoint. Used to publish the stream.
func (s StreamStatsImpl) PublishEndpoint() *string {
	return s.PublishEndpointValue
}

// Publish endpoint. Used to publish the stream.
func (s *StreamStatsImpl) SetPublishEndpoint(v string) StreamStats {
	if s == nil {
		return nil
	}
	s.PublishEndpointValue = &v
	return s
}

// Indicates the status of the stream.
func (s StreamStatsImpl) Status() *StreamStatus {
	return s.StatusValue
}

// Indicates the status of the stream.
func (s *StreamStatsImpl) SetStatus(v StreamStatus) StreamStats {
	if s == nil {
		return nil
	}
	s.StatusValue = &v
	return s
}

// HTTP(s) URL that can be used for streaming API of this stream
func (s StreamStatsImpl) StreamingEndpoint() *string {
	return s.StreamingEndpointValue
}

// HTTP(s) URL that can be used for streaming API of this stream
func (s *StreamStatsImpl) SetStreamingEndpoint(v string) StreamStats {
	if s == nil {
		return nil
	}
	s.StreamingEndpointValue = &v
	return s
}

// The time period during which no frames were received from the stream's input.
// Format: ticks (ticks)
// Example: 1284
func (s StreamStatsImpl) TSDelay() *Ticks {
	return s.TSDelayValue
}

// The time period during which no frames were received from the stream's input.
// Format: ticks (ticks)
// Example: 1284
func (s *StreamStatsImpl) SetTSDelay(v Ticks) StreamStats {
	if s == nil {
		return nil
	}
	s.TSDelayValue = &v
	return s
}

// NewStreamZoneConfig creates a new StreamZoneConfig instance
func NewStreamZoneConfig() StreamZoneConfig {
	return &StreamZoneConfigImpl{}
}

// The name of the zone to which the stream belongs. Preferred zones means that the stream will be provisioned to these zones first.
// If preferred zones is empty, stream will be provisioned to any available zone.
// If preferred zones is not available, stream will be provisioned to any available zone.
// After fallback stream will be provisioned to preferred zone.
func (s StreamZoneConfigImpl) PreferredZones() []string {
	return s.PreferredZonesValue
}

// The name of the zone to which the stream belongs. Preferred zones means that the stream will be provisioned to these zones first.
// If preferred zones is empty, stream will be provisioned to any available zone.
// If preferred zones is not available, stream will be provisioned to any available zone.
// After fallback stream will be provisioned to preferred zone.
func (s *StreamZoneConfigImpl) SetPreferredZones(v []string) StreamZoneConfig {
	if s == nil {
		return nil
	}
	s.PreferredZonesValue = v
	return s
}

// The name of the zone to which the stream belongs.
// Required zones means that the stream can be provisioned only on these zones.
// If required zones is empty, stream will be provisioned to any available zone.
func (s StreamZoneConfigImpl) RequiredZones() []string {
	return s.RequiredZonesValue
}

// The name of the zone to which the stream belongs.
// Required zones means that the stream can be provisioned only on these zones.
// If required zones is empty, stream will be provisioned to any available zone.
func (s *StreamZoneConfigImpl) SetRequiredZones(v []string) StreamZoneConfig {
	if s == nil {
		return nil
	}
	s.RequiredZonesValue = v
	return s
}

// NewStreamer creates a new Streamer instance
func NewStreamer() Streamer {
	return &StreamerImpl{}
}

// The URL for provisioning of configuration from the managing server to the streamer.
// This URL does not have to be public but must be accessible from the managing server.
// The API URL can also be used as Public and/or Private payload URL if they are not set.
// When used as Public payload URL, the API URL shall be public to allow playback from this streamer.
// Format: url (url)
// Example: http://streamer.local:8080
func (s StreamerImpl) APIURL() *URL {
	return s.APIURLValue
}

// The URL for provisioning of configuration from the managing server to the streamer.
// This URL does not have to be public but must be accessible from the managing server.
// The API URL can also be used as Public and/or Private payload URL if they are not set.
// When used as Public payload URL, the API URL shall be public to allow playback from this streamer.
// Format: url (url)
// Example: http://streamer.local:8080
func (s *StreamerImpl) SetAPIURL(v URL) Streamer {
	if s == nil {
		return nil
	}
	s.APIURLValue = &v
	return s
}

// Maximal number of streams.
// Example: 5
func (s StreamerImpl) ChannelLimit() *int {
	return s.ChannelLimitValue
}

// Maximal number of streams.
// Example: 5
func (s *StreamerImpl) SetChannelLimit(v int) Streamer {
	if s == nil {
		return nil
	}
	s.ChannelLimitValue = &v
	return s
}

// The key for authorization for inter-Flussonic connections.
// All cluster peers should have the same cluster key.
// Example: xS6i6Q3DCc5nEvnu
func (s StreamerImpl) ClusterKey() *string {
	return s.ClusterKeyValue
}

// The key for authorization for inter-Flussonic connections.
// All cluster peers should have the same cluster key.
// Example: xS6i6Q3DCc5nEvnu
func (s *StreamerImpl) SetClusterKey(v string) Streamer {
	if s == nil {
		return nil
	}
	s.ClusterKeyValue = &v
	return s
}

// Flussonic Media Server configuration which will be provided to Streamer
func (s StreamerImpl) Config() StreamerConfigConfig {
	return s.ConfigValue
}

// Flussonic Media Server configuration which will be provided to Streamer
func (s *StreamerImpl) SetConfig(v StreamerConfigConfig) Streamer {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*StreamerConfigConfigImpl); ok {
		s.ConfigValue = impl
	}
	return s
}

// The configuration of the DVRs
func (s StreamerImpl) Dvrs() []DvrConfig {
	if s.DvrsValue == nil {
		return nil
	}
	result := make([]DvrConfig, len(s.DvrsValue))
	for i, item := range s.DvrsValue {
		result[i] = item
	}
	return result
}

// The configuration of the DVRs
func (s *StreamerImpl) SetDvrs(v []DvrConfig) Streamer {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*DvrConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*DvrConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.DvrsValue = impl
	}
	return s
}

// Streamer's identifier in the cluster.
// The managing server may try using this hostname to access the streamer
// if API URL is not specified.
// Format: server_name (server_name)
// Example: peer.example.com
func (s StreamerImpl) Hostname() *ServerName {
	return s.HostnameValue
}

// Streamer's identifier in the cluster.
// The managing server may try using this hostname to access the streamer
// if API URL is not specified.
// Format: server_name (server_name)
// Example: peer.example.com
func (s *StreamerImpl) SetHostname(v ServerName) Streamer {
	if s == nil {
		return nil
	}
	s.HostnameValue = &v
	return s
}

func (s StreamerImpl) Labels() map[string]UnixName {
	return s.LabelsValue
}

func (s *StreamerImpl) SetLabels(v map[string]UnixName) Streamer {
	if s == nil {
		return nil
	}
	s.LabelsValue = v
	return s
}

// The internal address for communication in a local network (by default, it is equal to API URL).
// Format: url (url)
// Example: http://streamer.local
func (s StreamerImpl) PrivatePayloadURL() *URL {
	return s.PrivatePayloadURLValue
}

// The internal address for communication in a local network (by default, it is equal to API URL).
// Format: url (url)
// Example: http://streamer.local
func (s *StreamerImpl) SetPrivatePayloadURL(v URL) Streamer {
	if s == nil {
		return nil
	}
	s.PrivatePayloadURLValue = &v
	return s
}

// The public address that is exposed to clients. It can also contain a port number.
// The client will be redirected to this URL and port when requesting for the stream captured on the peer
// even if other `http` port is set in the peer's own config.
// Format: url (url)
// Example: http://public.example.com
func (s StreamerImpl) PublicPayloadURL() *URL {
	return s.PublicPayloadURLValue
}

// The public address that is exposed to clients. It can also contain a port number.
// The client will be redirected to this URL and port when requesting for the stream captured on the peer
// even if other `http` port is set in the peer's own config.
// Format: url (url)
// Example: http://public.example.com
func (s *StreamerImpl) SetPublicPayloadURL(v URL) Streamer {
	if s == nil {
		return nil
	}
	s.PublicPayloadURLValue = &v
	return s
}

// Role of node
func (s StreamerImpl) Role() *CentralNodeRoleRole {
	return s.RoleValue
}

// Role of node
func (s *StreamerImpl) SetRole(v CentralNodeRoleRole) Streamer {
	if s == nil {
		return nil
	}
	s.RoleValue = &v
	return s
}

// Statistics on peers in the cluster.
func (s StreamerImpl) Stats() PeerStats {
	return s.StatsValue
}

// Statistics on peers in the cluster.
func (s *StreamerImpl) SetStats(v PeerStats) Streamer {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*PeerStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// Server network bandwidth limit in kbit.
// This value is used to calculate the current network load status.
// Format: speed (speed)
// Example: 1024
func (s StreamerImpl) TotalBandwidth() *Speed {
	return s.TotalBandwidthValue
}

// Server network bandwidth limit in kbit.
// This value is used to calculate the current network load status.
// Format: speed (speed)
// Example: 1024
func (s *StreamerImpl) SetTotalBandwidth(v Speed) Streamer {
	if s == nil {
		return nil
	}
	s.TotalBandwidthValue = &v
	return s
}

// The names of the zones to which the streamer provides.
// Example: [zone1 zone2]
func (s StreamerImpl) Zones() []string {
	return s.ZonesValue
}

// The names of the zones to which the streamer provides.
// Example: [zone1 zone2]
func (s *StreamerImpl) SetZones(v []string) Streamer {
	if s == nil {
		return nil
	}
	s.ZonesValue = v
	return s
}

// NewStreamerConfig creates a new StreamerConfig instance
func NewStreamerConfig() StreamerConfig {
	return &StreamerConfigImpl{}
}

// The URL for provisioning of configuration from the managing server to the streamer.
// This URL does not have to be public but must be accessible from the managing server.
// The API URL can also be used as Public and/or Private payload URL if they are not set.
// When used as Public payload URL, the API URL shall be public to allow playback from this streamer.
// Format: url (url)
// Example: http://streamer.local:8080
func (s StreamerConfigImpl) APIURL() *URL {
	return s.APIURLValue
}

// The URL for provisioning of configuration from the managing server to the streamer.
// This URL does not have to be public but must be accessible from the managing server.
// The API URL can also be used as Public and/or Private payload URL if they are not set.
// When used as Public payload URL, the API URL shall be public to allow playback from this streamer.
// Format: url (url)
// Example: http://streamer.local:8080
func (s *StreamerConfigImpl) SetAPIURL(v URL) StreamerConfig {
	if s == nil {
		return nil
	}
	s.APIURLValue = &v
	return s
}

// Maximal number of streams.
// Example: 5
func (s StreamerConfigImpl) ChannelLimit() *int {
	return s.ChannelLimitValue
}

// Maximal number of streams.
// Example: 5
func (s *StreamerConfigImpl) SetChannelLimit(v int) StreamerConfig {
	if s == nil {
		return nil
	}
	s.ChannelLimitValue = &v
	return s
}

// The key for authorization for inter-Flussonic connections.
// All cluster peers should have the same cluster key.
// Example: xS6i6Q3DCc5nEvnu
func (s StreamerConfigImpl) ClusterKey() *string {
	return s.ClusterKeyValue
}

// The key for authorization for inter-Flussonic connections.
// All cluster peers should have the same cluster key.
// Example: xS6i6Q3DCc5nEvnu
func (s *StreamerConfigImpl) SetClusterKey(v string) StreamerConfig {
	if s == nil {
		return nil
	}
	s.ClusterKeyValue = &v
	return s
}

// Flussonic Media Server configuration which will be provided to Streamer
func (s StreamerConfigImpl) Config() StreamerConfigConfig {
	return s.ConfigValue
}

// Flussonic Media Server configuration which will be provided to Streamer
func (s *StreamerConfigImpl) SetConfig(v StreamerConfigConfig) StreamerConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*StreamerConfigConfigImpl); ok {
		s.ConfigValue = impl
	}
	return s
}

// The configuration of the DVRs
func (s StreamerConfigImpl) Dvrs() []DvrConfig {
	if s.DvrsValue == nil {
		return nil
	}
	result := make([]DvrConfig, len(s.DvrsValue))
	for i, item := range s.DvrsValue {
		result[i] = item
	}
	return result
}

// The configuration of the DVRs
func (s *StreamerConfigImpl) SetDvrs(v []DvrConfig) StreamerConfig {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*DvrConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*DvrConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.DvrsValue = impl
	}
	return s
}

// Streamer's identifier in the cluster.
// The managing server may try using this hostname to access the streamer
// if API URL is not specified.
// Format: server_name (server_name)
// Example: peer.example.com
func (s StreamerConfigImpl) Hostname() *ServerName {
	return s.HostnameValue
}

// Streamer's identifier in the cluster.
// The managing server may try using this hostname to access the streamer
// if API URL is not specified.
// Format: server_name (server_name)
// Example: peer.example.com
func (s *StreamerConfigImpl) SetHostname(v ServerName) StreamerConfig {
	if s == nil {
		return nil
	}
	s.HostnameValue = &v
	return s
}

func (s StreamerConfigImpl) Labels() map[string]UnixName {
	return s.LabelsValue
}

func (s *StreamerConfigImpl) SetLabels(v map[string]UnixName) StreamerConfig {
	if s == nil {
		return nil
	}
	s.LabelsValue = v
	return s
}

// The internal address for communication in a local network (by default, it is equal to API URL).
// Format: url (url)
// Example: http://streamer.local
func (s StreamerConfigImpl) PrivatePayloadURL() *URL {
	return s.PrivatePayloadURLValue
}

// The internal address for communication in a local network (by default, it is equal to API URL).
// Format: url (url)
// Example: http://streamer.local
func (s *StreamerConfigImpl) SetPrivatePayloadURL(v URL) StreamerConfig {
	if s == nil {
		return nil
	}
	s.PrivatePayloadURLValue = &v
	return s
}

// The public address that is exposed to clients. It can also contain a port number.
// The client will be redirected to this URL and port when requesting for the stream captured on the peer
// even if other `http` port is set in the peer's own config.
// Format: url (url)
// Example: http://public.example.com
func (s StreamerConfigImpl) PublicPayloadURL() *URL {
	return s.PublicPayloadURLValue
}

// The public address that is exposed to clients. It can also contain a port number.
// The client will be redirected to this URL and port when requesting for the stream captured on the peer
// even if other `http` port is set in the peer's own config.
// Format: url (url)
// Example: http://public.example.com
func (s *StreamerConfigImpl) SetPublicPayloadURL(v URL) StreamerConfig {
	if s == nil {
		return nil
	}
	s.PublicPayloadURLValue = &v
	return s
}

// Role of node
func (s StreamerConfigImpl) Role() *CentralNodeRoleRole {
	return s.RoleValue
}

// Role of node
func (s *StreamerConfigImpl) SetRole(v CentralNodeRoleRole) StreamerConfig {
	if s == nil {
		return nil
	}
	s.RoleValue = &v
	return s
}

// Statistics on peers in the cluster.
func (s StreamerConfigImpl) Stats() PeerStats {
	return s.StatsValue
}

// Statistics on peers in the cluster.
func (s *StreamerConfigImpl) SetStats(v PeerStats) StreamerConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*PeerStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// Server network bandwidth limit in kbit.
// This value is used to calculate the current network load status.
// Format: speed (speed)
// Example: 1024
func (s StreamerConfigImpl) TotalBandwidth() *Speed {
	return s.TotalBandwidthValue
}

// Server network bandwidth limit in kbit.
// This value is used to calculate the current network load status.
// Format: speed (speed)
// Example: 1024
func (s *StreamerConfigImpl) SetTotalBandwidth(v Speed) StreamerConfig {
	if s == nil {
		return nil
	}
	s.TotalBandwidthValue = &v
	return s
}

// NewStreamerConfigConfig creates a new StreamerConfigConfig instance
func NewStreamerConfigConfig() StreamerConfigConfig {
	return &StreamerConfigConfigImpl{}
}

// The list of allowed subnets to accept API requests from.
func (s StreamerConfigConfigImpl) APIAllowedFrom() []Cidr {
	return s.APIAllowedFromValue
}

// The list of allowed subnets to accept API requests from.
func (s *StreamerConfigConfigImpl) SetAPIAllowedFrom(v []Cidr) StreamerConfigConfig {
	if s == nil {
		return nil
	}
	s.APIAllowedFromValue = v
	return s
}

// The configuration of auth backends
func (s StreamerConfigConfigImpl) AuthBackends() []AuthBackendConfig {
	if s.AuthBackendsValue == nil {
		return nil
	}
	result := make([]AuthBackendConfig, len(s.AuthBackendsValue))
	for i, item := range s.AuthBackendsValue {
		result[i] = item
	}
	return result
}

// The configuration of auth backends
func (s *StreamerConfigConfigImpl) SetAuthBackends(v []AuthBackendConfig) StreamerConfigConfig {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*AuthBackendConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*AuthBackendConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.AuthBackendsValue = impl
	}
	return s
}

// Configure key name of query string key-value pair for token authentication
func (s StreamerConfigConfigImpl) AuthToken() *AuthToken {
	return s.AuthTokenValue
}

// Configure key name of query string key-value pair for token authentication
func (s *StreamerConfigConfigImpl) SetAuthToken(v AuthToken) StreamerConfigConfig {
	if s == nil {
		return nil
	}
	s.AuthTokenValue = &v
	return s
}

// The configuration of the balancers.
func (s StreamerConfigConfigImpl) Balancers() []BalancerConfig {
	if s.BalancersValue == nil {
		return nil
	}
	result := make([]BalancerConfig, len(s.BalancersValue))
	for i, item := range s.BalancersValue {
		result[i] = item
	}
	return result
}

// The configuration of the balancers.
func (s *StreamerConfigConfigImpl) SetBalancers(v []BalancerConfig) StreamerConfigConfig {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*BalancerConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*BalancerConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.BalancersValue = impl
	}
	return s
}

// The configuration of the cache.
func (s StreamerConfigConfigImpl) Caches() []CacheConfig {
	if s.CachesValue == nil {
		return nil
	}
	result := make([]CacheConfig, len(s.CachesValue))
	for i, item := range s.CachesValue {
		result[i] = item
	}
	return result
}

// The configuration of the cache.
func (s *StreamerConfigConfigImpl) SetCaches(v []CacheConfig) StreamerConfigConfig {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*CacheConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*CacheConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.CachesValue = impl
	}
	return s
}

// The configuration of the camera alarms.
func (s StreamerConfigConfigImpl) CameraAlarm() CameraAlarmConfig {
	return s.CameraAlarmValue
}

// The configuration of the camera alarms.
func (s *StreamerConfigConfigImpl) SetCameraAlarm(v CameraAlarmConfig) StreamerConfigConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*CameraAlarmConfigImpl); ok {
		s.CameraAlarmValue = impl
	}
	return s
}

// The configuration of the chassis.
func (s StreamerConfigConfigImpl) Chassis() ChassisConfig {
	return s.ChassisValue
}

// The configuration of the chassis.
func (s *StreamerConfigConfigImpl) SetChassis(v ChassisConfig) StreamerConfigConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ChassisConfigImpl); ok {
		s.ChassisValue = impl
	}
	return s
}

// The cluster key to unite several servers with the same key into a cluster.
// Example: xS6i6Q3DCc5nEvnu
func (s StreamerConfigConfigImpl) ClusterKey() *string {
	return s.ClusterKeyValue
}

// The cluster key to unite several servers with the same key into a cluster.
// Example: xS6i6Q3DCc5nEvnu
func (s *StreamerConfigConfigImpl) SetClusterKey(v string) StreamerConfigConfig {
	if s == nil {
		return nil
	}
	s.ClusterKeyValue = &v
	return s
}

// Configuration of decklink SDI capture cards
func (s StreamerConfigConfigImpl) Decklinks() []DecklinkConfig {
	if s.DecklinksValue == nil {
		return nil
	}
	result := make([]DecklinkConfig, len(s.DecklinksValue))
	for i, item := range s.DecklinksValue {
		result[i] = item
	}
	return result
}

// Configuration of decklink SDI capture cards
func (s *StreamerConfigConfigImpl) SetDecklinks(v []DecklinkConfig) StreamerConfigConfig {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*DecklinkConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*DecklinkConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.DecklinksValue = impl
	}
	return s
}

// The configuration of the DVB cards.
func (s StreamerConfigConfigImpl) DvbCards() []DvbCardConfig {
	if s.DvbCardsValue == nil {
		return nil
	}
	result := make([]DvbCardConfig, len(s.DvbCardsValue))
	for i, item := range s.DvbCardsValue {
		result[i] = item
	}
	return result
}

// The configuration of the DVB cards.
func (s *StreamerConfigConfigImpl) SetDvbCards(v []DvbCardConfig) StreamerConfigConfig {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*DvbCardConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*DvbCardConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.DvbCardsValue = impl
	}
	return s
}

// The configuration of the DVRs
func (s StreamerConfigConfigImpl) Dvrs() []DvrConfig {
	if s.DvrsValue == nil {
		return nil
	}
	result := make([]DvrConfig, len(s.DvrsValue))
	for i, item := range s.DvrsValue {
		result[i] = item
	}
	return result
}

// The configuration of the DVRs
func (s *StreamerConfigConfigImpl) SetDvrs(v []DvrConfig) StreamerConfigConfig {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*DvrConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*DvrConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.DvrsValue = impl
	}
	return s
}

// Credentials for administrator access to the server.
func (s StreamerConfigConfigImpl) EditAuth() AdminCredentials {
	return s.EditAuthValue
}

// Credentials for administrator access to the server.
func (s *StreamerConfigConfigImpl) SetEditAuth(v AdminCredentials) StreamerConfigConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*AdminCredentialsImpl); ok {
		s.EditAuthValue = impl
	}
	return s
}

// The configuration of event notifications
func (s StreamerConfigConfigImpl) EventSinks() []EventSinkConfig {
	if s.EventSinksValue == nil {
		return nil
	}
	result := make([]EventSinkConfig, len(s.EventSinksValue))
	for i, item := range s.EventSinksValue {
		result[i] = item
	}
	return result
}

// The configuration of event notifications
func (s *StreamerConfigConfigImpl) SetEventSinks(v []EventSinkConfig) StreamerConfigConfig {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*EventSinkConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*EventSinkConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.EventSinksValue = impl
	}
	return s
}

// The configuration of the file processor.
func (s StreamerConfigConfigImpl) FileProcessor() FileProcessorConfig {
	return s.FileProcessorValue
}

// The configuration of the file processor.
func (s *StreamerConfigConfigImpl) SetFileProcessor(v FileProcessorConfig) StreamerConfigConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*FileProcessorConfigImpl); ok {
		s.FileProcessorValue = impl
	}
	return s
}

// Use your own GeoIP database.
// Format: disk_path (disk_path)
// Example: /usr/share/GeoIP/GeoLite2-City.mmdb
func (s StreamerConfigConfigImpl) Geoip() *DiskPath {
	return s.GeoipValue
}

// Use your own GeoIP database.
// Format: disk_path (disk_path)
// Example: /usr/share/GeoIP/GeoLite2-City.mmdb
func (s *StreamerConfigConfigImpl) SetGeoip(v DiskPath) StreamerConfigConfig {
	if s == nil {
		return nil
	}
	s.GeoipValue = &v
	return s
}

// List of HTTP prefixes that can be handled via call to remote http server
func (s StreamerConfigConfigImpl) HTTPProxies() []HTTPProxyConfig {
	if s.HTTPProxiesValue == nil {
		return nil
	}
	result := make([]HTTPProxyConfig, len(s.HTTPProxiesValue))
	for i, item := range s.HTTPProxiesValue {
		result[i] = item
	}
	return result
}

// List of HTTP prefixes that can be handled via call to remote http server
func (s *StreamerConfigConfigImpl) SetHTTPProxies(v []HTTPProxyConfig) StreamerConfigConfig {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*HTTPProxyConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*HTTPProxyConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.HTTPProxiesValue = impl
	}
	return s
}

// The configuration of the IPTV
func (s StreamerConfigConfigImpl) Iptv() IptvConfig {
	return s.IptvValue
}

// The configuration of the IPTV
func (s *StreamerConfigConfigImpl) SetIptv(v IptvConfig) StreamerConfigConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*IptvConfigImpl); ok {
		s.IptvValue = impl
	}
	return s
}

// The configuration of network listeners.
func (s StreamerConfigConfigImpl) Listeners() Listeners {
	return s.ListenersValue
}

// The configuration of network listeners.
func (s *StreamerConfigConfigImpl) SetListeners(v Listeners) StreamerConfigConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ListenersImpl); ok {
		s.ListenersValue = impl
	}
	return s
}

// Enables logging of requests for streams (manifests, segments) and API request.
func (s StreamerConfigConfigImpl) LogRequests() *bool {
	return s.LogRequestsValue
}

// Enables logging of requests for streams (manifests, segments) and API request.
func (s *StreamerConfigConfigImpl) SetLogRequests(v bool) StreamerConfigConfig {
	if s == nil {
		return nil
	}
	s.LogRequestsValue = &v
	return s
}

// Raise loglevel to debug if needed.
// Example: error
func (s StreamerConfigConfigImpl) Loglevel() *Loglevel {
	return s.LoglevelValue
}

// Raise loglevel to debug if needed.
// Example: error
func (s *StreamerConfigConfigImpl) SetLoglevel(v Loglevel) StreamerConfigConfig {
	if s == nil {
		return nil
	}
	s.LoglevelValue = &v
	return s
}

// Some additional options of the server.
// Example: {"role": "transcoder"}
func (s StreamerConfigConfigImpl) Meta() *string {
	return s.MetaValue
}

// Some additional options of the server.
// Example: {"role": "transcoder"}
func (s *StreamerConfigConfigImpl) SetMeta(v string) StreamerConfigConfig {
	if s == nil {
		return nil
	}
	s.MetaValue = &v
	return s
}

// Deprecated field. Will be deleted at 25.11
// Enables saving statistics on Nvidia performance.
// Example: true
func (s StreamerConfigConfigImpl) NvidiaMonitor() *bool {
	return s.NvidiaMonitorValue
}

// Deprecated field. Will be deleted at 25.11
// Enables saving statistics on Nvidia performance.
// Example: true
func (s *StreamerConfigConfigImpl) SetNvidiaMonitor(v bool) StreamerConfigConfig {
	if s == nil {
		return nil
	}
	s.NvidiaMonitorValue = &v
	return s
}

// The configuration of peers in the cluster.
func (s StreamerConfigConfigImpl) Peers() []PeerConfig {
	if s.PeersValue == nil {
		return nil
	}
	result := make([]PeerConfig, len(s.PeersValue))
	for i, item := range s.PeersValue {
		result[i] = item
	}
	return result
}

// The configuration of peers in the cluster.
func (s *StreamerConfigConfigImpl) SetPeers(v []PeerConfig) StreamerConfigConfig {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*PeerConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*PeerConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.PeersValue = impl
	}
	return s
}

// Directory to store Pulse statistics.
// Format: disk_path (disk_path)
// Example: /var/run/flussonic/pulsedb
func (s StreamerConfigConfigImpl) Pulsedb() *DiskPath {
	return s.PulsedbValue
}

// Directory to store Pulse statistics.
// Format: disk_path (disk_path)
// Example: /var/run/flussonic/pulsedb
func (s *StreamerConfigConfigImpl) SetPulsedb(v DiskPath) StreamerConfigConfig {
	if s == nil {
		return nil
	}
	s.PulsedbValue = &v
	return s
}

// The configuration of the port forwarding.
func (s StreamerConfigConfigImpl) Rproxy() RproxyConfig {
	return s.RproxyValue
}

// The configuration of the port forwarding.
func (s *StreamerConfigConfigImpl) SetRproxy(v RproxyConfig) StreamerConfigConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*RproxyConfigImpl); ok {
		s.RproxyValue = impl
	}
	return s
}

// The configuration of server domain name and aliases
func (s StreamerConfigConfigImpl) ServerNames() []ServerNameConfig {
	if s.ServerNamesValue == nil {
		return nil
	}
	result := make([]ServerNameConfig, len(s.ServerNamesValue))
	for i, item := range s.ServerNamesValue {
		result[i] = item
	}
	return result
}

// The configuration of server domain name and aliases
func (s *StreamerConfigConfigImpl) SetServerNames(v []ServerNameConfig) StreamerConfigConfig {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*ServerNameConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*ServerNameConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.ServerNamesValue = impl
	}
	return s
}

// Deprecated field. Will be deleted at 26.01
// Directory to store the session log.
// Format: disk_path (disk_path)
// Example: /var/run/flussonic/session_log
func (s StreamerConfigConfigImpl) SessionLog() *DiskPath {
	return s.SessionLogValue
}

// Deprecated field. Will be deleted at 26.01
// Directory to store the session log.
// Format: disk_path (disk_path)
// Example: /var/run/flussonic/session_log
func (s *StreamerConfigConfigImpl) SetSessionLog(v DiskPath) StreamerConfigConfig {
	if s == nil {
		return nil
	}
	s.SessionLogValue = &v
	return s
}

// The configuration of the video sources.
func (s StreamerConfigConfigImpl) Sources() []SourceConfig {
	if s.SourcesValue == nil {
		return nil
	}
	result := make([]SourceConfig, len(s.SourcesValue))
	for i, item := range s.SourcesValue {
		result[i] = item
	}
	return result
}

// The configuration of the video sources.
func (s *StreamerConfigConfigImpl) SetSources(v []SourceConfig) StreamerConfigConfig {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*SourceConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*SourceConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.SourcesValue = impl
	}
	return s
}

// Global SRT listening port. It is possible to use a single port for playback and publishing, but it is not compatible with clients.
// Consider configuring separate ports for playback and publishing for each stream.
func (s StreamerConfigConfigImpl) Srt() *ListenSpec {
	return s.SrtValue
}

// Global SRT listening port. It is possible to use a single port for playback and publishing, but it is not compatible with clients.
// Consider configuring separate ports for playback and publishing for each stream.
func (s *StreamerConfigConfigImpl) SetSrt(v *ListenSpec) StreamerConfigConfig {
	if s == nil {
		return nil
	}
	s.SrtValue = v
	return s
}

// SRT2 play configuration with single-port mode. Not supported by many clients, better use per-stream mode.
func (s StreamerConfigConfigImpl) Srt2Play() SrtConfig {
	return s.Srt2PlayValue
}

// SRT2 play configuration with single-port mode. Not supported by many clients, better use per-stream mode.
func (s *StreamerConfigConfigImpl) SetSrt2Play(v SrtConfig) StreamerConfigConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*SrtConfigImpl); ok {
		s.Srt2PlayValue = impl
	}
	return s
}

// SRT2 publish configuration with single-port mode. Not supported by many clients, better use per-stream mode.
func (s StreamerConfigConfigImpl) Srt2Publish() SrtConfig {
	return s.Srt2PublishValue
}

// SRT2 publish configuration with single-port mode. Not supported by many clients, better use per-stream mode.
func (s *StreamerConfigConfigImpl) SetSrt2Publish(v SrtConfig) StreamerConfigConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*SrtConfigImpl); ok {
		s.Srt2PublishValue = impl
	}
	return s
}

// SRT play configuration with single-port mode. Not supported by many clients, better use per-stream mode.
func (s StreamerConfigConfigImpl) SrtPlay() SrtConfig {
	return s.SrtPlayValue
}

// SRT play configuration with single-port mode. Not supported by many clients, better use per-stream mode.
func (s *StreamerConfigConfigImpl) SetSrtPlay(v SrtConfig) StreamerConfigConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*SrtConfigImpl); ok {
		s.SrtPlayValue = impl
	}
	return s
}

// SRT publish configuration with single-port mode. Not supported by many clients, better use per-stream mode.
func (s StreamerConfigConfigImpl) SrtPublish() SrtConfig {
	return s.SrtPublishValue
}

// SRT publish configuration with single-port mode. Not supported by many clients, better use per-stream mode.
func (s *StreamerConfigConfigImpl) SetSrtPublish(v SrtConfig) StreamerConfigConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*SrtConfigImpl); ok {
		s.SrtPublishValue = impl
	}
	return s
}

// The configuration of the streams.
func (s StreamerConfigConfigImpl) Streams() []StreamConfig {
	if s.StreamsValue == nil {
		return nil
	}
	result := make([]StreamConfig, len(s.StreamsValue))
	for i, item := range s.StreamsValue {
		result[i] = item
	}
	return result
}

// The configuration of the streams.
func (s *StreamerConfigConfigImpl) SetStreams(v []StreamConfig) StreamerConfigConfig {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*StreamConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*StreamConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.StreamsValue = impl
	}
	return s
}

// The configuration of the templates.
func (s StreamerConfigConfigImpl) Templates() []TemplateConfig {
	if s.TemplatesValue == nil {
		return nil
	}
	result := make([]TemplateConfig, len(s.TemplatesValue))
	for i, item := range s.TemplatesValue {
		result[i] = item
	}
	return result
}

// The configuration of the templates.
func (s *StreamerConfigConfigImpl) SetTemplates(v []TemplateConfig) StreamerConfigConfig {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*TemplateConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*TemplateConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.TemplatesValue = impl
	}
	return s
}

// Total server bandwidth.
// Format: speed (speed)
// Example: 1e+09
func (s StreamerConfigConfigImpl) TotalBandwidth() *Speed {
	return s.TotalBandwidthValue
}

// Total server bandwidth.
// Format: speed (speed)
// Example: 1e+09
func (s *StreamerConfigConfigImpl) SetTotalBandwidth(v Speed) StreamerConfigConfig {
	if s == nil {
		return nil
	}
	s.TotalBandwidthValue = &v
	return s
}

// The configuration of the transponders.
func (s StreamerConfigConfigImpl) Transponders() []TransponderConfig {
	if s.TranspondersValue == nil {
		return nil
	}
	result := make([]TransponderConfig, len(s.TranspondersValue))
	for i, item := range s.TranspondersValue {
		result[i] = item
	}
	return result
}

// The configuration of the transponders.
func (s *StreamerConfigConfigImpl) SetTransponders(v []TransponderConfig) StreamerConfigConfig {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*TransponderConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*TransponderConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.TranspondersValue = impl
	}
	return s
}

// This option applies to HLS and DASH protocols, for all streams on the server.
// The addresses of individual segments within a segment-based playlist will start with the specified prefix.
// This setting is available in the global part of the config file as well as locally for any individual stream.
// When specified at the stream level, it is only valid for this particular stream.
func (s StreamerConfigConfigImpl) URLPrefix() *URLPrefix {
	return s.URLPrefixValue
}

// This option applies to HLS and DASH protocols, for all streams on the server.
// The addresses of individual segments within a segment-based playlist will start with the specified prefix.
// This setting is available in the global part of the config file as well as locally for any individual stream.
// When specified at the stream level, it is only valid for this particular stream.
func (s *StreamerConfigConfigImpl) SetURLPrefix(v *URLPrefix) StreamerConfigConfig {
	if s == nil {
		return nil
	}
	s.URLPrefixValue = v
	return s
}

// Credentials for access to readonly API functions like getting streams info, status, and statistics.
func (s StreamerConfigConfigImpl) ViewAuth() AdminCredentials {
	return s.ViewAuthValue
}

// Credentials for access to readonly API functions like getting streams info, status, and statistics.
func (s *StreamerConfigConfigImpl) SetViewAuth(v AdminCredentials) StreamerConfigConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*AdminCredentialsImpl); ok {
		s.ViewAuthValue = impl
	}
	return s
}

// The configuration of VODs
func (s StreamerConfigConfigImpl) Vods() []VodConfig {
	if s.VodsValue == nil {
		return nil
	}
	result := make([]VodConfig, len(s.VodsValue))
	for i, item := range s.VodsValue {
		result[i] = item
	}
	return result
}

// The configuration of VODs
func (s *StreamerConfigConfigImpl) SetVods(v []VodConfig) StreamerConfigConfig {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*VodConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*VodConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.VodsValue = impl
	}
	return s
}

// The configuration of the video surveillance subsystem.
func (s StreamerConfigConfigImpl) Vsaas() VsaasConfig {
	return s.VsaasValue
}

// The configuration of the video surveillance subsystem.
func (s *StreamerConfigConfigImpl) SetVsaas(v VsaasConfig) StreamerConfigConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VsaasConfigImpl); ok {
		s.VsaasValue = impl
	}
	return s
}

// Global WebRTC ports configuration for playback (via WHEP - WebRTC HTTP egress protocol).
func (s StreamerConfigConfigImpl) WebrtcPlay() WebrtcRouterConfig {
	return s.WebrtcPlayValue
}

// Global WebRTC ports configuration for playback (via WHEP - WebRTC HTTP egress protocol).
func (s *StreamerConfigConfigImpl) SetWebrtcPlay(v WebrtcRouterConfig) StreamerConfigConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*WebrtcRouterConfigImpl); ok {
		s.WebrtcPlayValue = impl
	}
	return s
}

// Global WebRTC ports configuration for publishing (via WHIP - WebRTC HTTP ingestion protocol).
func (s StreamerConfigConfigImpl) WebrtcPublish() WebrtcRouterConfig {
	return s.WebrtcPublishValue
}

// Global WebRTC ports configuration for publishing (via WHIP - WebRTC HTTP ingestion protocol).
func (s *StreamerConfigConfigImpl) SetWebrtcPublish(v WebrtcRouterConfig) StreamerConfigConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*WebrtcRouterConfigImpl); ok {
		s.WebrtcPublishValue = impl
	}
	return s
}

// NewStreamerLayoutPrediction creates a new StreamerLayoutPrediction instance
func NewStreamerLayoutPrediction() StreamerLayoutPrediction {
	return &StreamerLayoutPredictionImpl{}
}

// The URL for provisioning of configuration from the managing server to the streamer.
// This URL does not have to be public but must be accessible from the managing server.
// The API URL can also be used as Public and/or Private payload URL if they are not set.
// When used as Public payload URL, the API URL shall be public to allow playback from this streamer.
// Format: url (url)
// Example: http://streamer.local:8080
func (s StreamerLayoutPredictionImpl) APIURL() *URL {
	return s.APIURLValue
}

// The URL for provisioning of configuration from the managing server to the streamer.
// This URL does not have to be public but must be accessible from the managing server.
// The API URL can also be used as Public and/or Private payload URL if they are not set.
// When used as Public payload URL, the API URL shall be public to allow playback from this streamer.
// Format: url (url)
// Example: http://streamer.local:8080
func (s *StreamerLayoutPredictionImpl) SetAPIURL(v URL) StreamerLayoutPrediction {
	if s == nil {
		return nil
	}
	s.APIURLValue = &v
	return s
}

// Maximal number of streams.
// Example: 5
func (s StreamerLayoutPredictionImpl) ChannelLimit() *int {
	return s.ChannelLimitValue
}

// Maximal number of streams.
// Example: 5
func (s *StreamerLayoutPredictionImpl) SetChannelLimit(v int) StreamerLayoutPrediction {
	if s == nil {
		return nil
	}
	s.ChannelLimitValue = &v
	return s
}

// The key for authorization for inter-Flussonic connections.
// All cluster peers should have the same cluster key.
// Example: xS6i6Q3DCc5nEvnu
func (s StreamerLayoutPredictionImpl) ClusterKey() *string {
	return s.ClusterKeyValue
}

// The key for authorization for inter-Flussonic connections.
// All cluster peers should have the same cluster key.
// Example: xS6i6Q3DCc5nEvnu
func (s *StreamerLayoutPredictionImpl) SetClusterKey(v string) StreamerLayoutPrediction {
	if s == nil {
		return nil
	}
	s.ClusterKeyValue = &v
	return s
}

// Flussonic Media Server configuration which will be provided to Streamer
func (s StreamerLayoutPredictionImpl) Config() StreamerConfigConfig {
	return s.ConfigValue
}

// Flussonic Media Server configuration which will be provided to Streamer
func (s *StreamerLayoutPredictionImpl) SetConfig(v StreamerConfigConfig) StreamerLayoutPrediction {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*StreamerConfigConfigImpl); ok {
		s.ConfigValue = impl
	}
	return s
}

// The configuration of the DVRs
func (s StreamerLayoutPredictionImpl) Dvrs() []DvrConfig {
	if s.DvrsValue == nil {
		return nil
	}
	result := make([]DvrConfig, len(s.DvrsValue))
	for i, item := range s.DvrsValue {
		result[i] = item
	}
	return result
}

// The configuration of the DVRs
func (s *StreamerLayoutPredictionImpl) SetDvrs(v []DvrConfig) StreamerLayoutPrediction {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*DvrConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*DvrConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.DvrsValue = impl
	}
	return s
}

// Streamer's identifier in the cluster.
// The managing server may try using this hostname to access the streamer
// if API URL is not specified.
// Format: server_name (server_name)
// Example: peer.example.com
func (s StreamerLayoutPredictionImpl) Hostname() *ServerName {
	return s.HostnameValue
}

// Streamer's identifier in the cluster.
// The managing server may try using this hostname to access the streamer
// if API URL is not specified.
// Format: server_name (server_name)
// Example: peer.example.com
func (s *StreamerLayoutPredictionImpl) SetHostname(v ServerName) StreamerLayoutPrediction {
	if s == nil {
		return nil
	}
	s.HostnameValue = &v
	return s
}

func (s StreamerLayoutPredictionImpl) Labels() map[string]UnixName {
	return s.LabelsValue
}

func (s *StreamerLayoutPredictionImpl) SetLabels(v map[string]UnixName) StreamerLayoutPrediction {
	if s == nil {
		return nil
	}
	s.LabelsValue = v
	return s
}

// The internal address for communication in a local network (by default, it is equal to API URL).
// Format: url (url)
// Example: http://streamer.local
func (s StreamerLayoutPredictionImpl) PrivatePayloadURL() *URL {
	return s.PrivatePayloadURLValue
}

// The internal address for communication in a local network (by default, it is equal to API URL).
// Format: url (url)
// Example: http://streamer.local
func (s *StreamerLayoutPredictionImpl) SetPrivatePayloadURL(v URL) StreamerLayoutPrediction {
	if s == nil {
		return nil
	}
	s.PrivatePayloadURLValue = &v
	return s
}

// The public address that is exposed to clients. It can also contain a port number.
// The client will be redirected to this URL and port when requesting for the stream captured on the peer
// even if other `http` port is set in the peer's own config.
// Format: url (url)
// Example: http://public.example.com
func (s StreamerLayoutPredictionImpl) PublicPayloadURL() *URL {
	return s.PublicPayloadURLValue
}

// The public address that is exposed to clients. It can also contain a port number.
// The client will be redirected to this URL and port when requesting for the stream captured on the peer
// even if other `http` port is set in the peer's own config.
// Format: url (url)
// Example: http://public.example.com
func (s *StreamerLayoutPredictionImpl) SetPublicPayloadURL(v URL) StreamerLayoutPrediction {
	if s == nil {
		return nil
	}
	s.PublicPayloadURLValue = &v
	return s
}

// Role of node
func (s StreamerLayoutPredictionImpl) Role() *CentralNodeRoleRole {
	return s.RoleValue
}

// Role of node
func (s *StreamerLayoutPredictionImpl) SetRole(v CentralNodeRoleRole) StreamerLayoutPrediction {
	if s == nil {
		return nil
	}
	s.RoleValue = &v
	return s
}

// Statistics on peers in the cluster.
func (s StreamerLayoutPredictionImpl) Stats() PeerStats {
	return s.StatsValue
}

// Statistics on peers in the cluster.
func (s *StreamerLayoutPredictionImpl) SetStats(v PeerStats) StreamerLayoutPrediction {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*PeerStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// Server network bandwidth limit in kbit.
// This value is used to calculate the current network load status.
// Format: speed (speed)
// Example: 1024
func (s StreamerLayoutPredictionImpl) TotalBandwidth() *Speed {
	return s.TotalBandwidthValue
}

// Server network bandwidth limit in kbit.
// This value is used to calculate the current network load status.
// Format: speed (speed)
// Example: 1024
func (s *StreamerLayoutPredictionImpl) SetTotalBandwidth(v Speed) StreamerLayoutPrediction {
	if s == nil {
		return nil
	}
	s.TotalBandwidthValue = &v
	return s
}

// The names of the zones to which the streamer provides.
// Example: [zone1 zone2]
func (s StreamerLayoutPredictionImpl) Zones() []string {
	return s.ZonesValue
}

// The names of the zones to which the streamer provides.
// Example: [zone1 zone2]
func (s *StreamerLayoutPredictionImpl) SetZones(v []string) StreamerLayoutPrediction {
	if s == nil {
		return nil
	}
	s.ZonesValue = v
	return s
}

// NewStreamersList creates a new StreamersList instance
func NewStreamersList() StreamersList {
	return &StreamersListImpl{}
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s StreamersListImpl) EstimatedCount() *int {
	return s.EstimatedCountValue
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s *StreamersListImpl) SetEstimatedCount(v int) StreamersList {
	if s == nil {
		return nil
	}
	s.EstimatedCountValue = &v
	return s
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s StreamersListImpl) Next() *string {
	return s.NextValue
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s *StreamersListImpl) SetNext(v string) StreamersList {
	if s == nil {
		return nil
	}
	s.NextValue = &v
	return s
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s StreamersListImpl) Prev() *string {
	return s.PrevValue
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s *StreamersListImpl) SetPrev(v string) StreamersList {
	if s == nil {
		return nil
	}
	s.PrevValue = &v
	return s
}

// The list of streamers fetched according to the query parameters.
func (s StreamersListImpl) Streamers() []Streamer {
	if s.StreamersValue == nil {
		return nil
	}
	result := make([]Streamer, len(s.StreamersValue))
	for i, item := range s.StreamersValue {
		result[i] = item
	}
	return result
}

// The list of streamers fetched according to the query parameters.
func (s *StreamersListImpl) SetStreamers(v []Streamer) StreamersList {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*StreamerImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*StreamerImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.StreamersValue = impl
	}
	return s
}

// An object with a list of different timings measured during this API call.
func (s StreamersListImpl) Timing() any {
	return s.TimingValue
}

// An object with a list of different timings measured during this API call.
func (s *StreamersListImpl) SetTiming(v any) StreamersList {
	if s == nil {
		return nil
	}
	s.TimingValue = v
	return s
}

// Collection returns the collection items from StreamersList
func (s StreamersListImpl) Collection() []Streamer {
	return s.Streamers()
}

// NewStreamsList creates a new StreamsList instance
func NewStreamsList() StreamsList {
	return &StreamsListImpl{}
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s StreamsListImpl) EstimatedCount() *int {
	return s.EstimatedCountValue
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s *StreamsListImpl) SetEstimatedCount(v int) StreamsList {
	if s == nil {
		return nil
	}
	s.EstimatedCountValue = &v
	return s
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s StreamsListImpl) Next() *string {
	return s.NextValue
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s *StreamsListImpl) SetNext(v string) StreamsList {
	if s == nil {
		return nil
	}
	s.NextValue = &v
	return s
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s StreamsListImpl) Prev() *string {
	return s.PrevValue
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s *StreamsListImpl) SetPrev(v string) StreamsList {
	if s == nil {
		return nil
	}
	s.PrevValue = &v
	return s
}

// List of fetched streams according to the query parameters.
func (s StreamsListImpl) Streams() []StreamConfig {
	if s.StreamsValue == nil {
		return nil
	}
	result := make([]StreamConfig, len(s.StreamsValue))
	for i, item := range s.StreamsValue {
		result[i] = item
	}
	return result
}

// List of fetched streams according to the query parameters.
func (s *StreamsListImpl) SetStreams(v []StreamConfig) StreamsList {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*StreamConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*StreamConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.StreamsValue = impl
	}
	return s
}

// An object with a list of different timings measured during this API call.
func (s StreamsListImpl) Timing() any {
	return s.TimingValue
}

// An object with a list of different timings measured during this API call.
func (s *StreamsListImpl) SetTiming(v any) StreamsList {
	if s == nil {
		return nil
	}
	s.TimingValue = v
	return s
}

// Collection returns the collection items from StreamsList
func (s StreamsListImpl) Collection() []StreamConfig {
	return s.Streams()
}

// NewStreamsMultieditConfig creates a new StreamsMultieditConfig instance
func NewStreamsMultieditConfig() StreamsMultieditConfig {
	return &StreamsMultieditConfigImpl{}
}

// List of streams with their settings
func (s StreamsMultieditConfigImpl) Streams() []StreamConfigMultiedit {
	if s.StreamsValue == nil {
		return nil
	}
	result := make([]StreamConfigMultiedit, len(s.StreamsValue))
	for i, item := range s.StreamsValue {
		result[i] = item
	}
	return result
}

// List of streams with their settings
func (s *StreamsMultieditConfigImpl) SetStreams(v []StreamConfigMultiedit) StreamsMultieditConfig {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*StreamConfigMultieditImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*StreamConfigMultieditImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.StreamsValue = impl
	}
	return s
}

// NewStreamsZoneSettings creates a new StreamsZoneSettings instance
func NewStreamsZoneSettings() StreamsZoneSettings {
	return &StreamsZoneSettingsImpl{}
}

// List of streams with their zone settings
func (s StreamsZoneSettingsImpl) Streams() []any {
	return s.StreamsValue
}

// List of streams with their zone settings
func (s *StreamsZoneSettingsImpl) SetStreams(v []any) StreamsZoneSettings {
	if s == nil {
		return nil
	}
	s.StreamsValue = v
	return s
}

// NewSystemConfig creates a new SystemConfig instance
func NewSystemConfig() SystemConfig {
	return &SystemConfigImpl{}
}

// The parameter is needed so that other elements of the cluster (the center and the media server)
// can contact the watcher for authorization.
// Format: url (url)
// Example: auth@localhost:9015
func (s SystemConfigImpl) APIURL() *URL {
	return s.APIURLValue
}

// The parameter is needed so that other elements of the cluster (the center and the media server)
// can contact the watcher for authorization.
// Format: url (url)
// Example: auth@localhost:9015
func (s *SystemConfigImpl) SetAPIURL(v URL) SystemConfig {
	if s == nil {
		return nil
	}
	s.APIURLValue = &v
	return s
}

// The url through which the watcher addresses the central
// Format: url (url)
// Example: http://auth@localhost:9019/streamer/api/v3
func (s SystemConfigImpl) CentralURL() *URL {
	return s.CentralURLValue
}

// The url through which the watcher addresses the central
// Format: url (url)
// Example: http://auth@localhost:9019/streamer/api/v3
func (s *SystemConfigImpl) SetCentralURL(v URL) SystemConfig {
	if s == nil {
		return nil
	}
	s.CentralURLValue = &v
	return s
}

// An additional authorization backend that allows you to authenticate the camera not only in the watcher
// Format: url (url)
// Example: http://localhost/camera/authorization
func (s SystemConfigImpl) CustomAuth() *URL {
	return s.CustomAuthValue
}

// An additional authorization backend that allows you to authenticate the camera not only in the watcher
// Format: url (url)
// Example: http://localhost/camera/authorization
func (s *SystemConfigImpl) SetCustomAuth(v URL) SystemConfig {
	if s == nil {
		return nil
	}
	s.CustomAuthValue = &v
	return s
}

// The configuration of database connection
func (s SystemConfigImpl) Database() Database {
	return s.DatabaseValue
}

// The configuration of database connection
func (s *SystemConfigImpl) SetDatabase(v Database) SystemConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*DatabaseImpl); ok {
		s.DatabaseValue = impl
	}
	return s
}

// Issued license key
func (s SystemConfigImpl) LicenseKey() *string {
	return s.LicenseKeyValue
}

// Issued license key
func (s *SystemConfigImpl) SetLicenseKey(v string) SystemConfig {
	if s == nil {
		return nil
	}
	s.LicenseKeyValue = &v
	return s
}

// The configuration of network listeners.
func (s SystemConfigImpl) Listeners() Listeners {
	return s.ListenersValue
}

// The configuration of network listeners.
func (s *SystemConfigImpl) SetListeners(v Listeners) SystemConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ListenersImpl); ok {
		s.ListenersValue = impl
	}
	return s
}

// Set logging level
func (s SystemConfigImpl) Loglevel() *Loglevel {
	return s.LoglevelValue
}

// Set logging level
func (s *SystemConfigImpl) SetLoglevel(v Loglevel) SystemConfig {
	if s == nil {
		return nil
	}
	s.LoglevelValue = &v
	return s
}

// A parameter that determines the time of blocking the user in seconds after several incorrect login attempts
func (s SystemConfigImpl) WatcherBruteForceTimeout() *int {
	return s.WatcherBruteForceTimeoutValue
}

// A parameter that determines the time of blocking the user in seconds after several incorrect login attempts
func (s *SystemConfigImpl) SetWatcherBruteForceTimeout(v int) SystemConfig {
	if s == nil {
		return nil
	}
	s.WatcherBruteForceTimeoutValue = &v
	return s
}

// NewTSDescriptor creates a new TSDescriptor instance
func NewTSDescriptor() TSDescriptor {
	return &TSDescriptorImpl{}
}

// Descriptor data.
// Format: hexbinary (hexbinary)
func (s TSDescriptorImpl) Hex() Hexbinary {
	return s.HexValue
}

// Descriptor data.
// Format: hexbinary (hexbinary)
func (s *TSDescriptorImpl) SetHex(v Hexbinary) TSDescriptor {
	if s == nil {
		return nil
	}
	s.HexValue = v
	return s
}

// Identifier of the descriptor.
func (s TSDescriptorImpl) Tag() int {
	return s.TagValue
}

// Identifier of the descriptor.
func (s *TSDescriptorImpl) SetTag(v int) TSDescriptor {
	if s == nil {
		return nil
	}
	s.TagValue = v
	return s
}

// NewTSEitIntervals creates a new TSEitIntervals instance
func NewTSEitIntervals() TSEitIntervals {
	return &TSEitIntervalsImpl{}
}

// Period for the actual transponder.
func (s TSEitIntervalsImpl) Actual() *int {
	return s.ActualValue
}

// Period for the actual transponder.
func (s *TSEitIntervalsImpl) SetActual(v int) TSEitIntervals {
	if s == nil {
		return nil
	}
	s.ActualValue = &v
	return s
}

// Period for the other transponder.
func (s TSEitIntervalsImpl) Other() *int {
	return s.OtherValue
}

// Period for the other transponder.
func (s *TSEitIntervalsImpl) SetOther(v int) TSEitIntervals {
	if s == nil {
		return nil
	}
	s.OtherValue = &v
	return s
}

// NewTSTimeouts creates a new TSTimeouts instance
func NewTSTimeouts() TSTimeouts {
	return &TSTimeoutsImpl{}
}

// The timeout value.
func (s TSTimeoutsImpl) MediaInfo() *int {
	return s.MediaInfoValue
}

// The timeout value.
func (s *TSTimeoutsImpl) SetMediaInfo(v int) TSTimeouts {
	if s == nil {
		return nil
	}
	s.MediaInfoValue = &v
	return s
}

// The type of the program.
func (s TSTimeoutsImpl) ServiceType() *int {
	return s.ServiceTypeValue
}

// The type of the program.
func (s *TSTimeoutsImpl) SetServiceType(v int) TSTimeouts {
	if s == nil {
		return nil
	}
	s.ServiceTypeValue = &v
	return s
}

// NewTSVersions creates a new TSVersions instance
func NewTSVersions() TSVersions {
	return &TSVersionsImpl{}
}

// The version of CAT table.
func (s TSVersionsImpl) Cat() *int {
	return s.CatValue
}

// The version of CAT table.
func (s *TSVersionsImpl) SetCat(v int) TSVersions {
	if s == nil {
		return nil
	}
	s.CatValue = &v
	return s
}

// The version of NIT table.
func (s TSVersionsImpl) Nit() *int {
	return s.NitValue
}

// The version of NIT table.
func (s *TSVersionsImpl) SetNit(v int) TSVersions {
	if s == nil {
		return nil
	}
	s.NitValue = &v
	return s
}

// The version of PAT table.
func (s TSVersionsImpl) Pat() *int {
	return s.PatValue
}

// The version of PAT table.
func (s *TSVersionsImpl) SetPat(v int) TSVersions {
	if s == nil {
		return nil
	}
	s.PatValue = &v
	return s
}

// The version of PMT table.
func (s TSVersionsImpl) Pmt() *int {
	return s.PmtValue
}

// The version of PMT table.
func (s *TSVersionsImpl) SetPmt(v int) TSVersions {
	if s == nil {
		return nil
	}
	s.PmtValue = &v
	return s
}

// Global version for all PSI tables.
func (s TSVersionsImpl) Psi() *int {
	return s.PsiValue
}

// Global version for all PSI tables.
func (s *TSVersionsImpl) SetPsi(v int) TSVersions {
	if s == nil {
		return nil
	}
	s.PsiValue = &v
	return s
}

// The version of SDT table.
func (s TSVersionsImpl) Sdt() *int {
	return s.SdtValue
}

// The version of SDT table.
func (s *TSVersionsImpl) SetSdt(v int) TSVersions {
	if s == nil {
		return nil
	}
	s.SdtValue = &v
	return s
}

// NewTemplateConfig creates a new TemplateConfig instance
func NewTemplateConfig() TemplateConfig {
	return &TemplateConfigImpl{}
}

// Whether a stream is disabled. Disabled streams are inactive and do not run.
// Displayed only with the API calls.
// Example: false
func (s TemplateConfigImpl) Disabled() *bool {
	return s.DisabledValue
}

// Whether a stream is disabled. Disabled streams are inactive and do not run.
// Displayed only with the API calls.
// Example: false
func (s *TemplateConfigImpl) SetDisabled(v bool) TemplateConfig {
	if s == nil {
		return nil
	}
	s.DisabledValue = &v
	return s
}

// DVR configuraton.
func (s TemplateConfigImpl) Dvr() StreamDvrSpec {
	return s.DvrValue
}

// DVR configuraton.
func (s *TemplateConfigImpl) SetDvr(v StreamDvrSpec) TemplateConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*StreamDvrSpecImpl); ok {
		s.DvrValue = impl
	}
	return s
}

// List of stream inputs.
// ***Important:*** A stream without any inputs can receive video frames **only** if backup file is specified.
func (s TemplateConfigImpl) Inputs() []StreamInput {
	return s.InputsValue
}

// List of stream inputs.
// ***Important:*** A stream without any inputs can receive video frames **only** if backup file is specified.
func (s *TemplateConfigImpl) SetInputs(v []StreamInput) TemplateConfig {
	if s == nil {
		return nil
	}
	s.InputsValue = v
	return s
}

// Stream labels in key value format.
// Key is a string in unix_name format (alphanumeric characters, underscores, hyphens and periods).
func (s TemplateConfigImpl) Labels() map[string]UnixName {
	return s.LabelsValue
}

// Stream labels in key value format.
// Key is a string in unix_name format (alphanumeric characters, underscores, hyphens and periods).
func (s *TemplateConfigImpl) SetLabels(v map[string]UnixName) TemplateConfig {
	if s == nil {
		return nil
	}
	s.LabelsValue = v
	return s
}

// A list of pushes. When a server initiates the connection and sends a stream
// to other server(s), it is called a `push`.
func (s TemplateConfigImpl) Pushes() []StreamPush {
	return s.PushesValue
}

// A list of pushes. When a server initiates the connection and sends a stream
// to other server(s), it is called a `push`.
func (s *TemplateConfigImpl) SetPushes(v []StreamPush) TemplateConfig {
	if s == nil {
		return nil
	}
	s.PushesValue = v
	return s
}

// Whether a stream is `static` or not.
// If set to `True` the server will try to keep this stream running even if
// there are no viewers or errors encountered.
// Streamer restarts *all* `static` streams even if any internal errors occur
// and the `static` streams crash.
// Example: true
func (s TemplateConfigImpl) Static() *bool {
	return s.StaticValue
}

// Whether a stream is `static` or not.
// If set to `True` the server will try to keep this stream running even if
// there are no viewers or errors encountered.
// Streamer restarts *all* `static` streams even if any internal errors occur
// and the `static` streams crash.
// Example: true
func (s *TemplateConfigImpl) SetStatic(v bool) TemplateConfig {
	if s == nil {
		return nil
	}
	s.StaticValue = &v
	return s
}

// Video analytics parameters.
func (s TemplateConfigImpl) Vision() VisionSpec {
	return s.VisionValue
}

// Video analytics parameters.
func (s *TemplateConfigImpl) SetVision(v VisionSpec) TemplateConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionSpecImpl); ok {
		s.VisionValue = impl
	}
	return s
}

// NewTemplateConfigSpecific creates a new TemplateConfigSpecific instance
func NewTemplateConfigSpecific() TemplateConfigSpecific {
	return &TemplateConfigSpecificImpl{}
}

// NewThumbnailsSpec creates a new ThumbnailsSpec instance
func NewThumbnailsSpec() ThumbnailsSpec {
	return &ThumbnailsSpecImpl{}
}

// Whether to generate thumbnails from the video stream.
func (s ThumbnailsSpecImpl) Enabled() any {
	return s.EnabledValue
}

// Whether to generate thumbnails from the video stream.
func (s *ThumbnailsSpecImpl) SetEnabled(v any) ThumbnailsSpec {
	if s == nil {
		return nil
	}
	s.EnabledValue = v
	return s
}

// NewTlsCertificate creates a new TlsCertificate instance
func NewTlsCertificate() TlsCertificate {
	return &TlsCertificateImpl{}
}

// Deprecated field. Will be deleted at 25.09
// Information about the CA certificate applied on the server.
func (s TlsCertificateImpl) Cacert() CertificateInfo {
	return s.CacertValue
}

// Deprecated field. Will be deleted at 25.09
// Information about the CA certificate applied on the server.
func (s *TlsCertificateImpl) SetCacert(v CertificateInfo) TlsCertificate {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*CertificateInfoImpl); ok {
		s.CacertValue = impl
	}
	return s
}

// Information about the server certificate.
func (s TlsCertificateImpl) Cert() CertificateInfo {
	return s.CertValue
}

// Information about the server certificate.
func (s *TlsCertificateImpl) SetCert(v CertificateInfo) TlsCertificate {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*CertificateInfoImpl); ok {
		s.CertValue = impl
	}
	return s
}

// Information about the fullchain certificate including leaf and CA certificates.
func (s TlsCertificateImpl) Fullchain() []CertificateInfo {
	if s.FullchainValue == nil {
		return nil
	}
	result := make([]CertificateInfo, len(s.FullchainValue))
	for i, item := range s.FullchainValue {
		result[i] = item
	}
	return result
}

// Information about the fullchain certificate including leaf and CA certificates.
func (s *TlsCertificateImpl) SetFullchain(v []CertificateInfo) TlsCertificate {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*CertificateInfoImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*CertificateInfoImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.FullchainValue = impl
	}
	return s
}

// Shows if the server private key matches the server certificate.
func (s TlsCertificateImpl) PrivateKeyMatchCertificate() *bool {
	return s.PrivateKeyMatchCertificateValue
}

// Shows if the server private key matches the server certificate.
func (s *TlsCertificateImpl) SetPrivateKeyMatchCertificate(v bool) TlsCertificate {
	if s == nil {
		return nil
	}
	s.PrivateKeyMatchCertificateValue = &v
	return s
}

// NewTrackInfo creates a new TrackInfo instance
func NewTrackInfo() TrackInfo {
	return &TrackInfoImpl{}
}

// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
// The higher FPS is, the smoother the video playback is.
// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
func (s TrackInfoImpl) AvgFPS() *float64 {
	return s.AvgFPSValue
}

// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
// The higher FPS is, the smoother the video playback is.
// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
func (s *TrackInfoImpl) SetAvgFPS(v float64) TrackInfo {
	if s == nil {
		return nil
	}
	s.AvgFPSValue = &v
	return s
}

// Average GOP size (expressed in number of frames) of the last 1000-2000 frames.
// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
// If this value is floating, this means that your transcoder is working in flexible GOP size mode and some players may have problems.
// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
// Example: 25
func (s TrackInfoImpl) AvgGop() *int {
	return s.AvgGopValue
}

// Average GOP size (expressed in number of frames) of the last 1000-2000 frames.
// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
// If this value is floating, this means that your transcoder is working in flexible GOP size mode and some players may have problems.
// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
// Example: 25
func (s *TrackInfoImpl) SetAvgGop(v int) TrackInfo {
	if s == nil {
		return nil
	}
	s.AvgGopValue = &v
	return s
}

// Bandwidth necessary to transfer this track.
// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
// Format: speed (speed)
// Example: 2600
func (s TrackInfoImpl) Bandwidth() *Speed {
	return s.BandwidthValue
}

// Bandwidth necessary to transfer this track.
// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
// Format: speed (speed)
// Example: 2600
func (s *TrackInfoImpl) SetBandwidth(v Speed) TrackInfo {
	if s == nil {
		return nil
	}
	s.BandwidthValue = &v
	return s
}

// Average number of B-frames in a GOP. B-frames contain links to keyframes and P-frames before and after themselves.
// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
// Example: 3
func (s TrackInfoImpl) Bframes() *int {
	return s.BframesValue
}

// Average number of B-frames in a GOP. B-frames contain links to keyframes and P-frames before and after themselves.
// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
// Example: 3
func (s *TrackInfoImpl) SetBframes(v int) TrackInfo {
	if s == nil {
		return nil
	}
	s.BframesValue = &v
	return s
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s TrackInfoImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s *TrackInfoImpl) SetBitrate(v Speed) TrackInfo {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// The number of audio channels.
// Example: 2
func (s TrackInfoImpl) Channels() *int {
	return s.ChannelsValue
}

// The number of audio channels.
// Example: 2
func (s *TrackInfoImpl) SetChannels(v int) TrackInfo {
	if s == nil {
		return nil
	}
	s.ChannelsValue = &v
	return s
}

// Parameters of closed captions.
func (s TrackInfoImpl) ClosedCaptions() []ClosedCaptions {
	if s.ClosedCaptionsValue == nil {
		return nil
	}
	result := make([]ClosedCaptions, len(s.ClosedCaptionsValue))
	for i, item := range s.ClosedCaptionsValue {
		result[i] = item
	}
	return result
}

// Parameters of closed captions.
func (s *TrackInfoImpl) SetClosedCaptions(v []ClosedCaptions) TrackInfo {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*ClosedCaptionsImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*ClosedCaptionsImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.ClosedCaptionsValue = impl
	}
	return s
}

// Codec of the track. Different codecs do **not** get the same track.
// Example: h264
func (s TrackInfoImpl) Codec() *FrameCodec {
	return s.CodecValue
}

// Codec of the track. Different codecs do **not** get the same track.
// Example: h264
func (s *TrackInfoImpl) SetCodec(v FrameCodec) TrackInfo {
	if s == nil {
		return nil
	}
	s.CodecValue = &v
	return s
}

// Content of the track (audio, video, or text).
func (s TrackInfoImpl) Content() FrameContent {
	return s.ContentValue
}

// Content of the track (audio, video, or text).
func (s *TrackInfoImpl) SetContent(v FrameContent) TrackInfo {
	if s == nil {
		return nil
	}
	s.ContentValue = v
	return s
}

// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
// Higher frame rates capture more images per second, which makes for smoother video.
// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
func (s TrackInfoImpl) FPS() *float64 {
	return s.FPSValue
}

// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
// Higher frame rates capture more images per second, which makes for smoother video.
// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
func (s *TrackInfoImpl) SetFPS(v float64) TrackInfo {
	if s == nil {
		return nil
	}
	s.FPSValue = &v
	return s
}

// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
// However, sometimes (when the connection is broken) video breakups are possible.
// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
// This situation is considered as a frame gap and is handled differently across different protocols.
// Format: ticks (ticks)
func (s TrackInfoImpl) FrameDuration() *Ticks {
	return s.FrameDurationValue
}

// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
// However, sometimes (when the connection is broken) video breakups are possible.
// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
// This situation is considered as a frame gap and is handled differently across different protocols.
// Format: ticks (ticks)
func (s *TrackInfoImpl) SetFrameDuration(v Ticks) TrackInfo {
	if s == nil {
		return nil
	}
	s.FrameDurationValue = &v
	return s
}

// The number of frames in a group of pictures (GOP).
// The encoder will create all GOPs of an exactly identical size - as specified in this option.
// A bigger GOP can be good for video compression but it can result in big zap-time (the duration of time between changing a channel and displaying a new channel.)
func (s TrackInfoImpl) GopSize() *int {
	return s.GopSizeValue
}

// The number of frames in a group of pictures (GOP).
// The encoder will create all GOPs of an exactly identical size - as specified in this option.
// A bigger GOP can be good for video compression but it can result in big zap-time (the duration of time between changing a channel and displaying a new channel.)
func (s *TrackInfoImpl) SetGopSize(v int) TrackInfo {
	if s == nil {
		return nil
	}
	s.GopSizeValue = &v
	return s
}

// The picture height in pixels on the display where it will be played by a player.
// If you need to insert a web-player into a web page, use this value for choosing the player size.
// Format: pixels (pixels)
func (s TrackInfoImpl) Height() *Pixels {
	return s.HeightValue
}

// The picture height in pixels on the display where it will be played by a player.
// If you need to insert a web-player into a web page, use this value for choosing the player size.
// Format: pixels (pixels)
func (s *TrackInfoImpl) SetHeight(v Pixels) TrackInfo {
	if s == nil {
		return nil
	}
	s.HeightValue = &v
	return s
}

// Indicates if progressive scanning method is used for all frames of the track
func (s TrackInfoImpl) IsProgressive() *bool {
	return s.IsProgressiveValue
}

// Indicates if progressive scanning method is used for all frames of the track
func (s *TrackInfoImpl) SetIsProgressive(v bool) TrackInfo {
	if s == nil {
		return nil
	}
	s.IsProgressiveValue = &v
	return s
}

// Language value of the track, if applicable.
// Example: eng
func (s TrackInfoImpl) Language() *string {
	return s.LanguageValue
}

// Language value of the track, if applicable.
// Example: eng
func (s *TrackInfoImpl) SetLanguage(v string) TrackInfo {
	if s == nil {
		return nil
	}
	s.LanguageValue = &v
	return s
}

// Last GOP size (expressed in number of frames).
// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
// If this value is floating, this means that your transcoder is working in a flexible GOP size mode and some players may have problems.
// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
// Example: 28
func (s TrackInfoImpl) LastGop() *int {
	return s.LastGopValue
}

// Last GOP size (expressed in number of frames).
// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
// If this value is floating, this means that your transcoder is working in a flexible GOP size mode and some players may have problems.
// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
// Example: 28
func (s *TrackInfoImpl) SetLastGop(v int) TrackInfo {
	if s == nil {
		return nil
	}
	s.LastGopValue = &v
	return s
}

// The size of the length field for H264 bitstream without start codes.
func (s TrackInfoImpl) LengthSize() *int {
	return s.LengthSizeValue
}

// The size of the length field for H264 bitstream without start codes.
func (s *TrackInfoImpl) SetLengthSize(v int) TrackInfo {
	if s == nil {
		return nil
	}
	s.LengthSizeValue = &v
	return s
}

// A set of constraints that indicate a degree of required decoder performance.
// This parameter is used for compatibility with old devices.
func (s TrackInfoImpl) Level() *string {
	return s.LevelValue
}

// A set of constraints that indicate a degree of required decoder performance.
// This parameter is used for compatibility with old devices.
func (s *TrackInfoImpl) SetLevel(v string) TrackInfo {
	if s == nil {
		return nil
	}
	s.LevelValue = &v
	return s
}

// The number of I-frames to be used for encoding.
func (s TrackInfoImpl) NumRefsFrames() *int {
	return s.NumRefsFramesValue
}

// The number of I-frames to be used for encoding.
func (s *TrackInfoImpl) SetNumRefsFrames(v int) TrackInfo {
	if s == nil {
		return nil
	}
	s.NumRefsFramesValue = &v
	return s
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s TrackInfoImpl) Pid() *int {
	return s.PidValue
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s *TrackInfoImpl) SetPid(v int) TrackInfo {
	if s == nil {
		return nil
	}
	s.PidValue = &v
	return s
}

// The color model of the video.
func (s TrackInfoImpl) PixFmt() *FrameVideoPixFmt {
	return s.PixFmtValue
}

// The color model of the video.
func (s *TrackInfoImpl) SetPixFmt(v FrameVideoPixFmt) TrackInfo {
	if s == nil {
		return nil
	}
	s.PixFmtValue = &v
	return s
}

// The picture width in pixels of the original video before transcoding.
// Format: pixels (pixels)
func (s TrackInfoImpl) PixelHeight() *Pixels {
	return s.PixelHeightValue
}

// The picture width in pixels of the original video before transcoding.
// Format: pixels (pixels)
func (s *TrackInfoImpl) SetPixelHeight(v Pixels) TrackInfo {
	if s == nil {
		return nil
	}
	s.PixelHeightValue = &v
	return s
}

// The picture width in pixels of the original video before transcoding.
// Format: pixels (pixels)
func (s TrackInfoImpl) PixelWidth() *Pixels {
	return s.PixelWidthValue
}

// The picture width in pixels of the original video before transcoding.
// Format: pixels (pixels)
func (s *TrackInfoImpl) SetPixelWidth(v Pixels) TrackInfo {
	if s == nil {
		return nil
	}
	s.PixelWidthValue = &v
	return s
}

// A specific codec-dependent profile of the output video.
// The profile allows to assume if the track can be played on a particular device.
func (s TrackInfoImpl) Profile() *string {
	return s.ProfileValue
}

// A specific codec-dependent profile of the output video.
// The profile allows to assume if the track can be played on a particular device.
func (s *TrackInfoImpl) SetProfile(v string) TrackInfo {
	if s == nil {
		return nil
	}
	s.ProfileValue = &v
	return s
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// Example: 8000
func (s TrackInfoImpl) SampleRate() *int {
	return s.SampleRateValue
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// Example: 8000
func (s *TrackInfoImpl) SetSampleRate(v int) TrackInfo {
	if s == nil {
		return nil
	}
	s.SampleRateValue = &v
	return s
}

// The second number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
// SAR is used for creating non-anamorphic video from anamorphic video.
func (s TrackInfoImpl) SarHeight() *int {
	return s.SarHeightValue
}

// The second number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
// SAR is used for creating non-anamorphic video from anamorphic video.
func (s *TrackInfoImpl) SetSarHeight(v int) TrackInfo {
	if s == nil {
		return nil
	}
	s.SarHeightValue = &v
	return s
}

// The first number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
// SAR is used for creating non-anamorphic video from anamorphic video.
func (s TrackInfoImpl) SarWidth() *int {
	return s.SarWidthValue
}

// The first number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
// SAR is used for creating non-anamorphic video from anamorphic video.
func (s *TrackInfoImpl) SetSarWidth(v int) TrackInfo {
	if s == nil {
		return nil
	}
	s.SarWidthValue = &v
	return s
}

// Human-readable localized title of the track.
// Example: Video1
func (s TrackInfoImpl) Title() *string {
	return s.TitleValue
}

// Human-readable localized title of the track.
// Example: Video1
func (s *TrackInfoImpl) SetTitle(v string) TrackInfo {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// Track identifier assigned by Flussonic.
// Example: v1
func (s TrackInfoImpl) TrackID() any {
	return s.TrackIDValue
}

// Track identifier assigned by Flussonic.
// Example: v1
func (s *TrackInfoImpl) SetTrackID(v any) TrackInfo {
	if s == nil {
		return nil
	}
	s.TrackIDValue = v
	return s
}

// The picture width in pixels on the display where it will be played by a player.
// If you need to insert a web-player into a web page, use this value for choosing the player size.
// Format: pixels (pixels)
func (s TrackInfoImpl) Width() *Pixels {
	return s.WidthValue
}

// The picture width in pixels on the display where it will be played by a player.
// If you need to insert a web-player into a web page, use this value for choosing the player size.
// Format: pixels (pixels)
func (s *TrackInfoImpl) SetWidth(v Pixels) TrackInfo {
	if s == nil {
		return nil
	}
	s.WidthValue = &v
	return s
}

// NewTrackInfoApplication creates a new TrackInfoApplication instance
func NewTrackInfoApplication() TrackInfoApplication {
	return &TrackInfoApplicationImpl{}
}

// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
// The higher FPS is, the smoother the video playback is.
// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
func (s TrackInfoApplicationImpl) AvgFPS() *float64 {
	return s.AvgFPSValue
}

// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
// The higher FPS is, the smoother the video playback is.
// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
func (s *TrackInfoApplicationImpl) SetAvgFPS(v float64) TrackInfoApplication {
	if s == nil {
		return nil
	}
	s.AvgFPSValue = &v
	return s
}

// Bandwidth necessary to transfer this track.
// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
// Format: speed (speed)
// Example: 2600
func (s TrackInfoApplicationImpl) Bandwidth() *Speed {
	return s.BandwidthValue
}

// Bandwidth necessary to transfer this track.
// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
// Format: speed (speed)
// Example: 2600
func (s *TrackInfoApplicationImpl) SetBandwidth(v Speed) TrackInfoApplication {
	if s == nil {
		return nil
	}
	s.BandwidthValue = &v
	return s
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s TrackInfoApplicationImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s *TrackInfoApplicationImpl) SetBitrate(v Speed) TrackInfoApplication {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// Codec of the track. Different codecs do **not** get the same track.
// Example: h264
func (s TrackInfoApplicationImpl) Codec() *FrameCodec {
	return s.CodecValue
}

// Codec of the track. Different codecs do **not** get the same track.
// Example: h264
func (s *TrackInfoApplicationImpl) SetCodec(v FrameCodec) TrackInfoApplication {
	if s == nil {
		return nil
	}
	s.CodecValue = &v
	return s
}

// Content of the track (audio, video, or text).
func (s TrackInfoApplicationImpl) Content() FrameContent {
	return s.ContentValue
}

// Content of the track (audio, video, or text).
func (s *TrackInfoApplicationImpl) SetContent(v FrameContent) TrackInfoApplication {
	if s == nil {
		return nil
	}
	s.ContentValue = v
	return s
}

// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
// However, sometimes (when the connection is broken) video breakups are possible.
// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
// This situation is considered as a frame gap and is handled differently across different protocols.
// Format: ticks (ticks)
func (s TrackInfoApplicationImpl) FrameDuration() *Ticks {
	return s.FrameDurationValue
}

// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
// However, sometimes (when the connection is broken) video breakups are possible.
// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
// This situation is considered as a frame gap and is handled differently across different protocols.
// Format: ticks (ticks)
func (s *TrackInfoApplicationImpl) SetFrameDuration(v Ticks) TrackInfoApplication {
	if s == nil {
		return nil
	}
	s.FrameDurationValue = &v
	return s
}

// Language value of the track, if applicable.
// Example: eng
func (s TrackInfoApplicationImpl) Language() *string {
	return s.LanguageValue
}

// Language value of the track, if applicable.
// Example: eng
func (s *TrackInfoApplicationImpl) SetLanguage(v string) TrackInfoApplication {
	if s == nil {
		return nil
	}
	s.LanguageValue = &v
	return s
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s TrackInfoApplicationImpl) Pid() *int {
	return s.PidValue
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s *TrackInfoApplicationImpl) SetPid(v int) TrackInfoApplication {
	if s == nil {
		return nil
	}
	s.PidValue = &v
	return s
}

// Human-readable localized title of the track.
// Example: Video1
func (s TrackInfoApplicationImpl) Title() *string {
	return s.TitleValue
}

// Human-readable localized title of the track.
// Example: Video1
func (s *TrackInfoApplicationImpl) SetTitle(v string) TrackInfoApplication {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// Track identifier assigned by Flussonic.
// Example: v1
func (s TrackInfoApplicationImpl) TrackID() any {
	return s.TrackIDValue
}

// Track identifier assigned by Flussonic.
// Example: v1
func (s *TrackInfoApplicationImpl) SetTrackID(v any) TrackInfoApplication {
	if s == nil {
		return nil
	}
	s.TrackIDValue = v
	return s
}

// NewTrackInfoApplicationSpecific creates a new TrackInfoApplicationSpecific instance
func NewTrackInfoApplicationSpecific() TrackInfoApplicationSpecific {
	return &TrackInfoApplicationSpecificImpl{}
}

// Language value of the track, if applicable.
// Example: eng
func (s TrackInfoApplicationSpecificImpl) Language() *string {
	return s.LanguageValue
}

// Language value of the track, if applicable.
// Example: eng
func (s *TrackInfoApplicationSpecificImpl) SetLanguage(v string) TrackInfoApplicationSpecific {
	if s == nil {
		return nil
	}
	s.LanguageValue = &v
	return s
}

// NewTrackInfoAudio creates a new TrackInfoAudio instance
func NewTrackInfoAudio() TrackInfoAudio {
	return &TrackInfoAudioImpl{}
}

// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
// The higher FPS is, the smoother the video playback is.
// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
func (s TrackInfoAudioImpl) AvgFPS() *float64 {
	return s.AvgFPSValue
}

// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
// The higher FPS is, the smoother the video playback is.
// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
func (s *TrackInfoAudioImpl) SetAvgFPS(v float64) TrackInfoAudio {
	if s == nil {
		return nil
	}
	s.AvgFPSValue = &v
	return s
}

// Bandwidth necessary to transfer this track.
// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
// Format: speed (speed)
// Example: 2600
func (s TrackInfoAudioImpl) Bandwidth() *Speed {
	return s.BandwidthValue
}

// Bandwidth necessary to transfer this track.
// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
// Format: speed (speed)
// Example: 2600
func (s *TrackInfoAudioImpl) SetBandwidth(v Speed) TrackInfoAudio {
	if s == nil {
		return nil
	}
	s.BandwidthValue = &v
	return s
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s TrackInfoAudioImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s *TrackInfoAudioImpl) SetBitrate(v Speed) TrackInfoAudio {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// The number of audio channels.
// Example: 2
func (s TrackInfoAudioImpl) Channels() *int {
	return s.ChannelsValue
}

// The number of audio channels.
// Example: 2
func (s *TrackInfoAudioImpl) SetChannels(v int) TrackInfoAudio {
	if s == nil {
		return nil
	}
	s.ChannelsValue = &v
	return s
}

// Codec of the track. Different codecs do **not** get the same track.
// Example: h264
func (s TrackInfoAudioImpl) Codec() *FrameCodec {
	return s.CodecValue
}

// Codec of the track. Different codecs do **not** get the same track.
// Example: h264
func (s *TrackInfoAudioImpl) SetCodec(v FrameCodec) TrackInfoAudio {
	if s == nil {
		return nil
	}
	s.CodecValue = &v
	return s
}

// Content of the track (audio, video, or text).
func (s TrackInfoAudioImpl) Content() FrameContent {
	return s.ContentValue
}

// Content of the track (audio, video, or text).
func (s *TrackInfoAudioImpl) SetContent(v FrameContent) TrackInfoAudio {
	if s == nil {
		return nil
	}
	s.ContentValue = v
	return s
}

// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
// However, sometimes (when the connection is broken) video breakups are possible.
// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
// This situation is considered as a frame gap and is handled differently across different protocols.
// Format: ticks (ticks)
func (s TrackInfoAudioImpl) FrameDuration() *Ticks {
	return s.FrameDurationValue
}

// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
// However, sometimes (when the connection is broken) video breakups are possible.
// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
// This situation is considered as a frame gap and is handled differently across different protocols.
// Format: ticks (ticks)
func (s *TrackInfoAudioImpl) SetFrameDuration(v Ticks) TrackInfoAudio {
	if s == nil {
		return nil
	}
	s.FrameDurationValue = &v
	return s
}

// Language value of the track, if applicable.
// Example: eng
func (s TrackInfoAudioImpl) Language() *string {
	return s.LanguageValue
}

// Language value of the track, if applicable.
// Example: eng
func (s *TrackInfoAudioImpl) SetLanguage(v string) TrackInfoAudio {
	if s == nil {
		return nil
	}
	s.LanguageValue = &v
	return s
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s TrackInfoAudioImpl) Pid() *int {
	return s.PidValue
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s *TrackInfoAudioImpl) SetPid(v int) TrackInfoAudio {
	if s == nil {
		return nil
	}
	s.PidValue = &v
	return s
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// Example: 8000
func (s TrackInfoAudioImpl) SampleRate() *int {
	return s.SampleRateValue
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// Example: 8000
func (s *TrackInfoAudioImpl) SetSampleRate(v int) TrackInfoAudio {
	if s == nil {
		return nil
	}
	s.SampleRateValue = &v
	return s
}

// Human-readable localized title of the track.
// Example: Video1
func (s TrackInfoAudioImpl) Title() *string {
	return s.TitleValue
}

// Human-readable localized title of the track.
// Example: Video1
func (s *TrackInfoAudioImpl) SetTitle(v string) TrackInfoAudio {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// Track identifier assigned by Flussonic.
// Example: v1
func (s TrackInfoAudioImpl) TrackID() any {
	return s.TrackIDValue
}

// Track identifier assigned by Flussonic.
// Example: v1
func (s *TrackInfoAudioImpl) SetTrackID(v any) TrackInfoAudio {
	if s == nil {
		return nil
	}
	s.TrackIDValue = v
	return s
}

// NewTrackInfoAudioSpecific creates a new TrackInfoAudioSpecific instance
func NewTrackInfoAudioSpecific() TrackInfoAudioSpecific {
	return &TrackInfoAudioSpecificImpl{}
}

// The number of audio channels.
// Example: 2
func (s TrackInfoAudioSpecificImpl) Channels() *int {
	return s.ChannelsValue
}

// The number of audio channels.
// Example: 2
func (s *TrackInfoAudioSpecificImpl) SetChannels(v int) TrackInfoAudioSpecific {
	if s == nil {
		return nil
	}
	s.ChannelsValue = &v
	return s
}

// Language value of the track, if applicable.
// Example: eng
func (s TrackInfoAudioSpecificImpl) Language() *string {
	return s.LanguageValue
}

// Language value of the track, if applicable.
// Example: eng
func (s *TrackInfoAudioSpecificImpl) SetLanguage(v string) TrackInfoAudioSpecific {
	if s == nil {
		return nil
	}
	s.LanguageValue = &v
	return s
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// Example: 8000
func (s TrackInfoAudioSpecificImpl) SampleRate() *int {
	return s.SampleRateValue
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// Example: 8000
func (s *TrackInfoAudioSpecificImpl) SetSampleRate(v int) TrackInfoAudioSpecific {
	if s == nil {
		return nil
	}
	s.SampleRateValue = &v
	return s
}

// NewTrackInfoBase creates a new TrackInfoBase instance
func NewTrackInfoBase() TrackInfoBase {
	return &TrackInfoBaseImpl{}
}

// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
// The higher FPS is, the smoother the video playback is.
// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
func (s TrackInfoBaseImpl) AvgFPS() *float64 {
	return s.AvgFPSValue
}

// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
// The higher FPS is, the smoother the video playback is.
// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
func (s *TrackInfoBaseImpl) SetAvgFPS(v float64) TrackInfoBase {
	if s == nil {
		return nil
	}
	s.AvgFPSValue = &v
	return s
}

// Bandwidth necessary to transfer this track.
// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
// Format: speed (speed)
// Example: 2600
func (s TrackInfoBaseImpl) Bandwidth() *Speed {
	return s.BandwidthValue
}

// Bandwidth necessary to transfer this track.
// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
// Format: speed (speed)
// Example: 2600
func (s *TrackInfoBaseImpl) SetBandwidth(v Speed) TrackInfoBase {
	if s == nil {
		return nil
	}
	s.BandwidthValue = &v
	return s
}

// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
// However, sometimes (when the connection is broken) video breakups are possible.
// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
// This situation is considered as a frame gap and is handled differently across different protocols.
// Format: ticks (ticks)
func (s TrackInfoBaseImpl) FrameDuration() *Ticks {
	return s.FrameDurationValue
}

// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
// However, sometimes (when the connection is broken) video breakups are possible.
// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
// This situation is considered as a frame gap and is handled differently across different protocols.
// Format: ticks (ticks)
func (s *TrackInfoBaseImpl) SetFrameDuration(v Ticks) TrackInfoBase {
	if s == nil {
		return nil
	}
	s.FrameDurationValue = &v
	return s
}

// Track identifier assigned by Flussonic.
// Example: v1
func (s TrackInfoBaseImpl) TrackID() any {
	return s.TrackIDValue
}

// Track identifier assigned by Flussonic.
// Example: v1
func (s *TrackInfoBaseImpl) SetTrackID(v any) TrackInfoBase {
	if s == nil {
		return nil
	}
	s.TrackIDValue = v
	return s
}

// NewTrackInfoBaseConfigurable creates a new TrackInfoBaseConfigurable instance
func NewTrackInfoBaseConfigurable() TrackInfoBaseConfigurable {
	return &TrackInfoBaseConfigurableImpl{}
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s TrackInfoBaseConfigurableImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s *TrackInfoBaseConfigurableImpl) SetBitrate(v Speed) TrackInfoBaseConfigurable {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// Content of the track (audio, video, or text).
func (s TrackInfoBaseConfigurableImpl) Content() FrameContent {
	return s.ContentValue
}

// Content of the track (audio, video, or text).
func (s *TrackInfoBaseConfigurableImpl) SetContent(v FrameContent) TrackInfoBaseConfigurable {
	if s == nil {
		return nil
	}
	s.ContentValue = v
	return s
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s TrackInfoBaseConfigurableImpl) Pid() *int {
	return s.PidValue
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s *TrackInfoBaseConfigurableImpl) SetPid(v int) TrackInfoBaseConfigurable {
	if s == nil {
		return nil
	}
	s.PidValue = &v
	return s
}

// Human-readable localized title of the track.
// Example: Video1
func (s TrackInfoBaseConfigurableImpl) Title() *string {
	return s.TitleValue
}

// Human-readable localized title of the track.
// Example: Video1
func (s *TrackInfoBaseConfigurableImpl) SetTitle(v string) TrackInfoBaseConfigurable {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// NewTrackInfoMetadata creates a new TrackInfoMetadata instance
func NewTrackInfoMetadata() TrackInfoMetadata {
	return &TrackInfoMetadataImpl{}
}

// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
// The higher FPS is, the smoother the video playback is.
// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
func (s TrackInfoMetadataImpl) AvgFPS() *float64 {
	return s.AvgFPSValue
}

// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
// The higher FPS is, the smoother the video playback is.
// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
func (s *TrackInfoMetadataImpl) SetAvgFPS(v float64) TrackInfoMetadata {
	if s == nil {
		return nil
	}
	s.AvgFPSValue = &v
	return s
}

// Bandwidth necessary to transfer this track.
// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
// Format: speed (speed)
// Example: 2600
func (s TrackInfoMetadataImpl) Bandwidth() *Speed {
	return s.BandwidthValue
}

// Bandwidth necessary to transfer this track.
// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
// Format: speed (speed)
// Example: 2600
func (s *TrackInfoMetadataImpl) SetBandwidth(v Speed) TrackInfoMetadata {
	if s == nil {
		return nil
	}
	s.BandwidthValue = &v
	return s
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s TrackInfoMetadataImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s *TrackInfoMetadataImpl) SetBitrate(v Speed) TrackInfoMetadata {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// Codec of the track. Different codecs do **not** get the same track.
// Example: h264
func (s TrackInfoMetadataImpl) Codec() *FrameCodec {
	return s.CodecValue
}

// Codec of the track. Different codecs do **not** get the same track.
// Example: h264
func (s *TrackInfoMetadataImpl) SetCodec(v FrameCodec) TrackInfoMetadata {
	if s == nil {
		return nil
	}
	s.CodecValue = &v
	return s
}

// Content of the track (audio, video, or text).
func (s TrackInfoMetadataImpl) Content() FrameContent {
	return s.ContentValue
}

// Content of the track (audio, video, or text).
func (s *TrackInfoMetadataImpl) SetContent(v FrameContent) TrackInfoMetadata {
	if s == nil {
		return nil
	}
	s.ContentValue = v
	return s
}

// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
// However, sometimes (when the connection is broken) video breakups are possible.
// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
// This situation is considered as a frame gap and is handled differently across different protocols.
// Format: ticks (ticks)
func (s TrackInfoMetadataImpl) FrameDuration() *Ticks {
	return s.FrameDurationValue
}

// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
// However, sometimes (when the connection is broken) video breakups are possible.
// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
// This situation is considered as a frame gap and is handled differently across different protocols.
// Format: ticks (ticks)
func (s *TrackInfoMetadataImpl) SetFrameDuration(v Ticks) TrackInfoMetadata {
	if s == nil {
		return nil
	}
	s.FrameDurationValue = &v
	return s
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s TrackInfoMetadataImpl) Pid() *int {
	return s.PidValue
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s *TrackInfoMetadataImpl) SetPid(v int) TrackInfoMetadata {
	if s == nil {
		return nil
	}
	s.PidValue = &v
	return s
}

// Human-readable localized title of the track.
// Example: Video1
func (s TrackInfoMetadataImpl) Title() *string {
	return s.TitleValue
}

// Human-readable localized title of the track.
// Example: Video1
func (s *TrackInfoMetadataImpl) SetTitle(v string) TrackInfoMetadata {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// Track identifier assigned by Flussonic.
// Example: v1
func (s TrackInfoMetadataImpl) TrackID() any {
	return s.TrackIDValue
}

// Track identifier assigned by Flussonic.
// Example: v1
func (s *TrackInfoMetadataImpl) SetTrackID(v any) TrackInfoMetadata {
	if s == nil {
		return nil
	}
	s.TrackIDValue = v
	return s
}

// NewTrackInfoText creates a new TrackInfoText instance
func NewTrackInfoText() TrackInfoText {
	return &TrackInfoTextImpl{}
}

// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
// The higher FPS is, the smoother the video playback is.
// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
func (s TrackInfoTextImpl) AvgFPS() *float64 {
	return s.AvgFPSValue
}

// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
// The higher FPS is, the smoother the video playback is.
// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
func (s *TrackInfoTextImpl) SetAvgFPS(v float64) TrackInfoText {
	if s == nil {
		return nil
	}
	s.AvgFPSValue = &v
	return s
}

// Bandwidth necessary to transfer this track.
// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
// Format: speed (speed)
// Example: 2600
func (s TrackInfoTextImpl) Bandwidth() *Speed {
	return s.BandwidthValue
}

// Bandwidth necessary to transfer this track.
// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
// Format: speed (speed)
// Example: 2600
func (s *TrackInfoTextImpl) SetBandwidth(v Speed) TrackInfoText {
	if s == nil {
		return nil
	}
	s.BandwidthValue = &v
	return s
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s TrackInfoTextImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s *TrackInfoTextImpl) SetBitrate(v Speed) TrackInfoText {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// Codec of the track. Different codecs do **not** get the same track.
// Example: h264
func (s TrackInfoTextImpl) Codec() *FrameCodec {
	return s.CodecValue
}

// Codec of the track. Different codecs do **not** get the same track.
// Example: h264
func (s *TrackInfoTextImpl) SetCodec(v FrameCodec) TrackInfoText {
	if s == nil {
		return nil
	}
	s.CodecValue = &v
	return s
}

// Content of the track (audio, video, or text).
func (s TrackInfoTextImpl) Content() FrameContent {
	return s.ContentValue
}

// Content of the track (audio, video, or text).
func (s *TrackInfoTextImpl) SetContent(v FrameContent) TrackInfoText {
	if s == nil {
		return nil
	}
	s.ContentValue = v
	return s
}

// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
// However, sometimes (when the connection is broken) video breakups are possible.
// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
// This situation is considered as a frame gap and is handled differently across different protocols.
// Format: ticks (ticks)
func (s TrackInfoTextImpl) FrameDuration() *Ticks {
	return s.FrameDurationValue
}

// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
// However, sometimes (when the connection is broken) video breakups are possible.
// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
// This situation is considered as a frame gap and is handled differently across different protocols.
// Format: ticks (ticks)
func (s *TrackInfoTextImpl) SetFrameDuration(v Ticks) TrackInfoText {
	if s == nil {
		return nil
	}
	s.FrameDurationValue = &v
	return s
}

// Language value of the track, if applicable.
// Example: eng
func (s TrackInfoTextImpl) Language() *string {
	return s.LanguageValue
}

// Language value of the track, if applicable.
// Example: eng
func (s *TrackInfoTextImpl) SetLanguage(v string) TrackInfoText {
	if s == nil {
		return nil
	}
	s.LanguageValue = &v
	return s
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s TrackInfoTextImpl) Pid() *int {
	return s.PidValue
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s *TrackInfoTextImpl) SetPid(v int) TrackInfoText {
	if s == nil {
		return nil
	}
	s.PidValue = &v
	return s
}

// Human-readable localized title of the track.
// Example: Video1
func (s TrackInfoTextImpl) Title() *string {
	return s.TitleValue
}

// Human-readable localized title of the track.
// Example: Video1
func (s *TrackInfoTextImpl) SetTitle(v string) TrackInfoText {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// Track identifier assigned by Flussonic.
// Example: v1
func (s TrackInfoTextImpl) TrackID() any {
	return s.TrackIDValue
}

// Track identifier assigned by Flussonic.
// Example: v1
func (s *TrackInfoTextImpl) SetTrackID(v any) TrackInfoText {
	if s == nil {
		return nil
	}
	s.TrackIDValue = v
	return s
}

// NewTrackInfoTextSpecific creates a new TrackInfoTextSpecific instance
func NewTrackInfoTextSpecific() TrackInfoTextSpecific {
	return &TrackInfoTextSpecificImpl{}
}

// Language value of the track, if applicable.
// Example: eng
func (s TrackInfoTextSpecificImpl) Language() *string {
	return s.LanguageValue
}

// Language value of the track, if applicable.
// Example: eng
func (s *TrackInfoTextSpecificImpl) SetLanguage(v string) TrackInfoTextSpecific {
	if s == nil {
		return nil
	}
	s.LanguageValue = &v
	return s
}

// NewTrackInfoVideo creates a new TrackInfoVideo instance
func NewTrackInfoVideo() TrackInfoVideo {
	return &TrackInfoVideoImpl{}
}

// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
// The higher FPS is, the smoother the video playback is.
// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
func (s TrackInfoVideoImpl) AvgFPS() *float64 {
	return s.AvgFPSValue
}

// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
// The higher FPS is, the smoother the video playback is.
// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
func (s *TrackInfoVideoImpl) SetAvgFPS(v float64) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.AvgFPSValue = &v
	return s
}

// Average GOP size (expressed in number of frames) of the last 1000-2000 frames.
// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
// If this value is floating, this means that your transcoder is working in flexible GOP size mode and some players may have problems.
// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
// Example: 25
func (s TrackInfoVideoImpl) AvgGop() *int {
	return s.AvgGopValue
}

// Average GOP size (expressed in number of frames) of the last 1000-2000 frames.
// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
// If this value is floating, this means that your transcoder is working in flexible GOP size mode and some players may have problems.
// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
// Example: 25
func (s *TrackInfoVideoImpl) SetAvgGop(v int) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.AvgGopValue = &v
	return s
}

// Bandwidth necessary to transfer this track.
// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
// Format: speed (speed)
// Example: 2600
func (s TrackInfoVideoImpl) Bandwidth() *Speed {
	return s.BandwidthValue
}

// Bandwidth necessary to transfer this track.
// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
// Format: speed (speed)
// Example: 2600
func (s *TrackInfoVideoImpl) SetBandwidth(v Speed) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.BandwidthValue = &v
	return s
}

// Average number of B-frames in a GOP. B-frames contain links to keyframes and P-frames before and after themselves.
// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
// Example: 3
func (s TrackInfoVideoImpl) Bframes() *int {
	return s.BframesValue
}

// Average number of B-frames in a GOP. B-frames contain links to keyframes and P-frames before and after themselves.
// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
// Example: 3
func (s *TrackInfoVideoImpl) SetBframes(v int) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.BframesValue = &v
	return s
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s TrackInfoVideoImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s *TrackInfoVideoImpl) SetBitrate(v Speed) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// Parameters of closed captions.
func (s TrackInfoVideoImpl) ClosedCaptions() []ClosedCaptions {
	if s.ClosedCaptionsValue == nil {
		return nil
	}
	result := make([]ClosedCaptions, len(s.ClosedCaptionsValue))
	for i, item := range s.ClosedCaptionsValue {
		result[i] = item
	}
	return result
}

// Parameters of closed captions.
func (s *TrackInfoVideoImpl) SetClosedCaptions(v []ClosedCaptions) TrackInfoVideo {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*ClosedCaptionsImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*ClosedCaptionsImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.ClosedCaptionsValue = impl
	}
	return s
}

// Codec of the track. Different codecs do **not** get the same track.
// Example: h264
func (s TrackInfoVideoImpl) Codec() *FrameCodec {
	return s.CodecValue
}

// Codec of the track. Different codecs do **not** get the same track.
// Example: h264
func (s *TrackInfoVideoImpl) SetCodec(v FrameCodec) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.CodecValue = &v
	return s
}

// Content of the track (audio, video, or text).
func (s TrackInfoVideoImpl) Content() FrameContent {
	return s.ContentValue
}

// Content of the track (audio, video, or text).
func (s *TrackInfoVideoImpl) SetContent(v FrameContent) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.ContentValue = v
	return s
}

// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
// Higher frame rates capture more images per second, which makes for smoother video.
// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
func (s TrackInfoVideoImpl) FPS() *float64 {
	return s.FPSValue
}

// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
// Higher frame rates capture more images per second, which makes for smoother video.
// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
func (s *TrackInfoVideoImpl) SetFPS(v float64) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.FPSValue = &v
	return s
}

// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
// However, sometimes (when the connection is broken) video breakups are possible.
// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
// This situation is considered as a frame gap and is handled differently across different protocols.
// Format: ticks (ticks)
func (s TrackInfoVideoImpl) FrameDuration() *Ticks {
	return s.FrameDurationValue
}

// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
// However, sometimes (when the connection is broken) video breakups are possible.
// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
// This situation is considered as a frame gap and is handled differently across different protocols.
// Format: ticks (ticks)
func (s *TrackInfoVideoImpl) SetFrameDuration(v Ticks) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.FrameDurationValue = &v
	return s
}

// The number of frames in a group of pictures (GOP).
// The encoder will create all GOPs of an exactly identical size - as specified in this option.
// A bigger GOP can be good for video compression but it can result in big zap-time (the duration of time between changing a channel and displaying a new channel.)
func (s TrackInfoVideoImpl) GopSize() *int {
	return s.GopSizeValue
}

// The number of frames in a group of pictures (GOP).
// The encoder will create all GOPs of an exactly identical size - as specified in this option.
// A bigger GOP can be good for video compression but it can result in big zap-time (the duration of time between changing a channel and displaying a new channel.)
func (s *TrackInfoVideoImpl) SetGopSize(v int) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.GopSizeValue = &v
	return s
}

// The picture height in pixels on the display where it will be played by a player.
// If you need to insert a web-player into a web page, use this value for choosing the player size.
// Format: pixels (pixels)
func (s TrackInfoVideoImpl) Height() *Pixels {
	return s.HeightValue
}

// The picture height in pixels on the display where it will be played by a player.
// If you need to insert a web-player into a web page, use this value for choosing the player size.
// Format: pixels (pixels)
func (s *TrackInfoVideoImpl) SetHeight(v Pixels) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.HeightValue = &v
	return s
}

// Indicates if progressive scanning method is used for all frames of the track
func (s TrackInfoVideoImpl) IsProgressive() *bool {
	return s.IsProgressiveValue
}

// Indicates if progressive scanning method is used for all frames of the track
func (s *TrackInfoVideoImpl) SetIsProgressive(v bool) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.IsProgressiveValue = &v
	return s
}

// Last GOP size (expressed in number of frames).
// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
// If this value is floating, this means that your transcoder is working in a flexible GOP size mode and some players may have problems.
// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
// Example: 28
func (s TrackInfoVideoImpl) LastGop() *int {
	return s.LastGopValue
}

// Last GOP size (expressed in number of frames).
// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
// If this value is floating, this means that your transcoder is working in a flexible GOP size mode and some players may have problems.
// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
// Example: 28
func (s *TrackInfoVideoImpl) SetLastGop(v int) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.LastGopValue = &v
	return s
}

// The size of the length field for H264 bitstream without start codes.
func (s TrackInfoVideoImpl) LengthSize() *int {
	return s.LengthSizeValue
}

// The size of the length field for H264 bitstream without start codes.
func (s *TrackInfoVideoImpl) SetLengthSize(v int) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.LengthSizeValue = &v
	return s
}

// A set of constraints that indicate a degree of required decoder performance.
// This parameter is used for compatibility with old devices.
func (s TrackInfoVideoImpl) Level() *string {
	return s.LevelValue
}

// A set of constraints that indicate a degree of required decoder performance.
// This parameter is used for compatibility with old devices.
func (s *TrackInfoVideoImpl) SetLevel(v string) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.LevelValue = &v
	return s
}

// The number of I-frames to be used for encoding.
func (s TrackInfoVideoImpl) NumRefsFrames() *int {
	return s.NumRefsFramesValue
}

// The number of I-frames to be used for encoding.
func (s *TrackInfoVideoImpl) SetNumRefsFrames(v int) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.NumRefsFramesValue = &v
	return s
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s TrackInfoVideoImpl) Pid() *int {
	return s.PidValue
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s *TrackInfoVideoImpl) SetPid(v int) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.PidValue = &v
	return s
}

// The color model of the video.
func (s TrackInfoVideoImpl) PixFmt() *FrameVideoPixFmt {
	return s.PixFmtValue
}

// The color model of the video.
func (s *TrackInfoVideoImpl) SetPixFmt(v FrameVideoPixFmt) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.PixFmtValue = &v
	return s
}

// The picture width in pixels of the original video before transcoding.
// Format: pixels (pixels)
func (s TrackInfoVideoImpl) PixelHeight() *Pixels {
	return s.PixelHeightValue
}

// The picture width in pixels of the original video before transcoding.
// Format: pixels (pixels)
func (s *TrackInfoVideoImpl) SetPixelHeight(v Pixels) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.PixelHeightValue = &v
	return s
}

// The picture width in pixels of the original video before transcoding.
// Format: pixels (pixels)
func (s TrackInfoVideoImpl) PixelWidth() *Pixels {
	return s.PixelWidthValue
}

// The picture width in pixels of the original video before transcoding.
// Format: pixels (pixels)
func (s *TrackInfoVideoImpl) SetPixelWidth(v Pixels) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.PixelWidthValue = &v
	return s
}

// A specific codec-dependent profile of the output video.
// The profile allows to assume if the track can be played on a particular device.
func (s TrackInfoVideoImpl) Profile() *string {
	return s.ProfileValue
}

// A specific codec-dependent profile of the output video.
// The profile allows to assume if the track can be played on a particular device.
func (s *TrackInfoVideoImpl) SetProfile(v string) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.ProfileValue = &v
	return s
}

// The second number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
// SAR is used for creating non-anamorphic video from anamorphic video.
func (s TrackInfoVideoImpl) SarHeight() *int {
	return s.SarHeightValue
}

// The second number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
// SAR is used for creating non-anamorphic video from anamorphic video.
func (s *TrackInfoVideoImpl) SetSarHeight(v int) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.SarHeightValue = &v
	return s
}

// The first number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
// SAR is used for creating non-anamorphic video from anamorphic video.
func (s TrackInfoVideoImpl) SarWidth() *int {
	return s.SarWidthValue
}

// The first number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
// SAR is used for creating non-anamorphic video from anamorphic video.
func (s *TrackInfoVideoImpl) SetSarWidth(v int) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.SarWidthValue = &v
	return s
}

// Human-readable localized title of the track.
// Example: Video1
func (s TrackInfoVideoImpl) Title() *string {
	return s.TitleValue
}

// Human-readable localized title of the track.
// Example: Video1
func (s *TrackInfoVideoImpl) SetTitle(v string) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// Track identifier assigned by Flussonic.
// Example: v1
func (s TrackInfoVideoImpl) TrackID() any {
	return s.TrackIDValue
}

// Track identifier assigned by Flussonic.
// Example: v1
func (s *TrackInfoVideoImpl) SetTrackID(v any) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.TrackIDValue = v
	return s
}

// The picture width in pixels on the display where it will be played by a player.
// If you need to insert a web-player into a web page, use this value for choosing the player size.
// Format: pixels (pixels)
func (s TrackInfoVideoImpl) Width() *Pixels {
	return s.WidthValue
}

// The picture width in pixels on the display where it will be played by a player.
// If you need to insert a web-player into a web page, use this value for choosing the player size.
// Format: pixels (pixels)
func (s *TrackInfoVideoImpl) SetWidth(v Pixels) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.WidthValue = &v
	return s
}

// NewTrackInfoVideoConfigurable creates a new TrackInfoVideoConfigurable instance
func NewTrackInfoVideoConfigurable() TrackInfoVideoConfigurable {
	return &TrackInfoVideoConfigurableImpl{}
}

// Average number of B-frames in a GOP. B-frames contain links to keyframes and P-frames before and after themselves.
// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
// Example: 3
func (s TrackInfoVideoConfigurableImpl) Bframes() *int {
	return s.BframesValue
}

// Average number of B-frames in a GOP. B-frames contain links to keyframes and P-frames before and after themselves.
// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
// Example: 3
func (s *TrackInfoVideoConfigurableImpl) SetBframes(v int) TrackInfoVideoConfigurable {
	if s == nil {
		return nil
	}
	s.BframesValue = &v
	return s
}

// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
// Higher frame rates capture more images per second, which makes for smoother video.
// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
func (s TrackInfoVideoConfigurableImpl) FPS() *float64 {
	return s.FPSValue
}

// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
// Higher frame rates capture more images per second, which makes for smoother video.
// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
func (s *TrackInfoVideoConfigurableImpl) SetFPS(v float64) TrackInfoVideoConfigurable {
	if s == nil {
		return nil
	}
	s.FPSValue = &v
	return s
}

// The number of frames in a group of pictures (GOP).
// The encoder will create all GOPs of an exactly identical size - as specified in this option.
// A bigger GOP can be good for video compression but it can result in big zap-time (the duration of time between changing a channel and displaying a new channel.)
func (s TrackInfoVideoConfigurableImpl) GopSize() *int {
	return s.GopSizeValue
}

// The number of frames in a group of pictures (GOP).
// The encoder will create all GOPs of an exactly identical size - as specified in this option.
// A bigger GOP can be good for video compression but it can result in big zap-time (the duration of time between changing a channel and displaying a new channel.)
func (s *TrackInfoVideoConfigurableImpl) SetGopSize(v int) TrackInfoVideoConfigurable {
	if s == nil {
		return nil
	}
	s.GopSizeValue = &v
	return s
}

// The picture height in pixels on the display where it will be played by a player.
// If you need to insert a web-player into a web page, use this value for choosing the player size.
// Format: pixels (pixels)
func (s TrackInfoVideoConfigurableImpl) Height() *Pixels {
	return s.HeightValue
}

// The picture height in pixels on the display where it will be played by a player.
// If you need to insert a web-player into a web page, use this value for choosing the player size.
// Format: pixels (pixels)
func (s *TrackInfoVideoConfigurableImpl) SetHeight(v Pixels) TrackInfoVideoConfigurable {
	if s == nil {
		return nil
	}
	s.HeightValue = &v
	return s
}

// A set of constraints that indicate a degree of required decoder performance.
// This parameter is used for compatibility with old devices.
func (s TrackInfoVideoConfigurableImpl) Level() *string {
	return s.LevelValue
}

// A set of constraints that indicate a degree of required decoder performance.
// This parameter is used for compatibility with old devices.
func (s *TrackInfoVideoConfigurableImpl) SetLevel(v string) TrackInfoVideoConfigurable {
	if s == nil {
		return nil
	}
	s.LevelValue = &v
	return s
}

// The number of I-frames to be used for encoding.
func (s TrackInfoVideoConfigurableImpl) NumRefsFrames() *int {
	return s.NumRefsFramesValue
}

// The number of I-frames to be used for encoding.
func (s *TrackInfoVideoConfigurableImpl) SetNumRefsFrames(v int) TrackInfoVideoConfigurable {
	if s == nil {
		return nil
	}
	s.NumRefsFramesValue = &v
	return s
}

// The color model of the video.
func (s TrackInfoVideoConfigurableImpl) PixFmt() *FrameVideoPixFmt {
	return s.PixFmtValue
}

// The color model of the video.
func (s *TrackInfoVideoConfigurableImpl) SetPixFmt(v FrameVideoPixFmt) TrackInfoVideoConfigurable {
	if s == nil {
		return nil
	}
	s.PixFmtValue = &v
	return s
}

// The picture width in pixels of the original video before transcoding.
// Format: pixels (pixels)
func (s TrackInfoVideoConfigurableImpl) PixelHeight() *Pixels {
	return s.PixelHeightValue
}

// The picture width in pixels of the original video before transcoding.
// Format: pixels (pixels)
func (s *TrackInfoVideoConfigurableImpl) SetPixelHeight(v Pixels) TrackInfoVideoConfigurable {
	if s == nil {
		return nil
	}
	s.PixelHeightValue = &v
	return s
}

// The picture width in pixels of the original video before transcoding.
// Format: pixels (pixels)
func (s TrackInfoVideoConfigurableImpl) PixelWidth() *Pixels {
	return s.PixelWidthValue
}

// The picture width in pixels of the original video before transcoding.
// Format: pixels (pixels)
func (s *TrackInfoVideoConfigurableImpl) SetPixelWidth(v Pixels) TrackInfoVideoConfigurable {
	if s == nil {
		return nil
	}
	s.PixelWidthValue = &v
	return s
}

// A specific codec-dependent profile of the output video.
// The profile allows to assume if the track can be played on a particular device.
func (s TrackInfoVideoConfigurableImpl) Profile() *string {
	return s.ProfileValue
}

// A specific codec-dependent profile of the output video.
// The profile allows to assume if the track can be played on a particular device.
func (s *TrackInfoVideoConfigurableImpl) SetProfile(v string) TrackInfoVideoConfigurable {
	if s == nil {
		return nil
	}
	s.ProfileValue = &v
	return s
}

// The second number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
// SAR is used for creating non-anamorphic video from anamorphic video.
func (s TrackInfoVideoConfigurableImpl) SarHeight() *int {
	return s.SarHeightValue
}

// The second number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
// SAR is used for creating non-anamorphic video from anamorphic video.
func (s *TrackInfoVideoConfigurableImpl) SetSarHeight(v int) TrackInfoVideoConfigurable {
	if s == nil {
		return nil
	}
	s.SarHeightValue = &v
	return s
}

// The first number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
// SAR is used for creating non-anamorphic video from anamorphic video.
func (s TrackInfoVideoConfigurableImpl) SarWidth() *int {
	return s.SarWidthValue
}

// The first number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
// SAR is used for creating non-anamorphic video from anamorphic video.
func (s *TrackInfoVideoConfigurableImpl) SetSarWidth(v int) TrackInfoVideoConfigurable {
	if s == nil {
		return nil
	}
	s.SarWidthValue = &v
	return s
}

// The picture width in pixels on the display where it will be played by a player.
// If you need to insert a web-player into a web page, use this value for choosing the player size.
// Format: pixels (pixels)
func (s TrackInfoVideoConfigurableImpl) Width() *Pixels {
	return s.WidthValue
}

// The picture width in pixels on the display where it will be played by a player.
// If you need to insert a web-player into a web page, use this value for choosing the player size.
// Format: pixels (pixels)
func (s *TrackInfoVideoConfigurableImpl) SetWidth(v Pixels) TrackInfoVideoConfigurable {
	if s == nil {
		return nil
	}
	s.WidthValue = &v
	return s
}

// NewTrackInfoVideoSpecific creates a new TrackInfoVideoSpecific instance
func NewTrackInfoVideoSpecific() TrackInfoVideoSpecific {
	return &TrackInfoVideoSpecificImpl{}
}

// Average GOP size (expressed in number of frames) of the last 1000-2000 frames.
// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
// If this value is floating, this means that your transcoder is working in flexible GOP size mode and some players may have problems.
// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
// Example: 25
func (s TrackInfoVideoSpecificImpl) AvgGop() *int {
	return s.AvgGopValue
}

// Average GOP size (expressed in number of frames) of the last 1000-2000 frames.
// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
// If this value is floating, this means that your transcoder is working in flexible GOP size mode and some players may have problems.
// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
// Example: 25
func (s *TrackInfoVideoSpecificImpl) SetAvgGop(v int) TrackInfoVideoSpecific {
	if s == nil {
		return nil
	}
	s.AvgGopValue = &v
	return s
}

// Parameters of closed captions.
func (s TrackInfoVideoSpecificImpl) ClosedCaptions() []ClosedCaptions {
	if s.ClosedCaptionsValue == nil {
		return nil
	}
	result := make([]ClosedCaptions, len(s.ClosedCaptionsValue))
	for i, item := range s.ClosedCaptionsValue {
		result[i] = item
	}
	return result
}

// Parameters of closed captions.
func (s *TrackInfoVideoSpecificImpl) SetClosedCaptions(v []ClosedCaptions) TrackInfoVideoSpecific {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*ClosedCaptionsImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*ClosedCaptionsImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.ClosedCaptionsValue = impl
	}
	return s
}

// Indicates if progressive scanning method is used for all frames of the track
func (s TrackInfoVideoSpecificImpl) IsProgressive() *bool {
	return s.IsProgressiveValue
}

// Indicates if progressive scanning method is used for all frames of the track
func (s *TrackInfoVideoSpecificImpl) SetIsProgressive(v bool) TrackInfoVideoSpecific {
	if s == nil {
		return nil
	}
	s.IsProgressiveValue = &v
	return s
}

// Last GOP size (expressed in number of frames).
// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
// If this value is floating, this means that your transcoder is working in a flexible GOP size mode and some players may have problems.
// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
// Example: 28
func (s TrackInfoVideoSpecificImpl) LastGop() *int {
	return s.LastGopValue
}

// Last GOP size (expressed in number of frames).
// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
// If this value is floating, this means that your transcoder is working in a flexible GOP size mode and some players may have problems.
// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
// Example: 28
func (s *TrackInfoVideoSpecificImpl) SetLastGop(v int) TrackInfoVideoSpecific {
	if s == nil {
		return nil
	}
	s.LastGopValue = &v
	return s
}

// The size of the length field for H264 bitstream without start codes.
func (s TrackInfoVideoSpecificImpl) LengthSize() *int {
	return s.LengthSizeValue
}

// The size of the length field for H264 bitstream without start codes.
func (s *TrackInfoVideoSpecificImpl) SetLengthSize(v int) TrackInfoVideoSpecific {
	if s == nil {
		return nil
	}
	s.LengthSizeValue = &v
	return s
}

// NewTranscoderDeviceStats creates a new TranscoderDeviceStats instance
func NewTranscoderDeviceStats() TranscoderDeviceStats {
	return &TranscoderDeviceStatsImpl{}
}

// Shows if the device can make an interlaced stream from a progressive one.
func (s TranscoderDeviceStatsImpl) CanInterlace() *bool {
	return s.CanInterlaceValue
}

// Shows if the device can make an interlaced stream from a progressive one.
func (s *TranscoderDeviceStatsImpl) SetCanInterlace(v bool) TranscoderDeviceStats {
	if s == nil {
		return nil
	}
	s.CanInterlaceValue = &v
	return s
}

// Shows if the transcoder with this device can run in the same process as Flussonic Media Server.
func (s TranscoderDeviceStatsImpl) CanInternal() *bool {
	return s.CanInternalValue
}

// Shows if the transcoder with this device can run in the same process as Flussonic Media Server.
func (s *TranscoderDeviceStatsImpl) SetCanInternal(v bool) TranscoderDeviceStats {
	if s == nil {
		return nil
	}
	s.CanInternalValue = &v
	return s
}

// Shows if the device can put a logo on the image.
func (s TranscoderDeviceStatsImpl) CanLogo() *bool {
	return s.CanLogoValue
}

// Shows if the device can put a logo on the image.
func (s *TranscoderDeviceStatsImpl) SetCanLogo(v bool) TranscoderDeviceStats {
	if s == nil {
		return nil
	}
	s.CanLogoValue = &v
	return s
}

// GPU decoder load percentage.
func (s TranscoderDeviceStatsImpl) GpuDec() *int {
	return s.GpuDecValue
}

// GPU decoder load percentage.
func (s *TranscoderDeviceStatsImpl) SetGpuDec(v int) TranscoderDeviceStats {
	if s == nil {
		return nil
	}
	s.GpuDecValue = &v
	return s
}

// GPU encoder load percentage.
func (s TranscoderDeviceStatsImpl) GpuEnc() *int {
	return s.GpuEncValue
}

// GPU encoder load percentage.
func (s *TranscoderDeviceStatsImpl) SetGpuEnc(v int) TranscoderDeviceStats {
	if s == nil {
		return nil
	}
	s.GpuEncValue = &v
	return s
}

// GPU shared memory amount.
func (s TranscoderDeviceStatsImpl) GpuSm() *int {
	return s.GpuSmValue
}

// GPU shared memory amount.
func (s *TranscoderDeviceStatsImpl) SetGpuSm(v int) TranscoderDeviceStats {
	if s == nil {
		return nil
	}
	s.GpuSmValue = &v
	return s
}

// GPU temperature, C.
func (s TranscoderDeviceStatsImpl) GpuTemp() *int {
	return s.GpuTempValue
}

// GPU temperature, C.
func (s *TranscoderDeviceStatsImpl) SetGpuTemp(v int) TranscoderDeviceStats {
	if s == nil {
		return nil
	}
	s.GpuTempValue = &v
	return s
}

// The ID of the device used for transcoding.
// In PUT requests, you can use `auto` for Flussonic to set the ID itself.
// In the response to GET requests, the `id` will always be a number.
func (s TranscoderDeviceStatsImpl) ID() *TcDeviceid {
	return s.IDValue
}

// The ID of the device used for transcoding.
// In PUT requests, you can use `auto` for Flussonic to set the ID itself.
// In the response to GET requests, the `id` will always be a number.
func (s *TranscoderDeviceStatsImpl) SetID(v *TcDeviceid) TranscoderDeviceStats {
	if s == nil {
		return nil
	}
	s.IDValue = v
	return s
}

// Free RAM.
func (s TranscoderDeviceStatsImpl) Memfree() *int {
	return s.MemfreeValue
}

// Free RAM.
func (s *TranscoderDeviceStatsImpl) SetMemfree(v int) TranscoderDeviceStats {
	if s == nil {
		return nil
	}
	s.MemfreeValue = &v
	return s
}

// Total RAM on the device.
func (s TranscoderDeviceStatsImpl) Memtotal() *int {
	return s.MemtotalValue
}

// Total RAM on the device.
func (s *TranscoderDeviceStatsImpl) SetMemtotal(v int) TranscoderDeviceStats {
	if s == nil {
		return nil
	}
	s.MemtotalValue = &v
	return s
}

// Utilized RAM.
func (s TranscoderDeviceStatsImpl) Memused() *int {
	return s.MemusedValue
}

// Utilized RAM.
func (s *TranscoderDeviceStatsImpl) SetMemused(v int) TranscoderDeviceStats {
	if s == nil {
		return nil
	}
	s.MemusedValue = &v
	return s
}

// The name of the transcoder device.
func (s TranscoderDeviceStatsImpl) Name() *string {
	return s.NameValue
}

// The name of the transcoder device.
func (s *TranscoderDeviceStatsImpl) SetName(v string) TranscoderDeviceStats {
	if s == nil {
		return nil
	}
	s.NameValue = &v
	return s
}

// The ability of the device to be reconfigured online, i.e. without complete restart of the transcoder.
// `full` means that both decoder and encoder can be reconfigured online.
// `encoder` means that only encoder can be reconfigured online.
// `decoder` means that only decoder can be reconfigured online.
// `false` means that online reconfiguration is not supported.
func (s TranscoderDeviceStatsImpl) ReconfigSupport() *TcReconfigSupport {
	return s.ReconfigSupportValue
}

// The ability of the device to be reconfigured online, i.e. without complete restart of the transcoder.
// `full` means that both decoder and encoder can be reconfigured online.
// `encoder` means that only encoder can be reconfigured online.
// `decoder` means that only decoder can be reconfigured online.
// `false` means that online reconfiguration is not supported.
func (s *TranscoderDeviceStatsImpl) SetReconfigSupport(v *TcReconfigSupport) TranscoderDeviceStats {
	if s == nil {
		return nil
	}
	s.ReconfigSupportValue = v
	return s
}

// The type of the device used for transcoding.
// Example: cpu
func (s TranscoderDeviceStatsImpl) Type() *TranscoderDevice {
	return s.TypeValue
}

// The type of the device used for transcoding.
// Example: cpu
func (s *TranscoderDeviceStatsImpl) SetType(v TranscoderDevice) TranscoderDeviceStats {
	if s == nil {
		return nil
	}
	s.TypeValue = &v
	return s
}

// NewTransponderConfig creates a new TransponderConfig instance
func NewTransponderConfig() TransponderConfig {
	return &TransponderConfigImpl{}
}

// Transponder bitrate.
// Format: speed (speed)
func (s TransponderConfigImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// Transponder bitrate.
// Format: speed (speed)
func (s *TransponderConfigImpl) SetBitrate(v Speed) TransponderConfig {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// Transponder's program guide in EIT format.
func (s TransponderConfigImpl) Eit() TransponderEit {
	return s.EitValue
}

// Transponder's program guide in EIT format.
func (s *TransponderConfigImpl) SetEit(v TransponderEit) TransponderConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*TransponderEitImpl); ok {
		s.EitValue = impl
	}
	return s
}

// The name of the transponder.
// Format: media_name (media_name)
// Example: multiplexer
func (s TransponderConfigImpl) Name() MediaName {
	return s.NameValue
}

// The name of the transponder.
// Format: media_name (media_name)
// Example: multiplexer
func (s *TransponderConfigImpl) SetName(v MediaName) TransponderConfig {
	if s == nil {
		return nil
	}
	s.NameValue = v
	return s
}

// Identifier of the delivery network.
func (s TransponderConfigImpl) NetworkID() *int {
	return s.NetworkIDValue
}

// Identifier of the delivery network.
func (s *TransponderConfigImpl) SetNetworkID(v int) TransponderConfig {
	if s == nil {
		return nil
	}
	s.NetworkIDValue = &v
	return s
}

// The name of the TV network.
// Example: Example Network
func (s TransponderConfigImpl) NetworkName() *string {
	return s.NetworkNameValue
}

// The name of the TV network.
// Example: Example Network
func (s *TransponderConfigImpl) SetNetworkName(v string) TransponderConfig {
	if s == nil {
		return nil
	}
	s.NetworkNameValue = &v
	return s
}

// Identifier of the original delivery network. The same original network is used for NIT and SDT.
func (s TransponderConfigImpl) OriginalNetworkID() *int {
	return s.OriginalNetworkIDValue
}

// Identifier of the original delivery network. The same original network is used for NIT and SDT.
func (s *TransponderConfigImpl) SetOriginalNetworkID(v int) TransponderConfig {
	if s == nil {
		return nil
	}
	s.OriginalNetworkIDValue = &v
	return s
}

// The list of other transponders on the network.
func (s TransponderConfigImpl) Others() []TransponderOther {
	if s.OthersValue == nil {
		return nil
	}
	result := make([]TransponderOther, len(s.OthersValue))
	for i, item := range s.OthersValue {
		result[i] = item
	}
	return result
}

// The list of other transponders on the network.
func (s *TransponderConfigImpl) SetOthers(v []TransponderOther) TransponderConfig {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*TransponderOtherImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*TransponderOtherImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.OthersValue = impl
	}
	return s
}

// The length of multiplexer input buffer.
// The higher value makes the multiplexer more robust to non-uniform inputs.
// The lower value reduces input-to-output latency, but requires more stable bitrate (CBR) on input.
// Format: milliseconds (milliseconds)
// Example: 800
func (s TransponderConfigImpl) Prebuffer() *Milliseconds {
	return s.PrebufferValue
}

// The length of multiplexer input buffer.
// The higher value makes the multiplexer more robust to non-uniform inputs.
// The lower value reduces input-to-output latency, but requires more stable bitrate (CBR) on input.
// Format: milliseconds (milliseconds)
// Example: 800
func (s *TransponderConfigImpl) SetPrebuffer(v Milliseconds) TransponderConfig {
	if s == nil {
		return nil
	}
	s.PrebufferValue = &v
	return s
}

// The list of programs in the transponder.
func (s TransponderConfigImpl) Programs() []TransponderProgram {
	if s.ProgramsValue == nil {
		return nil
	}
	result := make([]TransponderProgram, len(s.ProgramsValue))
	for i, item := range s.ProgramsValue {
		result[i] = item
	}
	return result
}

// The list of programs in the transponder.
func (s *TransponderConfigImpl) SetPrograms(v []TransponderProgram) TransponderConfig {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*TransponderProgramImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*TransponderProgramImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.ProgramsValue = impl
	}
	return s
}

// Provider of the transponder.
// Example: Example Provider
func (s TransponderConfigImpl) Provider() *string {
	return s.ProviderValue
}

// Provider of the transponder.
// Example: Example Provider
func (s *TransponderConfigImpl) SetProvider(v string) TransponderConfig {
	if s == nil {
		return nil
	}
	s.ProviderValue = &v
	return s
}

// The list of pushes for the transponder.
func (s TransponderConfigImpl) Pushes() []TransponderPush {
	if s.PushesValue == nil {
		return nil
	}
	result := make([]TransponderPush, len(s.PushesValue))
	for i, item := range s.PushesValue {
		result[i] = item
	}
	return result
}

// The list of pushes for the transponder.
func (s *TransponderConfigImpl) SetPushes(v []TransponderPush) TransponderConfig {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*TransponderPushImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*TransponderPushImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.PushesValue = impl
	}
	return s
}

// Detailed runtime information about the multiplexer.
func (s TransponderConfigImpl) Stats() MultiplexerStats {
	return s.StatsValue
}

// Detailed runtime information about the multiplexer.
func (s *TransponderConfigImpl) SetStats(v MultiplexerStats) TransponderConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*MultiplexerStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// The list of time offsets.
func (s TransponderConfigImpl) TimeOffsets() []TransponderTimeOffset {
	if s.TimeOffsetsValue == nil {
		return nil
	}
	result := make([]TransponderTimeOffset, len(s.TimeOffsetsValue))
	for i, item := range s.TimeOffsetsValue {
		result[i] = item
	}
	return result
}

// The list of time offsets.
func (s *TransponderConfigImpl) SetTimeOffsets(v []TransponderTimeOffset) TransponderConfig {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*TransponderTimeOffsetImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*TransponderTimeOffsetImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.TimeOffsetsValue = impl
	}
	return s
}

// The list of timeouts for autodetect of provider, title, and service_type of the programs.
func (s TransponderConfigImpl) Timeouts() TSTimeouts {
	return s.TimeoutsValue
}

// The list of timeouts for autodetect of provider, title, and service_type of the programs.
func (s *TransponderConfigImpl) SetTimeouts(v TSTimeouts) TransponderConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*TSTimeoutsImpl); ok {
		s.TimeoutsValue = impl
	}
	return s
}

// The list of transport stream descriptors. Descriptors are added to NIT and SDT.
func (s TransponderConfigImpl) TSDescriptors() []TSDescriptor {
	if s.TSDescriptorsValue == nil {
		return nil
	}
	result := make([]TSDescriptor, len(s.TSDescriptorsValue))
	for i, item := range s.TSDescriptorsValue {
		result[i] = item
	}
	return result
}

// The list of transport stream descriptors. Descriptors are added to NIT and SDT.
func (s *TransponderConfigImpl) SetTSDescriptors(v []TSDescriptor) TransponderConfig {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*TSDescriptorImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*TSDescriptorImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.TSDescriptorsValue = impl
	}
	return s
}

// The identifier of the transport stream for the transponder.
func (s TransponderConfigImpl) TSStreamID() *int {
	return s.TSStreamIDValue
}

// The identifier of the transport stream for the transponder.
func (s *TransponderConfigImpl) SetTSStreamID(v int) TransponderConfig {
	if s == nil {
		return nil
	}
	s.TSStreamIDValue = &v
	return s
}

// Versions of PSI tables.
func (s TransponderConfigImpl) Versions() TSVersions {
	return s.VersionsValue
}

// Versions of PSI tables.
func (s *TransponderConfigImpl) SetVersions(v TSVersions) TransponderConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*TSVersionsImpl); ok {
		s.VersionsValue = impl
	}
	return s
}

// The size of the video buffer for the transponder.
func (s TransponderConfigImpl) VideoBuffer() *int {
	return s.VideoBufferValue
}

// The size of the video buffer for the transponder.
func (s *TransponderConfigImpl) SetVideoBuffer(v int) TransponderConfig {
	if s == nil {
		return nil
	}
	s.VideoBufferValue = &v
	return s
}

// NewTransponderEit creates a new TransponderEit instance
func NewTransponderEit() TransponderEit {
	return &TransponderEitImpl{}
}

// Periods for sending the present/following events.
func (s TransponderEitImpl) IntervalsPf() TSEitIntervals {
	return s.IntervalsPfValue
}

// Periods for sending the present/following events.
func (s *TransponderEitImpl) SetIntervalsPf(v TSEitIntervals) TransponderEit {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*TSEitIntervalsImpl); ok {
		s.IntervalsPfValue = impl
	}
	return s
}

// Periods for sending the event schedules.
func (s TransponderEitImpl) IntervalsSchedule() TSEitIntervals {
	return s.IntervalsScheduleValue
}

// Periods for sending the event schedules.
func (s *TransponderEitImpl) SetIntervalsSchedule(v TSEitIntervals) TransponderEit {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*TSEitIntervalsImpl); ok {
		s.IntervalsScheduleValue = impl
	}
	return s
}

// Period for storing the XMLTV files.
// Format: seconds (seconds)
func (s TransponderEitImpl) KeepEpg() *Seconds {
	return s.KeepEpgValue
}

// Period for storing the XMLTV files.
// Format: seconds (seconds)
func (s *TransponderEitImpl) SetKeepEpg(v Seconds) TransponderEit {
	if s == nil {
		return nil
	}
	s.KeepEpgValue = &v
	return s
}

// Maximum bitrate for the transponder's EIT EPG.
// Format: max_bitrate (max_bitrate)
func (s TransponderEitImpl) MaxBitrate() *MaxBitrate {
	return s.MaxBitrateValue
}

// Maximum bitrate for the transponder's EIT EPG.
// Format: max_bitrate (max_bitrate)
func (s *TransponderEitImpl) SetMaxBitrate(v MaxBitrate) TransponderEit {
	if s == nil {
		return nil
	}
	s.MaxBitrateValue = &v
	return s
}

// Directory for storing the XMLTV EPG files.
// Example: xmltv_dir
func (s TransponderEitImpl) XmltvURL() *string {
	return s.XmltvURLValue
}

// Directory for storing the XMLTV EPG files.
// Example: xmltv_dir
func (s *TransponderEitImpl) SetXmltvURL(v string) TransponderEit {
	if s == nil {
		return nil
	}
	s.XmltvURLValue = &v
	return s
}

// NewTransponderOther creates a new TransponderOther instance
func NewTransponderOther() TransponderOther {
	return &TransponderOtherImpl{}
}

// The name of the other transponder on the network.
// Format: media_name (media_name)
func (s TransponderOtherImpl) Name() MediaName {
	return s.NameValue
}

// The name of the other transponder on the network.
// Format: media_name (media_name)
func (s *TransponderOtherImpl) SetName(v MediaName) TransponderOther {
	if s == nil {
		return nil
	}
	s.NameValue = v
	return s
}

// NewTransponderPid creates a new TransponderPid instance
func NewTransponderPid() TransponderPid {
	return &TransponderPidImpl{}
}

// Bitrate of the track.
// Format: speed (speed)
// Example: 2543
func (s TransponderPidImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// Bitrate of the track.
// Format: speed (speed)
// Example: 2543
func (s *TransponderPidImpl) SetBitrate(v Speed) TransponderPid {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// Codec for this pid. Use this if just content+track is not enough.
// Example: scte35
func (s TransponderPidImpl) Codec() *FrameCodec {
	return s.CodecValue
}

// Codec for this pid. Use this if just content+track is not enough.
// Example: scte35
func (s *TransponderPidImpl) SetCodec(v FrameCodec) TransponderPid {
	if s == nil {
		return nil
	}
	s.CodecValue = &v
	return s
}

// Content of the track.
// Example: audio
func (s TransponderPidImpl) Content() string {
	return s.ContentValue
}

// Content of the track.
// Example: audio
func (s *TransponderPidImpl) SetContent(v string) TransponderPid {
	if s == nil {
		return nil
	}
	s.ContentValue = v
	return s
}

// Raw elementary stream descriptors to describe proprietary stream in PMT program info
// Plese refer to ISO/IEC 13818-1 section 2.6 for syntax
// This is an optional parameter for advanced users. By default, the media Server
// is automatically sets the stream_type according to the track codec.
// Format: hexbinary (hexbinary)
// Example: 52010D
func (s TransponderPidImpl) EsInfo() *Hexbinary {
	return s.EsInfoValue
}

// Raw elementary stream descriptors to describe proprietary stream in PMT program info
// Plese refer to ISO/IEC 13818-1 section 2.6 for syntax
// This is an optional parameter for advanced users. By default, the media Server
// is automatically sets the stream_type according to the track codec.
// Format: hexbinary (hexbinary)
// Example: 52010D
func (s *TransponderPidImpl) SetEsInfo(v Hexbinary) TransponderPid {
	if s == nil {
		return nil
	}
	s.EsInfoValue = &v
	return s
}

// A PID to assign to a matched track or system table.
// PID identifies the payload (media or service) in the resulting MPTS stream.
// Multiplexer will include only the tracks with specified PIDs.
// It is possible to set PID values for video, audio and other media tracks, as well as for PMT and SDT.
func (s TransponderPidImpl) Pid() int {
	return s.PidValue
}

// A PID to assign to a matched track or system table.
// PID identifies the payload (media or service) in the resulting MPTS stream.
// Multiplexer will include only the tracks with specified PIDs.
// It is possible to set PID values for video, audio and other media tracks, as well as for PMT and SDT.
func (s *TransponderPidImpl) SetPid(v int) TransponderPid {
	if s == nil {
		return nil
	}
	s.PidValue = v
	return s
}

// Detailed runtime information about the multiplexer pid.
func (s TransponderPidImpl) Stats() PushPidCounters {
	return s.StatsValue
}

// Detailed runtime information about the multiplexer pid.
func (s *TransponderPidImpl) SetStats(v PushPidCounters) TransponderPid {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*PushPidCountersImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// Custom program element type in PMT
// Combined with bypass (content=metadata, track=0) this option makes
// proprietary PSI streams appear in PMT program info with given stream_type field
// This is an optional parameter for advanced users. By default, the media Server
// is automatically sets the stream_type according to the track codec.
// Example: 12
func (s TransponderPidImpl) StreamType() *int {
	return s.StreamTypeValue
}

// Custom program element type in PMT
// Combined with bypass (content=metadata, track=0) this option makes
// proprietary PSI streams appear in PMT program info with given stream_type field
// This is an optional parameter for advanced users. By default, the media Server
// is automatically sets the stream_type according to the track codec.
// Example: 12
func (s *TransponderPidImpl) SetStreamType(v int) TransponderPid {
	if s == nil {
		return nil
	}
	s.StreamTypeValue = &v
	return s
}

// Index of a track with specified content and maybe codec.
// E.g. when you specify content=audio and track=2 the second audio track will be selected.
// If you specify content=audio, codec=aac and track=1, the first AAC track will be selected
// even if it is a third audio track and fifth track in stream media_info
// Example: 1
func (s TransponderPidImpl) Track() int {
	return s.TrackValue
}

// Index of a track with specified content and maybe codec.
// E.g. when you specify content=audio and track=2 the second audio track will be selected.
// If you specify content=audio, codec=aac and track=1, the first AAC track will be selected
// even if it is a third audio track and fifth track in stream media_info
// Example: 1
func (s *TransponderPidImpl) SetTrack(v int) TransponderPid {
	if s == nil {
		return nil
	}
	s.TrackValue = v
	return s
}

// NewTransponderProgram creates a new TransponderProgram instance
func NewTransponderProgram() TransponderProgram {
	return &TransponderProgramImpl{}
}

// The name of the EIT.
// Example: EIT_Title
func (s TransponderProgramImpl) EitTitle() *string {
	return s.EitTitleValue
}

// The name of the EIT.
// Example: EIT_Title
func (s *TransponderProgramImpl) SetEitTitle(v string) TransponderProgram {
	if s == nil {
		return nil
	}
	s.EitTitleValue = &v
	return s
}

// Logical channel number.
// Example: 5
func (s TransponderProgramImpl) Lcn() *int {
	return s.LcnValue
}

// Logical channel number.
// Example: 5
func (s *TransponderProgramImpl) SetLcn(v int) TransponderProgram {
	if s == nil {
		return nil
	}
	s.LcnValue = &v
	return s
}

// The list of PIDs.
func (s TransponderProgramImpl) Pids() OutputMpegtsPids {
	return s.PidsValue
}

// The list of PIDs.
func (s *TransponderProgramImpl) SetPids(v OutputMpegtsPids) TransponderProgram {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*OutputMpegtsPidsImpl); ok {
		s.PidsValue = impl
	}
	return s
}

// Identifier of the program within the transponder.
func (s TransponderProgramImpl) ProgramID() int {
	return s.ProgramIDValue
}

// Identifier of the program within the transponder.
func (s *TransponderProgramImpl) SetProgramID(v int) TransponderProgram {
	if s == nil {
		return nil
	}
	s.ProgramIDValue = v
	return s
}

// Information about the program type.
// Example: digital_tv
func (s TransponderProgramImpl) ServiceType() *TSServiceType {
	return s.ServiceTypeValue
}

// Information about the program type.
// Example: digital_tv
func (s *TransponderProgramImpl) SetServiceType(v *TSServiceType) TransponderProgram {
	if s == nil {
		return nil
	}
	s.ServiceTypeValue = v
	return s
}

// The stream that is in use as the program source.
// Format: media_name (media_name)
// Example: hockey1
func (s TransponderProgramImpl) Source() *MediaName {
	return s.SourceValue
}

// The stream that is in use as the program source.
// Format: media_name (media_name)
// Example: hockey1
func (s *TransponderProgramImpl) SetSource(v MediaName) TransponderProgram {
	if s == nil {
		return nil
	}
	s.SourceValue = &v
	return s
}

// The program title.
// Example: ProgramTitle
func (s TransponderProgramImpl) Title() *string {
	return s.TitleValue
}

// The program title.
// Example: ProgramTitle
func (s *TransponderProgramImpl) SetTitle(v string) TransponderProgram {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// NewTransponderProgramStats creates a new TransponderProgramStats instance
func NewTransponderProgramStats() TransponderProgramStats {
	return &TransponderProgramStatsImpl{}
}

// Number of times the program was reset.
// This may occur when a frame fails to enqueue due to bad timing.
func (s TransponderProgramStatsImpl) ErrorsProgramReset() *int {
	return s.ErrorsProgramResetValue
}

// Number of times the program was reset.
// This may occur when a frame fails to enqueue due to bad timing.
func (s *TransponderProgramStatsImpl) SetErrorsProgramReset(v int) TransponderProgramStats {
	if s == nil {
		return nil
	}
	s.ErrorsProgramResetValue = &v
	return s
}

// Number of SCTE-35 splices that missed their intended splice point.
func (s TransponderProgramStatsImpl) ErrorsScte35Announces() *int {
	return s.ErrorsScte35AnnouncesValue
}

// Number of SCTE-35 splices that missed their intended splice point.
func (s *TransponderProgramStatsImpl) SetErrorsScte35Announces(v int) TransponderProgramStats {
	if s == nil {
		return nil
	}
	s.ErrorsScte35AnnouncesValue = &v
	return s
}

// Number of times the program was reset due to a change in the `output_dts_shift` option.
// This may happen when the input source is switched.
func (s TransponderProgramStatsImpl) OutputDtsShiftChanged() *int {
	return s.OutputDtsShiftChangedValue
}

// Number of times the program was reset due to a change in the `output_dts_shift` option.
// This may happen when the input source is switched.
func (s *TransponderProgramStatsImpl) SetOutputDtsShiftChanged(v int) TransponderProgramStats {
	if s == nil {
		return nil
	}
	s.OutputDtsShiftChangedValue = &v
	return s
}

// Program ID of the program.
func (s TransponderProgramStatsImpl) Pnr() int {
	return s.PnrValue
}

// Program ID of the program.
func (s *TransponderProgramStatsImpl) SetPnr(v int) TransponderProgramStats {
	if s == nil {
		return nil
	}
	s.PnrValue = v
	return s
}

// Number of SCTE-35 splices targeting an IDR frame.
func (s TransponderProgramStatsImpl) Scte35Announces() *int {
	return s.Scte35AnnouncesValue
}

// Number of SCTE-35 splices targeting an IDR frame.
func (s *TransponderProgramStatsImpl) SetScte35Announces(v int) TransponderProgramStats {
	if s == nil {
		return nil
	}
	s.Scte35AnnouncesValue = &v
	return s
}

// NewTransponderPush creates a new TransponderPush instance
func NewTransponderPush() TransponderPush {
	return &TransponderPushImpl{}
}

// The multicast socket option that enables ingesting the sent data back to the transponder.
// Use for test purposes, e.g. if the same server creates MTPS and splits MPTS to separate programs.
func (s TransponderPushImpl) MulticastLoop() *bool {
	return s.MulticastLoopValue
}

// The multicast socket option that enables ingesting the sent data back to the transponder.
// Use for test purposes, e.g. if the same server creates MTPS and splits MPTS to separate programs.
func (s *TransponderPushImpl) SetMulticastLoop(v bool) TransponderPush {
	if s == nil {
		return nil
	}
	s.MulticastLoopValue = &v
	return s
}

// Monitoring multicast group and stop pushing if another publisher presented
func (s TransponderPushImpl) Standby() *bool {
	return s.StandbyValue
}

// Monitoring multicast group and stop pushing if another publisher presented
func (s *TransponderPushImpl) SetStandby(v bool) TransponderPush {
	if s == nil {
		return nil
	}
	s.StandbyValue = &v
	return s
}

// Detailed runtime information about the push.
func (s TransponderPushImpl) Stats() PushCounters {
	return s.StatsValue
}

// Detailed runtime information about the push.
func (s *TransponderPushImpl) SetStats(v PushCounters) TransponderPush {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*PushCountersImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// ToS byte in the IP packages of the multicasted data.
func (s TransponderPushImpl) Tos() *int {
	return s.TosValue
}

// ToS byte in the IP packages of the multicasted data.
func (s *TransponderPushImpl) SetTos(v int) TransponderPush {
	if s == nil {
		return nil
	}
	s.TosValue = &v
	return s
}

// Push URL for the MPTS stream. Usually it is a `udp://` multicast address and port.
func (s TransponderPushImpl) URL() string {
	return s.URLValue
}

// Push URL for the MPTS stream. Usually it is a `udp://` multicast address and port.
func (s *TransponderPushImpl) SetURL(v string) TransponderPush {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// NewTransponderTimeOffset creates a new TransponderTimeOffset instance
func NewTransponderTimeOffset() TransponderTimeOffset {
	return &TransponderTimeOffsetImpl{}
}

// The country code.
func (s TransponderTimeOffsetImpl) Country() string {
	return s.CountryValue
}

// The country code.
func (s *TransponderTimeOffsetImpl) SetCountry(v string) TransponderTimeOffset {
	if s == nil {
		return nil
	}
	s.CountryValue = v
	return s
}

// The current offset time from UTC.
func (s TransponderTimeOffsetImpl) LocalTimeOffset() *string {
	return s.LocalTimeOffsetValue
}

// The current offset time from UTC.
func (s *TransponderTimeOffsetImpl) SetLocalTimeOffset(v string) TransponderTimeOffset {
	if s == nil {
		return nil
	}
	s.LocalTimeOffsetValue = &v
	return s
}

// The next offset time after the change.
func (s TransponderTimeOffsetImpl) NextTimeOffset() *string {
	return s.NextTimeOffsetValue
}

// The next offset time after the change.
func (s *TransponderTimeOffsetImpl) SetNextTimeOffset(v string) TransponderTimeOffset {
	if s == nil {
		return nil
	}
	s.NextTimeOffsetValue = &v
	return s
}

// The region code.
func (s TransponderTimeOffsetImpl) Region() *int {
	return s.RegionValue
}

// The region code.
func (s *TransponderTimeOffsetImpl) SetRegion(v int) TransponderTimeOffset {
	if s == nil {
		return nil
	}
	s.RegionValue = &v
	return s
}

// Date and time when the time change takes place.
func (s TransponderTimeOffsetImpl) TimeOfChange() *int {
	return s.TimeOfChangeValue
}

// Date and time when the time change takes place.
func (s *TransponderTimeOffsetImpl) SetTimeOfChange(v int) TransponderTimeOffset {
	if s == nil {
		return nil
	}
	s.TimeOfChangeValue = &v
	return s
}

// NewUser creates a new User instance
func NewUser() User {
	return &UserImpl{}
}

// The parameter regulates the rights for the user
// Example: generic
func (s UserImpl) AccessLevel() *UserAdminAccessLevel {
	return s.AccessLevelValue
}

// The parameter regulates the rights for the user
// Example: generic
func (s *UserImpl) SetAccessLevel(v UserAdminAccessLevel) User {
	if s == nil {
		return nil
	}
	s.AccessLevelValue = &v
	return s
}

// The date and time when the user was created.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.672531199e+12
func (s UserImpl) CreatedAt() *UtcMs {
	return s.CreatedAtValue
}

// The date and time when the user was created.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.672531199e+12
func (s *UserImpl) SetCreatedAt(v UtcMs) User {
	if s == nil {
		return nil
	}
	s.CreatedAtValue = &v
	return s
}

// A parameter that allows you to enable/disable the user
// Example: false
func (s UserImpl) Disabled() *bool {
	return s.DisabledValue
}

// A parameter that allows you to enable/disable the user
// Example: false
func (s *UserImpl) SetDisabled(v bool) User {
	if s == nil {
		return nil
	}
	s.DisabledValue = &v
	return s
}

// User's email. Required for password recovery.
// Format: email (email)
// Example: user@example.com
func (s UserImpl) Email() *Email {
	return s.EmailValue
}

// User's email. Required for password recovery.
// Format: email (email)
// Example: user@example.com
func (s *UserImpl) SetEmail(v Email) User {
	if s == nil {
		return nil
	}
	s.EmailValue = &v
	return s
}

// The user's full name.
func (s UserImpl) Fullname() *string {
	return s.FullnameValue
}

// The user's full name.
func (s *UserImpl) SetFullname(v string) User {
	if s == nil {
		return nil
	}
	s.FullnameValue = &v
	return s
}

// Identifier of the user.
// Example: 1
func (s UserImpl) ID() *int {
	return s.IDValue
}

// Identifier of the user.
// Example: 1
func (s *UserImpl) SetID(v int) User {
	if s == nil {
		return nil
	}
	s.IDValue = &v
	return s
}

// The language, selected by user.
// Format: ISO 639-1
// Example: en
func (s UserImpl) Locale() *ISO6391 {
	return s.LocaleValue
}

// The language, selected by user.
// Format: ISO 639-1
// Example: en
func (s *UserImpl) SetLocale(v ISO6391) User {
	if s == nil {
		return nil
	}
	s.LocaleValue = &v
	return s
}

// The maximum number of sessions the user can have simultaneously.
func (s UserImpl) MaxSessions() *int {
	return s.MaxSessionsValue
}

// The maximum number of sessions the user can have simultaneously.
func (s *UserImpl) SetMaxSessions(v int) User {
	if s == nil {
		return nil
	}
	s.MaxSessionsValue = &v
	return s
}

// User name (login)
func (s UserImpl) Name() *string {
	return s.NameValue
}

// User name (login)
func (s *UserImpl) SetName(v string) User {
	if s == nil {
		return nil
	}
	s.NameValue = &v
	return s
}

// Additional information or notes about the user.
func (s UserImpl) Note() *string {
	return s.NoteValue
}

// Additional information or notes about the user.
func (s *UserImpl) SetNote(v string) User {
	if s == nil {
		return nil
	}
	s.NoteValue = &v
	return s
}

// A parameter indicating that the user belongs to certain organizations
func (s UserImpl) Organizations() []UserAdminOrganizationsItem {
	if s.OrganizationsValue == nil {
		return nil
	}
	result := make([]UserAdminOrganizationsItem, len(s.OrganizationsValue))
	for i, item := range s.OrganizationsValue {
		result[i] = item
	}
	return result
}

// A parameter indicating that the user belongs to certain organizations
func (s *UserImpl) SetOrganizations(v []UserAdminOrganizationsItem) User {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*UserAdminOrganizationsItemImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*UserAdminOrganizationsItemImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.OrganizationsValue = impl
	}
	return s
}

// The specified password will be saved as a hash, used only for writing
func (s UserImpl) Password() *string {
	return s.PasswordValue
}

// The specified password will be saved as a hash, used only for writing
func (s *UserImpl) SetPassword(v string) User {
	if s == nil {
		return nil
	}
	s.PasswordValue = &v
	return s
}

// User's phone number
// Format: phone-number (phone-number)
// Example: +78007778413
func (s UserImpl) Phone() *PhoneNumber {
	return s.PhoneValue
}

// User's phone number
// Format: phone-number (phone-number)
// Example: +78007778413
func (s *UserImpl) SetPhone(v PhoneNumber) User {
	if s == nil {
		return nil
	}
	s.PhoneValue = &v
	return s
}

// A flag indicating that the user has read-only access and cannot modify their own data.
// Example: false
func (s UserImpl) Readonly() *bool {
	return s.ReadonlyValue
}

// A flag indicating that the user has read-only access and cannot modify their own data.
// Example: false
func (s *UserImpl) SetReadonly(v bool) User {
	if s == nil {
		return nil
	}
	s.ReadonlyValue = &v
	return s
}

// NewUserAdmin creates a new UserAdmin instance
func NewUserAdmin() UserAdmin {
	return &UserAdminImpl{}
}

// The parameter regulates the rights for the user
// Example: generic
func (s UserAdminImpl) AccessLevel() *UserAdminAccessLevel {
	return s.AccessLevelValue
}

// The parameter regulates the rights for the user
// Example: generic
func (s *UserAdminImpl) SetAccessLevel(v UserAdminAccessLevel) UserAdmin {
	if s == nil {
		return nil
	}
	s.AccessLevelValue = &v
	return s
}

// A parameter that allows you to enable/disable the user
// Example: false
func (s UserAdminImpl) Disabled() *bool {
	return s.DisabledValue
}

// A parameter that allows you to enable/disable the user
// Example: false
func (s *UserAdminImpl) SetDisabled(v bool) UserAdmin {
	if s == nil {
		return nil
	}
	s.DisabledValue = &v
	return s
}

// Identifier of the user.
// Example: 1
func (s UserAdminImpl) ID() *int {
	return s.IDValue
}

// Identifier of the user.
// Example: 1
func (s *UserAdminImpl) SetID(v int) UserAdmin {
	if s == nil {
		return nil
	}
	s.IDValue = &v
	return s
}

// A parameter indicating that the user belongs to certain organizations
func (s UserAdminImpl) Organizations() []UserAdminOrganizationsItem {
	if s.OrganizationsValue == nil {
		return nil
	}
	result := make([]UserAdminOrganizationsItem, len(s.OrganizationsValue))
	for i, item := range s.OrganizationsValue {
		result[i] = item
	}
	return result
}

// A parameter indicating that the user belongs to certain organizations
func (s *UserAdminImpl) SetOrganizations(v []UserAdminOrganizationsItem) UserAdmin {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*UserAdminOrganizationsItemImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*UserAdminOrganizationsItemImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.OrganizationsValue = impl
	}
	return s
}

// A flag indicating that the user has read-only access and cannot modify their own data.
// Example: false
func (s UserAdminImpl) Readonly() *bool {
	return s.ReadonlyValue
}

// A flag indicating that the user has read-only access and cannot modify their own data.
// Example: false
func (s *UserAdminImpl) SetReadonly(v bool) UserAdmin {
	if s == nil {
		return nil
	}
	s.ReadonlyValue = &v
	return s
}

// NewUserAdminOrganizationsItem creates a new UserAdminOrganizationsItem instance
func NewUserAdminOrganizationsItem() UserAdminOrganizationsItem {
	return &UserAdminOrganizationsItemImpl{}
}

// Id of the organization
// Example: 1
func (s UserAdminOrganizationsItemImpl) ID() *int {
	return s.IDValue
}

// Id of the organization
// Example: 1
func (s *UserAdminOrganizationsItemImpl) SetID(v int) UserAdminOrganizationsItem {
	if s == nil {
		return nil
	}
	s.IDValue = &v
	return s
}

// Owner properties.
func (s UserAdminOrganizationsItemImpl) Owner() UserAdminOrganizationsItemOwner {
	return s.OwnerValue
}

// Owner properties.
func (s *UserAdminOrganizationsItemImpl) SetOwner(v UserAdminOrganizationsItemOwner) UserAdminOrganizationsItem {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*UserAdminOrganizationsItemOwnerImpl); ok {
		s.OwnerValue = impl
	}
	return s
}

// Organization permissions
func (s UserAdminOrganizationsItemImpl) Permissions() OrganizationPermissions {
	return s.PermissionsValue
}

// Organization permissions
func (s *UserAdminOrganizationsItemImpl) SetPermissions(v OrganizationPermissions) UserAdminOrganizationsItem {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*OrganizationPermissionsImpl); ok {
		s.PermissionsValue = impl
	}
	return s
}

// Display title of the organization
// Example: Cameras
func (s UserAdminOrganizationsItemImpl) Title() *string {
	return s.TitleValue
}

// Display title of the organization
// Example: Cameras
func (s *UserAdminOrganizationsItemImpl) SetTitle(v string) UserAdminOrganizationsItem {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// NewUserAdminOrganizationsItemOwner creates a new UserAdminOrganizationsItemOwner instance
func NewUserAdminOrganizationsItemOwner() UserAdminOrganizationsItemOwner {
	return &UserAdminOrganizationsItemOwnerImpl{}
}

// ID of the organizations owner.
// Example: 2
func (s UserAdminOrganizationsItemOwnerImpl) ID() *int {
	return s.IDValue
}

// ID of the organizations owner.
// Example: 2
func (s *UserAdminOrganizationsItemOwnerImpl) SetID(v int) UserAdminOrganizationsItemOwner {
	if s == nil {
		return nil
	}
	s.IDValue = &v
	return s
}

// Name of the organizations owner.
// Example: admin
func (s UserAdminOrganizationsItemOwnerImpl) Name() *string {
	return s.NameValue
}

// Name of the organizations owner.
// Example: admin
func (s *UserAdminOrganizationsItemOwnerImpl) SetName(v string) UserAdminOrganizationsItemOwner {
	if s == nil {
		return nil
	}
	s.NameValue = &v
	return s
}

// NewUserBase creates a new UserBase instance
func NewUserBase() UserBase {
	return &UserBaseImpl{}
}

// The date and time when the user was created.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.672531199e+12
func (s UserBaseImpl) CreatedAt() *UtcMs {
	return s.CreatedAtValue
}

// The date and time when the user was created.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.672531199e+12
func (s *UserBaseImpl) SetCreatedAt(v UtcMs) UserBase {
	if s == nil {
		return nil
	}
	s.CreatedAtValue = &v
	return s
}

// User's email. Required for password recovery.
// Format: email (email)
// Example: user@example.com
func (s UserBaseImpl) Email() *Email {
	return s.EmailValue
}

// User's email. Required for password recovery.
// Format: email (email)
// Example: user@example.com
func (s *UserBaseImpl) SetEmail(v Email) UserBase {
	if s == nil {
		return nil
	}
	s.EmailValue = &v
	return s
}

// The user's full name.
func (s UserBaseImpl) Fullname() *string {
	return s.FullnameValue
}

// The user's full name.
func (s *UserBaseImpl) SetFullname(v string) UserBase {
	if s == nil {
		return nil
	}
	s.FullnameValue = &v
	return s
}

// The language, selected by user.
// Format: ISO 639-1
// Example: en
func (s UserBaseImpl) Locale() *ISO6391 {
	return s.LocaleValue
}

// The language, selected by user.
// Format: ISO 639-1
// Example: en
func (s *UserBaseImpl) SetLocale(v ISO6391) UserBase {
	if s == nil {
		return nil
	}
	s.LocaleValue = &v
	return s
}

// The maximum number of sessions the user can have simultaneously.
func (s UserBaseImpl) MaxSessions() *int {
	return s.MaxSessionsValue
}

// The maximum number of sessions the user can have simultaneously.
func (s *UserBaseImpl) SetMaxSessions(v int) UserBase {
	if s == nil {
		return nil
	}
	s.MaxSessionsValue = &v
	return s
}

// User name (login)
func (s UserBaseImpl) Name() *string {
	return s.NameValue
}

// User name (login)
func (s *UserBaseImpl) SetName(v string) UserBase {
	if s == nil {
		return nil
	}
	s.NameValue = &v
	return s
}

// Additional information or notes about the user.
func (s UserBaseImpl) Note() *string {
	return s.NoteValue
}

// Additional information or notes about the user.
func (s *UserBaseImpl) SetNote(v string) UserBase {
	if s == nil {
		return nil
	}
	s.NoteValue = &v
	return s
}

// The specified password will be saved as a hash, used only for writing
func (s UserBaseImpl) Password() *string {
	return s.PasswordValue
}

// The specified password will be saved as a hash, used only for writing
func (s *UserBaseImpl) SetPassword(v string) UserBase {
	if s == nil {
		return nil
	}
	s.PasswordValue = &v
	return s
}

// User's phone number
// Format: phone-number (phone-number)
// Example: +78007778413
func (s UserBaseImpl) Phone() *PhoneNumber {
	return s.PhoneValue
}

// User's phone number
// Format: phone-number (phone-number)
// Example: +78007778413
func (s *UserBaseImpl) SetPhone(v PhoneNumber) UserBase {
	if s == nil {
		return nil
	}
	s.PhoneValue = &v
	return s
}

// NewUserCreate creates a new UserCreate instance
func NewUserCreate() UserCreate {
	return &UserCreateImpl{}
}

// The parameter regulates the rights for the user
// Example: generic
func (s UserCreateImpl) AccessLevel() *UserAdminAccessLevel {
	return s.AccessLevelValue
}

// The parameter regulates the rights for the user
// Example: generic
func (s *UserCreateImpl) SetAccessLevel(v UserAdminAccessLevel) UserCreate {
	if s == nil {
		return nil
	}
	s.AccessLevelValue = &v
	return s
}

// The date and time when the user was created.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.672531199e+12
func (s UserCreateImpl) CreatedAt() *UtcMs {
	return s.CreatedAtValue
}

// The date and time when the user was created.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.672531199e+12
func (s *UserCreateImpl) SetCreatedAt(v UtcMs) UserCreate {
	if s == nil {
		return nil
	}
	s.CreatedAtValue = &v
	return s
}

// A parameter that allows you to enable/disable the user
// Example: false
func (s UserCreateImpl) Disabled() *bool {
	return s.DisabledValue
}

// A parameter that allows you to enable/disable the user
// Example: false
func (s *UserCreateImpl) SetDisabled(v bool) UserCreate {
	if s == nil {
		return nil
	}
	s.DisabledValue = &v
	return s
}

// User's email. Required for password recovery.
// Format: email (email)
// Example: user@example.com
func (s UserCreateImpl) Email() *Email {
	return s.EmailValue
}

// User's email. Required for password recovery.
// Format: email (email)
// Example: user@example.com
func (s *UserCreateImpl) SetEmail(v Email) UserCreate {
	if s == nil {
		return nil
	}
	s.EmailValue = &v
	return s
}

// The user's full name.
func (s UserCreateImpl) Fullname() *string {
	return s.FullnameValue
}

// The user's full name.
func (s *UserCreateImpl) SetFullname(v string) UserCreate {
	if s == nil {
		return nil
	}
	s.FullnameValue = &v
	return s
}

// Identifier of the user.
// Example: 1
func (s UserCreateImpl) ID() *int {
	return s.IDValue
}

// Identifier of the user.
// Example: 1
func (s *UserCreateImpl) SetID(v int) UserCreate {
	if s == nil {
		return nil
	}
	s.IDValue = &v
	return s
}

// The language, selected by user.
// Format: ISO 639-1
// Example: en
func (s UserCreateImpl) Locale() *ISO6391 {
	return s.LocaleValue
}

// The language, selected by user.
// Format: ISO 639-1
// Example: en
func (s *UserCreateImpl) SetLocale(v ISO6391) UserCreate {
	if s == nil {
		return nil
	}
	s.LocaleValue = &v
	return s
}

// The maximum number of sessions the user can have simultaneously.
func (s UserCreateImpl) MaxSessions() *int {
	return s.MaxSessionsValue
}

// The maximum number of sessions the user can have simultaneously.
func (s *UserCreateImpl) SetMaxSessions(v int) UserCreate {
	if s == nil {
		return nil
	}
	s.MaxSessionsValue = &v
	return s
}

// User name (login)
func (s UserCreateImpl) Name() *string {
	return s.NameValue
}

// User name (login)
func (s *UserCreateImpl) SetName(v string) UserCreate {
	if s == nil {
		return nil
	}
	s.NameValue = &v
	return s
}

// Additional information or notes about the user.
func (s UserCreateImpl) Note() *string {
	return s.NoteValue
}

// Additional information or notes about the user.
func (s *UserCreateImpl) SetNote(v string) UserCreate {
	if s == nil {
		return nil
	}
	s.NoteValue = &v
	return s
}

// The identifier of the Organization to which the user should be added.
// If no organization_id - default organization should be used.
// Example: 12
func (s UserCreateImpl) OrganizationID() *int {
	return s.OrganizationIDValue
}

// The identifier of the Organization to which the user should be added.
// If no organization_id - default organization should be used.
// Example: 12
func (s *UserCreateImpl) SetOrganizationID(v int) UserCreate {
	if s == nil {
		return nil
	}
	s.OrganizationIDValue = &v
	return s
}

// A parameter indicating that the user belongs to certain organizations
func (s UserCreateImpl) Organizations() []UserAdminOrganizationsItem {
	if s.OrganizationsValue == nil {
		return nil
	}
	result := make([]UserAdminOrganizationsItem, len(s.OrganizationsValue))
	for i, item := range s.OrganizationsValue {
		result[i] = item
	}
	return result
}

// A parameter indicating that the user belongs to certain organizations
func (s *UserCreateImpl) SetOrganizations(v []UserAdminOrganizationsItem) UserCreate {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*UserAdminOrganizationsItemImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*UserAdminOrganizationsItemImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.OrganizationsValue = impl
	}
	return s
}

// The specified password will be saved as a hash, used only for writing
func (s UserCreateImpl) Password() *string {
	return s.PasswordValue
}

// The specified password will be saved as a hash, used only for writing
func (s *UserCreateImpl) SetPassword(v string) UserCreate {
	if s == nil {
		return nil
	}
	s.PasswordValue = &v
	return s
}

// User's phone number
// Format: phone-number (phone-number)
// Example: +78007778413
func (s UserCreateImpl) Phone() *PhoneNumber {
	return s.PhoneValue
}

// User's phone number
// Format: phone-number (phone-number)
// Example: +78007778413
func (s *UserCreateImpl) SetPhone(v PhoneNumber) UserCreate {
	if s == nil {
		return nil
	}
	s.PhoneValue = &v
	return s
}

// A flag indicating that the user has read-only access and cannot modify their own data.
// Example: false
func (s UserCreateImpl) Readonly() *bool {
	return s.ReadonlyValue
}

// A flag indicating that the user has read-only access and cannot modify their own data.
// Example: false
func (s *UserCreateImpl) SetReadonly(v bool) UserCreate {
	if s == nil {
		return nil
	}
	s.ReadonlyValue = &v
	return s
}

// NewUsers creates a new Users instance
func NewUsers() Users {
	return &UsersImpl{}
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s UsersImpl) EstimatedCount() *int {
	return s.EstimatedCountValue
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s *UsersImpl) SetEstimatedCount(v int) Users {
	if s == nil {
		return nil
	}
	s.EstimatedCountValue = &v
	return s
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s UsersImpl) Next() *string {
	return s.NextValue
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s *UsersImpl) SetNext(v string) Users {
	if s == nil {
		return nil
	}
	s.NextValue = &v
	return s
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s UsersImpl) Prev() *string {
	return s.PrevValue
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s *UsersImpl) SetPrev(v string) Users {
	if s == nil {
		return nil
	}
	s.PrevValue = &v
	return s
}

// An object with a list of different timings measured during this API call.
func (s UsersImpl) Timing() any {
	return s.TimingValue
}

// An object with a list of different timings measured during this API call.
func (s *UsersImpl) SetTiming(v any) Users {
	if s == nil {
		return nil
	}
	s.TimingValue = v
	return s
}

// List of fetched users according to the query parameters.
func (s UsersImpl) UsersList() []User {
	if s.UsersListValue == nil {
		return nil
	}
	result := make([]User, len(s.UsersListValue))
	for i, item := range s.UsersListValue {
		result[i] = item
	}
	return result
}

// List of fetched users according to the query parameters.
func (s *UsersImpl) SetUsersList(v []User) Users {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*UserImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*UserImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.UsersListValue = impl
	}
	return s
}

// Collection returns the collection items from Users
func (s UsersImpl) Collection() []User {
	return s.UsersList()
}

// NewVisionAlerts creates a new VisionAlerts instance
func NewVisionAlerts() VisionAlerts {
	return &VisionAlertsImpl{}
}

// The time when an episode could not be created due to low detection quality (on blurry or noisy frames).
// It may be caused by uncertainty when the picture is not clear enough.
// Try adjusting the shutter speed parameters on your camera.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s VisionAlertsImpl) LowQualityAt() *UtcMs {
	return s.LowQualityAtValue
}

// The time when an episode could not be created due to low detection quality (on blurry or noisy frames).
// It may be caused by uncertainty when the picture is not clear enough.
// Try adjusting the shutter speed parameters on your camera.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s *VisionAlertsImpl) SetLowQualityAt(v UtcMs) VisionAlerts {
	if s == nil {
		return nil
	}
	s.LowQualityAtValue = &v
	return s
}

// The time when an episode could not be created due to insufficient detections.
// The issue occurs when the selected detector is unable to find the target object enough times.
// It is possible that the target object appears shortly or is obscured by something.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s VisionAlertsImpl) NotEnoughDetectionsAt() *UtcMs {
	return s.NotEnoughDetectionsAtValue
}

// The time when an episode could not be created due to insufficient detections.
// The issue occurs when the selected detector is unable to find the target object enough times.
// It is possible that the target object appears shortly or is obscured by something.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s *VisionAlertsImpl) SetNotEnoughDetectionsAt(v UtcMs) VisionAlerts {
	if s == nil {
		return nil
	}
	s.NotEnoughDetectionsAtValue = &v
	return s
}

// The time when an episode could not be created due to the small size of detections relative to the detector internal settings.
// The camera placement may need to be adjusted closer to the target objects.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s VisionAlertsImpl) SmallSizeAt() *UtcMs {
	return s.SmallSizeAtValue
}

// The time when an episode could not be created due to the small size of detections relative to the detector internal settings.
// The camera placement may need to be adjusted closer to the target objects.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s *VisionAlertsImpl) SetSmallSizeAt(v UtcMs) VisionAlerts {
	if s == nil {
		return nil
	}
	s.SmallSizeAtValue = &v
	return s
}

// NewVisionDetectorConfig creates a new VisionDetectorConfig instance
func NewVisionDetectorConfig() VisionDetectorConfig {
	return &VisionDetectorConfigImpl{}
}

func (s VisionDetectorConfigImpl) DetectorType() VisionDetectorConfigDetectorType {
	return s.DetectorTypeValue
}

func (s *VisionDetectorConfigImpl) SetDetectorType(v VisionDetectorConfigDetectorType) VisionDetectorConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionDetectorConfigDetectorTypeImpl); ok {
		s.DetectorTypeValue = impl
	}
	return s
}

func (s VisionDetectorConfigImpl) RegionCoordinates() VisionDetectorConfigRegionCoordinates {
	return s.RegionCoordinatesValue
}

func (s *VisionDetectorConfigImpl) SetRegionCoordinates(v VisionDetectorConfigRegionCoordinates) VisionDetectorConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionDetectorConfigRegionCoordinatesImpl); ok {
		s.RegionCoordinatesValue = impl
	}
	return s
}

// Identifier of the detection area.
// It is used to distinguish episodes from various regions of interest within the frame.
// For instance, it can be used with a single camera facing two entrances to count visitors independently at each entrance.
func (s VisionDetectorConfigImpl) RegionID() string {
	return s.RegionIDValue
}

// Identifier of the detection area.
// It is used to distinguish episodes from various regions of interest within the frame.
// For instance, it can be used with a single camera facing two entrances to count visitors independently at each entrance.
func (s *VisionDetectorConfigImpl) SetRegionID(v string) VisionDetectorConfig {
	if s == nil {
		return nil
	}
	s.RegionIDValue = v
	return s
}

// Name of the detection area
// Example: Zone 1
func (s VisionDetectorConfigImpl) RegionTitle() *string {
	return s.RegionTitleValue
}

// Name of the detection area
// Example: Zone 1
func (s *VisionDetectorConfigImpl) SetRegionTitle(v string) VisionDetectorConfig {
	if s == nil {
		return nil
	}
	s.RegionTitleValue = &v
	return s
}

// Runtime information about the vision process.
func (s VisionDetectorConfigImpl) Stats() VisionDetectorStats {
	return s.StatsValue
}

// Runtime information about the vision process.
func (s *VisionDetectorConfigImpl) SetStats(v VisionDetectorStats) VisionDetectorConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionDetectorStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// NewVisionDetectorConfigDetectorType creates a new VisionDetectorConfigDetectorType instance
func NewVisionDetectorConfigDetectorType() VisionDetectorConfigDetectorType {
	return &VisionDetectorConfigDetectorTypeImpl{}
}

// NewVisionDetectorConfigRegionCoordinates creates a new VisionDetectorConfigRegionCoordinates instance
func NewVisionDetectorConfigRegionCoordinates() VisionDetectorConfigRegionCoordinates {
	return &VisionDetectorConfigRegionCoordinatesImpl{}
}

// NewVisionDetectorStats creates a new VisionDetectorStats instance
func NewVisionDetectorStats() VisionDetectorStats {
	return &VisionDetectorStatsImpl{}
}

// Identifies analytics issues related to frames in a stream that impact episode creation
func (s VisionDetectorStatsImpl) Alerts() VisionAlerts {
	return s.AlertsValue
}

// Identifies analytics issues related to frames in a stream that impact episode creation
func (s *VisionDetectorStatsImpl) SetAlerts(v VisionAlerts) VisionDetectorStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionAlertsImpl); ok {
		s.AlertsValue = impl
	}
	return s
}

// The time when there was the last detection. Constant updates mean that analytics can detect objects on frames.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s VisionDetectorStatsImpl) LastDetectionAt() *UtcMs {
	return s.LastDetectionAtValue
}

// The time when there was the last detection. Constant updates mean that analytics can detect objects on frames.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s *VisionDetectorStatsImpl) SetLastDetectionAt(v UtcMs) VisionDetectorStats {
	if s == nil {
		return nil
	}
	s.LastDetectionAtValue = &v
	return s
}

// NewVisionPoint creates a new VisionPoint instance
func NewVisionPoint() VisionPoint {
	return &VisionPointImpl{}
}

// X coordinate. Fraction of full frame width
// Examples: 0.54, 0.78
func (s VisionPointImpl) X() float64 {
	return s.XValue
}

// X coordinate. Fraction of full frame width
// Examples: 0.54, 0.78
func (s *VisionPointImpl) SetX(v float64) VisionPoint {
	if s == nil {
		return nil
	}
	s.XValue = v
	return s
}

// Y coordinate. Fraction of full frame height
// Examples: 0.12, 0.38
func (s VisionPointImpl) Y() float64 {
	return s.YValue
}

// Y coordinate. Fraction of full frame height
// Examples: 0.12, 0.38
func (s *VisionPointImpl) SetY(v float64) VisionPoint {
	if s == nil {
		return nil
	}
	s.YValue = v
	return s
}

// NewVisionSpec creates a new VisionSpec instance
func NewVisionSpec() VisionSpec {
	return &VisionSpecImpl{}
}

// The algorithm used for video analytics.
// Example: faces
func (s VisionSpecImpl) Alg() *VisionSpecAlg {
	return s.AlgValue
}

// The algorithm used for video analytics.
// Example: faces
func (s *VisionSpecImpl) SetAlg(v VisionSpecAlg) VisionSpec {
	if s == nil {
		return nil
	}
	s.AlgValue = &v
	return s
}

// This parameter allows you to select specific polygonal area(s) for detection.
// By default, it is empty, and the recognition system searches over the entire camera field of view.
// Each area is specified as a sequence of comma-separated coordinates of vertices of the polygon: `x0,y0,x1,y1,x2,y2,...`.
// The vertices are specified in a counter-clockwise direction. Multiple areas are separated by `:`.
func (s VisionSpecImpl) Areas() *string {
	return s.AreasValue
}

// This parameter allows you to select specific polygonal area(s) for detection.
// By default, it is empty, and the recognition system searches over the entire camera field of view.
// Each area is specified as a sequence of comma-separated coordinates of vertices of the polygon: `x0,y0,x1,y1,x2,y2,...`.
// The vertices are specified in a counter-clockwise direction. Multiple areas are separated by `:`.
func (s *VisionSpecImpl) SetAreas(v string) VisionSpec {
	if s == nil {
		return nil
	}
	s.AreasValue = &v
	return s
}

// Configuration of videoanalytics modules.
// This configuration supersedes `alg` and `areas` parameters.
// If this field is specified, values of `alg` and `areas` fields are being ignored.
func (s VisionSpecImpl) Detectors() []VisionDetectorConfig {
	if s.DetectorsValue == nil {
		return nil
	}
	result := make([]VisionDetectorConfig, len(s.DetectorsValue))
	for i, item := range s.DetectorsValue {
		result[i] = item
	}
	return result
}

// Configuration of videoanalytics modules.
// This configuration supersedes `alg` and `areas` parameters.
// If this field is specified, values of `alg` and `areas` fields are being ignored.
func (s *VisionSpecImpl) SetDetectors(v []VisionDetectorConfig) VisionSpec {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*VisionDetectorConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*VisionDetectorConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.DetectorsValue = impl
	}
	return s
}

// NewVisionSpecPresets creates a new VisionSpecPresets instance
func NewVisionSpecPresets() VisionSpecPresets {
	return &VisionSpecPresetsImpl{}
}

// The algorithm used for video analytics.
// Example: faces
func (s VisionSpecPresetsImpl) Alg() *VisionSpecPresetsAlg {
	return s.AlgValue
}

// The algorithm used for video analytics.
// Example: faces
func (s *VisionSpecPresetsImpl) SetAlg(v VisionSpecPresetsAlg) VisionSpecPresets {
	if s == nil {
		return nil
	}
	s.AlgValue = &v
	return s
}

// NewVodConfig creates a new VodConfig instance
func NewVodConfig() VodConfig {
	return &VodConfigImpl{}
}

// Whether to add an audio-only version of an HLS stream.
// Used to create App Store compliant HLS streams to deliver the content to Apple iOS devices.
// Add audio-only HLS playlist to variant MBR playlist for iOS compliant streaming.
// Example: false
func (s VodConfigImpl) AddAudioOnly() *bool {
	return s.AddAudioOnlyValue
}

// Whether to add an audio-only version of an HLS stream.
// Used to create App Store compliant HLS streams to deliver the content to Apple iOS devices.
// Add audio-only HLS playlist to variant MBR playlist for iOS compliant streaming.
// Example: false
func (s *VodConfigImpl) SetAddAudioOnly(v bool) VodConfig {
	if s == nil {
		return nil
	}
	s.AddAudioOnlyValue = &v
	return s
}

// Turns on automatic creation of a multi-bitrate HLS playlist from several files with different bitrates.
func (s VodConfigImpl) AutoMbr() *bool {
	return s.AutoMbrValue
}

// Turns on automatic creation of a multi-bitrate HLS playlist from several files with different bitrates.
func (s *VodConfigImpl) SetAutoMbr(v bool) VodConfig {
	if s == nil {
		return nil
	}
	s.AutoMbrValue = &v
	return s
}

// Configuraton of the local file cache which is used for files from a cloud or an HTTP server.
// If this option is enabled, a file will be downloaded to a local cache path by megabyte blocks.
// During playback, the file will be first read from the cache.
// This allows to avoid multiple HTTP requests to the source for each part of data and, thus, to speed up broadcasting.
func (s VodConfigImpl) Cache() CacheSpec {
	return s.CacheValue
}

// Configuraton of the local file cache which is used for files from a cloud or an HTTP server.
// If this option is enabled, a file will be downloaded to a local cache path by megabyte blocks.
// During playback, the file will be first read from the cache.
// This allows to avoid multiple HTTP requests to the source for each part of data and, thus, to speed up broadcasting.
func (s *VodConfigImpl) SetCache(v CacheSpec) VodConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*CacheSpecImpl); ok {
		s.CacheValue = impl
	}
	return s
}

// Whether this VOD location is disabled.
// Example: false
func (s VodConfigImpl) Disabled() *bool {
	return s.DisabledValue
}

// Whether this VOD location is disabled.
// Example: false
func (s *VodConfigImpl) SetDisabled(v bool) VodConfig {
	if s == nil {
		return nil
	}
	s.DisabledValue = &v
	return s
}

// Enables downloading files from the URL `http://FLUSSONIC-IP:80/vod_prefix/file_subpath.mp4`.
// The `Range` HTTP headers are supported.
// Example: false
func (s VodConfigImpl) Download() *bool {
	return s.DownloadValue
}

// Enables downloading files from the URL `http://FLUSSONIC-IP:80/vod_prefix/file_subpath.mp4`.
// The `Range` HTTP headers are supported.
// Example: false
func (s *VodConfigImpl) SetDownload(v bool) VodConfig {
	if s == nil {
		return nil
	}
	s.DownloadValue = &v
	return s
}

// Configuraton of the content encryption (DRM).
func (s VodConfigImpl) Drm() DrmSpec {
	return s.DrmValue
}

// Configuraton of the content encryption (DRM).
func (s *VodConfigImpl) SetDrm(v DrmSpec) VodConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*DrmSpecImpl); ok {
		s.DrmValue = impl
	}
	return s
}

// Overlay logo.
func (s VodConfigImpl) Logo() WebLogoSpec {
	return s.LogoValue
}

// Overlay logo.
func (s *VodConfigImpl) SetLogo(v WebLogoSpec) VodConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*WebLogoSpecImpl); ok {
		s.LogoValue = impl
	}
	return s
}

// Configuraton of the authorization backend for play sessions **only**.
func (s VodConfigImpl) OnPlay() AuthSpec {
	return s.OnPlayValue
}

// Configuraton of the authorization backend for play sessions **only**.
func (s *VodConfigImpl) SetOnPlay(v AuthSpec) VodConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*AuthSpecImpl); ok {
		s.OnPlayValue = impl
	}
	return s
}

// If an order of VOD locations is declared, it is a position of the this VOD location in the order.
// Format: sort_index (sort_index)
// Example: 1
func (s VodConfigImpl) Position() *SortIndex {
	return s.PositionValue
}

// If an order of VOD locations is declared, it is a position of the this VOD location in the order.
// Format: sort_index (sort_index)
// Example: 1
func (s *VodConfigImpl) SetPosition(v SortIndex) VodConfig {
	if s == nil {
		return nil
	}
	s.PositionValue = &v
	return s
}

// The unique name of VOD location.
// It is used as a prefix in file playback requests to explicitly specify where the system should find the files for playing.
// All the path after the prefix will be cut and added to the specified path on the disk (the storage configured for this VOD location).
// Thus, the system will find the file on the disk and play it.
// Format: media_name (media_name)
// Example: movies
func (s VodConfigImpl) Prefix() *MediaName {
	return s.PrefixValue
}

// The unique name of VOD location.
// It is used as a prefix in file playback requests to explicitly specify where the system should find the files for playing.
// All the path after the prefix will be cut and added to the specified path on the disk (the storage configured for this VOD location).
// Thus, the system will find the file on the disk and play it.
// Format: media_name (media_name)
// Example: movies
func (s *VodConfigImpl) SetPrefix(v MediaName) VodConfig {
	if s == nil {
		return nil
	}
	s.PrefixValue = &v
	return s
}

// Configuraton of play protocols.
func (s VodConfigImpl) Protocols() PlayProtocolsSpec {
	return s.ProtocolsValue
}

// Configuraton of play protocols.
func (s *VodConfigImpl) SetProtocols(v PlayProtocolsSpec) VodConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*PlayProtocolsSpecImpl); ok {
		s.ProtocolsValue = impl
	}
	return s
}

// Human-readable name of the content provider. Applicable to MPEG-TS.
func (s VodConfigImpl) Provider() *string {
	return s.ProviderValue
}

// Human-readable name of the content provider. Applicable to MPEG-TS.
func (s *VodConfigImpl) SetProvider(v string) VodConfig {
	if s == nil {
		return nil
	}
	s.ProviderValue = &v
	return s
}

// The number of simultaneous readers form disk that should wait in a queue for playing a file.
// Example: 100
func (s VodConfigImpl) ReadQueue() *int {
	return s.ReadQueueValue
}

// The number of simultaneous readers form disk that should wait in a queue for playing a file.
// Example: 100
func (s *VodConfigImpl) SetReadQueue(v int) VodConfig {
	if s == nil {
		return nil
	}
	s.ReadQueueValue = &v
	return s
}

// The time, in seconds, of the segment duration. Used for the protocols like HLS or DASH.
func (s VodConfigImpl) SegmentDuration() *Milliseconds {
	return s.SegmentDurationValue
}

// The time, in seconds, of the segment duration. Used for the protocols like HLS or DASH.
func (s *VodConfigImpl) SetSegmentDuration(v Milliseconds) VodConfig {
	if s == nil {
		return nil
	}
	s.SegmentDurationValue = &v
	return s
}

// The directories (on disk or on another server) that Flussonic scans for VOD files.
func (s VodConfigImpl) Storages() []VodStorage {
	if s.StoragesValue == nil {
		return nil
	}
	result := make([]VodStorage, len(s.StoragesValue))
	for i, item := range s.StoragesValue {
		result[i] = item
	}
	return result
}

// The directories (on disk or on another server) that Flussonic scans for VOD files.
func (s *VodConfigImpl) SetStorages(v []VodStorage) VodConfig {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*VodStorageImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*VodStorageImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.StoragesValue = impl
	}
	return s
}

// Configuration of thumbnails generator.
func (s VodConfigImpl) Thumbnails() ThumbnailsSpec {
	return s.ThumbnailsValue
}

// Configuration of thumbnails generator.
func (s *VodConfigImpl) SetThumbnails(v ThumbnailsSpec) VodConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ThumbnailsSpecImpl); ok {
		s.ThumbnailsValue = impl
	}
	return s
}

// The time (in milliseconds) passed since the last file request.
// If the file was not requested within this period, it will be closed and its resources will be deallocated.
// Example: 3
func (s VodConfigImpl) Timeout() *int {
	return s.TimeoutValue
}

// The time (in milliseconds) passed since the last file request.
// If the file was not requested within this period, it will be closed and its resources will be deallocated.
// Example: 3
func (s *VodConfigImpl) SetTimeout(v int) VodConfig {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// The names of separate segments within a segment-based HLS or DASH playlist start with the *specified* prefix.
// The option no longer works for *variant playlists*.
func (s VodConfigImpl) URLPrefix() *URLPrefix {
	return s.URLPrefixValue
}

// The names of separate segments within a segment-based HLS or DASH playlist start with the *specified* prefix.
// The option no longer works for *variant playlists*.
func (s *VodConfigImpl) SetURLPrefix(v *URLPrefix) VodConfig {
	if s == nil {
		return nil
	}
	s.URLPrefixValue = v
	return s
}

// NewVodStorage creates a new VodStorage instance
func NewVodStorage() VodStorage {
	return &VodStorageImpl{}
}

// Some additional options.
func (s VodStorageImpl) Extra() map[string]string {
	return s.ExtraValue
}

// Some additional options.
func (s *VodStorageImpl) SetExtra(v map[string]string) VodStorage {
	if s == nil {
		return nil
	}
	s.ExtraValue = v
	return s
}

// The storage (on the disk or on another server) that Flussonic will scan for VOD files.
// If it is a path on the disk, it should be specified relating to the disk root.
// It is possible to specify multiple storages for one VOD location. When Flussonic gets the URL for playing the file, it finds the prefix in this URL,
// cuts the path after it and consequently searches for this path in all specified storages.
// Example: /storage
func (s VodStorageImpl) URL() *string {
	return s.URLValue
}

// The storage (on the disk or on another server) that Flussonic will scan for VOD files.
// If it is a path on the disk, it should be specified relating to the disk root.
// It is possible to specify multiple storages for one VOD location. When Flussonic gets the URL for playing the file, it finds the prefix in this URL,
// cuts the path after it and consequently searches for this path in all specified storages.
// Example: /storage
func (s *VodStorageImpl) SetURL(v string) VodStorage {
	if s == nil {
		return nil
	}
	s.URLValue = &v
	return s
}

// NewVsaasConfig creates a new VsaasConfig instance
func NewVsaasConfig() VsaasConfig {
	return &VsaasConfigImpl{}
}

// All requests to /central will be proxied to this url.
func (s VsaasConfigImpl) CentralURL() *string {
	return s.CentralURLValue
}

// All requests to /central will be proxied to this url.
func (s *VsaasConfigImpl) SetCentralURL(v string) VsaasConfig {
	if s == nil {
		return nil
	}
	s.CentralURLValue = &v
	return s
}

// All requests to /vsaas and /watcher will be proxied to this url.
// Watcher will not be launched by flussonic with this option.
func (s VsaasConfigImpl) WatcherURL() *string {
	return s.WatcherURLValue
}

// All requests to /vsaas and /watcher will be proxied to this url.
// Watcher will not be launched by flussonic with this option.
func (s *VsaasConfigImpl) SetWatcherURL(v string) VsaasConfig {
	if s == nil {
		return nil
	}
	s.WatcherURLValue = &v
	return s
}

// NewWatcherAgentConfig creates a new WatcherAgentConfig instance
func NewWatcherAgentConfig() WatcherAgentConfig {
	return &WatcherAgentConfigImpl{}
}

// Agent identifier
// Example: 1234567
func (s WatcherAgentConfigImpl) ID() *string {
	return s.IDValue
}

// Agent identifier
// Example: 1234567
func (s *WatcherAgentConfigImpl) SetID(v string) WatcherAgentConfig {
	if s == nil {
		return nil
	}
	s.IDValue = &v
	return s
}

// Agent authentication key.
func (s WatcherAgentConfigImpl) Key() *string {
	return s.KeyValue
}

// Agent authentication key.
func (s *WatcherAgentConfigImpl) SetKey(v string) WatcherAgentConfig {
	if s == nil {
		return nil
	}
	s.KeyValue = &v
	return s
}

// The model of the camera with [Agent](https://flussonic.com/doc/agent-with-watcher/).
func (s WatcherAgentConfigImpl) Model() *string {
	return s.ModelValue
}

// The model of the camera with [Agent](https://flussonic.com/doc/agent-with-watcher/).
func (s *WatcherAgentConfigImpl) SetModel(v string) WatcherAgentConfig {
	if s == nil {
		return nil
	}
	s.ModelValue = &v
	return s
}

// The device (camera or router) serial number.
func (s WatcherAgentConfigImpl) Serial() *string {
	return s.SerialValue
}

// The device (camera or router) serial number.
func (s *WatcherAgentConfigImpl) SetSerial(v string) WatcherAgentConfig {
	if s == nil {
		return nil
	}
	s.SerialValue = &v
	return s
}

// Agents's metrics and other statistical information.
func (s WatcherAgentConfigImpl) Stats() WatcherAgentStats {
	return s.StatsValue
}

// Agents's metrics and other statistical information.
func (s *WatcherAgentConfigImpl) SetStats(v WatcherAgentStats) WatcherAgentConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*WatcherAgentStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// List of streams info that have this agent in their inputs
func (s WatcherAgentConfigImpl) Streams() []any {
	return s.StreamsValue
}

// List of streams info that have this agent in their inputs
func (s *WatcherAgentConfigImpl) SetStreams(v []any) WatcherAgentConfig {
	if s == nil {
		return nil
	}
	s.StreamsValue = v
	return s
}

// NewWatcherAgentControlConnection creates a new WatcherAgentControlConnection instance
func NewWatcherAgentControlConnection() WatcherAgentControlConnection {
	return &WatcherAgentControlConnectionImpl{}
}

// A flag showing if Agent is connected at the moment of the request.
func (s WatcherAgentControlConnectionImpl) Alive() *bool {
	return s.AliveValue
}

// A flag showing if Agent is connected at the moment of the request.
func (s *WatcherAgentControlConnectionImpl) SetAlive(v bool) WatcherAgentControlConnection {
	if s == nil {
		return nil
	}
	s.AliveValue = &v
	return s
}

// A number of bytes received from the server by Agent since `opened_at`.
// Format: bytes (bytes)
// Example: 40000
func (s WatcherAgentControlConnectionImpl) BytesFromServer() *Bytes {
	return s.BytesFromServerValue
}

// A number of bytes received from the server by Agent since `opened_at`.
// Format: bytes (bytes)
// Example: 40000
func (s *WatcherAgentControlConnectionImpl) SetBytesFromServer(v Bytes) WatcherAgentControlConnection {
	if s == nil {
		return nil
	}
	s.BytesFromServerValue = &v
	return s
}

// A number of bytes sent to the server by Agent since `opened_at`.
// Format: bytes (bytes)
// Example: 4e+11
func (s WatcherAgentControlConnectionImpl) BytesToServer() *Bytes {
	return s.BytesToServerValue
}

// A number of bytes sent to the server by Agent since `opened_at`.
// Format: bytes (bytes)
// Example: 4e+11
func (s *WatcherAgentControlConnectionImpl) SetBytesToServer(v Bytes) WatcherAgentControlConnection {
	if s == nil {
		return nil
	}
	s.BytesToServerValue = &v
	return s
}

// Hostname of the server
// Example: agents-001.vsaas.io
func (s WatcherAgentControlConnectionImpl) Hostname() *string {
	return s.HostnameValue
}

// Hostname of the server
// Example: agents-001.vsaas.io
func (s *WatcherAgentControlConnectionImpl) SetHostname(v string) WatcherAgentControlConnection {
	if s == nil {
		return nil
	}
	s.HostnameValue = &v
	return s
}

// Timestamp of the current Agent control connection opening.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s WatcherAgentControlConnectionImpl) OpenedAt() *UtcMs {
	return s.OpenedAtValue
}

// Timestamp of the current Agent control connection opening.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s *WatcherAgentControlConnectionImpl) SetOpenedAt(v UtcMs) WatcherAgentControlConnection {
	if s == nil {
		return nil
	}
	s.OpenedAtValue = &v
	return s
}

// UTC timestamp of the last Agent status change to offline or online.
// Same as `opened_at` if Agent is now connected.
// Format: utc (Unix timestamp in seconds)
// Example: 1.634560921e+09
func (s WatcherAgentControlConnectionImpl) StatusChangedAt() *Utc {
	return s.StatusChangedAtValue
}

// UTC timestamp of the last Agent status change to offline or online.
// Same as `opened_at` if Agent is now connected.
// Format: utc (Unix timestamp in seconds)
// Example: 1.634560921e+09
func (s *WatcherAgentControlConnectionImpl) SetStatusChangedAt(v Utc) WatcherAgentControlConnection {
	if s == nil {
		return nil
	}
	s.StatusChangedAtValue = &v
	return s
}

// NewWatcherAgentDataConnections creates a new WatcherAgentDataConnections instance
func NewWatcherAgentDataConnections() WatcherAgentDataConnections {
	return &WatcherAgentDataConnectionsImpl{}
}

// A number of times the streamer tried to open a data connection via this Agent.
// Example: 400
func (s WatcherAgentDataConnectionsImpl) ConnectionsAttempted() *int {
	return s.ConnectionsAttemptedValue
}

// A number of times the streamer tried to open a data connection via this Agent.
// Example: 400
func (s *WatcherAgentDataConnectionsImpl) SetConnectionsAttempted(v int) WatcherAgentDataConnections {
	if s == nil {
		return nil
	}
	s.ConnectionsAttemptedValue = &v
	return s
}

// A number of currently active data connections opened via this Agent.
// Example: 2
func (s WatcherAgentDataConnectionsImpl) ConnectionsCurrent() *int {
	return s.ConnectionsCurrentValue
}

// A number of currently active data connections opened via this Agent.
// Example: 2
func (s *WatcherAgentDataConnectionsImpl) SetConnectionsCurrent(v int) WatcherAgentDataConnections {
	if s == nil {
		return nil
	}
	s.ConnectionsCurrentValue = &v
	return s
}

// A number of successfully opened data connections via this Agent.
// Example: 300
func (s WatcherAgentDataConnectionsImpl) ConnectionsOpened() *int {
	return s.ConnectionsOpenedValue
}

// A number of successfully opened data connections via this Agent.
// Example: 300
func (s *WatcherAgentDataConnectionsImpl) SetConnectionsOpened(v int) WatcherAgentDataConnections {
	if s == nil {
		return nil
	}
	s.ConnectionsOpenedValue = &v
	return s
}

// NewWatcherAgentStats creates a new WatcherAgentStats instance
func NewWatcherAgentStats() WatcherAgentStats {
	return &WatcherAgentStatsImpl{}
}

// The type of Agent installed on the device:
// * `single` means "one Agent = one camera", i.e. Agent is installed on a camera itself.
// * `router` means "one Agent = multiple cameras", i.e. Agent is installed on a router
// to provision the cameras from LAN to Watcher.
func (s WatcherAgentStatsImpl) AgentType() *string {
	return s.AgentTypeValue
}

// The type of Agent installed on the device:
// * `single` means "one Agent = one camera", i.e. Agent is installed on a camera itself.
// * `router` means "one Agent = multiple cameras", i.e. Agent is installed on a router
// to provision the cameras from LAN to Watcher.
func (s *WatcherAgentStatsImpl) SetAgentType(v string) WatcherAgentStats {
	if s == nil {
		return nil
	}
	s.AgentTypeValue = &v
	return s
}

// The number of successfully established connections.
func (s WatcherAgentStatsImpl) ConnectionsEstablished() *int {
	return s.ConnectionsEstablishedValue
}

// The number of successfully established connections.
func (s *WatcherAgentStatsImpl) SetConnectionsEstablished(v int) WatcherAgentStats {
	if s == nil {
		return nil
	}
	s.ConnectionsEstablishedValue = &v
	return s
}

// The number of connections requested by Agent.
func (s WatcherAgentStatsImpl) ConnectionsRequested() *int {
	return s.ConnectionsRequestedValue
}

// The number of connections requested by Agent.
func (s *WatcherAgentStatsImpl) SetConnectionsRequested(v int) WatcherAgentStats {
	if s == nil {
		return nil
	}
	s.ConnectionsRequestedValue = &v
	return s
}

// Parameters of the connection between Agent and its endpoint.
func (s WatcherAgentStatsImpl) EndpointConnection() WatcherAgentControlConnection {
	return s.EndpointConnectionValue
}

// Parameters of the connection between Agent and its endpoint.
func (s *WatcherAgentStatsImpl) SetEndpointConnection(v WatcherAgentControlConnection) WatcherAgentStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*WatcherAgentControlConnectionImpl); ok {
		s.EndpointConnectionValue = impl
	}
	return s
}

// IP address of the device (camera or router) in the local network.
// Format: ipv4 (ipv4)
// Example: 10.10.17.88
func (s WatcherAgentStatsImpl) LocalIP() *Ipv4 {
	return s.LocalIPValue
}

// IP address of the device (camera or router) in the local network.
// Format: ipv4 (ipv4)
// Example: 10.10.17.88
func (s *WatcherAgentStatsImpl) SetLocalIP(v Ipv4) WatcherAgentStats {
	if s == nil {
		return nil
	}
	s.LocalIPValue = &v
	return s
}

// MAC-address of the device.
// Example: F0-23-B9-59-20-F1
func (s WatcherAgentStatsImpl) MacAddress() *string {
	return s.MacAddressValue
}

// MAC-address of the device.
// Example: F0-23-B9-59-20-F1
func (s *WatcherAgentStatsImpl) SetMacAddress(v string) WatcherAgentStats {
	if s == nil {
		return nil
	}
	s.MacAddressValue = &v
	return s
}

// Public IP address of the device (camera or router) on which the Agent is running.
// Format: ipv4 (ipv4)
// Example: 185.134.232.183
func (s WatcherAgentStatsImpl) PeerIP() *Ipv4 {
	return s.PeerIPValue
}

// Public IP address of the device (camera or router) on which the Agent is running.
// Format: ipv4 (ipv4)
// Example: 185.134.232.183
func (s *WatcherAgentStatsImpl) SetPeerIP(v Ipv4) WatcherAgentStats {
	if s == nil {
		return nil
	}
	s.PeerIPValue = &v
	return s
}

// Parameters of the connection between Agent and its streampoint.
func (s WatcherAgentStatsImpl) StreampointConnection() WatcherAgentStatsStreampointConnection {
	return s.StreampointConnectionValue
}

// Parameters of the connection between Agent and its streampoint.
func (s *WatcherAgentStatsImpl) SetStreampointConnection(v WatcherAgentStatsStreampointConnection) WatcherAgentStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*WatcherAgentStatsStreampointConnectionImpl); ok {
		s.StreampointConnectionValue = impl
	}
	return s
}

// Agent version.
// Example: v21.02-8-g535c85d
func (s WatcherAgentStatsImpl) Version() *string {
	return s.VersionValue
}

// Agent version.
// Example: v21.02-8-g535c85d
func (s *WatcherAgentStatsImpl) SetVersion(v string) WatcherAgentStats {
	if s == nil {
		return nil
	}
	s.VersionValue = &v
	return s
}

// NewWatcherAgentStatsStreampointConnection creates a new WatcherAgentStatsStreampointConnection instance
func NewWatcherAgentStatsStreampointConnection() WatcherAgentStatsStreampointConnection {
	return &WatcherAgentStatsStreampointConnectionImpl{}
}

// A flag showing if Agent is connected at the moment of the request.
func (s WatcherAgentStatsStreampointConnectionImpl) Alive() *bool {
	return s.AliveValue
}

// A flag showing if Agent is connected at the moment of the request.
func (s *WatcherAgentStatsStreampointConnectionImpl) SetAlive(v bool) WatcherAgentStatsStreampointConnection {
	if s == nil {
		return nil
	}
	s.AliveValue = &v
	return s
}

// A number of bytes received from the server by Agent since `opened_at`.
// Format: bytes (bytes)
// Example: 40000
func (s WatcherAgentStatsStreampointConnectionImpl) BytesFromServer() *Bytes {
	return s.BytesFromServerValue
}

// A number of bytes received from the server by Agent since `opened_at`.
// Format: bytes (bytes)
// Example: 40000
func (s *WatcherAgentStatsStreampointConnectionImpl) SetBytesFromServer(v Bytes) WatcherAgentStatsStreampointConnection {
	if s == nil {
		return nil
	}
	s.BytesFromServerValue = &v
	return s
}

// A number of bytes sent to the server by Agent since `opened_at`.
// Format: bytes (bytes)
// Example: 4e+11
func (s WatcherAgentStatsStreampointConnectionImpl) BytesToServer() *Bytes {
	return s.BytesToServerValue
}

// A number of bytes sent to the server by Agent since `opened_at`.
// Format: bytes (bytes)
// Example: 4e+11
func (s *WatcherAgentStatsStreampointConnectionImpl) SetBytesToServer(v Bytes) WatcherAgentStatsStreampointConnection {
	if s == nil {
		return nil
	}
	s.BytesToServerValue = &v
	return s
}

// A number of times the streamer tried to open a data connection via this Agent.
// Example: 400
func (s WatcherAgentStatsStreampointConnectionImpl) ConnectionsAttempted() *int {
	return s.ConnectionsAttemptedValue
}

// A number of times the streamer tried to open a data connection via this Agent.
// Example: 400
func (s *WatcherAgentStatsStreampointConnectionImpl) SetConnectionsAttempted(v int) WatcherAgentStatsStreampointConnection {
	if s == nil {
		return nil
	}
	s.ConnectionsAttemptedValue = &v
	return s
}

// A number of currently active data connections opened via this Agent.
// Example: 2
func (s WatcherAgentStatsStreampointConnectionImpl) ConnectionsCurrent() *int {
	return s.ConnectionsCurrentValue
}

// A number of currently active data connections opened via this Agent.
// Example: 2
func (s *WatcherAgentStatsStreampointConnectionImpl) SetConnectionsCurrent(v int) WatcherAgentStatsStreampointConnection {
	if s == nil {
		return nil
	}
	s.ConnectionsCurrentValue = &v
	return s
}

// A number of successfully opened data connections via this Agent.
// Example: 300
func (s WatcherAgentStatsStreampointConnectionImpl) ConnectionsOpened() *int {
	return s.ConnectionsOpenedValue
}

// A number of successfully opened data connections via this Agent.
// Example: 300
func (s *WatcherAgentStatsStreampointConnectionImpl) SetConnectionsOpened(v int) WatcherAgentStatsStreampointConnection {
	if s == nil {
		return nil
	}
	s.ConnectionsOpenedValue = &v
	return s
}

// Hostname of the server
// Example: agents-001.vsaas.io
func (s WatcherAgentStatsStreampointConnectionImpl) Hostname() *string {
	return s.HostnameValue
}

// Hostname of the server
// Example: agents-001.vsaas.io
func (s *WatcherAgentStatsStreampointConnectionImpl) SetHostname(v string) WatcherAgentStatsStreampointConnection {
	if s == nil {
		return nil
	}
	s.HostnameValue = &v
	return s
}

// Timestamp of the current Agent control connection opening.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s WatcherAgentStatsStreampointConnectionImpl) OpenedAt() *UtcMs {
	return s.OpenedAtValue
}

// Timestamp of the current Agent control connection opening.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s *WatcherAgentStatsStreampointConnectionImpl) SetOpenedAt(v UtcMs) WatcherAgentStatsStreampointConnection {
	if s == nil {
		return nil
	}
	s.OpenedAtValue = &v
	return s
}

// UTC timestamp of the last Agent status change to offline or online.
// Same as `opened_at` if Agent is now connected.
// Format: utc (Unix timestamp in seconds)
// Example: 1.634560921e+09
func (s WatcherAgentStatsStreampointConnectionImpl) StatusChangedAt() *Utc {
	return s.StatusChangedAtValue
}

// UTC timestamp of the last Agent status change to offline or online.
// Same as `opened_at` if Agent is now connected.
// Format: utc (Unix timestamp in seconds)
// Example: 1.634560921e+09
func (s *WatcherAgentStatsStreampointConnectionImpl) SetStatusChangedAt(v Utc) WatcherAgentStatsStreampointConnection {
	if s == nil {
		return nil
	}
	s.StatusChangedAtValue = &v
	return s
}

// NewWatcherStatus creates a new WatcherStatus instance
func NewWatcherStatus() WatcherStatus {
	return &WatcherStatusImpl{}
}

// List of Watcher checks
func (s WatcherStatusImpl) Checks() WatcherStatusChecks {
	return s.ChecksValue
}

// List of Watcher checks
func (s *WatcherStatusImpl) SetChecks(v WatcherStatusChecks) WatcherStatus {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*WatcherStatusChecksImpl); ok {
		s.ChecksValue = impl
	}
	return s
}

// The operator identifier
// Example: 15432
func (s WatcherStatusImpl) OperatorID() *int {
	return s.OperatorIDValue
}

// The operator identifier
// Example: 15432
func (s *WatcherStatusImpl) SetOperatorID(v int) WatcherStatus {
	if s == nil {
		return nil
	}
	s.OperatorIDValue = &v
	return s
}

// NewWatcherStatusChecks creates a new WatcherStatusChecks instance
func NewWatcherStatusChecks() WatcherStatusChecks {
	return &WatcherStatusChecksImpl{}
}

// List of errors details
func (s WatcherStatusChecksImpl) ErrorsDetails() []WatcherStatusChecksErrorsDetailsItem {
	if s.ErrorsDetailsValue == nil {
		return nil
	}
	result := make([]WatcherStatusChecksErrorsDetailsItem, len(s.ErrorsDetailsValue))
	for i, item := range s.ErrorsDetailsValue {
		result[i] = item
	}
	return result
}

// List of errors details
func (s *WatcherStatusChecksImpl) SetErrorsDetails(v []WatcherStatusChecksErrorsDetailsItem) WatcherStatusChecks {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*WatcherStatusChecksErrorsDetailsItemImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*WatcherStatusChecksErrorsDetailsItemImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.ErrorsDetailsValue = impl
	}
	return s
}

// Whether or not the Watcher API key has been updated on the agent server.
// Example: true
func (s WatcherStatusChecksImpl) IsDomainAPIKeyMatched() *bool {
	return s.IsDomainAPIKeyMatchedValue
}

// Whether or not the Watcher API key has been updated on the agent server.
// Example: true
func (s *WatcherStatusChecksImpl) SetIsDomainAPIKeyMatched(v bool) WatcherStatusChecks {
	if s == nil {
		return nil
	}
	s.IsDomainAPIKeyMatchedValue = &v
	return s
}

// Watcher availability from the Internet
// Example: true
func (s WatcherStatusChecksImpl) IsWatcherURLAvailable() *bool {
	return s.IsWatcherURLAvailableValue
}

// Watcher availability from the Internet
// Example: true
func (s *WatcherStatusChecksImpl) SetIsWatcherURLAvailable(v bool) WatcherStatusChecks {
	if s == nil {
		return nil
	}
	s.IsWatcherURLAvailableValue = &v
	return s
}

// Whether or not the Watcher host has been updated on the agent server.
// Example: false
func (s WatcherStatusChecksImpl) IsWatcherURLMatched() *bool {
	return s.IsWatcherURLMatchedValue
}

// Whether or not the Watcher host has been updated on the agent server.
// Example: false
func (s *WatcherStatusChecksImpl) SetIsWatcherURLMatched(v bool) WatcherStatusChecks {
	if s == nil {
		return nil
	}
	s.IsWatcherURLMatchedValue = &v
	return s
}

// NewWatcherStatusChecksErrorsDetailsItem creates a new WatcherStatusChecksErrorsDetailsItem instance
func NewWatcherStatusChecksErrorsDetailsItem() WatcherStatusChecksErrorsDetailsItem {
	return &WatcherStatusChecksErrorsDetailsItemImpl{}
}

// Failed check name
func (s WatcherStatusChecksErrorsDetailsItemImpl) Check() *string {
	return s.CheckValue
}

// Failed check name
func (s *WatcherStatusChecksErrorsDetailsItemImpl) SetCheck(v string) WatcherStatusChecksErrorsDetailsItem {
	if s == nil {
		return nil
	}
	s.CheckValue = &v
	return s
}

// Error message
func (s WatcherStatusChecksErrorsDetailsItemImpl) Error() *string {
	return s.ErrorValue
}

// Error message
func (s *WatcherStatusChecksErrorsDetailsItemImpl) SetError(v string) WatcherStatusChecksErrorsDetailsItem {
	if s == nil {
		return nil
	}
	s.ErrorValue = &v
	return s
}

// NewWatcherStreamConfig creates a new WatcherStreamConfig instance
func NewWatcherStreamConfig() WatcherStreamConfig {
	return &WatcherStreamConfigImpl{}
}

// Audio settings for the stream.
func (s WatcherStreamConfigImpl) Audio() WatcherStreamConfigAudio {
	return s.AudioValue
}

// Audio settings for the stream.
func (s *WatcherStreamConfigImpl) SetAudio(v WatcherStreamConfigAudio) WatcherStreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*WatcherStreamConfigAudioImpl); ok {
		s.AudioValue = impl
	}
	return s
}

// A publishable stream.
// Example: false
func (s WatcherStreamConfigImpl) CanPublish() *bool {
	return s.CanPublishValue
}

// A publishable stream.
// Example: false
func (s *WatcherStreamConfigImpl) SetCanPublish(v bool) WatcherStreamConfig {
	if s == nil {
		return nil
	}
	s.CanPublishValue = &v
	return s
}

// Camera coordinates on a map or a floor plan.
func (s WatcherStreamConfigImpl) Coordinates() MapSpec {
	return s.CoordinatesValue
}

// Camera coordinates on a map or a floor plan.
func (s *WatcherStreamConfigImpl) SetCoordinates(v MapSpec) WatcherStreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*MapSpecImpl); ok {
		s.CoordinatesValue = impl
	}
	return s
}

// The date and time when the steam was created.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.672531199e+12
func (s WatcherStreamConfigImpl) CreatedAt() *UtcMs {
	return s.CreatedAtValue
}

// The date and time when the steam was created.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.672531199e+12
func (s *WatcherStreamConfigImpl) SetCreatedAt(v UtcMs) WatcherStreamConfig {
	if s == nil {
		return nil
	}
	s.CreatedAtValue = &v
	return s
}

// Domain the stream belongs to.
func (s WatcherStreamConfigImpl) Domain() DomainBase {
	return s.DomainValue
}

// Domain the stream belongs to.
func (s *WatcherStreamConfigImpl) SetDomain(v DomainBase) WatcherStreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*DomainBaseImpl); ok {
		s.DomainValue = impl
	}
	return s
}

// Duration of the firmware update. If this field is present, the update process is ongoing.
// Format: milliseconds (milliseconds)
func (s WatcherStreamConfigImpl) FirmwareUpdateDuration() *Milliseconds {
	return s.FirmwareUpdateDurationValue
}

// Duration of the firmware update. If this field is present, the update process is ongoing.
// Format: milliseconds (milliseconds)
func (s *WatcherStreamConfigImpl) SetFirmwareUpdateDuration(v Milliseconds) WatcherStreamConfig {
	if s == nil {
		return nil
	}
	s.FirmwareUpdateDurationValue = &v
	return s
}

// Folder identificator.
func (s WatcherStreamConfigImpl) FolderID() *int {
	return s.FolderIDValue
}

// Folder identificator.
func (s *WatcherStreamConfigImpl) SetFolderID(v int) WatcherStreamConfig {
	if s == nil {
		return nil
	}
	s.FolderIDValue = &v
	return s
}

// Information about the latest changes made to the camera configuration.
func (s WatcherStreamConfigImpl) LastChange() AuditLogRecord {
	return s.LastChangeValue
}

// Information about the latest changes made to the camera configuration.
func (s *WatcherStreamConfigImpl) SetLastChange(v AuditLogRecord) WatcherStreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*AuditLogRecordImpl); ok {
		s.LastChangeValue = impl
	}
	return s
}

// The time when the last episode occurred.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s WatcherStreamConfigImpl) LastEpisodeAt() *UtcMs {
	return s.LastEpisodeAtValue
}

// The time when the last episode occurred.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *WatcherStreamConfigImpl) SetLastEpisodeAt(v UtcMs) WatcherStreamConfig {
	if s == nil {
		return nil
	}
	s.LastEpisodeAtValue = &v
	return s
}

// Layouts information
func (s WatcherStreamConfigImpl) Layout() CentralStreamLayout {
	return s.LayoutValue
}

// Layouts information
func (s *WatcherStreamConfigImpl) SetLayout(v CentralStreamLayout) WatcherStreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*CentralStreamLayoutImpl); ok {
		s.LayoutValue = impl
	}
	return s
}

// Rules of layout.
func (s WatcherStreamConfigImpl) LayoutRules() StreamZoneConfig {
	return s.LayoutRulesValue
}

// Rules of layout.
func (s *WatcherStreamConfigImpl) SetLayoutRules(v StreamZoneConfig) WatcherStreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*StreamZoneConfigImpl); ok {
		s.LayoutRulesValue = impl
	}
	return s
}

// Deprecated field. Will be deleted at 24.12
// Camera coordinates on a map or a floor plan. Deprecated. Use coordinates instead.
func (s WatcherStreamConfigImpl) MapCoordinates() MapSpec {
	return s.MapCoordinatesValue
}

// Deprecated field. Will be deleted at 24.12
// Camera coordinates on a map or a floor plan. Deprecated. Use coordinates instead.
func (s *WatcherStreamConfigImpl) SetMapCoordinates(v MapSpec) WatcherStreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*MapSpecImpl); ok {
		s.MapCoordinatesValue = impl
	}
	return s
}

// Onvif configuration
func (s WatcherStreamConfigImpl) Onvif() StreamOnvifConfig {
	return s.OnvifValue
}

// Onvif configuration
func (s *WatcherStreamConfigImpl) SetOnvif(v StreamOnvifConfig) WatcherStreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*StreamOnvifConfigImpl); ok {
		s.OnvifValue = impl
	}
	return s
}

// Organization the stream belongs to.
func (s WatcherStreamConfigImpl) Organization() OrganizationStream {
	return s.OrganizationValue
}

// Organization the stream belongs to.
func (s *WatcherStreamConfigImpl) SetOrganization(v OrganizationStream) WatcherStreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*OrganizationStreamImpl); ok {
		s.OrganizationValue = impl
	}
	return s
}

// Deprecated field. Will be deleted at 25.11
// ID of the organization the stream belongs to.
// Only organization owner or domain administrator could change it.
// Example: 9
func (s WatcherStreamConfigImpl) OrganizationID() *int {
	return s.OrganizationIDValue
}

// Deprecated field. Will be deleted at 25.11
// ID of the organization the stream belongs to.
// Only organization owner or domain administrator could change it.
// Example: 9
func (s *WatcherStreamConfigImpl) SetOrganizationID(v int) WatcherStreamConfig {
	if s == nil {
		return nil
	}
	s.OrganizationIDValue = &v
	return s
}

// Contains path to stream as a list.
// Each item of the list can be interpreted as a node in a folders tree.
func (s WatcherStreamConfigImpl) Path() []StreamPathItem {
	if s.PathValue == nil {
		return nil
	}
	result := make([]StreamPathItem, len(s.PathValue))
	for i, item := range s.PathValue {
		result[i] = item
	}
	return result
}

// Contains path to stream as a list.
// Each item of the list can be interpreted as a node in a folders tree.
func (s *WatcherStreamConfigImpl) SetPath(v []StreamPathItem) WatcherStreamConfig {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*StreamPathItemImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*StreamPathItemImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.PathValue = impl
	}
	return s
}

// Camera adress on a map.
func (s WatcherStreamConfigImpl) PostalAddress() *string {
	return s.PostalAddressValue
}

// Camera adress on a map.
func (s *WatcherStreamConfigImpl) SetPostalAddress(v string) WatcherStreamConfig {
	if s == nil {
		return nil
	}
	s.PostalAddressValue = &v
	return s
}

// Preset settings.
func (s WatcherStreamConfigImpl) Preset() StreamPreset {
	return s.PresetValue
}

// Preset settings.
func (s *WatcherStreamConfigImpl) SetPreset(v StreamPreset) WatcherStreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*StreamPresetImpl); ok {
		s.PresetValue = impl
	}
	return s
}

// Deprecated field. Will be deleted at 26.01
// Preset identificator.
func (s WatcherStreamConfigImpl) PresetID() *int {
	return s.PresetIDValue
}

// Deprecated field. Will be deleted at 26.01
// Preset identificator.
func (s *WatcherStreamConfigImpl) SetPresetID(v int) WatcherStreamConfig {
	if s == nil {
		return nil
	}
	s.PresetIDValue = &v
	return s
}

// NewWatcherStreamConfigAudio creates a new WatcherStreamConfigAudio instance
func NewWatcherStreamConfigAudio() WatcherStreamConfigAudio {
	return &WatcherStreamConfigAudioImpl{}
}

// A flag showing if the audio is captured (false) or not (true) from the stream.
// Example: false
func (s WatcherStreamConfigAudioImpl) Disabled() *bool {
	return s.DisabledValue
}

// A flag showing if the audio is captured (false) or not (true) from the stream.
// Example: false
func (s *WatcherStreamConfigAudioImpl) SetDisabled(v bool) WatcherStreamConfigAudio {
	if s == nil {
		return nil
	}
	s.DisabledValue = &v
	return s
}

// Audio codec (the AAC codec is used by default).
func (s WatcherStreamConfigAudioImpl) TranscodeAudioCodec() *FrameAudioCodec {
	return s.TranscodeAudioCodecValue
}

// Audio codec (the AAC codec is used by default).
func (s *WatcherStreamConfigAudioImpl) SetTranscodeAudioCodec(v FrameAudioCodec) WatcherStreamConfigAudio {
	if s == nil {
		return nil
	}
	s.TranscodeAudioCodecValue = &v
	return s
}

// NewWebLogoSpec creates a new WebLogoSpec instance
func NewWebLogoSpec() WebLogoSpec {
	return &WebLogoSpecImpl{}
}

// Change the position of the logo to the bottom.
func (s WebLogoSpecImpl) Bottom() *int {
	return s.BottomValue
}

// Change the position of the logo to the bottom.
func (s *WebLogoSpecImpl) SetBottom(v int) WebLogoSpec {
	if s == nil {
		return nil
	}
	s.BottomValue = &v
	return s
}

// Set the specified height for the logo.
// Example: 100
func (s WebLogoSpecImpl) Height() *int {
	return s.HeightValue
}

// Set the specified height for the logo.
// Example: 100
func (s *WebLogoSpecImpl) SetHeight(v int) WebLogoSpec {
	if s == nil {
		return nil
	}
	s.HeightValue = &v
	return s
}

// Change the position of the logo to the left.
// Example: 15
func (s WebLogoSpecImpl) Left() *int {
	return s.LeftValue
}

// Change the position of the logo to the left.
// Example: 15
func (s *WebLogoSpecImpl) SetLeft(v int) WebLogoSpec {
	if s == nil {
		return nil
	}
	s.LeftValue = &v
	return s
}

// Change the position of the logo to the right.
func (s WebLogoSpecImpl) Right() *int {
	return s.RightValue
}

// Change the position of the logo to the right.
func (s *WebLogoSpecImpl) SetRight(v int) WebLogoSpec {
	if s == nil {
		return nil
	}
	s.RightValue = &v
	return s
}

// Change the position of the logo to the top.
// Example: 15
func (s WebLogoSpecImpl) Top() *int {
	return s.TopValue
}

// Change the position of the logo to the top.
// Example: 15
func (s *WebLogoSpecImpl) SetTop(v int) WebLogoSpec {
	if s == nil {
		return nil
	}
	s.TopValue = &v
	return s
}

// Set the specified width for the logo.
// Example: 200
func (s WebLogoSpecImpl) Width() *int {
	return s.WidthValue
}

// Set the specified width for the logo.
// Example: 200
func (s *WebLogoSpecImpl) SetWidth(v int) WebLogoSpec {
	if s == nil {
		return nil
	}
	s.WidthValue = &v
	return s
}

// NewWebrtcRouterConfig creates a new WebrtcRouterConfig instance
func NewWebrtcRouterConfig() WebrtcRouterConfig {
	return &WebrtcRouterConfigImpl{}
}

// Ports that will be used for WebRTC data handling.
func (s WebrtcRouterConfigImpl) Ports() []int {
	return s.PortsValue
}

// Ports that will be used for WebRTC data handling.
func (s *WebrtcRouterConfigImpl) SetPorts(v []int) WebrtcRouterConfig {
	if s == nil {
		return nil
	}
	s.PortsValue = v
	return s
}

// Transport protocol
func (s WebrtcRouterConfigImpl) Transport() *WebrtcTransport {
	return s.TransportValue
}

// Transport protocol
func (s *WebrtcRouterConfigImpl) SetTransport(v WebrtcTransport) WebrtcRouterConfig {
	if s == nil {
		return nil
	}
	s.TransportValue = &v
	return s
}

// NewZone creates a new Zone instance
func NewZone() Zone {
	return &ZoneImpl{}
}

// Information about the created zone.
func (s ZoneImpl) Created() CreationInfo {
	return s.CreatedValue
}

// Information about the created zone.
func (s *ZoneImpl) SetCreated(v CreationInfo) Zone {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*CreationInfoImpl); ok {
		s.CreatedValue = impl
	}
	return s
}

// Dedicated zones can only accept streams with the corresponding required or preferred zone assignment.
// They are used to separate streamers from cameras that should not be assigned to them.
// Example: false
func (s ZoneImpl) IsDedicated() *bool {
	return s.IsDedicatedValue
}

// Dedicated zones can only accept streams with the corresponding required or preferred zone assignment.
// They are used to separate streamers from cameras that should not be assigned to them.
// Example: false
func (s *ZoneImpl) SetIsDedicated(v bool) Zone {
	if s == nil {
		return nil
	}
	s.IsDedicatedValue = &v
	return s
}

// The name of the zone. Unique identifier.
// Format: unix_name (Contains only alphanumeric characters (a-z, A-Z, 0-9), underscores (_), hyphens (-) and periods (.).)
// Pattern: ^[a-zA-Z0-9_.-]+$
// Example: zone1
func (s ZoneImpl) Name() UnixName {
	return s.NameValue
}

// The name of the zone. Unique identifier.
// Format: unix_name (Contains only alphanumeric characters (a-z, A-Z, 0-9), underscores (_), hyphens (-) and periods (.).)
// Pattern: ^[a-zA-Z0-9_.-]+$
// Example: zone1
func (s *ZoneImpl) SetName(v UnixName) Zone {
	if s == nil {
		return nil
	}
	s.NameValue = v
	return s
}

// Statistics of the zone.
func (s ZoneImpl) Stats() ZoneStats {
	return s.StatsValue
}

// Statistics of the zone.
func (s *ZoneImpl) SetStats(v ZoneStats) Zone {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ZoneStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// NewZoneStats creates a new ZoneStats instance
func NewZoneStats() ZoneStats {
	return &ZoneStatsImpl{}
}

// Number of streams with preferred zone assignment
// Example: 10
func (s ZoneStatsImpl) PreferredStreamsCount() *int {
	return s.PreferredStreamsCountValue
}

// Number of streams with preferred zone assignment
// Example: 10
func (s *ZoneStatsImpl) SetPreferredStreamsCount(v int) ZoneStats {
	if s == nil {
		return nil
	}
	s.PreferredStreamsCountValue = &v
	return s
}

// Number of streams with required zone assignment
// Example: 10
func (s ZoneStatsImpl) RequiredStreamsCount() *int {
	return s.RequiredStreamsCountValue
}

// Number of streams with required zone assignment
// Example: 10
func (s *ZoneStatsImpl) SetRequiredStreamsCount(v int) ZoneStats {
	if s == nil {
		return nil
	}
	s.RequiredStreamsCountValue = &v
	return s
}

// List of streamers assigned to this zone.
// Example: [streamer1 streamer2]
func (s ZoneStatsImpl) Streamers() []string {
	return s.StreamersValue
}

// List of streamers assigned to this zone.
// Example: [streamer1 streamer2]
func (s *ZoneStatsImpl) SetStreamers(v []string) ZoneStats {
	if s == nil {
		return nil
	}
	s.StreamersValue = v
	return s
}

// Number of streamers assigned to this zone
// Example: 1
func (s ZoneStatsImpl) StreamersCount() *int {
	return s.StreamersCountValue
}

// Number of streamers assigned to this zone
// Example: 1
func (s *ZoneStatsImpl) SetStreamersCount(v int) ZoneStats {
	if s == nil {
		return nil
	}
	s.StreamersCountValue = &v
	return s
}

// NewZonesList creates a new ZonesList instance
func NewZonesList() ZonesList {
	return &ZonesListImpl{}
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s ZonesListImpl) EstimatedCount() *int {
	return s.EstimatedCountValue
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s *ZonesListImpl) SetEstimatedCount(v int) ZonesList {
	if s == nil {
		return nil
	}
	s.EstimatedCountValue = &v
	return s
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s ZonesListImpl) Next() *string {
	return s.NextValue
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s *ZonesListImpl) SetNext(v string) ZonesList {
	if s == nil {
		return nil
	}
	s.NextValue = &v
	return s
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s ZonesListImpl) Prev() *string {
	return s.PrevValue
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s *ZonesListImpl) SetPrev(v string) ZonesList {
	if s == nil {
		return nil
	}
	s.PrevValue = &v
	return s
}

// An object with a list of different timings measured during this API call.
func (s ZonesListImpl) Timing() any {
	return s.TimingValue
}

// An object with a list of different timings measured during this API call.
func (s *ZonesListImpl) SetTiming(v any) ZonesList {
	if s == nil {
		return nil
	}
	s.TimingValue = v
	return s
}

// The list of zones fetched according to the query parameters.
func (s ZonesListImpl) Zones() []Zone {
	if s.ZonesValue == nil {
		return nil
	}
	result := make([]Zone, len(s.ZonesValue))
	for i, item := range s.ZonesValue {
		result[i] = item
	}
	return result
}

// The list of zones fetched according to the query parameters.
func (s *ZonesListImpl) SetZones(v []Zone) ZonesList {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*ZoneImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*ZoneImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.ZonesValue = impl
	}
	return s
}

// Collection returns the collection items from ZonesList
func (s ZonesListImpl) Collection() []Zone {
	return s.Zones()
}
