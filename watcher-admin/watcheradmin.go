// Code generated by cmd/main. DO NOT EDIT.
package watcheradmin

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"iter"
	"net/http"
	"net/url"
	"strconv"
	"strings"

	"github.com/flussonic/go-flussonic/authorization"
	"github.com/flussonic/go-flussonic/config"
	"github.com/flussonic/go-flussonic/internal/baseclient"
	"github.com/flussonic/go-flussonic/internal/cursors"
	model "github.com/flussonic/go-flussonic/watcher-admin/model"
)

// WatcherAdmin defines the interface for interacting with WatcherAdmin API.
type WatcherAdmin interface {
	// AdminStreamsList List streams for admin
	// The key difference between this method and streams_list is the additional parameters. These additional parameters are available only for admin (e.g. 'required_zones' and 'preferred_zones').  This API method is one of the most important in whole API, because it gives the list of all streams.  `streams_list` in Watcher Admin API: * can list all streams within the Watcher. * admin is not allowed to watch content from any cameras for security reasons.  `streams_list` in Watcher Client API: * return streams from organizations where you're member * provives a playback token that allows play video from the camera.
	AdminStreamsList(ctx context.Context, query *AdminStreamsListQuery) (model.StreamsList, error)
	// AdminStreamsListIterator iterates through all items using cursor pagination
	AdminStreamsListIterator(ctx context.Context, query *AdminStreamsListQuery) iter.Seq2[model.StreamConfig, error]
	// AgentGet Get one Agent
	// The method allows you to fetch a single Agent.  The returned data are the same as for `agents_list` operation.
	AgentGet(ctx context.Context, id string) (model.WatcherAgentConfig, error)
	// AgentsList List Agents
	// The list of configured and provisioned Agents, i.e. Agents that connected to your server at least once.
	AgentsList(ctx context.Context, query *AgentsListQuery) (model.AgentsList, error)
	// AgentsListIterator iterates through all items using cursor pagination
	AgentsListIterator(ctx context.Context, query *AgentsListQuery) iter.Seq2[model.Agent, error]
	// CameraAuthGet Get auth for camera
	// Create or update a auth for camera by its name.
	CameraAuthGet(ctx context.Context, name string) (model.Auth, error)
	// CameraAuthSave Save auth for camera
	// Create or update a auth for camera by its name.
	CameraAuthSave(ctx context.Context, name string) (model.Auth, error)
	// CameraConfigGet Get one stream camera config
	// This method allows to fetch a single stream camera config info.
	CameraConfigGet(ctx context.Context, name string) (model.CameraConfig, error)
	// CameraConfigSave Save stream camera config
	// Create or update a stream config by its name.
	CameraConfigSave(ctx context.Context, name string, body model.CameraConfig) (model.CameraConfig, error)
	// CameraReboot Reboot camera
	// Reboot camera
	CameraReboot(ctx context.Context, name string) error
	// ClusterStatsGet Get current health of cluster
	// This method allows you to fetch cluster's health
	ClusterStatsGet(ctx context.Context, query *ClusterStatsGetQuery) (model.ClusterHealthStats, error)
	// DeleteOrganizationPreset Delete preset from organization
	// This method allows to remove a specific preset from organization.
	DeleteOrganizationPreset(ctx context.Context, organization_id string, preset_id string) error
	// DomainConfigGet Get domain settings
	// The method allows you to get the domain settings
	DomainConfigGet(ctx context.Context) (model.DomainConfig, error)
	// DomainConfigSave Save domain settings
	// The method allows you to save the domain settings
	DomainConfigSave(ctx context.Context, body model.DomainConfig) error
	// EventsList Get events of Watcher
	// This method allows to get the batch of events. Currently this method is not implemented yet. However, its schema can be used for understanding Watcher logging.
	EventsList(ctx context.Context, query *EventsListQuery) (model.EventsList, error)
	// EventsListIterator iterates through all items using cursor pagination
	EventsListIterator(ctx context.Context, query *EventsListQuery) iter.Seq2[model.Event, error]
	// LetsencryptIssue Issue letsencrypt certificate
	// Issue letsencrypt certificate
	LetsencryptIssue(ctx context.Context, body model.LetsencryptRequest) (model.TlsCertificate, error)
	// LivenessProbe Liveness probe
	// K8s liveness probe.
	LivenessProbe(ctx context.Context) (model.ServerStatsWhoami, error)
	// LoginCreate Get an auth token
	// The method creates a new temporary auth-token (JWT). The JTW token used as Bearer token in requests other than `/login`.
	LoginCreate(ctx context.Context) (model.LoginInfoAdditional, error)
	// OrganizationPresetSave Update organizations preset
	// Save organization preset by its id or adds new preset to organization.
	OrganizationPresetSave(ctx context.Context, organization_id string, body model.OrganizationPreset) (model.Preset, error)
	// PresetGet Get one preset
	// This method is used to get info about preset by its id.
	PresetGet(ctx context.Context, id string) (model.Preset, error)
	// PresetSave Update preset
	// This method will update the existing preset with the specified id.
	PresetSave(ctx context.Context, id string, body model.Preset) (model.Preset, error)
	// PresetsCreate Create preset
	// This method will create a new preset.
	PresetsCreate(ctx context.Context, body model.Preset) (model.Preset, error)
	// PresetsList List presets
	// The presets in Watcher is a set of DVR and analytics parameters that you can use as a template when creating and configuring cameras. When you select a preset in the camera settings, the parameters from the preset are populated to the camera settings. A set of presets on the camera is defined by the set of presets selected for the camera's Organization. https://flussonic.com/doc/manage-presets-in-watcher-ui/  This method is used to get info about presets. If the `organization_id` is transferred this method will return presets only allowed in organization with that Id.
	PresetsList(ctx context.Context, query *PresetsListQuery) (model.PresetsList, error)
	// PresetsListIterator iterates through all items using cursor pagination
	PresetsListIterator(ctx context.Context, query *PresetsListQuery) iter.Seq2[model.Preset, error]
	// PreviewLayoutChangeForStreamConfig Dry run layouter for changed stream configuration
	// This method allows you to see how the overall layout will be changed due to changes into stream configuration. Note that if [Layouter](https://flussonic.com/doc/api/layouter/) is [disabled](https://flussonic.com/doc/api/central/#tag/config/operation/config_save%7Cbody%7Clayouter_enabled), this method will return an error.
	PreviewLayoutChangeForStreamConfig(ctx context.Context, name string, query *PreviewLayoutChangeForStreamConfigQuery, body model.StreamConfig) (model.CentralStreamLayoutPrediction, error)
	// PreviewLayoutChangeForStreamConfigIterator iterates through all items using cursor pagination
	PreviewLayoutChangeForStreamConfigIterator(ctx context.Context, name string, query *PreviewLayoutChangeForStreamConfigQuery, body model.StreamConfig) iter.Seq2[model.CentralStreamLayoutListItem, error]
	// PreviewLayoutChangeForStreamerConfig Dry run layouter for changed streamer configuration
	// This method allows you to see how the overall layout will be changed due to changes into streamer configuration. Note that if [Layouter](https://flussonic.com/doc/api/layouter/) is [disabled](https://flussonic.com/doc/api/central/#tag/config/operation/config_save%7Cbody%7Clayouter_enabled), this method will return an error.
	PreviewLayoutChangeForStreamerConfig(ctx context.Context, hostname string, query *PreviewLayoutChangeForStreamerConfigQuery, body model.StreamerLayoutPrediction) (model.CentralStreamerLayoutPrediction, error)
	// PreviewLayoutChangeForStreamerConfigIterator iterates through all items using cursor pagination
	PreviewLayoutChangeForStreamerConfigIterator(ctx context.Context, hostname string, query *PreviewLayoutChangeForStreamerConfigQuery, body model.StreamerLayoutPrediction) iter.Seq2[model.CentralStreamerLayoutPredictionItem, error]
	// ReadinessProbe Readiness probe
	// K8s readiness probe.
	ReadinessProbe(ctx context.Context) (model.ServerStatsWhoami, error)
	// SharedTokenCreate Create Shared token
	// Method to create shared token
	SharedTokenCreate(ctx context.Context, body model.SharedToken) (model.SharedToken, error)
	// SharedTokenDelete Delete Shared token
	// This method allows to delete a single shared token.
	SharedTokenDelete(ctx context.Context, key string) error
	// SharedTokensList List Shared tokens
	// Method allows to fetch configured Shared tokens
	SharedTokensList(ctx context.Context, query *SharedTokensListQuery) (model.SharedTokensList, error)
	// SharedTokensListIterator iterates through all items using cursor pagination
	SharedTokensListIterator(ctx context.Context, query *SharedTokensListQuery) iter.Seq2[model.SharedToken, error]
	// StreamDelete Delete the stream
	// This method allows to delete a single stream. You can delete `config_override` by this API call if you want to remove all runtime overrides.  If you do not specify any `part` parameter, this stream will be deleted from `config_on_disk` and if it was `named_by: config`, then it will immediately stop.
	StreamDelete(ctx context.Context, name string, query *StreamDeleteQuery) error
	// StreamFirmwareUpdate Update camera firmware
	// This method allows you to update camera firmware
	StreamFirmwareUpdate(ctx context.Context, name string, body model.FirmwareUpdate) error
	// StreamGet Get one stream
	// This method allows to fetch a single stream. Refer to the `streams_list` operation to find out what data will be returned in this method.
	StreamGet(ctx context.Context, name string) (model.StreamConfig, error)
	// StreamLayoutsGet Get layouts of stream
	// This method allows you to fetch stream layouts list
	StreamLayoutsGet(ctx context.Context, name string, query *StreamLayoutsGetQuery) (model.CentralStreamLayouts, error)
	// StreamLayoutsGetIterator iterates through all items using cursor pagination
	StreamLayoutsGetIterator(ctx context.Context, name string, query *StreamLayoutsGetQuery) iter.Seq2[model.CentralStreamLayout, error]
	// StreamSave Save stream
	// Create or update a stream by its name. If the stream doesn't exists in the disk config, it will be created.  If you try to update a stream that is started from a template by a user request having `named_by=user`, a new stream will be created in the disk config.  If you pass only a partial stream configuration, this field will be updated, not the whole stream.  To create a new stream the property `name` is required.  Pass the `"$reset": true` option to replace the stream configuration with the provided one.
	StreamSave(ctx context.Context, name string, query *StreamSaveQuery, body model.StreamConfig) (model.StreamConfig, error)
	// StreamerDelete Delete the streamer
	// Delete the streamer by its hostname.
	StreamerDelete(ctx context.Context, hostname string) error
	// StreamerGet Get the streamer
	// This method allows you to fetch the main parameters and current metrics of a single streamer
	StreamerGet(ctx context.Context, hostname string) (model.Streamer, error)
	// StreamerSave Save the streamer
	// This method will either create a new streamer (if there is no streamer with the hostname specified in the request), or update the existing streamer having the specified hostname.
	StreamerSave(ctx context.Context, hostname string, query *StreamerSaveQuery, body model.Streamer) (model.Streamer, error)
	// StreamersList List streamers
	// Returns the list of all streamers with main parameters and current metric values.
	StreamersList(ctx context.Context, query *StreamersListQuery) (model.StreamersList, error)
	// StreamersListIterator iterates through all items using cursor pagination
	StreamersListIterator(ctx context.Context, query *StreamersListQuery) iter.Seq2[model.Streamer, error]
	// StreamsMultiedit Save streams settings
	// Create or update settings for each stream. This operation does everything or nothing. If at least one stream has an invalid configuration or can't be processed, the request will fail.
	StreamsMultiedit(ctx context.Context, body model.StreamsMultieditConfig) error
	// StreamsZonesSettings Save streams with zone settings
	// Create or update zone settings for each stream. This operation does everything or nothing. If at least one stream has an invalid configuration or can't be processed, the request will fail.
	StreamsZonesSettings(ctx context.Context, body model.StreamsZoneSettings) error
	// SystemConfigGet Get system settings
	// The method allows you to get the system settings
	SystemConfigGet(ctx context.Context) (model.SystemConfig, error)
	// TlsCertificateGet Get tls certificate
	// Get current tls certificate
	TlsCertificateGet(ctx context.Context) (model.TlsCertificate, error)
	// UserCreate Create user
	// This method allows you to create a user
	UserCreate(ctx context.Context, body any) (model.User, error)
	// UserDelete Delete a user
	// This method allows you to delete a user
	UserDelete(ctx context.Context, user_id string) error
	// UserGet Get a user
	// This method allows you to fetch the user by its identifier
	UserGet(ctx context.Context, user_id string) (model.User, error)
	// UserSave Save user
	// This method allows you to update user data
	UserSave(ctx context.Context, user_id string, body model.User) (model.User, error)
	// UsersApikeyCreate Create new API key for user
	// The API key is used for authentication in API requests, allowing access to protected resources without using a password.
	UsersApikeyCreate(ctx context.Context, user_id string) (model.Apikey, error)
	// UsersApikeyGet Get user's API key
	// The API key is used for authentication in API requests, allowing access to protected resources without using a password.
	UsersApikeyGet(ctx context.Context, user_id string) (model.Apikey, error)
	// UsersList List of users
	// List of available users
	UsersList(ctx context.Context, query *UsersListQuery) (model.Users, error)
	// UsersListIterator iterates through all items using cursor pagination
	UsersListIterator(ctx context.Context, query *UsersListQuery) iter.Seq2[model.User, error]
	// WatcherProvision The operator identifier creation
	// This method allows you to create the operator identifier
	WatcherProvision(ctx context.Context) (model.WatcherStatus, error)
	// WatcherStatusGet Get the Watcher status
	// Get the Watcher status on the agent server.
	WatcherStatusGet(ctx context.Context) (model.WatcherStatus, error)
	// ZoneDelete Delete the zone
	// Delete the zone by its name.
	ZoneDelete(ctx context.Context, name string) error
	// ZoneGet Get the zone
	// This method allows you to fetch the main parameters and current metrics of a single zone
	ZoneGet(ctx context.Context, name string) (model.Zone, error)
	// ZoneSave Save the zone
	// This method will either create a new zone (if there is no zone with the name specified in the request), or update the existing zone having the specified name.
	ZoneSave(ctx context.Context, name string, body model.Zone) (model.Zone, error)
	// ZonesList List zones
	// Returns the list of all zones with main parameters and current metric values.
	ZonesList(ctx context.Context, query *ZonesListQuery) (model.ZonesList, error)
	// ZonesListIterator iterates through all items using cursor pagination
	ZonesListIterator(ctx context.Context, query *ZonesListQuery) iter.Seq2[model.Zone, error]
}

// AdminStreamsListQuery represents query parameters for AdminStreamsList method
type AdminStreamsListQuery struct {
	Cursor string
	Limit  int
	// Comma-separated list of preferred zones. Returns streams, belonging to at least one preferred zone from the list.
	PreferredZones string
	// Comma-separated list of required zones. Returns streams, belonging to at least one required zone from the list.
	RequiredZones string
	Select        []string
	Sort          []string
	Extra         map[string]string
}

// ToQueryString converts AdminStreamsListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *AdminStreamsListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.PreferredZones != "" {
		values.Set("preferred_zones", q.PreferredZones)
	}
	if q.RequiredZones != "" {
		values.Set("required_zones", q.RequiredZones)
	}
	if len(q.Select) > 0 {
		values.Set("select", strings.Join(q.Select, ","))
	}
	if len(q.Sort) > 0 {
		values.Set("sort", strings.Join(q.Sort, ","))
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *AdminStreamsListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// AgentsListQuery represents query parameters for AgentsList method
type AgentsListQuery struct {
	Cursor string
	Limit  int
	// Organization identifier to select agents only available for this organization. If the `organization_id` is not transferred, all available agents will be returned.
	OrganizationId int
	Select         []string
	Sort           []string
	// Filter agents by stream presence. If any stream has the agent in its inputs, the agent will not be returned with filter `stream_is=null`.
	Stream string
	// Filter agents by stream title using partial match. The search is case-insensitive and matches any part of the stream title.
	TitleLike string
	Extra     map[string]string
}

// ToQueryString converts AgentsListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *AgentsListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.OrganizationId != 0 {
		values.Set("organization_id", strconv.Itoa(q.OrganizationId))
	}
	if q.Stream != "" {
		values.Set("stream", q.Stream)
	}
	if q.TitleLike != "" {
		values.Set("title_like", q.TitleLike)
	}
	if len(q.Select) > 0 {
		values.Set("select", strings.Join(q.Select, ","))
	}
	if len(q.Sort) > 0 {
		values.Set("sort", strings.Join(q.Sort, ","))
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *AgentsListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// ClusterStatsGetQuery represents query parameters for ClusterStatsGet method
type ClusterStatsGetQuery struct {
	// This parameter is used instead of the Accept header to select of non-JSON response content format.
	Format string
	Extra  map[string]string
}

// ToQueryString converts ClusterStatsGetQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *ClusterStatsGetQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Format != "" {
		values.Set("format", q.Format)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// EventsListQuery represents query parameters for EventsList method
type EventsListQuery struct {
	Cursor string
	Limit  int
	Select []string
	Sort   []string
	Extra  map[string]string
}

// ToQueryString converts EventsListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *EventsListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if len(q.Select) > 0 {
		values.Set("select", strings.Join(q.Select, ","))
	}
	if len(q.Sort) > 0 {
		values.Set("sort", strings.Join(q.Sort, ","))
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *EventsListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// PresetsListQuery represents query parameters for PresetsList method
type PresetsListQuery struct {
	Cursor string
	Limit  int
	// Organization identifier to select presets only available for this organization. If the `organization_id` is not transferred, all available presets will be returned.
	OrganizationId int
	Select         []string
	Sort           []string
	Extra          map[string]string
}

// ToQueryString converts PresetsListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *PresetsListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.OrganizationId != 0 {
		values.Set("organization_id", strconv.Itoa(q.OrganizationId))
	}
	if len(q.Select) > 0 {
		values.Set("select", strings.Join(q.Select, ","))
	}
	if len(q.Sort) > 0 {
		values.Set("sort", strings.Join(q.Sort, ","))
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *PresetsListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// PreviewLayoutChangeForStreamConfigQuery represents query parameters for PreviewLayoutChangeForStreamConfig method
type PreviewLayoutChangeForStreamConfigQuery struct {
	Cursor string
	Limit  int
	Select []string
	Sort   []string
	Extra  map[string]string
}

// ToQueryString converts PreviewLayoutChangeForStreamConfigQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *PreviewLayoutChangeForStreamConfigQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if len(q.Select) > 0 {
		values.Set("select", strings.Join(q.Select, ","))
	}
	if len(q.Sort) > 0 {
		values.Set("sort", strings.Join(q.Sort, ","))
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *PreviewLayoutChangeForStreamConfigQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// PreviewLayoutChangeForStreamerConfigQuery represents query parameters for PreviewLayoutChangeForStreamerConfig method
type PreviewLayoutChangeForStreamerConfigQuery struct {
	Cursor string
	Limit  int
	Select []string
	Sort   []string
	Extra  map[string]string
}

// ToQueryString converts PreviewLayoutChangeForStreamerConfigQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *PreviewLayoutChangeForStreamerConfigQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if len(q.Select) > 0 {
		values.Set("select", strings.Join(q.Select, ","))
	}
	if len(q.Sort) > 0 {
		values.Set("sort", strings.Join(q.Sort, ","))
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *PreviewLayoutChangeForStreamerConfigQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// SharedTokensListQuery represents query parameters for SharedTokensList method
type SharedTokensListQuery struct {
	Cursor string
	Limit  int
	Select []string
	Sort   []string
	Extra  map[string]string
}

// ToQueryString converts SharedTokensListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *SharedTokensListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if len(q.Select) > 0 {
		values.Set("select", strings.Join(q.Select, ","))
	}
	if len(q.Sort) > 0 {
		values.Set("sort", strings.Join(q.Sort, ","))
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *SharedTokensListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// StreamDeleteQuery represents query parameters for StreamDelete method
type StreamDeleteQuery struct {
	// part of config to delete
	Part  string
	Extra map[string]string
}

// ToQueryString converts StreamDeleteQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *StreamDeleteQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Part != "" {
		values.Set("part", q.Part)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// StreamLayoutsGetQuery represents query parameters for StreamLayoutsGet method
type StreamLayoutsGetQuery struct {
	// Get layouts created after this timestamp
	CreatedAtGt int
	// Get layouts created before this timestamp
	CreatedAtLt int
	// A properly encoded equivalent of offset allowing you to read the next bunch of items.  We do not offer common `offset` fields, so please use cursor for predictable fetching of quickly changing list of items.
	Cursor string
	// Limit the number of returned layouts
	Limit  int
	Select []string
	Sort   []string
	Extra  map[string]string
}

// ToQueryString converts StreamLayoutsGetQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *StreamLayoutsGetQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.CreatedAtGt != 0 {
		values.Set("created_at_gt", strconv.Itoa(q.CreatedAtGt))
	}
	if q.CreatedAtLt != 0 {
		values.Set("created_at_lt", strconv.Itoa(q.CreatedAtLt))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	if q.Limit != 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if len(q.Select) > 0 {
		values.Set("select", strings.Join(q.Select, ","))
	}
	if len(q.Sort) > 0 {
		values.Set("sort", strings.Join(q.Sort, ","))
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *StreamLayoutsGetQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// StreamSaveQuery represents query parameters for StreamSave method
type StreamSaveQuery struct {
	// The stream is configured by several origins of configuration. It may be `config_on_disk` or temporary runtime `config_override` that can be provided via `on_play` or `on_publish` backend, or edited via this API call if you pass `config_override` to this parameter.
	Part  string
	Extra map[string]string
}

// ToQueryString converts StreamSaveQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *StreamSaveQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Part != "" {
		values.Set("part", q.Part)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// StreamerSaveQuery represents query parameters for StreamerSave method
type StreamerSaveQuery struct {
	// This flag enables some checks before saving streamer. List of checks:   - Watcher can reach the streamer (get its config);    If a request with `checks_enable=true` is sent,  then if at least one of the checks fails, the streamer will not be saved.
	ChecksEnable bool
	Extra        map[string]string
}

// ToQueryString converts StreamerSaveQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *StreamerSaveQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	values.Set("checks_enable", strconv.FormatBool(q.ChecksEnable))
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// StreamersListQuery represents query parameters for StreamersList method
type StreamersListQuery struct {
	Cursor string
	Limit  int
	Select []string
	Sort   []string
	Extra  map[string]string
}

// ToQueryString converts StreamersListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *StreamersListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if len(q.Select) > 0 {
		values.Set("select", strings.Join(q.Select, ","))
	}
	if len(q.Sort) > 0 {
		values.Set("sort", strings.Join(q.Sort, ","))
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *StreamersListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// UsersListQuery represents query parameters for UsersList method
type UsersListQuery struct {
	Cursor string
	Limit  int
	// Organization identifier to select users only available for this organization. If the `organization_id` is not transferred, all available users will be returned.
	OrganizationId int
	Select         []string
	Sort           []string
	Extra          map[string]string
}

// ToQueryString converts UsersListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *UsersListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.OrganizationId != 0 {
		values.Set("organization_id", strconv.Itoa(q.OrganizationId))
	}
	if len(q.Select) > 0 {
		values.Set("select", strings.Join(q.Select, ","))
	}
	if len(q.Sort) > 0 {
		values.Set("sort", strings.Join(q.Sort, ","))
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *UsersListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// ZonesListQuery represents query parameters for ZonesList method
type ZonesListQuery struct {
	Cursor string
	Limit  int
	Select []string
	Sort   []string
	Extra  map[string]string
}

// ToQueryString converts ZonesListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *ZonesListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if len(q.Select) > 0 {
		values.Set("select", strings.Join(q.Select, ","))
	}
	if len(q.Sort) > 0 {
		values.Set("sort", strings.Join(q.Sort, ","))
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *ZonesListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// BaseClientFactory is a factory function type for creating base HTTP clients.
type BaseClientFactory func(cfg *config.Config, apiURL string, authKey authorization.AuthKey) baseclient.BaseClient

// defaultBaseClientFactory creates a default base client instance.
func defaultBaseClientFactory(cfg *config.Config, apiURL string, authKey authorization.AuthKey) baseclient.BaseClient {
	return baseclient.New(cfg.HTTPClient, apiURL, authKey, cfg.Originator, cfg.Retry)
}

// Client is the concrete implementation of the WatcherAdmin interface.
type Client struct {
	base   baseclient.BaseClient
	apiURL string
}

// NewWithBaseFactory creates a new WatcherAdmin client with a custom base client factory.
// This is primarily used for testing or when custom HTTP client behavior is needed.
func NewWithBaseFactory(cfg *config.Config, baseFactory BaseClientFactory) (WatcherAdmin, error) {
	if cfg.Hostname == "" {
		return nil, fmt.Errorf("hostname is required")
	}

	if cfg.Protocol == "" {
		cfg.Protocol = "http"
	}

	if cfg.Port == 0 {
		if cfg.Protocol == "https" {
			cfg.Port = 443
		} else {
			cfg.Port = 80
		}
	}

	apiURL := fmt.Sprintf("%s://%s:%d", cfg.Protocol, cfg.Hostname, cfg.Port)

	var authKey authorization.AuthKey
	if cfg.Auth != nil {
		authKey = cfg.Auth
	} else if cfg.ClusterKey != "" {
		authKey = authorization.ClusterKey(cfg.ClusterKey)
	}

	if cfg.Originator == "" {
		cfg.Originator = config.DefaultOriginator
	}

	base := baseFactory(cfg, apiURL, authKey)

	return &Client{
		base:   base,
		apiURL: apiURL,
	}, nil
}

// New creates a new WatcherAdmin client with default settings.
func New(cfg *config.Config) (WatcherAdmin, error) {
	return NewWithBaseFactory(cfg, defaultBaseClientFactory)
}

// doGet performs a GET request and unmarshals the response into result.
func (c *Client) doGet(ctx context.Context, path string, result any) error {
	request, err := http.NewRequestWithContext(ctx, http.MethodGet, c.apiURL+path, http.NoBody)
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}
	request.Header.Set("Content-Type", "application/json")
	return c.base.Request(ctx, request, result)
}

// doPost performs a POST request with a JSON body and unmarshals the response into result.
func (c *Client) doPost(ctx context.Context, path string, body any, result any) error {
	bodyBytes, err := json.Marshal(body)
	if err != nil {
		return fmt.Errorf("failed to marshal request body: %w", err)
	}
	request, err := http.NewRequestWithContext(ctx, http.MethodPost, c.apiURL+path, bytes.NewBuffer(bodyBytes))
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}
	request.Header.Set("Content-Type", "application/json")
	return c.base.Request(ctx, request, result)
}

// doPut performs a PUT request with a JSON body and unmarshals the response into result.
func (c *Client) doPut(ctx context.Context, path string, body any, result any) error {
	bodyBytes, err := json.Marshal(body)
	if err != nil {
		return fmt.Errorf("failed to marshal request body: %w", err)
	}
	request, err := http.NewRequestWithContext(ctx, http.MethodPut, c.apiURL+path, bytes.NewBuffer(bodyBytes))
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}
	request.Header.Set("Content-Type", "application/json")
	return c.base.Request(ctx, request, result)
}

// doDelete performs a DELETE request.
func (c *Client) doDelete(ctx context.Context, path string) error {
	request, err := http.NewRequestWithContext(ctx, http.MethodDelete, c.apiURL+path, http.NoBody)
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}
	request.Header.Set("Content-Type", "application/json")
	return c.base.Request(ctx, request, nil)
}

// doList performs a GET request with query parameters and unmarshals the response into result.
func (c *Client) doList(ctx context.Context, path string, query interface{ ToQueryString() (string, error) }, result any) error {
	if query == nil {
		request, err := http.NewRequestWithContext(ctx, http.MethodGet, c.apiURL+path, http.NoBody)
		if err != nil {
			return fmt.Errorf("failed to create request: %w", err)
		}
		request.Header.Set("Content-Type", "application/json")
		return c.base.Request(ctx, request, result)
	}
	queryString, err := query.ToQueryString()
	if err != nil {
		return fmt.Errorf("failed to build query string: %w", err)
	}
	requestURL := c.apiURL + path
	if queryString != "" {
		requestURL += "?" + queryString
	}
	request, err := http.NewRequestWithContext(ctx, http.MethodGet, requestURL, http.NoBody)
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}
	request.Header.Set("Content-Type", "application/json")
	return c.base.Request(ctx, request, result)
}

// AdminStreamsList List streams for admin
// The key difference between this method and streams_list is the additional parameters. These additional parameters are available only for admin (e.g. 'required_zones' and 'preferred_zones').  This API method is one of the most important in whole API, because it gives the list of all streams.  `streams_list` in Watcher Admin API: * can list all streams within the Watcher. * admin is not allowed to watch content from any cameras for security reasons.  `streams_list` in Watcher Client API: * return streams from organizations where you're member * provives a playback token that allows play video from the camera.
func (c *Client) AdminStreamsList(ctx context.Context, query *AdminStreamsListQuery) (model.StreamsList, error) {
	path := "/watcher/admin-api/v3/streams"
	result := &model.StreamsListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// AdminStreamsListIterator iterates through all StreamConfig items using cursor pagination.
func (c *Client) AdminStreamsListIterator(ctx context.Context, query *AdminStreamsListQuery) iter.Seq2[model.StreamConfig, error] {
	return cursors.Iterator(ctx, c.AdminStreamsList, query)
}

// AgentGet Get one Agent
// The method allows you to fetch a single Agent.  The returned data are the same as for `agents_list` operation.
func (c *Client) AgentGet(ctx context.Context, id string) (model.WatcherAgentConfig, error) {
	path := fmt.Sprintf("/watcher/admin-api/v3/agents/%s", id)
	result := &model.WatcherAgentConfigImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// AgentsList List Agents
// The list of configured and provisioned Agents, i.e. Agents that connected to your server at least once.
func (c *Client) AgentsList(ctx context.Context, query *AgentsListQuery) (model.AgentsList, error) {
	path := "/watcher/admin-api/v3/agents"
	result := &model.AgentsListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// AgentsListIterator iterates through all Agent items using cursor pagination.
func (c *Client) AgentsListIterator(ctx context.Context, query *AgentsListQuery) iter.Seq2[model.Agent, error] {
	return cursors.Iterator(ctx, c.AgentsList, query)
}

// CameraAuthGet Get auth for camera
// Create or update a auth for camera by its name.
func (c *Client) CameraAuthGet(ctx context.Context, name string) (model.Auth, error) {
	path := fmt.Sprintf("/watcher/admin-api/v3/streams/%s/auth", name)
	result := &model.AuthImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// CameraAuthSave Save auth for camera
// Create or update a auth for camera by its name.
func (c *Client) CameraAuthSave(ctx context.Context, name string) (model.Auth, error) {
	path := fmt.Sprintf("/watcher/admin-api/v3/streams/%s/auth", name)
	result := &model.AuthImpl{}
	if err := c.doPut(ctx, path, nil, result); err != nil {
		return nil, err
	}
	return result, nil
}

// CameraConfigGet Get one stream camera config
// This method allows to fetch a single stream camera config info.
func (c *Client) CameraConfigGet(ctx context.Context, name string) (model.CameraConfig, error) {
	path := fmt.Sprintf("/watcher/admin-api/v3/streams/%s/camera_config", name)
	result := &model.CameraConfigImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// CameraConfigSave Save stream camera config
// Create or update a stream config by its name.
func (c *Client) CameraConfigSave(ctx context.Context, name string, body model.CameraConfig) (model.CameraConfig, error) {
	path := fmt.Sprintf("/watcher/admin-api/v3/streams/%s/camera_config", name)
	result := &model.CameraConfigImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// CameraReboot Reboot camera
// Reboot camera
func (c *Client) CameraReboot(ctx context.Context, name string) error {
	path := fmt.Sprintf("/watcher/admin-api/v3/streams/%s/reboot", name)
	if err := c.doPost(ctx, path, nil, nil); err != nil {
		return err
	}
	return nil
}

// ClusterStatsGet Get current health of cluster
// This method allows you to fetch cluster's health
func (c *Client) ClusterStatsGet(ctx context.Context, query *ClusterStatsGetQuery) (model.ClusterHealthStats, error) {
	path := "/watcher/admin-api/v3/cluster/stats"
	result := &model.ClusterHealthStatsImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// DeleteOrganizationPreset Delete preset from organization
// This method allows to remove a specific preset from organization.
func (c *Client) DeleteOrganizationPreset(ctx context.Context, organization_id string, preset_id string) error {
	path := fmt.Sprintf("/watcher/admin-api/v3/organizations/%s/presets/%s", organization_id, preset_id)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// DomainConfigGet Get domain settings
// The method allows you to get the domain settings
func (c *Client) DomainConfigGet(ctx context.Context) (model.DomainConfig, error) {
	path := "/watcher/admin-api/v3/domain_config"
	result := &model.DomainConfigImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// DomainConfigSave Save domain settings
// The method allows you to save the domain settings
func (c *Client) DomainConfigSave(ctx context.Context, body model.DomainConfig) error {
	path := "/watcher/admin-api/v3/domain_config"
	if err := c.doPut(ctx, path, body, nil); err != nil {
		return err
	}
	return nil
}

// EventsList Get events of Watcher
// This method allows to get the batch of events. Currently this method is not implemented yet. However, its schema can be used for understanding Watcher logging.
func (c *Client) EventsList(ctx context.Context, query *EventsListQuery) (model.EventsList, error) {
	path := "/watcher/admin-api/v3/events"
	result := &model.EventsListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// EventsListIterator iterates through all Event items using cursor pagination.
func (c *Client) EventsListIterator(ctx context.Context, query *EventsListQuery) iter.Seq2[model.Event, error] {
	return cursors.Iterator(ctx, c.EventsList, query)
}

// LetsencryptIssue Issue letsencrypt certificate
// Issue letsencrypt certificate
func (c *Client) LetsencryptIssue(ctx context.Context, body model.LetsencryptRequest) (model.TlsCertificate, error) {
	path := "/watcher/admin-api/v3/tls/letsencrypt"
	result := &model.TlsCertificateImpl{}
	if err := c.doPost(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// LivenessProbe Liveness probe
// K8s liveness probe.
func (c *Client) LivenessProbe(ctx context.Context) (model.ServerStatsWhoami, error) {
	path := "/watcher/admin-api/v3/monitoring/liveness"
	result := &model.ServerStatsWhoamiImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// LoginCreate Get an auth token
// The method creates a new temporary auth-token (JWT). The JTW token used as Bearer token in requests other than `/login`.
func (c *Client) LoginCreate(ctx context.Context) (model.LoginInfoAdditional, error) {
	path := "/watcher/admin-api/v3/login"
	result := &model.LoginInfoAdditionalImpl{}
	if err := c.doPost(ctx, path, nil, result); err != nil {
		return nil, err
	}
	return result, nil
}

// OrganizationPresetSave Update organizations preset
// Save organization preset by its id or adds new preset to organization.
func (c *Client) OrganizationPresetSave(ctx context.Context, organization_id string, body model.OrganizationPreset) (model.Preset, error) {
	path := fmt.Sprintf("/watcher/admin-api/v3/organizations/%s/presets", organization_id)
	result := &model.PresetImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// PresetGet Get one preset
// This method is used to get info about preset by its id.
func (c *Client) PresetGet(ctx context.Context, id string) (model.Preset, error) {
	path := fmt.Sprintf("/watcher/admin-api/v3/presets/%s", id)
	result := &model.PresetImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// PresetSave Update preset
// This method will update the existing preset with the specified id.
func (c *Client) PresetSave(ctx context.Context, id string, body model.Preset) (model.Preset, error) {
	path := fmt.Sprintf("/watcher/admin-api/v3/presets/%s", id)
	result := &model.PresetImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// PresetsCreate Create preset
// This method will create a new preset.
func (c *Client) PresetsCreate(ctx context.Context, body model.Preset) (model.Preset, error) {
	path := "/watcher/admin-api/v3/presets"
	result := &model.PresetImpl{}
	if err := c.doPost(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// PresetsList List presets
// The presets in Watcher is a set of DVR and analytics parameters that you can use as a template when creating and configuring cameras. When you select a preset in the camera settings, the parameters from the preset are populated to the camera settings. A set of presets on the camera is defined by the set of presets selected for the camera's Organization. https://flussonic.com/doc/manage-presets-in-watcher-ui/  This method is used to get info about presets. If the `organization_id` is transferred this method will return presets only allowed in organization with that Id.
func (c *Client) PresetsList(ctx context.Context, query *PresetsListQuery) (model.PresetsList, error) {
	path := "/watcher/admin-api/v3/presets"
	result := &model.PresetsListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// PresetsListIterator iterates through all Preset items using cursor pagination.
func (c *Client) PresetsListIterator(ctx context.Context, query *PresetsListQuery) iter.Seq2[model.Preset, error] {
	return cursors.Iterator(ctx, c.PresetsList, query)
}

// PreviewLayoutChangeForStreamConfig Dry run layouter for changed stream configuration
// This method allows you to see how the overall layout will be changed due to changes into stream configuration. Note that if [Layouter](https://flussonic.com/doc/api/layouter/) is [disabled](https://flussonic.com/doc/api/central/#tag/config/operation/config_save%7Cbody%7Clayouter_enabled), this method will return an error.
func (c *Client) PreviewLayoutChangeForStreamConfig(ctx context.Context, name string, query *PreviewLayoutChangeForStreamConfigQuery, body model.StreamConfig) (model.CentralStreamLayoutPrediction, error) {
	path := fmt.Sprintf("/watcher/admin-api/v3/streams/%s/preview_layout_change", name)
	result := &model.CentralStreamLayoutPredictionImpl{}
	if err := c.doPost(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// PreviewLayoutChangeForStreamConfigIterator iterates through all CentralStreamLayoutListItem items using cursor pagination.
func (c *Client) PreviewLayoutChangeForStreamConfigIterator(ctx context.Context, name string, query *PreviewLayoutChangeForStreamConfigQuery, body model.StreamConfig) iter.Seq2[model.CentralStreamLayoutListItem, error] {
	return cursors.Iterator(ctx, func(ctx context.Context, query *PreviewLayoutChangeForStreamConfigQuery) (model.CentralStreamLayoutPrediction, error) {
		return c.PreviewLayoutChangeForStreamConfig(ctx, name, query, body)
	}, query)
}

// PreviewLayoutChangeForStreamerConfig Dry run layouter for changed streamer configuration
// This method allows you to see how the overall layout will be changed due to changes into streamer configuration. Note that if [Layouter](https://flussonic.com/doc/api/layouter/) is [disabled](https://flussonic.com/doc/api/central/#tag/config/operation/config_save%7Cbody%7Clayouter_enabled), this method will return an error.
func (c *Client) PreviewLayoutChangeForStreamerConfig(ctx context.Context, hostname string, query *PreviewLayoutChangeForStreamerConfigQuery, body model.StreamerLayoutPrediction) (model.CentralStreamerLayoutPrediction, error) {
	path := fmt.Sprintf("/watcher/admin-api/v3/streamers/%s/preview_layout_change", hostname)
	result := &model.CentralStreamerLayoutPredictionImpl{}
	if err := c.doPost(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// PreviewLayoutChangeForStreamerConfigIterator iterates through all CentralStreamerLayoutPredictionItem items using cursor pagination.
func (c *Client) PreviewLayoutChangeForStreamerConfigIterator(ctx context.Context, hostname string, query *PreviewLayoutChangeForStreamerConfigQuery, body model.StreamerLayoutPrediction) iter.Seq2[model.CentralStreamerLayoutPredictionItem, error] {
	return cursors.Iterator(ctx, func(ctx context.Context, query *PreviewLayoutChangeForStreamerConfigQuery) (model.CentralStreamerLayoutPrediction, error) {
		return c.PreviewLayoutChangeForStreamerConfig(ctx, hostname, query, body)
	}, query)
}

// ReadinessProbe Readiness probe
// K8s readiness probe.
func (c *Client) ReadinessProbe(ctx context.Context) (model.ServerStatsWhoami, error) {
	path := "/watcher/admin-api/v3/monitoring/readiness"
	result := &model.ServerStatsWhoamiImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// SharedTokenCreate Create Shared token
// Method to create shared token
func (c *Client) SharedTokenCreate(ctx context.Context, body model.SharedToken) (model.SharedToken, error) {
	path := "/watcher/admin-api/v3/shares"
	result := &model.SharedTokenImpl{}
	if err := c.doPost(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// SharedTokenDelete Delete Shared token
// This method allows to delete a single shared token.
func (c *Client) SharedTokenDelete(ctx context.Context, key string) error {
	path := fmt.Sprintf("/watcher/admin-api/v3/shares/%s", key)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// SharedTokensList List Shared tokens
// Method allows to fetch configured Shared tokens
func (c *Client) SharedTokensList(ctx context.Context, query *SharedTokensListQuery) (model.SharedTokensList, error) {
	path := "/watcher/admin-api/v3/shares"
	result := &model.SharedTokensListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// SharedTokensListIterator iterates through all SharedToken items using cursor pagination.
func (c *Client) SharedTokensListIterator(ctx context.Context, query *SharedTokensListQuery) iter.Seq2[model.SharedToken, error] {
	return cursors.Iterator(ctx, c.SharedTokensList, query)
}

// StreamDelete Delete the stream
// This method allows to delete a single stream. You can delete `config_override` by this API call if you want to remove all runtime overrides.  If you do not specify any `part` parameter, this stream will be deleted from `config_on_disk` and if it was `named_by: config`, then it will immediately stop.
func (c *Client) StreamDelete(ctx context.Context, name string, query *StreamDeleteQuery) error {
	path := fmt.Sprintf("/watcher/admin-api/v3/streams/%s", name)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// StreamFirmwareUpdate Update camera firmware
// This method allows you to update camera firmware
func (c *Client) StreamFirmwareUpdate(ctx context.Context, name string, body model.FirmwareUpdate) error {
	path := fmt.Sprintf("/watcher/admin-api/v3/streams/%s/firmware_update", name)
	if err := c.doPut(ctx, path, body, nil); err != nil {
		return err
	}
	return nil
}

// StreamGet Get one stream
// This method allows to fetch a single stream. Refer to the `streams_list` operation to find out what data will be returned in this method.
func (c *Client) StreamGet(ctx context.Context, name string) (model.StreamConfig, error) {
	path := fmt.Sprintf("/watcher/admin-api/v3/streams/%s", name)
	result := &model.StreamConfigImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// StreamLayoutsGet Get layouts of stream
// This method allows you to fetch stream layouts list
func (c *Client) StreamLayoutsGet(ctx context.Context, name string, query *StreamLayoutsGetQuery) (model.CentralStreamLayouts, error) {
	path := fmt.Sprintf("/watcher/admin-api/v3/streams/%s/layouts", name)
	result := &model.CentralStreamLayoutsImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// StreamLayoutsGetIterator iterates through all CentralStreamLayout items using cursor pagination.
func (c *Client) StreamLayoutsGetIterator(ctx context.Context, name string, query *StreamLayoutsGetQuery) iter.Seq2[model.CentralStreamLayout, error] {
	return cursors.Iterator(ctx, func(ctx context.Context, query *StreamLayoutsGetQuery) (model.CentralStreamLayouts, error) {
		return c.StreamLayoutsGet(ctx, name, query)
	}, query)
}

// StreamSave Save stream
// Create or update a stream by its name. If the stream doesn't exists in the disk config, it will be created.  If you try to update a stream that is started from a template by a user request having `named_by=user`, a new stream will be created in the disk config.  If you pass only a partial stream configuration, this field will be updated, not the whole stream.  To create a new stream the property `name` is required.  Pass the `"$reset": true` option to replace the stream configuration with the provided one.
func (c *Client) StreamSave(ctx context.Context, name string, query *StreamSaveQuery, body model.StreamConfig) (model.StreamConfig, error) {
	path := fmt.Sprintf("/watcher/admin-api/v3/streams/%s", name)
	result := &model.StreamConfigImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// StreamerDelete Delete the streamer
// Delete the streamer by its hostname.
func (c *Client) StreamerDelete(ctx context.Context, hostname string) error {
	path := fmt.Sprintf("/watcher/admin-api/v3/streamers/%s", hostname)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// StreamerGet Get the streamer
// This method allows you to fetch the main parameters and current metrics of a single streamer
func (c *Client) StreamerGet(ctx context.Context, hostname string) (model.Streamer, error) {
	path := fmt.Sprintf("/watcher/admin-api/v3/streamers/%s", hostname)
	result := &model.StreamerImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// StreamerSave Save the streamer
// This method will either create a new streamer (if there is no streamer with the hostname specified in the request), or update the existing streamer having the specified hostname.
func (c *Client) StreamerSave(ctx context.Context, hostname string, query *StreamerSaveQuery, body model.Streamer) (model.Streamer, error) {
	path := fmt.Sprintf("/watcher/admin-api/v3/streamers/%s", hostname)
	result := &model.StreamerImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// StreamersList List streamers
// Returns the list of all streamers with main parameters and current metric values.
func (c *Client) StreamersList(ctx context.Context, query *StreamersListQuery) (model.StreamersList, error) {
	path := "/watcher/admin-api/v3/streamers"
	result := &model.StreamersListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// StreamersListIterator iterates through all Streamer items using cursor pagination.
func (c *Client) StreamersListIterator(ctx context.Context, query *StreamersListQuery) iter.Seq2[model.Streamer, error] {
	return cursors.Iterator(ctx, c.StreamersList, query)
}

// StreamsMultiedit Save streams settings
// Create or update settings for each stream. This operation does everything or nothing. If at least one stream has an invalid configuration or can't be processed, the request will fail.
func (c *Client) StreamsMultiedit(ctx context.Context, body model.StreamsMultieditConfig) error {
	path := "/watcher/admin-api/v3/streams/multiedit"
	if err := c.doPost(ctx, path, body, nil); err != nil {
		return err
	}
	return nil
}

// StreamsZonesSettings Save streams with zone settings
// Create or update zone settings for each stream. This operation does everything or nothing. If at least one stream has an invalid configuration or can't be processed, the request will fail.
func (c *Client) StreamsZonesSettings(ctx context.Context, body model.StreamsZoneSettings) error {
	path := "/watcher/admin-api/v3/streams/zones"
	if err := c.doPost(ctx, path, body, nil); err != nil {
		return err
	}
	return nil
}

// SystemConfigGet Get system settings
// The method allows you to get the system settings
func (c *Client) SystemConfigGet(ctx context.Context) (model.SystemConfig, error) {
	path := "/watcher/admin-api/v3/system_config"
	result := &model.SystemConfigImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// TlsCertificateGet Get tls certificate
// Get current tls certificate
func (c *Client) TlsCertificateGet(ctx context.Context) (model.TlsCertificate, error) {
	path := "/watcher/admin-api/v3/tls/letsencrypt"
	result := &model.TlsCertificateImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// UserCreate Create user
// This method allows you to create a user
func (c *Client) UserCreate(ctx context.Context, body any) (model.User, error) {
	path := "/watcher/admin-api/v3/users"
	result := &model.UserImpl{}
	if err := c.doPost(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// UserDelete Delete a user
// This method allows you to delete a user
func (c *Client) UserDelete(ctx context.Context, user_id string) error {
	path := fmt.Sprintf("/watcher/admin-api/v3/users/%s", user_id)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// UserGet Get a user
// This method allows you to fetch the user by its identifier
func (c *Client) UserGet(ctx context.Context, user_id string) (model.User, error) {
	path := fmt.Sprintf("/watcher/admin-api/v3/users/%s", user_id)
	result := &model.UserImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// UserSave Save user
// This method allows you to update user data
func (c *Client) UserSave(ctx context.Context, user_id string, body model.User) (model.User, error) {
	path := fmt.Sprintf("/watcher/admin-api/v3/users/%s", user_id)
	result := &model.UserImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// UsersApikeyCreate Create new API key for user
// The API key is used for authentication in API requests, allowing access to protected resources without using a password.
func (c *Client) UsersApikeyCreate(ctx context.Context, user_id string) (model.Apikey, error) {
	path := fmt.Sprintf("/watcher/admin-api/v3/users/%s/apikey", user_id)
	result := &model.ApikeyImpl{}
	if err := c.doPost(ctx, path, nil, result); err != nil {
		return nil, err
	}
	return result, nil
}

// UsersApikeyGet Get user's API key
// The API key is used for authentication in API requests, allowing access to protected resources without using a password.
func (c *Client) UsersApikeyGet(ctx context.Context, user_id string) (model.Apikey, error) {
	path := fmt.Sprintf("/watcher/admin-api/v3/users/%s/apikey", user_id)
	result := &model.ApikeyImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// UsersList List of users
// List of available users
func (c *Client) UsersList(ctx context.Context, query *UsersListQuery) (model.Users, error) {
	path := "/watcher/admin-api/v3/users"
	result := &model.UsersImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// UsersListIterator iterates through all User items using cursor pagination.
func (c *Client) UsersListIterator(ctx context.Context, query *UsersListQuery) iter.Seq2[model.User, error] {
	return cursors.Iterator(ctx, c.UsersList, query)
}

// WatcherProvision The operator identifier creation
// This method allows you to create the operator identifier
func (c *Client) WatcherProvision(ctx context.Context) (model.WatcherStatus, error) {
	path := "/watcher/admin-api/v3/peeklio/create_operator_id"
	result := &model.WatcherStatusImpl{}
	if err := c.doPost(ctx, path, nil, result); err != nil {
		return nil, err
	}
	return result, nil
}

// WatcherStatusGet Get the Watcher status
// Get the Watcher status on the agent server.
func (c *Client) WatcherStatusGet(ctx context.Context) (model.WatcherStatus, error) {
	path := "/watcher/admin-api/v3/peeklio/check_watcher_status"
	result := &model.WatcherStatusImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// ZoneDelete Delete the zone
// Delete the zone by its name.
func (c *Client) ZoneDelete(ctx context.Context, name string) error {
	path := fmt.Sprintf("/watcher/admin-api/v3/zones/%s", name)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// ZoneGet Get the zone
// This method allows you to fetch the main parameters and current metrics of a single zone
func (c *Client) ZoneGet(ctx context.Context, name string) (model.Zone, error) {
	path := fmt.Sprintf("/watcher/admin-api/v3/zones/%s", name)
	result := &model.ZoneImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// ZoneSave Save the zone
// This method will either create a new zone (if there is no zone with the name specified in the request), or update the existing zone having the specified name.
func (c *Client) ZoneSave(ctx context.Context, name string, body model.Zone) (model.Zone, error) {
	path := fmt.Sprintf("/watcher/admin-api/v3/zones/%s", name)
	result := &model.ZoneImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// ZonesList List zones
// Returns the list of all zones with main parameters and current metric values.
func (c *Client) ZonesList(ctx context.Context, query *ZonesListQuery) (model.ZonesList, error) {
	path := "/watcher/admin-api/v3/zones"
	result := &model.ZonesListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// ZonesListIterator iterates through all Zone items using cursor pagination.
func (c *Client) ZonesListIterator(ctx context.Context, query *ZonesListQuery) iter.Seq2[model.Zone, error] {
	return cursors.Iterator(ctx, c.ZonesList, query)
}
