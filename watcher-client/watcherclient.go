// Code generated by cmd/main. DO NOT EDIT.
package watcherclient

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"iter"
	"net/http"
	"net/url"
	"strconv"

	"github.com/flussonic/go-flussonic/authorization"
	"github.com/flussonic/go-flussonic/config"
	"github.com/flussonic/go-flussonic/internal/baseclient"
	"github.com/flussonic/go-flussonic/internal/cursors"
	model "github.com/flussonic/go-flussonic/watcher-client/model"
)

// WatcherClient defines the interface for interacting with WatcherClient API.
type WatcherClient interface {
	// AgentActivationTokenCreate Create activation token
	// This method creates activation token for agent. This token used by mobile app in qr-code for wifi camera with agent for adding camera with agent in watcher.
	AgentActivationTokenCreate(ctx context.Context, body model.AgentActivationTokenRequest) (model.AgentActivationToken, error)
	// AgentActivationTokenGet Check activation token provisioned to watcher
	// This method allows you to check that camera with agent was provisioned to watcher. If you got 404 on this method you - token not existing and you must create a new one to add camera with agent. If no camera_name field in response - camera not provisioned yet to watcher. If camera_name field in response - camera provisioned to watcher.
	AgentActivationTokenGet(ctx context.Context, token string) (model.AgentActivationToken, error)
	// CameraAuthGet Get auth for camera
	// Create or update a auth for camera by its name.
	CameraAuthGet(ctx context.Context, name string) (model.Auth, error)
	// CameraAuthSave Save auth for camera
	// Create or update a auth for camera by its name.
	CameraAuthSave(ctx context.Context, name string) (model.Auth, error)
	// CameraConfigGet Get one stream camera config
	// This method allows to fetch a single stream camera config info.
	CameraConfigGet(ctx context.Context, name string) (model.CameraConfig, error)
	// CameraConfigSave Save stream camera config
	// Create or update a stream config by its name.
	CameraConfigSave(ctx context.Context, name string, body model.CameraConfig) (model.CameraConfig, error)
	// CameraReboot Reboot camera
	// Reboot camera
	CameraReboot(ctx context.Context, name string) error
	// DeleteOrganizationPreset Delete preset from organization
	// This method allows to remove a specific preset from organization.
	DeleteOrganizationPreset(ctx context.Context, organization_id string, preset_id string) error
	// DeviceTokenConfirm Confirm notification received by device
	// Should be called by a device when notification received
	DeviceTokenConfirm(ctx context.Context, token string) (model.DeviceToken, error)
	// DeviceTokenDelete Delete device token
	// Delete device token. Mobile application have to delete all expired device tokens, received from Firebase.
	DeviceTokenDelete(ctx context.Context, token string) error
	// DeviceTokenGet Get device token
	// Returns a device token info
	DeviceTokenGet(ctx context.Context, token string) (model.DeviceToken, error)
	// DeviceTokenSave Save a new device token
	// Save a new device token in Watcher. You can read how to create it here: https://firebase.google.com/docs/cloud-messaging/android/client?hl=en#sample-register You must save and refresh token if you want to receive notifications about [camera events](#tag/profile/operation/event_subscription_create).
	DeviceTokenSave(ctx context.Context, token string, body model.DeviceToken) (model.DeviceToken, error)
	// EpisodeAddToFavorites Add episode to the favorites
	// This method allows you to add an episode to the favorites.
	EpisodeAddToFavorites(ctx context.Context, episode_id string) error
	// EpisodeDelete Delete episode
	// This method allows you to delete a registered episode. Only manually created episodes can be deleted. Episodes created automatically by the system (e.g., by video analytics) cannot be deleted.
	EpisodeDelete(ctx context.Context, episode_id string, query *EpisodeDeleteQuery) error
	// EpisodeDeleteFromFavorites Delete episode from the favorites
	// This method allows you to delete an episode from the favorites.
	EpisodeDeleteFromFavorites(ctx context.Context, episode_id string) error
	// EpisodeGet Get episode
	// This method allows you to fetch a registered episode
	EpisodeGet(ctx context.Context, episode_id string, query *EpisodeGetQuery) (model.WatcherEpisode, error)
	// EpisodesList List episodes
	// This method allows you to fetch registered episodes
	EpisodesList(ctx context.Context, query *EpisodesListQuery) (model.EpisodesList, error)
	// EpisodesListIterator iterates through all items using cursor pagination
	EpisodesListIterator(ctx context.Context, query *EpisodesListQuery) iter.Seq2[model.WatcherEpisode, error]
	// EventSubscriptionCreate Create a new event subscription on specific stream
	// Create a new event subscription
	EventSubscriptionCreate(ctx context.Context, body model.SubscriptionRequest) (model.Subscription, error)
	// EventSubscriptionDelete Unsubscribe from events on specific stream
	// Delete subscription on events
	EventSubscriptionDelete(ctx context.Context, body model.SubscriptionRequest) error
	// FolderCreate Create folder
	// Create folder.
	FolderCreate(ctx context.Context, organization_id string, body model.Folder) (model.Folder, error)
	// FolderDelete Delete folder
	// This method allows to delete a folder.
	FolderDelete(ctx context.Context, organization_id string, folder_id string) error
	// FolderGet Get folder info
	// This method allows to fetch folder info.
	FolderGet(ctx context.Context, organization_id string, folder_id string) (model.Folder, error)
	// FolderList Get list of folders
	// This method allows to fetch a list of folders info.
	FolderList(ctx context.Context, organization_id string, query *FolderListQuery) (model.FoldersList, error)
	// FolderListIterator iterates through all items using cursor pagination
	FolderListIterator(ctx context.Context, organization_id string, query *FolderListQuery) iter.Seq2[model.Folder, error]
	// FolderSave Save folder
	// Save folder.
	FolderSave(ctx context.Context, organization_id string, folder_id string, body model.Folder) (model.Folder, error)
	// FolderUserDelete Delete user in a folder
	// This method allows to delete user info in a folder.
	FolderUserDelete(ctx context.Context, organization_id string, folder_id string, user_id string) error
	// FolderUserGet Get user in a folder
	// This method allows to fetch user in a folder.
	FolderUserGet(ctx context.Context, organization_id string, folder_id string, user_id string) (model.FolderUser, error)
	// FolderUserSave Save user in a folder
	// Save user info in a folder.
	FolderUserSave(ctx context.Context, organization_id string, folder_id string, user_id string, body model.FolderUser) (model.FolderUser, error)
	// FolderUsersList Get a list of users in a folder
	// This method allows to fetch a list of users in a folder.
	FolderUsersList(ctx context.Context, organization_id string, folder_id string, query *FolderUsersListQuery) (model.FolderUsersList, error)
	// FolderUsersListIterator iterates through all items using cursor pagination
	FolderUsersListIterator(ctx context.Context, organization_id string, folder_id string, query *FolderUsersListQuery) iter.Seq2[model.FolderUsers, error]
	// GetInviteShortInfo Get organization invite short info
	// This method allows to get short info about organization invite.
	GetInviteShortInfo(ctx context.Context, invite_key string) (model.OrganizationBase, error)
	// LoginCreate Get an auth token
	// The method creates a new temporary auth-token (JWT). The JTW token used as Bearer token in requests other than `/login`.
	LoginCreate(ctx context.Context) (model.LoginInfoAdditional, error)
	// MessageDelete Delete a message
	// This method allows you to delete a message
	MessageDelete(ctx context.Context, message_id string) error
	// MessageGet Get a message
	// This method allows you to fetch the message by its identifier
	MessageGet(ctx context.Context, message_id string) (model.Message, error)
	// MessageSend Send a message
	// This method allows you to send a message to a user
	MessageSend(ctx context.Context, body model.MessageSend) (model.MessageResponse, error)
	// MessageUpdate Update message
	// Update message by its id.
	MessageUpdate(ctx context.Context, message_id string, body model.MessageChangeRequest) (model.Message, error)
	// MessagesList List of messages
	// List of messages
	MessagesList(ctx context.Context, query *MessagesListQuery) (model.Messages, error)
	// MessagesListIterator iterates through all items using cursor pagination
	MessagesListIterator(ctx context.Context, query *MessagesListQuery) iter.Seq2[model.Message, error]
	// MosaicCreate Create mosaic
	// This method allows you to create a mosaic
	MosaicCreate(ctx context.Context, body any) (model.Mosaic, error)
	// MosaicDelete Delete a mosaic
	// This method allows you to delete a mosaic
	MosaicDelete(ctx context.Context, mosaic_id string) error
	// MosaicGet Get mosaic detail
	// This method is used to get info about mosaic by its id.
	MosaicGet(ctx context.Context, mosaic_id string) (model.Mosaic, error)
	// MosaicSave Save mosaic
	// This method allows you to update mosaic data
	MosaicSave(ctx context.Context, mosaic_id string, body model.MosaicSave) (model.Mosaic, error)
	// MosaicsList List mosaics
	// Returns the list of all mosaics. Mosaics allow you to combine multiple cameras to display on a single screen.
	MosaicsList(ctx context.Context, query *MosaicsListQuery) (model.MosaicsList, error)
	// MosaicsListIterator iterates through all items using cursor pagination
	MosaicsListIterator(ctx context.Context, query *MosaicsListQuery) iter.Seq2[model.Mosaic, error]
	// NotificationSend Send an arbitrary push notification
	// Send an arbitrary push notification. This method sends test push notification to user.
	NotificationSend(ctx context.Context, body any) error
	// OrganizationCreate Create organization
	// Create new organization
	OrganizationCreate(ctx context.Context, body model.Organization) (model.Organization, error)
	// OrganizationDelete Delete organization
	// Delete organization by its id.
	OrganizationDelete(ctx context.Context, organization_id string) error
	// OrganizationGet Get single organization info
	// This method allows to fetch a single organization info. Refer to the `organizations_list` operation to find out what data will be returned in this method.
	OrganizationGet(ctx context.Context, organization_id string) (model.Organization, error)
	// OrganizationInviteAccept Accept organization invite
	// This method allows to accept organization invite and add user to organization.
	OrganizationInviteAccept(ctx context.Context, invite_key string) error
	// OrganizationInviteCreate Create organization invite key
	// This method allows to create a single organizations invite key.  Using this key user can invite other users to the organization.  Only organization owner can create invite key.
	OrganizationInviteCreate(ctx context.Context, organization_id string, body model.OrganizationInviteSetup) (model.OrganizationInviteKey, error)
	// OrganizationPresetSave Update organizations preset
	// Save organization preset by its id or adds new preset to organization.
	OrganizationPresetSave(ctx context.Context, organization_id string, body model.OrganizationPreset) (model.Preset, error)
	// OrganizationSave Update organization
	// Update organization by its id.
	OrganizationSave(ctx context.Context, organization_id string, body model.Organization) (model.Organization, error)
	// OrganizationUserDelete Delete user from organization
	// Delete user from organization by its id.
	OrganizationUserDelete(ctx context.Context, organization_id string, user_id string) error
	// OrganizationUserGet Get single organization user info
	// This method allows to fetch a single organizations user info.
	OrganizationUserGet(ctx context.Context, organization_id string, user_id string) (model.OrganizationUser, error)
	// OrganizationUserSave Update organizations user
	// Update organization user by its id or adds new user to organization.
	OrganizationUserSave(ctx context.Context, organization_id string, user_id string, body model.OrganizationPermissions) (model.OrganizationUser, error)
	// OrganizationUsersList List users in organization
	// Users who are members of the organization
	OrganizationUsersList(ctx context.Context, organization_id string, query *OrganizationUsersListQuery) (model.OrganizationUsersList, error)
	// OrganizationUsersListIterator iterates through all items using cursor pagination
	OrganizationUsersListIterator(ctx context.Context, organization_id string, query *OrganizationUsersListQuery) iter.Seq2[model.OrganizationUser, error]
	// OrganizationsList List organizations
	// Organizations of which the user is member
	OrganizationsList(ctx context.Context, query *OrganizationsListQuery) (model.OrganizationsList, error)
	// OrganizationsListIterator iterates through all items using cursor pagination
	OrganizationsListIterator(ctx context.Context, query *OrganizationsListQuery) iter.Seq2[model.Organization, error]
	// PasswordRecovery Send password recovery email
	// Send user email with password recovery instructions. This method will return success  regardless of whether there is a user with the specified email address or not
	PasswordRecovery(ctx context.Context, body any) error
	// PersonDelete Delete person
	// Delete person by its id.
	PersonDelete(ctx context.Context, person_id string) error
	// PersonGet Get the Person
	// This method allows you to fetch the person by its identifier
	PersonGet(ctx context.Context, person_id string) (model.Person, error)
	// PersonListsGet Lists Person
	// This method allows you to fetch the person lists
	PersonListsGet(ctx context.Context, query *PersonListsGetQuery) (model.PersonListsList, error)
	// PersonListsGetIterator iterates through all items using cursor pagination
	PersonListsGetIterator(ctx context.Context, query *PersonListsGetQuery) iter.Seq2[model.PersonLists, error]
	// PersonsList List Persons
	// The list of registered videoanalytics persons
	PersonsList(ctx context.Context, query *PersonsListQuery) (model.PersonsList, error)
	// PersonsListIterator iterates through all items using cursor pagination
	PersonsListIterator(ctx context.Context, query *PersonsListQuery) iter.Seq2[model.VisionPerson, error]
	// PresetGet Get one preset
	// This method is used to get info about preset by its id.
	PresetGet(ctx context.Context, id string) (model.Preset, error)
	// PresetsList List presets
	// The presets in Watcher is a set of DVR and analytics parameters that you can use as a template when creating and configuring cameras. When you select a preset in the camera settings, the parameters from the preset are populated to the camera settings. A set of presets on the camera is defined by the set of presets selected for the camera's Organization. https://flussonic.com/doc/manage-presets-in-watcher-ui/  This method is used to get info about presets. If the `organization_id` is transferred this method will return presets only allowed in organization with that Id.
	PresetsList(ctx context.Context, query *PresetsListQuery) (model.PresetsList, error)
	// PresetsListIterator iterates through all items using cursor pagination
	PresetsListIterator(ctx context.Context, query *PresetsListQuery) iter.Seq2[model.Preset, error]
	// ProfileGet Get profile info
	// Get profile info.
	ProfileGet(ctx context.Context) (model.Profile, error)
	// ProfileSave Update profile info
	// Update profile info.
	ProfileSave(ctx context.Context, body model.Profile) (model.Profile, error)
	// ResetPassword Reset password
	// Changes user password
	ResetPassword(ctx context.Context, body model.PasswordReset) error
	// StreamDelete Delete the stream
	// This method allows to delete a single stream. You can delete `config_override` by this API call if you want to remove all runtime overrides.  If you do not specify any `part` parameter, this stream will be deleted from `config_on_disk` and if it was `named_by: config`, then it will immediately stop.
	StreamDelete(ctx context.Context, name string, query *StreamDeleteQuery) error
	// StreamFirmwareUpdate Update camera firmware
	// This method allows you to update camera firmware
	StreamFirmwareUpdate(ctx context.Context, name string, body model.FirmwareUpdate) error
	// StreamGet Get one stream
	// This method allows to fetch a single stream. Refer to the `streams_list` operation to find out what data will be returned in this method.
	StreamGet(ctx context.Context, name string) (model.StreamConfig, error)
	// StreamPermissionUserDelete Delete stream permissions
	// Delete all permissions for a specific user to access a stream. Removes direct access permissions for a user to this stream. This API is accessible to: - Users with 'can_edit' permission for the stream - Organization admins with 'can_edit_streams' permission - Domain administrators - Organization owners
	StreamPermissionUserDelete(ctx context.Context, name string, user_id string) error
	// StreamPermissionUserGet Get user permissions to a stream
	// Returns the permissions that a specific user has for a specified stream via stream permissions. Shows detailed permissions a user has for this stream. This API is accessible to: - Users with 'can_edit' permission for the stream - Organization admins with 'can_edit_streams' permission - Domain administrators - Organization owners
	StreamPermissionUserGet(ctx context.Context, name string, user_id string) (model.StreamUserPermission, error)
	// StreamPermissionUserSave Update stream permissions
	// Saves permissions for a specific user to access a stream.  These permissions override folder-level permissions but are overridden by organization-level permissions. Updates or creates direct stream permissions for a user. These permissions override folder-level permissions but are overridden by organization-level permissions. This API is accessible to: - Users with 'can_edit' permission for the stream - Organization admins with 'can_edit_streams' permission - Domain administrators - Organization owners
	StreamPermissionUserSave(ctx context.Context, name string, user_id string, body model.StreamPermissionsAccess) (model.StreamUserPermission, error)
	// StreamPermissionsUsersList List users with permissions to a stream
	// Returns a list of users who have direct access to the specified stream via stream permissions. Lists all users with explicit permissions set for this stream. This API is accessible to: - Users with 'can_edit' permission for the stream - Organization admins with 'can_edit_streams' permission - Domain administrators - Organization owners
	StreamPermissionsUsersList(ctx context.Context, name string, query *StreamPermissionsUsersListQuery) (model.StreamUsersPermissionsList, error)
	// StreamPermissionsUsersListIterator iterates through all items using cursor pagination
	StreamPermissionsUsersListIterator(ctx context.Context, name string, query *StreamPermissionsUsersListQuery) iter.Seq2[model.StreamUserPermission, error]
	// StreamPtzExecute Execute a PTZ command
	// Execute a PTZ command
	StreamPtzExecute(ctx context.Context, name string, body model.PtzCommand) error
	// StreamSave Save stream
	// Create or update a stream by its name. If the stream doesn't exists in the disk config, it will be created.  If you try to update a stream that is started from a template by a user request having `named_by=user`, a new stream will be created in the disk config.  If you pass only a partial stream configuration, this field will be updated, not the whole stream.  To create a new stream the property `name` is required.  Pass the `"$reset": true` option to replace the stream configuration with the provided one.
	StreamSave(ctx context.Context, name string, query *StreamSaveQuery, body model.StreamConfig) (model.StreamConfig, error)
	// StreamsImport Import of streams
	// This method allows you to easily add or update camera configurations. If a camera with the specified name exists, its settings will be updated; otherwise, a new camera will be created. This is useful for making simultaneous changes to multiple cameras, such as integrating billing or setting up different user configurations.  New cameras will be added or existing ones updated without affecting others.  Requests can be sent in CSV format.  Ensure the user has permission to edit cameras in the relevant organizations before submitting.  If errors occur, no changes will be made, preserving the original configuration.
	StreamsImport(ctx context.Context) (model.StreamsImportResponse, error)
	// StreamsList List streams
	// This API method is one of the most important in whole API, because it gives the list of all streams.  `streams_list` in Watcher Admin API: * can list all streams within the Watcher. * admin is not allowed to watch content from any cameras for security reasons.  `streams_list` in Watcher Client API: * return streams from organizations where you're member * prodives a playback token that allows play video from the camera.
	StreamsList(ctx context.Context, query *StreamsListQuery) (model.StreamsList, error)
	// StreamsListIterator iterates through all items using cursor pagination
	StreamsListIterator(ctx context.Context, query *StreamsListQuery) iter.Seq2[model.StreamConfig, error]
	// StreamsMultiedit Save streams settings
	// Create or update settings for each stream. This operation does everything or nothing. If at least one stream has an invalid configuration or can't be processed, the request will fail.
	StreamsMultiedit(ctx context.Context, body model.StreamsMultieditConfig) error
	// UiSettingsGet Get UI settings
	// The method allows you to fetch UI settings including branding colors, logos, etc. It can work without authorization for the login page to be loaded.
	UiSettingsGet(ctx context.Context) (model.UiSettingsConfig, error)
	// UserApikeyCreate Create new apikey for user
	// Create apikey for user
	UserApikeyCreate(ctx context.Context) (model.Apikey, error)
	// UserApikeyDelete Delete apikey for user
	// Delete apikey for user
	UserApikeyDelete(ctx context.Context) error
	// UserApikeyGet Get users apikey
	// Get users apikey
	UserApikeyGet(ctx context.Context) (model.Apikey, error)
	// UserCreate Create user
	// This method allows you to create a user
	UserCreate(ctx context.Context, body any) (model.User, error)
	// UserDelete Delete a user
	// This method allows you to delete a user
	UserDelete(ctx context.Context, user_id string) error
	// UserGet Get a user
	// This method allows you to fetch the user by its identifier
	UserGet(ctx context.Context, user_id string) (model.User, error)
	// UserOrganizationFoldersList Get user's folders in organization
	// Get list of folders available for user in specific organization
	UserOrganizationFoldersList(ctx context.Context, user_id string, organization_id string, query *UserOrganizationFoldersListQuery) (model.UserFolders, error)
	// UserOrganizationFoldersListIterator iterates through all items using cursor pagination
	UserOrganizationFoldersListIterator(ctx context.Context, user_id string, organization_id string, query *UserOrganizationFoldersListQuery) iter.Seq2[model.UserFolder, error]
	// UserOrganizationsList Get user's organizations
	// Get list of organizations available for user
	UserOrganizationsList(ctx context.Context, user_id string, query *UserOrganizationsListQuery) (model.OrganizationsList, error)
	// UserOrganizationsListIterator iterates through all items using cursor pagination
	UserOrganizationsListIterator(ctx context.Context, user_id string, query *UserOrganizationsListQuery) iter.Seq2[model.Organization, error]
	// UserSave Save user
	// This method allows you to update user data
	UserSave(ctx context.Context, user_id string, body model.User) (model.User, error)
	// UserStreamPermissionDelete Delete stream permissions
	// Delete all permissions for the user to access a stream. Removes direct permissions for a user to access a specific stream. Note that the user may still have access via organization or folder permissions. This API is accessible to: - Organization admins with 'can_edit_users' permission - Domain administrators - Organization owners
	UserStreamPermissionDelete(ctx context.Context, user_id string, name string) error
	// UserStreamPermissionGet Get user permissions to a stream
	// Returns the permissions that the user has for a specified stream via stream permissions. Allows viewing user-specific stream permissions. This API is accessible to: - The user themselves - Organization admins with 'can_edit_users' permission - Domain administrators - Organization owners
	UserStreamPermissionGet(ctx context.Context, user_id string, name string) (model.UserStreamPermission, error)
	// UserStreamPermissionSave Update user's stream permissions
	// Save permissions for the user to access a stream. These permissions override folder-level permissions but are overridden by organization-level permissions. Updates or creates permissions for a user to access a specific stream. This API is accessible to: - Organization admins with 'can_edit_users' permission - Domain administrators - Organization owners
	UserStreamPermissionSave(ctx context.Context, user_id string, name string, body model.StreamPermissionsAccess) (model.UserStreamPermission, error)
	// UserStreamsPermissionsList List streams accessible to a user
	// Returns a list of streams to which the specified user has direct access via stream permissions. Lists all streams where a user has explicit permissions set. This API is accessible to: - The user themselves - Organization admins with 'can_edit_users' permission - Domain administrators - Organization owners
	UserStreamsPermissionsList(ctx context.Context, user_id string, query *UserStreamsPermissionsListQuery) (model.UserStreamsPermissionsList, error)
	// UserStreamsPermissionsListIterator iterates through all items using cursor pagination
	UserStreamsPermissionsListIterator(ctx context.Context, user_id string, query *UserStreamsPermissionsListQuery) iter.Seq2[model.UserStreamPermission, error]
	// UsersApikeyCreate Create new API key for user
	// The API key is used for authentication in API requests, allowing access to protected resources without using a password.
	UsersApikeyCreate(ctx context.Context, user_id string) (model.Apikey, error)
	// UsersApikeyGet Get user's API key
	// The API key is used for authentication in API requests, allowing access to protected resources without using a password.
	UsersApikeyGet(ctx context.Context, user_id string) (model.Apikey, error)
	// UsersList List of users
	// List of available users
	UsersList(ctx context.Context, query *UsersListQuery) (model.Users, error)
	// UsersListIterator iterates through all items using cursor pagination
	UsersListIterator(ctx context.Context, query *UsersListQuery) iter.Seq2[model.User, error]
	// WebPushSubscribe Create subscription
	// Subscribes the client to Push Messages
	WebPushSubscribe(ctx context.Context, body model.WebPushSubscriptionCreate) error
	// WebPushSubscriptionExistenceGet Subscription existence
	// Checks for subscription on the backend
	WebPushSubscriptionExistenceGet(ctx context.Context, query *WebPushSubscriptionExistenceGetQuery) (any, error)
	// WebPushUnsubscribe Delete subscription
	// Deletes the subscription, so the client will no longer receive Push Messages on it
	WebPushUnsubscribe(ctx context.Context, body model.WebPushSubscription) error
}

// EpisodeDeleteQuery represents query parameters for EpisodeDelete method
type EpisodeDeleteQuery struct {
	// Authorization token for unauthenticated access to the episode
	Token string
	Extra map[string]string
}

// ToQueryString converts EpisodeDeleteQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *EpisodeDeleteQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Token != "" {
		values.Set("token", q.Token)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// EpisodeGetQuery represents query parameters for EpisodeGet method
type EpisodeGetQuery struct {
	// Authorization token for unauthenticated access to the episode
	Token string
	Extra map[string]string
}

// ToQueryString converts EpisodeGetQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *EpisodeGetQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Token != "" {
		values.Set("token", q.Token)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// EpisodesListQuery represents query parameters for EpisodesList method
type EpisodesListQuery struct {
	Cursor string
	// Episode type
	EpisodeType string
	Limit       int
	// Filter the collection by media name on which the episode is registered
	Media string
	// Client may ask to delay a response if there are no episodes to fetch. This should be used as a long-poll mechanism for lightweight fetching episodes from origin.
	PollTimeout int
	// Request for the search across the streams being processed by the inference server. Query is a free-formed text that describes an object to search for and its attributes. Query may include color properties ("yellow"), appearance attributes ("beard"). Results may be inaccurate and should be reviewed by inspecting corresponding video fragments. In order to use "context search" feature packages [flussonic-vision](https://flussonic.com/doc/watcher-vision-installation/#watcher-vision-installation) and `vision-context-search` must be installed at the  inference server to make digital fingerprints of streams. In case you use the "q" parameter to get a list of episodes, the following collection filters are only supported: "media", "opened_at_gte", "opened_at_lte".
	Q      string
	Select string
	Sort   string
	// Filter the collection by episode update time. This field is rather specific because it allows to have an update stream with new/updated episodes
	UpdatedAtGt int
	Extra       map[string]string
}

// ToQueryString converts EpisodesListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *EpisodesListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.EpisodeType != "" {
		values.Set("episode_type", q.EpisodeType)
	}
	if q.Media != "" {
		values.Set("media", q.Media)
	}
	if q.PollTimeout != 0 {
		values.Set("poll_timeout", strconv.Itoa(q.PollTimeout))
	}
	if q.Q != "" {
		values.Set("q", q.Q)
	}
	if q.UpdatedAtGt != 0 {
		values.Set("updated_at_gt", strconv.Itoa(q.UpdatedAtGt))
	}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *EpisodesListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// FolderListQuery represents query parameters for FolderList method
type FolderListQuery struct {
	Cursor string
	Limit  int
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts FolderListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *FolderListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *FolderListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// FolderUsersListQuery represents query parameters for FolderUsersList method
type FolderUsersListQuery struct {
	Cursor string
	Limit  int
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts FolderUsersListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *FolderUsersListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *FolderUsersListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// MessagesListQuery represents query parameters for MessagesList method
type MessagesListQuery struct {
	Cursor string
	Limit  int
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts MessagesListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *MessagesListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *MessagesListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// MosaicsListQuery represents query parameters for MosaicsList method
type MosaicsListQuery struct {
	Cursor string
	Limit  int
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts MosaicsListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *MosaicsListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *MosaicsListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// OrganizationUsersListQuery represents query parameters for OrganizationUsersList method
type OrganizationUsersListQuery struct {
	Cursor string
	Limit  int
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts OrganizationUsersListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *OrganizationUsersListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *OrganizationUsersListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// OrganizationsListQuery represents query parameters for OrganizationsList method
type OrganizationsListQuery struct {
	Cursor string
	Limit  int
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts OrganizationsListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *OrganizationsListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *OrganizationsListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// PersonListsGetQuery represents query parameters for PersonListsGet method
type PersonListsGetQuery struct {
	Cursor string
	Limit  int
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts PersonListsGetQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *PersonListsGetQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *PersonListsGetQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// PersonsListQuery represents query parameters for PersonsList method
type PersonsListQuery struct {
	Cursor string
	Limit  int
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts PersonsListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *PersonsListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *PersonsListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// PresetsListQuery represents query parameters for PresetsList method
type PresetsListQuery struct {
	Cursor string
	Limit  int
	// Organization identifier to select presets only available for this organization. If the `organization_id` is not transferred, all available presets will be returned.
	OrganizationId int
	Select         string
	Sort           string
	Extra          map[string]string
}

// ToQueryString converts PresetsListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *PresetsListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.OrganizationId != 0 {
		values.Set("organization_id", strconv.Itoa(q.OrganizationId))
	}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *PresetsListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// StreamDeleteQuery represents query parameters for StreamDelete method
type StreamDeleteQuery struct {
	// part of config to delete
	Part  string
	Extra map[string]string
}

// ToQueryString converts StreamDeleteQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *StreamDeleteQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Part != "" {
		values.Set("part", q.Part)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// StreamPermissionsUsersListQuery represents query parameters for StreamPermissionsUsersList method
type StreamPermissionsUsersListQuery struct {
	Cursor string
	Limit  int
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts StreamPermissionsUsersListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *StreamPermissionsUsersListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *StreamPermissionsUsersListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// StreamSaveQuery represents query parameters for StreamSave method
type StreamSaveQuery struct {
	// The stream is configured by several origins of configuration. It may be `config_on_disk` or temporary runtime `config_override` that can be provided via `on_play` or `on_publish` backend, or edited via this API call if you pass `config_override` to this parameter.
	Part  string
	Extra map[string]string
}

// ToQueryString converts StreamSaveQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *StreamSaveQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Part != "" {
		values.Set("part", q.Part)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// StreamsListQuery represents query parameters for StreamsList method
type StreamsListQuery struct {
	Cursor string
	Limit  int
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts StreamsListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *StreamsListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *StreamsListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// UserOrganizationFoldersListQuery represents query parameters for UserOrganizationFoldersList method
type UserOrganizationFoldersListQuery struct {
	Cursor string
	Limit  int
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts UserOrganizationFoldersListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *UserOrganizationFoldersListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *UserOrganizationFoldersListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// UserOrganizationsListQuery represents query parameters for UserOrganizationsList method
type UserOrganizationsListQuery struct {
	// A parameter to filter organizations based on their edit availability for the current user
	CanEdit bool
	Cursor  string
	Limit   int
	Select  string
	Sort    string
	Extra   map[string]string
}

// ToQueryString converts UserOrganizationsListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *UserOrganizationsListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	values.Set("can_edit", strconv.FormatBool(q.CanEdit))
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *UserOrganizationsListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// UserStreamsPermissionsListQuery represents query parameters for UserStreamsPermissionsList method
type UserStreamsPermissionsListQuery struct {
	Cursor string
	Limit  int
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts UserStreamsPermissionsListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *UserStreamsPermissionsListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *UserStreamsPermissionsListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// UsersListQuery represents query parameters for UsersList method
type UsersListQuery struct {
	Cursor string
	Limit  int
	// Organization identifier to select users only available for this organization. If the `organization_id` is not transferred, all available users will be returned.
	OrganizationId int
	Select         string
	Sort           string
	Extra          map[string]string
}

// ToQueryString converts UsersListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *UsersListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.OrganizationId != 0 {
		values.Set("organization_id", strconv.Itoa(q.OrganizationId))
	}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *UsersListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// WebPushSubscriptionExistenceGetQuery represents query parameters for WebPushSubscriptionExistenceGet method
type WebPushSubscriptionExistenceGetQuery struct {
	// Subscription endpoint
	Endpoint string
	Extra    map[string]string
}

// ToQueryString converts WebPushSubscriptionExistenceGetQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *WebPushSubscriptionExistenceGetQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", fmt.Errorf("query is required")
	}
	if q.Endpoint == "" {
		return "", fmt.Errorf("query parameter 'endpoint' is required")
	}
	values := url.Values{}
	values.Set("endpoint", q.Endpoint)
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// BaseClientFactory is a factory function type for creating base HTTP clients.
type BaseClientFactory func(cfg *config.Config, apiURL string, authKey authorization.AuthKey) baseclient.BaseClient

// defaultBaseClientFactory creates a default base client instance.
func defaultBaseClientFactory(cfg *config.Config, apiURL string, authKey authorization.AuthKey) baseclient.BaseClient {
	return baseclient.New(cfg.HTTPClient, apiURL, authKey, cfg.Originator, cfg.Retry)
}

// Client is the concrete implementation of the WatcherClient interface.
type Client struct {
	base   baseclient.BaseClient
	apiURL string
}

// NewWithBaseFactory creates a new WatcherClient client with a custom base client factory.
// This is primarily used for testing or when custom HTTP client behavior is needed.
func NewWithBaseFactory(cfg *config.Config, baseFactory BaseClientFactory) (WatcherClient, error) {
	if cfg.Hostname == "" {
		return nil, fmt.Errorf("hostname is required")
	}

	if cfg.Protocol == "" {
		cfg.Protocol = "http"
	}

	if cfg.Port == 0 {
		if cfg.Protocol == "https" {
			cfg.Port = 443
		} else {
			cfg.Port = 80
		}
	}

	apiURL := fmt.Sprintf("%s://%s:%d", cfg.Protocol, cfg.Hostname, cfg.Port)

	var authKey authorization.AuthKey
	if cfg.Auth != nil {
		authKey = cfg.Auth
	} else if cfg.ClusterKey != "" {
		authKey = authorization.ClusterKey(cfg.ClusterKey)
	}

	if cfg.Originator == "" {
		cfg.Originator = config.DefaultOriginator
	}

	base := baseFactory(cfg, apiURL, authKey)

	return &Client{
		base:   base,
		apiURL: apiURL,
	}, nil
}

// New creates a new WatcherClient client with default settings.
func New(cfg *config.Config) (WatcherClient, error) {
	return NewWithBaseFactory(cfg, defaultBaseClientFactory)
}

// doGet performs a GET request and unmarshals the response into result.
func (c *Client) doGet(ctx context.Context, path string, result any) error {
	request, err := http.NewRequestWithContext(ctx, http.MethodGet, c.apiURL+path, http.NoBody)
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}
	request.Header.Set("Content-Type", "application/json")
	return c.base.Request(ctx, request, result)
}

// doPost performs a POST request with a JSON body and unmarshals the response into result.
func (c *Client) doPost(ctx context.Context, path string, body any, result any) error {
	bodyBytes, err := json.Marshal(body)
	if err != nil {
		return fmt.Errorf("failed to marshal request body: %w", err)
	}
	request, err := http.NewRequestWithContext(ctx, http.MethodPost, c.apiURL+path, bytes.NewBuffer(bodyBytes))
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}
	request.Header.Set("Content-Type", "application/json")
	return c.base.Request(ctx, request, result)
}

// doPut performs a PUT request with a JSON body and unmarshals the response into result.
func (c *Client) doPut(ctx context.Context, path string, body any, result any) error {
	bodyBytes, err := json.Marshal(body)
	if err != nil {
		return fmt.Errorf("failed to marshal request body: %w", err)
	}
	request, err := http.NewRequestWithContext(ctx, http.MethodPut, c.apiURL+path, bytes.NewBuffer(bodyBytes))
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}
	request.Header.Set("Content-Type", "application/json")
	return c.base.Request(ctx, request, result)
}

// doDelete performs a DELETE request.
func (c *Client) doDelete(ctx context.Context, path string) error {
	request, err := http.NewRequestWithContext(ctx, http.MethodDelete, c.apiURL+path, http.NoBody)
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}
	request.Header.Set("Content-Type", "application/json")
	return c.base.Request(ctx, request, nil)
}

// doList performs a GET request with query parameters and unmarshals the response into result.
func (c *Client) doList(ctx context.Context, path string, query interface{ ToQueryString() (string, error) }, result any) error {
	if query == nil {
		request, err := http.NewRequestWithContext(ctx, http.MethodGet, c.apiURL+path, http.NoBody)
		if err != nil {
			return fmt.Errorf("failed to create request: %w", err)
		}
		request.Header.Set("Content-Type", "application/json")
		return c.base.Request(ctx, request, result)
	}
	queryString, err := query.ToQueryString()
	if err != nil {
		return fmt.Errorf("failed to build query string: %w", err)
	}
	requestURL := c.apiURL + path
	if queryString != "" {
		requestURL += "?" + queryString
	}
	request, err := http.NewRequestWithContext(ctx, http.MethodGet, requestURL, http.NoBody)
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}
	request.Header.Set("Content-Type", "application/json")
	return c.base.Request(ctx, request, result)
}

// AgentActivationTokenCreate Create activation token
// This method creates activation token for agent. This token used by mobile app in qr-code for wifi camera with agent for adding camera with agent in watcher.
func (c *Client) AgentActivationTokenCreate(ctx context.Context, body model.AgentActivationTokenRequest) (model.AgentActivationToken, error) {
	path := "/watcher/client-api/v3/agent_activation_token"
	result := &model.AgentActivationTokenImpl{}
	if err := c.doPost(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// AgentActivationTokenGet Check activation token provisioned to watcher
// This method allows you to check that camera with agent was provisioned to watcher. If you got 404 on this method you - token not existing and you must create a new one to add camera with agent. If no camera_name field in response - camera not provisioned yet to watcher. If camera_name field in response - camera provisioned to watcher.
func (c *Client) AgentActivationTokenGet(ctx context.Context, token string) (model.AgentActivationToken, error) {
	path := fmt.Sprintf("/watcher/client-api/v3/agent_activation_token/%s", token)
	result := &model.AgentActivationTokenImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// CameraAuthGet Get auth for camera
// Create or update a auth for camera by its name.
func (c *Client) CameraAuthGet(ctx context.Context, name string) (model.Auth, error) {
	path := fmt.Sprintf("/watcher/client-api/v3/streams/%s/auth", name)
	result := &model.AuthImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// CameraAuthSave Save auth for camera
// Create or update a auth for camera by its name.
func (c *Client) CameraAuthSave(ctx context.Context, name string) (model.Auth, error) {
	path := fmt.Sprintf("/watcher/client-api/v3/streams/%s/auth", name)
	result := &model.AuthImpl{}
	if err := c.doPut(ctx, path, nil, result); err != nil {
		return nil, err
	}
	return result, nil
}

// CameraConfigGet Get one stream camera config
// This method allows to fetch a single stream camera config info.
func (c *Client) CameraConfigGet(ctx context.Context, name string) (model.CameraConfig, error) {
	path := fmt.Sprintf("/watcher/client-api/v3/streams/%s/camera_config", name)
	result := &model.CameraConfigImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// CameraConfigSave Save stream camera config
// Create or update a stream config by its name.
func (c *Client) CameraConfigSave(ctx context.Context, name string, body model.CameraConfig) (model.CameraConfig, error) {
	path := fmt.Sprintf("/watcher/client-api/v3/streams/%s/camera_config", name)
	result := &model.CameraConfigImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// CameraReboot Reboot camera
// Reboot camera
func (c *Client) CameraReboot(ctx context.Context, name string) error {
	path := fmt.Sprintf("/watcher/client-api/v3/streams/%s/reboot", name)
	if err := c.doPost(ctx, path, nil, nil); err != nil {
		return err
	}
	return nil
}

// DeleteOrganizationPreset Delete preset from organization
// This method allows to remove a specific preset from organization.
func (c *Client) DeleteOrganizationPreset(ctx context.Context, organization_id string, preset_id string) error {
	path := fmt.Sprintf("/watcher/client-api/v3/organizations/%s/presets/%s", organization_id, preset_id)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// DeviceTokenConfirm Confirm notification received by device
// Should be called by a device when notification received
func (c *Client) DeviceTokenConfirm(ctx context.Context, token string) (model.DeviceToken, error) {
	path := fmt.Sprintf("/watcher/client-api/v3/profile/device-tokens/%s/confirm", token)
	result := &model.DeviceTokenImpl{}
	if err := c.doPost(ctx, path, nil, result); err != nil {
		return nil, err
	}
	return result, nil
}

// DeviceTokenDelete Delete device token
// Delete device token. Mobile application have to delete all expired device tokens, received from Firebase.
func (c *Client) DeviceTokenDelete(ctx context.Context, token string) error {
	path := fmt.Sprintf("/watcher/client-api/v3/profile/device-tokens/%s", token)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// DeviceTokenGet Get device token
// Returns a device token info
func (c *Client) DeviceTokenGet(ctx context.Context, token string) (model.DeviceToken, error) {
	path := fmt.Sprintf("/watcher/client-api/v3/profile/device-tokens/%s", token)
	result := &model.DeviceTokenImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// DeviceTokenSave Save a new device token
// Save a new device token in Watcher. You can read how to create it here: https://firebase.google.com/docs/cloud-messaging/android/client?hl=en#sample-register You must save and refresh token if you want to receive notifications about [camera events](#tag/profile/operation/event_subscription_create).
func (c *Client) DeviceTokenSave(ctx context.Context, token string, body model.DeviceToken) (model.DeviceToken, error) {
	path := fmt.Sprintf("/watcher/client-api/v3/profile/device-tokens/%s", token)
	result := &model.DeviceTokenImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// EpisodeAddToFavorites Add episode to the favorites
// This method allows you to add an episode to the favorites.
func (c *Client) EpisodeAddToFavorites(ctx context.Context, episode_id string) error {
	path := fmt.Sprintf("/watcher/client-api/v3/episodes/%s/favorites", episode_id)
	if err := c.doPost(ctx, path, nil, nil); err != nil {
		return err
	}
	return nil
}

// EpisodeDelete Delete episode
// This method allows you to delete a registered episode. Only manually created episodes can be deleted. Episodes created automatically by the system (e.g., by video analytics) cannot be deleted.
func (c *Client) EpisodeDelete(ctx context.Context, episode_id string, query *EpisodeDeleteQuery) error {
	path := fmt.Sprintf("/watcher/client-api/v3/episodes/%s", episode_id)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// EpisodeDeleteFromFavorites Delete episode from the favorites
// This method allows you to delete an episode from the favorites.
func (c *Client) EpisodeDeleteFromFavorites(ctx context.Context, episode_id string) error {
	path := fmt.Sprintf("/watcher/client-api/v3/episodes/%s/favorites", episode_id)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// EpisodeGet Get episode
// This method allows you to fetch a registered episode
func (c *Client) EpisodeGet(ctx context.Context, episode_id string, query *EpisodeGetQuery) (model.WatcherEpisode, error) {
	path := fmt.Sprintf("/watcher/client-api/v3/episodes/%s", episode_id)
	result := &model.WatcherEpisodeImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// EpisodesList List episodes
// This method allows you to fetch registered episodes
func (c *Client) EpisodesList(ctx context.Context, query *EpisodesListQuery) (model.EpisodesList, error) {
	path := "/watcher/client-api/v3/episodes"
	result := &model.EpisodesListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// EpisodesListIterator iterates through all WatcherEpisode items using cursor pagination.
func (c *Client) EpisodesListIterator(ctx context.Context, query *EpisodesListQuery) iter.Seq2[model.WatcherEpisode, error] {
	return cursors.Iterator(ctx, c.EpisodesList, query)
}

// EventSubscriptionCreate Create a new event subscription on specific stream
// Create a new event subscription
func (c *Client) EventSubscriptionCreate(ctx context.Context, body model.SubscriptionRequest) (model.Subscription, error) {
	path := "/watcher/client-api/v3/profile/subscriptions/stream_event"
	result := &model.SubscriptionImpl{}
	if err := c.doPost(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// EventSubscriptionDelete Unsubscribe from events on specific stream
// Delete subscription on events
func (c *Client) EventSubscriptionDelete(ctx context.Context, body model.SubscriptionRequest) error {
	path := "/watcher/client-api/v3/profile/subscriptions/stream_event"
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// FolderCreate Create folder
// Create folder.
func (c *Client) FolderCreate(ctx context.Context, organization_id string, body model.Folder) (model.Folder, error) {
	path := fmt.Sprintf("/watcher/client-api/v3/organizations/%s/folders", organization_id)
	result := &model.FolderImpl{}
	if err := c.doPost(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// FolderDelete Delete folder
// This method allows to delete a folder.
func (c *Client) FolderDelete(ctx context.Context, organization_id string, folder_id string) error {
	path := fmt.Sprintf("/watcher/client-api/v3/organizations/%s/folders/%s", organization_id, folder_id)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// FolderGet Get folder info
// This method allows to fetch folder info.
func (c *Client) FolderGet(ctx context.Context, organization_id string, folder_id string) (model.Folder, error) {
	path := fmt.Sprintf("/watcher/client-api/v3/organizations/%s/folders/%s", organization_id, folder_id)
	result := &model.FolderImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// FolderList Get list of folders
// This method allows to fetch a list of folders info.
func (c *Client) FolderList(ctx context.Context, organization_id string, query *FolderListQuery) (model.FoldersList, error) {
	path := fmt.Sprintf("/watcher/client-api/v3/organizations/%s/folders", organization_id)
	result := &model.FoldersListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// FolderListIterator iterates through all Folder items using cursor pagination.
func (c *Client) FolderListIterator(ctx context.Context, organization_id string, query *FolderListQuery) iter.Seq2[model.Folder, error] {
	return cursors.Iterator(ctx, func(ctx context.Context, query *FolderListQuery) (model.FoldersList, error) {
		return c.FolderList(ctx, organization_id, query)
	}, query)
}

// FolderSave Save folder
// Save folder.
func (c *Client) FolderSave(ctx context.Context, organization_id string, folder_id string, body model.Folder) (model.Folder, error) {
	path := fmt.Sprintf("/watcher/client-api/v3/organizations/%s/folders/%s", organization_id, folder_id)
	result := &model.FolderImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// FolderUserDelete Delete user in a folder
// This method allows to delete user info in a folder.
func (c *Client) FolderUserDelete(ctx context.Context, organization_id string, folder_id string, user_id string) error {
	path := fmt.Sprintf("/watcher/client-api/v3/organizations/%s/folders/%s/users/%s", organization_id, folder_id, user_id)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// FolderUserGet Get user in a folder
// This method allows to fetch user in a folder.
func (c *Client) FolderUserGet(ctx context.Context, organization_id string, folder_id string, user_id string) (model.FolderUser, error) {
	path := fmt.Sprintf("/watcher/client-api/v3/organizations/%s/folders/%s/users/%s", organization_id, folder_id, user_id)
	result := &model.FolderUserImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// FolderUserSave Save user in a folder
// Save user info in a folder.
func (c *Client) FolderUserSave(ctx context.Context, organization_id string, folder_id string, user_id string, body model.FolderUser) (model.FolderUser, error) {
	path := fmt.Sprintf("/watcher/client-api/v3/organizations/%s/folders/%s/users/%s", organization_id, folder_id, user_id)
	result := &model.FolderUserImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// FolderUsersList Get a list of users in a folder
// This method allows to fetch a list of users in a folder.
func (c *Client) FolderUsersList(ctx context.Context, organization_id string, folder_id string, query *FolderUsersListQuery) (model.FolderUsersList, error) {
	path := fmt.Sprintf("/watcher/client-api/v3/organizations/%s/folders/%s/users", organization_id, folder_id)
	result := &model.FolderUsersListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// FolderUsersListIterator iterates through all FolderUsers items using cursor pagination.
func (c *Client) FolderUsersListIterator(ctx context.Context, organization_id string, folder_id string, query *FolderUsersListQuery) iter.Seq2[model.FolderUsers, error] {
	return cursors.Iterator(ctx, func(ctx context.Context, query *FolderUsersListQuery) (model.FolderUsersList, error) {
		return c.FolderUsersList(ctx, organization_id, folder_id, query)
	}, query)
}

// GetInviteShortInfo Get organization invite short info
// This method allows to get short info about organization invite.
func (c *Client) GetInviteShortInfo(ctx context.Context, invite_key string) (model.OrganizationBase, error) {
	path := fmt.Sprintf("/watcher/client-api/v3/organizations/invite/%s", invite_key)
	result := &model.OrganizationBaseImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// LoginCreate Get an auth token
// The method creates a new temporary auth-token (JWT). The JTW token used as Bearer token in requests other than `/login`.
func (c *Client) LoginCreate(ctx context.Context) (model.LoginInfoAdditional, error) {
	path := "/watcher/client-api/v3/login"
	result := &model.LoginInfoAdditionalImpl{}
	if err := c.doPost(ctx, path, nil, result); err != nil {
		return nil, err
	}
	return result, nil
}

// MessageDelete Delete a message
// This method allows you to delete a message
func (c *Client) MessageDelete(ctx context.Context, message_id string) error {
	path := fmt.Sprintf("/watcher/client-api/v3/messages/%s", message_id)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// MessageGet Get a message
// This method allows you to fetch the message by its identifier
func (c *Client) MessageGet(ctx context.Context, message_id string) (model.Message, error) {
	path := fmt.Sprintf("/watcher/client-api/v3/messages/%s", message_id)
	result := &model.MessageImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// MessageSend Send a message
// This method allows you to send a message to a user
func (c *Client) MessageSend(ctx context.Context, body model.MessageSend) (model.MessageResponse, error) {
	path := "/watcher/client-api/v3/messages"
	result := &model.MessageResponseImpl{}
	if err := c.doPost(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// MessageUpdate Update message
// Update message by its id.
func (c *Client) MessageUpdate(ctx context.Context, message_id string, body model.MessageChangeRequest) (model.Message, error) {
	path := fmt.Sprintf("/watcher/client-api/v3/messages/%s", message_id)
	result := &model.MessageImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// MessagesList List of messages
// List of messages
func (c *Client) MessagesList(ctx context.Context, query *MessagesListQuery) (model.Messages, error) {
	path := "/watcher/client-api/v3/messages"
	result := &model.MessagesImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// MessagesListIterator iterates through all Message items using cursor pagination.
func (c *Client) MessagesListIterator(ctx context.Context, query *MessagesListQuery) iter.Seq2[model.Message, error] {
	return cursors.Iterator(ctx, c.MessagesList, query)
}

// MosaicCreate Create mosaic
// This method allows you to create a mosaic
func (c *Client) MosaicCreate(ctx context.Context, body any) (model.Mosaic, error) {
	path := "/watcher/client-api/v3/mosaics"
	result := &model.MosaicImpl{}
	if err := c.doPost(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// MosaicDelete Delete a mosaic
// This method allows you to delete a mosaic
func (c *Client) MosaicDelete(ctx context.Context, mosaic_id string) error {
	path := fmt.Sprintf("/watcher/client-api/v3/mosaics/%s", mosaic_id)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// MosaicGet Get mosaic detail
// This method is used to get info about mosaic by its id.
func (c *Client) MosaicGet(ctx context.Context, mosaic_id string) (model.Mosaic, error) {
	path := fmt.Sprintf("/watcher/client-api/v3/mosaics/%s", mosaic_id)
	result := &model.MosaicImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// MosaicSave Save mosaic
// This method allows you to update mosaic data
func (c *Client) MosaicSave(ctx context.Context, mosaic_id string, body model.MosaicSave) (model.Mosaic, error) {
	path := fmt.Sprintf("/watcher/client-api/v3/mosaics/%s", mosaic_id)
	result := &model.MosaicImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// MosaicsList List mosaics
// Returns the list of all mosaics. Mosaics allow you to combine multiple cameras to display on a single screen.
func (c *Client) MosaicsList(ctx context.Context, query *MosaicsListQuery) (model.MosaicsList, error) {
	path := "/watcher/client-api/v3/mosaics"
	result := &model.MosaicsListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// MosaicsListIterator iterates through all Mosaic items using cursor pagination.
func (c *Client) MosaicsListIterator(ctx context.Context, query *MosaicsListQuery) iter.Seq2[model.Mosaic, error] {
	return cursors.Iterator(ctx, c.MosaicsList, query)
}

// NotificationSend Send an arbitrary push notification
// Send an arbitrary push notification. This method sends test push notification to user.
func (c *Client) NotificationSend(ctx context.Context, body any) error {
	path := "/watcher/client-api/v3/notifications/notify"
	if err := c.doPost(ctx, path, body, nil); err != nil {
		return err
	}
	return nil
}

// OrganizationCreate Create organization
// Create new organization
func (c *Client) OrganizationCreate(ctx context.Context, body model.Organization) (model.Organization, error) {
	path := "/watcher/client-api/v3/organizations"
	result := &model.OrganizationImpl{}
	if err := c.doPost(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// OrganizationDelete Delete organization
// Delete organization by its id.
func (c *Client) OrganizationDelete(ctx context.Context, organization_id string) error {
	path := fmt.Sprintf("/watcher/client-api/v3/organizations/%s", organization_id)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// OrganizationGet Get single organization info
// This method allows to fetch a single organization info. Refer to the `organizations_list` operation to find out what data will be returned in this method.
func (c *Client) OrganizationGet(ctx context.Context, organization_id string) (model.Organization, error) {
	path := fmt.Sprintf("/watcher/client-api/v3/organizations/%s", organization_id)
	result := &model.OrganizationImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// OrganizationInviteAccept Accept organization invite
// This method allows to accept organization invite and add user to organization.
func (c *Client) OrganizationInviteAccept(ctx context.Context, invite_key string) error {
	path := fmt.Sprintf("/watcher/client-api/v3/organizations/invite/%s", invite_key)
	if err := c.doPut(ctx, path, nil, nil); err != nil {
		return err
	}
	return nil
}

// OrganizationInviteCreate Create organization invite key
// This method allows to create a single organizations invite key.  Using this key user can invite other users to the organization.  Only organization owner can create invite key.
func (c *Client) OrganizationInviteCreate(ctx context.Context, organization_id string, body model.OrganizationInviteSetup) (model.OrganizationInviteKey, error) {
	path := fmt.Sprintf("/watcher/client-api/v3/organizations/%s/invite", organization_id)
	result := &model.OrganizationInviteKeyImpl{}
	if err := c.doPost(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// OrganizationPresetSave Update organizations preset
// Save organization preset by its id or adds new preset to organization.
func (c *Client) OrganizationPresetSave(ctx context.Context, organization_id string, body model.OrganizationPreset) (model.Preset, error) {
	path := fmt.Sprintf("/watcher/client-api/v3/organizations/%s/presets", organization_id)
	result := &model.PresetImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// OrganizationSave Update organization
// Update organization by its id.
func (c *Client) OrganizationSave(ctx context.Context, organization_id string, body model.Organization) (model.Organization, error) {
	path := fmt.Sprintf("/watcher/client-api/v3/organizations/%s", organization_id)
	result := &model.OrganizationImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// OrganizationUserDelete Delete user from organization
// Delete user from organization by its id.
func (c *Client) OrganizationUserDelete(ctx context.Context, organization_id string, user_id string) error {
	path := fmt.Sprintf("/watcher/client-api/v3/organizations/%s/users/%s", organization_id, user_id)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// OrganizationUserGet Get single organization user info
// This method allows to fetch a single organizations user info.
func (c *Client) OrganizationUserGet(ctx context.Context, organization_id string, user_id string) (model.OrganizationUser, error) {
	path := fmt.Sprintf("/watcher/client-api/v3/organizations/%s/users/%s", organization_id, user_id)
	result := &model.OrganizationUserImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// OrganizationUserSave Update organizations user
// Update organization user by its id or adds new user to organization.
func (c *Client) OrganizationUserSave(ctx context.Context, organization_id string, user_id string, body model.OrganizationPermissions) (model.OrganizationUser, error) {
	path := fmt.Sprintf("/watcher/client-api/v3/organizations/%s/users/%s", organization_id, user_id)
	result := &model.OrganizationUserImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// OrganizationUsersList List users in organization
// Users who are members of the organization
func (c *Client) OrganizationUsersList(ctx context.Context, organization_id string, query *OrganizationUsersListQuery) (model.OrganizationUsersList, error) {
	path := fmt.Sprintf("/watcher/client-api/v3/organizations/%s/users", organization_id)
	result := &model.OrganizationUsersListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// OrganizationUsersListIterator iterates through all OrganizationUser items using cursor pagination.
func (c *Client) OrganizationUsersListIterator(ctx context.Context, organization_id string, query *OrganizationUsersListQuery) iter.Seq2[model.OrganizationUser, error] {
	return cursors.Iterator(ctx, func(ctx context.Context, query *OrganizationUsersListQuery) (model.OrganizationUsersList, error) {
		return c.OrganizationUsersList(ctx, organization_id, query)
	}, query)
}

// OrganizationsList List organizations
// Organizations of which the user is member
func (c *Client) OrganizationsList(ctx context.Context, query *OrganizationsListQuery) (model.OrganizationsList, error) {
	path := "/watcher/client-api/v3/organizations"
	result := &model.OrganizationsListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// OrganizationsListIterator iterates through all Organization items using cursor pagination.
func (c *Client) OrganizationsListIterator(ctx context.Context, query *OrganizationsListQuery) iter.Seq2[model.Organization, error] {
	return cursors.Iterator(ctx, c.OrganizationsList, query)
}

// PasswordRecovery Send password recovery email
// Send user email with password recovery instructions. This method will return success  regardless of whether there is a user with the specified email address or not
func (c *Client) PasswordRecovery(ctx context.Context, body any) error {
	path := "/watcher/client-api/v3/password_recovery"
	if err := c.doPost(ctx, path, body, nil); err != nil {
		return err
	}
	return nil
}

// PersonDelete Delete person
// Delete person by its id.
func (c *Client) PersonDelete(ctx context.Context, person_id string) error {
	path := fmt.Sprintf("/watcher/client-api/v3/persons/%s", person_id)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// PersonGet Get the Person
// This method allows you to fetch the person by its identifier
func (c *Client) PersonGet(ctx context.Context, person_id string) (model.Person, error) {
	path := fmt.Sprintf("/watcher/client-api/v3/persons/%s", person_id)
	result := &model.PersonImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// PersonListsGet Lists Person
// This method allows you to fetch the person lists
func (c *Client) PersonListsGet(ctx context.Context, query *PersonListsGetQuery) (model.PersonListsList, error) {
	path := "/watcher/client-api/v3/person_lists"
	result := &model.PersonListsListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// PersonListsGetIterator iterates through all PersonLists items using cursor pagination.
func (c *Client) PersonListsGetIterator(ctx context.Context, query *PersonListsGetQuery) iter.Seq2[model.PersonLists, error] {
	return cursors.Iterator(ctx, c.PersonListsGet, query)
}

// PersonsList List Persons
// The list of registered videoanalytics persons
func (c *Client) PersonsList(ctx context.Context, query *PersonsListQuery) (model.PersonsList, error) {
	path := "/watcher/client-api/v3/persons"
	result := &model.PersonsListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// PersonsListIterator iterates through all VisionPerson items using cursor pagination.
func (c *Client) PersonsListIterator(ctx context.Context, query *PersonsListQuery) iter.Seq2[model.VisionPerson, error] {
	return cursors.Iterator(ctx, c.PersonsList, query)
}

// PresetGet Get one preset
// This method is used to get info about preset by its id.
func (c *Client) PresetGet(ctx context.Context, id string) (model.Preset, error) {
	path := fmt.Sprintf("/watcher/client-api/v3/presets/%s", id)
	result := &model.PresetImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// PresetsList List presets
// The presets in Watcher is a set of DVR and analytics parameters that you can use as a template when creating and configuring cameras. When you select a preset in the camera settings, the parameters from the preset are populated to the camera settings. A set of presets on the camera is defined by the set of presets selected for the camera's Organization. https://flussonic.com/doc/manage-presets-in-watcher-ui/  This method is used to get info about presets. If the `organization_id` is transferred this method will return presets only allowed in organization with that Id.
func (c *Client) PresetsList(ctx context.Context, query *PresetsListQuery) (model.PresetsList, error) {
	path := "/watcher/client-api/v3/presets"
	result := &model.PresetsListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// PresetsListIterator iterates through all Preset items using cursor pagination.
func (c *Client) PresetsListIterator(ctx context.Context, query *PresetsListQuery) iter.Seq2[model.Preset, error] {
	return cursors.Iterator(ctx, c.PresetsList, query)
}

// ProfileGet Get profile info
// Get profile info.
func (c *Client) ProfileGet(ctx context.Context) (model.Profile, error) {
	path := "/watcher/client-api/v3/profile"
	result := &model.ProfileImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// ProfileSave Update profile info
// Update profile info.
func (c *Client) ProfileSave(ctx context.Context, body model.Profile) (model.Profile, error) {
	path := "/watcher/client-api/v3/profile"
	result := &model.ProfileImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// ResetPassword Reset password
// Changes user password
func (c *Client) ResetPassword(ctx context.Context, body model.PasswordReset) error {
	path := "/watcher/client-api/v3/reset_password"
	if err := c.doPost(ctx, path, body, nil); err != nil {
		return err
	}
	return nil
}

// StreamDelete Delete the stream
// This method allows to delete a single stream. You can delete `config_override` by this API call if you want to remove all runtime overrides.  If you do not specify any `part` parameter, this stream will be deleted from `config_on_disk` and if it was `named_by: config`, then it will immediately stop.
func (c *Client) StreamDelete(ctx context.Context, name string, query *StreamDeleteQuery) error {
	path := fmt.Sprintf("/watcher/client-api/v3/streams/%s", name)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// StreamFirmwareUpdate Update camera firmware
// This method allows you to update camera firmware
func (c *Client) StreamFirmwareUpdate(ctx context.Context, name string, body model.FirmwareUpdate) error {
	path := fmt.Sprintf("/watcher/client-api/v3/streams/%s/firmware_update", name)
	if err := c.doPut(ctx, path, body, nil); err != nil {
		return err
	}
	return nil
}

// StreamGet Get one stream
// This method allows to fetch a single stream. Refer to the `streams_list` operation to find out what data will be returned in this method.
func (c *Client) StreamGet(ctx context.Context, name string) (model.StreamConfig, error) {
	path := fmt.Sprintf("/watcher/client-api/v3/streams/%s", name)
	result := &model.StreamConfigImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// StreamPermissionUserDelete Delete stream permissions
// Delete all permissions for a specific user to access a stream. Removes direct access permissions for a user to this stream. This API is accessible to: - Users with 'can_edit' permission for the stream - Organization admins with 'can_edit_streams' permission - Domain administrators - Organization owners
func (c *Client) StreamPermissionUserDelete(ctx context.Context, name string, user_id string) error {
	path := fmt.Sprintf("/watcher/client-api/v3/streams/%s/permissions/users/%s", name, user_id)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// StreamPermissionUserGet Get user permissions to a stream
// Returns the permissions that a specific user has for a specified stream via stream permissions. Shows detailed permissions a user has for this stream. This API is accessible to: - Users with 'can_edit' permission for the stream - Organization admins with 'can_edit_streams' permission - Domain administrators - Organization owners
func (c *Client) StreamPermissionUserGet(ctx context.Context, name string, user_id string) (model.StreamUserPermission, error) {
	path := fmt.Sprintf("/watcher/client-api/v3/streams/%s/permissions/users/%s", name, user_id)
	result := &model.StreamUserPermissionImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// StreamPermissionUserSave Update stream permissions
// Saves permissions for a specific user to access a stream.  These permissions override folder-level permissions but are overridden by organization-level permissions. Updates or creates direct stream permissions for a user. These permissions override folder-level permissions but are overridden by organization-level permissions. This API is accessible to: - Users with 'can_edit' permission for the stream - Organization admins with 'can_edit_streams' permission - Domain administrators - Organization owners
func (c *Client) StreamPermissionUserSave(ctx context.Context, name string, user_id string, body model.StreamPermissionsAccess) (model.StreamUserPermission, error) {
	path := fmt.Sprintf("/watcher/client-api/v3/streams/%s/permissions/users/%s", name, user_id)
	result := &model.StreamUserPermissionImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// StreamPermissionsUsersList List users with permissions to a stream
// Returns a list of users who have direct access to the specified stream via stream permissions. Lists all users with explicit permissions set for this stream. This API is accessible to: - Users with 'can_edit' permission for the stream - Organization admins with 'can_edit_streams' permission - Domain administrators - Organization owners
func (c *Client) StreamPermissionsUsersList(ctx context.Context, name string, query *StreamPermissionsUsersListQuery) (model.StreamUsersPermissionsList, error) {
	path := fmt.Sprintf("/watcher/client-api/v3/streams/%s/permissions/users", name)
	result := &model.StreamUsersPermissionsListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// StreamPermissionsUsersListIterator iterates through all StreamUserPermission items using cursor pagination.
func (c *Client) StreamPermissionsUsersListIterator(ctx context.Context, name string, query *StreamPermissionsUsersListQuery) iter.Seq2[model.StreamUserPermission, error] {
	return cursors.Iterator(ctx, func(ctx context.Context, query *StreamPermissionsUsersListQuery) (model.StreamUsersPermissionsList, error) {
		return c.StreamPermissionsUsersList(ctx, name, query)
	}, query)
}

// StreamPtzExecute Execute a PTZ command
// Execute a PTZ command
func (c *Client) StreamPtzExecute(ctx context.Context, name string, body model.PtzCommand) error {
	path := fmt.Sprintf("/watcher/client-api/v3/streams/%s/ptz", name)
	if err := c.doPost(ctx, path, body, nil); err != nil {
		return err
	}
	return nil
}

// StreamSave Save stream
// Create or update a stream by its name. If the stream doesn't exists in the disk config, it will be created.  If you try to update a stream that is started from a template by a user request having `named_by=user`, a new stream will be created in the disk config.  If you pass only a partial stream configuration, this field will be updated, not the whole stream.  To create a new stream the property `name` is required.  Pass the `"$reset": true` option to replace the stream configuration with the provided one.
func (c *Client) StreamSave(ctx context.Context, name string, query *StreamSaveQuery, body model.StreamConfig) (model.StreamConfig, error) {
	path := fmt.Sprintf("/watcher/client-api/v3/streams/%s", name)
	result := &model.StreamConfigImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// StreamsImport Import of streams
// This method allows you to easily add or update camera configurations. If a camera with the specified name exists, its settings will be updated; otherwise, a new camera will be created. This is useful for making simultaneous changes to multiple cameras, such as integrating billing or setting up different user configurations.  New cameras will be added or existing ones updated without affecting others.  Requests can be sent in CSV format.  Ensure the user has permission to edit cameras in the relevant organizations before submitting.  If errors occur, no changes will be made, preserving the original configuration.
func (c *Client) StreamsImport(ctx context.Context) (model.StreamsImportResponse, error) {
	path := "/watcher/client-api/v3/streams/import"
	result := &model.StreamsImportResponseImpl{}
	if err := c.doPost(ctx, path, nil, result); err != nil {
		return nil, err
	}
	return result, nil
}

// StreamsList List streams
// This API method is one of the most important in whole API, because it gives the list of all streams.  `streams_list` in Watcher Admin API: * can list all streams within the Watcher. * admin is not allowed to watch content from any cameras for security reasons.  `streams_list` in Watcher Client API: * return streams from organizations where you're member * prodives a playback token that allows play video from the camera.
func (c *Client) StreamsList(ctx context.Context, query *StreamsListQuery) (model.StreamsList, error) {
	path := "/watcher/client-api/v3/streams"
	result := &model.StreamsListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// StreamsListIterator iterates through all StreamConfig items using cursor pagination.
func (c *Client) StreamsListIterator(ctx context.Context, query *StreamsListQuery) iter.Seq2[model.StreamConfig, error] {
	return cursors.Iterator(ctx, c.StreamsList, query)
}

// StreamsMultiedit Save streams settings
// Create or update settings for each stream. This operation does everything or nothing. If at least one stream has an invalid configuration or can't be processed, the request will fail.
func (c *Client) StreamsMultiedit(ctx context.Context, body model.StreamsMultieditConfig) error {
	path := "/watcher/client-api/v3/streams/multiedit"
	if err := c.doPost(ctx, path, body, nil); err != nil {
		return err
	}
	return nil
}

// UiSettingsGet Get UI settings
// The method allows you to fetch UI settings including branding colors, logos, etc. It can work without authorization for the login page to be loaded.
func (c *Client) UiSettingsGet(ctx context.Context) (model.UiSettingsConfig, error) {
	path := "/watcher/client-api/v3/ui_settings"
	result := &model.UiSettingsConfigImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// UserApikeyCreate Create new apikey for user
// Create apikey for user
func (c *Client) UserApikeyCreate(ctx context.Context) (model.Apikey, error) {
	path := "/watcher/client-api/v3/profile/apikey"
	result := &model.ApikeyImpl{}
	if err := c.doPost(ctx, path, nil, result); err != nil {
		return nil, err
	}
	return result, nil
}

// UserApikeyDelete Delete apikey for user
// Delete apikey for user
func (c *Client) UserApikeyDelete(ctx context.Context) error {
	path := "/watcher/client-api/v3/profile/apikey"
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// UserApikeyGet Get users apikey
// Get users apikey
func (c *Client) UserApikeyGet(ctx context.Context) (model.Apikey, error) {
	path := "/watcher/client-api/v3/profile/apikey"
	result := &model.ApikeyImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// UserCreate Create user
// This method allows you to create a user
func (c *Client) UserCreate(ctx context.Context, body any) (model.User, error) {
	path := "/watcher/client-api/v3/users"
	result := &model.UserImpl{}
	if err := c.doPost(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// UserDelete Delete a user
// This method allows you to delete a user
func (c *Client) UserDelete(ctx context.Context, user_id string) error {
	path := fmt.Sprintf("/watcher/client-api/v3/users/%s", user_id)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// UserGet Get a user
// This method allows you to fetch the user by its identifier
func (c *Client) UserGet(ctx context.Context, user_id string) (model.User, error) {
	path := fmt.Sprintf("/watcher/client-api/v3/users/%s", user_id)
	result := &model.UserImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// UserOrganizationFoldersList Get user's folders in organization
// Get list of folders available for user in specific organization
func (c *Client) UserOrganizationFoldersList(ctx context.Context, user_id string, organization_id string, query *UserOrganizationFoldersListQuery) (model.UserFolders, error) {
	path := fmt.Sprintf("/watcher/client-api/v3/users/%s/organization/%s/folders", user_id, organization_id)
	result := &model.UserFoldersImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// UserOrganizationFoldersListIterator iterates through all UserFolder items using cursor pagination.
func (c *Client) UserOrganizationFoldersListIterator(ctx context.Context, user_id string, organization_id string, query *UserOrganizationFoldersListQuery) iter.Seq2[model.UserFolder, error] {
	return cursors.Iterator(ctx, func(ctx context.Context, query *UserOrganizationFoldersListQuery) (model.UserFolders, error) {
		return c.UserOrganizationFoldersList(ctx, user_id, organization_id, query)
	}, query)
}

// UserOrganizationsList Get user's organizations
// Get list of organizations available for user
func (c *Client) UserOrganizationsList(ctx context.Context, user_id string, query *UserOrganizationsListQuery) (model.OrganizationsList, error) {
	path := fmt.Sprintf("/watcher/client-api/v3/users/%s/organization", user_id)
	result := &model.OrganizationsListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// UserOrganizationsListIterator iterates through all Organization items using cursor pagination.
func (c *Client) UserOrganizationsListIterator(ctx context.Context, user_id string, query *UserOrganizationsListQuery) iter.Seq2[model.Organization, error] {
	return cursors.Iterator(ctx, func(ctx context.Context, query *UserOrganizationsListQuery) (model.OrganizationsList, error) {
		return c.UserOrganizationsList(ctx, user_id, query)
	}, query)
}

// UserSave Save user
// This method allows you to update user data
func (c *Client) UserSave(ctx context.Context, user_id string, body model.User) (model.User, error) {
	path := fmt.Sprintf("/watcher/client-api/v3/users/%s", user_id)
	result := &model.UserImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// UserStreamPermissionDelete Delete stream permissions
// Delete all permissions for the user to access a stream. Removes direct permissions for a user to access a specific stream. Note that the user may still have access via organization or folder permissions. This API is accessible to: - Organization admins with 'can_edit_users' permission - Domain administrators - Organization owners
func (c *Client) UserStreamPermissionDelete(ctx context.Context, user_id string, name string) error {
	path := fmt.Sprintf("/watcher/client-api/v3/users/%s/permissions/streams/%s", user_id, name)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// UserStreamPermissionGet Get user permissions to a stream
// Returns the permissions that the user has for a specified stream via stream permissions. Allows viewing user-specific stream permissions. This API is accessible to: - The user themselves - Organization admins with 'can_edit_users' permission - Domain administrators - Organization owners
func (c *Client) UserStreamPermissionGet(ctx context.Context, user_id string, name string) (model.UserStreamPermission, error) {
	path := fmt.Sprintf("/watcher/client-api/v3/users/%s/permissions/streams/%s", user_id, name)
	result := &model.UserStreamPermissionImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// UserStreamPermissionSave Update user's stream permissions
// Save permissions for the user to access a stream. These permissions override folder-level permissions but are overridden by organization-level permissions. Updates or creates permissions for a user to access a specific stream. This API is accessible to: - Organization admins with 'can_edit_users' permission - Domain administrators - Organization owners
func (c *Client) UserStreamPermissionSave(ctx context.Context, user_id string, name string, body model.StreamPermissionsAccess) (model.UserStreamPermission, error) {
	path := fmt.Sprintf("/watcher/client-api/v3/users/%s/permissions/streams/%s", user_id, name)
	result := &model.UserStreamPermissionImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// UserStreamsPermissionsList List streams accessible to a user
// Returns a list of streams to which the specified user has direct access via stream permissions. Lists all streams where a user has explicit permissions set. This API is accessible to: - The user themselves - Organization admins with 'can_edit_users' permission - Domain administrators - Organization owners
func (c *Client) UserStreamsPermissionsList(ctx context.Context, user_id string, query *UserStreamsPermissionsListQuery) (model.UserStreamsPermissionsList, error) {
	path := fmt.Sprintf("/watcher/client-api/v3/users/%s/permissions/streams", user_id)
	result := &model.UserStreamsPermissionsListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// UserStreamsPermissionsListIterator iterates through all UserStreamPermission items using cursor pagination.
func (c *Client) UserStreamsPermissionsListIterator(ctx context.Context, user_id string, query *UserStreamsPermissionsListQuery) iter.Seq2[model.UserStreamPermission, error] {
	return cursors.Iterator(ctx, func(ctx context.Context, query *UserStreamsPermissionsListQuery) (model.UserStreamsPermissionsList, error) {
		return c.UserStreamsPermissionsList(ctx, user_id, query)
	}, query)
}

// UsersApikeyCreate Create new API key for user
// The API key is used for authentication in API requests, allowing access to protected resources without using a password.
func (c *Client) UsersApikeyCreate(ctx context.Context, user_id string) (model.Apikey, error) {
	path := fmt.Sprintf("/watcher/client-api/v3/users/%s/apikey", user_id)
	result := &model.ApikeyImpl{}
	if err := c.doPost(ctx, path, nil, result); err != nil {
		return nil, err
	}
	return result, nil
}

// UsersApikeyGet Get user's API key
// The API key is used for authentication in API requests, allowing access to protected resources without using a password.
func (c *Client) UsersApikeyGet(ctx context.Context, user_id string) (model.Apikey, error) {
	path := fmt.Sprintf("/watcher/client-api/v3/users/%s/apikey", user_id)
	result := &model.ApikeyImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// UsersList List of users
// List of available users
func (c *Client) UsersList(ctx context.Context, query *UsersListQuery) (model.Users, error) {
	path := "/watcher/client-api/v3/users"
	result := &model.UsersImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// UsersListIterator iterates through all User items using cursor pagination.
func (c *Client) UsersListIterator(ctx context.Context, query *UsersListQuery) iter.Seq2[model.User, error] {
	return cursors.Iterator(ctx, c.UsersList, query)
}

// WebPushSubscribe Create subscription
// Subscribes the client to Push Messages
func (c *Client) WebPushSubscribe(ctx context.Context, body model.WebPushSubscriptionCreate) error {
	path := "/watcher/client-api/v3/web_push/subscribe"
	if err := c.doPost(ctx, path, body, nil); err != nil {
		return err
	}
	return nil
}

// WebPushSubscriptionExistenceGet Subscription existence
// Checks for subscription on the backend
func (c *Client) WebPushSubscriptionExistenceGet(ctx context.Context, query *WebPushSubscriptionExistenceGetQuery) (any, error) {
	path := "/watcher/client-api/v3/web_push/subscription"
	var result any
	if err := c.doList(ctx, path, query, nil); err != nil {
		return nil, err
	}
	return result, nil
}

// WebPushUnsubscribe Delete subscription
// Deletes the subscription, so the client will no longer receive Push Messages on it
func (c *Client) WebPushUnsubscribe(ctx context.Context, body model.WebPushSubscription) error {
	path := "/watcher/client-api/v3/web_push/unsubscribe"
	if err := c.doPost(ctx, path, body, nil); err != nil {
		return err
	}
	return nil
}
