// Code generated by cmd/main. DO NOT EDIT.
package model

// agent_id
type AgentID string

// agent://ID identification for `via` configuration option
type AgentURL string

// base64
type Base64 string

// byte
type Byte string

// bytes
type Bytes int

// client_count
type ClientCount int

// email
type Email string

// Protocol for connecting to camera.
type FirmwareUpdateProto string

const (
	// Iris protocol
	FirmwareUpdateProtoIris FirmwareUpdateProto = "iris"
	// ISAPI/PSIA protocol
	FirmwareUpdateProtoIsapi FirmwareUpdateProto = "isapi"
	// Xm protocol
	FirmwareUpdateProtoXm FirmwareUpdateProto = "xm"
	// MSTAR/Sputnik protocol
	FirmwareUpdateProtoSputnik FirmwareUpdateProto = "sputnik"
)

type FolderHierarchyShiftDirection string

const (
	// This parameter allows changing the folders order set by `order_num` without re-numbering all folders manually.
	// Just specify the ID of the folder (on the same level within the parent folder) to place the current folder after.
	// Watcher will rearrange the order numbers automatically.
	//
	// You can use `shift_before` parameter instead depending on your situation.
	//
	FolderHierarchyShiftDirectionAfter FolderHierarchyShiftDirection = "after"
	// This parameter allows changing the folders order set by `order_num` without re-numbering all folders manually.
	// Just specify the ID of the folder (on the same level within the parent folder) to place the current folder before.
	// Watcher will rearrange the order numbers automatically.
	//
	// You can use `shift_after` parameter instead depending on your situation.
	//
	FolderHierarchyShiftDirectionBefore FolderHierarchyShiftDirection = "before"
	// This parameter allows changing the level of the folder in the hierarchy.
	// Specify the parent folder ID to place the current folder under it.
	//
	FolderHierarchyShiftDirectionInside FolderHierarchyShiftDirection = "inside"
)

// hexbinary
type Hexbinary string

type ISO6391 string

// input_url
type InputURL string

// Whether it is a file with a finite start and end time or a live stream.
type MediaInfoSpecificFlowType string

const (
	MediaInfoSpecificFlowTypeFile      MediaInfoSpecificFlowType = "file"
	MediaInfoSpecificFlowTypeStream    MediaInfoSpecificFlowType = "stream"
	MediaInfoSpecificFlowTypeDvrFile   MediaInfoSpecificFlowType = "dvr_file"
	MediaInfoSpecificFlowTypeDvrStream MediaInfoSpecificFlowType = "dvr_stream"
)

// media_name
type MediaName string

// The type of a message.
type MessageBaseType string

const (
	// The info message type.
	//
	MessageBaseTypeInfo MessageBaseType = "info"
	// The warning message type.
	//
	MessageBaseTypeWarning MessageBaseType = "warning"
	// The danger message type.
	//
	MessageBaseTypeDanger MessageBaseType = "danger"
)

// milliseconds
type Milliseconds float64

// Use this parameter to specify mosaic display mode and size.
type MosaicBaseType string

const (
	// Size 1x7
	MosaicBaseType1X7 MosaicBaseType = "1x7"
	// Size 2x2
	MosaicBaseType2X2 MosaicBaseType = "2x2"
	// Size 3x3
	MosaicBaseType3X3 MosaicBaseType = "3x3"
	// Size 4x4
	MosaicBaseType4X4 MosaicBaseType = "4x4"
	// Size 5x5
	MosaicBaseType5X5 MosaicBaseType = "5x5"
	// Size 6x6
	MosaicBaseType6X6 MosaicBaseType = "6x6"
	// Size 7x7
	MosaicBaseType7X7 MosaicBaseType = "7x7"
	// Size 8x8
	MosaicBaseType8X8 MosaicBaseType = "8x8"
)

type OnOffAutoMode string

const (
	// The system is turned on
	OnOffAutoModeOn OnOffAutoMode = "on"
	// The system is turned off
	OnOffAutoModeOff OnOffAutoMode = "off"
	// The system automatically adjusts based on conditions
	OnOffAutoModeAuto OnOffAutoMode = "auto"
)

type OnOffMode string

const (
	// The system is turned on
	OnOffModeOn OnOffMode = "on"
	// The system is turned off
	OnOffModeOff OnOffMode = "off"
)

// percent
type Percent int

// phone-number
type PhoneNumber string

// pixels
type Pixels int

// seconds
type Seconds float64

// Installation position of the camera
type SensorImageOrientation string

const (
	// Default camera mount.
	SensorImageOrientationNormal SensorImageOrientation = "normal"
	// Camera is mounted on the ceiling.
	SensorImageOrientationUpsideDown SensorImageOrientation = "upside_down"
)

// snowflake_id
type SnowflakeID int

// speed
type Speed int

// This configuration is deprecated. Use `dvbocr` configuration field in stream.
//
// This parameter allows to manage subtitles in an output stream.
type StreamInputMpegtsSpecificSubtitles string

const (
	// An output stream will have no subtitles track.
	StreamInputMpegtsSpecificSubtitlesDrop StreamInputMpegtsSpecificSubtitles = "drop"
	// An output stream will have a subtitles track in DVB, without conversion to text (default behavior).
	StreamInputMpegtsSpecificSubtitlesAccept StreamInputMpegtsSpecificSubtitles = "accept"
	// An output stream will have a track containing subtitles converted to a text format (WebVTT).
	StreamInputMpegtsSpecificSubtitlesOcrReplace StreamInputMpegtsSpecificSubtitles = "ocr_replace"
	// An output stream will have two tracks containing subtitles:
	// the original track with subtitles in DVB and a new track with text subtitles.
	//
	StreamInputMpegtsSpecificSubtitlesOcrAdd StreamInputMpegtsSpecificSubtitles = "ocr_add"
)

// This configuration is deprecated. Use `dvbocr` configuration field in stream.
//
// This parameter allows to manage subtitles in an output stream.
type StreamInputSrtPublishSpecificSubtitles string

const (
	// An output stream will have no subtitles track.
	StreamInputSrtPublishSpecificSubtitlesDrop StreamInputSrtPublishSpecificSubtitles = "drop"
	// An output stream will have a subtitles track in DVB, without conversion to text (default behavior).
	StreamInputSrtPublishSpecificSubtitlesAccept StreamInputSrtPublishSpecificSubtitles = "accept"
	// An output stream will have a track containing subtitles converted to a text format (WebVTT).
	StreamInputSrtPublishSpecificSubtitlesOcrReplace StreamInputSrtPublishSpecificSubtitles = "ocr_replace"
	// An output stream will have two tracks containing subtitles:
	// the original track with subtitles in DVB and a new track with text subtitles.
	//
	StreamInputSrtPublishSpecificSubtitlesOcrAdd StreamInputSrtPublishSpecificSubtitles = "ocr_add"
)

// ticks
type Ticks float64

// uri
type URI string

// url
type URL string

// The parameter regulates the rights for the user
type UserAdminAccessLevel string

const (
	// Defines standard rights for the user (access is allowed only in the client ui and
	// view of those cameras to which access is granted explicitly)
	//
	UserAdminAccessLevelGeneric UserAdminAccessLevel = "generic"
	// Grants full rights (allows you to create organizations,
	// use both admin ui and client ui, change domain settings)
	//
	UserAdminAccessLevelAdmin UserAdminAccessLevel = "admin"
)

// Unix timestamp in seconds
type Utc int

// Unix timestamp in milliseconds
type UtcMs int

// The algorithm used for video analytics.
type VisionSpecAlg string

const (
	// The algorithm for face recognition is used.
	VisionSpecAlgFaces VisionSpecAlg = "faces"
	// The algorithm for license plate recognition is used.
	VisionSpecAlgPlates VisionSpecAlg = "plates"
)

// The algorithm used for video analytics.
type VisionSpecPresetsAlg string

const (
	// The algorithm for face recognition is used.
	VisionSpecPresetsAlgFaces VisionSpecPresetsAlg = "faces"
	// The algorithm for license plate recognition is used.
	VisionSpecPresetsAlgPlates VisionSpecPresetsAlg = "plates"
)

type EpisodeCloseReason string

const (
	// Episode was closed because of no activity was detected in it.
	EpisodeCloseReasonTimeout EpisodeCloseReason = "timeout"
)

type FrameAppCodec string

const (
	FrameAppCodecMpegts FrameAppCodec = "mpegts"
	FrameAppCodecObject FrameAppCodec = "object"
	FrameAppCodecEit    FrameAppCodec = "eit"
	FrameAppCodecScte27 FrameAppCodec = "scte27"
	FrameAppCodecScte35 FrameAppCodec = "scte35"
	FrameAppCodecKlv    FrameAppCodec = "klv"
	FrameAppCodecEmpty  FrameAppCodec = "empty"
)

type FrameAudioCodec string

const (
	FrameAudioCodecAac FrameAudioCodec = "aac"
)

type FrameCodec string

type FrameContent string

const (
	FrameContentAudio       FrameContent = "audio"
	FrameContentVideo       FrameContent = "video"
	FrameContentText        FrameContent = "text"
	FrameContentMetadata    FrameContent = "metadata"
	FrameContentApplication FrameContent = "application"
)

type FrameRawCodec string

const (
	FrameRawCodecYuv       FrameRawCodec = "yuv"
	FrameRawCodecUyvy422   FrameRawCodec = "uyvy422"
	FrameRawCodecYuyv422   FrameRawCodec = "yuyv422"
	FrameRawCodecYuv422p10 FrameRawCodec = "yuv422p10"
	FrameRawCodecArgb      FrameRawCodec = "argb"
	FrameRawCodecRgb48     FrameRawCodec = "rgb48"
	FrameRawCodecV210      FrameRawCodec = "v210"
	FrameRawCodecPcm       FrameRawCodec = "pcm"
	FrameRawCodecR210      FrameRawCodec = "r210"
)

type FrameTextCodec string

const (
	FrameTextCodecTtxt     FrameTextCodec = "ttxt"
	FrameTextCodecText     FrameTextCodec = "text"
	FrameTextCodecWvtt     FrameTextCodec = "wvtt"
	FrameTextCodecTtml     FrameTextCodec = "ttml"
	FrameTextCodecSubtitle FrameTextCodec = "subtitle"
	FrameTextCodecId3t     FrameTextCodec = "id3t"
	FrameTextCodecOnvif    FrameTextCodec = "onvif"
	FrameTextCodecTx3g     FrameTextCodec = "tx3g"
)

type FrameVideoCodec string

const (
	FrameVideoCodecH264   FrameVideoCodec = "h264"
	FrameVideoCodecHevc   FrameVideoCodec = "hevc"
	FrameVideoCodecMp2v   FrameVideoCodec = "mp2v"
	FrameVideoCodecVp9    FrameVideoCodec = "vp9"
	FrameVideoCodecMjpeg  FrameVideoCodec = "mjpeg"
	FrameVideoCodecScreen FrameVideoCodec = "screen"
	FrameVideoCodecJpeg   FrameVideoCodec = "jpeg"
	FrameVideoCodecAv1    FrameVideoCodec = "av1"
	FrameVideoCodecJ2k    FrameVideoCodec = "j2k"
)

type FrameVideoPixFmt string

const (
	FrameVideoPixFmtYuv420p   FrameVideoPixFmt = "yuv420p"
	FrameVideoPixFmtYuvj420p  FrameVideoPixFmt = "yuvj420p"
	FrameVideoPixFmtYuv422p   FrameVideoPixFmt = "yuv422p"
	FrameVideoPixFmtYuv444p   FrameVideoPixFmt = "yuv444p"
	FrameVideoPixFmtYuv420p10 FrameVideoPixFmt = "yuv420p10"
	FrameVideoPixFmtYuv422p10 FrameVideoPixFmt = "yuv422p10"
	FrameVideoPixFmtYuv444p10 FrameVideoPixFmt = "yuv444p10"
	FrameVideoPixFmtYuv420p12 FrameVideoPixFmt = "yuv420p12"
	FrameVideoPixFmtYuv422p12 FrameVideoPixFmt = "yuv422p12"
	FrameVideoPixFmtYuv444p12 FrameVideoPixFmt = "yuv444p12"
	FrameVideoPixFmtGray8     FrameVideoPixFmt = "gray8"
	FrameVideoPixFmtGray10    FrameVideoPixFmt = "gray10"
	FrameVideoPixFmtGray12    FrameVideoPixFmt = "gray12"
	FrameVideoPixFmtNv12      FrameVideoPixFmt = "nv12"
	FrameVideoPixFmtP016      FrameVideoPixFmt = "p016"
	FrameVideoPixFmtV210      FrameVideoPixFmt = "v210"
	FrameVideoPixFmtUyvy422   FrameVideoPixFmt = "uyvy422"
	FrameVideoPixFmtYuyv422   FrameVideoPixFmt = "yuyv422"
	FrameVideoPixFmtRgb48     FrameVideoPixFmt = "rgb48"
	FrameVideoPixFmtArgb      FrameVideoPixFmt = "argb"
	FrameVideoPixFmtX2rgb10be FrameVideoPixFmt = "x2rgb10be"
)

type MediaQuality string

const (
	MediaQualityLow    MediaQuality = "low"
	MediaQualityMedium MediaQuality = "medium"
	MediaQualityHigh   MediaQuality = "high"
)

type OutputAudio string

const (
	// Keep the original audio codec.
	OutputAudioKeep OutputAudio = "keep"
	// Keep AAC if available or transcode to AAC; delete other tracks if any.
	OutputAudioAac OutputAudio = "aac"
	// Add AAC if it was not available already while keeping the original track.
	OutputAudioAddAac OutputAudio = "add_aac"
	// Make silence in audio track by using AAC codec. Replace original non-AAC track to AAC.
	OutputAudioAacSilence OutputAudio = "aac_silence"
	// Make silence in audio track by using original audio codec.
	OutputAudioKeepSilence OutputAudio = "keep_silence"
)

type Protocol string

const (
	ProtocolCopy         Protocol = "copy"
	ProtocolFake         Protocol = "fake"
	ProtocolRTP          Protocol = "rtp"
	ProtocolRtmp         Protocol = "rtmp"
	ProtocolRtmps        Protocol = "rtmps"
	ProtocolRtmpe        Protocol = "rtmpe"
	ProtocolRtsp         Protocol = "rtsp"
	ProtocolRtspUDP      Protocol = "rtsp-udp"
	ProtocolRtsp2        Protocol = "rtsp2"
	ProtocolRtsps        Protocol = "rtsps"
	ProtocolEst          Protocol = "est"
	ProtocolSrt          Protocol = "srt"
	ProtocolMseld        Protocol = "mseld"
	ProtocolShoutcast    Protocol = "shoutcast"
	ProtocolShoutcasts   Protocol = "shoutcasts"
	ProtocolWebrtc       Protocol = "webrtc"
	ProtocolHls          Protocol = "hls"
	ProtocolHlss         Protocol = "hlss"
	ProtocolHls2         Protocol = "hls2"
	ProtocolHlss2        Protocol = "hlss2"
	ProtocolLlhls        Protocol = "llhls"
	ProtocolCmaf         Protocol = "cmaf"
	ProtocolDash         Protocol = "dash"
	ProtocolMss          Protocol = "mss"
	ProtocolM4s          Protocol = "m4s"
	ProtocolM4ss         Protocol = "m4ss"
	ProtocolM4f          Protocol = "m4f"
	ProtocolM4fs         Protocol = "m4fs"
	ProtocolTshttp       Protocol = "tshttp"
	ProtocolTshttps      Protocol = "tshttps"
	ProtocolTstcp        Protocol = "tstcp"
	ProtocolTsssl        Protocol = "tsssl"
	ProtocolFlv          Protocol = "flv"
	ProtocolAnnexb       Protocol = "annexb"
	ProtocolUDP          Protocol = "udp"
	ProtocolUdp1         Protocol = "udp1"
	ProtocolUdp2         Protocol = "udp2"
	ProtocolUdp3         Protocol = "udp3"
	ProtocolMptsUDP      Protocol = "mpts-udp"
	ProtocolMptsHTTP     Protocol = "mpts-http"
	ProtocolMptsHTTPS    Protocol = "mpts-https"
	ProtocolMptsDvb      Protocol = "mpts-dvb"
	ProtocolDvb          Protocol = "dvb"
	ProtocolDecklink     Protocol = "decklink"
	ProtocolDektec       Protocol = "dektec"
	ProtocolDektecAsi    Protocol = "dektec-asi"
	ProtocolV4l          Protocol = "v4l"
	ProtocolV4l2         Protocol = "v4l2"
	ProtocolPlaylist     Protocol = "playlist"
	ProtocolMixer        Protocol = "mixer"
	ProtocolMosaic       Protocol = "mosaic"
	ProtocolMosaic2      Protocol = "mosaic2"
	ProtocolTimeshift    Protocol = "timeshift"
	ProtocolFile         Protocol = "file"
	ProtocolDownload     Protocol = "download"
	ProtocolMbr          Protocol = "mbr"
	ProtocolMp4          Protocol = "mp4"
	ProtocolLogo         Protocol = "logo"
	ProtocolJpeg         Protocol = "jpeg"
	ProtocolMjpeg        Protocol = "mjpeg"
	ProtocolH323         Protocol = "h323"
	ProtocolAdInjector   Protocol = "ad_injector"
	ProtocolFfmpeg       Protocol = "ffmpeg"
	ProtocolTransponder  Protocol = "transponder"
	ProtocolAPI          Protocol = "api"
	ProtocolJSONManifest Protocol = "json_manifest"
	ProtocolPlayer       Protocol = "player"
	ProtocolNdi          Protocol = "ndi"
	ProtocolFrip         Protocol = "frip"
	ProtocolSt2110       Protocol = "st2110"
	ProtocolBackup       Protocol = "backup"
	ProtocolMxl          Protocol = "mxl"
)

type StreamInput any

type StreamStatus string

const (
	// Input is OK, stream is ready to be served to your audience.
	StreamStatusRunning StreamStatus = "running"
	// Flussonic awaits for input (publish) or it's an 'on demand' stream waiting for client.
	StreamStatusWaiting StreamStatus = "waiting"
	// Something is wrong and Flussonic is not able to serve the stream to your audience.
	StreamStatusError StreamStatus = "error"
)

type ThumbnailsEnabledSpec any

type VisionDetector string

const (
	VisionDetectorFaces    VisionDetector = "faces"
	VisionDetectorVehicles VisionDetector = "vehicles"
	VisionDetectorMotion   VisionDetector = "motion"
	VisionDetectorQrCodes  VisionDetector = "qr-codes"
	VisionDetectorHumans   VisionDetector = "humans"
)

type VisionImageMimetype string

const (
	// jpeg
	VisionImageMimetypeImageJpeg VisionImageMimetype = "image/jpeg"
)

// Object class
type VisionObjectClass string

const (
	VisionObjectClassFace         VisionObjectClass = "face"
	VisionObjectClassLicensePlate VisionObjectClass = "license_plate"
	VisionObjectClassVehicle      VisionObjectClass = "vehicle"
	VisionObjectClassHuman        VisionObjectClass = "human"
)

type VisionPersonOriginator string

const (
	// Person is created by operator or external system via API.
	// For example, when you add the person in Watcher UI, it has `originator=api`.
	// But when you edit an automatically created person in UI, `originator=identification_service` remains.
	//
	VisionPersonOriginatorAPI VisionPersonOriginator = "api"
	// Person is created automatically by the Identification service
	// because no matching person was found in the persons database.
	//
	// The Identification service stores unrecognized persons and matches new episodes with them
	// in case if it becomes known who this is (i.e. if operator edits such person in UI to specify name).
	//
	VisionPersonOriginatorIdentificationService VisionPersonOriginator = "identification_service"
)

// Emergency type of the vehicle, e.g. ambulance, police, firetruck.
type VisionVehicleEmergencySubtype string

const (
	// ambulance car
	VisionVehicleEmergencySubtypeAmbulance VisionVehicleEmergencySubtype = "ambulance"
	// police car
	VisionVehicleEmergencySubtypePolice VisionVehicleEmergencySubtype = "police"
	// firetruck car
	VisionVehicleEmergencySubtypeFiretruck VisionVehicleEmergencySubtype = "firetruck"
)

// Shows from which side the vehicle was detected.
type VisionVehicleFacingSide string

const (
	// The vehicle was detected from the front.
	VisionVehicleFacingSideFront VisionVehicleFacingSide = "front"
	// The vehicle was detected from the rear.
	VisionVehicleFacingSideRear VisionVehicleFacingSide = "rear"
)

// The purpose of the vehicle, e.g. emergency or regular.
// Police, ambulance cars and firetrucks are being detected by the videoanalytics as `emergency`.
// Any other type of vehicle is marked as `regular`.
type VisionVehiclePurpose string

const (
	// Regular car
	VisionVehiclePurposeRegular VisionVehiclePurpose = "regular"
	// Emergency vehicle (police, ambulance or firetruck)
	VisionVehiclePurposeEmergency VisionVehiclePurpose = "emergency"
)

type WebrtcPreferVideoCodec string

type WebrtcTransport string

const (
	WebrtcTransportUDP WebrtcTransport = "udp"
	WebrtcTransportTCP WebrtcTransport = "tcp"
)

// Required: token
type AgentActivationToken interface {
	// A unique stream name. Its presence notifies about the binding of the agent token to the stream.
	StreamName() *string
	// A unique stream name. Its presence notifies about the binding of the agent token to the stream.
	SetStreamName(string) AgentActivationToken
	// Agent activation token.
	Token() string
	// Agent activation token.
	SetToken(string) AgentActivationToken
}

type AgentActivationTokenRequest interface {
	// Any text note about the camera.
	Comment() *string
	// Any text note about the camera.
	SetComment(string) AgentActivationTokenRequest
	Coordinates() Coordinates
	SetCoordinates(Coordinates) AgentActivationTokenRequest
	// The archive depth for the camera (the number of days).
	DvrDepth() *int
	// The archive depth for the camera (the number of days).
	SetDvrDepth(int) AgentActivationTokenRequest
	// The maximum storage space for the camera's archive, in Gigabytes.
	DvrSpace() *int
	// The maximum storage space for the camera's archive, in Gigabytes.
	SetDvrSpace(int) AgentActivationTokenRequest
	// Shows if the camera enabled or not. If the camera is enabled (the parameter is true), video from it is captured by the streamer.
	Enabled() *bool
	// Shows if the camera enabled or not. If the camera is enabled (the parameter is true), video from it is captured by the streamer.
	SetEnabled(bool) AgentActivationTokenRequest
	// The identifier of a folder to which the camera is added.
	FolderID() *int
	// The identifier of a folder to which the camera is added.
	SetFolderID(int) AgentActivationTokenRequest
	// The identifier of the Organization to which the camera belongs.
	// The user activating the camera must have the right to control the cameras in this organization.
	// If user belongs to only one organization, camera will be automatically added to this organization.
	// If user belongs to multiple organizations, this parameter is required.
	OrganizationID() *int
	// The identifier of the Organization to which the camera belongs.
	// The user activating the camera must have the right to control the cameras in this organization.
	// If user belongs to only one organization, camera will be automatically added to this organization.
	// If user belongs to multiple organizations, this parameter is required.
	SetOrganizationID(int) AgentActivationTokenRequest
	// The postal address of the camera.
	PostalAddress() *string
	// The postal address of the camera.
	SetPostalAddress(string) AgentActivationTokenRequest
	// The identifier of the preset assigned to the camera.
	// If this parameter is not specified, the camera will be added with default preset.
	PresetID() *int
	// The identifier of the preset assigned to the camera.
	// If this parameter is not specified, the camera will be added with default preset.
	SetPresetID(int) AgentActivationTokenRequest
	// If true, the video is captured continuously; if false, the camera is in "On-demand" mode.
	Static() *bool
	// If true, the video is captured continuously; if false, the camera is in "On-demand" mode.
	SetStatic(bool) AgentActivationTokenRequest
	// Human readable title of the camera as displayed in the UI. If not specified, title will be automatically generated.
	Title() *string
	// Human readable title of the camera as displayed in the UI. If not specified, title will be automatically generated.
	SetTitle(string) AgentActivationTokenRequest
}

// Users apikey for access via API.
type Apikey interface {
	// Apikey for users access via API.
	Apikey() *string
	// Apikey for users access via API.
	SetApikey(string) Apikey
}

type AuditLogRecord interface {
	// The time when the last changes were made.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	CreatedAt() *UtcMs
	// The time when the last changes were made.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetCreatedAt(UtcMs) AuditLogRecord
	// Who initiated the last changes.
	// Examples: admin
	User() *string
	// Who initiated the last changes.
	// Examples: admin
	SetUser(string) AuditLogRecord
}

// Authentication details configuration
type Auth interface {
	// Username authentication
	Login() *string
	// Username authentication
	SetLogin(string) Auth
	// Password authentication
	Password() *string
	// Password authentication
	SetPassword(string) Auth
	// Service port on which Onvif/PSIA is accessible, default is 80
	Port() *int
	// Service port on which Onvif/PSIA is accessible, default is 80
	SetPort(int) Auth
}

type CameraConfig interface {
	// Describes camera information.
	CameraInfo() any
	// Describes camera information.
	SetCameraInfo(any) CameraConfig
	// These parameters allow optimizing media quality and performance based on device capabilities and network conditions.
	MediaQuality() any
	// These parameters allow optimizing media quality and performance based on device capabilities and network conditions.
	SetMediaQuality(any) CameraConfig
	// Describes sensor configuration.
	Sensor() any
	// Describes sensor configuration.
	SetSensor(any) CameraConfig
}

// Camera information
type CameraInfo interface {
	// Firmware version
	Firmware() *string
	// Firmware version
	SetFirmware(string) CameraInfo
	// Manufacturer name
	Manufacturer() *string
	// Manufacturer name
	SetManufacturer(string) CameraInfo
	// Model name
	Model() *string
	// Model name
	SetModel(string) CameraInfo
	// Serial number
	SerialNumber() *string
	// Serial number
	SetSerialNumber(string) CameraInfo
}

type CameraTagWb interface {
}

type ClosedCaptions interface {
	// Language of closed captions.
	// Example: eng
	Language() *string
	// Language of closed captions.
	// Example: eng
	SetLanguage(string) ClosedCaptions
	// Under what name the audio track will be displayed on the player.
	// Example: English
	Name() *string
	// Under what name the audio track will be displayed on the player.
	// Example: English
	SetName(string) ClosedCaptions
}

type CollectionResponse interface {
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	EstimatedCount() *int
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	SetEstimatedCount(int) CollectionResponse
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	Next() *string
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	SetNext(string) CollectionResponse
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	Prev() *string
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	SetPrev(string) CollectionResponse
	// An object with a list of different timings measured during this API call.
	Timing() any
	// An object with a list of different timings measured during this API call.
	SetTiming(any) CollectionResponse
}

// The camera geographic coordinates: latitude and longitude.
type Coordinates interface {
	// Latitude.
	Latitude() *float64
	// Latitude.
	SetLatitude(float64) Coordinates
	// Longitude.
	Longitude() *float64
	// Longitude.
	SetLongitude(float64) Coordinates
}

// Device info
// Required: platform
type DeviceInfo interface {
	// Device model
	Model() *string
	// Device model
	SetModel(string) DeviceInfo
	// Device platform
	Platform() string
	// Device platform
	SetPlatform(string) DeviceInfo
	// Device platform version
	Version() *string
	// Device platform version
	SetVersion(string) DeviceInfo
}

// Generated with firebase token
// Required: token
type DeviceToken interface {
	Device() DeviceInfo
	SetDevice(DeviceInfo) DeviceToken
	// Device token. You can read how to create it here: https://firebase.google.com/docs/cloud-messaging/android/client?hl=en#sample-register
	Token() string
	// Device token. You can read how to create it here: https://firebase.google.com/docs/cloud-messaging/android/client?hl=en#sample-register
	SetToken(string) DeviceToken
}

type DvrBaseConfig interface {
	// Additional archive depth in seconds for episodes. If set, episodes and their corresponding DVR record
	// will be saved for `expiration + episodes_expiration` seconds.
	// The archive clean-up within `[expiration, expiration+episodes_expiration]` seconds of the
	// recording performed depending on [external_episodes_list](https://flussonic.com/doc/api/config-external/#tag/dvr/operation/external_episodes_list)
	// response of `episodes_url`.
	// Anything older than `expiration+episodes_expiration` seconds will
	// be cleaned even if `episodes_url` does not respond.
	// Format: seconds (seconds)
	// Examples: 6.048e+06
	EpisodesExpiration() *Seconds
	// Additional archive depth in seconds for episodes. If set, episodes and their corresponding DVR record
	// will be saved for `expiration + episodes_expiration` seconds.
	// The archive clean-up within `[expiration, expiration+episodes_expiration]` seconds of the
	// recording performed depending on [external_episodes_list](https://flussonic.com/doc/api/config-external/#tag/dvr/operation/external_episodes_list)
	// response of `episodes_url`.
	// Anything older than `expiration+episodes_expiration` seconds will
	// be cleaned even if `episodes_url` does not respond.
	// Format: seconds (seconds)
	// Examples: 6.048e+06
	SetEpisodesExpiration(Seconds) DvrBaseConfig
	// Archive depth - a period (in seconds) back from the current moment during which the
	// contigious part of archive is stored.
	// As time goes, the parts of the recording which are older than the archive depth are deleted.
	// If you have option `episodes_expiration` enabled, then some parts of DVR that are
	// locked by episode signalling mechanism may be kept more than this `expiration` depth.
	// If `episodes_url` does not respond, the archive clean-up by `expiration` is not performed;
	// only the archive with expired episodes (`episodes_expiration`) is cleaned up until the `episodes_url` restores.
	// Format: seconds (seconds)
	// Examples: 604800
	Expiration() *Seconds
	// Archive depth - a period (in seconds) back from the current moment during which the
	// contigious part of archive is stored.
	// As time goes, the parts of the recording which are older than the archive depth are deleted.
	// If you have option `episodes_expiration` enabled, then some parts of DVR that are
	// locked by episode signalling mechanism may be kept more than this `expiration` depth.
	// If `episodes_url` does not respond, the archive clean-up by `expiration` is not performed;
	// only the archive with expired episodes (`episodes_expiration`) is cleaned up until the `episodes_url` restores.
	// Format: seconds (seconds)
	// Examples: 604800
	SetExpiration(Seconds) DvrBaseConfig
	// Maximum disk consumption in bytes. When this limit is reached,
	// the oldest segment of the recording will be overridden by later data.
	// This option affects both continuous recording and locked episodes (see `episodes_url`).
	// If `episodes_url` does not respond, the archive clean-up by `storage_limit` is not performed
	// to avoid deleting the recordings that should not be deleted.
	// Format: bytes (bytes)
	// Example: 4e+11
	StorageLimit() *Bytes
	// Maximum disk consumption in bytes. When this limit is reached,
	// the oldest segment of the recording will be overridden by later data.
	// This option affects both continuous recording and locked episodes (see `episodes_url`).
	// If `episodes_url` does not respond, the archive clean-up by `storage_limit` is not performed
	// to avoid deleting the recordings that should not be deleted.
	// Format: bytes (bytes)
	// Example: 4e+11
	SetStorageLimit(Bytes) DvrBaseConfig
}

// Required: from, depth, ranges
type DvrInfo interface {
	// The size of the recorded archive.
	// Format: bytes (bytes)
	// Example: 1.296e+11
	Bytes() *Bytes
	// The size of the recorded archive.
	// Format: bytes (bytes)
	// Example: 1.296e+11
	SetBytes(Bytes) DvrInfo
	// The time interval between the start of the *first* recording segment and the end of the *last* one.
	// Format: seconds (seconds)
	// Example: 259200
	Depth() Seconds
	// The time interval between the start of the *first* recording segment and the end of the *last* one.
	// Format: seconds (seconds)
	// Example: 259200
	SetDepth(Seconds) DvrInfo
	// Deprecated field. Will be deleted at 25.07
	// The size of the recorded archive. Please, use bytes instead.
	// Format: bytes (bytes)
	// Example: 1.099511627776e+12
	DiskSize() *Bytes
	// Deprecated field. Will be deleted at 25.07
	// The size of the recorded archive. Please, use bytes instead.
	// Format: bytes (bytes)
	// Example: 1.099511627776e+12
	SetDiskSize(Bytes) DvrInfo
	// A total duration of the recorded segments, excluding recording gaps.
	// It can be smaller than depth if you have gaps.
	// Format: seconds (seconds)
	// Example: 172800
	Duration() *Seconds
	// A total duration of the recorded segments, excluding recording gaps.
	// It can be smaller than depth if you have gaps.
	// Format: seconds (seconds)
	// Example: 172800
	SetDuration(Seconds) DvrInfo
	// The UTC timestamp of the first recording in this archive.
	// Format: utc (Unix timestamp in seconds)
	// Example: 1.641045644e+09
	From() Utc
	// The UTC timestamp of the first recording in this archive.
	// Format: utc (Unix timestamp in seconds)
	// Example: 1.641045644e+09
	SetFrom(Utc) DvrInfo
	// Deprecated field. Will be deleted at 24.09
	// The list of DVR ranges. The param is replaced with `ranges_list` method.
	Ranges() []DvrRange
	// Deprecated field. Will be deleted at 24.09
	// The list of DVR ranges. The param is replaced with `ranges_list` method.
	SetRanges([]DvrRange) DvrInfo
}

type DvrRange interface {
	// The the of the last recorded data.
	// Please notice that closed_at could be changed. There are two reasons.
	// - Cleaner process reduced data. Read [more](https://flussonic.com/doc/api/reference/#tag/stream/operation/stream_get/response%7Cdvr%7Cepisodes_url).
	// - Recording is still working. Near real-time value means that DVR is active at the moment.
	// This is a replacement for `duration` field
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	ClosedAt() *UtcMs
	// The the of the last recorded data.
	// Please notice that closed_at could be changed. There are two reasons.
	// - Cleaner process reduced data. Read [more](https://flussonic.com/doc/api/reference/#tag/stream/operation/stream_get/response%7Cdvr%7Cepisodes_url).
	// - Recording is still working. Near real-time value means that DVR is active at the moment.
	// This is a replacement for `duration` field
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetClosedAt(UtcMs) DvrRange
	// Deprecated field. Will be deleted at 24.11
	// The duration of the recorded DVR range.
	// Use closed_at instead of this field.
	// Format: seconds (seconds)
	// Example: 28800
	Duration() *Seconds
	// Deprecated field. Will be deleted at 24.11
	// The duration of the recorded DVR range.
	// Use closed_at instead of this field.
	// Format: seconds (seconds)
	// Example: 28800
	SetDuration(Seconds) DvrRange
	// Deprecated field. Will be deleted at 24.11
	// The beginning of the recorded DVR range. Use opened_at instead.
	// Mention that opened_at has milliseconds
	// Format: utc (Unix timestamp in seconds)
	// Example: 1.525186456e+09
	From() *Utc
	// Deprecated field. Will be deleted at 24.11
	// The beginning of the recorded DVR range. Use opened_at instead.
	// Mention that opened_at has milliseconds
	// Format: utc (Unix timestamp in seconds)
	// Example: 1.525186456e+09
	SetFrom(Utc) DvrRange
	// The time when this range was started. Naming is standard for whole flussonic ecosystem.
	// Is a replacement for field `from`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	OpenedAt() *UtcMs
	// The time when this range was started. Naming is standard for whole flussonic ecosystem.
	// Is a replacement for field `from`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetOpenedAt(UtcMs) DvrRange
}

type EpisodeAppearanceTimestamps interface {
	// The time when this episode was fetched by Central.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637098611e+12
	CentralTimestamp() *UtcMs
	// The time when this episode was fetched by Central.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637098611e+12
	SetCentralTimestamp(UtcMs) EpisodeAppearanceTimestamps
	// The time when this episode was created in inference service.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	InferenceTimestamp() *UtcMs
	// The time when this episode was created in inference service.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	SetInferenceTimestamp(UtcMs) EpisodeAppearanceTimestamps
	// The time when this episode was fetched by Watcher.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	WatcherTimestamp() *UtcMs
	// The time when this episode was fetched by Watcher.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	SetWatcherTimestamp(UtcMs) EpisodeAppearanceTimestamps
}

// # Definition
// Episode is a record about continious part of one video stream.
// It is used in video analytics, television systems, etc. for describing one continious and logically
// consolidated part of video stream.
// For example, episode can describe one TV show or a part of video when the car with specific license plate
// passed the camera view.
// Different systems in our ecosystem can emit and consume episodes of different `episode_type`.
// # Alternatives
// What episodes are not:
// * they cannot combine multiple streams. If you have multicamera view on the scene, you will have to create many episodes and join then in another system
// * they cannot be multipart. Only one continious uninterrupted episode. However, it is ok for them to overlap.
// # Updates
// Episodes are supposed to be streamable and updatable.
// If you consume episodes, you must be ready to see old `episode_id`
// with new updated data. You MUST overwrite previous data.
// If you emit episodes and you change any fields, you MUST accumulate previous data of episode and send full copy of
// updated episode.
// # Borders
// Episode have two mandatory fields: `opened_at` and `updated_at`, they are default borders of the episode:
// beginning and the end.
// Sometimes you need to look at another fields: `started_at` and `closed_at`.
// `started_at` appears when episode emitter decides that beginning of the episode should be different from `opened_at`,
// for example if video analytics has analysed previous frames and decided that this object appeared earlier.
// `closed_at` can appear if episode source have decided that episode will not continue anymore, for example
// car have run out of camera view. However, `updated_at` can be still changed, if any other system will add
// more data there, for example detected licence plates of some other auxiliary information.
// Required: episode_id, media, opened_at, updated_at
type EpisodeBase interface {
	// The reason for closing the episode.
	CloseReason() *EpisodeCloseReason
	// The reason for closing the episode.
	SetCloseReason(EpisodeCloseReason) EpisodeBase
	// Episode emitter can decide that episode considered closed and will not grow further.
	// `closed_at` MUST NOT change, it must be emitted only once.
	// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
	// of the episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	ClosedAt() *UtcMs
	// Episode emitter can decide that episode considered closed and will not grow further.
	// `closed_at` MUST NOT change, it must be emitted only once.
	// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
	// of the episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetClosedAt(UtcMs) EpisodeBase
	// The time when the episode appeared in the service relative to the server time.
	EpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps
	// The time when the episode appeared in the service relative to the server time.
	SetEpisodeAppearanceTimestamps(EpisodeAppearanceTimestamps) EpisodeBase
	// Unique identifier of the episode. Must be created by the system that first creates this episode.
	// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
	// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
	// handle very long integers.
	// Format: snowflake_id (snowflake_id)
	// Examples: 1.722279170848854e+18
	EpisodeID() SnowflakeID
	// Unique identifier of the episode. Must be created by the system that first creates this episode.
	// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
	// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
	// handle very long integers.
	// Format: snowflake_id (snowflake_id)
	// Examples: 1.722279170848854e+18
	SetEpisodeID(SnowflakeID) EpisodeBase
	// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
	// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
	// Format: base64 (base64)
	FramePreview() *Base64
	// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
	// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
	// Format: base64 (base64)
	SetFramePreview(Base64) EpisodeBase
	// Stream name on which this episode exists.
	// Format: media_name (media_name)
	Media() MediaName
	// Stream name on which this episode exists.
	// Format: media_name (media_name)
	SetMedia(MediaName) EpisodeBase
	// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
	// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
	// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
	// sort as by `opened_at`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	OpenedAt() UtcMs
	// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
	// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
	// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
	// sort as by `opened_at`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetOpenedAt(UtcMs) EpisodeBase
	// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Format: base64 (base64)
	Preview() *Base64
	// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Format: base64 (base64)
	SetPreview(Base64) EpisodeBase
	// The time when the preview of this episode is available.
	// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
	// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
	// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
	// for details.
	// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	PreviewTimestamp() *UtcMs
	// The time when the preview of this episode is available.
	// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
	// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
	// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
	// for details.
	// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetPreviewTimestamp(UtcMs) EpisodeBase
	// This field can be used as indication of the fact that some system have checked and ensured that
	// this episode has really started at some time, that may differ from `opened_at`.
	// For example video analytics will use this field for the time when this episode was confirmed as confident.
	// May be not relevant for television systems.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	StartedAt() *UtcMs
	// This field can be used as indication of the fact that some system have checked and ensured that
	// this episode has really started at some time, that may differ from `opened_at`.
	// For example video analytics will use this field for the time when this episode was confirmed as confident.
	// May be not relevant for television systems.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetStartedAt(UtcMs) EpisodeBase
	// The time of last change of the episode.
	// System that processes episodes and can send them to other systems, MUST update this field
	// on any changes in this episode.
	// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
	// this `updated_at` can be used as a sort key for fetching fresh updates.
	// Consumer of the episodes can use `updated_at` in the following scenario:
	// * fetch all exisiting episodes from the source
	// * take biggest `updated_at` from this dataset, it will be T
	// * ask source for all episodes with `updated_at > T`
	// This algorithm can be used for fetching update stream from the source.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637098611e+12
	UpdatedAt() UtcMs
	// The time of last change of the episode.
	// System that processes episodes and can send them to other systems, MUST update this field
	// on any changes in this episode.
	// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
	// this `updated_at` can be used as a sort key for fetching fresh updates.
	// Consumer of the episodes can use `updated_at` in the following scenario:
	// * fetch all exisiting episodes from the source
	// * take biggest `updated_at` from this dataset, it will be T
	// * ask source for all episodes with `updated_at > T`
	// This algorithm can be used for fetching update stream from the source.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637098611e+12
	SetUpdatedAt(UtcMs) EpisodeBase
}

type EpisodeCustom interface {
	// The reason for closing the episode.
	CloseReason() *EpisodeCloseReason
	// The reason for closing the episode.
	SetCloseReason(EpisodeCloseReason) EpisodeCustom
	// Episode emitter can decide that episode considered closed and will not grow further.
	// `closed_at` MUST NOT change, it must be emitted only once.
	// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
	// of the episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	ClosedAt() *UtcMs
	// Episode emitter can decide that episode considered closed and will not grow further.
	// `closed_at` MUST NOT change, it must be emitted only once.
	// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
	// of the episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetClosedAt(UtcMs) EpisodeCustom
	// The time when the episode appeared in the service relative to the server time.
	EpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps
	// The time when the episode appeared in the service relative to the server time.
	SetEpisodeAppearanceTimestamps(EpisodeAppearanceTimestamps) EpisodeCustom
	// Unique identifier of the episode. Must be created by the system that first creates this episode.
	// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
	// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
	// handle very long integers.
	// Format: snowflake_id (snowflake_id)
	// Examples: 1.722279170848854e+18
	EpisodeID() SnowflakeID
	// Unique identifier of the episode. Must be created by the system that first creates this episode.
	// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
	// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
	// handle very long integers.
	// Format: snowflake_id (snowflake_id)
	// Examples: 1.722279170848854e+18
	SetEpisodeID(SnowflakeID) EpisodeCustom
	// Custom episode type.
	// Use this field to define your own episode types when integrating custom analytics.
	// If episode type is not specified, episode will be saved with `generic` type.
	EpisodeType() *string
	// Custom episode type.
	// Use this field to define your own episode types when integrating custom analytics.
	// If episode type is not specified, episode will be saved with `generic` type.
	SetEpisodeType(string) EpisodeCustom
	// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
	// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
	// Format: base64 (base64)
	FramePreview() *Base64
	// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
	// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
	// Format: base64 (base64)
	SetFramePreview(Base64) EpisodeCustom
	// Stream name on which this episode exists.
	// Format: media_name (media_name)
	Media() MediaName
	// Stream name on which this episode exists.
	// Format: media_name (media_name)
	SetMedia(MediaName) EpisodeCustom
	// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
	// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
	// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
	// sort as by `opened_at`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	OpenedAt() UtcMs
	// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
	// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
	// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
	// sort as by `opened_at`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetOpenedAt(UtcMs) EpisodeCustom
	// Custom episode payload. Use this field to provide additional information about the episode.
	Payload() any
	// Custom episode payload. Use this field to provide additional information about the episode.
	SetPayload(any) EpisodeCustom
	// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Format: base64 (base64)
	Preview() *Base64
	// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Format: base64 (base64)
	SetPreview(Base64) EpisodeCustom
	// The time when the preview of this episode is available.
	// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
	// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
	// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
	// for details.
	// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	PreviewTimestamp() *UtcMs
	// The time when the preview of this episode is available.
	// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
	// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
	// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
	// for details.
	// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetPreviewTimestamp(UtcMs) EpisodeCustom
	// This field can be used as indication of the fact that some system have checked and ensured that
	// this episode has really started at some time, that may differ from `opened_at`.
	// For example video analytics will use this field for the time when this episode was confirmed as confident.
	// May be not relevant for television systems.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	StartedAt() *UtcMs
	// This field can be used as indication of the fact that some system have checked and ensured that
	// this episode has really started at some time, that may differ from `opened_at`.
	// For example video analytics will use this field for the time when this episode was confirmed as confident.
	// May be not relevant for television systems.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetStartedAt(UtcMs) EpisodeCustom
	// The time of last change of the episode.
	// System that processes episodes and can send them to other systems, MUST update this field
	// on any changes in this episode.
	// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
	// this `updated_at` can be used as a sort key for fetching fresh updates.
	// Consumer of the episodes can use `updated_at` in the following scenario:
	// * fetch all exisiting episodes from the source
	// * take biggest `updated_at` from this dataset, it will be T
	// * ask source for all episodes with `updated_at > T`
	// This algorithm can be used for fetching update stream from the source.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637098611e+12
	UpdatedAt() UtcMs
	// The time of last change of the episode.
	// System that processes episodes and can send them to other systems, MUST update this field
	// on any changes in this episode.
	// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
	// this `updated_at` can be used as a sort key for fetching fresh updates.
	// Consumer of the episodes can use `updated_at` in the following scenario:
	// * fetch all exisiting episodes from the source
	// * take biggest `updated_at` from this dataset, it will be T
	// * ask source for all episodes with `updated_at > T`
	// This algorithm can be used for fetching update stream from the source.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637098611e+12
	SetUpdatedAt(UtcMs) EpisodeCustom
}

type EpisodeExtra interface {
	// Optional description of the episode. Can be used to provide additional context or details about the episode.
	// Example: Person detected at the main entrance, stayed for 30 seconds
	Description() *string
	// Optional description of the episode. Can be used to provide additional context or details about the episode.
	// Example: Person detected at the main entrance, stayed for 30 seconds
	SetDescription(string) EpisodeExtra
	// Duration of the episode in milliseconds.
	// Format: milliseconds (milliseconds)
	// Example: 10500
	Duration() *Milliseconds
	// Duration of the episode in milliseconds.
	// Format: milliseconds (milliseconds)
	// Example: 10500
	SetDuration(Milliseconds) EpisodeExtra
	// Whether the episode is added to favorites.
	// Example: false
	IsFavorite() *bool
	// Whether the episode is added to favorites.
	// Example: false
	SetIsFavorite(bool) EpisodeExtra
	// Optional title of the episode. Can be used to provide a human-readable name for the episode.
	// Example: Visitor at main entrance
	Title() *string
	// Optional title of the episode. Can be used to provide a human-readable name for the episode.
	// Example: Visitor at main entrance
	SetTitle(string) EpisodeExtra
}

type EpisodeGeneric interface {
	// The reason for closing the episode.
	CloseReason() *EpisodeCloseReason
	// The reason for closing the episode.
	SetCloseReason(EpisodeCloseReason) EpisodeGeneric
	// Episode emitter can decide that episode considered closed and will not grow further.
	// `closed_at` MUST NOT change, it must be emitted only once.
	// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
	// of the episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	ClosedAt() *UtcMs
	// Episode emitter can decide that episode considered closed and will not grow further.
	// `closed_at` MUST NOT change, it must be emitted only once.
	// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
	// of the episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetClosedAt(UtcMs) EpisodeGeneric
	// The time when the episode appeared in the service relative to the server time.
	EpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps
	// The time when the episode appeared in the service relative to the server time.
	SetEpisodeAppearanceTimestamps(EpisodeAppearanceTimestamps) EpisodeGeneric
	// Unique identifier of the episode. Must be created by the system that first creates this episode.
	// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
	// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
	// handle very long integers.
	// Format: snowflake_id (snowflake_id)
	// Examples: 1.722279170848854e+18
	EpisodeID() SnowflakeID
	// Unique identifier of the episode. Must be created by the system that first creates this episode.
	// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
	// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
	// handle very long integers.
	// Format: snowflake_id (snowflake_id)
	// Examples: 1.722279170848854e+18
	SetEpisodeID(SnowflakeID) EpisodeGeneric
	// Generic stream episode
	EpisodeType() *string
	// Generic stream episode
	SetEpisodeType(string) EpisodeGeneric
	// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
	// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
	// Format: base64 (base64)
	FramePreview() *Base64
	// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
	// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
	// Format: base64 (base64)
	SetFramePreview(Base64) EpisodeGeneric
	// Stream name on which this episode exists.
	// Format: media_name (media_name)
	Media() MediaName
	// Stream name on which this episode exists.
	// Format: media_name (media_name)
	SetMedia(MediaName) EpisodeGeneric
	// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
	// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
	// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
	// sort as by `opened_at`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	OpenedAt() UtcMs
	// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
	// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
	// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
	// sort as by `opened_at`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetOpenedAt(UtcMs) EpisodeGeneric
	// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Format: base64 (base64)
	Preview() *Base64
	// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Format: base64 (base64)
	SetPreview(Base64) EpisodeGeneric
	// The time when the preview of this episode is available.
	// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
	// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
	// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
	// for details.
	// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	PreviewTimestamp() *UtcMs
	// The time when the preview of this episode is available.
	// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
	// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
	// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
	// for details.
	// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetPreviewTimestamp(UtcMs) EpisodeGeneric
	// This field can be used as indication of the fact that some system have checked and ensured that
	// this episode has really started at some time, that may differ from `opened_at`.
	// For example video analytics will use this field for the time when this episode was confirmed as confident.
	// May be not relevant for television systems.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	StartedAt() *UtcMs
	// This field can be used as indication of the fact that some system have checked and ensured that
	// this episode has really started at some time, that may differ from `opened_at`.
	// For example video analytics will use this field for the time when this episode was confirmed as confident.
	// May be not relevant for television systems.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetStartedAt(UtcMs) EpisodeGeneric
	// The time of last change of the episode.
	// System that processes episodes and can send them to other systems, MUST update this field
	// on any changes in this episode.
	// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
	// this `updated_at` can be used as a sort key for fetching fresh updates.
	// Consumer of the episodes can use `updated_at` in the following scenario:
	// * fetch all exisiting episodes from the source
	// * take biggest `updated_at` from this dataset, it will be T
	// * ask source for all episodes with `updated_at > T`
	// This algorithm can be used for fetching update stream from the source.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637098611e+12
	UpdatedAt() UtcMs
	// The time of last change of the episode.
	// System that processes episodes and can send them to other systems, MUST update this field
	// on any changes in this episode.
	// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
	// this `updated_at` can be used as a sort key for fetching fresh updates.
	// Consumer of the episodes can use `updated_at` in the following scenario:
	// * fetch all exisiting episodes from the source
	// * take biggest `updated_at` from this dataset, it will be T
	// * ask source for all episodes with `updated_at > T`
	// This algorithm can be used for fetching update stream from the source.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637098611e+12
	SetUpdatedAt(UtcMs) EpisodeGeneric
}

type EpisodePlay interface {
	// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
	// Example: onetime_token
	PlaybackToken() *string
	// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
	// Example: onetime_token
	SetPlaybackToken(string) EpisodePlay
	// HTTP(s) URL that can be used for streaming API of this episode
	// Example: https://streamer.example.com
	StreamingEndpoint() *string
	// HTTP(s) URL that can be used for streaming API of this episode
	// Example: https://streamer.example.com
	SetStreamingEndpoint(string) EpisodePlay
}

type EpisodeStreamDetails interface {
	// Details about stream related to the episode.
	Stream() EpisodeStreamDetailsStream
	// Details about stream related to the episode.
	SetStream(EpisodeStreamDetailsStream) EpisodeStreamDetails
}

// Details about stream related to the episode.
// Required: name
type EpisodeStreamDetailsStream interface {
	// Human-readable description of the stream.
	// Example: This is a test stream
	Comment() *string
	// Human-readable description of the stream.
	// Example: This is a test stream
	SetComment(string) EpisodeStreamDetailsStream
	// Globally unique stream name.
	// Note that the name could not be changed after the stream is created.
	// Format: media_name (media_name)
	// Examples: Decklink-Stream, Dektec-Stream, hockey1, mylive/bunny, test_stream
	Name() MediaName
	// Globally unique stream name.
	// Note that the name could not be changed after the stream is created.
	// Format: media_name (media_name)
	// Examples: Decklink-Stream, Dektec-Stream, hockey1, mylive/bunny, test_stream
	SetName(MediaName) EpisodeStreamDetailsStream
	// ID of the organization the stream belongs to.
	// Example: 9
	OrganizationID() *int
	// ID of the organization the stream belongs to.
	// Example: 9
	SetOrganizationID(int) EpisodeStreamDetailsStream
	// Configuration of thumbnail of the stream.
	Thumbnails() ThumbnailsSpec
	// Configuration of thumbnail of the stream.
	SetThumbnails(ThumbnailsSpec) EpisodeStreamDetailsStream
	// Human-readable title of the stream. Provided for SDT MPEG-TS table or
	// SDP RTSP title parameter.
	// Example: Hockey channel
	Title() *string
	// Human-readable title of the stream. Provided for SDT MPEG-TS table or
	// SDP RTSP title parameter.
	// Example: Hockey channel
	SetTitle(string) EpisodeStreamDetailsStream
}

type EpisodesList interface {
	// The list of Episodes fetched according to the query parameters.
	Episodes() []WatcherEpisode
	// The list of Episodes fetched according to the query parameters.
	SetEpisodes([]WatcherEpisode) EpisodesList
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	EstimatedCount() *int
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	SetEstimatedCount(int) EpisodesList
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	Next() *string
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	SetNext(string) EpisodesList
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	Prev() *string
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	SetPrev(string) EpisodesList
	// An object with a list of different timings measured during this API call.
	Timing() any
	// An object with a list of different timings measured during this API call.
	SetTiming(any) EpisodesList
	// Collection returns the collection items
	Collection() []WatcherEpisode
}

type Error interface {
	// an application-specific error code, expressed as a string value
	Code() *string
	// an application-specific error code, expressed as a string value
	SetCode(string) Error
	// a unique identifier for this particular occurrence of the problem
	ID() *string
	// a unique identifier for this particular occurrence of the problem
	SetID(string) Error
	// a meta object containing non-standard meta-information about the error.
	Meta() map[string]string
	// a meta object containing non-standard meta-information about the error.
	SetMeta(map[string]string) Error
	// an object containing references to the source of the error
	Source() ErrorSource
	// an object containing references to the source of the error
	SetSource(ErrorSource) Error
	// the HTTP status code applicable to this problem, expressed as a string value
	Status() *string
	// the HTTP status code applicable to this problem, expressed as a string value
	SetStatus(string) Error
	// a short, human-readable summary of the problem that SHOULD NOT change from
	// occurrence to occurrence of the problem, except for purposes of localization
	Title() *string
	// a short, human-readable summary of the problem that SHOULD NOT change from
	// occurrence to occurrence of the problem, except for purposes of localization
	SetTitle(string) Error
}

type ErrorResponse interface {
	// List of structured errors
	Errors() []Error
	// List of structured errors
	SetErrors([]Error) ErrorResponse
}

// an object containing references to the source of the error
type ErrorSource interface {
	// a string indicating which URI query parameter caused the error.
	Parameter() *string
	// a string indicating which URI query parameter caused the error.
	SetParameter(string) ErrorSource
	// a JSON Pointer [RFC6901] to the associated entity in the request document
	// [e.g. `"/data"` for a primary data object, or `"/data/attributes/title"` for a specific attribute].
	Pointer() *string
	// a JSON Pointer [RFC6901] to the associated entity in the request document
	// [e.g. `"/data"` for a primary data object, or `"/data/attributes/title"` for a specific attribute].
	SetPointer(string) ErrorSource
}

// Update camera firmware
// Required: image
type FirmwareUpdate interface {
	// Image for updating camera. Documentation for updating cameras: https://flussonic.com/doc/flussonic-home-v1/#upgrade.
	// Format: binary (binary)
	// Example: b'DL'
	Image() any
	// Image for updating camera. Documentation for updating cameras: https://flussonic.com/doc/flussonic-home-v1/#upgrade.
	// Format: binary (binary)
	// Example: b'DL'
	SetImage(any) FirmwareUpdate
	// Protocol for connecting to camera.
	// Example: iris
	Proto() *FirmwareUpdateProto
	// Protocol for connecting to camera.
	// Example: iris
	SetProto(FirmwareUpdateProto) FirmwareUpdate
}

// Floor file object
type FloorFile interface {
	// Image data in base64 format
	B64Content() *string
	// Image data in base64 format
	SetB64Content(string) FloorFile
	// Image data in binary format
	BinaryContent() *string
	// Image data in binary format
	SetBinaryContent(string) FloorFile
	// Mime type of the image
	MimeType() *string
	// Mime type of the image
	SetMimeType(string) FloorFile
	// File name
	// Example: 1-maps-2_07957af5f132243350a0f5546a675cb006354b69
	Name() *string
	// File name
	// Example: 1-maps-2_07957af5f132243350a0f5546a675cb006354b69
	SetName(string) FloorFile
	// Deprecated field. Will be deleted at 25.09
	// Image URL
	URL() *string
	// Deprecated field. Will be deleted at 25.09
	// Image URL
	SetURL(string) FloorFile
}

// Required: id
type Folder interface {
	// The folder may have a floor plan attached to it to be shown on the map.
	// This parameter sets the image center coordinates: latitude and longitude.
	Coordinates() MapSpec
	// The folder may have a floor plan attached to it to be shown on the map.
	// This parameter sets the image center coordinates: latitude and longitude.
	SetCoordinates(MapSpec) Folder
	// Object of map parameters
	FloorPlan() FolderFloorPlan
	// Object of map parameters
	SetFloorPlan(FolderFloorPlan) Folder
	// Hierarchy object.
	Hierarchy() FolderHierarchy
	// Hierarchy object.
	SetHierarchy(FolderHierarchy) Folder
	// The folder ID.
	ID() int
	// The folder ID.
	SetID(int) Folder
	// The identifier of the Organization to which the folder belongs.
	OrganizationID() *int
	// The identifier of the Organization to which the folder belongs.
	SetOrganizationID(int) Folder
	// The identifier of the parent folder.
	ParentID() *int
	// The identifier of the parent folder.
	SetParentID(int) Folder
	// The number of streams in the folder.
	// Example: 2
	StreamsCount() *int
	// The number of streams in the folder.
	// Example: 2
	SetStreamsCount(int) Folder
	// The folder name.
	Title() *string
	// The folder name.
	SetTitle(string) Folder
}

// Object of map parameters
type FolderFloorPlan interface {
	// The coordinates of the bottom left corner of the floor plan image.
	Bottomleft() MapSpec
	// The coordinates of the bottom left corner of the floor plan image.
	SetBottomleft(MapSpec) FolderFloorPlan
	File() FloorFile
	SetFile(FloorFile) FolderFloorPlan
	// The coordinates of the top left corner of the floor plan image.
	Topleft() MapSpec
	// The coordinates of the top left corner of the floor plan image.
	SetTopleft(MapSpec) FolderFloorPlan
	// The coordinates of the top right corner of the floor plan image.
	Topright() MapSpec
	// The coordinates of the top right corner of the floor plan image.
	SetTopright(MapSpec) FolderFloorPlan
}

// Hierarchy object.
type FolderHierarchy interface {
	// The folder level in the hierarchy. The default (main) folder of the Organization is level 0.
	// The child folder of the default folder is level 1, etc.
	Level() *int
	// The folder level in the hierarchy. The default (main) folder of the Organization is level 0.
	// The child folder of the default folder is level 1, etc.
	SetLevel(int) FolderHierarchy
	// The index number of the folder within the parent folder. This number can be used for ordering folders.
	OrderNum() *int
	// The index number of the folder within the parent folder. This number can be used for ordering folders.
	SetOrderNum(int) FolderHierarchy
	// This parameters block allows changing the level of the folder in the hierarchy and order of folders
	Shift() FolderHierarchyShift
	// This parameters block allows changing the level of the folder in the hierarchy and order of folders
	SetShift(FolderHierarchyShift) FolderHierarchy
}

// This parameters block allows changing the level of the folder in the hierarchy and order of folders
type FolderHierarchyShift interface {
	// The Id of destination folder.
	Destination() *int
	// The Id of destination folder.
	SetDestination(int) FolderHierarchyShift
	Direction() *FolderHierarchyShiftDirection
	SetDirection(FolderHierarchyShiftDirection) FolderHierarchyShift
}

type FolderUser interface {
	// The flag showing if the user can manage and execute actions on the streams in the folder.
	CanUseActions() *bool
	// The flag showing if the user can manage and execute actions on the streams in the folder.
	SetCanUseActions(bool) FolderUser
	// The flag if the user can use PTZ controls.
	CanUsePtz() *bool
	// The flag if the user can use PTZ controls.
	SetCanUsePtz(bool) FolderUser
	// The flag showing if the user can view only live on the streams in the folder and the list of streams.
	CanView() *bool
	// The flag showing if the user can view only live on the streams in the folder and the list of streams.
	SetCanView(bool) FolderUser
	// The flag showing if the user can view archive on the streams in the folder.
	CanViewDvr() *bool
	// The flag showing if the user can view archive on the streams in the folder.
	SetCanViewDvr(bool) FolderUser
	// The dvr depth limit allows to:
	// Set the maximum recording depth, which determines how far back recorded materials can be viewed.
	// Manage access to archived data, ensuring security and control over who can access records.
	// if set to 0, the user has unlimited access to the archive.
	// Format: seconds (seconds)
	// Example: 3600
	DvrDepthLimit() *Seconds
	// The dvr depth limit allows to:
	// Set the maximum recording depth, which determines how far back recorded materials can be viewed.
	// Manage access to archived data, ensuring security and control over who can access records.
	// if set to 0, the user has unlimited access to the archive.
	// Format: seconds (seconds)
	// Example: 3600
	SetDvrDepthLimit(Seconds) FolderUser
}

type FolderUsers interface {
	// The flag showing if the user can manage and execute actions on the streams in the folder.
	CanUseActions() *bool
	// The flag showing if the user can manage and execute actions on the streams in the folder.
	SetCanUseActions(bool) FolderUsers
	// The flag if the user can use PTZ controls.
	CanUsePtz() *bool
	// The flag if the user can use PTZ controls.
	SetCanUsePtz(bool) FolderUsers
	// The flag showing if the user can view only live on the streams in the folder and the list of streams.
	CanView() *bool
	// The flag showing if the user can view only live on the streams in the folder and the list of streams.
	SetCanView(bool) FolderUsers
	// The flag showing if the user can view archive on the streams in the folder.
	CanViewDvr() *bool
	// The flag showing if the user can view archive on the streams in the folder.
	SetCanViewDvr(bool) FolderUsers
	// The dvr depth limit allows to:
	// Set the maximum recording depth, which determines how far back recorded materials can be viewed.
	// Manage access to archived data, ensuring security and control over who can access records.
	// if set to 0, the user has unlimited access to the archive.
	// Format: seconds (seconds)
	// Example: 3600
	DvrDepthLimit() *Seconds
	// The dvr depth limit allows to:
	// Set the maximum recording depth, which determines how far back recorded materials can be viewed.
	// Manage access to archived data, ensuring security and control over who can access records.
	// if set to 0, the user has unlimited access to the archive.
	// Format: seconds (seconds)
	// Example: 3600
	SetDvrDepthLimit(Seconds) FolderUsers
	// User identifier
	UserID() *int
	// User identifier
	SetUserID(int) FolderUsers
}

type FolderUsersList interface {
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	EstimatedCount() *int
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	SetEstimatedCount(int) FolderUsersList
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	Next() *string
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	SetNext(string) FolderUsersList
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	Prev() *string
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	SetPrev(string) FolderUsersList
	// An object with a list of different timings measured during this API call.
	Timing() any
	// An object with a list of different timings measured during this API call.
	SetTiming(any) FolderUsersList
	// List of fetched users in a folder according to the query parameters.
	Users() []FolderUsers
	// List of fetched users in a folder according to the query parameters.
	SetUsers([]FolderUsers) FolderUsersList
	// Collection returns the collection items
	Collection() []FolderUsers
}

type FoldersList interface {
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	EstimatedCount() *int
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	SetEstimatedCount(int) FoldersList
	// List of folders.
	Folders() []Folder
	// List of folders.
	SetFolders([]Folder) FoldersList
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	Next() *string
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	SetNext(string) FoldersList
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	Prev() *string
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	SetPrev(string) FoldersList
	// An object with a list of different timings measured during this API call.
	Timing() any
	// An object with a list of different timings measured during this API call.
	SetTiming(any) FoldersList
	// Collection returns the collection items
	Collection() []Folder
}

// Here are counters for h264/h265 decoder.
type H26xDecoderCounters interface {
	// Number of NAL units, which `forbidden_zero_bit` is set to one.
	DiscardedBrokenNalCount() *int
	// Number of NAL units, which `forbidden_zero_bit` is set to one.
	SetDiscardedBrokenNalCount(int) H26xDecoderCounters
	// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
	// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
	// This counter shows number of discarded `Fragmentation Units`
	DiscardedFuCount() *int
	// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
	// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
	// This counter shows number of discarded `Fragmentation Units`
	SetDiscardedFuCount(int) H26xDecoderCounters
	// Number of discarded NAL units.
	DiscardedNalCount() *int
	// Number of discarded NAL units.
	SetDiscardedNalCount(int) H26xDecoderCounters
	// Number of NAL units, which type is not allowed in `non-interleaved packetization mode`.
	DiscardedNotAllowedNalCount() *int
	// Number of NAL units, which type is not allowed in `non-interleaved packetization mode`.
	SetDiscardedNotAllowedNalCount(int) H26xDecoderCounters
	// Number of discarded `SEI` NAL units
	DiscardedSeiCount() *int
	// Number of discarded `SEI` NAL units
	SetDiscardedSeiCount(int) H26xDecoderCounters
	// There is workaround to not interrupt `FU` sequence if `end-FU` followed by `middle-FU`.
	// This counter shows how many time the workaround was applied.
	FuEndThenMiddleWorkaroundCount() *int
	// There is workaround to not interrupt `FU` sequence if `end-FU` followed by `middle-FU`.
	// This counter shows how many time the workaround was applied.
	SetFuEndThenMiddleWorkaroundCount(int) H26xDecoderCounters
	// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
	// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
	// This counter shows number of `Fragmentation Units` which `Start bit` and `End bit` are set to one in the same `FU` header
	FuHasBothStartEndBitsCount() *int
	// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
	// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
	// This counter shows number of `Fragmentation Units` which `Start bit` and `End bit` are set to one in the same `FU` header
	SetFuHasBothStartEndBitsCount(int) H26xDecoderCounters
	// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
	// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
	// `Fragmentation Units` pattern must have a `Start FU`, `End FU` and could have `FUs` between these ones.
	// This counter indicates how many times pattern was broken.
	FuPatternIsBrokenCount() *int
	// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
	// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
	// `Fragmentation Units` pattern must have a `Start FU`, `End FU` and could have `FUs` between these ones.
	// This counter indicates how many times pattern was broken.
	SetFuPatternIsBrokenCount(int) H26xDecoderCounters
	// NAL deframentation could be interrupted by unexpected NAL or broken/incomplete packet.
	// If NAL deframentation is interrupted then incomplete fragment of NAL is not discarded and used in decoding process.
	// This counter indicates how many incomplete NALs were used.
	IncompleteNalCount() *int
	// NAL deframentation could be interrupted by unexpected NAL or broken/incomplete packet.
	// If NAL deframentation is interrupted then incomplete fragment of NAL is not discarded and used in decoding process.
	// This counter indicates how many incomplete NALs were used.
	SetIncompleteNalCount(int) H26xDecoderCounters
	// Number of `SEI` NAL units with bad payload
	InvalidSeiPayloadCount() *int
	// Number of `SEI` NAL units with bad payload
	SetInvalidSeiPayloadCount(int) H26xDecoderCounters
	// Number of `SEI` NAL units with invalid size
	InvalidSeiSizeCount() *int
	// Number of `SEI` NAL units with invalid size
	SetInvalidSeiSizeCount(int) H26xDecoderCounters
	// Number of `SEI` NAL units with invalid type
	InvalidSeiTypeCount() *int
	// Number of `SEI` NAL units with invalid type
	SetInvalidSeiTypeCount(int) H26xDecoderCounters
	// How many NAL `AGGREGATION` units handled by this decoder.
	NalAggregationCount() *int
	// How many NAL `AGGREGATION` units handled by this decoder.
	SetNalAggregationCount(int) H26xDecoderCounters
	// How many NAL `AUD` units handled by this decoder.
	NalAudCount() *int
	// How many NAL `AUD` units handled by this decoder.
	SetNalAudCount(int) H26xDecoderCounters
	// How many NAL units handled by this decoder.
	NalCount() *int
	// How many NAL units handled by this decoder.
	SetNalCount(int) H26xDecoderCounters
	// How many NAL `FILLER` units handled by this decoder.
	NalFillerCount() *int
	// How many NAL `FILLER` units handled by this decoder.
	SetNalFillerCount(int) H26xDecoderCounters
	// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
	// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
	// This counter shows how many `Fragmentation Units` handled by this decoder.
	NalFuCount() *int
	// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
	// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
	// This counter shows how many `Fragmentation Units` handled by this decoder.
	SetNalFuCount(int) H26xDecoderCounters
	// How many NAL `IDR` units handled by this decoder.
	NalIdrCount() *int
	// How many NAL `IDR` units handled by this decoder.
	SetNalIdrCount(int) H26xDecoderCounters
	// How many other NAL units handled by this decoder.
	NalOtherCount() *int
	// How many other NAL units handled by this decoder.
	SetNalOtherCount(int) H26xDecoderCounters
	// How many NAL `PPS` units handled by this decoder.
	NalPpsCount() *int
	// How many NAL `PPS` units handled by this decoder.
	SetNalPpsCount(int) H26xDecoderCounters
	// How many NAL `SEI` units handled by this decoder.
	NalSeiCount() *int
	// How many NAL `SEI` units handled by this decoder.
	SetNalSeiCount(int) H26xDecoderCounters
	// How many NAL `SINGLE` units handled by this decoder.
	NalSingleCount() *int
	// How many NAL `SINGLE` units handled by this decoder.
	SetNalSingleCount(int) H26xDecoderCounters
	// How many NAL `SLICE` units handled by this decoder.
	NalSliceCount() *int
	// How many NAL `SLICE` units handled by this decoder.
	SetNalSliceCount(int) H26xDecoderCounters
	// How many NAL `SPS` units handled by this decoder.
	NalSpsCount() *int
	// How many NAL `SPS` units handled by this decoder.
	SetNalSpsCount(int) H26xDecoderCounters
	// How many NAL `STAP_A` units handled by this decoder.
	NalStapACount() *int
	// How many NAL `STAP_A` units handled by this decoder.
	SetNalStapACount(int) H26xDecoderCounters
	// How many NAL `VPS` units handled by this decoder.
	NalVpsCount() *int
	// How many NAL `VPS` units handled by this decoder.
	SetNalVpsCount(int) H26xDecoderCounters
}

// Agent counters
type InputAgentCounters interface {
	// These errors indicate that the agent does not have enough buffer size to handle outgoing traffic.
	ErrorsBufferOverrun() *int
	// These errors indicate that the agent does not have enough buffer size to handle outgoing traffic.
	SetErrorsBufferOverrun(int) InputAgentCounters
	// The agent was unable to open the requested connection. These errors may indicate problems opening the TCP socket on the agent or the remote host is unreacheable.
	ErrorsConnFailed() *int
	// The agent was unable to open the requested connection. These errors may indicate problems opening the TCP socket on the agent or the remote host is unreacheable.
	SetErrorsConnFailed(int) InputAgentCounters
	// These errors indicate that the agent is receiving invalid requests.
	ErrorsInvalidRequest() *int
	// These errors indicate that the agent is receiving invalid requests.
	SetErrorsInvalidRequest(int) InputAgentCounters
	// These errors indicate that the agent does not have enough memory to establish a connection to the remote host.
	ErrorsOutOfMemory() *int
	// These errors indicate that the agent does not have enough memory to establish a connection to the remote host.
	SetErrorsOutOfMemory(int) InputAgentCounters
	// Unknown errors counter.
	ErrorsUnknown() *int
	// Unknown errors counter.
	SetErrorsUnknown(int) InputAgentCounters
}

// Here are grouped different counters for sessions: generic and errors
type InputCounters interface {
	// How many Ad markers passed to this stream from the inputs.
	AdSplicesIngested() *int
	// How many Ad markers passed to this stream from the inputs.
	SetAdSplicesIngested(int) InputCounters
	// How many Ad markers inserted to this stream by user.
	AdSplicesInserted() *int
	// How many Ad markers inserted to this stream by user.
	SetAdSplicesInserted(int) InputCounters
	Agent() InputAgentCounters
	SetAgent(InputAgentCounters) InputCounters
	// Number of bytes received by this stream from live sources.
	// It will be counted before transcoding and will sum all inputs working together.
	// Format: bytes (bytes)
	Bytes() *Bytes
	// Number of bytes received by this stream from live sources.
	// It will be counted before transcoding and will sum all inputs working together.
	// Format: bytes (bytes)
	SetBytes(Bytes) InputCounters
	// Number of bytes received by this stream when downloading from remote DVR.
	// Format: bytes (bytes)
	BytesDvr() *Bytes
	// Number of bytes received by this stream when downloading from remote DVR.
	// Format: bytes (bytes)
	SetBytesDvr(Bytes) InputCounters
	// Sum of all other specific errors in the last minute
	// Example: 0
	ErrorRate() *int
	// Sum of all other specific errors in the last minute
	// Example: 0
	SetErrorRate(int) InputCounters
	// Sum of all other specific errors. Can be used for triggering alert on any error
	// Example: 0
	Errors() *int
	// Sum of all other specific errors. Can be used for triggering alert on any error
	// Example: 0
	SetErrors(int) InputCounters
	// How many times we've got 403 (eaccess).
	Errors403() *int
	// How many times we've got 403 (eaccess).
	SetErrors403(int) InputCounters
	// How many times we've got 404 (enoent).
	Errors404() *int
	// How many times we've got 404 (enoent).
	SetErrors404(int) InputCounters
	// How many times we've got 500 (backend error).
	Errors500() *int
	// How many times we've got 500 (backend error).
	SetErrors500(int) InputCounters
	// Demultiplexing was done right, but content is broken.
	ErrorsBrokenPayload() *int
	// Demultiplexing was done right, but content is broken.
	SetErrorsBrokenPayload(int) InputCounters
	// How many times input was restarted due to internal crash.
	// This may happen due to unhandled input.
	ErrorsCrashed() *int
	// How many times input was restarted due to internal crash.
	// This may happen due to unhandled input.
	SetErrorsCrashed(int) InputCounters
	// Decoder reset count due to abnormal DTS change. Can happen in MPEG-TS, RTP.
	ErrorsDecoderReset() *int
	// Decoder reset count due to abnormal DTS change. Can happen in MPEG-TS, RTP.
	SetErrorsDecoderReset(int) InputCounters
	// This can be used as a `TS_sync_loss` - how many times MPEG-TS sync was lost.
	// Also this counter refers to RTSP desync, when camera starts dropping TCP data and
	// we have to find packet boundaries.
	// Here we write count of such resynchronizations.
	ErrorsDesync() *int
	// This can be used as a `TS_sync_loss` - how many times MPEG-TS sync was lost.
	// Also this counter refers to RTSP desync, when camera starts dropping TCP data and
	// we have to find packet boundaries.
	// Here we write count of such resynchronizations.
	SetErrorsDesync(int) InputCounters
	// Dropped frames count due timestamp adjustment.
	ErrorsDroppedFrames() *int
	// Dropped frames count due timestamp adjustment.
	SetErrorsDroppedFrames(int) InputCounters
	// RTP, MPEG-TS or other protocols have enough information to tell how many packets were lost
	ErrorsLostPackets() *int
	// RTP, MPEG-TS or other protocols have enough information to tell how many packets were lost
	SetErrorsLostPackets(int) InputCounters
	// how many times PAT was missing during 0,5 seconds or pid 0 misses PAT
	// `PAT_error`
	ErrorsTSPat() *int
	// how many times PAT was missing during 0,5 seconds or pid 0 misses PAT
	// `PAT_error`
	SetErrorsTSPat(int) InputCounters
	// How many times have received PAT that was missing required service (program)
	ErrorsTSServiceLost() *int
	// How many times have received PAT that was missing required service (program)
	SetErrorsTSServiceLost(int) InputCounters
	// Number of connection restarts to fix ts_stuck issue. Can happen in RTSP.
	ErrorsTSStuckRestarts() *int
	// Number of connection restarts to fix ts_stuck issue. Can happen in RTSP.
	SetErrorsTSStuckRestarts(int) InputCounters
	// Number of frames passed to this stream from the inputs.
	Frames() *int
	// Number of frames passed to this stream from the inputs.
	SetFrames(int) InputCounters
	// Aggregated: how many times this stream has switched between different inputs.
	// Individual input: number of times switched to this input.
	InputSwitches() *int
	// Aggregated: how many times this stream has switched between different inputs.
	// Individual input: number of times switched to this input.
	SetInputSwitches(int) InputCounters
	// Number of secondary inputs that have some problems.
	// Example: 0
	InvalidSecondaryInputs() *int
	// Number of secondary inputs that have some problems.
	// Example: 0
	SetInvalidSecondaryInputs(int) InputCounters
	// Indicates, how often does media_info changes
	MediaInfoChanges() *int
	// Indicates, how often does media_info changes
	SetMediaInfoChanges(int) InputCounters
	MotionDetector() InputMotionDetectorCounters
	SetMotionDetector(InputMotionDetectorCounters) InputCounters
	// How many seconds has this stream had no frames.
	// Format: seconds (seconds)
	NumSecNoData() *Seconds
	// How many seconds has this stream had no frames.
	// Format: seconds (seconds)
	SetNumSecNoData(Seconds) InputCounters
	// How many seconds has this stream played from primary input.
	// Format: seconds (seconds)
	NumSecOnPrimaryInput() *Seconds
	// How many seconds has this stream played from primary input.
	// Format: seconds (seconds)
	SetNumSecOnPrimaryInput(Seconds) InputCounters
	// How many seconds has this stream played from secondary inputs.
	// Format: seconds (seconds)
	NumSecOnSecondaryInput() *Seconds
	// How many seconds has this stream played from secondary inputs.
	// Format: seconds (seconds)
	SetNumSecOnSecondaryInput(Seconds) InputCounters
	// Per pid statistics calculated for MPEG-TS input
	Pids() []InputPidCounters
	// Per pid statistics calculated for MPEG-TS input
	SetPids([]InputPidCounters) InputCounters
	// Source may send frames not in the order they should be played. It will be catched and reordered.
	// This counter indicates how many times did it happened.
	ReorderCount() *int
	// Source may send frames not in the order they should be played. It will be catched and reordered.
	// This counter indicates how many times did it happened.
	SetReorderCount(int) InputCounters
	// Source may send frames timestamps faster or slower than realtime.
	// Live stream will catch it and resync. This counter indicates how many times did it happened.
	ResyncCountDrift() *int
	// Source may send frames timestamps faster or slower than realtime.
	// Live stream will catch it and resync. This counter indicates how many times did it happened.
	SetResyncCountDrift(int) InputCounters
	// Source may change timestamps without any signalling. This counter indicates how bad is the source
	ResyncCountJump() *int
	// Source may change timestamps without any signalling. This counter indicates how bad is the source
	SetResyncCountJump(int) InputCounters
	// Stream timestamps are synchronized with real time. This counter tells, how many times
	// it was syncronized after source reconnect.
	ResyncCountNormal() *int
	// Stream timestamps are synchronized with real time. This counter tells, how many times
	// it was syncronized after source reconnect.
	SetResyncCountNormal(int) InputCounters
	// How many times has this stream retried to connect to source
	Retries() *int
	// How many times has this stream retried to connect to source
	SetRetries(int) InputCounters
	// Per channel statistics calculated for RTP input
	RTPChannels() []InputRTPCounters
	// Per channel statistics calculated for RTP input
	SetRTPChannels([]InputRTPCounters) InputCounters
	Sdi() InputSdiCounters
	SetSdi(InputSdiCounters) InputCounters
	Srt() InputSrtCounters
	SetSrt(InputSrtCounters) InputCounters
	// Number of secondary inputs that have no problems.
	// Example: 2
	ValidSecondaryInputs() *int
	// Number of secondary inputs that have no problems.
	// Example: 2
	SetValidSecondaryInputs(int) InputCounters
}

// Specific counters to get insights on current state of getting events from cameras.
// Designed to be used by analyzers, monitoring and alerting tools
type InputMotionDetectorCounters interface {
	// Number of collected episodes.
	EpisodesCount() *int
	// Number of collected episodes.
	SetEpisodesCount(int) InputMotionDetectorCounters
	// Number of responses with broken content.
	ErrorsBrokenPayload() *int
	// Number of responses with broken content.
	SetErrorsBrokenPayload(int) InputMotionDetectorCounters
	// `ONVIF Event Handling Test Specification` says that valid values for `CurrentTime` and `TerminationTime` are
	// `TerminationTime >= CurrentTime + InitialTerminationTime`.
	// How many responses did not met the condition.
	ErrorsIncorrectTimeValuesCount() *int
	// `ONVIF Event Handling Test Specification` says that valid values for `CurrentTime` and `TerminationTime` are
	// `TerminationTime >= CurrentTime + InitialTerminationTime`.
	// How many responses did not met the condition.
	SetErrorsIncorrectTimeValuesCount(int) InputMotionDetectorCounters
	// Number of failed request attempts because of no agent connected.
	ErrorsNoAgentConnected() *int
	// Number of failed request attempts because of no agent connected.
	SetErrorsNoAgentConnected(int) InputMotionDetectorCounters
	// Number of attempts to request disabled or unsupported ONVIF service
	ErrorsNoServiceCount() *int
	// Number of attempts to request disabled or unsupported ONVIF service
	SetErrorsNoServiceCount(int) InputMotionDetectorCounters
	// Number of not authorized requests
	ErrorsNotAuthorizedCount() *int
	// Number of not authorized requests
	SetErrorsNotAuthorizedCount(int) InputMotionDetectorCounters
	// Number of failed requests because of bad url or network issues.
	ErrorsURLUnreachableCount() *int
	// Number of failed requests because of bad url or network issues.
	SetErrorsURLUnreachableCount(int) InputMotionDetectorCounters
	// Number of detected motions.
	MotionDetectedCount() *int
	// Number of detected motions.
	SetMotionDetectedCount(int) InputMotionDetectorCounters
}

// Required: pid
type InputPidCounters interface {
	// How many PES packets were started not from startcode
	BrokenPesCount() *int
	// How many PES packets were started not from startcode
	SetBrokenPesCount(int) InputPidCounters
	// How many bytes were discarded due to lack of PES startcode
	BrokenPesSum() *int
	// How many bytes were discarded due to lack of PES startcode
	SetBrokenPesSum(int) InputPidCounters
	// How many times PTS was less than PCR or previous PTS
	CorrectedBackwardPts() *int
	// How many times PTS was less than PCR or previous PTS
	SetCorrectedBackwardPts(int) InputPidCounters
	// Unhandled crashes inside mpegts decoding process due
	Crashed() *int
	// Unhandled crashes inside mpegts decoding process due
	SetCrashed(int) InputPidCounters
	// How many times was discarded too big ES buffer without making a frame of it
	DiscardedBufferCount() *int
	// How many times was discarded too big ES buffer without making a frame of it
	SetDiscardedBufferCount(int) InputPidCounters
	// How many bytes were lost due to discarding ES buffer
	DiscardedBufferSum() *int
	// How many bytes were lost due to discarding ES buffer
	SetDiscardedBufferSum(int) InputPidCounters
	// Time on this PID jumped back from reference PTS and it was not a roll over zero
	DtsGoesBackwards() *int
	// Time on this PID jumped back from reference PTS and it was not a roll over zero
	SetDtsGoesBackwards(int) InputPidCounters
	// Time on this PID jumped forward too far away from reference PTS
	DtsJumpForward() *int
	// Time on this PID jumped forward too far away from reference PTS
	SetDtsJumpForward(int) InputPidCounters
	// Packets without payload and adaptation field
	EmptyPackets() *int
	// Packets without payload and adaptation field
	SetEmptyPackets(int) InputPidCounters
	// Packets with adaptation field larger than packet size
	ErrorsAdaptationBroken() *int
	// Packets with adaptation field larger than packet size
	SetErrorsAdaptationBroken(int) InputPidCounters
	// How many times pid has been lost
	ErrorsPidLost() *int
	// How many times pid has been lost
	SetErrorsPidLost(int) InputPidCounters
	// how many MPEG-TS packets were received with non-contigious contiuity counters.
	// `Continuity_count_error`
	// Example: 0
	ErrorsTSCc() *int
	// how many MPEG-TS packets were received with non-contigious contiuity counters.
	// `Continuity_count_error`
	// Example: 0
	SetErrorsTSCc(int) InputPidCounters
	// how many times PMT was not received after 0,5 seconds
	// `PMT_error`
	ErrorsTSPmt() *int
	// how many times PMT was not received after 0,5 seconds
	// `PMT_error`
	SetErrorsTSPmt(int) InputPidCounters
	// How many times have received PSI entry with broken checksum
	// `CRC_error`
	ErrorsTSPsiChecksum() *int
	// How many times have received PSI entry with broken checksum
	// `CRC_error`
	SetErrorsTSPsiChecksum(int) InputPidCounters
	// Amount of scrambled TS packets
	ErrorsTSScrambled() *int
	// Amount of scrambled TS packets
	SetErrorsTSScrambled(int) InputPidCounters
	// How many MPEG-TS packets with Transport Error Indicator were received
	// `Transport_error`, 2.1
	ErrorsTSTei() *int
	// How many MPEG-TS packets with Transport Error Indicator were received
	// `Transport_error`, 2.1
	SetErrorsTSTei(int) InputPidCounters
	// How many H264(5) NAL fillers were seen in the input
	FillersCount() *int
	// How many H264(5) NAL fillers were seen in the input
	SetFillersCount(int) InputPidCounters
	// How many bytes were seen in NAL fillers
	FillersSum() *int
	// How many bytes were seen in NAL fillers
	SetFillersSum(int) InputPidCounters
	// Frame count on this pid
	Frames() *int
	// Frame count on this pid
	SetFrames(int) InputPidCounters
	// How many MPEG-TS packets with 188 bytes on this pid received
	Packets() *int
	// How many MPEG-TS packets with 188 bytes on this pid received
	SetPackets(int) InputPidCounters
	// How many PES packets were on the Padding streamId
	PaddingPesCount() *int
	// How many PES packets were on the Padding streamId
	SetPaddingPesCount(int) InputPidCounters
	// How many bytes were in PES packets on the Padding streamId
	PaddingPesSum() *int
	// How many bytes were in PES packets on the Padding streamId
	SetPaddingPesSum(int) InputPidCounters
	// If PTS is drifting away from PCR, it can be resynchronized with PCR. This is a resync count
	PcrResync() *int
	// If PTS is drifting away from PCR, it can be resynchronized with PCR. This is a resync count
	SetPcrResync(int) InputPidCounters
	// Related MPEG-TS pid with following problems
	Pid() int
	// Related MPEG-TS pid with following problems
	SetPid(int) InputPidCounters
	// What program does have this pid
	Pnr() *int
	// What program does have this pid
	SetPnr(int) InputPidCounters
	// In case of CC error last frame can be repeated. This is a count of repeated frames
	RepeatedFrames() *int
	// In case of CC error last frame can be repeated. This is a count of repeated frames
	SetRepeatedFrames(int) InputPidCounters
	// Jumps of timestamps inside a MPEG-TS stream
	TimeCorrections() *int
	// Jumps of timestamps inside a MPEG-TS stream
	SetTimeCorrections(int) InputPidCounters
	// Jump of the PTS was so big from previous, that had to flush all frames and restart parsing
	TooLargeDtsJump() *int
	// Jump of the PTS was so big from previous, that had to flush all frames and restart parsing
	SetTooLargeDtsJump(int) InputPidCounters
}

type InputRTPCounters interface {
	// How many bytes received for this channel
	Bytes() *int
	// How many bytes received for this channel
	SetBytes(int) InputRTPCounters
	// RTP channel number
	// Example: 0
	ChannelID() int
	// RTP channel number
	// Example: 0
	SetChannelID(int) InputRTPCounters
	// Content of the track transmitted in the channel
	// Example: video
	Content() *string
	// Content of the track transmitted in the channel
	// Example: video
	SetContent(string) InputRTPCounters
	// Number of NAL units, which `forbidden_zero_bit` is set to one.
	DiscardedBrokenNalCount() *int
	// Number of NAL units, which `forbidden_zero_bit` is set to one.
	SetDiscardedBrokenNalCount(int) InputRTPCounters
	// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
	// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
	// This counter shows number of discarded `Fragmentation Units`
	DiscardedFuCount() *int
	// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
	// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
	// This counter shows number of discarded `Fragmentation Units`
	SetDiscardedFuCount(int) InputRTPCounters
	// Number of discarded NAL units.
	DiscardedNalCount() *int
	// Number of discarded NAL units.
	SetDiscardedNalCount(int) InputRTPCounters
	// Number of NAL units, which type is not allowed in `non-interleaved packetization mode`.
	DiscardedNotAllowedNalCount() *int
	// Number of NAL units, which type is not allowed in `non-interleaved packetization mode`.
	SetDiscardedNotAllowedNalCount(int) InputRTPCounters
	// Number of discarded `SEI` NAL units
	DiscardedSeiCount() *int
	// Number of discarded `SEI` NAL units
	SetDiscardedSeiCount(int) InputRTPCounters
	// Demultiplexing was done right, but content is broken.
	ErrorsBrokenPayload() *int
	// Demultiplexing was done right, but content is broken.
	SetErrorsBrokenPayload(int) InputRTPCounters
	// Number of frames which dts is same as previous frame dts.
	ErrorsDtsStuck() *int
	// Number of frames which dts is same as previous frame dts.
	SetErrorsDtsStuck(int) InputRTPCounters
	// RTP have enough information to tell how many packets were lost
	ErrorsLostPackets() *int
	// RTP have enough information to tell how many packets were lost
	SetErrorsLostPackets(int) InputRTPCounters
	// How many frames received for this channel
	Frames() *int
	// How many frames received for this channel
	SetFrames(int) InputRTPCounters
	// There is workaround to not interrupt `FU` sequence if `end-FU` followed by `middle-FU`.
	// This counter shows how many time the workaround was applied.
	FuEndThenMiddleWorkaroundCount() *int
	// There is workaround to not interrupt `FU` sequence if `end-FU` followed by `middle-FU`.
	// This counter shows how many time the workaround was applied.
	SetFuEndThenMiddleWorkaroundCount(int) InputRTPCounters
	// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
	// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
	// This counter shows number of `Fragmentation Units` which `Start bit` and `End bit` are set to one in the same `FU` header
	FuHasBothStartEndBitsCount() *int
	// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
	// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
	// This counter shows number of `Fragmentation Units` which `Start bit` and `End bit` are set to one in the same `FU` header
	SetFuHasBothStartEndBitsCount(int) InputRTPCounters
	// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
	// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
	// `Fragmentation Units` pattern must have a `Start FU`, `End FU` and could have `FUs` between these ones.
	// This counter indicates how many times pattern was broken.
	FuPatternIsBrokenCount() *int
	// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
	// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
	// `Fragmentation Units` pattern must have a `Start FU`, `End FU` and could have `FUs` between these ones.
	// This counter indicates how many times pattern was broken.
	SetFuPatternIsBrokenCount(int) InputRTPCounters
	// NAL deframentation could be interrupted by unexpected NAL or broken/incomplete packet.
	// If NAL deframentation is interrupted then incomplete fragment of NAL is not discarded and used in decoding process.
	// This counter indicates how many incomplete NALs were used.
	IncompleteNalCount() *int
	// NAL deframentation could be interrupted by unexpected NAL or broken/incomplete packet.
	// If NAL deframentation is interrupted then incomplete fragment of NAL is not discarded and used in decoding process.
	// This counter indicates how many incomplete NALs were used.
	SetIncompleteNalCount(int) InputRTPCounters
	// Number of `SEI` NAL units with bad payload
	InvalidSeiPayloadCount() *int
	// Number of `SEI` NAL units with bad payload
	SetInvalidSeiPayloadCount(int) InputRTPCounters
	// Number of `SEI` NAL units with invalid size
	InvalidSeiSizeCount() *int
	// Number of `SEI` NAL units with invalid size
	SetInvalidSeiSizeCount(int) InputRTPCounters
	// Number of `SEI` NAL units with invalid type
	InvalidSeiTypeCount() *int
	// Number of `SEI` NAL units with invalid type
	SetInvalidSeiTypeCount(int) InputRTPCounters
	// Number of RTP packets which marker bit is set to one.
	MarkerPacketsCount() *int
	// Number of RTP packets which marker bit is set to one.
	SetMarkerPacketsCount(int) InputRTPCounters
	// How many NACK messages are sent for this channel
	NackCount() *int
	// How many NACK messages are sent for this channel
	SetNackCount(int) InputRTPCounters
	// How many NAL `AGGREGATION` units handled by this decoder.
	NalAggregationCount() *int
	// How many NAL `AGGREGATION` units handled by this decoder.
	SetNalAggregationCount(int) InputRTPCounters
	// How many NAL `AUD` units handled by this decoder.
	NalAudCount() *int
	// How many NAL `AUD` units handled by this decoder.
	SetNalAudCount(int) InputRTPCounters
	// How many NAL units handled by this decoder.
	NalCount() *int
	// How many NAL units handled by this decoder.
	SetNalCount(int) InputRTPCounters
	// How many NAL `FILLER` units handled by this decoder.
	NalFillerCount() *int
	// How many NAL `FILLER` units handled by this decoder.
	SetNalFillerCount(int) InputRTPCounters
	// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
	// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
	// This counter shows how many `Fragmentation Units` handled by this decoder.
	NalFuCount() *int
	// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
	// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
	// This counter shows how many `Fragmentation Units` handled by this decoder.
	SetNalFuCount(int) InputRTPCounters
	// How many NAL `IDR` units handled by this decoder.
	NalIdrCount() *int
	// How many NAL `IDR` units handled by this decoder.
	SetNalIdrCount(int) InputRTPCounters
	// How many other NAL units handled by this decoder.
	NalOtherCount() *int
	// How many other NAL units handled by this decoder.
	SetNalOtherCount(int) InputRTPCounters
	// How many NAL `PPS` units handled by this decoder.
	NalPpsCount() *int
	// How many NAL `PPS` units handled by this decoder.
	SetNalPpsCount(int) InputRTPCounters
	// How many NAL `SEI` units handled by this decoder.
	NalSeiCount() *int
	// How many NAL `SEI` units handled by this decoder.
	SetNalSeiCount(int) InputRTPCounters
	// How many NAL `SINGLE` units handled by this decoder.
	NalSingleCount() *int
	// How many NAL `SINGLE` units handled by this decoder.
	SetNalSingleCount(int) InputRTPCounters
	// How many NAL `SLICE` units handled by this decoder.
	NalSliceCount() *int
	// How many NAL `SLICE` units handled by this decoder.
	SetNalSliceCount(int) InputRTPCounters
	// How many NAL `SPS` units handled by this decoder.
	NalSpsCount() *int
	// How many NAL `SPS` units handled by this decoder.
	SetNalSpsCount(int) InputRTPCounters
	// How many NAL `STAP_A` units handled by this decoder.
	NalStapACount() *int
	// How many NAL `STAP_A` units handled by this decoder.
	SetNalStapACount(int) InputRTPCounters
	// How many NAL `VPS` units handled by this decoder.
	NalVpsCount() *int
	// How many NAL `VPS` units handled by this decoder.
	SetNalVpsCount(int) InputRTPCounters
	// If no marker bit packet is received after 400 RTP packets then decoder switches to `no_marker_mode` and
	// makes frame on each timecode change.
	// This flag shows if decoder works in `no_marker_mode`.
	NoMarkerModeFlag() *bool
	// If no marker bit packet is received after 400 RTP packets then decoder switches to `no_marker_mode` and
	// makes frame on each timecode change.
	// This flag shows if decoder works in `no_marker_mode`.
	SetNoMarkerModeFlag(bool) InputRTPCounters
	// Number of rtp packets rejected due to wrong payload type
	PtRejectCount() *int
	// Number of rtp packets rejected due to wrong payload type
	SetPtRejectCount(int) InputRTPCounters
	// Total size of rejected packets due to wrong payload type (pt_reject_count) rtp packets
	PtRejectSum() *int
	// Total size of rejected packets due to wrong payload type (pt_reject_count) rtp packets
	SetPtRejectSum(int) InputRTPCounters
	// How many RTCP packets received for this channel
	RtcpPackets() *int
	// How many RTCP packets received for this channel
	SetRtcpPackets(int) InputRTPCounters
	// How many RTP packets received for this channel
	RTPPackets() *int
	// How many RTP packets received for this channel
	SetRTPPackets(int) InputRTPCounters
	// Sender wallclock deviation from server time in ms. Positive value means that sender time is ahead of server time.
	SenderClockDeviation() *int
	// Sender wallclock deviation from server time in ms. Positive value means that sender time is ahead of server time.
	SetSenderClockDeviation(int) InputRTPCounters
	// Number of rtcp SR packets which `RTP timestamp` is equal to the previous rtcp SR packet `RTP timestamp`.
	SrTSStuck() *int
	// Number of rtcp SR packets which `RTP timestamp` is equal to the previous rtcp SR packet `RTP timestamp`.
	SetSrTSStuck(int) InputRTPCounters
	// Time on this channel is jumped back from reference wallclock.
	TSGoesBackwards() *int
	// Time on this channel is jumped back from reference wallclock.
	SetTSGoesBackwards(int) InputRTPCounters
	// Time on this channel is jumped forward from reference wallclock.
	TSJumpForward() *int
	// Time on this channel is jumped forward from reference wallclock.
	SetTSJumpForward(int) InputRTPCounters
	// https://datatracker.ietf.org/doc/html/rfc6184#section-4.1
	// access unit: A set of NAL units always containing a primary coded picture.  In addition to the primary coded
	// picture, an access unit may also contain one or more redundant coded pictures or other NAL units not containing
	// slices or slice data partitions of a coded picture.  The decoding of an access unit always results in a
	// decoded picture.
	// There is `marker bit` in RTP packet which is set for the very last packet of the access unit indicated by the RTP timestamp.
	// It is protocol violation if received RTP packet has the same timestamp as previous marker bit packet.
	// This counter is a number of RTP packets which `RTP timestamp` is equal to previous RTP marker bit packet.
	TSStuck() *int
	// https://datatracker.ietf.org/doc/html/rfc6184#section-4.1
	// access unit: A set of NAL units always containing a primary coded picture.  In addition to the primary coded
	// picture, an access unit may also contain one or more redundant coded pictures or other NAL units not containing
	// slices or slice data partitions of a coded picture.  The decoding of an access unit always results in a
	// decoded picture.
	// There is `marker bit` in RTP packet which is set for the very last packet of the access unit indicated by the RTP timestamp.
	// It is protocol violation if received RTP packet has the same timestamp as previous marker bit packet.
	// This counter is a number of RTP packets which `RTP timestamp` is equal to previous RTP marker bit packet.
	SetTSStuck(int) InputRTPCounters
}

// SDI,HDMI and other raw input counters
type InputSdiCounters interface {
	// Gauge of average duration of incoming frame calculated in real time.
	AvgRecvDuration() *int
	// Gauge of average duration of incoming frame calculated in real time.
	SetAvgRecvDuration(int) InputSdiCounters
	// Frames injected to fix client-side SDI stream drift.
	CompensatedFrames() *int
	// Frames injected to fix client-side SDI stream drift.
	SetCompensatedFrames(int) InputSdiCounters
	// Counter of configured audio sdi channels without samples or non valid.
	ErrorLostAudio() *int
	// Counter of configured audio sdi channels without samples or non valid.
	SetErrorLostAudio(int) InputSdiCounters
	// The frame was dropped due to too high CPU load.
	ErrorsCpuStall() *int
	// The frame was dropped due to too high CPU load.
	SetErrorsCpuStall(int) InputSdiCounters
	// Frame data is duplicated from previous frame because the input was too slow.
	ErrorsDuplicate() *int
	// Frame data is duplicated from previous frame because the input was too slow.
	SetErrorsDuplicate(int) InputSdiCounters
	// Frames dropped due to 'No signal'.
	ErrorsNoSignal() *int
	// Frames dropped due to 'No signal'.
	SetErrorsNoSignal(int) InputSdiCounters
	// Frame time is the same as the previous frame.
	ErrorsTSDuplicate() *int
	// Frame time is the same as the previous frame.
	SetErrorsTSDuplicate(int) InputSdiCounters
	// Gauge of maximum deviation from the estimated frame duration.
	PeakDurationDeviation() *int
	// Gauge of maximum deviation from the estimated frame duration.
	SetPeakDurationDeviation(int) InputSdiCounters
}

// SRT specific counters
type InputSrtCounters interface {
	// How many SRT packets were dropped by various reasons
	ErrorDroppedPackets() *int
	// How many SRT packets were dropped by various reasons
	SetErrorDroppedPackets(int) InputSrtCounters
	// How many SRT packets were lost
	ErrorLostPackets() *int
	// How many SRT packets were lost
	SetErrorLostPackets(int) InputSrtCounters
	// Receiver buffering delay
	Latency() *int
	// Receiver buffering delay
	SetLatency(int) InputSrtCounters
	// Total incoming SRT packets counter
	Packets() *int
	// Total incoming SRT packets counter
	SetPackets(int) InputSrtCounters
	// How many packets were retransmitted
	RetransmittedPackets() *int
	// How many packets were retransmitted
	SetRetransmittedPackets(int) InputSrtCounters
	// Round-trip time
	Rtt() *int
	// Round-trip time
	SetRtt(int) InputSrtCounters
}

type InputStats interface {
	// Whether this input is selected as active for the stream.
	// Example: true
	Active() *bool
	// Whether this input is selected as active for the stream.
	// Example: true
	SetActive(bool) InputStats
	// How many Ad markers passed to this stream from the inputs.
	AdSplicesIngested() *int
	// How many Ad markers passed to this stream from the inputs.
	SetAdSplicesIngested(int) InputStats
	// How many Ad markers inserted to this stream by user.
	AdSplicesInserted() *int
	// How many Ad markers inserted to this stream by user.
	SetAdSplicesInserted(int) InputStats
	Agent() InputAgentCounters
	SetAgent(InputAgentCounters) InputStats
	// Number of bytes received by this stream from live sources.
	// It will be counted before transcoding and will sum all inputs working together.
	// Format: bytes (bytes)
	Bytes() *Bytes
	// Number of bytes received by this stream from live sources.
	// It will be counted before transcoding and will sum all inputs working together.
	// Format: bytes (bytes)
	SetBytes(Bytes) InputStats
	// Number of bytes received by this stream when downloading from remote DVR.
	// Format: bytes (bytes)
	BytesDvr() *Bytes
	// Number of bytes received by this stream when downloading from remote DVR.
	// Format: bytes (bytes)
	SetBytesDvr(Bytes) InputStats
	// Indicates that the stream sources have different track sets, which may cause switching problems. The list of tracks to be compared is obtained only when the sources are checked or started, until then the stream is considered normal.
	DivergentInputs() *bool
	// Indicates that the stream sources have different track sets, which may cause switching problems. The list of tracks to be compared is obtained only when the sources are checked or started, until then the stream is considered normal.
	SetDivergentInputs(bool) InputStats
	// Information about DVR that this input has
	DvrInfo() DvrInfo
	// Information about DVR that this input has
	SetDvrInfo(DvrInfo) InputStats
	// Sum of all other specific errors in the last minute
	// Example: 0
	ErrorRate() *int
	// Sum of all other specific errors in the last minute
	// Example: 0
	SetErrorRate(int) InputStats
	// Sum of all other specific errors. Can be used for triggering alert on any error
	// Example: 0
	Errors() *int
	// Sum of all other specific errors. Can be used for triggering alert on any error
	// Example: 0
	SetErrors(int) InputStats
	// How many times we've got 403 (eaccess).
	Errors403() *int
	// How many times we've got 403 (eaccess).
	SetErrors403(int) InputStats
	// How many times we've got 404 (enoent).
	Errors404() *int
	// How many times we've got 404 (enoent).
	SetErrors404(int) InputStats
	// How many times we've got 500 (backend error).
	Errors500() *int
	// How many times we've got 500 (backend error).
	SetErrors500(int) InputStats
	// Demultiplexing was done right, but content is broken.
	ErrorsBrokenPayload() *int
	// Demultiplexing was done right, but content is broken.
	SetErrorsBrokenPayload(int) InputStats
	// How many times input was restarted due to internal crash.
	// This may happen due to unhandled input.
	ErrorsCrashed() *int
	// How many times input was restarted due to internal crash.
	// This may happen due to unhandled input.
	SetErrorsCrashed(int) InputStats
	// Decoder reset count due to abnormal DTS change. Can happen in MPEG-TS, RTP.
	ErrorsDecoderReset() *int
	// Decoder reset count due to abnormal DTS change. Can happen in MPEG-TS, RTP.
	SetErrorsDecoderReset(int) InputStats
	// This can be used as a `TS_sync_loss` - how many times MPEG-TS sync was lost.
	// Also this counter refers to RTSP desync, when camera starts dropping TCP data and
	// we have to find packet boundaries.
	// Here we write count of such resynchronizations.
	ErrorsDesync() *int
	// This can be used as a `TS_sync_loss` - how many times MPEG-TS sync was lost.
	// Also this counter refers to RTSP desync, when camera starts dropping TCP data and
	// we have to find packet boundaries.
	// Here we write count of such resynchronizations.
	SetErrorsDesync(int) InputStats
	// Dropped frames count due timestamp adjustment.
	ErrorsDroppedFrames() *int
	// Dropped frames count due timestamp adjustment.
	SetErrorsDroppedFrames(int) InputStats
	// RTP, MPEG-TS or other protocols have enough information to tell how many packets were lost
	ErrorsLostPackets() *int
	// RTP, MPEG-TS or other protocols have enough information to tell how many packets were lost
	SetErrorsLostPackets(int) InputStats
	// how many times PAT was missing during 0,5 seconds or pid 0 misses PAT
	// `PAT_error`
	ErrorsTSPat() *int
	// how many times PAT was missing during 0,5 seconds or pid 0 misses PAT
	// `PAT_error`
	SetErrorsTSPat(int) InputStats
	// How many times have received PAT that was missing required service (program)
	ErrorsTSServiceLost() *int
	// How many times have received PAT that was missing required service (program)
	SetErrorsTSServiceLost(int) InputStats
	// Number of connection restarts to fix ts_stuck issue. Can happen in RTSP.
	ErrorsTSStuckRestarts() *int
	// Number of connection restarts to fix ts_stuck issue. Can happen in RTSP.
	SetErrorsTSStuckRestarts(int) InputStats
	// Number of frames passed to this stream from the inputs.
	Frames() *int
	// Number of frames passed to this stream from the inputs.
	SetFrames(int) InputStats
	// Aggregated: how many times this stream has switched between different inputs.
	// Individual input: number of times switched to this input.
	InputSwitches() *int
	// Aggregated: how many times this stream has switched between different inputs.
	// Individual input: number of times switched to this input.
	SetInputSwitches(int) InputStats
	// Number of secondary inputs that have some problems.
	// Example: 0
	InvalidSecondaryInputs() *int
	// Number of secondary inputs that have some problems.
	// Example: 0
	SetInvalidSecondaryInputs(int) InputStats
	// IP address of the connected peer.
	// Example: 172.16.25.73
	IP() *string
	// IP address of the connected peer.
	// Example: 172.16.25.73
	SetIP(string) InputStats
	// Technical description of the input content.
	MediaInfo() MediaInfo
	// Technical description of the input content.
	SetMediaInfo(MediaInfo) InputStats
	// Indicates, how often does media_info changes
	MediaInfoChanges() *int
	// Indicates, how often does media_info changes
	SetMediaInfoChanges(int) InputStats
	MotionDetector() InputMotionDetectorCounters
	SetMotionDetector(InputMotionDetectorCounters) InputStats
	// How many seconds has this stream had no frames.
	// Format: seconds (seconds)
	NumSecNoData() *Seconds
	// How many seconds has this stream had no frames.
	// Format: seconds (seconds)
	SetNumSecNoData(Seconds) InputStats
	// How many seconds has this stream played from primary input.
	// Format: seconds (seconds)
	NumSecOnPrimaryInput() *Seconds
	// How many seconds has this stream played from primary input.
	// Format: seconds (seconds)
	SetNumSecOnPrimaryInput(Seconds) InputStats
	// How many seconds has this stream played from secondary inputs.
	// Format: seconds (seconds)
	NumSecOnSecondaryInput() *Seconds
	// How many seconds has this stream played from secondary inputs.
	// Format: seconds (seconds)
	SetNumSecOnSecondaryInput(Seconds) InputStats
	// The time when this session was created.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	OpenedAt() *UtcMs
	// The time when this session was created.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	SetOpenedAt(UtcMs) InputStats
	// Per pid statistics calculated for MPEG-TS input
	Pids() []InputPidCounters
	// Per pid statistics calculated for MPEG-TS input
	SetPids([]InputPidCounters) InputStats
	// Protocol used for the data transmission in the session.
	// Example: dash
	Proto() *Protocol
	// Protocol used for the data transmission in the session.
	// Example: dash
	SetProto(Protocol) InputStats
	// Source may send frames not in the order they should be played. It will be catched and reordered.
	// This counter indicates how many times did it happened.
	ReorderCount() *int
	// Source may send frames not in the order they should be played. It will be catched and reordered.
	// This counter indicates how many times did it happened.
	SetReorderCount(int) InputStats
	// Source may send frames timestamps faster or slower than realtime.
	// Live stream will catch it and resync. This counter indicates how many times did it happened.
	ResyncCountDrift() *int
	// Source may send frames timestamps faster or slower than realtime.
	// Live stream will catch it and resync. This counter indicates how many times did it happened.
	SetResyncCountDrift(int) InputStats
	// Source may change timestamps without any signalling. This counter indicates how bad is the source
	ResyncCountJump() *int
	// Source may change timestamps without any signalling. This counter indicates how bad is the source
	SetResyncCountJump(int) InputStats
	// Stream timestamps are synchronized with real time. This counter tells, how many times
	// it was syncronized after source reconnect.
	ResyncCountNormal() *int
	// Stream timestamps are synchronized with real time. This counter tells, how many times
	// it was syncronized after source reconnect.
	SetResyncCountNormal(int) InputStats
	// How many times has this stream retried to connect to source
	Retries() *int
	// How many times has this stream retried to connect to source
	SetRetries(int) InputStats
	// Per channel statistics calculated for RTP input
	RTPChannels() []InputRTPCounters
	// Per channel statistics calculated for RTP input
	SetRTPChannels([]InputRTPCounters) InputStats
	Sdi() InputSdiCounters
	SetSdi(InputSdiCounters) InputStats
	Srt() InputSrtCounters
	SetSrt(InputSrtCounters) InputStats
	// The time period during which no frames were received from the stream's input.
	// Format: ticks (ticks)
	// Example: 1284
	TSDelay() *Ticks
	// The time period during which no frames were received from the stream's input.
	// Format: ticks (ticks)
	// Example: 1284
	SetTSDelay(Ticks) InputStats
	// The time period during which no frames were received per each track according to `media_info`
	// Example: [1284]
	TSDelayPerTracks() []Ticks
	// The time period during which no frames were received per each track according to `media_info`
	// Example: [1284]
	SetTSDelayPerTracks([]Ticks) InputStats
	// Deprecated field. Will be deleted at 25.03
	// Final URL after redirects.
	// Deprecated because was never actually used.
	// Format: url (url)
	// Example: udp://239.0.0.1:1234
	URL() *URL
	// Deprecated field. Will be deleted at 25.03
	// Final URL after redirects.
	// Deprecated because was never actually used.
	// Format: url (url)
	// Example: udp://239.0.0.1:1234
	SetURL(URL) InputStats
	// Client's user agent for selected protocol.
	// Example: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML. like Gecko) Chrome/90.0.4430.72 Safari/537.36
	UserAgent() *string
	// Client's user agent for selected protocol.
	// Example: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML. like Gecko) Chrome/90.0.4430.72 Safari/537.36
	SetUserAgent(string) InputStats
	// Number of secondary inputs that have no problems.
	// Example: 2
	ValidSecondaryInputs() *int
	// Number of secondary inputs that have no problems.
	// Example: 2
	SetValidSecondaryInputs(int) InputStats
}

type LoginInfoAdditional interface {
	// A JWT token with a limited lifetime duration. JWT algorithm is RS256.
	// Example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
	AccessToken() *string
	// A JWT token with a limited lifetime duration. JWT algorithm is RS256.
	// Example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
	SetAccessToken(string) LoginInfoAdditional
	// A token used to get a new access_token after expiration.
	// It works with `/login` request only.
	// Example: 3637e790-5530-11ed-bdc3-0242ac120002
	RefreshToken() *string
	// A token used to get a new access_token after expiration.
	// It works with `/login` request only.
	// Example: 3637e790-5530-11ed-bdc3-0242ac120002
	SetRefreshToken(string) LoginInfoAdditional
}

type LoginInfoBase interface {
	// A JWT token with a limited lifetime duration. JWT algorithm is RS256.
	// Example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
	AccessToken() *string
	// A JWT token with a limited lifetime duration. JWT algorithm is RS256.
	// Example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
	SetAccessToken(string) LoginInfoBase
	// A token used to get a new access_token after expiration.
	// It works with `/login` request only.
	// Example: 3637e790-5530-11ed-bdc3-0242ac120002
	RefreshToken() *string
	// A token used to get a new access_token after expiration.
	// It works with `/login` request only.
	// Example: 3637e790-5530-11ed-bdc3-0242ac120002
	SetRefreshToken(string) LoginInfoBase
}

type Map interface {
	// Map server API Key if required.
	APIKey() *string
	// Map server API Key if required.
	SetAPIKey(string) Map
	// Coordinates of map center.
	Center() MapSpec
	// Coordinates of map center.
	SetCenter(MapSpec) Map
	// Provider of the maps.
	Provider() string
	// Provider of the maps.
	SetProvider(string) Map
	// Custom map server url.
	// Format: url (url)
	URL() URL
	// Custom map server url.
	// Format: url (url)
	SetURL(URL) Map
}

// Properties of the map
// Required: provider
type MapBase interface {
	// Map server API Key if required.
	APIKey() *string
	// Map server API Key if required.
	SetAPIKey(string) MapBase
	// Coordinates of map center.
	Center() MapSpec
	// Coordinates of map center.
	SetCenter(MapSpec) MapBase
	// Provider of the maps.
	Provider() string
	// Provider of the maps.
	SetProvider(string) MapBase
}

type MapCustom interface {
	// Map server API Key if required.
	APIKey() *string
	// Map server API Key if required.
	SetAPIKey(string) MapCustom
	// Coordinates of map center.
	Center() MapSpec
	// Coordinates of map center.
	SetCenter(MapSpec) MapCustom
	// Provider of the maps.
	Provider() string
	// Provider of the maps.
	SetProvider(string) MapCustom
	// Custom map server url.
	// Format: url (url)
	URL() URL
	// Custom map server url.
	// Format: url (url)
	SetURL(URL) MapCustom
}

// Required: latitude, longitude
type MapSpec interface {
	// Geographic latitude.
	// Example: 55.7512
	Latitude() float64
	// Geographic latitude.
	// Example: 55.7512
	SetLatitude(float64) MapSpec
	// Geographic longitude.
	// Example: 37.6184
	Longitude() float64
	// Geographic longitude.
	// Example: 37.6184
	SetLongitude(float64) MapSpec
}

type MediaInfo interface {
	// Duration of the media, if applicable.
	// Format: ticks (ticks)
	Duration() *Ticks
	// Duration of the media, if applicable.
	// Format: ticks (ticks)
	SetDuration(Ticks) MediaInfo
	// Whether it is a file with a finite start and end time or a live stream.
	// Example: stream
	FlowType() *MediaInfoSpecificFlowType
	// Whether it is a file with a finite start and end time or a live stream.
	// Example: stream
	SetFlowType(MediaInfoSpecificFlowType) MediaInfo
	// The program ID for MPEG TS streams.
	// Example: 110
	ProgramID() *int
	// The program ID for MPEG TS streams.
	// Example: 110
	SetProgramID(int) MediaInfo
	// The media provider of this content.
	// Example: Netflix
	Provider() *string
	// The media provider of this content.
	// Example: Netflix
	SetProvider(string) MediaInfo
	// The identifier of the transport stream for MPEG TS streams.
	// Example: 253
	StreamID() *int
	// The identifier of the transport stream for MPEG TS streams.
	// Example: 253
	SetStreamID(int) MediaInfo
	// Human-readable title of the media.
	// Example: Bunny
	Title() *string
	// Human-readable title of the media.
	// Example: Bunny
	SetTitle(string) MediaInfo
	// Information about available tracks (video, audio, or text).
	Tracks() []TrackInfo
	// Information about available tracks (video, audio, or text).
	SetTracks([]TrackInfo) MediaInfo
}

type MediaInfoCommon interface {
	// The program ID for MPEG TS streams.
	// Example: 110
	ProgramID() *int
	// The program ID for MPEG TS streams.
	// Example: 110
	SetProgramID(int) MediaInfoCommon
	// The media provider of this content.
	// Example: Netflix
	Provider() *string
	// The media provider of this content.
	// Example: Netflix
	SetProvider(string) MediaInfoCommon
	// The identifier of the transport stream for MPEG TS streams.
	// Example: 253
	StreamID() *int
	// The identifier of the transport stream for MPEG TS streams.
	// Example: 253
	SetStreamID(int) MediaInfoCommon
	// Human-readable title of the media.
	// Example: Bunny
	Title() *string
	// Human-readable title of the media.
	// Example: Bunny
	SetTitle(string) MediaInfoCommon
}

type MediaInfoSpecific interface {
	// Duration of the media, if applicable.
	// Format: ticks (ticks)
	Duration() *Ticks
	// Duration of the media, if applicable.
	// Format: ticks (ticks)
	SetDuration(Ticks) MediaInfoSpecific
	// Whether it is a file with a finite start and end time or a live stream.
	// Example: stream
	FlowType() *MediaInfoSpecificFlowType
	// Whether it is a file with a finite start and end time or a live stream.
	// Example: stream
	SetFlowType(MediaInfoSpecificFlowType) MediaInfoSpecific
	// Information about available tracks (video, audio, or text).
	Tracks() []TrackInfo
	// Information about available tracks (video, audio, or text).
	SetTracks([]TrackInfo) MediaInfoSpecific
}

type Message interface {
	Body() *string
	SetBody(string) Message
	// Identifier of the message.
	// Example: 1
	ID() *int
	// Identifier of the message.
	// Example: 1
	SetID(int) Message
	// Whether to display the notification on the information panel or not
	// Example: false
	IsDashboard() *bool
	// Whether to display the notification on the information panel or not
	// Example: false
	SetIsDashboard(bool) Message
	// This parameter indicates whether the message is deleted or not.
	// Example: false
	IsDeleted() *bool
	// This parameter indicates whether the message is deleted or not.
	// Example: false
	SetIsDeleted(bool) Message
	// Whether to send a push notification to mobile devices or not
	// Example: false
	IsPush() *bool
	// Whether to send a push notification to mobile devices or not
	// Example: false
	SetIsPush(bool) Message
	// Message sender
	Sender() MessageSender
	// Message sender
	SetSender(MessageSender) Message
	Title() *string
	SetTitle(string) Message
	// The type of a message.
	// Example: warning
	Type() *MessageBaseType
	// The type of a message.
	// Example: warning
	SetType(MessageBaseType) Message
	// Message recipient
	User() MessageUser
	// Message recipient
	SetUser(MessageUser) Message
	// This parameter indicates whether the message has been read or not.
	// Example: false
	WasRead() *bool
	// This parameter indicates whether the message has been read or not.
	// Example: false
	SetWasRead(bool) Message
}

// The message that will be sent to the user.
type MessageBase interface {
	Body() *string
	SetBody(string) MessageBase
	// Whether to display the notification on the information panel or not
	// Example: false
	IsDashboard() *bool
	// Whether to display the notification on the information panel or not
	// Example: false
	SetIsDashboard(bool) MessageBase
	// Whether to send a push notification to mobile devices or not
	// Example: false
	IsPush() *bool
	// Whether to send a push notification to mobile devices or not
	// Example: false
	SetIsPush(bool) MessageBase
	Title() *string
	SetTitle(string) MessageBase
	// The type of a message.
	// Example: warning
	Type() *MessageBaseType
	// The type of a message.
	// Example: warning
	SetType(MessageBaseType) MessageBase
}

type MessageChangeRequest interface {
	Body() *string
	SetBody(string) MessageChangeRequest
	// Whether to display the notification on the information panel or not
	// Example: false
	IsDashboard() *bool
	// Whether to display the notification on the information panel or not
	// Example: false
	SetIsDashboard(bool) MessageChangeRequest
	// Whether to send a push notification to mobile devices or not
	// Example: false
	IsPush() *bool
	// Whether to send a push notification to mobile devices or not
	// Example: false
	SetIsPush(bool) MessageChangeRequest
	Title() *string
	SetTitle(string) MessageChangeRequest
	// The type of a message.
	// Example: warning
	Type() *MessageBaseType
	// The type of a message.
	// Example: warning
	SetType(MessageBaseType) MessageChangeRequest
	// This parameter indicates whether the message has been read or not.
	// Example: false
	WasRead() *bool
	// This parameter indicates whether the message has been read or not.
	// Example: false
	SetWasRead(bool) MessageChangeRequest
}

type MessageResponse interface {
	Body() *string
	SetBody(string) MessageResponse
	// The number of devices to which push notifications were sent. If the flag `is_push` is set to `true` and no devices are returned,
	// it means the user has no devices registered for push notifications.
	// Example: 3
	Devices() *int
	// The number of devices to which push notifications were sent. If the flag `is_push` is set to `true` and no devices are returned,
	// it means the user has no devices registered for push notifications.
	// Example: 3
	SetDevices(int) MessageResponse
	// Identifier of the message.
	// Example: 1
	ID() *int
	// Identifier of the message.
	// Example: 1
	SetID(int) MessageResponse
	// Whether to display the notification on the information panel or not
	// Example: false
	IsDashboard() *bool
	// Whether to display the notification on the information panel or not
	// Example: false
	SetIsDashboard(bool) MessageResponse
	// This parameter indicates whether the message is deleted or not.
	// Example: false
	IsDeleted() *bool
	// This parameter indicates whether the message is deleted or not.
	// Example: false
	SetIsDeleted(bool) MessageResponse
	// Whether to send a push notification to mobile devices or not
	// Example: false
	IsPush() *bool
	// Whether to send a push notification to mobile devices or not
	// Example: false
	SetIsPush(bool) MessageResponse
	// Message sender
	Sender() MessageSender
	// Message sender
	SetSender(MessageSender) MessageResponse
	Title() *string
	SetTitle(string) MessageResponse
	// The type of a message.
	// Example: warning
	Type() *MessageBaseType
	// The type of a message.
	// Example: warning
	SetType(MessageBaseType) MessageResponse
	// Message recipient
	User() MessageUser
	// Message recipient
	SetUser(MessageUser) MessageResponse
	// This parameter indicates whether the message has been read or not.
	// Example: false
	WasRead() *bool
	// This parameter indicates whether the message has been read or not.
	// Example: false
	SetWasRead(bool) MessageResponse
}

type MessageSend interface {
	Body() *string
	SetBody(string) MessageSend
	// Whether to display the notification on the information panel or not
	// Example: false
	IsDashboard() *bool
	// Whether to display the notification on the information panel or not
	// Example: false
	SetIsDashboard(bool) MessageSend
	// Whether to send a push notification to mobile devices or not
	// Example: false
	IsPush() *bool
	// Whether to send a push notification to mobile devices or not
	// Example: false
	SetIsPush(bool) MessageSend
	Title() *string
	SetTitle(string) MessageSend
	// The type of a message.
	// Example: warning
	Type() *MessageBaseType
	// The type of a message.
	// Example: warning
	SetType(MessageBaseType) MessageSend
	// Identifier of the user to whom the message will be sent.
	// Example: 1
	UserID() *int
	// Identifier of the user to whom the message will be sent.
	// Example: 1
	SetUserID(int) MessageSend
}

// Message sender
type MessageSender interface {
	// User ID who sent the message
	// Example: 1
	ID() *int
	// User ID who sent the message
	// Example: 1
	SetID(int) MessageSender
	// User name who sent the message
	// Example: admin
	Name() *string
	// User name who sent the message
	// Example: admin
	SetName(string) MessageSender
}

// Message recipient
type MessageUser interface {
	// User ID to whom the message was sent
	// Example: 1
	ID() *int
	// User ID to whom the message was sent
	// Example: 1
	SetID(int) MessageUser
	// User name to whom the message was sent
	// Example: support
	Name() *string
	// User name to whom the message was sent
	// Example: support
	SetName(string) MessageUser
}

type Messages interface {
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	EstimatedCount() *int
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	SetEstimatedCount(int) Messages
	// List of fetched messages according to the query parameters.
	Messages() []Message
	// List of fetched messages according to the query parameters.
	SetMessages([]Message) Messages
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	Next() *string
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	SetNext(string) Messages
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	Prev() *string
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	SetPrev(string) Messages
	// An object with a list of different timings measured during this API call.
	Timing() any
	// An object with a list of different timings measured during this API call.
	SetTiming(any) Messages
	// Collection returns the collection items
	Collection() []Message
}

type Mosaic interface {
	// Mosaic identifier.
	// Example: 7
	ID() *int
	// Mosaic identifier.
	// Example: 7
	SetID(int) Mosaic
	// The identifier of organization that the mosaic is linked to.
	// Example: 9
	OrganizationID() *int
	// The identifier of organization that the mosaic is linked to.
	// Example: 9
	SetOrganizationID(int) Mosaic
	// The list of streams from which the mosaic is formed.
	// The array is contiguously filled in the order of the streams' arrangement on the mosaic.
	// An empty element corresponds to a cell without a stream.
	Streams() []MosaicStream
	// The list of streams from which the mosaic is formed.
	// The array is contiguously filled in the order of the streams' arrangement on the mosaic.
	// An empty element corresponds to a cell without a stream.
	SetStreams([]MosaicStream) Mosaic
	// Human-readable mosaic name.
	Title() *string
	// Human-readable mosaic name.
	SetTitle(string) Mosaic
	// Use this parameter to specify mosaic display mode and size.
	// Example: 2x2
	Type() *MosaicBaseType
	// Use this parameter to specify mosaic display mode and size.
	// Example: 2x2
	SetType(MosaicBaseType) Mosaic
}

type MosaicBase interface {
	// The identifier of organization that the mosaic is linked to.
	// Example: 9
	OrganizationID() *int
	// The identifier of organization that the mosaic is linked to.
	// Example: 9
	SetOrganizationID(int) MosaicBase
	// Human-readable mosaic name.
	Title() *string
	// Human-readable mosaic name.
	SetTitle(string) MosaicBase
	// Use this parameter to specify mosaic display mode and size.
	// Example: 2x2
	Type() *MosaicBaseType
	// Use this parameter to specify mosaic display mode and size.
	// Example: 2x2
	SetType(MosaicBaseType) MosaicBase
}

type MosaicSave interface {
	// The identifier of organization that the mosaic is linked to.
	// Example: 9
	OrganizationID() *int
	// The identifier of organization that the mosaic is linked to.
	// Example: 9
	SetOrganizationID(int) MosaicSave
	// The list of streams from which the mosaic is formed.
	// The array is contiguously filled in the order of the streams' arrangement on the mosaic.
	// An empty element corresponds to a cell without a stream.
	Streams() []MosaicSaveStreamsItem
	// The list of streams from which the mosaic is formed.
	// The array is contiguously filled in the order of the streams' arrangement on the mosaic.
	// An empty element corresponds to a cell without a stream.
	SetStreams([]MosaicSaveStreamsItem) MosaicSave
	// Human-readable mosaic name.
	Title() *string
	// Human-readable mosaic name.
	SetTitle(string) MosaicSave
	// Use this parameter to specify mosaic display mode and size.
	// Example: 2x2
	Type() *MosaicBaseType
	// Use this parameter to specify mosaic display mode and size.
	// Example: 2x2
	SetType(MosaicBaseType) MosaicSave
}

type MosaicSaveStreamsItem interface {
	// Globally unique stream name.
	// Format: media_name (media_name)
	// Example: ag-12345
	Name() *MediaName
	// Globally unique stream name.
	// Format: media_name (media_name)
	// Example: ag-12345
	SetName(MediaName) MosaicSaveStreamsItem
}

// The link to the stream.
// There may be an empty object. An empty object corresponds to a cell without a stream.
type MosaicStream interface {
	// A flag indicating if the current stream of the camera is available (true) or not (false).
	Alive() *bool
	// A flag indicating if the current stream of the camera is available (true) or not (false).
	SetAlive(bool) MosaicStream
	// Globally unique stream name.
	// Format: media_name (media_name)
	// Example: ag-12345
	Name() *MediaName
	// Globally unique stream name.
	// Format: media_name (media_name)
	// Example: ag-12345
	SetName(MediaName) MosaicStream
	// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
	// Example: onetime_token
	PlaybackToken() *string
	// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
	// Example: onetime_token
	SetPlaybackToken(string) MosaicStream
	// HTTP(s) URL that can be used for streaming API of this stream
	// Example: https://ms.example.com
	StreamingEndpoint() *string
	// HTTP(s) URL that can be used for streaming API of this stream
	// Example: https://ms.example.com
	SetStreamingEndpoint(string) MosaicStream
	// Human-readable title of the stream. Provided for SDT MPEG-TS table or
	// SDP RTSP title parameter.
	// Example: Hockey channel
	Title() *string
	// Human-readable title of the stream. Provided for SDT MPEG-TS table or
	// SDP RTSP title parameter.
	// Example: Hockey channel
	SetTitle(string) MosaicStream
}

type MosaicsList interface {
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	EstimatedCount() *int
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	SetEstimatedCount(int) MosaicsList
	// List of mosaics
	Mosaics() []Mosaic
	// List of mosaics
	SetMosaics([]Mosaic) MosaicsList
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	Next() *string
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	SetNext(string) MosaicsList
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	Prev() *string
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	SetPrev(string) MosaicsList
	// An object with a list of different timings measured during this API call.
	Timing() any
	// An object with a list of different timings measured during this API call.
	SetTiming(any) MosaicsList
	// Collection returns the collection items
	Collection() []Mosaic
}

// Notification data
// Required: title, body
type NotificationsRequest interface {
	// Body of notification
	Body() string
	// Body of notification
	SetBody(string) NotificationsRequest
	// Title of notification
	Title() string
	// Title of notification
	SetTitle(string) NotificationsRequest
}

type OnOff interface {
	Mode() *OnOffMode
	SetMode(OnOffMode) OnOff
}

type OnOffAuto interface {
	Mode() *OnOffAutoMode
	SetMode(OnOffAutoMode) OnOffAuto
}

type Organization interface {
	// The date and time when the organization was created.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.672531199e+12
	CreatedAt() *UtcMs
	// The date and time when the organization was created.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.672531199e+12
	SetCreatedAt(UtcMs) Organization
	// Organization identifier.
	// Example: 7
	ID() int
	// Organization identifier.
	// Example: 7
	SetID(int) Organization
	// Is that organization is default for new users.
	// Example: true
	IsDefault() *bool
	// Is that organization is default for new users.
	// Example: true
	SetIsDefault(bool) Organization
	// Limits for properties in organization.
	Limits() OrganizationLimits
	// Limits for properties in organization.
	SetLimits(OrganizationLimits) Organization
	// Owner properties.
	Owner() OrganizationOwner
	// Owner properties.
	SetOwner(OrganizationOwner) Organization
	// Pickpoint properties.
	Pickpoint() OrganizationPickpoint
	// Pickpoint properties.
	SetPickpoint(OrganizationPickpoint) Organization
	// Counts for streams, users and mosaics in organization.
	Stats() OrganizationStats
	// Counts for streams, users and mosaics in organization.
	SetStats(OrganizationStats) Organization
	// Human-readable name of the organization.
	// Example: Example LLC
	Title() string
	// Human-readable name of the organization.
	// Example: Example LLC
	SetTitle(string) Organization
	// User permissions in organization.
	UserPermissions() OrganizationPermissions
	// User permissions in organization.
	SetUserPermissions(OrganizationPermissions) Organization
}

// Required: id, title
type OrganizationBase interface {
	// Organization identifier.
	// Example: 7
	ID() int
	// Organization identifier.
	// Example: 7
	SetID(int) OrganizationBase
	// Human-readable name of the organization.
	// Example: Example LLC
	Title() string
	// Human-readable name of the organization.
	// Example: Example LLC
	SetTitle(string) OrganizationBase
}

type OrganizationInviteKey interface {
	// Unique invitation key that can be used to invite users to the organization.
	InviteKey() *string
	// Unique invitation key that can be used to invite users to the organization.
	SetInviteKey(string) OrganizationInviteKey
	// User permissions in organization.
	Permissions() OrganizationInviteSetupPermissions
	// User permissions in organization.
	SetPermissions(OrganizationInviteSetupPermissions) OrganizationInviteKey
}

type OrganizationInviteSetup interface {
	// User permissions in organization.
	Permissions() OrganizationInviteSetupPermissions
	// User permissions in organization.
	SetPermissions(OrganizationInviteSetupPermissions) OrganizationInviteSetup
}

// User permissions in organization.
type OrganizationInviteSetupPermissions interface {
	// An indicator of whether the user has control over the streams.
	CanEditStreams() *bool
	// An indicator of whether the user has control over the streams.
	SetCanEditStreams(bool) OrganizationInviteSetupPermissions
	// An indicator of whether the user has control over the users.
	CanEditUsers() *bool
	// An indicator of whether the user has control over the users.
	SetCanEditUsers(bool) OrganizationInviteSetupPermissions
	// An indicator of whether the user can view statistics of organization.
	CanViewStats() *bool
	// An indicator of whether the user can view statistics of organization.
	SetCanViewStats(bool) OrganizationInviteSetupPermissions
	// An indicator of whether the user can view the streams.
	CanViewStreams() *bool
	// An indicator of whether the user can view the streams.
	SetCanViewStreams(bool) OrganizationInviteSetupPermissions
}

// Limits for properties in organization.
type OrganizationLimits interface {
	// Streams limit in organization. Maximum amount of streams for organization.
	// Example: 50
	Streams() *int
	// Streams limit in organization. Maximum amount of streams for organization.
	// Example: 50
	SetStreams(int) OrganizationLimits
	// Owner cannot add users above this limit.
	// Example: 50
	Users() *int
	// Owner cannot add users above this limit.
	// Example: 50
	SetUsers(int) OrganizationLimits
}

// Owner properties.
type OrganizationOwner interface {
	// ID of the organizations owner.
	// Example: 2
	ID() *int
	// ID of the organizations owner.
	// Example: 2
	SetID(int) OrganizationOwner
	// Name of the organizations owner.
	// Example: admin
	Name() *string
	// Name of the organizations owner.
	// Example: admin
	SetName(string) OrganizationOwner
}

type OrganizationPermissions interface {
	// An indicator of whether the user has control over the persons list in organization.
	// Example: true
	CanEditPersonsLists() *bool
	// An indicator of whether the user has control over the persons list in organization.
	// Example: true
	SetCanEditPersonsLists(bool) OrganizationPermissions
	// An indicator of whether the user has control over the streams.
	// Example: true
	CanEditStreams() *bool
	// An indicator of whether the user has control over the streams.
	// Example: true
	SetCanEditStreams(bool) OrganizationPermissions
	// An indicator of whether the user has control over the users.
	// Example: true
	CanEditUsers() *bool
	// An indicator of whether the user has control over the users.
	// Example: true
	SetCanEditUsers(bool) OrganizationPermissions
	// An indicator of whether the user can view persons list in organization.
	// Example: true
	CanViewPersonsLists() *bool
	// An indicator of whether the user can view persons list in organization.
	// Example: true
	SetCanViewPersonsLists(bool) OrganizationPermissions
	// An indicator of whether the user can view statistics of organization.
	// Example: true
	CanViewStats() *bool
	// An indicator of whether the user can view statistics of organization.
	// Example: true
	SetCanViewStats(bool) OrganizationPermissions
	// An indicator of whether the user can view the streams.
	// Example: true
	CanViewStreams() *bool
	// An indicator of whether the user can view the streams.
	// Example: true
	SetCanViewStreams(bool) OrganizationPermissions
	// Is the user a member of the organization.
	// Example: true
	IsMember() *bool
	// Is the user a member of the organization.
	// Example: true
	SetIsMember(bool) OrganizationPermissions
}

type OrganizationPickpoint interface {
}

type OrganizationPreset interface {
	// Preset identifier
	// Example: 7
	PresetID() *int
	// Preset identifier
	// Example: 7
	SetPresetID(int) OrganizationPreset
}

// Counts for streams, users and mosaics in organization.
type OrganizationStats interface {
	// Count of mosaics in organization.
	// Example: 2
	Mosaics() *int
	// Count of mosaics in organization.
	// Example: 2
	SetMosaics(int) OrganizationStats
	// Count of streams in organization.
	// Example: 12
	Streams() *int
	// Count of streams in organization.
	// Example: 12
	SetStreams(int) OrganizationStats
	// Count of users in organization.
	// Example: 12
	Users() *int
	// Count of users in organization.
	// Example: 12
	SetUsers(int) OrganizationStats
}

type OrganizationStream interface {
	// ID of the organization. Only organization owner or domain administrator could change it.
	// Example: 9
	ID() *int
	// ID of the organization. Only organization owner or domain administrator could change it.
	// Example: 9
	SetID(int) OrganizationStream
	// Title of the organization.
	// Example: Organization 1
	Title() *string
	// Title of the organization.
	// Example: Organization 1
	SetTitle(string) OrganizationStream
}

type OrganizationUser interface {
	// User email
	// Example: user@example.com
	Email() *string
	// User email
	// Example: user@example.com
	SetEmail(string) OrganizationUser
	// User identifier
	// Example: 7
	ID() *int
	// User identifier
	// Example: 7
	SetID(int) OrganizationUser
	// User name
	// Example: Example LLC
	Name() *string
	// User name
	// Example: Example LLC
	SetName(string) OrganizationUser
	// User permissions
	Permissions() OrganizationUserPermissions
	// User permissions
	SetPermissions(OrganizationUserPermissions) OrganizationUser
}

// User permissions
type OrganizationUserPermissions interface {
	// List of permissions in [Folders](https://flussonic.com/doc/api/watcher-client/#tag/folder)
	Folders() []any
	// List of permissions in [Folders](https://flussonic.com/doc/api/watcher-client/#tag/folder)
	SetFolders([]any) OrganizationUserPermissions
	// User permissions in [Organization](https://flussonic.com/doc/api/watcher-client/#tag/organization)
	Organization() OrganizationPermissions
	// User permissions in [Organization](https://flussonic.com/doc/api/watcher-client/#tag/organization)
	SetOrganization(OrganizationPermissions) OrganizationUserPermissions
}

type OrganizationUsersList interface {
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	EstimatedCount() *int
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	SetEstimatedCount(int) OrganizationUsersList
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	Next() *string
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	SetNext(string) OrganizationUsersList
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	Prev() *string
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	SetPrev(string) OrganizationUsersList
	// An object with a list of different timings measured during this API call.
	Timing() any
	// An object with a list of different timings measured during this API call.
	SetTiming(any) OrganizationUsersList
	// List of users in organizations.
	Users() []OrganizationUser
	// List of users in organizations.
	SetUsers([]OrganizationUser) OrganizationUsersList
	// Collection returns the collection items
	Collection() []OrganizationUser
}

type OrganizationsList interface {
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	EstimatedCount() *int
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	SetEstimatedCount(int) OrganizationsList
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	Next() *string
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	SetNext(string) OrganizationsList
	// List of organizations.
	Organizations() []Organization
	// List of organizations.
	SetOrganizations([]Organization) OrganizationsList
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	Prev() *string
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	SetPrev(string) OrganizationsList
	// An object with a list of different timings measured during this API call.
	Timing() any
	// An object with a list of different timings measured during this API call.
	SetTiming(any) OrganizationsList
	// Collection returns the collection items
	Collection() []Organization
}

type PasswordRecovery interface {
	// Email address to which instructions will be sent
	// Format: email (email)
	// Example: user@example.com
	Email() *Email
	// Email address to which instructions will be sent
	// Format: email (email)
	// Example: user@example.com
	SetEmail(Email) PasswordRecovery
}

type PasswordReset interface {
	// New password
	Password() *string
	// New password
	SetPassword(string) PasswordReset
}

// Person
// Required: person_id, updated_at, originator
type Person interface {
	// When this person was marked as deleted
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637095014573e+12
	DeletedAt() *UtcMs
	// When this person was marked as deleted
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637095014573e+12
	SetDeletedAt(UtcMs) Person
	// Identifier of the person in the external system.
	// Use it when supplying the recognition results further into the external system
	// (e.g. for access level check) if the person identifiers in the external system
	// are different from the ones in Flussonic Identification database.
	// This field may contain `null` when video analytics detects a new person
	// which explicitly has no association in the external system (i.e. if `originator=identification_service`).
	// Examples: dedcc8e8
	ExternalID() *string
	// Identifier of the person in the external system.
	// Use it when supplying the recognition results further into the external system
	// (e.g. for access level check) if the person identifiers in the external system
	// are different from the ones in Flussonic Identification database.
	// This field may contain `null` when video analytics detects a new person
	// which explicitly has no association in the external system (i.e. if `originator=identification_service`).
	// Examples: dedcc8e8
	SetExternalID(string) Person
	// When this person was first seen
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637034282845e+12
	FirstSeenAt() *UtcMs
	// When this person was first seen
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637034282845e+12
	SetFirstSeenAt(UtcMs) Person
	// When this person was last seen
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637095014573e+12
	LastSeenAt() *UtcMs
	// When this person was last seen
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637095014573e+12
	SetLastSeenAt(UtcMs) Person
	// The name of the person filled in manually or automatically if not recognized
	// Examples: John Doe, Unknown ABC
	Name() *string
	// The name of the person filled in manually or automatically if not recognized
	// Examples: John Doe, Unknown ABC
	SetName(string) Person
	// Organization information.
	Organization() OrganizationBase
	// Organization information.
	SetOrganization(OrganizationBase) Person
	// Indicates the way this person was created:
	// manually via an api or automatically in the identification service.
	Originator() VisionPersonOriginator
	// Indicates the way this person was created:
	// manually via an api or automatically in the identification service.
	SetOriginator(VisionPersonOriginator) Person
	// Identifier of the person
	// Format: snowflake_id (snowflake_id)
	// Examples: 7.036001172460667e+18
	PersonID() SnowflakeID
	// Identifier of the person
	// Format: snowflake_id (snowflake_id)
	// Examples: 7.036001172460667e+18
	SetPersonID(SnowflakeID) Person
	// Person list details
	PersonList() PersonPersonList
	// Person list details
	SetPersonList(PersonPersonList) Person
	// Person's photos. External system uploads images
	// which are being processed by videoanalytics
	// to get digital fingerprint of the person
	Photos() []VisionImageAttributes
	// Person's photos. External system uploads images
	// which are being processed by videoanalytics
	// to get digital fingerprint of the person
	SetPhotos([]VisionImageAttributes) Person
	// When this person was last updated
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637034282845e+12
	UpdatedAt() UtcMs
	// When this person was last updated
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637034282845e+12
	SetUpdatedAt(UtcMs) Person
}

type PersonLists interface {
	// Identifier of the person list.
	// Example: 1
	ID() *int
	// Identifier of the person list.
	// Example: 1
	SetID(int) PersonLists
	// The person list name.
	// Example: List 1
	Name() *string
	// The person list name.
	// Example: List 1
	SetName(string) PersonLists
	// Organization information.
	Organization() OrganizationBase
	// Organization information.
	SetOrganization(OrganizationBase) PersonLists
	// Counts elements in a list based on specific attributes.
	Stats() PersonListsStats
	// Counts elements in a list based on specific attributes.
	SetStats(PersonListsStats) PersonLists
}

type PersonListsList interface {
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	EstimatedCount() *int
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	SetEstimatedCount(int) PersonListsList
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	Next() *string
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	SetNext(string) PersonListsList
	// List of fetched person lists according to the query parameters.
	PersonLists() []PersonLists
	// List of fetched person lists according to the query parameters.
	SetPersonLists([]PersonLists) PersonListsList
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	Prev() *string
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	SetPrev(string) PersonListsList
	// An object with a list of different timings measured during this API call.
	Timing() any
	// An object with a list of different timings measured during this API call.
	SetTiming(any) PersonListsList
	// Collection returns the collection items
	Collection() []PersonLists
}

// Counts elements in a list based on specific attributes.
type PersonListsStats interface {
	// The number of camera in the person list.
	// Example: 1
	Camera() *int
	// The number of camera in the person list.
	// Example: 1
	SetCamera(int) PersonListsStats
	// The number of person in the person list.
	// Example: 1
	Person() *int
	// The number of person in the person list.
	// Example: 1
	SetPerson(int) PersonListsStats
}

// Person list details
type PersonPersonList interface {
	// Person list identifier
	// Example: 3
	ID() *int
	// Person list identifier
	// Example: 3
	SetID(int) PersonPersonList
	// Person list name
	// Example: List 1
	Name() *string
	// Person list name
	// Example: List 1
	SetName(string) PersonPersonList
}

type PersonsList interface {
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	EstimatedCount() *int
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	SetEstimatedCount(int) PersonsList
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	Next() *string
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	SetNext(string) PersonsList
	// List of fetched persons according to the query parameters.
	Persons() []VisionPerson
	// List of fetched persons according to the query parameters.
	SetPersons([]VisionPerson) PersonsList
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	Prev() *string
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	SetPrev(string) PersonsList
	// An object with a list of different timings measured during this API call.
	Timing() any
	// An object with a list of different timings measured during this API call.
	SetTiming(any) PersonsList
	// Collection returns the collection items
	Collection() []VisionPerson
}

// Required: id, title
type Preset interface {
	// DVR configuration
	Dvr() StreamDvrSpec
	// DVR configuration
	SetDvr(StreamDvrSpec) Preset
	// Preset identifier
	// Example: 7
	ID() int
	// Preset identifier
	// Example: 7
	SetID(int) Preset
	// Shows if the preset is adjustable.
	// ```is_adjustable``` is needed for a situation where presets are managed by external billing.
	// If ```is_adjustable: true``` user can change camera settings meanwhile using this preset.
	// If ```is_adjustable: false``` user can not change camera settings meanwhile using this preset.
	// If the camera has a non-adjustable presets, the DVR and analytics parameters from PUT requests will not be applied.
	// In this case, either make the preset adjustable, or change the preset itself to achieve the required configuration.
	// Example: true
	IsAdjustable() *bool
	// Shows if the preset is adjustable.
	// ```is_adjustable``` is needed for a situation where presets are managed by external billing.
	// If ```is_adjustable: true``` user can change camera settings meanwhile using this preset.
	// If ```is_adjustable: false``` user can not change camera settings meanwhile using this preset.
	// If the camera has a non-adjustable presets, the DVR and analytics parameters from PUT requests will not be applied.
	// In this case, either make the preset adjustable, or change the preset itself to achieve the required configuration.
	// Example: true
	SetIsAdjustable(bool) Preset
	// Shows if the preset is available in all Organizations.
	IsDefault() *bool
	// Shows if the preset is available in all Organizations.
	SetIsDefault(bool) Preset
	// Information about the latest changes made to the preset configuration.
	LastChange() PresetLastChange
	// Information about the latest changes made to the preset configuration.
	SetLastChange(PresetLastChange) Preset
	// Statistics of the preset.
	Stats() PresetStats
	// Statistics of the preset.
	SetStats(PresetStats) Preset
	// Human-readable name of the preset.
	// Example: Example preset name
	Title() string
	// Human-readable name of the preset.
	// Example: Example preset name
	SetTitle(string) Preset
	// Vision configuration
	Vision() VisionSpecPresets
	// Vision configuration
	SetVision(VisionSpecPresets) Preset
}

type PresetLastChange interface {
	// The time when the last changes were made.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.672531199e+12
	UpdatedAt() *UtcMs
	// The time when the last changes were made.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.672531199e+12
	SetUpdatedAt(UtcMs) PresetLastChange
	// Information about the user who modified.
	User() PresetLastChangeUser
	// Information about the user who modified.
	SetUser(PresetLastChangeUser) PresetLastChange
}

// Information about the user who modified.
type PresetLastChangeUser interface {
	// Identifier of the user.
	// Example: 1
	ID() *int
	// Identifier of the user.
	// Example: 1
	SetID(int) PresetLastChangeUser
	// User name (login)
	// Example: admin
	Name() *string
	// User name (login)
	// Example: admin
	SetName(string) PresetLastChangeUser
}

// Statistics of the preset.
type PresetStats interface {
	// Count of organizations are currently using this preset.
	// Example: 12
	OrganizationsCount() *int
	// Count of organizations are currently using this preset.
	// Example: 12
	SetOrganizationsCount(int) PresetStats
	// Count of streams are currently using this preset.
	// Example: 12
	StreamsCount() *int
	// Count of streams are currently using this preset.
	// Example: 12
	SetStreamsCount(int) PresetStats
}

type PresetsList interface {
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	EstimatedCount() *int
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	SetEstimatedCount(int) PresetsList
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	Next() *string
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	SetNext(string) PresetsList
	// List of presets.
	Presets() []Preset
	// List of presets.
	SetPresets([]Preset) PresetsList
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	Prev() *string
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	SetPrev(string) PresetsList
	// An object with a list of different timings measured during this API call.
	Timing() any
	// An object with a list of different timings measured during this API call.
	SetTiming(any) PresetsList
	// Collection returns the collection items
	Collection() []Preset
}

type Profile interface {
	// Apikey for users access via API.
	Apikey() *string
	// Apikey for users access via API.
	SetApikey(string) Profile
	// The date and time when the user was created.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.672531199e+12
	CreatedAt() *UtcMs
	// The date and time when the user was created.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.672531199e+12
	SetCreatedAt(UtcMs) Profile
	// User's email. Required for password recovery.
	// Format: email (email)
	// Example: user@example.com
	Email() *Email
	// User's email. Required for password recovery.
	// Format: email (email)
	// Example: user@example.com
	SetEmail(Email) Profile
	// The user's full name.
	Fullname() *string
	// The user's full name.
	SetFullname(string) Profile
	// Indicates that user has access_level equal "admin".
	IsAdmin() *bool
	// Indicates that user has access_level equal "admin".
	SetIsAdmin(bool) Profile
	// Indicates that user has access_level equal "domain admin".
	IsDomainAdmin() *bool
	// Indicates that user has access_level equal "domain admin".
	SetIsDomainAdmin(bool) Profile
	// Indicates that the user has a read-only access level.
	// Example: true
	IsReadonly() *bool
	// Indicates that the user has a read-only access level.
	// Example: true
	SetIsReadonly(bool) Profile
	// The language, selected by user.
	// Format: ISO 639-1
	// Example: en
	Locale() *ISO6391
	// The language, selected by user.
	// Format: ISO 639-1
	// Example: en
	SetLocale(ISO6391) Profile
	// The maximum number of sessions the user can have simultaneously.
	MaxSessions() *int
	// The maximum number of sessions the user can have simultaneously.
	SetMaxSessions(int) Profile
	// User name (login)
	Name() *string
	// User name (login)
	SetName(string) Profile
	// Additional information or notes about the user.
	Note() *string
	// Additional information or notes about the user.
	SetNote(string) Profile
	// The specified password will be saved as a hash, used only for writing
	Password() *string
	// The specified password will be saved as a hash, used only for writing
	SetPassword(string) Profile
	// User's phone number
	// Format: phone-number (phone-number)
	// Example: +78007778413
	Phone() *PhoneNumber
	// User's phone number
	// Format: phone-number (phone-number)
	// Example: +78007778413
	SetPhone(PhoneNumber) Profile
}

type PtzCommand interface {
	// start PTZ continuous move
	// Example: move_continuous
	Command() *string
	// start PTZ continuous move
	// Example: move_continuous
	SetCommand(string) PtzCommand
	// Speed to move the camera down. Percentage of the maximum pan speed.
	// Example: 50
	Down() *int
	// Speed to move the camera down. Percentage of the maximum pan speed.
	// Example: 50
	SetDown(int) PtzCommand
	// Speed to zoom in the camera. Percentage of the maximum zoom speed.
	// Example: 20
	In() *int
	// Speed to zoom in the camera. Percentage of the maximum zoom speed.
	// Example: 20
	SetIn(int) PtzCommand
	// Speed to move the camera left. Percentage of the maximum tilt speed.
	// Example: 50
	Left() *int
	// Speed to move the camera left. Percentage of the maximum tilt speed.
	// Example: 50
	SetLeft(int) PtzCommand
	// Speed to zoom out the camera. Percentage of the maximum zoom speed.
	// Example: 0
	Out() *int
	// Speed to zoom out the camera. Percentage of the maximum zoom speed.
	// Example: 0
	SetOut(int) PtzCommand
	// Speed to move the camera right. Percentage of the maximum tilt speed.
	// Example: 0
	Right() *int
	// Speed to move the camera right. Percentage of the maximum tilt speed.
	// Example: 0
	SetRight(int) PtzCommand
	// Speed to move the camera up. Percentage of the maximum pan speed.
	// Example: 0
	Up() *int
	// Speed to move the camera up. Percentage of the maximum pan speed.
	// Example: 0
	SetUp(int) PtzCommand
}

type PtzMoveContinuous interface {
	// start PTZ continuous move
	// Example: move_continuous
	Command() *string
	// start PTZ continuous move
	// Example: move_continuous
	SetCommand(string) PtzMoveContinuous
	// Speed to move the camera down. Percentage of the maximum pan speed.
	// Example: 50
	Down() *int
	// Speed to move the camera down. Percentage of the maximum pan speed.
	// Example: 50
	SetDown(int) PtzMoveContinuous
	// Speed to zoom in the camera. Percentage of the maximum zoom speed.
	// Example: 20
	In() *int
	// Speed to zoom in the camera. Percentage of the maximum zoom speed.
	// Example: 20
	SetIn(int) PtzMoveContinuous
	// Speed to move the camera left. Percentage of the maximum tilt speed.
	// Example: 50
	Left() *int
	// Speed to move the camera left. Percentage of the maximum tilt speed.
	// Example: 50
	SetLeft(int) PtzMoveContinuous
	// Speed to zoom out the camera. Percentage of the maximum zoom speed.
	// Example: 0
	Out() *int
	// Speed to zoom out the camera. Percentage of the maximum zoom speed.
	// Example: 0
	SetOut(int) PtzMoveContinuous
	// Speed to move the camera right. Percentage of the maximum tilt speed.
	// Example: 0
	Right() *int
	// Speed to move the camera right. Percentage of the maximum tilt speed.
	// Example: 0
	SetRight(int) PtzMoveContinuous
	// Speed to move the camera up. Percentage of the maximum pan speed.
	// Example: 0
	Up() *int
	// Speed to move the camera up. Percentage of the maximum pan speed.
	// Example: 0
	SetUp(int) PtzMoveContinuous
}

// Required: channel_id
type RTPCountersBase interface {
	// How many bytes received for this channel
	Bytes() *int
	// How many bytes received for this channel
	SetBytes(int) RTPCountersBase
	// RTP channel number
	// Example: 0
	ChannelID() int
	// RTP channel number
	// Example: 0
	SetChannelID(int) RTPCountersBase
	// Content of the track transmitted in the channel
	// Example: video
	Content() *string
	// Content of the track transmitted in the channel
	// Example: video
	SetContent(string) RTPCountersBase
	// Demultiplexing was done right, but content is broken.
	ErrorsBrokenPayload() *int
	// Demultiplexing was done right, but content is broken.
	SetErrorsBrokenPayload(int) RTPCountersBase
	// Number of frames which dts is same as previous frame dts.
	ErrorsDtsStuck() *int
	// Number of frames which dts is same as previous frame dts.
	SetErrorsDtsStuck(int) RTPCountersBase
	// RTP have enough information to tell how many packets were lost
	ErrorsLostPackets() *int
	// RTP have enough information to tell how many packets were lost
	SetErrorsLostPackets(int) RTPCountersBase
	// How many frames received for this channel
	Frames() *int
	// How many frames received for this channel
	SetFrames(int) RTPCountersBase
	// Number of RTP packets which marker bit is set to one.
	MarkerPacketsCount() *int
	// Number of RTP packets which marker bit is set to one.
	SetMarkerPacketsCount(int) RTPCountersBase
	// How many NACK messages are sent for this channel
	NackCount() *int
	// How many NACK messages are sent for this channel
	SetNackCount(int) RTPCountersBase
	// If no marker bit packet is received after 400 RTP packets then decoder switches to `no_marker_mode` and
	// makes frame on each timecode change.
	// This flag shows if decoder works in `no_marker_mode`.
	NoMarkerModeFlag() *bool
	// If no marker bit packet is received after 400 RTP packets then decoder switches to `no_marker_mode` and
	// makes frame on each timecode change.
	// This flag shows if decoder works in `no_marker_mode`.
	SetNoMarkerModeFlag(bool) RTPCountersBase
	// Number of rtp packets rejected due to wrong payload type
	PtRejectCount() *int
	// Number of rtp packets rejected due to wrong payload type
	SetPtRejectCount(int) RTPCountersBase
	// Total size of rejected packets due to wrong payload type (pt_reject_count) rtp packets
	PtRejectSum() *int
	// Total size of rejected packets due to wrong payload type (pt_reject_count) rtp packets
	SetPtRejectSum(int) RTPCountersBase
	// How many RTCP packets received for this channel
	RtcpPackets() *int
	// How many RTCP packets received for this channel
	SetRtcpPackets(int) RTPCountersBase
	// How many RTP packets received for this channel
	RTPPackets() *int
	// How many RTP packets received for this channel
	SetRTPPackets(int) RTPCountersBase
	// Sender wallclock deviation from server time in ms. Positive value means that sender time is ahead of server time.
	SenderClockDeviation() *int
	// Sender wallclock deviation from server time in ms. Positive value means that sender time is ahead of server time.
	SetSenderClockDeviation(int) RTPCountersBase
	// Number of rtcp SR packets which `RTP timestamp` is equal to the previous rtcp SR packet `RTP timestamp`.
	SrTSStuck() *int
	// Number of rtcp SR packets which `RTP timestamp` is equal to the previous rtcp SR packet `RTP timestamp`.
	SetSrTSStuck(int) RTPCountersBase
	// Time on this channel is jumped back from reference wallclock.
	TSGoesBackwards() *int
	// Time on this channel is jumped back from reference wallclock.
	SetTSGoesBackwards(int) RTPCountersBase
	// Time on this channel is jumped forward from reference wallclock.
	TSJumpForward() *int
	// Time on this channel is jumped forward from reference wallclock.
	SetTSJumpForward(int) RTPCountersBase
	// https://datatracker.ietf.org/doc/html/rfc6184#section-4.1
	// access unit: A set of NAL units always containing a primary coded picture.  In addition to the primary coded
	// picture, an access unit may also contain one or more redundant coded pictures or other NAL units not containing
	// slices or slice data partitions of a coded picture.  The decoding of an access unit always results in a
	// decoded picture.
	// There is `marker bit` in RTP packet which is set for the very last packet of the access unit indicated by the RTP timestamp.
	// It is protocol violation if received RTP packet has the same timestamp as previous marker bit packet.
	// This counter is a number of RTP packets which `RTP timestamp` is equal to previous RTP marker bit packet.
	TSStuck() *int
	// https://datatracker.ietf.org/doc/html/rfc6184#section-4.1
	// access unit: A set of NAL units always containing a primary coded picture.  In addition to the primary coded
	// picture, an access unit may also contain one or more redundant coded pictures or other NAL units not containing
	// slices or slice data partitions of a coded picture.  The decoding of an access unit always results in a
	// decoded picture.
	// There is `marker bit` in RTP packet which is set for the very last packet of the access unit indicated by the RTP timestamp.
	// It is protocol violation if received RTP packet has the same timestamp as previous marker bit packet.
	// This counter is a number of RTP packets which `RTP timestamp` is equal to previous RTP marker bit packet.
	SetTSStuck(int) RTPCountersBase
}

type Sensor interface {
	// Image blacklight compensation correction
	BlacklightCompensation() OnOff
	// Image blacklight compensation correction
	SetBlacklightCompensation(OnOff) Sensor
	// Image brightness correction.
	// The value is indicated as a percentage from 0 to 100.
	// Format: percent (percent)
	BrightnessCorrection() *Percent
	// Image brightness correction.
	// The value is indicated as a percentage from 0 to 100.
	// Format: percent (percent)
	SetBrightnessCorrection(Percent) Sensor
	// Image contrast correction.
	// The value is indicated as a percentage from 0 to 100.
	// Format: percent (percent)
	ContrastCorrection() *Percent
	// Image contrast correction.
	// The value is indicated as a percentage from 0 to 100.
	// Format: percent (percent)
	SetContrastCorrection(Percent) Sensor
	// Installation position of the camera
	ImageOrientation() *SensorImageOrientation
	// Installation position of the camera
	SetImageOrientation(SensorImageOrientation) Sensor
	// Infrared cut-of filter
	InfraredCutoffFilter() OnOffAuto
	// Infrared cut-of filter
	SetInfraredCutoffFilter(OnOffAuto) Sensor
	// Image saturation correction.
	// The value is indicated as a percentage from 0 to 100.
	// Format: percent (percent)
	Saturation() *Percent
	// Image saturation correction.
	// The value is indicated as a percentage from 0 to 100.
	// Format: percent (percent)
	SetSaturation(Percent) Sensor
	// Sharpness / edges contrast enhancement level.
	// The value is indicated as a percentage from 0 to 100.
	// Format: percent (percent)
	Sharpness() *Percent
	// Sharpness / edges contrast enhancement level.
	// The value is indicated as a percentage from 0 to 100.
	// Format: percent (percent)
	SetSharpness(Percent) Sensor
	// Image wide dynamic range correction.
	// The value is indicated as a percentage from 0 to 100.
	// Format: percent (percent)
	WideDynamicRange() *Percent
	// Image wide dynamic range correction.
	// The value is indicated as a percentage from 0 to 100.
	// Format: percent (percent)
	SetWideDynamicRange(Percent) Sensor
}

// A stream who has been granted access via stream permissions.
type StreamBaseStreamPermissions interface {
	// Stream name
	Name() *string
	// Stream name
	SetName(string) StreamBaseStreamPermissions
}

type StreamConfig interface {
	// Audio settings for the stream.
	Audio() WatcherStreamConfigAudio
	// Audio settings for the stream.
	SetAudio(WatcherStreamConfigAudio) StreamConfig
	// A publishable stream.
	// Example: false
	CanPublish() *bool
	// A publishable stream.
	// Example: false
	SetCanPublish(bool) StreamConfig
	// Human-readable description of the stream.
	// Example: This is a test stream
	Comment() *string
	// Human-readable description of the stream.
	// Example: This is a test stream
	SetComment(string) StreamConfig
	// Camera coordinates on a map or a floor plan.
	Coordinates() MapSpec
	// Camera coordinates on a map or a floor plan.
	SetCoordinates(MapSpec) StreamConfig
	// The date and time when the steam was created.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.672531199e+12
	CreatedAt() *UtcMs
	// The date and time when the steam was created.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.672531199e+12
	SetCreatedAt(UtcMs) StreamConfig
	// Whether a stream is disabled. Disabled streams are inactive and do not run.
	// Displayed only with the API calls.
	// Example: false
	Disabled() *bool
	// Whether a stream is disabled. Disabled streams are inactive and do not run.
	// Displayed only with the API calls.
	// Example: false
	SetDisabled(bool) StreamConfig
	// DVR configuraton.
	Dvr() StreamDvrSpec
	// DVR configuraton.
	SetDvr(StreamDvrSpec) StreamConfig
	// Duration of the firmware update. If this field is present, the update process is ongoing.
	// Format: milliseconds (milliseconds)
	FirmwareUpdateDuration() *Milliseconds
	// Duration of the firmware update. If this field is present, the update process is ongoing.
	// Format: milliseconds (milliseconds)
	SetFirmwareUpdateDuration(Milliseconds) StreamConfig
	// Folder identificator.
	FolderID() *int
	// Folder identificator.
	SetFolderID(int) StreamConfig
	// List of stream inputs.
	// ***Important:*** A stream without any inputs can receive video frames **only** if backup file is specified.
	Inputs() []StreamInput
	// List of stream inputs.
	// ***Important:*** A stream without any inputs can receive video frames **only** if backup file is specified.
	SetInputs([]StreamInput) StreamConfig
	// The stream is added to favorites list.
	IsFavourite() *bool
	// The stream is added to favorites list.
	SetIsFavourite(bool) StreamConfig
	// Information about the latest changes made to the camera configuration.
	LastChange() AuditLogRecord
	// Information about the latest changes made to the camera configuration.
	SetLastChange(AuditLogRecord) StreamConfig
	// The time when the last episode occurred.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	LastEpisodeAt() *UtcMs
	// The time when the last episode occurred.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetLastEpisodeAt(UtcMs) StreamConfig
	// Deprecated field. Will be deleted at 24.12
	// Camera coordinates on a map or a floor plan. Deprecated. Use coordinates instead.
	MapCoordinates() MapSpec
	// Deprecated field. Will be deleted at 24.12
	// Camera coordinates on a map or a floor plan. Deprecated. Use coordinates instead.
	SetMapCoordinates(MapSpec) StreamConfig
	// Globally unique stream name.
	// Note that the name could not be changed after the stream is created.
	// Format: media_name (media_name)
	// Examples: Decklink-Stream, Dektec-Stream, hockey1, mylive/bunny, test_stream
	Name() MediaName
	// Globally unique stream name.
	// Note that the name could not be changed after the stream is created.
	// Format: media_name (media_name)
	// Examples: Decklink-Stream, Dektec-Stream, hockey1, mylive/bunny, test_stream
	SetName(MediaName) StreamConfig
	// Notifications are enabled for the camera.
	NotificationsEnabled() *bool
	// Notifications are enabled for the camera.
	SetNotificationsEnabled(bool) StreamConfig
	// Onvif configuration
	Onvif() StreamOnvifConfig
	// Onvif configuration
	SetOnvif(StreamOnvifConfig) StreamConfig
	// Organization the stream belongs to.
	Organization() OrganizationStream
	// Organization the stream belongs to.
	SetOrganization(OrganizationStream) StreamConfig
	// Deprecated field. Will be deleted at 25.11
	// ID of the organization the stream belongs to.
	// Only organization owner or domain administrator could change it.
	// Example: 9
	OrganizationID() *int
	// Deprecated field. Will be deleted at 25.11
	// ID of the organization the stream belongs to.
	// Only organization owner or domain administrator could change it.
	// Example: 9
	SetOrganizationID(int) StreamConfig
	// Contains path to stream as a list.
	// Each item of the list can be interpreted as a node in a folders tree.
	Path() []StreamPathItem
	// Contains path to stream as a list.
	// Each item of the list can be interpreted as a node in a folders tree.
	SetPath([]StreamPathItem) StreamConfig
	// Camera adress on a map.
	PostalAddress() *string
	// Camera adress on a map.
	SetPostalAddress(string) StreamConfig
	// Preset settings.
	Preset() StreamPreset
	// Preset settings.
	SetPreset(StreamPreset) StreamConfig
	// Deprecated field. Will be deleted at 26.01
	// Preset identificator.
	PresetID() *int
	// Deprecated field. Will be deleted at 26.01
	// Preset identificator.
	SetPresetID(int) StreamConfig
	// Whether a stream is `static` or not.
	// If set to `True` the server will try to keep this stream running even if
	// there are no viewers or errors encountered.
	// Streamer restarts *all* `static` streams even if any internal errors occur
	// and the `static` streams crash.
	// Example: true
	Static() *bool
	// Whether a stream is `static` or not.
	// If set to `True` the server will try to keep this stream running even if
	// there are no viewers or errors encountered.
	// Streamer restarts *all* `static` streams even if any internal errors occur
	// and the `static` streams crash.
	// Example: true
	SetStatic(bool) StreamConfig
	// Stream's metrics and other statistical information.
	Stats() StreamStats
	// Stream's metrics and other statistical information.
	SetStats(StreamStats) StreamConfig
	// Human-readable title of the stream. Provided for SDT MPEG-TS table or
	// SDP RTSP title parameter.
	// Example: Hockey channel
	Title() *string
	// Human-readable title of the stream. Provided for SDT MPEG-TS table or
	// SDP RTSP title parameter.
	// Example: Hockey channel
	SetTitle(string) StreamConfig
	// Video analytics parameters.
	Vision() VisionSpec
	// Video analytics parameters.
	SetVision(VisionSpec) StreamConfig
}

type StreamConfigAdditional interface {
	// Stream's metrics and other statistical information.
	Stats() StreamStats
	// Stream's metrics and other statistical information.
	SetStats(StreamStats) StreamConfigAdditional
}

type StreamConfigBase interface {
	// Whether a stream is disabled. Disabled streams are inactive and do not run.
	// Displayed only with the API calls.
	// Example: false
	Disabled() *bool
	// Whether a stream is disabled. Disabled streams are inactive and do not run.
	// Displayed only with the API calls.
	// Example: false
	SetDisabled(bool) StreamConfigBase
	// Whether a stream is `static` or not.
	// If set to `True` the server will try to keep this stream running even if
	// there are no viewers or errors encountered.
	// Streamer restarts *all* `static` streams even if any internal errors occur
	// and the `static` streams crash.
	// Example: true
	Static() *bool
	// Whether a stream is `static` or not.
	// If set to `True` the server will try to keep this stream running even if
	// there are no viewers or errors encountered.
	// Streamer restarts *all* `static` streams even if any internal errors occur
	// and the `static` streams crash.
	// Example: true
	SetStatic(bool) StreamConfigBase
}

type StreamConfigInput interface {
	// List of stream inputs.
	// ***Important:*** A stream without any inputs can receive video frames **only** if backup file is specified.
	Inputs() []StreamInput
	// List of stream inputs.
	// ***Important:*** A stream without any inputs can receive video frames **only** if backup file is specified.
	SetInputs([]StreamInput) StreamConfigInput
}

type StreamConfigMedia interface {
	// DVR configuraton.
	Dvr() StreamDvrSpec
	// DVR configuraton.
	SetDvr(StreamDvrSpec) StreamConfigMedia
}

type StreamConfigMultiedit interface {
	// DVR configuration.
	Dvr() StreamDvrSpec
	// DVR configuration.
	SetDvr(StreamDvrSpec) StreamConfigMultiedit
	// Stream name
	Name() *string
	// Stream name
	SetName(string) StreamConfigMultiedit
	// Preset identificator.
	PresetID() *int
	// Preset identificator.
	SetPresetID(int) StreamConfigMultiedit
}

type StreamConfigOnpremises interface {
	// Video analytics parameters.
	Vision() VisionSpec
	// Video analytics parameters.
	SetVision(VisionSpec) StreamConfigOnpremises
}

// Required: name
type StreamConfigSpecific interface {
	// Human-readable description of the stream.
	// Example: This is a test stream
	Comment() *string
	// Human-readable description of the stream.
	// Example: This is a test stream
	SetComment(string) StreamConfigSpecific
	// Globally unique stream name.
	// Note that the name could not be changed after the stream is created.
	// Format: media_name (media_name)
	// Examples: Decklink-Stream, Dektec-Stream, hockey1, mylive/bunny, test_stream
	Name() MediaName
	// Globally unique stream name.
	// Note that the name could not be changed after the stream is created.
	// Format: media_name (media_name)
	// Examples: Decklink-Stream, Dektec-Stream, hockey1, mylive/bunny, test_stream
	SetName(MediaName) StreamConfigSpecific
	// Human-readable title of the stream. Provided for SDT MPEG-TS table or
	// SDP RTSP title parameter.
	// Example: Hockey channel
	Title() *string
	// Human-readable title of the stream. Provided for SDT MPEG-TS table or
	// SDP RTSP title parameter.
	// Example: Hockey channel
	SetTitle(string) StreamConfigSpecific
}

type StreamDvrSpec interface {
	// Additional archive depth in seconds for episodes. If set, episodes and their corresponding DVR record
	// will be saved for `expiration + episodes_expiration` seconds.
	// The archive clean-up within `[expiration, expiration+episodes_expiration]` seconds of the
	// recording performed depending on [external_episodes_list](https://flussonic.com/doc/api/config-external/#tag/dvr/operation/external_episodes_list)
	// response of `episodes_url`.
	// Anything older than `expiration+episodes_expiration` seconds will
	// be cleaned even if `episodes_url` does not respond.
	// Format: seconds (seconds)
	// Examples: 6.048e+06
	EpisodesExpiration() *Seconds
	// Additional archive depth in seconds for episodes. If set, episodes and their corresponding DVR record
	// will be saved for `expiration + episodes_expiration` seconds.
	// The archive clean-up within `[expiration, expiration+episodes_expiration]` seconds of the
	// recording performed depending on [external_episodes_list](https://flussonic.com/doc/api/config-external/#tag/dvr/operation/external_episodes_list)
	// response of `episodes_url`.
	// Anything older than `expiration+episodes_expiration` seconds will
	// be cleaned even if `episodes_url` does not respond.
	// Format: seconds (seconds)
	// Examples: 6.048e+06
	SetEpisodesExpiration(Seconds) StreamDvrSpec
	// Archive depth - a period (in seconds) back from the current moment during which the
	// contigious part of archive is stored.
	// As time goes, the parts of the recording which are older than the archive depth are deleted.
	// If you have option `episodes_expiration` enabled, then some parts of DVR that are
	// locked by episode signalling mechanism may be kept more than this `expiration` depth.
	// If `episodes_url` does not respond, the archive clean-up by `expiration` is not performed;
	// only the archive with expired episodes (`episodes_expiration`) is cleaned up until the `episodes_url` restores.
	// Format: seconds (seconds)
	// Examples: 604800
	Expiration() *Seconds
	// Archive depth - a period (in seconds) back from the current moment during which the
	// contigious part of archive is stored.
	// As time goes, the parts of the recording which are older than the archive depth are deleted.
	// If you have option `episodes_expiration` enabled, then some parts of DVR that are
	// locked by episode signalling mechanism may be kept more than this `expiration` depth.
	// If `episodes_url` does not respond, the archive clean-up by `expiration` is not performed;
	// only the archive with expired episodes (`episodes_expiration`) is cleaned up until the `episodes_url` restores.
	// Format: seconds (seconds)
	// Examples: 604800
	SetExpiration(Seconds) StreamDvrSpec
	// How many servers will contain a copy of the DVR archive.
	// You can find more information [here](https://flussonic.com/doc/api/layouter/#tag/stream/operation/streams_list/response%7Cstreams%7Cdvr%7Credundancy_factor)
	// Example: 1
	RedundancyFactor() *int
	// How many servers will contain a copy of the DVR archive.
	// You can find more information [here](https://flussonic.com/doc/api/layouter/#tag/stream/operation/streams_list/response%7Cstreams%7Cdvr%7Credundancy_factor)
	// Example: 1
	SetRedundancyFactor(int) StreamDvrSpec
	// Maximum disk consumption in bytes. When this limit is reached,
	// the oldest segment of the recording will be overridden by later data.
	// This option affects both continuous recording and locked episodes (see `episodes_url`).
	// If `episodes_url` does not respond, the archive clean-up by `storage_limit` is not performed
	// to avoid deleting the recordings that should not be deleted.
	// Format: bytes (bytes)
	// Example: 4e+11
	StorageLimit() *Bytes
	// Maximum disk consumption in bytes. When this limit is reached,
	// the oldest segment of the recording will be overridden by later data.
	// This option affects both continuous recording and locked episodes (see `episodes_url`).
	// If `episodes_url` does not respond, the archive clean-up by `storage_limit` is not performed
	// to avoid deleting the recordings that should not be deleted.
	// Format: bytes (bytes)
	// Example: 4e+11
	SetStorageLimit(Bytes) StreamDvrSpec
}

type StreamDvrSpecificSpec interface {
	// How many servers will contain a copy of the DVR archive.
	// You can find more information [here](https://flussonic.com/doc/api/layouter/#tag/stream/operation/streams_list/response%7Cstreams%7Cdvr%7Credundancy_factor)
	// Example: 1
	RedundancyFactor() *int
	// How many servers will contain a copy of the DVR archive.
	// You can find more information [here](https://flussonic.com/doc/api/layouter/#tag/stream/operation/streams_list/response%7Cstreams%7Cdvr%7Credundancy_factor)
	// Example: 1
	SetRedundancyFactor(int) StreamDvrSpecificSpec
}

type StreamInputBase interface {
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	AllowIf() *string
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	SetAllowIf(string) StreamInputBase
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	AudioTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetAudioTimeout(Seconds) StreamInputBase
	// Human-readable description of the input.
	// Example: This is a test input
	Comment() *string
	// Human-readable description of the input.
	// Example: This is a test input
	SetComment(string) StreamInputBase
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	DenyIf() *string
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	SetDenyIf(string) StreamInputBase
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	FramesTimeout() *int
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	SetFramesTimeout(int) StreamInputBase
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	Headers() map[string]string
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	SetHeaders(map[string]string) StreamInputBase
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	MaxRetryTimeout() *Seconds
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	SetMaxRetryTimeout(Seconds) StreamInputBase
	// Skip input start if the stream has no clients.
	NoClientsReconnectDelay() *int
	// Skip input start if the stream has no clients.
	SetNoClientsReconnectDelay(int) StreamInputBase
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	OutputAudio() *OutputAudio
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	SetOutputAudio(OutputAudio) StreamInputBase
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	Priority() *int
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	SetPriority(int) StreamInputBase
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SourceTimeout() any
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SetSourceTimeout(any) StreamInputBase
	// Detailed runtime information about the input.
	Stats() InputStats
	// Detailed runtime information about the input.
	SetStats(InputStats) StreamInputBase
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	Timeout() *int
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	SetTimeout(int) StreamInputBase
	// User agent. Can be modified if a protocol allows it.
	UserAgent() *string
	// User agent. Can be modified if a protocol allows it.
	SetUserAgent(string) StreamInputBase
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	Via() *AgentURL
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	SetVia(AgentURL) StreamInputBase
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	VideoTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetVideoTimeout(Seconds) StreamInputBase
}

type StreamInputFake interface {
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	AllowIf() *string
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	SetAllowIf(string) StreamInputFake
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	AudioTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetAudioTimeout(Seconds) StreamInputFake
	// Bitrate of an artificially created test video stream.
	// Applicable to the `fake://fake` URL.
	// Format: speed (speed)
	Bitrate() *Speed
	// Bitrate of an artificially created test video stream.
	// Applicable to the `fake://fake` URL.
	// Format: speed (speed)
	SetBitrate(Speed) StreamInputFake
	// Human-readable description of the input.
	// Example: This is a test input
	Comment() *string
	// Human-readable description of the input.
	// Example: This is a test input
	SetComment(string) StreamInputFake
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	DenyIf() *string
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	SetDenyIf(string) StreamInputFake
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	FramesTimeout() *int
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	SetFramesTimeout(int) StreamInputFake
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	Headers() map[string]string
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	SetHeaders(map[string]string) StreamInputFake
	// Height of an artificially created test video stream.
	// Applicable to the `fake://fake` URL.
	Height() *int
	// Height of an artificially created test video stream.
	// Applicable to the `fake://fake` URL.
	SetHeight(int) StreamInputFake
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	MaxRetryTimeout() *Seconds
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	SetMaxRetryTimeout(Seconds) StreamInputFake
	// Skip input start if the stream has no clients.
	NoClientsReconnectDelay() *int
	// Skip input start if the stream has no clients.
	SetNoClientsReconnectDelay(int) StreamInputFake
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	OutputAudio() *OutputAudio
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	SetOutputAudio(OutputAudio) StreamInputFake
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	Priority() *int
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	SetPriority(int) StreamInputFake
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SourceTimeout() any
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SetSourceTimeout(any) StreamInputFake
	// Detailed runtime information about the input.
	Stats() InputStats
	// Detailed runtime information about the input.
	SetStats(InputStats) StreamInputFake
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	Timeout() *int
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	SetTimeout(int) StreamInputFake
	// URL to get a demo stream.
	// Format: input_url (input_url)
	// Pattern: ^fake://.*$
	// Example: fake://fake
	URL() InputURL
	// URL to get a demo stream.
	// Format: input_url (input_url)
	// Pattern: ^fake://.*$
	// Example: fake://fake
	SetURL(InputURL) StreamInputFake
	// User agent. Can be modified if a protocol allows it.
	UserAgent() *string
	// User agent. Can be modified if a protocol allows it.
	SetUserAgent(string) StreamInputFake
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	Via() *AgentURL
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	SetVia(AgentURL) StreamInputFake
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	VideoTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetVideoTimeout(Seconds) StreamInputFake
	// Width of an artificially created test video stream.
	// Applicable to the `fake://fake` URL.
	Width() *int
	// Width of an artificially created test video stream.
	// Applicable to the `fake://fake` URL.
	SetWidth(int) StreamInputFake
}

type StreamInputFile interface {
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	AllowIf() *string
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	SetAllowIf(string) StreamInputFile
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	AudioTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetAudioTimeout(Seconds) StreamInputFile
	// The rules for handling the closed captions.
	ClosedCaptions() map[string]string
	// The rules for handling the closed captions.
	SetClosedCaptions(map[string]string) StreamInputFile
	// Human-readable description of the input.
	// Example: This is a test input
	Comment() *string
	// Human-readable description of the input.
	// Example: This is a test input
	SetComment(string) StreamInputFile
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	DenyIf() *string
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	SetDenyIf(string) StreamInputFile
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	FramesTimeout() *int
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	SetFramesTimeout(int) StreamInputFile
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	Headers() map[string]string
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	SetHeaders(map[string]string) StreamInputFile
	// An array of MPEG-TS language descriptors in format `[{key: track, value: language}]`
	Languages() map[string]string
	// An array of MPEG-TS language descriptors in format `[{key: track, value: language}]`
	SetLanguages(map[string]string) StreamInputFile
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	MaxRetryTimeout() *Seconds
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	SetMaxRetryTimeout(Seconds) StreamInputFile
	// Skip input start if the stream has no clients.
	NoClientsReconnectDelay() *int
	// Skip input start if the stream has no clients.
	SetNoClientsReconnectDelay(int) StreamInputFile
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	OutputAudio() *OutputAudio
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	SetOutputAudio(OutputAudio) StreamInputFile
	// Choose a specific PID to ingest from an MPEG-TS stream.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Example: [211]
	Pids() []int
	// Choose a specific PID to ingest from an MPEG-TS stream.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Example: [211]
	SetPids([]int) StreamInputFile
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	Priority() *int
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	SetPriority(int) StreamInputFile
	// Choose a program to ingest from an MPEG-TS stream.
	// Example: [1]
	Programs() []int
	// Choose a program to ingest from an MPEG-TS stream.
	// Example: [1]
	SetPrograms([]int) StreamInputFile
	// Deprecated field. Will be deleted at 23.09
	// This option disables processing of SCTE-35 markers from an MPEG-TS input stream.
	// Deprecated since 22.12.
	// Available ways to disable processing of SCTE-35 markers:
	// 1. pids option to select tracks without SCTE-35 markers
	// 2. hls_scte35 option from stream_config_media for hls output
	// 3. performing appropriate tuning pids in the transponder
	// Example: true
	Scte35() *bool
	// Deprecated field. Will be deleted at 23.09
	// This option disables processing of SCTE-35 markers from an MPEG-TS input stream.
	// Deprecated since 22.12.
	// Available ways to disable processing of SCTE-35 markers:
	// 1. pids option to select tracks without SCTE-35 markers
	// 2. hls_scte35 option from stream_config_media for hls output
	// 3. performing appropriate tuning pids in the transponder
	// Example: true
	SetScte35(bool) StreamInputFile
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SourceTimeout() any
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SetSourceTimeout(any) StreamInputFile
	// Detailed runtime information about the input.
	Stats() InputStats
	// Detailed runtime information about the input.
	SetStats(InputStats) StreamInputFile
	// Deprecated field. Will be deleted at 25.03
	// This configuration is deprecated. Use `dvbocr` configuration field in stream.
	// This parameter allows to manage subtitles in an output stream.
	// Example: drop
	Subtitles() *StreamInputMpegtsSpecificSubtitles
	// Deprecated field. Will be deleted at 25.03
	// This configuration is deprecated. Use `dvbocr` configuration field in stream.
	// This parameter allows to manage subtitles in an output stream.
	// Example: drop
	SetSubtitles(StreamInputMpegtsSpecificSubtitles) StreamInputFile
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	Timeout() *int
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	SetTimeout(int) StreamInputFile
	// URL to get a stream from file.
	// Format: input_url (input_url)
	// Pattern: ^file://.*$
	// Example: file://vod/bunny.mp4
	URL() InputURL
	// URL to get a stream from file.
	// Format: input_url (input_url)
	// Pattern: ^file://.*$
	// Example: file://vod/bunny.mp4
	SetURL(InputURL) StreamInputFile
	// User agent. Can be modified if a protocol allows it.
	UserAgent() *string
	// User agent. Can be modified if a protocol allows it.
	SetUserAgent(string) StreamInputFile
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	Via() *AgentURL
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	SetVia(AgentURL) StreamInputFile
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	VideoTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetVideoTimeout(Seconds) StreamInputFile
}

type StreamInputMpegtsSpecific interface {
	// The rules for handling the closed captions.
	ClosedCaptions() map[string]string
	// The rules for handling the closed captions.
	SetClosedCaptions(map[string]string) StreamInputMpegtsSpecific
	// An array of MPEG-TS language descriptors in format `[{key: track, value: language}]`
	Languages() map[string]string
	// An array of MPEG-TS language descriptors in format `[{key: track, value: language}]`
	SetLanguages(map[string]string) StreamInputMpegtsSpecific
	// Choose a specific PID to ingest from an MPEG-TS stream.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Example: [211]
	Pids() []int
	// Choose a specific PID to ingest from an MPEG-TS stream.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Example: [211]
	SetPids([]int) StreamInputMpegtsSpecific
	// Choose a program to ingest from an MPEG-TS stream.
	// Example: [1]
	Programs() []int
	// Choose a program to ingest from an MPEG-TS stream.
	// Example: [1]
	SetPrograms([]int) StreamInputMpegtsSpecific
	// Deprecated field. Will be deleted at 23.09
	// This option disables processing of SCTE-35 markers from an MPEG-TS input stream.
	// Deprecated since 22.12.
	// Available ways to disable processing of SCTE-35 markers:
	// 1. pids option to select tracks without SCTE-35 markers
	// 2. hls_scte35 option from stream_config_media for hls output
	// 3. performing appropriate tuning pids in the transponder
	// Example: true
	Scte35() *bool
	// Deprecated field. Will be deleted at 23.09
	// This option disables processing of SCTE-35 markers from an MPEG-TS input stream.
	// Deprecated since 22.12.
	// Available ways to disable processing of SCTE-35 markers:
	// 1. pids option to select tracks without SCTE-35 markers
	// 2. hls_scte35 option from stream_config_media for hls output
	// 3. performing appropriate tuning pids in the transponder
	// Example: true
	SetScte35(bool) StreamInputMpegtsSpecific
	// Deprecated field. Will be deleted at 25.03
	// This configuration is deprecated. Use `dvbocr` configuration field in stream.
	// This parameter allows to manage subtitles in an output stream.
	// Example: drop
	Subtitles() *StreamInputMpegtsSpecificSubtitles
	// Deprecated field. Will be deleted at 25.03
	// This configuration is deprecated. Use `dvbocr` configuration field in stream.
	// This parameter allows to manage subtitles in an output stream.
	// Example: drop
	SetSubtitles(StreamInputMpegtsSpecificSubtitles) StreamInputMpegtsSpecific
}

type StreamInputPublish interface {
	// The correction between the target bitrate (Receiver Estimated Maximum Bitrate, calculated in Flussonic) and browser bitrate, in kbit/s.
	// Flussonic sends the target bitrate to the browser from which the publication is carried out so that the browser adjusts the bitrate of the publication by this value.
	// The default value is 300 kbit/s.
	// Example: 200
	AbrCorrection() *int
	// The correction between the target bitrate (Receiver Estimated Maximum Bitrate, calculated in Flussonic) and browser bitrate, in kbit/s.
	// Flussonic sends the target bitrate to the browser from which the publication is carried out so that the browser adjusts the bitrate of the publication by this value.
	// The default value is 300 kbit/s.
	// Example: 200
	SetAbrCorrection(int) StreamInputPublish
	// The number of cycles of bitrate auto-adjustment.
	// After the specified number of auto-adjustment cycles passes, Flussonic considers the bitrate to be optimal, and it is no longer analyzed.
	// By default, `abr_cycles`=5.
	// If `abr_cycles`=0, the adjustment process takes place all the time while the publication lasts.
	// Example: 3
	AbrCycles() *int
	// The number of cycles of bitrate auto-adjustment.
	// After the specified number of auto-adjustment cycles passes, Flussonic considers the bitrate to be optimal, and it is no longer analyzed.
	// By default, `abr_cycles`=5.
	// If `abr_cycles`=0, the adjustment process takes place all the time while the publication lasts.
	// Example: 3
	SetAbrCycles(int) StreamInputPublish
	// Whether adaptive bitrate process is logged.
	// Example: 1
	AbrDebug() *int
	// Whether adaptive bitrate process is logged.
	// Example: 1
	SetAbrDebug(int) StreamInputPublish
	// The lower limit of packet loss. When it is reached, Flussonic raises the bitrate.
	// That is, if packet loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup` percent.
	// Example: 2
	AbrLossLower() *float64
	// The lower limit of packet loss. When it is reached, Flussonic raises the bitrate.
	// That is, if packet loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup` percent.
	// Example: 2
	SetAbrLossLower(float64) StreamInputPublish
	// The upper limit of packet loss. When it is reached, Flussonic reduces the bitrate.
	// That is, if packet loss is greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.
	// Example: 10
	AbrLossUpper() *float64
	// The upper limit of packet loss. When it is reached, Flussonic reduces the bitrate.
	// That is, if packet loss is greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.
	// Example: 10
	SetAbrLossUpper(float64) StreamInputPublish
	// Maximum bitrate for adjustment process, in kbit/s.
	// Flussonic will keep the publication bitrate equal or below of the specified value.
	// Example: 1000
	AbrMaxBitrate() *int
	// Maximum bitrate for adjustment process, in kbit/s.
	// Flussonic will keep the publication bitrate equal or below of the specified value.
	// Example: 1000
	SetAbrMaxBitrate(int) StreamInputPublish
	// The algorithm for determining the need to change the bitrate of the published stream and for calculating the target bitrate.
	// Two options are possible:
	// * `abr_mode=0` - This mode takes into account the packet losses, target bitrate, browser bitrate and the number of auto-adjustment cycles.
	// * `abr_mode=1` - This mode considers only packet losses and target bitrate.
	// Example: 1
	AbrMode() *int
	// The algorithm for determining the need to change the bitrate of the published stream and for calculating the target bitrate.
	// Two options are possible:
	// * `abr_mode=0` - This mode takes into account the packet losses, target bitrate, browser bitrate and the number of auto-adjustment cycles.
	// * `abr_mode=1` - This mode considers only packet losses and target bitrate.
	// Example: 1
	SetAbrMode(int) StreamInputPublish
	// A step of reducing the bitrate to the minimum.
	// If packet losses are greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.
	AbrStepdown() *float64
	// A step of reducing the bitrate to the minimum.
	// If packet losses are greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.
	SetAbrStepdown(float64) StreamInputPublish
	// Increment step for raising the bitrate to the maximum, in percent. The default step is 30%.
	// If the loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup percent`.
	AbrStepup() *int
	// Increment step for raising the bitrate to the maximum, in percent. The default step is 30%.
	// If the loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup percent`.
	SetAbrStepup(int) StreamInputPublish
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	AllowIf() *string
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	SetAllowIf(string) StreamInputPublish
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	AudioTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetAudioTimeout(Seconds) StreamInputPublish
	// Human-readable description of the input.
	// Example: This is a test input
	Comment() *string
	// Human-readable description of the input.
	// Example: This is a test input
	SetComment(string) StreamInputPublish
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	DenyIf() *string
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	SetDenyIf(string) StreamInputPublish
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	FramesTimeout() *int
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	SetFramesTimeout(int) StreamInputPublish
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	Headers() map[string]string
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	SetHeaders(map[string]string) StreamInputPublish
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	MaxRetryTimeout() *Seconds
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	SetMaxRetryTimeout(Seconds) StreamInputPublish
	// The minimum bitrate threshold, in kbit/s. The default value is 100 kbit/s.
	// Example: 150
	MinBitrate() *int
	// The minimum bitrate threshold, in kbit/s. The default value is 100 kbit/s.
	// Example: 150
	SetMinBitrate(int) StreamInputPublish
	// Skip input start if the stream has no clients.
	NoClientsReconnectDelay() *int
	// Skip input start if the stream has no clients.
	SetNoClientsReconnectDelay(int) StreamInputPublish
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	OutputAudio() *OutputAudio
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	SetOutputAudio(OutputAudio) StreamInputPublish
	// Deprecated field. Will be deleted at 24.11
	// Choose one of the listed video codecs at the start of the publication via WebRTC.
	// Example: av1
	PreferCodec() *WebrtcPreferVideoCodec
	// Deprecated field. Will be deleted at 24.11
	// Choose one of the listed video codecs at the start of the publication via WebRTC.
	// Example: av1
	SetPreferCodec(WebrtcPreferVideoCodec) StreamInputPublish
	// Prefer one of the listed video codecs at the start of the publication via WebRTC.
	// Example: av1
	PreferVideoCodec() *WebrtcPreferVideoCodec
	// Prefer one of the listed video codecs at the start of the publication via WebRTC.
	// Example: av1
	SetPreferVideoCodec(WebrtcPreferVideoCodec) StreamInputPublish
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	Priority() *int
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	SetPriority(int) StreamInputPublish
	// This option disables processing of SCTE-35 markers from SRT input stream.
	// Example: true
	Scte35() *bool
	// This option disables processing of SCTE-35 markers from SRT input stream.
	// Example: true
	SetScte35(bool) StreamInputPublish
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SourceTimeout() any
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SetSourceTimeout(any) StreamInputPublish
	// Detailed runtime information about the input.
	Stats() InputStats
	// Detailed runtime information about the input.
	SetStats(InputStats) StreamInputPublish
	// Deprecated field. Will be deleted at 25.03
	// This configuration is deprecated. Use `dvbocr` configuration field in stream.
	// This parameter allows to manage subtitles in an output stream.
	// Example: drop
	Subtitles() *StreamInputSrtPublishSpecificSubtitles
	// Deprecated field. Will be deleted at 25.03
	// This configuration is deprecated. Use `dvbocr` configuration field in stream.
	// This parameter allows to manage subtitles in an output stream.
	// Example: drop
	SetSubtitles(StreamInputSrtPublishSpecificSubtitles) StreamInputPublish
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	Timeout() *int
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	SetTimeout(int) StreamInputPublish
	// Choose the prefered transport of the publication via WebRTC: UDP or TCP.
	// Example: udp
	Transport() *WebrtcTransport
	// Choose the prefered transport of the publication via WebRTC: UDP or TCP.
	// Example: udp
	SetTransport(WebrtcTransport) StreamInputPublish
	// The publish:// URL used to indicate where this stream started in publish mode.
	// You can publish videos to Flussonic using the following URLs:
	// __RTSP__: rtsp://FLUSSONIC-IP/stream_name
	// __HTTP MPEG-TS__: http://FLUSSONIC-IP/stream_name/mpegts
	// __RTMP__: rtmp://flussonic-ip/published or rtmp://flussonic-ip/static/published
	// __WebRTC__: http://FLUSSONIC-IP/stream_name/whip
	// __SRT__: srt://FLUSSONIC-IP:SRT_PORT?streamid=#!::r=STREAM_NAME,m=publish
	// Format: input_url (input_url)
	// Pattern: ^publish://.*$
	// Example: publish://
	URL() InputURL
	// The publish:// URL used to indicate where this stream started in publish mode.
	// You can publish videos to Flussonic using the following URLs:
	// __RTSP__: rtsp://FLUSSONIC-IP/stream_name
	// __HTTP MPEG-TS__: http://FLUSSONIC-IP/stream_name/mpegts
	// __RTMP__: rtmp://flussonic-ip/published or rtmp://flussonic-ip/static/published
	// __WebRTC__: http://FLUSSONIC-IP/stream_name/whip
	// __SRT__: srt://FLUSSONIC-IP:SRT_PORT?streamid=#!::r=STREAM_NAME,m=publish
	// Format: input_url (input_url)
	// Pattern: ^publish://.*$
	// Example: publish://
	SetURL(InputURL) StreamInputPublish
	// User agent. Can be modified if a protocol allows it.
	UserAgent() *string
	// User agent. Can be modified if a protocol allows it.
	SetUserAgent(string) StreamInputPublish
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	Via() *AgentURL
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	SetVia(AgentURL) StreamInputPublish
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	VideoTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetVideoTimeout(Seconds) StreamInputPublish
	// Whether the adaptive bitrate mechanism is used for WebRTC publications.
	// Example: true
	WebrtcAbr() *bool
	// Whether the adaptive bitrate mechanism is used for WebRTC publications.
	// Example: true
	SetWebrtcAbr(bool) StreamInputPublish
}

type StreamInputRtsp interface {
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	AllowIf() *string
	// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
	// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
	// If no such file, the input is allowed.
	SetAllowIf(string) StreamInputRtsp
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	AudioTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetAudioTimeout(Seconds) StreamInputRtsp
	// Human-readable description of the input.
	// Example: This is a test input
	Comment() *string
	// Human-readable description of the input.
	// Example: This is a test input
	SetComment(string) StreamInputRtsp
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	DenyIf() *string
	// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
	// This option allows you to manage inputs without API requests.
	// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
	// The `/path/to/file` file contains only the digit `1`.
	// That means that the first input will not be used when you play the stream, so the second one will.
	// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
	// If no such file, the input is allowed.
	SetDenyIf(string) StreamInputRtsp
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	FramesTimeout() *int
	// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
	// This period of time must be smaller than `source_timeout`.
	// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
	// Example: 3
	SetFramesTimeout(int) StreamInputRtsp
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	Headers() map[string]string
	// Request headers as key-value pairs.
	// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
	SetHeaders(map[string]string) StreamInputRtsp
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	MaxRetryTimeout() *Seconds
	// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
	// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
	// Format: seconds (seconds)
	// Example: 30
	SetMaxRetryTimeout(Seconds) StreamInputRtsp
	// Skip input start if the stream has no clients.
	NoClientsReconnectDelay() *int
	// Skip input start if the stream has no clients.
	SetNoClientsReconnectDelay(int) StreamInputRtsp
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	OutputAudio() *OutputAudio
	// Enables transcoding of the published audio to another codec.
	// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
	SetOutputAudio(OutputAudio) StreamInputRtsp
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	Priority() *int
	// The priority that Media Server takes into account when switching to another source.
	// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
	// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
	// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
	// Example: 1
	SetPriority(int) StreamInputRtsp
	// Whether to force UDP to capture a video from RTSP cameras.
	RTP() *string
	// Whether to force UDP to capture a video from RTSP cameras.
	SetRTP(string) StreamInputRtsp
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SourceTimeout() any
	// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
	// Example: 20
	SetSourceTimeout(any) StreamInputRtsp
	// Detailed runtime information about the input.
	Stats() InputStats
	// Detailed runtime information about the input.
	SetStats(InputStats) StreamInputRtsp
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	Timeout() *int
	// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
	// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
	// Example: 10
	SetTimeout(int) StreamInputRtsp
	// URL to connect to the RTSP source and get the stream.
	// Format: input_url (input_url)
	// Pattern: ^(rtsp|rtsps|rtsp-udp|rtsp2)://.*$
	// Examples: rtsp-udp://remote.host.com/example, rtsp2://remote.host.com/example, rtsp://remote.host.com/example, rtsps://remote.host.com/example
	URL() InputURL
	// URL to connect to the RTSP source and get the stream.
	// Format: input_url (input_url)
	// Pattern: ^(rtsp|rtsps|rtsp-udp|rtsp2)://.*$
	// Examples: rtsp-udp://remote.host.com/example, rtsp2://remote.host.com/example, rtsp://remote.host.com/example, rtsps://remote.host.com/example
	SetURL(InputURL) StreamInputRtsp
	// User agent. Can be modified if a protocol allows it.
	UserAgent() *string
	// User agent. Can be modified if a protocol allows it.
	SetUserAgent(string) StreamInputRtsp
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	Via() *AgentURL
	// Agent ID. Used as a proxy to connect to the input server.
	// Format: agent_url (agent://ID identification for `via` configuration option)
	SetVia(AgentURL) StreamInputRtsp
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	VideoTimeout() *Seconds
	// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
	// Format: seconds (seconds)
	// Example: 20
	SetVideoTimeout(Seconds) StreamInputRtsp
	// Whether to wait for the full RTP time synchronization before the processing of frames from the RTSP camera.
	WaitRtcp() *bool
	// Whether to wait for the full RTP time synchronization before the processing of frames from the RTSP camera.
	SetWaitRtcp(bool) StreamInputRtsp
}

type StreamInputSrtPublishSpecific interface {
	// This option disables processing of SCTE-35 markers from SRT input stream.
	// Example: true
	Scte35() *bool
	// This option disables processing of SCTE-35 markers from SRT input stream.
	// Example: true
	SetScte35(bool) StreamInputSrtPublishSpecific
	// Deprecated field. Will be deleted at 25.03
	// This configuration is deprecated. Use `dvbocr` configuration field in stream.
	// This parameter allows to manage subtitles in an output stream.
	// Example: drop
	Subtitles() *StreamInputSrtPublishSpecificSubtitles
	// Deprecated field. Will be deleted at 25.03
	// This configuration is deprecated. Use `dvbocr` configuration field in stream.
	// This parameter allows to manage subtitles in an output stream.
	// Example: drop
	SetSubtitles(StreamInputSrtPublishSpecificSubtitles) StreamInputSrtPublishSpecific
}

// Title: WebRTC
type StreamInputWebrtcPublishSpecific interface {
	// The correction between the target bitrate (Receiver Estimated Maximum Bitrate, calculated in Flussonic) and browser bitrate, in kbit/s.
	// Flussonic sends the target bitrate to the browser from which the publication is carried out so that the browser adjusts the bitrate of the publication by this value.
	// The default value is 300 kbit/s.
	// Example: 200
	AbrCorrection() *int
	// The correction between the target bitrate (Receiver Estimated Maximum Bitrate, calculated in Flussonic) and browser bitrate, in kbit/s.
	// Flussonic sends the target bitrate to the browser from which the publication is carried out so that the browser adjusts the bitrate of the publication by this value.
	// The default value is 300 kbit/s.
	// Example: 200
	SetAbrCorrection(int) StreamInputWebrtcPublishSpecific
	// The number of cycles of bitrate auto-adjustment.
	// After the specified number of auto-adjustment cycles passes, Flussonic considers the bitrate to be optimal, and it is no longer analyzed.
	// By default, `abr_cycles`=5.
	// If `abr_cycles`=0, the adjustment process takes place all the time while the publication lasts.
	// Example: 3
	AbrCycles() *int
	// The number of cycles of bitrate auto-adjustment.
	// After the specified number of auto-adjustment cycles passes, Flussonic considers the bitrate to be optimal, and it is no longer analyzed.
	// By default, `abr_cycles`=5.
	// If `abr_cycles`=0, the adjustment process takes place all the time while the publication lasts.
	// Example: 3
	SetAbrCycles(int) StreamInputWebrtcPublishSpecific
	// Whether adaptive bitrate process is logged.
	// Example: 1
	AbrDebug() *int
	// Whether adaptive bitrate process is logged.
	// Example: 1
	SetAbrDebug(int) StreamInputWebrtcPublishSpecific
	// The lower limit of packet loss. When it is reached, Flussonic raises the bitrate.
	// That is, if packet loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup` percent.
	// Example: 2
	AbrLossLower() *float64
	// The lower limit of packet loss. When it is reached, Flussonic raises the bitrate.
	// That is, if packet loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup` percent.
	// Example: 2
	SetAbrLossLower(float64) StreamInputWebrtcPublishSpecific
	// The upper limit of packet loss. When it is reached, Flussonic reduces the bitrate.
	// That is, if packet loss is greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.
	// Example: 10
	AbrLossUpper() *float64
	// The upper limit of packet loss. When it is reached, Flussonic reduces the bitrate.
	// That is, if packet loss is greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.
	// Example: 10
	SetAbrLossUpper(float64) StreamInputWebrtcPublishSpecific
	// Maximum bitrate for adjustment process, in kbit/s.
	// Flussonic will keep the publication bitrate equal or below of the specified value.
	// Example: 1000
	AbrMaxBitrate() *int
	// Maximum bitrate for adjustment process, in kbit/s.
	// Flussonic will keep the publication bitrate equal or below of the specified value.
	// Example: 1000
	SetAbrMaxBitrate(int) StreamInputWebrtcPublishSpecific
	// The algorithm for determining the need to change the bitrate of the published stream and for calculating the target bitrate.
	// Two options are possible:
	// * `abr_mode=0` - This mode takes into account the packet losses, target bitrate, browser bitrate and the number of auto-adjustment cycles.
	// * `abr_mode=1` - This mode considers only packet losses and target bitrate.
	// Example: 1
	AbrMode() *int
	// The algorithm for determining the need to change the bitrate of the published stream and for calculating the target bitrate.
	// Two options are possible:
	// * `abr_mode=0` - This mode takes into account the packet losses, target bitrate, browser bitrate and the number of auto-adjustment cycles.
	// * `abr_mode=1` - This mode considers only packet losses and target bitrate.
	// Example: 1
	SetAbrMode(int) StreamInputWebrtcPublishSpecific
	// A step of reducing the bitrate to the minimum.
	// If packet losses are greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.
	AbrStepdown() *float64
	// A step of reducing the bitrate to the minimum.
	// If packet losses are greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.
	SetAbrStepdown(float64) StreamInputWebrtcPublishSpecific
	// Increment step for raising the bitrate to the maximum, in percent. The default step is 30%.
	// If the loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup percent`.
	AbrStepup() *int
	// Increment step for raising the bitrate to the maximum, in percent. The default step is 30%.
	// If the loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup percent`.
	SetAbrStepup(int) StreamInputWebrtcPublishSpecific
	// The minimum bitrate threshold, in kbit/s. The default value is 100 kbit/s.
	// Example: 150
	MinBitrate() *int
	// The minimum bitrate threshold, in kbit/s. The default value is 100 kbit/s.
	// Example: 150
	SetMinBitrate(int) StreamInputWebrtcPublishSpecific
	// Deprecated field. Will be deleted at 24.11
	// Choose one of the listed video codecs at the start of the publication via WebRTC.
	// Example: av1
	PreferCodec() *WebrtcPreferVideoCodec
	// Deprecated field. Will be deleted at 24.11
	// Choose one of the listed video codecs at the start of the publication via WebRTC.
	// Example: av1
	SetPreferCodec(WebrtcPreferVideoCodec) StreamInputWebrtcPublishSpecific
	// Prefer one of the listed video codecs at the start of the publication via WebRTC.
	// Example: av1
	PreferVideoCodec() *WebrtcPreferVideoCodec
	// Prefer one of the listed video codecs at the start of the publication via WebRTC.
	// Example: av1
	SetPreferVideoCodec(WebrtcPreferVideoCodec) StreamInputWebrtcPublishSpecific
	// Choose the prefered transport of the publication via WebRTC: UDP or TCP.
	// Example: udp
	Transport() *WebrtcTransport
	// Choose the prefered transport of the publication via WebRTC: UDP or TCP.
	// Example: udp
	SetTransport(WebrtcTransport) StreamInputWebrtcPublishSpecific
	// Whether the adaptive bitrate mechanism is used for WebRTC publications.
	// Example: true
	WebrtcAbr() *bool
	// Whether the adaptive bitrate mechanism is used for WebRTC publications.
	// Example: true
	SetWebrtcAbr(bool) StreamInputWebrtcPublishSpecific
}

type StreamOnvifConfig interface {
	// Shows if PTZ control should be enabled for the camera.
	// The PTZ function must be supported and enabled on the ONVIF camera
	// in order to be able to actually control PTZ from Watcher or your UI.
	Ptz() *bool
	// Shows if PTZ control should be enabled for the camera.
	// The PTZ function must be supported and enabled on the ONVIF camera
	// in order to be able to actually control PTZ from Watcher or your UI.
	SetPtz(bool) StreamOnvifConfig
}

type StreamPathItem interface {
	// ID of the path item the stream is included in.
	ID() *int
	// ID of the path item the stream is included in.
	SetID(int) StreamPathItem
	// Title of path item the stream is included in.
	Title() *string
	// Title of path item the stream is included in.
	SetTitle(string) StreamPathItem
}

type StreamPermissionsAccess interface {
	// Whether the user can control PTZ cameras
	CanUsePtz() *bool
	// Whether the user can control PTZ cameras
	SetCanUsePtz(bool) StreamPermissionsAccess
	// Whether the user can view the stream
	CanView() *bool
	// Whether the user can view the stream
	SetCanView(bool) StreamPermissionsAccess
	// Whether the user can view the stream archive
	CanViewDvr() *bool
	// Whether the user can view the stream archive
	SetCanViewDvr(bool) StreamPermissionsAccess
	// Maximum archive depth in seconds that user can access
	DvrDepthLimit() *int
	// Maximum archive depth in seconds that user can access
	SetDvrDepthLimit(int) StreamPermissionsAccess
}

type StreamPreset interface {
	// Preset identificator.
	ID() *int
	// Preset identificator.
	SetID(int) StreamPreset
	// Shows if the preset is adjustable.
	// ```is_adjustable``` is needed for a situation where presets are managed by external billing.
	// If ```is_adjustable: true``` user can change camera settings meanwhile using this preset.
	// If ```is_adjustable: false``` user can not change camera settings meanwhile using this preset.
	// If the camera has a non-adjustable presets, the DVR and analytics parameters from PUT requests will not be applied.
	// In this case, either make the preset adjustable, or change the preset itself to achieve the required configuration.
	// Example: true
	IsAdjustable() *bool
	// Shows if the preset is adjustable.
	// ```is_adjustable``` is needed for a situation where presets are managed by external billing.
	// If ```is_adjustable: true``` user can change camera settings meanwhile using this preset.
	// If ```is_adjustable: false``` user can not change camera settings meanwhile using this preset.
	// If the camera has a non-adjustable presets, the DVR and analytics parameters from PUT requests will not be applied.
	// In this case, either make the preset adjustable, or change the preset itself to achieve the required configuration.
	// Example: true
	SetIsAdjustable(bool) StreamPreset
	// Human-readable name of the preset.
	// Example: Example preset name
	Title() *string
	// Human-readable name of the preset.
	// Example: Example preset name
	SetTitle(string) StreamPreset
}

type StreamStats interface {
	// The status of the Agent serving the stream.
	AgentStatus() *string
	// The status of the Agent serving the stream.
	SetAgentStatus(string) StreamStats
	// Becomes `false` when `ts_delay` > 12000 (= 12 seconds)
	// Example: true
	Alive() *bool
	// Becomes `false` when `ts_delay` > 12000 (= 12 seconds)
	// Example: true
	SetAlive(bool) StreamStats
	// Stream bitrate.
	// Format: speed (speed)
	// Example: 186
	Bitrate() *Speed
	// Stream bitrate.
	// Format: speed (speed)
	// Example: 186
	SetBitrate(Speed) StreamStats
	// The amount of stream data sent to the clients.
	// Format: bytes (bytes)
	// Example: 0
	BytesOut() *Bytes
	// The amount of stream data sent to the clients.
	// Format: bytes (bytes)
	// Example: 0
	SetBytesOut(Bytes) StreamStats
	// The identifier of the Agent that is currently serving the stream.
	// Format: agent_id (agent_id)
	CurrentAgentID() *AgentID
	// The identifier of the Agent that is currently serving the stream.
	// Format: agent_id (agent_id)
	SetCurrentAgentID(AgentID) StreamStats
	// The information about the recorded DVR archive.
	DvrInfo() DvrInfo
	// The information about the recorded DVR archive.
	SetDvrInfo(DvrInfo) StreamStats
	// The time when the last time frame was sent to the stream output (in UTC).
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.636383841974e+12
	LastDtsAt() *UtcMs
	// The time when the last time frame was sent to the stream output (in UTC).
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.636383841974e+12
	SetLastDtsAt(UtcMs) StreamStats
	// The time period in seconds during which the stream is being captured.
	// Can be calculated from `opened_at`
	// Format: milliseconds (milliseconds)
	// Example: 71977
	Lifetime() *Milliseconds
	// The time period in seconds during which the stream is being captured.
	// Can be calculated from `opened_at`
	// Format: milliseconds (milliseconds)
	// Example: 71977
	SetLifetime(Milliseconds) StreamStats
	// Technical information about the output media content.
	MediaInfo() MediaInfo
	// Technical information about the output media content.
	SetMediaInfo(MediaInfo) StreamStats
	// Deprecated field. Will be deleted at 25.04
	// The number of clients receiving the stream.
	// Use play.play_opened_sessions instead
	// Format: client_count (client_count)
	// Example: 3
	OnlineClients() *ClientCount
	// Deprecated field. Will be deleted at 25.04
	// The number of clients receiving the stream.
	// Use play.play_opened_sessions instead
	// Format: client_count (client_count)
	// Example: 3
	SetOnlineClients(ClientCount) StreamStats
	// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
	// Example: onetime_token
	PlaybackToken() *string
	// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
	// Example: onetime_token
	SetPlaybackToken(string) StreamStats
	// Publish endpoint. Used to publish the stream.
	PublishEndpoint() *string
	// Publish endpoint. Used to publish the stream.
	SetPublishEndpoint(string) StreamStats
	// Indicates the status of the stream.
	Status() *StreamStatus
	// Indicates the status of the stream.
	SetStatus(StreamStatus) StreamStats
	// HTTP(s) URL that can be used for streaming API of this stream
	StreamingEndpoint() *string
	// HTTP(s) URL that can be used for streaming API of this stream
	SetStreamingEndpoint(string) StreamStats
	// The time period during which no frames were received from the stream's input.
	// Format: ticks (ticks)
	// Example: 1284
	TSDelay() *Ticks
	// The time period during which no frames were received from the stream's input.
	// Format: ticks (ticks)
	// Example: 1284
	SetTSDelay(Ticks) StreamStats
}

type StreamUserPermission interface {
	Permissions() StreamUserPermissionPermissions
	SetPermissions(StreamUserPermissionPermissions) StreamUserPermission
	User() StreamUserPermissionUser
	SetUser(StreamUserPermissionUser) StreamUserPermission
}

type StreamUserPermissionPermissions interface {
	// Whether the user can control PTZ cameras
	CanUsePtz() *bool
	// Whether the user can control PTZ cameras
	SetCanUsePtz(bool) StreamUserPermissionPermissions
	// Whether the user can view the stream
	CanView() *bool
	// Whether the user can view the stream
	SetCanView(bool) StreamUserPermissionPermissions
	// Whether the user can view the stream archive
	CanViewDvr() *bool
	// Whether the user can view the stream archive
	SetCanViewDvr(bool) StreamUserPermissionPermissions
	// Maximum archive depth in seconds that user can access
	DvrDepthLimit() *int
	// Maximum archive depth in seconds that user can access
	SetDvrDepthLimit(int) StreamUserPermissionPermissions
}

type StreamUserPermissionUser interface {
	// User identifier
	ID() *int
	// User identifier
	SetID(int) StreamUserPermissionUser
}

type StreamUsersPermissionsList interface {
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	EstimatedCount() *int
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	SetEstimatedCount(int) StreamUsersPermissionsList
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	Next() *string
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	SetNext(string) StreamUsersPermissionsList
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	Prev() *string
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	SetPrev(string) StreamUsersPermissionsList
	// An object with a list of different timings measured during this API call.
	Timing() any
	// An object with a list of different timings measured during this API call.
	SetTiming(any) StreamUsersPermissionsList
	// List of users
	UsersPermissions() []StreamUserPermission
	// List of users
	SetUsersPermissions([]StreamUserPermission) StreamUsersPermissionsList
	// Collection returns the collection items
	Collection() []StreamUserPermission
}

type StreamsImportResponse interface {
	// The number of streams created
	Created() *int
	// The number of streams created
	SetCreated(int) StreamsImportResponse
	// The number of streams updated
	Updated() *int
	// The number of streams updated
	SetUpdated(int) StreamsImportResponse
}

type StreamsList interface {
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	EstimatedCount() *int
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	SetEstimatedCount(int) StreamsList
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	Next() *string
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	SetNext(string) StreamsList
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	Prev() *string
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	SetPrev(string) StreamsList
	// List of fetched streams according to the query parameters.
	Streams() []StreamConfig
	// List of fetched streams according to the query parameters.
	SetStreams([]StreamConfig) StreamsList
	// An object with a list of different timings measured during this API call.
	Timing() any
	// An object with a list of different timings measured during this API call.
	SetTiming(any) StreamsList
	// Collection returns the collection items
	Collection() []StreamConfig
}

// Array of streams with settings
type StreamsMultieditConfig interface {
	// List of streams with their settings
	Streams() []StreamConfigMultiedit
	// List of streams with their settings
	SetStreams([]StreamConfigMultiedit) StreamsMultieditConfig
}

type Subscription interface {
	// Choosing which type of events to subscribe to
	EventTypes() SubscriptionRequestEventTypes
	// Choosing which type of events to subscribe to
	SetEventTypes(SubscriptionRequestEventTypes) Subscription
	// notification frequency in seconds
	// Format: seconds (seconds)
	NotificationFrequency() *Seconds
	// notification frequency in seconds
	// Format: seconds (seconds)
	SetNotificationFrequency(Seconds) Subscription
	// Type of notification
	NotificationType() string
	// Type of notification
	SetNotificationType(string) Subscription
	// stream identificator
	StreamName() string
	// stream identificator
	SetStreamName(string) Subscription
}

// Required: event_types, notification_type, stream_name
type SubscriptionRequest interface {
	// Choosing which type of events to subscribe to
	EventTypes() SubscriptionRequestEventTypes
	// Choosing which type of events to subscribe to
	SetEventTypes(SubscriptionRequestEventTypes) SubscriptionRequest
	// Type of notification
	NotificationType() string
	// Type of notification
	SetNotificationType(string) SubscriptionRequest
	// stream identificator
	StreamName() string
	// stream identificator
	SetStreamName(string) SubscriptionRequest
}

// Choosing which type of events to subscribe to
type SubscriptionRequestEventTypes interface {
	// Face episode
	// Example: true
	EpisodeFace() *bool
	// Face episode
	// Example: true
	SetEpisodeFace(bool) SubscriptionRequestEventTypes
	// Generic episode
	// Example: true
	EpisodeGeneric() *bool
	// Generic episode
	// Example: true
	SetEpisodeGeneric(bool) SubscriptionRequestEventTypes
	// Vehicle episode
	// Example: false
	EpisodeVehicle() *bool
	// Vehicle episode
	// Example: false
	SetEpisodeVehicle(bool) SubscriptionRequestEventTypes
	// Get notified when a stream goes offline
	// Example: true
	StreamDead() *bool
	// Get notified when a stream goes offline
	// Example: true
	SetStreamDead(bool) SubscriptionRequestEventTypes
}

type ThumbnailsSpec interface {
	// Whether to generate thumbnails from the video stream.
	Enabled() any
	// Whether to generate thumbnails from the video stream.
	SetEnabled(any) ThumbnailsSpec
}

type TrackInfo interface {
	// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
	// The higher FPS is, the smoother the video playback is.
	// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
	AvgFPS() *float64
	// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
	// The higher FPS is, the smoother the video playback is.
	// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
	SetAvgFPS(float64) TrackInfo
	// Average GOP size (expressed in number of frames) of the last 1000-2000 frames.
	// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
	// If this value is floating, this means that your transcoder is working in flexible GOP size mode and some players may have problems.
	// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
	// Example: 25
	AvgGop() *int
	// Average GOP size (expressed in number of frames) of the last 1000-2000 frames.
	// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
	// If this value is floating, this means that your transcoder is working in flexible GOP size mode and some players may have problems.
	// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
	// Example: 25
	SetAvgGop(int) TrackInfo
	// Bandwidth necessary to transfer this track.
	// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
	// Format: speed (speed)
	// Example: 2600
	Bandwidth() *Speed
	// Bandwidth necessary to transfer this track.
	// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
	// Format: speed (speed)
	// Example: 2600
	SetBandwidth(Speed) TrackInfo
	// Average number of B-frames in a GOP. B-frames contain links to keyframes and P-frames before and after themselves.
	// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
	// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
	// Example: 3
	Bframes() *int
	// Average number of B-frames in a GOP. B-frames contain links to keyframes and P-frames before and after themselves.
	// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
	// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
	// Example: 3
	SetBframes(int) TrackInfo
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	Bitrate() *Speed
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	SetBitrate(Speed) TrackInfo
	// The number of audio channels.
	// Example: 2
	Channels() *int
	// The number of audio channels.
	// Example: 2
	SetChannels(int) TrackInfo
	// Parameters of closed captions.
	ClosedCaptions() []ClosedCaptions
	// Parameters of closed captions.
	SetClosedCaptions([]ClosedCaptions) TrackInfo
	// Codec of the track. Different codecs do **not** get the same track.
	// Example: h264
	Codec() *FrameCodec
	// Codec of the track. Different codecs do **not** get the same track.
	// Example: h264
	SetCodec(FrameCodec) TrackInfo
	// Content of the track (audio, video, or text).
	Content() FrameContent
	// Content of the track (audio, video, or text).
	SetContent(FrameContent) TrackInfo
	// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
	// Higher frame rates capture more images per second, which makes for smoother video.
	// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
	// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
	// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
	// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
	// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
	FPS() *float64
	// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
	// Higher frame rates capture more images per second, which makes for smoother video.
	// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
	// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
	// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
	// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
	// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
	SetFPS(float64) TrackInfo
	// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
	// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
	// However, sometimes (when the connection is broken) video breakups are possible.
	// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
	// This situation is considered as a frame gap and is handled differently across different protocols.
	// Format: ticks (ticks)
	FrameDuration() *Ticks
	// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
	// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
	// However, sometimes (when the connection is broken) video breakups are possible.
	// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
	// This situation is considered as a frame gap and is handled differently across different protocols.
	// Format: ticks (ticks)
	SetFrameDuration(Ticks) TrackInfo
	// The number of frames in a group of pictures (GOP).
	// The encoder will create all GOPs of an exactly identical size - as specified in this option.
	// A bigger GOP can be good for video compression but it can result in big zap-time (the duration of time between changing a channel and displaying a new channel.)
	GopSize() *int
	// The number of frames in a group of pictures (GOP).
	// The encoder will create all GOPs of an exactly identical size - as specified in this option.
	// A bigger GOP can be good for video compression but it can result in big zap-time (the duration of time between changing a channel and displaying a new channel.)
	SetGopSize(int) TrackInfo
	// The picture height in pixels on the display where it will be played by a player.
	// If you need to insert a web-player into a web page, use this value for choosing the player size.
	// Format: pixels (pixels)
	Height() *Pixels
	// The picture height in pixels on the display where it will be played by a player.
	// If you need to insert a web-player into a web page, use this value for choosing the player size.
	// Format: pixels (pixels)
	SetHeight(Pixels) TrackInfo
	// Indicates if progressive scanning method is used for all frames of the track
	IsProgressive() *bool
	// Indicates if progressive scanning method is used for all frames of the track
	SetIsProgressive(bool) TrackInfo
	// Language value of the track, if applicable.
	// Example: eng
	Language() *string
	// Language value of the track, if applicable.
	// Example: eng
	SetLanguage(string) TrackInfo
	// Last GOP size (expressed in number of frames).
	// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
	// If this value is floating, this means that your transcoder is working in a flexible GOP size mode and some players may have problems.
	// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
	// Example: 28
	LastGop() *int
	// Last GOP size (expressed in number of frames).
	// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
	// If this value is floating, this means that your transcoder is working in a flexible GOP size mode and some players may have problems.
	// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
	// Example: 28
	SetLastGop(int) TrackInfo
	// The size of the length field for H264 bitstream without start codes.
	LengthSize() *int
	// The size of the length field for H264 bitstream without start codes.
	SetLengthSize(int) TrackInfo
	// A set of constraints that indicate a degree of required decoder performance.
	// This parameter is used for compatibility with old devices.
	Level() *string
	// A set of constraints that indicate a degree of required decoder performance.
	// This parameter is used for compatibility with old devices.
	SetLevel(string) TrackInfo
	// The number of I-frames to be used for encoding.
	NumRefsFrames() *int
	// The number of I-frames to be used for encoding.
	SetNumRefsFrames(int) TrackInfo
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	Pid() *int
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	SetPid(int) TrackInfo
	// The color model of the video.
	PixFmt() *FrameVideoPixFmt
	// The color model of the video.
	SetPixFmt(FrameVideoPixFmt) TrackInfo
	// The picture width in pixels of the original video before transcoding.
	// Format: pixels (pixels)
	PixelHeight() *Pixels
	// The picture width in pixels of the original video before transcoding.
	// Format: pixels (pixels)
	SetPixelHeight(Pixels) TrackInfo
	// The picture width in pixels of the original video before transcoding.
	// Format: pixels (pixels)
	PixelWidth() *Pixels
	// The picture width in pixels of the original video before transcoding.
	// Format: pixels (pixels)
	SetPixelWidth(Pixels) TrackInfo
	// A specific codec-dependent profile of the output video.
	// The profile allows to assume if the track can be played on a particular device.
	Profile() *string
	// A specific codec-dependent profile of the output video.
	// The profile allows to assume if the track can be played on a particular device.
	SetProfile(string) TrackInfo
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// Example: 8000
	SampleRate() *int
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// Example: 8000
	SetSampleRate(int) TrackInfo
	// The second number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
	// SAR is used for creating non-anamorphic video from anamorphic video.
	SarHeight() *int
	// The second number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
	// SAR is used for creating non-anamorphic video from anamorphic video.
	SetSarHeight(int) TrackInfo
	// The first number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
	// SAR is used for creating non-anamorphic video from anamorphic video.
	SarWidth() *int
	// The first number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
	// SAR is used for creating non-anamorphic video from anamorphic video.
	SetSarWidth(int) TrackInfo
	// Human-readable localized title of the track.
	// Example: Video1
	Title() *string
	// Human-readable localized title of the track.
	// Example: Video1
	SetTitle(string) TrackInfo
	// Track identifier assigned by Flussonic.
	// Example: v1
	TrackID() any
	// Track identifier assigned by Flussonic.
	// Example: v1
	SetTrackID(any) TrackInfo
	// The picture width in pixels on the display where it will be played by a player.
	// If you need to insert a web-player into a web page, use this value for choosing the player size.
	// Format: pixels (pixels)
	Width() *Pixels
	// The picture width in pixels on the display where it will be played by a player.
	// If you need to insert a web-player into a web page, use this value for choosing the player size.
	// Format: pixels (pixels)
	SetWidth(Pixels) TrackInfo
}

type TrackInfoApplication interface {
	// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
	// The higher FPS is, the smoother the video playback is.
	// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
	AvgFPS() *float64
	// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
	// The higher FPS is, the smoother the video playback is.
	// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
	SetAvgFPS(float64) TrackInfoApplication
	// Bandwidth necessary to transfer this track.
	// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
	// Format: speed (speed)
	// Example: 2600
	Bandwidth() *Speed
	// Bandwidth necessary to transfer this track.
	// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
	// Format: speed (speed)
	// Example: 2600
	SetBandwidth(Speed) TrackInfoApplication
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	Bitrate() *Speed
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	SetBitrate(Speed) TrackInfoApplication
	// Codec of the track. Different codecs do **not** get the same track.
	// Example: h264
	Codec() *FrameCodec
	// Codec of the track. Different codecs do **not** get the same track.
	// Example: h264
	SetCodec(FrameCodec) TrackInfoApplication
	// Content of the track (audio, video, or text).
	Content() FrameContent
	// Content of the track (audio, video, or text).
	SetContent(FrameContent) TrackInfoApplication
	// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
	// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
	// However, sometimes (when the connection is broken) video breakups are possible.
	// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
	// This situation is considered as a frame gap and is handled differently across different protocols.
	// Format: ticks (ticks)
	FrameDuration() *Ticks
	// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
	// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
	// However, sometimes (when the connection is broken) video breakups are possible.
	// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
	// This situation is considered as a frame gap and is handled differently across different protocols.
	// Format: ticks (ticks)
	SetFrameDuration(Ticks) TrackInfoApplication
	// Language value of the track, if applicable.
	// Example: eng
	Language() *string
	// Language value of the track, if applicable.
	// Example: eng
	SetLanguage(string) TrackInfoApplication
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	Pid() *int
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	SetPid(int) TrackInfoApplication
	// Human-readable localized title of the track.
	// Example: Video1
	Title() *string
	// Human-readable localized title of the track.
	// Example: Video1
	SetTitle(string) TrackInfoApplication
	// Track identifier assigned by Flussonic.
	// Example: v1
	TrackID() any
	// Track identifier assigned by Flussonic.
	// Example: v1
	SetTrackID(any) TrackInfoApplication
}

type TrackInfoApplicationSpecific interface {
	// Language value of the track, if applicable.
	// Example: eng
	Language() *string
	// Language value of the track, if applicable.
	// Example: eng
	SetLanguage(string) TrackInfoApplicationSpecific
}

type TrackInfoAudio interface {
	// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
	// The higher FPS is, the smoother the video playback is.
	// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
	AvgFPS() *float64
	// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
	// The higher FPS is, the smoother the video playback is.
	// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
	SetAvgFPS(float64) TrackInfoAudio
	// Bandwidth necessary to transfer this track.
	// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
	// Format: speed (speed)
	// Example: 2600
	Bandwidth() *Speed
	// Bandwidth necessary to transfer this track.
	// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
	// Format: speed (speed)
	// Example: 2600
	SetBandwidth(Speed) TrackInfoAudio
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	Bitrate() *Speed
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	SetBitrate(Speed) TrackInfoAudio
	// The number of audio channels.
	// Example: 2
	Channels() *int
	// The number of audio channels.
	// Example: 2
	SetChannels(int) TrackInfoAudio
	// Codec of the track. Different codecs do **not** get the same track.
	// Example: h264
	Codec() *FrameCodec
	// Codec of the track. Different codecs do **not** get the same track.
	// Example: h264
	SetCodec(FrameCodec) TrackInfoAudio
	// Content of the track (audio, video, or text).
	Content() FrameContent
	// Content of the track (audio, video, or text).
	SetContent(FrameContent) TrackInfoAudio
	// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
	// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
	// However, sometimes (when the connection is broken) video breakups are possible.
	// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
	// This situation is considered as a frame gap and is handled differently across different protocols.
	// Format: ticks (ticks)
	FrameDuration() *Ticks
	// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
	// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
	// However, sometimes (when the connection is broken) video breakups are possible.
	// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
	// This situation is considered as a frame gap and is handled differently across different protocols.
	// Format: ticks (ticks)
	SetFrameDuration(Ticks) TrackInfoAudio
	// Language value of the track, if applicable.
	// Example: eng
	Language() *string
	// Language value of the track, if applicable.
	// Example: eng
	SetLanguage(string) TrackInfoAudio
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	Pid() *int
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	SetPid(int) TrackInfoAudio
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// Example: 8000
	SampleRate() *int
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// Example: 8000
	SetSampleRate(int) TrackInfoAudio
	// Human-readable localized title of the track.
	// Example: Video1
	Title() *string
	// Human-readable localized title of the track.
	// Example: Video1
	SetTitle(string) TrackInfoAudio
	// Track identifier assigned by Flussonic.
	// Example: v1
	TrackID() any
	// Track identifier assigned by Flussonic.
	// Example: v1
	SetTrackID(any) TrackInfoAudio
}

type TrackInfoAudioSpecific interface {
	// The number of audio channels.
	// Example: 2
	Channels() *int
	// The number of audio channels.
	// Example: 2
	SetChannels(int) TrackInfoAudioSpecific
	// Language value of the track, if applicable.
	// Example: eng
	Language() *string
	// Language value of the track, if applicable.
	// Example: eng
	SetLanguage(string) TrackInfoAudioSpecific
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// Example: 8000
	SampleRate() *int
	// Sample rate, in hertz -
	// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
	// Example: 8000
	SetSampleRate(int) TrackInfoAudioSpecific
}

type TrackInfoBase interface {
	// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
	// The higher FPS is, the smoother the video playback is.
	// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
	AvgFPS() *float64
	// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
	// The higher FPS is, the smoother the video playback is.
	// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
	SetAvgFPS(float64) TrackInfoBase
	// Bandwidth necessary to transfer this track.
	// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
	// Format: speed (speed)
	// Example: 2600
	Bandwidth() *Speed
	// Bandwidth necessary to transfer this track.
	// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
	// Format: speed (speed)
	// Example: 2600
	SetBandwidth(Speed) TrackInfoBase
	// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
	// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
	// However, sometimes (when the connection is broken) video breakups are possible.
	// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
	// This situation is considered as a frame gap and is handled differently across different protocols.
	// Format: ticks (ticks)
	FrameDuration() *Ticks
	// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
	// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
	// However, sometimes (when the connection is broken) video breakups are possible.
	// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
	// This situation is considered as a frame gap and is handled differently across different protocols.
	// Format: ticks (ticks)
	SetFrameDuration(Ticks) TrackInfoBase
	// Track identifier assigned by Flussonic.
	// Example: v1
	TrackID() any
	// Track identifier assigned by Flussonic.
	// Example: v1
	SetTrackID(any) TrackInfoBase
}

// Required: content
type TrackInfoBaseConfigurable interface {
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	Bitrate() *Speed
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	SetBitrate(Speed) TrackInfoBaseConfigurable
	// Content of the track (audio, video, or text).
	Content() FrameContent
	// Content of the track (audio, video, or text).
	SetContent(FrameContent) TrackInfoBaseConfigurable
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	Pid() *int
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	SetPid(int) TrackInfoBaseConfigurable
	// Human-readable localized title of the track.
	// Example: Video1
	Title() *string
	// Human-readable localized title of the track.
	// Example: Video1
	SetTitle(string) TrackInfoBaseConfigurable
}

type TrackInfoMetadata interface {
	// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
	// The higher FPS is, the smoother the video playback is.
	// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
	AvgFPS() *float64
	// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
	// The higher FPS is, the smoother the video playback is.
	// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
	SetAvgFPS(float64) TrackInfoMetadata
	// Bandwidth necessary to transfer this track.
	// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
	// Format: speed (speed)
	// Example: 2600
	Bandwidth() *Speed
	// Bandwidth necessary to transfer this track.
	// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
	// Format: speed (speed)
	// Example: 2600
	SetBandwidth(Speed) TrackInfoMetadata
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	Bitrate() *Speed
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	SetBitrate(Speed) TrackInfoMetadata
	// Codec of the track. Different codecs do **not** get the same track.
	// Example: h264
	Codec() *FrameCodec
	// Codec of the track. Different codecs do **not** get the same track.
	// Example: h264
	SetCodec(FrameCodec) TrackInfoMetadata
	// Content of the track (audio, video, or text).
	Content() FrameContent
	// Content of the track (audio, video, or text).
	SetContent(FrameContent) TrackInfoMetadata
	// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
	// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
	// However, sometimes (when the connection is broken) video breakups are possible.
	// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
	// This situation is considered as a frame gap and is handled differently across different protocols.
	// Format: ticks (ticks)
	FrameDuration() *Ticks
	// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
	// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
	// However, sometimes (when the connection is broken) video breakups are possible.
	// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
	// This situation is considered as a frame gap and is handled differently across different protocols.
	// Format: ticks (ticks)
	SetFrameDuration(Ticks) TrackInfoMetadata
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	Pid() *int
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	SetPid(int) TrackInfoMetadata
	// Human-readable localized title of the track.
	// Example: Video1
	Title() *string
	// Human-readable localized title of the track.
	// Example: Video1
	SetTitle(string) TrackInfoMetadata
	// Track identifier assigned by Flussonic.
	// Example: v1
	TrackID() any
	// Track identifier assigned by Flussonic.
	// Example: v1
	SetTrackID(any) TrackInfoMetadata
}

type TrackInfoText interface {
	// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
	// The higher FPS is, the smoother the video playback is.
	// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
	AvgFPS() *float64
	// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
	// The higher FPS is, the smoother the video playback is.
	// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
	SetAvgFPS(float64) TrackInfoText
	// Bandwidth necessary to transfer this track.
	// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
	// Format: speed (speed)
	// Example: 2600
	Bandwidth() *Speed
	// Bandwidth necessary to transfer this track.
	// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
	// Format: speed (speed)
	// Example: 2600
	SetBandwidth(Speed) TrackInfoText
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	Bitrate() *Speed
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	SetBitrate(Speed) TrackInfoText
	// Codec of the track. Different codecs do **not** get the same track.
	// Example: h264
	Codec() *FrameCodec
	// Codec of the track. Different codecs do **not** get the same track.
	// Example: h264
	SetCodec(FrameCodec) TrackInfoText
	// Content of the track (audio, video, or text).
	Content() FrameContent
	// Content of the track (audio, video, or text).
	SetContent(FrameContent) TrackInfoText
	// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
	// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
	// However, sometimes (when the connection is broken) video breakups are possible.
	// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
	// This situation is considered as a frame gap and is handled differently across different protocols.
	// Format: ticks (ticks)
	FrameDuration() *Ticks
	// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
	// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
	// However, sometimes (when the connection is broken) video breakups are possible.
	// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
	// This situation is considered as a frame gap and is handled differently across different protocols.
	// Format: ticks (ticks)
	SetFrameDuration(Ticks) TrackInfoText
	// Language value of the track, if applicable.
	// Example: eng
	Language() *string
	// Language value of the track, if applicable.
	// Example: eng
	SetLanguage(string) TrackInfoText
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	Pid() *int
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	SetPid(int) TrackInfoText
	// Human-readable localized title of the track.
	// Example: Video1
	Title() *string
	// Human-readable localized title of the track.
	// Example: Video1
	SetTitle(string) TrackInfoText
	// Track identifier assigned by Flussonic.
	// Example: v1
	TrackID() any
	// Track identifier assigned by Flussonic.
	// Example: v1
	SetTrackID(any) TrackInfoText
}

type TrackInfoTextSpecific interface {
	// Language value of the track, if applicable.
	// Example: eng
	Language() *string
	// Language value of the track, if applicable.
	// Example: eng
	SetLanguage(string) TrackInfoTextSpecific
}

type TrackInfoVideo interface {
	// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
	// The higher FPS is, the smoother the video playback is.
	// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
	AvgFPS() *float64
	// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
	// The higher FPS is, the smoother the video playback is.
	// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
	SetAvgFPS(float64) TrackInfoVideo
	// Average GOP size (expressed in number of frames) of the last 1000-2000 frames.
	// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
	// If this value is floating, this means that your transcoder is working in flexible GOP size mode and some players may have problems.
	// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
	// Example: 25
	AvgGop() *int
	// Average GOP size (expressed in number of frames) of the last 1000-2000 frames.
	// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
	// If this value is floating, this means that your transcoder is working in flexible GOP size mode and some players may have problems.
	// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
	// Example: 25
	SetAvgGop(int) TrackInfoVideo
	// Bandwidth necessary to transfer this track.
	// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
	// Format: speed (speed)
	// Example: 2600
	Bandwidth() *Speed
	// Bandwidth necessary to transfer this track.
	// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
	// Format: speed (speed)
	// Example: 2600
	SetBandwidth(Speed) TrackInfoVideo
	// Average number of B-frames in a GOP. B-frames contain links to keyframes and P-frames before and after themselves.
	// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
	// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
	// Example: 3
	Bframes() *int
	// Average number of B-frames in a GOP. B-frames contain links to keyframes and P-frames before and after themselves.
	// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
	// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
	// Example: 3
	SetBframes(int) TrackInfoVideo
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	Bitrate() *Speed
	// Bitrate of the track in kbit/s.
	// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
	// this field sets the desired transport bandwidth instead of raw video bitrate.
	// Format: speed (speed)
	// Example: 2543
	SetBitrate(Speed) TrackInfoVideo
	// Parameters of closed captions.
	ClosedCaptions() []ClosedCaptions
	// Parameters of closed captions.
	SetClosedCaptions([]ClosedCaptions) TrackInfoVideo
	// Codec of the track. Different codecs do **not** get the same track.
	// Example: h264
	Codec() *FrameCodec
	// Codec of the track. Different codecs do **not** get the same track.
	// Example: h264
	SetCodec(FrameCodec) TrackInfoVideo
	// Content of the track (audio, video, or text).
	Content() FrameContent
	// Content of the track (audio, video, or text).
	SetContent(FrameContent) TrackInfoVideo
	// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
	// Higher frame rates capture more images per second, which makes for smoother video.
	// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
	// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
	// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
	// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
	// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
	FPS() *float64
	// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
	// Higher frame rates capture more images per second, which makes for smoother video.
	// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
	// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
	// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
	// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
	// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
	SetFPS(float64) TrackInfoVideo
	// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
	// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
	// However, sometimes (when the connection is broken) video breakups are possible.
	// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
	// This situation is considered as a frame gap and is handled differently across different protocols.
	// Format: ticks (ticks)
	FrameDuration() *Ticks
	// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
	// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
	// However, sometimes (when the connection is broken) video breakups are possible.
	// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
	// This situation is considered as a frame gap and is handled differently across different protocols.
	// Format: ticks (ticks)
	SetFrameDuration(Ticks) TrackInfoVideo
	// The number of frames in a group of pictures (GOP).
	// The encoder will create all GOPs of an exactly identical size - as specified in this option.
	// A bigger GOP can be good for video compression but it can result in big zap-time (the duration of time between changing a channel and displaying a new channel.)
	GopSize() *int
	// The number of frames in a group of pictures (GOP).
	// The encoder will create all GOPs of an exactly identical size - as specified in this option.
	// A bigger GOP can be good for video compression but it can result in big zap-time (the duration of time between changing a channel and displaying a new channel.)
	SetGopSize(int) TrackInfoVideo
	// The picture height in pixels on the display where it will be played by a player.
	// If you need to insert a web-player into a web page, use this value for choosing the player size.
	// Format: pixels (pixels)
	Height() *Pixels
	// The picture height in pixels on the display where it will be played by a player.
	// If you need to insert a web-player into a web page, use this value for choosing the player size.
	// Format: pixels (pixels)
	SetHeight(Pixels) TrackInfoVideo
	// Indicates if progressive scanning method is used for all frames of the track
	IsProgressive() *bool
	// Indicates if progressive scanning method is used for all frames of the track
	SetIsProgressive(bool) TrackInfoVideo
	// Last GOP size (expressed in number of frames).
	// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
	// If this value is floating, this means that your transcoder is working in a flexible GOP size mode and some players may have problems.
	// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
	// Example: 28
	LastGop() *int
	// Last GOP size (expressed in number of frames).
	// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
	// If this value is floating, this means that your transcoder is working in a flexible GOP size mode and some players may have problems.
	// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
	// Example: 28
	SetLastGop(int) TrackInfoVideo
	// The size of the length field for H264 bitstream without start codes.
	LengthSize() *int
	// The size of the length field for H264 bitstream without start codes.
	SetLengthSize(int) TrackInfoVideo
	// A set of constraints that indicate a degree of required decoder performance.
	// This parameter is used for compatibility with old devices.
	Level() *string
	// A set of constraints that indicate a degree of required decoder performance.
	// This parameter is used for compatibility with old devices.
	SetLevel(string) TrackInfoVideo
	// The number of I-frames to be used for encoding.
	NumRefsFrames() *int
	// The number of I-frames to be used for encoding.
	SetNumRefsFrames(int) TrackInfoVideo
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	Pid() *int
	// This parameter sets PIDs values for outgoing MPEG-TS streams.
	// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
	// It is possible to set PID values for PMT, SDT, video, and audio tracks.
	// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
	// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
	// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
	// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
	SetPid(int) TrackInfoVideo
	// The color model of the video.
	PixFmt() *FrameVideoPixFmt
	// The color model of the video.
	SetPixFmt(FrameVideoPixFmt) TrackInfoVideo
	// The picture width in pixels of the original video before transcoding.
	// Format: pixels (pixels)
	PixelHeight() *Pixels
	// The picture width in pixels of the original video before transcoding.
	// Format: pixels (pixels)
	SetPixelHeight(Pixels) TrackInfoVideo
	// The picture width in pixels of the original video before transcoding.
	// Format: pixels (pixels)
	PixelWidth() *Pixels
	// The picture width in pixels of the original video before transcoding.
	// Format: pixels (pixels)
	SetPixelWidth(Pixels) TrackInfoVideo
	// A specific codec-dependent profile of the output video.
	// The profile allows to assume if the track can be played on a particular device.
	Profile() *string
	// A specific codec-dependent profile of the output video.
	// The profile allows to assume if the track can be played on a particular device.
	SetProfile(string) TrackInfoVideo
	// The second number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
	// SAR is used for creating non-anamorphic video from anamorphic video.
	SarHeight() *int
	// The second number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
	// SAR is used for creating non-anamorphic video from anamorphic video.
	SetSarHeight(int) TrackInfoVideo
	// The first number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
	// SAR is used for creating non-anamorphic video from anamorphic video.
	SarWidth() *int
	// The first number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
	// SAR is used for creating non-anamorphic video from anamorphic video.
	SetSarWidth(int) TrackInfoVideo
	// Human-readable localized title of the track.
	// Example: Video1
	Title() *string
	// Human-readable localized title of the track.
	// Example: Video1
	SetTitle(string) TrackInfoVideo
	// Track identifier assigned by Flussonic.
	// Example: v1
	TrackID() any
	// Track identifier assigned by Flussonic.
	// Example: v1
	SetTrackID(any) TrackInfoVideo
	// The picture width in pixels on the display where it will be played by a player.
	// If you need to insert a web-player into a web page, use this value for choosing the player size.
	// Format: pixels (pixels)
	Width() *Pixels
	// The picture width in pixels on the display where it will be played by a player.
	// If you need to insert a web-player into a web page, use this value for choosing the player size.
	// Format: pixels (pixels)
	SetWidth(Pixels) TrackInfoVideo
}

type TrackInfoVideoConfigurable interface {
	// Average number of B-frames in a GOP. B-frames contain links to keyframes and P-frames before and after themselves.
	// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
	// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
	// Example: 3
	Bframes() *int
	// Average number of B-frames in a GOP. B-frames contain links to keyframes and P-frames before and after themselves.
	// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
	// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
	// Example: 3
	SetBframes(int) TrackInfoVideoConfigurable
	// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
	// Higher frame rates capture more images per second, which makes for smoother video.
	// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
	// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
	// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
	// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
	// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
	FPS() *float64
	// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
	// Higher frame rates capture more images per second, which makes for smoother video.
	// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
	// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
	// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
	// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
	// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
	SetFPS(float64) TrackInfoVideoConfigurable
	// The number of frames in a group of pictures (GOP).
	// The encoder will create all GOPs of an exactly identical size - as specified in this option.
	// A bigger GOP can be good for video compression but it can result in big zap-time (the duration of time between changing a channel and displaying a new channel.)
	GopSize() *int
	// The number of frames in a group of pictures (GOP).
	// The encoder will create all GOPs of an exactly identical size - as specified in this option.
	// A bigger GOP can be good for video compression but it can result in big zap-time (the duration of time between changing a channel and displaying a new channel.)
	SetGopSize(int) TrackInfoVideoConfigurable
	// The picture height in pixels on the display where it will be played by a player.
	// If you need to insert a web-player into a web page, use this value for choosing the player size.
	// Format: pixels (pixels)
	Height() *Pixels
	// The picture height in pixels on the display where it will be played by a player.
	// If you need to insert a web-player into a web page, use this value for choosing the player size.
	// Format: pixels (pixels)
	SetHeight(Pixels) TrackInfoVideoConfigurable
	// A set of constraints that indicate a degree of required decoder performance.
	// This parameter is used for compatibility with old devices.
	Level() *string
	// A set of constraints that indicate a degree of required decoder performance.
	// This parameter is used for compatibility with old devices.
	SetLevel(string) TrackInfoVideoConfigurable
	// The number of I-frames to be used for encoding.
	NumRefsFrames() *int
	// The number of I-frames to be used for encoding.
	SetNumRefsFrames(int) TrackInfoVideoConfigurable
	// The color model of the video.
	PixFmt() *FrameVideoPixFmt
	// The color model of the video.
	SetPixFmt(FrameVideoPixFmt) TrackInfoVideoConfigurable
	// The picture width in pixels of the original video before transcoding.
	// Format: pixels (pixels)
	PixelHeight() *Pixels
	// The picture width in pixels of the original video before transcoding.
	// Format: pixels (pixels)
	SetPixelHeight(Pixels) TrackInfoVideoConfigurable
	// The picture width in pixels of the original video before transcoding.
	// Format: pixels (pixels)
	PixelWidth() *Pixels
	// The picture width in pixels of the original video before transcoding.
	// Format: pixels (pixels)
	SetPixelWidth(Pixels) TrackInfoVideoConfigurable
	// A specific codec-dependent profile of the output video.
	// The profile allows to assume if the track can be played on a particular device.
	Profile() *string
	// A specific codec-dependent profile of the output video.
	// The profile allows to assume if the track can be played on a particular device.
	SetProfile(string) TrackInfoVideoConfigurable
	// The second number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
	// SAR is used for creating non-anamorphic video from anamorphic video.
	SarHeight() *int
	// The second number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
	// SAR is used for creating non-anamorphic video from anamorphic video.
	SetSarHeight(int) TrackInfoVideoConfigurable
	// The first number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
	// SAR is used for creating non-anamorphic video from anamorphic video.
	SarWidth() *int
	// The first number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
	// SAR is used for creating non-anamorphic video from anamorphic video.
	SetSarWidth(int) TrackInfoVideoConfigurable
	// The picture width in pixels on the display where it will be played by a player.
	// If you need to insert a web-player into a web page, use this value for choosing the player size.
	// Format: pixels (pixels)
	Width() *Pixels
	// The picture width in pixels on the display where it will be played by a player.
	// If you need to insert a web-player into a web page, use this value for choosing the player size.
	// Format: pixels (pixels)
	SetWidth(Pixels) TrackInfoVideoConfigurable
}

type TrackInfoVideoSpecific interface {
	// Average GOP size (expressed in number of frames) of the last 1000-2000 frames.
	// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
	// If this value is floating, this means that your transcoder is working in flexible GOP size mode and some players may have problems.
	// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
	// Example: 25
	AvgGop() *int
	// Average GOP size (expressed in number of frames) of the last 1000-2000 frames.
	// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
	// If this value is floating, this means that your transcoder is working in flexible GOP size mode and some players may have problems.
	// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
	// Example: 25
	SetAvgGop(int) TrackInfoVideoSpecific
	// Parameters of closed captions.
	ClosedCaptions() []ClosedCaptions
	// Parameters of closed captions.
	SetClosedCaptions([]ClosedCaptions) TrackInfoVideoSpecific
	// Indicates if progressive scanning method is used for all frames of the track
	IsProgressive() *bool
	// Indicates if progressive scanning method is used for all frames of the track
	SetIsProgressive(bool) TrackInfoVideoSpecific
	// Last GOP size (expressed in number of frames).
	// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
	// If this value is floating, this means that your transcoder is working in a flexible GOP size mode and some players may have problems.
	// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
	// Example: 28
	LastGop() *int
	// Last GOP size (expressed in number of frames).
	// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
	// If this value is floating, this means that your transcoder is working in a flexible GOP size mode and some players may have problems.
	// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
	// Example: 28
	SetLastGop(int) TrackInfoVideoSpecific
	// The size of the length field for H264 bitstream without start codes.
	LengthSize() *int
	// The size of the length field for H264 bitstream without start codes.
	SetLengthSize(int) TrackInfoVideoSpecific
}

type UiSettingsConfig interface {
	// The product brand.
	// Examples: Central, Cloud, Streamer
	Brand() *string
	// The product brand.
	// Examples: Central, Cloud, Streamer
	SetBrand(string) UiSettingsConfig
	// The interface colors.
	Colors() UiSettingsConfigColors
	// The interface colors.
	SetColors(UiSettingsConfigColors) UiSettingsConfig
	// Contact information for customers to reach the company through various means.
	CompanyInfo() UiSettingsConfigCompanyInfo
	// Contact information for customers to reach the company through various means.
	SetCompanyInfo(UiSettingsConfigCompanyInfo) UiSettingsConfig
	// The default locale
	DefaultLocale() *ISO6391
	// The default locale
	SetDefaultLocale(ISO6391) UiSettingsConfig
	// The favicons of different sizes for different OSes and browsers.
	Favicons() UiSettingsConfigFavicons
	// The favicons of different sizes for different OSes and browsers.
	SetFavicons(UiSettingsConfigFavicons) UiSettingsConfig
	// The fonts in the UI.
	Fonts() UiSettingsConfigFonts
	// The fonts in the UI.
	SetFonts(UiSettingsConfigFonts) UiSettingsConfig
	// The list of possible locales
	// Example: [en ru]
	Locales() []ISO6391
	// The list of possible locales
	// Example: [en ru]
	SetLocales([]ISO6391) UiSettingsConfig
	// Map settings for displaying streams with specified coordinates.
	Map() Map
	// Map settings for displaying streams with specified coordinates.
	SetMap(Map) UiSettingsConfig
	// The product type.
	// Examples: central, cloud, streamer
	Product() *string
	// The product type.
	// Examples: central, cloud, streamer
	SetProduct(string) UiSettingsConfig
	// The product title.
	// Examples: Billing, Central, Cloud, Streamer
	Title() *string
	// The product title.
	// Examples: Billing, Central, Cloud, Streamer
	SetTitle(string) UiSettingsConfig
}

// The interface colors.
type UiSettingsConfigColors interface {
	// The background color.
	// Example: #fff
	Background() *string
	// The background color.
	// Example: #fff
	SetBackground(string) UiSettingsConfigColors
	// Primary color for interface elements like selection in the main menu, info icons, buttons, etc.
	// Examples: #002DAB, #002DAB, #4549F2, #4549F2
	Primary() *string
	// Primary color for interface elements like selection in the main menu, info icons, buttons, etc.
	// Examples: #002DAB, #002DAB, #4549F2, #4549F2
	SetPrimary(string) UiSettingsConfigColors
	// Secondary color for obsolete interface elements like active tab.
	// Examples: #E91E63, #E91E63, #FF0D70, #FF0D70
	Secondary() *string
	// Secondary color for obsolete interface elements like active tab.
	// Examples: #E91E63, #E91E63, #FF0D70, #FF0D70
	SetSecondary(string) UiSettingsConfigColors
}

// Contact information for customers to reach the company through various means.
type UiSettingsConfigCompanyInfo interface {
	// Details enabling customers to locate the company's physical location.
	Address() *string
	// Details enabling customers to locate the company's physical location.
	SetAddress(string) UiSettingsConfigCompanyInfo
	// Notify your users if you are not ready to answer phone calls and emails 24/7.
	BusinessHours() *string
	// Notify your users if you are not ready to answer phone calls and emails 24/7.
	SetBusinessHours(string) UiSettingsConfigCompanyInfo
	// Telephone contact information for reaching out to the company.
	Phone() *string
	// Telephone contact information for reaching out to the company.
	SetPhone(string) UiSettingsConfigCompanyInfo
}

// The favicons of different sizes for different OSes and browsers.
type UiSettingsConfigFavicons interface {
	// 128x128 pixels favicon.
	// Format: byte (byte)
	// Example: icons/favicon-128.png
	T128() *Byte
	// 128x128 pixels favicon.
	// Format: byte (byte)
	// Example: icons/favicon-128.png
	SetT128(Byte) UiSettingsConfigFavicons
	// 16x16 pixels favicon.
	// Format: byte (byte)
	// Example: icons/favicon-16.png
	T16() *Byte
	// 16x16 pixels favicon.
	// Format: byte (byte)
	// Example: icons/favicon-16.png
	SetT16(Byte) UiSettingsConfigFavicons
	// 32x32 pixels favicon.
	// Format: byte (byte)
	// Example: icons/favicon-32.png
	T32() *Byte
	// 32x32 pixels favicon.
	// Format: byte (byte)
	// Example: icons/favicon-32.png
	SetT32(Byte) UiSettingsConfigFavicons
	// 48x48 pixels favicon.
	// Format: byte (byte)
	// Example: icons/favicon-48.png
	T48() *Byte
	// 48x48 pixels favicon.
	// Format: byte (byte)
	// Example: icons/favicon-48.png
	SetT48(Byte) UiSettingsConfigFavicons
	// 64x64 pixels favicon.
	// Format: byte (byte)
	// Example: icons/favicon-64.png
	T64() *Byte
	// 64x64 pixels favicon.
	// Format: byte (byte)
	// Example: icons/favicon-64.png
	SetT64(Byte) UiSettingsConfigFavicons
}

// The fonts in the UI.
type UiSettingsConfigFonts interface {
	// The light font style.
	// Format: byte (byte)
	// Example: fira-sans-300.woff2
	Light() *Byte
	// The light font style.
	// Format: byte (byte)
	// Example: fira-sans-300.woff2
	SetLight(Byte) UiSettingsConfigFonts
	// The medium font style.
	// Format: byte (byte)
	// Example: fira-sans-500.woff2
	Medium() *Byte
	// The medium font style.
	// Format: byte (byte)
	// Example: fira-sans-500.woff2
	SetMedium(Byte) UiSettingsConfigFonts
	// The regular font style.
	// Format: byte (byte)
	// Example: fira-sans-400.woff2
	Regular() *Byte
	// The regular font style.
	// Format: byte (byte)
	// Example: fira-sans-400.woff2
	SetRegular(Byte) UiSettingsConfigFonts
}

type User interface {
	// The parameter regulates the rights for the user
	// Example: generic
	AccessLevel() *UserAdminAccessLevel
	// The parameter regulates the rights for the user
	// Example: generic
	SetAccessLevel(UserAdminAccessLevel) User
	// The date and time when the user was created.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.672531199e+12
	CreatedAt() *UtcMs
	// The date and time when the user was created.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.672531199e+12
	SetCreatedAt(UtcMs) User
	// A parameter that allows you to enable/disable the user
	// Example: false
	Disabled() *bool
	// A parameter that allows you to enable/disable the user
	// Example: false
	SetDisabled(bool) User
	// User's email. Required for password recovery.
	// Format: email (email)
	// Example: user@example.com
	Email() *Email
	// User's email. Required for password recovery.
	// Format: email (email)
	// Example: user@example.com
	SetEmail(Email) User
	// The user's full name.
	Fullname() *string
	// The user's full name.
	SetFullname(string) User
	// Identifier of the user.
	// Example: 1
	ID() *int
	// Identifier of the user.
	// Example: 1
	SetID(int) User
	// The language, selected by user.
	// Format: ISO 639-1
	// Example: en
	Locale() *ISO6391
	// The language, selected by user.
	// Format: ISO 639-1
	// Example: en
	SetLocale(ISO6391) User
	// The maximum number of sessions the user can have simultaneously.
	MaxSessions() *int
	// The maximum number of sessions the user can have simultaneously.
	SetMaxSessions(int) User
	// User name (login)
	Name() *string
	// User name (login)
	SetName(string) User
	// Additional information or notes about the user.
	Note() *string
	// Additional information or notes about the user.
	SetNote(string) User
	// A parameter indicating that the user belongs to certain organizations
	Organizations() []UserAdminOrganizationsItem
	// A parameter indicating that the user belongs to certain organizations
	SetOrganizations([]UserAdminOrganizationsItem) User
	// The specified password will be saved as a hash, used only for writing
	Password() *string
	// The specified password will be saved as a hash, used only for writing
	SetPassword(string) User
	// User's phone number
	// Format: phone-number (phone-number)
	// Example: +78007778413
	Phone() *PhoneNumber
	// User's phone number
	// Format: phone-number (phone-number)
	// Example: +78007778413
	SetPhone(PhoneNumber) User
	// A flag indicating that the user has read-only access and cannot modify their own data.
	// Example: false
	Readonly() *bool
	// A flag indicating that the user has read-only access and cannot modify their own data.
	// Example: false
	SetReadonly(bool) User
}

// User Parameters available from Admin API.
type UserAdmin interface {
	// The parameter regulates the rights for the user
	// Example: generic
	AccessLevel() *UserAdminAccessLevel
	// The parameter regulates the rights for the user
	// Example: generic
	SetAccessLevel(UserAdminAccessLevel) UserAdmin
	// A parameter that allows you to enable/disable the user
	// Example: false
	Disabled() *bool
	// A parameter that allows you to enable/disable the user
	// Example: false
	SetDisabled(bool) UserAdmin
	// Identifier of the user.
	// Example: 1
	ID() *int
	// Identifier of the user.
	// Example: 1
	SetID(int) UserAdmin
	// A parameter indicating that the user belongs to certain organizations
	Organizations() []UserAdminOrganizationsItem
	// A parameter indicating that the user belongs to certain organizations
	SetOrganizations([]UserAdminOrganizationsItem) UserAdmin
	// A flag indicating that the user has read-only access and cannot modify their own data.
	// Example: false
	Readonly() *bool
	// A flag indicating that the user has read-only access and cannot modify their own data.
	// Example: false
	SetReadonly(bool) UserAdmin
}

type UserAdminOrganizationsItem interface {
	// Id of the organization
	// Example: 1
	ID() *int
	// Id of the organization
	// Example: 1
	SetID(int) UserAdminOrganizationsItem
	// Owner properties.
	Owner() UserAdminOrganizationsItemOwner
	// Owner properties.
	SetOwner(UserAdminOrganizationsItemOwner) UserAdminOrganizationsItem
	// Organization permissions
	Permissions() OrganizationPermissions
	// Organization permissions
	SetPermissions(OrganizationPermissions) UserAdminOrganizationsItem
	// Display title of the organization
	// Example: Cameras
	Title() *string
	// Display title of the organization
	// Example: Cameras
	SetTitle(string) UserAdminOrganizationsItem
}

// Owner properties.
type UserAdminOrganizationsItemOwner interface {
	// ID of the organizations owner.
	// Example: 2
	ID() *int
	// ID of the organizations owner.
	// Example: 2
	SetID(int) UserAdminOrganizationsItemOwner
	// Name of the organizations owner.
	// Example: admin
	Name() *string
	// Name of the organizations owner.
	// Example: admin
	SetName(string) UserAdminOrganizationsItemOwner
}

// User parameters visible from Admin and Client APIs.
type UserBase interface {
	// The date and time when the user was created.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.672531199e+12
	CreatedAt() *UtcMs
	// The date and time when the user was created.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.672531199e+12
	SetCreatedAt(UtcMs) UserBase
	// User's email. Required for password recovery.
	// Format: email (email)
	// Example: user@example.com
	Email() *Email
	// User's email. Required for password recovery.
	// Format: email (email)
	// Example: user@example.com
	SetEmail(Email) UserBase
	// The user's full name.
	Fullname() *string
	// The user's full name.
	SetFullname(string) UserBase
	// The language, selected by user.
	// Format: ISO 639-1
	// Example: en
	Locale() *ISO6391
	// The language, selected by user.
	// Format: ISO 639-1
	// Example: en
	SetLocale(ISO6391) UserBase
	// The maximum number of sessions the user can have simultaneously.
	MaxSessions() *int
	// The maximum number of sessions the user can have simultaneously.
	SetMaxSessions(int) UserBase
	// User name (login)
	Name() *string
	// User name (login)
	SetName(string) UserBase
	// Additional information or notes about the user.
	Note() *string
	// Additional information or notes about the user.
	SetNote(string) UserBase
	// The specified password will be saved as a hash, used only for writing
	Password() *string
	// The specified password will be saved as a hash, used only for writing
	SetPassword(string) UserBase
	// User's phone number
	// Format: phone-number (phone-number)
	// Example: +78007778413
	Phone() *PhoneNumber
	// User's phone number
	// Format: phone-number (phone-number)
	// Example: +78007778413
	SetPhone(PhoneNumber) UserBase
}

// A user who has been granted access via stream permissions.
type UserBaseSteamPermissions interface {
	// User identifier
	ID() *int
	// User identifier
	SetID(int) UserBaseSteamPermissions
}

type UserCreate interface {
	// The parameter regulates the rights for the user
	// Example: generic
	AccessLevel() *UserAdminAccessLevel
	// The parameter regulates the rights for the user
	// Example: generic
	SetAccessLevel(UserAdminAccessLevel) UserCreate
	// The date and time when the user was created.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.672531199e+12
	CreatedAt() *UtcMs
	// The date and time when the user was created.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.672531199e+12
	SetCreatedAt(UtcMs) UserCreate
	// A parameter that allows you to enable/disable the user
	// Example: false
	Disabled() *bool
	// A parameter that allows you to enable/disable the user
	// Example: false
	SetDisabled(bool) UserCreate
	// User's email. Required for password recovery.
	// Format: email (email)
	// Example: user@example.com
	Email() *Email
	// User's email. Required for password recovery.
	// Format: email (email)
	// Example: user@example.com
	SetEmail(Email) UserCreate
	// The user's full name.
	Fullname() *string
	// The user's full name.
	SetFullname(string) UserCreate
	// Identifier of the user.
	// Example: 1
	ID() *int
	// Identifier of the user.
	// Example: 1
	SetID(int) UserCreate
	// The language, selected by user.
	// Format: ISO 639-1
	// Example: en
	Locale() *ISO6391
	// The language, selected by user.
	// Format: ISO 639-1
	// Example: en
	SetLocale(ISO6391) UserCreate
	// The maximum number of sessions the user can have simultaneously.
	MaxSessions() *int
	// The maximum number of sessions the user can have simultaneously.
	SetMaxSessions(int) UserCreate
	// User name (login)
	Name() *string
	// User name (login)
	SetName(string) UserCreate
	// Additional information or notes about the user.
	Note() *string
	// Additional information or notes about the user.
	SetNote(string) UserCreate
	// The identifier of the Organization to which the user should be added.
	// If no organization_id - first organization where user has permissions for managing users.
	// Example: 12
	OrganizationID() *int
	// The identifier of the Organization to which the user should be added.
	// If no organization_id - first organization where user has permissions for managing users.
	// Example: 12
	SetOrganizationID(int) UserCreate
	// A parameter indicating that the user belongs to certain organizations
	Organizations() []UserAdminOrganizationsItem
	// A parameter indicating that the user belongs to certain organizations
	SetOrganizations([]UserAdminOrganizationsItem) UserCreate
	// The specified password will be saved as a hash, used only for writing
	Password() *string
	// The specified password will be saved as a hash, used only for writing
	SetPassword(string) UserCreate
	// User's phone number
	// Format: phone-number (phone-number)
	// Example: +78007778413
	Phone() *PhoneNumber
	// User's phone number
	// Format: phone-number (phone-number)
	// Example: +78007778413
	SetPhone(PhoneNumber) UserCreate
	// A flag indicating that the user has read-only access and cannot modify their own data.
	// Example: false
	Readonly() *bool
	// A flag indicating that the user has read-only access and cannot modify their own data.
	// Example: false
	SetReadonly(bool) UserCreate
}

type UserFolder interface {
	// The folder may have a floor plan attached to it to be shown on the map.
	// This parameter sets the image center coordinates: latitude and longitude.
	Coordinates() MapSpec
	// The folder may have a floor plan attached to it to be shown on the map.
	// This parameter sets the image center coordinates: latitude and longitude.
	SetCoordinates(MapSpec) UserFolder
	// Object of map parameters
	FloorPlan() FolderFloorPlan
	// Object of map parameters
	SetFloorPlan(FolderFloorPlan) UserFolder
	// Hierarchy object.
	Hierarchy() FolderHierarchy
	// Hierarchy object.
	SetHierarchy(FolderHierarchy) UserFolder
	// The folder ID.
	ID() int
	// The folder ID.
	SetID(int) UserFolder
	// The identifier of the Organization to which the folder belongs.
	OrganizationID() *int
	// The identifier of the Organization to which the folder belongs.
	SetOrganizationID(int) UserFolder
	// The identifier of the parent folder.
	ParentID() *int
	// The identifier of the parent folder.
	SetParentID(int) UserFolder
	Permissions() UserFolderPermissions
	SetPermissions(UserFolderPermissions) UserFolder
	// The number of streams in the folder.
	// Example: 2
	StreamsCount() *int
	// The number of streams in the folder.
	// Example: 2
	SetStreamsCount(int) UserFolder
	// The folder name.
	Title() *string
	// The folder name.
	SetTitle(string) UserFolder
}

type UserFolderPermissions interface {
	// The flag showing if the user can manage and execute actions on the streams in the folder.
	CanUseActions() *bool
	// The flag showing if the user can manage and execute actions on the streams in the folder.
	SetCanUseActions(bool) UserFolderPermissions
	// The flag if the user can use PTZ controls.
	CanUsePtz() *bool
	// The flag if the user can use PTZ controls.
	SetCanUsePtz(bool) UserFolderPermissions
	// The flag showing if the user can view only live on the streams in the folder and the list of streams.
	CanView() *bool
	// The flag showing if the user can view only live on the streams in the folder and the list of streams.
	SetCanView(bool) UserFolderPermissions
	// The flag showing if the user can view archive on the streams in the folder.
	CanViewDvr() *bool
	// The flag showing if the user can view archive on the streams in the folder.
	SetCanViewDvr(bool) UserFolderPermissions
	// The dvr depth limit allows to:
	// Set the maximum recording depth, which determines how far back recorded materials can be viewed.
	// Manage access to archived data, ensuring security and control over who can access records.
	// if set to 0, the user has unlimited access to the archive.
	// Format: seconds (seconds)
	// Example: 3600
	DvrDepthLimit() *Seconds
	// The dvr depth limit allows to:
	// Set the maximum recording depth, which determines how far back recorded materials can be viewed.
	// Manage access to archived data, ensuring security and control over who can access records.
	// if set to 0, the user has unlimited access to the archive.
	// Format: seconds (seconds)
	// Example: 3600
	SetDvrDepthLimit(Seconds) UserFolderPermissions
}

type UserFolders interface {
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	EstimatedCount() *int
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	SetEstimatedCount(int) UserFolders
	// List of fetched user folders according to the query parameters.
	Folders() []UserFolder
	// List of fetched user folders according to the query parameters.
	SetFolders([]UserFolder) UserFolders
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	Next() *string
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	SetNext(string) UserFolders
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	Prev() *string
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	SetPrev(string) UserFolders
	// An object with a list of different timings measured during this API call.
	Timing() any
	// An object with a list of different timings measured during this API call.
	SetTiming(any) UserFolders
	// Collection returns the collection items
	Collection() []UserFolder
}

// User parameters visible from Admin and Client APIs.
type UserProfile interface {
	// Indicates that user has access_level equal "admin".
	IsAdmin() *bool
	// Indicates that user has access_level equal "admin".
	SetIsAdmin(bool) UserProfile
	// Indicates that user has access_level equal "domain admin".
	IsDomainAdmin() *bool
	// Indicates that user has access_level equal "domain admin".
	SetIsDomainAdmin(bool) UserProfile
	// Indicates that the user has a read-only access level.
	// Example: true
	IsReadonly() *bool
	// Indicates that the user has a read-only access level.
	// Example: true
	SetIsReadonly(bool) UserProfile
}

type UserStreamPermission interface {
	Permissions() UserStreamPermissionPermissions
	SetPermissions(UserStreamPermissionPermissions) UserStreamPermission
	Stream() UserStreamPermissionStream
	SetStream(UserStreamPermissionStream) UserStreamPermission
}

type UserStreamPermissionPermissions interface {
	// Whether the user can control PTZ cameras
	CanUsePtz() *bool
	// Whether the user can control PTZ cameras
	SetCanUsePtz(bool) UserStreamPermissionPermissions
	// Whether the user can view the stream
	CanView() *bool
	// Whether the user can view the stream
	SetCanView(bool) UserStreamPermissionPermissions
	// Whether the user can view the stream archive
	CanViewDvr() *bool
	// Whether the user can view the stream archive
	SetCanViewDvr(bool) UserStreamPermissionPermissions
	// Maximum archive depth in seconds that user can access
	DvrDepthLimit() *int
	// Maximum archive depth in seconds that user can access
	SetDvrDepthLimit(int) UserStreamPermissionPermissions
}

type UserStreamPermissionStream interface {
	// Stream name
	Name() *string
	// Stream name
	SetName(string) UserStreamPermissionStream
}

type UserStreamsPermissionsList interface {
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	EstimatedCount() *int
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	SetEstimatedCount(int) UserStreamsPermissionsList
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	Next() *string
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	SetNext(string) UserStreamsPermissionsList
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	Prev() *string
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	SetPrev(string) UserStreamsPermissionsList
	// List of streams
	StreamsPermissions() []UserStreamPermission
	// List of streams
	SetStreamsPermissions([]UserStreamPermission) UserStreamsPermissionsList
	// An object with a list of different timings measured during this API call.
	Timing() any
	// An object with a list of different timings measured during this API call.
	SetTiming(any) UserStreamsPermissionsList
	// Collection returns the collection items
	Collection() []UserStreamPermission
}

type Users interface {
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	EstimatedCount() *int
	// Estimated total number of records for the query (regardless of the cursors).
	// Example: 5
	SetEstimatedCount(int) Users
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	Next() *string
	// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fZ3Q9MA==
	SetNext(string) Users
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	Prev() *string
	// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
	// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
	// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
	SetPrev(string) Users
	// An object with a list of different timings measured during this API call.
	Timing() any
	// An object with a list of different timings measured during this API call.
	SetTiming(any) Users
	// List of fetched users according to the query parameters.
	UsersList() []User
	// List of fetched users according to the query parameters.
	SetUsersList([]User) Users
	// Collection returns the collection items
	Collection() []User
}

type VisionAlerts interface {
	// The time when an episode could not be created due to low detection quality (on blurry or noisy frames).
	// It may be caused by uncertainty when the picture is not clear enough.
	// Try adjusting the shutter speed parameters on your camera.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	LowQualityAt() *UtcMs
	// The time when an episode could not be created due to low detection quality (on blurry or noisy frames).
	// It may be caused by uncertainty when the picture is not clear enough.
	// Try adjusting the shutter speed parameters on your camera.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	SetLowQualityAt(UtcMs) VisionAlerts
	// The time when an episode could not be created due to insufficient detections.
	// The issue occurs when the selected detector is unable to find the target object enough times.
	// It is possible that the target object appears shortly or is obscured by something.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	NotEnoughDetectionsAt() *UtcMs
	// The time when an episode could not be created due to insufficient detections.
	// The issue occurs when the selected detector is unable to find the target object enough times.
	// It is possible that the target object appears shortly or is obscured by something.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	SetNotEnoughDetectionsAt(UtcMs) VisionAlerts
	// The time when an episode could not be created due to the small size of detections relative to the detector internal settings.
	// The camera placement may need to be adjusted closer to the target objects.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	SmallSizeAt() *UtcMs
	// The time when an episode could not be created due to the small size of detections relative to the detector internal settings.
	// The camera placement may need to be adjusted closer to the target objects.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	SetSmallSizeAt(UtcMs) VisionAlerts
}

type VisionAppearance interface {
	// Position of the objects at the frame
	Box() VisionBox
	// Position of the objects at the frame
	SetBox(VisionBox) VisionAppearance
}

// Rectangle
// Required: top, left, bottom, right
type VisionBox interface {
	// Bottom border of the bounding box. Fraction of full frame height
	Bottom() float64
	// Bottom border of the bounding box. Fraction of full frame height
	SetBottom(float64) VisionBox
	// Left border of the bounding box. Fraction of full frame width
	Left() float64
	// Left border of the bounding box. Fraction of full frame width
	SetLeft(float64) VisionBox
	// Right border of the bounding box. Fraction of full frame width
	Right() float64
	// Right border of the bounding box. Fraction of full frame width
	SetRight(float64) VisionBox
	// Top border of the bounding box. Fraction of full frame height
	Top() float64
	// Top border of the bounding box. Fraction of full frame height
	SetTop(float64) VisionBox
}

type VisionDetectedFace interface {
	// Appearance attributes of the detected object
	Appearance() VisionAppearance
	// Appearance attributes of the detected object
	SetAppearance(VisionAppearance) VisionDetectedFace
	// Confidence level of object detection
	Confidence() *float64
	// Confidence level of object detection
	SetConfidence(float64) VisionDetectedFace
	// Timestamp when the object was detected
	// Format: utc_ms (Unix timestamp in milliseconds)
	DetectedAt() UtcMs
	// Timestamp when the object was detected
	// Format: utc_ms (Unix timestamp in milliseconds)
	SetDetectedAt(UtcMs) VisionDetectedFace
	// The fingerprint of the detected face
	Fingerprint() VisionFaceFingerprint
	// The fingerprint of the detected face
	SetFingerprint(VisionFaceFingerprint) VisionDetectedFace
	// Class of the detected object
	ObjectClass() VisionObjectClass
	// Class of the detected object
	SetObjectClass(VisionObjectClass) VisionDetectedFace
	// Preview of the detected object
	Thumbnail() VisionImageAttributes
	// Preview of the detected object
	SetThumbnail(VisionImageAttributes) VisionDetectedFace
	// Quality of the thumbnail
	ThumbnailQuality() *float64
	// Quality of the thumbnail
	SetThumbnailQuality(float64) VisionDetectedFace
}

type VisionDetectedLicensePlate interface {
	// Appearance attributes of the detected object
	Appearance() VisionAppearance
	// Appearance attributes of the detected object
	SetAppearance(VisionAppearance) VisionDetectedLicensePlate
	// Confidence level of object detection
	Confidence() *float64
	// Confidence level of object detection
	SetConfidence(float64) VisionDetectedLicensePlate
	// Timestamp when the object was detected
	// Format: utc_ms (Unix timestamp in milliseconds)
	DetectedAt() UtcMs
	// Timestamp when the object was detected
	// Format: utc_ms (Unix timestamp in milliseconds)
	SetDetectedAt(UtcMs) VisionDetectedLicensePlate
	// Shows from which side the vehicle was detected.
	FacingSide() *VisionVehicleFacingSide
	// Shows from which side the vehicle was detected.
	SetFacingSide(VisionVehicleFacingSide) VisionDetectedLicensePlate
	// Class of the detected object
	ObjectClass() VisionObjectClass
	// Class of the detected object
	SetObjectClass(VisionObjectClass) VisionDetectedLicensePlate
	// Recognized vehicle's license plate number
	PlateText() *string
	// Recognized vehicle's license plate number
	SetPlateText(string) VisionDetectedLicensePlate
	// Preview of the detected object
	Thumbnail() VisionImageAttributes
	// Preview of the detected object
	SetThumbnail(VisionImageAttributes) VisionDetectedLicensePlate
	// Quality of the thumbnail
	ThumbnailQuality() *float64
	// Quality of the thumbnail
	SetThumbnailQuality(float64) VisionDetectedLicensePlate
}

// Required: detected_at, object_class
type VisionDetectedObjectBase interface {
	// Appearance attributes of the detected object
	Appearance() VisionAppearance
	// Appearance attributes of the detected object
	SetAppearance(VisionAppearance) VisionDetectedObjectBase
	// Confidence level of object detection
	Confidence() *float64
	// Confidence level of object detection
	SetConfidence(float64) VisionDetectedObjectBase
	// Timestamp when the object was detected
	// Format: utc_ms (Unix timestamp in milliseconds)
	DetectedAt() UtcMs
	// Timestamp when the object was detected
	// Format: utc_ms (Unix timestamp in milliseconds)
	SetDetectedAt(UtcMs) VisionDetectedObjectBase
	// Class of the detected object
	ObjectClass() VisionObjectClass
	// Class of the detected object
	SetObjectClass(VisionObjectClass) VisionDetectedObjectBase
	// Preview of the detected object
	Thumbnail() VisionImageAttributes
	// Preview of the detected object
	SetThumbnail(VisionImageAttributes) VisionDetectedObjectBase
	// Quality of the thumbnail
	ThumbnailQuality() *float64
	// Quality of the thumbnail
	SetThumbnailQuality(float64) VisionDetectedObjectBase
}

type VisionDetectedVehicle interface {
	// Appearance attributes of the detected object
	Appearance() VisionAppearance
	// Appearance attributes of the detected object
	SetAppearance(VisionAppearance) VisionDetectedVehicle
	// Confidence level of object detection
	Confidence() *float64
	// Confidence level of object detection
	SetConfidence(float64) VisionDetectedVehicle
	// Timestamp when the object was detected
	// Format: utc_ms (Unix timestamp in milliseconds)
	DetectedAt() UtcMs
	// Timestamp when the object was detected
	// Format: utc_ms (Unix timestamp in milliseconds)
	SetDetectedAt(UtcMs) VisionDetectedVehicle
	// Indicates if no license plate is detected on this vehicle
	LicensePlateMissing() *bool
	// Indicates if no license plate is detected on this vehicle
	SetLicensePlateMissing(bool) VisionDetectedVehicle
	// Class of the detected object
	ObjectClass() VisionObjectClass
	// Class of the detected object
	SetObjectClass(VisionObjectClass) VisionDetectedVehicle
	// The purpose of the vehicle, e.g. emergency or regular.
	Purpose() *VisionVehiclePurpose
	// The purpose of the vehicle, e.g. emergency or regular.
	SetPurpose(VisionVehiclePurpose) VisionDetectedVehicle
	// Preview of the detected object
	Thumbnail() VisionImageAttributes
	// Preview of the detected object
	SetThumbnail(VisionImageAttributes) VisionDetectedVehicle
	// Quality of the thumbnail
	ThumbnailQuality() *float64
	// Quality of the thumbnail
	SetThumbnailQuality(float64) VisionDetectedVehicle
}

// Required: detector_type, region_id
type VisionDetectorConfig interface {
	DetectorType() VisionDetectorConfigDetectorType
	SetDetectorType(VisionDetectorConfigDetectorType) VisionDetectorConfig
	RegionCoordinates() VisionDetectorConfigRegionCoordinates
	SetRegionCoordinates(VisionDetectorConfigRegionCoordinates) VisionDetectorConfig
	// Identifier of the detection area.
	// It is used to distinguish episodes from various regions of interest within the frame.
	// For instance, it can be used with a single camera facing two entrances to count visitors independently at each entrance.
	RegionID() string
	// Identifier of the detection area.
	// It is used to distinguish episodes from various regions of interest within the frame.
	// For instance, it can be used with a single camera facing two entrances to count visitors independently at each entrance.
	SetRegionID(string) VisionDetectorConfig
	// Name of the detection area
	// Example: Zone 1
	RegionTitle() *string
	// Name of the detection area
	// Example: Zone 1
	SetRegionTitle(string) VisionDetectorConfig
	// Runtime information about the vision process.
	Stats() VisionDetectorStats
	// Runtime information about the vision process.
	SetStats(VisionDetectorStats) VisionDetectorConfig
}

type VisionDetectorConfigDetectorType interface {
}

type VisionDetectorConfigRegionCoordinates interface {
}

type VisionDetectorStats interface {
	// Identifies analytics issues related to frames in a stream that impact episode creation
	Alerts() VisionAlerts
	// Identifies analytics issues related to frames in a stream that impact episode creation
	SetAlerts(VisionAlerts) VisionDetectorStats
	// The time when there was the last detection. Constant updates mean that analytics can detect objects on frames.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	LastDetectionAt() *UtcMs
	// The time when there was the last detection. Constant updates mean that analytics can detect objects on frames.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637094994e+12
	SetLastDetectionAt(UtcMs) VisionDetectorStats
}

type VisionEpisodeContextSearch interface {
	// The reason for closing the episode.
	CloseReason() *EpisodeCloseReason
	// The reason for closing the episode.
	SetCloseReason(EpisodeCloseReason) VisionEpisodeContextSearch
	// Episode emitter can decide that episode considered closed and will not grow further.
	// `closed_at` MUST NOT change, it must be emitted only once.
	// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
	// of the episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	ClosedAt() *UtcMs
	// Episode emitter can decide that episode considered closed and will not grow further.
	// `closed_at` MUST NOT change, it must be emitted only once.
	// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
	// of the episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetClosedAt(UtcMs) VisionEpisodeContextSearch
	// The time when the episode appeared in the service relative to the server time.
	EpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps
	// The time when the episode appeared in the service relative to the server time.
	SetEpisodeAppearanceTimestamps(EpisodeAppearanceTimestamps) VisionEpisodeContextSearch
	// Unique identifier of the episode. Must be created by the system that first creates this episode.
	// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
	// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
	// handle very long integers.
	// Format: snowflake_id (snowflake_id)
	// Examples: 1.722279170848854e+18
	EpisodeID() SnowflakeID
	// Unique identifier of the episode. Must be created by the system that first creates this episode.
	// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
	// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
	// handle very long integers.
	// Format: snowflake_id (snowflake_id)
	// Examples: 1.722279170848854e+18
	SetEpisodeID(SnowflakeID) VisionEpisodeContextSearch
	// Episode matches context search text query
	EpisodeType() *string
	// Episode matches context search text query
	SetEpisodeType(string) VisionEpisodeContextSearch
	// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
	// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
	// Format: base64 (base64)
	FramePreview() *Base64
	// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
	// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
	// Format: base64 (base64)
	SetFramePreview(Base64) VisionEpisodeContextSearch
	// Maximum matching score between the text query and episode.
	// Examples: 0.2345
	MatchScore() *float64
	// Maximum matching score between the text query and episode.
	// Examples: 0.2345
	SetMatchScore(float64) VisionEpisodeContextSearch
	// Stream name on which this episode exists.
	// Format: media_name (media_name)
	Media() MediaName
	// Stream name on which this episode exists.
	// Format: media_name (media_name)
	SetMedia(MediaName) VisionEpisodeContextSearch
	// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
	// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
	// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
	// sort as by `opened_at`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	OpenedAt() UtcMs
	// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
	// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
	// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
	// sort as by `opened_at`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetOpenedAt(UtcMs) VisionEpisodeContextSearch
	// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Format: base64 (base64)
	Preview() *Base64
	// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Format: base64 (base64)
	SetPreview(Base64) VisionEpisodeContextSearch
	// The time when the preview of this episode is available.
	// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
	// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
	// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
	// for details.
	// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	PreviewTimestamp() *UtcMs
	// The time when the preview of this episode is available.
	// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
	// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
	// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
	// for details.
	// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetPreviewTimestamp(UtcMs) VisionEpisodeContextSearch
	// This field can be used as indication of the fact that some system have checked and ensured that
	// this episode has really started at some time, that may differ from `opened_at`.
	// For example video analytics will use this field for the time when this episode was confirmed as confident.
	// May be not relevant for television systems.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	StartedAt() *UtcMs
	// This field can be used as indication of the fact that some system have checked and ensured that
	// this episode has really started at some time, that may differ from `opened_at`.
	// For example video analytics will use this field for the time when this episode was confirmed as confident.
	// May be not relevant for television systems.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetStartedAt(UtcMs) VisionEpisodeContextSearch
	// The time of last change of the episode.
	// System that processes episodes and can send them to other systems, MUST update this field
	// on any changes in this episode.
	// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
	// this `updated_at` can be used as a sort key for fetching fresh updates.
	// Consumer of the episodes can use `updated_at` in the following scenario:
	// * fetch all exisiting episodes from the source
	// * take biggest `updated_at` from this dataset, it will be T
	// * ask source for all episodes with `updated_at > T`
	// This algorithm can be used for fetching update stream from the source.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637098611e+12
	UpdatedAt() UtcMs
	// The time of last change of the episode.
	// System that processes episodes and can send them to other systems, MUST update this field
	// on any changes in this episode.
	// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
	// this `updated_at` can be used as a sort key for fetching fresh updates.
	// Consumer of the episodes can use `updated_at` in the following scenario:
	// * fetch all exisiting episodes from the source
	// * take biggest `updated_at` from this dataset, it will be T
	// * ask source for all episodes with `updated_at > T`
	// This algorithm can be used for fetching update stream from the source.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637098611e+12
	SetUpdatedAt(UtcMs) VisionEpisodeContextSearch
}

type VisionEpisodeFace interface {
	// The reason for closing the episode.
	CloseReason() *EpisodeCloseReason
	// The reason for closing the episode.
	SetCloseReason(EpisodeCloseReason) VisionEpisodeFace
	// Episode emitter can decide that episode considered closed and will not grow further.
	// `closed_at` MUST NOT change, it must be emitted only once.
	// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
	// of the episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	ClosedAt() *UtcMs
	// Episode emitter can decide that episode considered closed and will not grow further.
	// `closed_at` MUST NOT change, it must be emitted only once.
	// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
	// of the episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetClosedAt(UtcMs) VisionEpisodeFace
	// Detections associated with this episode
	Detections() []VisionDetectedFace
	// Detections associated with this episode
	SetDetections([]VisionDetectedFace) VisionEpisodeFace
	// The time when the episode appeared in the service relative to the server time.
	EpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps
	// The time when the episode appeared in the service relative to the server time.
	SetEpisodeAppearanceTimestamps(EpisodeAppearanceTimestamps) VisionEpisodeFace
	// Unique identifier of the episode. Must be created by the system that first creates this episode.
	// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
	// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
	// handle very long integers.
	// Format: snowflake_id (snowflake_id)
	// Examples: 1.722279170848854e+18
	EpisodeID() SnowflakeID
	// Unique identifier of the episode. Must be created by the system that first creates this episode.
	// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
	// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
	// handle very long integers.
	// Format: snowflake_id (snowflake_id)
	// Examples: 1.722279170848854e+18
	SetEpisodeID(SnowflakeID) VisionEpisodeFace
	// Face is detected
	EpisodeType() *string
	// Face is detected
	SetEpisodeType(string) VisionEpisodeFace
	// The fingerprint of the detected face
	Fingerprint() VisionFaceFingerprint
	// The fingerprint of the detected face
	SetFingerprint(VisionFaceFingerprint) VisionEpisodeFace
	// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
	// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
	// Format: base64 (base64)
	FramePreview() *Base64
	// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
	// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
	// Format: base64 (base64)
	SetFramePreview(Base64) VisionEpisodeFace
	// List of matched persons with similarity metric.
	// Videoanalytics identification service enriches episode's data and fills this field
	// with the list of persons that are similar to the face detected in this episode.
	MatchedPersons() []VisionPersonMatch
	// List of matched persons with similarity metric.
	// Videoanalytics identification service enriches episode's data and fills this field
	// with the list of persons that are similar to the face detected in this episode.
	SetMatchedPersons([]VisionPersonMatch) VisionEpisodeFace
	// Stream name on which this episode exists.
	// Format: media_name (media_name)
	Media() MediaName
	// Stream name on which this episode exists.
	// Format: media_name (media_name)
	SetMedia(MediaName) VisionEpisodeFace
	// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
	// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
	// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
	// sort as by `opened_at`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	OpenedAt() UtcMs
	// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
	// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
	// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
	// sort as by `opened_at`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetOpenedAt(UtcMs) VisionEpisodeFace
	// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Preview contains an image of person's face and has a resolution about 200 x 200 pixels with maximum size about 10 kilobytes.
	// Format: base64 (base64)
	Preview() Base64
	// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Preview contains an image of person's face and has a resolution about 200 x 200 pixels with maximum size about 10 kilobytes.
	// Format: base64 (base64)
	SetPreview(Base64) VisionEpisodeFace
	// The time when the preview of this episode is available.
	// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
	// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
	// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
	// for details.
	// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	PreviewTimestamp() *UtcMs
	// The time when the preview of this episode is available.
	// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
	// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
	// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
	// for details.
	// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetPreviewTimestamp(UtcMs) VisionEpisodeFace
	// This field can be used as indication of the fact that some system have checked and ensured that
	// this episode has really started at some time, that may differ from `opened_at`.
	// For example video analytics will use this field for the time when this episode was confirmed as confident.
	// May be not relevant for television systems.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	StartedAt() *UtcMs
	// This field can be used as indication of the fact that some system have checked and ensured that
	// this episode has really started at some time, that may differ from `opened_at`.
	// For example video analytics will use this field for the time when this episode was confirmed as confident.
	// May be not relevant for television systems.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetStartedAt(UtcMs) VisionEpisodeFace
	// The time of last change of the episode.
	// System that processes episodes and can send them to other systems, MUST update this field
	// on any changes in this episode.
	// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
	// this `updated_at` can be used as a sort key for fetching fresh updates.
	// Consumer of the episodes can use `updated_at` in the following scenario:
	// * fetch all exisiting episodes from the source
	// * take biggest `updated_at` from this dataset, it will be T
	// * ask source for all episodes with `updated_at > T`
	// This algorithm can be used for fetching update stream from the source.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637098611e+12
	UpdatedAt() UtcMs
	// The time of last change of the episode.
	// System that processes episodes and can send them to other systems, MUST update this field
	// on any changes in this episode.
	// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
	// this `updated_at` can be used as a sort key for fetching fresh updates.
	// Consumer of the episodes can use `updated_at` in the following scenario:
	// * fetch all exisiting episodes from the source
	// * take biggest `updated_at` from this dataset, it will be T
	// * ask source for all episodes with `updated_at > T`
	// This algorithm can be used for fetching update stream from the source.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637098611e+12
	SetUpdatedAt(UtcMs) VisionEpisodeFace
}

type VisionEpisodeHuman interface {
	// The reason for closing the episode.
	CloseReason() *EpisodeCloseReason
	// The reason for closing the episode.
	SetCloseReason(EpisodeCloseReason) VisionEpisodeHuman
	// Episode emitter can decide that episode considered closed and will not grow further.
	// `closed_at` MUST NOT change, it must be emitted only once.
	// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
	// of the episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	ClosedAt() *UtcMs
	// Episode emitter can decide that episode considered closed and will not grow further.
	// `closed_at` MUST NOT change, it must be emitted only once.
	// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
	// of the episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetClosedAt(UtcMs) VisionEpisodeHuman
	// Detections associated with this episode
	Detections() []VisionDetectedObjectBase
	// Detections associated with this episode
	SetDetections([]VisionDetectedObjectBase) VisionEpisodeHuman
	// The time when the episode appeared in the service relative to the server time.
	EpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps
	// The time when the episode appeared in the service relative to the server time.
	SetEpisodeAppearanceTimestamps(EpisodeAppearanceTimestamps) VisionEpisodeHuman
	// Unique identifier of the episode. Must be created by the system that first creates this episode.
	// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
	// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
	// handle very long integers.
	// Format: snowflake_id (snowflake_id)
	// Examples: 1.722279170848854e+18
	EpisodeID() SnowflakeID
	// Unique identifier of the episode. Must be created by the system that first creates this episode.
	// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
	// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
	// handle very long integers.
	// Format: snowflake_id (snowflake_id)
	// Examples: 1.722279170848854e+18
	SetEpisodeID(SnowflakeID) VisionEpisodeHuman
	// Human is detected
	EpisodeType() *string
	// Human is detected
	SetEpisodeType(string) VisionEpisodeHuman
	// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
	// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
	// Format: base64 (base64)
	FramePreview() *Base64
	// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
	// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
	// Format: base64 (base64)
	SetFramePreview(Base64) VisionEpisodeHuman
	// Stream name on which this episode exists.
	// Format: media_name (media_name)
	Media() MediaName
	// Stream name on which this episode exists.
	// Format: media_name (media_name)
	SetMedia(MediaName) VisionEpisodeHuman
	// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
	// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
	// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
	// sort as by `opened_at`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	OpenedAt() UtcMs
	// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
	// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
	// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
	// sort as by `opened_at`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetOpenedAt(UtcMs) VisionEpisodeHuman
	// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Format: base64 (base64)
	Preview() *Base64
	// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Format: base64 (base64)
	SetPreview(Base64) VisionEpisodeHuman
	// The time when the preview of this episode is available.
	// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
	// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
	// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
	// for details.
	// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	PreviewTimestamp() *UtcMs
	// The time when the preview of this episode is available.
	// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
	// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
	// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
	// for details.
	// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetPreviewTimestamp(UtcMs) VisionEpisodeHuman
	// This field can be used as indication of the fact that some system have checked and ensured that
	// this episode has really started at some time, that may differ from `opened_at`.
	// For example video analytics will use this field for the time when this episode was confirmed as confident.
	// May be not relevant for television systems.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	StartedAt() *UtcMs
	// This field can be used as indication of the fact that some system have checked and ensured that
	// this episode has really started at some time, that may differ from `opened_at`.
	// For example video analytics will use this field for the time when this episode was confirmed as confident.
	// May be not relevant for television systems.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetStartedAt(UtcMs) VisionEpisodeHuman
	// The time of last change of the episode.
	// System that processes episodes and can send them to other systems, MUST update this field
	// on any changes in this episode.
	// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
	// this `updated_at` can be used as a sort key for fetching fresh updates.
	// Consumer of the episodes can use `updated_at` in the following scenario:
	// * fetch all exisiting episodes from the source
	// * take biggest `updated_at` from this dataset, it will be T
	// * ask source for all episodes with `updated_at > T`
	// This algorithm can be used for fetching update stream from the source.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637098611e+12
	UpdatedAt() UtcMs
	// The time of last change of the episode.
	// System that processes episodes and can send them to other systems, MUST update this field
	// on any changes in this episode.
	// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
	// this `updated_at` can be used as a sort key for fetching fresh updates.
	// Consumer of the episodes can use `updated_at` in the following scenario:
	// * fetch all exisiting episodes from the source
	// * take biggest `updated_at` from this dataset, it will be T
	// * ask source for all episodes with `updated_at > T`
	// This algorithm can be used for fetching update stream from the source.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637098611e+12
	SetUpdatedAt(UtcMs) VisionEpisodeHuman
}

type VisionEpisodeQrCode interface {
	// The reason for closing the episode.
	CloseReason() *EpisodeCloseReason
	// The reason for closing the episode.
	SetCloseReason(EpisodeCloseReason) VisionEpisodeQrCode
	// Episode emitter can decide that episode considered closed and will not grow further.
	// `closed_at` MUST NOT change, it must be emitted only once.
	// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
	// of the episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	ClosedAt() *UtcMs
	// Episode emitter can decide that episode considered closed and will not grow further.
	// `closed_at` MUST NOT change, it must be emitted only once.
	// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
	// of the episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetClosedAt(UtcMs) VisionEpisodeQrCode
	// The time when the episode appeared in the service relative to the server time.
	EpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps
	// The time when the episode appeared in the service relative to the server time.
	SetEpisodeAppearanceTimestamps(EpisodeAppearanceTimestamps) VisionEpisodeQrCode
	// Unique identifier of the episode. Must be created by the system that first creates this episode.
	// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
	// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
	// handle very long integers.
	// Format: snowflake_id (snowflake_id)
	// Examples: 1.722279170848854e+18
	EpisodeID() SnowflakeID
	// Unique identifier of the episode. Must be created by the system that first creates this episode.
	// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
	// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
	// handle very long integers.
	// Format: snowflake_id (snowflake_id)
	// Examples: 1.722279170848854e+18
	SetEpisodeID(SnowflakeID) VisionEpisodeQrCode
	// QR-code is detected
	EpisodeType() *string
	// QR-code is detected
	SetEpisodeType(string) VisionEpisodeQrCode
	// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
	// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
	// Format: base64 (base64)
	FramePreview() *Base64
	// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
	// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
	// Format: base64 (base64)
	SetFramePreview(Base64) VisionEpisodeQrCode
	// Stream name on which this episode exists.
	// Format: media_name (media_name)
	Media() MediaName
	// Stream name on which this episode exists.
	// Format: media_name (media_name)
	SetMedia(MediaName) VisionEpisodeQrCode
	// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
	// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
	// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
	// sort as by `opened_at`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	OpenedAt() UtcMs
	// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
	// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
	// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
	// sort as by `opened_at`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetOpenedAt(UtcMs) VisionEpisodeQrCode
	// Raw data extracted from QR-code
	// Example: WIFI:T:WPA;S:MyOfficeWiFi;P:Mypassword;H:;
	Payload() *string
	// Raw data extracted from QR-code
	// Example: WIFI:T:WPA;S:MyOfficeWiFi;P:Mypassword;H:;
	SetPayload(string) VisionEpisodeQrCode
	// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Format: base64 (base64)
	Preview() *Base64
	// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Format: base64 (base64)
	SetPreview(Base64) VisionEpisodeQrCode
	// The time when the preview of this episode is available.
	// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
	// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
	// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
	// for details.
	// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	PreviewTimestamp() *UtcMs
	// The time when the preview of this episode is available.
	// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
	// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
	// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
	// for details.
	// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetPreviewTimestamp(UtcMs) VisionEpisodeQrCode
	// This field can be used as indication of the fact that some system have checked and ensured that
	// this episode has really started at some time, that may differ from `opened_at`.
	// For example video analytics will use this field for the time when this episode was confirmed as confident.
	// May be not relevant for television systems.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	StartedAt() *UtcMs
	// This field can be used as indication of the fact that some system have checked and ensured that
	// this episode has really started at some time, that may differ from `opened_at`.
	// For example video analytics will use this field for the time when this episode was confirmed as confident.
	// May be not relevant for television systems.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetStartedAt(UtcMs) VisionEpisodeQrCode
	// The time of last change of the episode.
	// System that processes episodes and can send them to other systems, MUST update this field
	// on any changes in this episode.
	// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
	// this `updated_at` can be used as a sort key for fetching fresh updates.
	// Consumer of the episodes can use `updated_at` in the following scenario:
	// * fetch all exisiting episodes from the source
	// * take biggest `updated_at` from this dataset, it will be T
	// * ask source for all episodes with `updated_at > T`
	// This algorithm can be used for fetching update stream from the source.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637098611e+12
	UpdatedAt() UtcMs
	// The time of last change of the episode.
	// System that processes episodes and can send them to other systems, MUST update this field
	// on any changes in this episode.
	// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
	// this `updated_at` can be used as a sort key for fetching fresh updates.
	// Consumer of the episodes can use `updated_at` in the following scenario:
	// * fetch all exisiting episodes from the source
	// * take biggest `updated_at` from this dataset, it will be T
	// * ask source for all episodes with `updated_at > T`
	// This algorithm can be used for fetching update stream from the source.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637098611e+12
	SetUpdatedAt(UtcMs) VisionEpisodeQrCode
}

type VisionEpisodeVehicle interface {
	// The reason for closing the episode.
	CloseReason() *EpisodeCloseReason
	// The reason for closing the episode.
	SetCloseReason(EpisodeCloseReason) VisionEpisodeVehicle
	// Episode emitter can decide that episode considered closed and will not grow further.
	// `closed_at` MUST NOT change, it must be emitted only once.
	// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
	// of the episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	ClosedAt() *UtcMs
	// Episode emitter can decide that episode considered closed and will not grow further.
	// `closed_at` MUST NOT change, it must be emitted only once.
	// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
	// of the episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetClosedAt(UtcMs) VisionEpisodeVehicle
	// Detections associated with this episode
	Detections() []any
	// Detections associated with this episode
	SetDetections([]any) VisionEpisodeVehicle
	// The time when the episode appeared in the service relative to the server time.
	EpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps
	// The time when the episode appeared in the service relative to the server time.
	SetEpisodeAppearanceTimestamps(EpisodeAppearanceTimestamps) VisionEpisodeVehicle
	// Unique identifier of the episode. Must be created by the system that first creates this episode.
	// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
	// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
	// handle very long integers.
	// Format: snowflake_id (snowflake_id)
	// Examples: 1.722279170848854e+18
	EpisodeID() SnowflakeID
	// Unique identifier of the episode. Must be created by the system that first creates this episode.
	// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
	// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
	// handle very long integers.
	// Format: snowflake_id (snowflake_id)
	// Examples: 1.722279170848854e+18
	SetEpisodeID(SnowflakeID) VisionEpisodeVehicle
	// Vehicle is detected
	EpisodeType() *string
	// Vehicle is detected
	SetEpisodeType(string) VisionEpisodeVehicle
	// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
	// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
	// Format: base64 (base64)
	FramePreview() *Base64
	// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
	// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
	// Format: base64 (base64)
	SetFramePreview(Base64) VisionEpisodeVehicle
	// Indicates if no license plate is detected on this vehicle
	LicensePlateMissing() *bool
	// Indicates if no license plate is detected on this vehicle
	SetLicensePlateMissing(bool) VisionEpisodeVehicle
	// Recognized vehicle's license plate number
	LicensePlateText() *string
	// Recognized vehicle's license plate number
	SetLicensePlateText(string) VisionEpisodeVehicle
	// Stream name on which this episode exists.
	// Format: media_name (media_name)
	Media() MediaName
	// Stream name on which this episode exists.
	// Format: media_name (media_name)
	SetMedia(MediaName) VisionEpisodeVehicle
	// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
	// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
	// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
	// sort as by `opened_at`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	OpenedAt() UtcMs
	// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
	// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
	// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
	// sort as by `opened_at`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetOpenedAt(UtcMs) VisionEpisodeVehicle
	// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Preview contains an image of vehicle's license plate and has a resolution about 160 x 64 pixels with maximum size about 10 kilobytes.
	// Format: base64 (base64)
	Preview() Base64
	// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Preview contains an image of vehicle's license plate and has a resolution about 160 x 64 pixels with maximum size about 10 kilobytes.
	// Format: base64 (base64)
	SetPreview(Base64) VisionEpisodeVehicle
	// The time when the preview of this episode is available.
	// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
	// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
	// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
	// for details.
	// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	PreviewTimestamp() *UtcMs
	// The time when the preview of this episode is available.
	// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
	// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
	// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
	// for details.
	// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetPreviewTimestamp(UtcMs) VisionEpisodeVehicle
	// This field can be used as indication of the fact that some system have checked and ensured that
	// this episode has really started at some time, that may differ from `opened_at`.
	// For example video analytics will use this field for the time when this episode was confirmed as confident.
	// May be not relevant for television systems.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	StartedAt() *UtcMs
	// This field can be used as indication of the fact that some system have checked and ensured that
	// this episode has really started at some time, that may differ from `opened_at`.
	// For example video analytics will use this field for the time when this episode was confirmed as confident.
	// May be not relevant for television systems.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetStartedAt(UtcMs) VisionEpisodeVehicle
	// The time of last change of the episode.
	// System that processes episodes and can send them to other systems, MUST update this field
	// on any changes in this episode.
	// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
	// this `updated_at` can be used as a sort key for fetching fresh updates.
	// Consumer of the episodes can use `updated_at` in the following scenario:
	// * fetch all exisiting episodes from the source
	// * take biggest `updated_at` from this dataset, it will be T
	// * ask source for all episodes with `updated_at > T`
	// This algorithm can be used for fetching update stream from the source.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637098611e+12
	UpdatedAt() UtcMs
	// The time of last change of the episode.
	// System that processes episodes and can send them to other systems, MUST update this field
	// on any changes in this episode.
	// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
	// this `updated_at` can be used as a sort key for fetching fresh updates.
	// Consumer of the episodes can use `updated_at` in the following scenario:
	// * fetch all exisiting episodes from the source
	// * take biggest `updated_at` from this dataset, it will be T
	// * ask source for all episodes with `updated_at > T`
	// This algorithm can be used for fetching update stream from the source.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637098611e+12
	SetUpdatedAt(UtcMs) VisionEpisodeVehicle
	// Emergency type of the vehicle.
	VehicleEmergencySubtype() *VisionVehicleEmergencySubtype
	// Emergency type of the vehicle.
	SetVehicleEmergencySubtype(VisionVehicleEmergencySubtype) VisionEpisodeVehicle
	// Shows from which side the vehicle was detected.
	VehicleFacingSide() *VisionVehicleFacingSide
	// Shows from which side the vehicle was detected.
	SetVehicleFacingSide(VisionVehicleFacingSide) VisionEpisodeVehicle
	// The purpose of the vehicle, e.g. emergency or regular.
	VehiclePurpose() *VisionVehiclePurpose
	// The purpose of the vehicle, e.g. emergency or regular.
	SetVehiclePurpose(VisionVehiclePurpose) VisionEpisodeVehicle
}

type VisionFaceAttributes interface {
	// The fingerprint of the detected face
	Fingerprint() VisionFaceFingerprint
	// The fingerprint of the detected face
	SetFingerprint(VisionFaceFingerprint) VisionFaceAttributes
}

// Digital fingerprint of the face
// Required: data, version
type VisionFaceFingerprint interface {
	// Base64 encoded representation of the fingerprint
	// Format: base64 (base64)
	Data() Base64
	// Base64 encoded representation of the fingerprint
	// Format: base64 (base64)
	SetData(Base64) VisionFaceFingerprint
	// Version identifier of the fingerprint's data. The version is assigned automatically.
	// Fingerprints of different versions cannot be compared to each other.
	// Examples: aabbccdd, c6ba4246
	Version() string
	// Version identifier of the fingerprint's data. The version is assigned automatically.
	// Fingerprints of different versions cannot be compared to each other.
	// Examples: aabbccdd, c6ba4246
	SetVersion(string) VisionFaceFingerprint
}

// Required: data
type VisionImageAttributes interface {
	// Base64-encoded image data
	// Format: base64 (base64)
	Data() Base64
	// Base64-encoded image data
	// Format: base64 (base64)
	SetData(Base64) VisionImageAttributes
	// MIME type of the image
	MimeType() *VisionImageMimetype
	// MIME type of the image
	SetMimeType(VisionImageMimetype) VisionImageAttributes
	// Checksum of this image
	// Format: hexbinary (hexbinary)
	Sha256() *Hexbinary
	// Checksum of this image
	// Format: hexbinary (hexbinary)
	SetSha256(Hexbinary) VisionImageAttributes
}

// Attributes of the detected vehicle
type VisionLicensePlateAttributes interface {
	// Shows from which side the vehicle was detected.
	FacingSide() *VisionVehicleFacingSide
	// Shows from which side the vehicle was detected.
	SetFacingSide(VisionVehicleFacingSide) VisionLicensePlateAttributes
	// Recognized vehicle's license plate number
	PlateText() *string
	// Recognized vehicle's license plate number
	SetPlateText(string) VisionLicensePlateAttributes
}

// Person
// Required: person_id, updated_at, originator
type VisionPerson interface {
	// When this person was marked as deleted
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637095014573e+12
	DeletedAt() *UtcMs
	// When this person was marked as deleted
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637095014573e+12
	SetDeletedAt(UtcMs) VisionPerson
	// Identifier of the person in the external system.
	// Use it when supplying the recognition results further into the external system
	// (e.g. for access level check) if the person identifiers in the external system
	// are different from the ones in Flussonic Identification database.
	// This field may contain `null` when video analytics detects a new person
	// which explicitly has no association in the external system (i.e. if `originator=identification_service`).
	// Examples: dedcc8e8
	ExternalID() *string
	// Identifier of the person in the external system.
	// Use it when supplying the recognition results further into the external system
	// (e.g. for access level check) if the person identifiers in the external system
	// are different from the ones in Flussonic Identification database.
	// This field may contain `null` when video analytics detects a new person
	// which explicitly has no association in the external system (i.e. if `originator=identification_service`).
	// Examples: dedcc8e8
	SetExternalID(string) VisionPerson
	// When this person was first seen
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637034282845e+12
	FirstSeenAt() *UtcMs
	// When this person was first seen
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637034282845e+12
	SetFirstSeenAt(UtcMs) VisionPerson
	// When this person was last seen
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637095014573e+12
	LastSeenAt() *UtcMs
	// When this person was last seen
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637095014573e+12
	SetLastSeenAt(UtcMs) VisionPerson
	// The name of the person filled in manually or automatically if not recognized
	// Examples: John Doe, Unknown ABC
	Name() *string
	// The name of the person filled in manually or automatically if not recognized
	// Examples: John Doe, Unknown ABC
	SetName(string) VisionPerson
	// Organization information.
	Organization() OrganizationBase
	// Organization information.
	SetOrganization(OrganizationBase) VisionPerson
	// Indicates the way this person was created:
	// manually via an api or automatically in the identification service.
	Originator() VisionPersonOriginator
	// Indicates the way this person was created:
	// manually via an api or automatically in the identification service.
	SetOriginator(VisionPersonOriginator) VisionPerson
	// Identifier of the person
	// Format: snowflake_id (snowflake_id)
	// Examples: 7.036001172460667e+18
	PersonID() SnowflakeID
	// Identifier of the person
	// Format: snowflake_id (snowflake_id)
	// Examples: 7.036001172460667e+18
	SetPersonID(SnowflakeID) VisionPerson
	// Person list details
	PersonList() VisionPersonPersonList
	// Person list details
	SetPersonList(VisionPersonPersonList) VisionPerson
	// Person's photos. External system uploads images
	// which are being processed by videoanalytics
	// to get digital fingerprint of the person
	Photos() []VisionImageAttributes
	// Person's photos. External system uploads images
	// which are being processed by videoanalytics
	// to get digital fingerprint of the person
	SetPhotos([]VisionImageAttributes) VisionPerson
	// When this person was last updated
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637034282845e+12
	UpdatedAt() UtcMs
	// When this person was last updated
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.637034282845e+12
	SetUpdatedAt(UtcMs) VisionPerson
}

// Person matching information
// Required: person, match_score
type VisionPersonMatch interface {
	// Score of the match with person. 1.0 means absolute match
	MatchScore() float64
	// Score of the match with person. 1.0 means absolute match
	SetMatchScore(float64) VisionPersonMatch
	// Matched person
	Person() VisionPerson
	// Matched person
	SetPerson(VisionPerson) VisionPersonMatch
}

// Person list details
type VisionPersonPersonList interface {
	// Person list identifier
	// Example: 3
	ID() *int
	// Person list identifier
	// Example: 3
	SetID(int) VisionPersonPersonList
	// Person list name
	// Example: List 1
	Name() *string
	// Person list name
	// Example: List 1
	SetName(string) VisionPersonPersonList
}

// 2D point
// Required: x, y
type VisionPoint interface {
	// X coordinate. Fraction of full frame width
	// Examples: 0.54, 0.78
	X() float64
	// X coordinate. Fraction of full frame width
	// Examples: 0.54, 0.78
	SetX(float64) VisionPoint
	// Y coordinate. Fraction of full frame height
	// Examples: 0.12, 0.38
	Y() float64
	// Y coordinate. Fraction of full frame height
	// Examples: 0.12, 0.38
	SetY(float64) VisionPoint
}

type VisionSpec interface {
	// The algorithm used for video analytics.
	// Example: faces
	Alg() *VisionSpecAlg
	// The algorithm used for video analytics.
	// Example: faces
	SetAlg(VisionSpecAlg) VisionSpec
	// This parameter allows you to select specific polygonal area(s) for detection.
	// By default, it is empty, and the recognition system searches over the entire camera field of view.
	// Each area is specified as a sequence of comma-separated coordinates of vertices of the polygon: `x0,y0,x1,y1,x2,y2,...`.
	// The vertices are specified in a counter-clockwise direction. Multiple areas are separated by `:`.
	Areas() *string
	// This parameter allows you to select specific polygonal area(s) for detection.
	// By default, it is empty, and the recognition system searches over the entire camera field of view.
	// Each area is specified as a sequence of comma-separated coordinates of vertices of the polygon: `x0,y0,x1,y1,x2,y2,...`.
	// The vertices are specified in a counter-clockwise direction. Multiple areas are separated by `:`.
	SetAreas(string) VisionSpec
	// Configuration of videoanalytics modules.
	// This configuration supersedes `alg` and `areas` parameters.
	// If this field is specified, values of `alg` and `areas` fields are being ignored.
	Detectors() []VisionDetectorConfig
	// Configuration of videoanalytics modules.
	// This configuration supersedes `alg` and `areas` parameters.
	// If this field is specified, values of `alg` and `areas` fields are being ignored.
	SetDetectors([]VisionDetectorConfig) VisionSpec
}

type VisionSpecPresets interface {
	// The algorithm used for video analytics.
	// Example: faces
	Alg() *VisionSpecPresetsAlg
	// The algorithm used for video analytics.
	// Example: faces
	SetAlg(VisionSpecPresetsAlg) VisionSpecPresets
}

type VisionVehicleAttributes interface {
	// Indicates if no license plate is detected on this vehicle
	LicensePlateMissing() *bool
	// Indicates if no license plate is detected on this vehicle
	SetLicensePlateMissing(bool) VisionVehicleAttributes
	// The purpose of the vehicle, e.g. emergency or regular.
	Purpose() *VisionVehiclePurpose
	// The purpose of the vehicle, e.g. emergency or regular.
	SetPurpose(VisionVehiclePurpose) VisionVehicleAttributes
}

type WatcherEpisode interface {
	// The reason for closing the episode.
	CloseReason() *EpisodeCloseReason
	// The reason for closing the episode.
	SetCloseReason(EpisodeCloseReason) WatcherEpisode
	// Episode emitter can decide that episode considered closed and will not grow further.
	// `closed_at` MUST NOT change, it must be emitted only once.
	// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
	// of the episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	ClosedAt() *UtcMs
	// Episode emitter can decide that episode considered closed and will not grow further.
	// `closed_at` MUST NOT change, it must be emitted only once.
	// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
	// of the episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetClosedAt(UtcMs) WatcherEpisode
	// Optional description of the episode. Can be used to provide additional context or details about the episode.
	// Example: Person detected at the main entrance, stayed for 30 seconds
	Description() *string
	// Optional description of the episode. Can be used to provide additional context or details about the episode.
	// Example: Person detected at the main entrance, stayed for 30 seconds
	SetDescription(string) WatcherEpisode
	// Detections associated with this episode
	Detections() any
	// Detections associated with this episode
	SetDetections(any) WatcherEpisode
	// Duration of the episode in milliseconds.
	// Format: milliseconds (milliseconds)
	// Example: 10500
	Duration() *Milliseconds
	// Duration of the episode in milliseconds.
	// Format: milliseconds (milliseconds)
	// Example: 10500
	SetDuration(Milliseconds) WatcherEpisode
	// The time when the episode appeared in the service relative to the server time.
	EpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps
	// The time when the episode appeared in the service relative to the server time.
	SetEpisodeAppearanceTimestamps(EpisodeAppearanceTimestamps) WatcherEpisode
	// Unique identifier of the episode. Must be created by the system that first creates this episode.
	// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
	// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
	// handle very long integers.
	// Format: snowflake_id (snowflake_id)
	// Examples: 1.722279170848854e+18
	EpisodeID() SnowflakeID
	// Unique identifier of the episode. Must be created by the system that first creates this episode.
	// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
	// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
	// handle very long integers.
	// Format: snowflake_id (snowflake_id)
	// Examples: 1.722279170848854e+18
	SetEpisodeID(SnowflakeID) WatcherEpisode
	// Generic stream episode/Face is detected/Vehicle is detected/Human is detected/Episode matches context search text query/QR-code is detected/Custom episode type.
	// Use this field to define your own episode types when integrating custom analytics.
	// If episode type is not specified, episode will be saved with `generic` type.
	EpisodeType() *string
	// Generic stream episode/Face is detected/Vehicle is detected/Human is detected/Episode matches context search text query/QR-code is detected/Custom episode type.
	// Use this field to define your own episode types when integrating custom analytics.
	// If episode type is not specified, episode will be saved with `generic` type.
	SetEpisodeType(string) WatcherEpisode
	// The fingerprint of the detected face
	Fingerprint() VisionFaceFingerprint
	// The fingerprint of the detected face
	SetFingerprint(VisionFaceFingerprint) WatcherEpisode
	// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
	// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
	// Format: base64 (base64)
	FramePreview() *Base64
	// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
	// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
	// Format: base64 (base64)
	SetFramePreview(Base64) WatcherEpisode
	// Whether the episode is added to favorites.
	// Example: false
	IsFavorite() *bool
	// Whether the episode is added to favorites.
	// Example: false
	SetIsFavorite(bool) WatcherEpisode
	// Indicates if no license plate is detected on this vehicle
	LicensePlateMissing() *bool
	// Indicates if no license plate is detected on this vehicle
	SetLicensePlateMissing(bool) WatcherEpisode
	// Recognized vehicle's license plate number
	LicensePlateText() *string
	// Recognized vehicle's license plate number
	SetLicensePlateText(string) WatcherEpisode
	// Maximum matching score between the text query and episode.
	// Examples: 0.2345
	MatchScore() *float64
	// Maximum matching score between the text query and episode.
	// Examples: 0.2345
	SetMatchScore(float64) WatcherEpisode
	// List of matched persons with similarity metric.
	// Videoanalytics identification service enriches episode's data and fills this field
	// with the list of persons that are similar to the face detected in this episode.
	MatchedPersons() []VisionPersonMatch
	// List of matched persons with similarity metric.
	// Videoanalytics identification service enriches episode's data and fills this field
	// with the list of persons that are similar to the face detected in this episode.
	SetMatchedPersons([]VisionPersonMatch) WatcherEpisode
	// Stream name on which this episode exists.
	// Format: media_name (media_name)
	Media() MediaName
	// Stream name on which this episode exists.
	// Format: media_name (media_name)
	SetMedia(MediaName) WatcherEpisode
	// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
	// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
	// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
	// sort as by `opened_at`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	OpenedAt() UtcMs
	// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
	// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
	// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
	// sort as by `opened_at`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetOpenedAt(UtcMs) WatcherEpisode
	// Raw data extracted from QR-code/Custom episode payload. Use this field to provide additional information about the episode.
	Payload() any
	// Raw data extracted from QR-code/Custom episode payload. Use this field to provide additional information about the episode.
	SetPayload(any) WatcherEpisode
	// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
	// Example: onetime_token
	PlaybackToken() *string
	// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
	// Example: onetime_token
	SetPlaybackToken(string) WatcherEpisode
	// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// /Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Preview contains an image of person's face and has a resolution about 200 x 200 pixels with maximum size about 10 kilobytes.
	// /Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Preview contains an image of vehicle's license plate and has a resolution about 160 x 64 pixels with maximum size about 10 kilobytes.
	Preview() *Base64
	// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// /Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Preview contains an image of person's face and has a resolution about 200 x 200 pixels with maximum size about 10 kilobytes.
	// /Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Preview contains an image of vehicle's license plate and has a resolution about 160 x 64 pixels with maximum size about 10 kilobytes.
	SetPreview(Base64) WatcherEpisode
	// The time when the preview of this episode is available.
	// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
	// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
	// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
	// for details.
	// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	PreviewTimestamp() *UtcMs
	// The time when the preview of this episode is available.
	// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
	// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
	// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
	// for details.
	// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetPreviewTimestamp(UtcMs) WatcherEpisode
	// This field can be used as indication of the fact that some system have checked and ensured that
	// this episode has really started at some time, that may differ from `opened_at`.
	// For example video analytics will use this field for the time when this episode was confirmed as confident.
	// May be not relevant for television systems.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	StartedAt() *UtcMs
	// This field can be used as indication of the fact that some system have checked and ensured that
	// this episode has really started at some time, that may differ from `opened_at`.
	// For example video analytics will use this field for the time when this episode was confirmed as confident.
	// May be not relevant for television systems.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetStartedAt(UtcMs) WatcherEpisode
	// Details about stream related to the episode.
	Stream() EpisodeStreamDetailsStream
	// Details about stream related to the episode.
	SetStream(EpisodeStreamDetailsStream) WatcherEpisode
	// HTTP(s) URL that can be used for streaming API of this episode
	// Example: https://streamer.example.com
	StreamingEndpoint() *string
	// HTTP(s) URL that can be used for streaming API of this episode
	// Example: https://streamer.example.com
	SetStreamingEndpoint(string) WatcherEpisode
	// Optional title of the episode. Can be used to provide a human-readable name for the episode.
	// Example: Visitor at main entrance
	Title() *string
	// Optional title of the episode. Can be used to provide a human-readable name for the episode.
	// Example: Visitor at main entrance
	SetTitle(string) WatcherEpisode
	// The time of last change of the episode.
	// System that processes episodes and can send them to other systems, MUST update this field
	// on any changes in this episode.
	// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
	// this `updated_at` can be used as a sort key for fetching fresh updates.
	// Consumer of the episodes can use `updated_at` in the following scenario:
	// * fetch all exisiting episodes from the source
	// * take biggest `updated_at` from this dataset, it will be T
	// * ask source for all episodes with `updated_at > T`
	// This algorithm can be used for fetching update stream from the source.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637098611e+12
	UpdatedAt() UtcMs
	// The time of last change of the episode.
	// System that processes episodes and can send them to other systems, MUST update this field
	// on any changes in this episode.
	// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
	// this `updated_at` can be used as a sort key for fetching fresh updates.
	// Consumer of the episodes can use `updated_at` in the following scenario:
	// * fetch all exisiting episodes from the source
	// * take biggest `updated_at` from this dataset, it will be T
	// * ask source for all episodes with `updated_at > T`
	// This algorithm can be used for fetching update stream from the source.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637098611e+12
	SetUpdatedAt(UtcMs) WatcherEpisode
	// Emergency type of the vehicle.
	VehicleEmergencySubtype() *VisionVehicleEmergencySubtype
	// Emergency type of the vehicle.
	SetVehicleEmergencySubtype(VisionVehicleEmergencySubtype) WatcherEpisode
	// Shows from which side the vehicle was detected.
	VehicleFacingSide() *VisionVehicleFacingSide
	// Shows from which side the vehicle was detected.
	SetVehicleFacingSide(VisionVehicleFacingSide) WatcherEpisode
	// The purpose of the vehicle, e.g. emergency or regular.
	VehiclePurpose() *VisionVehiclePurpose
	// The purpose of the vehicle, e.g. emergency or regular.
	SetVehiclePurpose(VisionVehiclePurpose) WatcherEpisode
}

// Base properties added by Watcher to all episode types
type WatcherEpisodeBase interface {
	// Optional description of the episode. Can be used to provide additional context or details about the episode.
	// Example: Person detected at the main entrance, stayed for 30 seconds
	Description() *string
	// Optional description of the episode. Can be used to provide additional context or details about the episode.
	// Example: Person detected at the main entrance, stayed for 30 seconds
	SetDescription(string) WatcherEpisodeBase
	// Duration of the episode in milliseconds.
	// Format: milliseconds (milliseconds)
	// Example: 10500
	Duration() *Milliseconds
	// Duration of the episode in milliseconds.
	// Format: milliseconds (milliseconds)
	// Example: 10500
	SetDuration(Milliseconds) WatcherEpisodeBase
	// Whether the episode is added to favorites.
	// Example: false
	IsFavorite() *bool
	// Whether the episode is added to favorites.
	// Example: false
	SetIsFavorite(bool) WatcherEpisodeBase
	// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
	// Example: onetime_token
	PlaybackToken() *string
	// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
	// Example: onetime_token
	SetPlaybackToken(string) WatcherEpisodeBase
	// Details about stream related to the episode.
	Stream() EpisodeStreamDetailsStream
	// Details about stream related to the episode.
	SetStream(EpisodeStreamDetailsStream) WatcherEpisodeBase
	// HTTP(s) URL that can be used for streaming API of this episode
	// Example: https://streamer.example.com
	StreamingEndpoint() *string
	// HTTP(s) URL that can be used for streaming API of this episode
	// Example: https://streamer.example.com
	SetStreamingEndpoint(string) WatcherEpisodeBase
	// Optional title of the episode. Can be used to provide a human-readable name for the episode.
	// Example: Visitor at main entrance
	Title() *string
	// Optional title of the episode. Can be used to provide a human-readable name for the episode.
	// Example: Visitor at main entrance
	SetTitle(string) WatcherEpisodeBase
}

type WatcherEpisodeContextSearch interface {
	// The reason for closing the episode.
	CloseReason() *EpisodeCloseReason
	// The reason for closing the episode.
	SetCloseReason(EpisodeCloseReason) WatcherEpisodeContextSearch
	// Episode emitter can decide that episode considered closed and will not grow further.
	// `closed_at` MUST NOT change, it must be emitted only once.
	// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
	// of the episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	ClosedAt() *UtcMs
	// Episode emitter can decide that episode considered closed and will not grow further.
	// `closed_at` MUST NOT change, it must be emitted only once.
	// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
	// of the episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetClosedAt(UtcMs) WatcherEpisodeContextSearch
	// Optional description of the episode. Can be used to provide additional context or details about the episode.
	// Example: Person detected at the main entrance, stayed for 30 seconds
	Description() *string
	// Optional description of the episode. Can be used to provide additional context or details about the episode.
	// Example: Person detected at the main entrance, stayed for 30 seconds
	SetDescription(string) WatcherEpisodeContextSearch
	// Duration of the episode in milliseconds.
	// Format: milliseconds (milliseconds)
	// Example: 10500
	Duration() *Milliseconds
	// Duration of the episode in milliseconds.
	// Format: milliseconds (milliseconds)
	// Example: 10500
	SetDuration(Milliseconds) WatcherEpisodeContextSearch
	// The time when the episode appeared in the service relative to the server time.
	EpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps
	// The time when the episode appeared in the service relative to the server time.
	SetEpisodeAppearanceTimestamps(EpisodeAppearanceTimestamps) WatcherEpisodeContextSearch
	// Unique identifier of the episode. Must be created by the system that first creates this episode.
	// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
	// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
	// handle very long integers.
	// Format: snowflake_id (snowflake_id)
	// Examples: 1.722279170848854e+18
	EpisodeID() SnowflakeID
	// Unique identifier of the episode. Must be created by the system that first creates this episode.
	// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
	// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
	// handle very long integers.
	// Format: snowflake_id (snowflake_id)
	// Examples: 1.722279170848854e+18
	SetEpisodeID(SnowflakeID) WatcherEpisodeContextSearch
	// Episode matches context search text query
	EpisodeType() *string
	// Episode matches context search text query
	SetEpisodeType(string) WatcherEpisodeContextSearch
	// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
	// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
	// Format: base64 (base64)
	FramePreview() *Base64
	// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
	// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
	// Format: base64 (base64)
	SetFramePreview(Base64) WatcherEpisodeContextSearch
	// Whether the episode is added to favorites.
	// Example: false
	IsFavorite() *bool
	// Whether the episode is added to favorites.
	// Example: false
	SetIsFavorite(bool) WatcherEpisodeContextSearch
	// Maximum matching score between the text query and episode.
	// Examples: 0.2345
	MatchScore() *float64
	// Maximum matching score between the text query and episode.
	// Examples: 0.2345
	SetMatchScore(float64) WatcherEpisodeContextSearch
	// Stream name on which this episode exists.
	// Format: media_name (media_name)
	Media() MediaName
	// Stream name on which this episode exists.
	// Format: media_name (media_name)
	SetMedia(MediaName) WatcherEpisodeContextSearch
	// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
	// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
	// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
	// sort as by `opened_at`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	OpenedAt() UtcMs
	// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
	// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
	// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
	// sort as by `opened_at`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetOpenedAt(UtcMs) WatcherEpisodeContextSearch
	// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
	// Example: onetime_token
	PlaybackToken() *string
	// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
	// Example: onetime_token
	SetPlaybackToken(string) WatcherEpisodeContextSearch
	// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Format: base64 (base64)
	Preview() *Base64
	// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Format: base64 (base64)
	SetPreview(Base64) WatcherEpisodeContextSearch
	// The time when the preview of this episode is available.
	// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
	// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
	// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
	// for details.
	// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	PreviewTimestamp() *UtcMs
	// The time when the preview of this episode is available.
	// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
	// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
	// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
	// for details.
	// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetPreviewTimestamp(UtcMs) WatcherEpisodeContextSearch
	// This field can be used as indication of the fact that some system have checked and ensured that
	// this episode has really started at some time, that may differ from `opened_at`.
	// For example video analytics will use this field for the time when this episode was confirmed as confident.
	// May be not relevant for television systems.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	StartedAt() *UtcMs
	// This field can be used as indication of the fact that some system have checked and ensured that
	// this episode has really started at some time, that may differ from `opened_at`.
	// For example video analytics will use this field for the time when this episode was confirmed as confident.
	// May be not relevant for television systems.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetStartedAt(UtcMs) WatcherEpisodeContextSearch
	// Details about stream related to the episode.
	Stream() EpisodeStreamDetailsStream
	// Details about stream related to the episode.
	SetStream(EpisodeStreamDetailsStream) WatcherEpisodeContextSearch
	// HTTP(s) URL that can be used for streaming API of this episode
	// Example: https://streamer.example.com
	StreamingEndpoint() *string
	// HTTP(s) URL that can be used for streaming API of this episode
	// Example: https://streamer.example.com
	SetStreamingEndpoint(string) WatcherEpisodeContextSearch
	// Optional title of the episode. Can be used to provide a human-readable name for the episode.
	// Example: Visitor at main entrance
	Title() *string
	// Optional title of the episode. Can be used to provide a human-readable name for the episode.
	// Example: Visitor at main entrance
	SetTitle(string) WatcherEpisodeContextSearch
	// The time of last change of the episode.
	// System that processes episodes and can send them to other systems, MUST update this field
	// on any changes in this episode.
	// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
	// this `updated_at` can be used as a sort key for fetching fresh updates.
	// Consumer of the episodes can use `updated_at` in the following scenario:
	// * fetch all exisiting episodes from the source
	// * take biggest `updated_at` from this dataset, it will be T
	// * ask source for all episodes with `updated_at > T`
	// This algorithm can be used for fetching update stream from the source.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637098611e+12
	UpdatedAt() UtcMs
	// The time of last change of the episode.
	// System that processes episodes and can send them to other systems, MUST update this field
	// on any changes in this episode.
	// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
	// this `updated_at` can be used as a sort key for fetching fresh updates.
	// Consumer of the episodes can use `updated_at` in the following scenario:
	// * fetch all exisiting episodes from the source
	// * take biggest `updated_at` from this dataset, it will be T
	// * ask source for all episodes with `updated_at > T`
	// This algorithm can be used for fetching update stream from the source.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637098611e+12
	SetUpdatedAt(UtcMs) WatcherEpisodeContextSearch
}

type WatcherEpisodeCustom interface {
	// The reason for closing the episode.
	CloseReason() *EpisodeCloseReason
	// The reason for closing the episode.
	SetCloseReason(EpisodeCloseReason) WatcherEpisodeCustom
	// Episode emitter can decide that episode considered closed and will not grow further.
	// `closed_at` MUST NOT change, it must be emitted only once.
	// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
	// of the episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	ClosedAt() *UtcMs
	// Episode emitter can decide that episode considered closed and will not grow further.
	// `closed_at` MUST NOT change, it must be emitted only once.
	// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
	// of the episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetClosedAt(UtcMs) WatcherEpisodeCustom
	// Optional description of the episode. Can be used to provide additional context or details about the episode.
	// Example: Person detected at the main entrance, stayed for 30 seconds
	Description() *string
	// Optional description of the episode. Can be used to provide additional context or details about the episode.
	// Example: Person detected at the main entrance, stayed for 30 seconds
	SetDescription(string) WatcherEpisodeCustom
	// Duration of the episode in milliseconds.
	// Format: milliseconds (milliseconds)
	// Example: 10500
	Duration() *Milliseconds
	// Duration of the episode in milliseconds.
	// Format: milliseconds (milliseconds)
	// Example: 10500
	SetDuration(Milliseconds) WatcherEpisodeCustom
	// The time when the episode appeared in the service relative to the server time.
	EpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps
	// The time when the episode appeared in the service relative to the server time.
	SetEpisodeAppearanceTimestamps(EpisodeAppearanceTimestamps) WatcherEpisodeCustom
	// Unique identifier of the episode. Must be created by the system that first creates this episode.
	// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
	// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
	// handle very long integers.
	// Format: snowflake_id (snowflake_id)
	// Examples: 1.722279170848854e+18
	EpisodeID() SnowflakeID
	// Unique identifier of the episode. Must be created by the system that first creates this episode.
	// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
	// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
	// handle very long integers.
	// Format: snowflake_id (snowflake_id)
	// Examples: 1.722279170848854e+18
	SetEpisodeID(SnowflakeID) WatcherEpisodeCustom
	// Custom episode type.
	// Use this field to define your own episode types when integrating custom analytics.
	// If episode type is not specified, episode will be saved with `generic` type.
	EpisodeType() *string
	// Custom episode type.
	// Use this field to define your own episode types when integrating custom analytics.
	// If episode type is not specified, episode will be saved with `generic` type.
	SetEpisodeType(string) WatcherEpisodeCustom
	// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
	// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
	// Format: base64 (base64)
	FramePreview() *Base64
	// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
	// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
	// Format: base64 (base64)
	SetFramePreview(Base64) WatcherEpisodeCustom
	// Whether the episode is added to favorites.
	// Example: false
	IsFavorite() *bool
	// Whether the episode is added to favorites.
	// Example: false
	SetIsFavorite(bool) WatcherEpisodeCustom
	// Stream name on which this episode exists.
	// Format: media_name (media_name)
	Media() MediaName
	// Stream name on which this episode exists.
	// Format: media_name (media_name)
	SetMedia(MediaName) WatcherEpisodeCustom
	// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
	// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
	// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
	// sort as by `opened_at`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	OpenedAt() UtcMs
	// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
	// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
	// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
	// sort as by `opened_at`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetOpenedAt(UtcMs) WatcherEpisodeCustom
	// Custom episode payload. Use this field to provide additional information about the episode.
	Payload() any
	// Custom episode payload. Use this field to provide additional information about the episode.
	SetPayload(any) WatcherEpisodeCustom
	// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
	// Example: onetime_token
	PlaybackToken() *string
	// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
	// Example: onetime_token
	SetPlaybackToken(string) WatcherEpisodeCustom
	// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Format: base64 (base64)
	Preview() *Base64
	// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Format: base64 (base64)
	SetPreview(Base64) WatcherEpisodeCustom
	// The time when the preview of this episode is available.
	// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
	// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
	// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
	// for details.
	// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	PreviewTimestamp() *UtcMs
	// The time when the preview of this episode is available.
	// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
	// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
	// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
	// for details.
	// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetPreviewTimestamp(UtcMs) WatcherEpisodeCustom
	// This field can be used as indication of the fact that some system have checked and ensured that
	// this episode has really started at some time, that may differ from `opened_at`.
	// For example video analytics will use this field for the time when this episode was confirmed as confident.
	// May be not relevant for television systems.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	StartedAt() *UtcMs
	// This field can be used as indication of the fact that some system have checked and ensured that
	// this episode has really started at some time, that may differ from `opened_at`.
	// For example video analytics will use this field for the time when this episode was confirmed as confident.
	// May be not relevant for television systems.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetStartedAt(UtcMs) WatcherEpisodeCustom
	// Details about stream related to the episode.
	Stream() EpisodeStreamDetailsStream
	// Details about stream related to the episode.
	SetStream(EpisodeStreamDetailsStream) WatcherEpisodeCustom
	// HTTP(s) URL that can be used for streaming API of this episode
	// Example: https://streamer.example.com
	StreamingEndpoint() *string
	// HTTP(s) URL that can be used for streaming API of this episode
	// Example: https://streamer.example.com
	SetStreamingEndpoint(string) WatcherEpisodeCustom
	// Optional title of the episode. Can be used to provide a human-readable name for the episode.
	// Example: Visitor at main entrance
	Title() *string
	// Optional title of the episode. Can be used to provide a human-readable name for the episode.
	// Example: Visitor at main entrance
	SetTitle(string) WatcherEpisodeCustom
	// The time of last change of the episode.
	// System that processes episodes and can send them to other systems, MUST update this field
	// on any changes in this episode.
	// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
	// this `updated_at` can be used as a sort key for fetching fresh updates.
	// Consumer of the episodes can use `updated_at` in the following scenario:
	// * fetch all exisiting episodes from the source
	// * take biggest `updated_at` from this dataset, it will be T
	// * ask source for all episodes with `updated_at > T`
	// This algorithm can be used for fetching update stream from the source.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637098611e+12
	UpdatedAt() UtcMs
	// The time of last change of the episode.
	// System that processes episodes and can send them to other systems, MUST update this field
	// on any changes in this episode.
	// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
	// this `updated_at` can be used as a sort key for fetching fresh updates.
	// Consumer of the episodes can use `updated_at` in the following scenario:
	// * fetch all exisiting episodes from the source
	// * take biggest `updated_at` from this dataset, it will be T
	// * ask source for all episodes with `updated_at > T`
	// This algorithm can be used for fetching update stream from the source.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637098611e+12
	SetUpdatedAt(UtcMs) WatcherEpisodeCustom
}

type WatcherEpisodeFace interface {
	// The reason for closing the episode.
	CloseReason() *EpisodeCloseReason
	// The reason for closing the episode.
	SetCloseReason(EpisodeCloseReason) WatcherEpisodeFace
	// Episode emitter can decide that episode considered closed and will not grow further.
	// `closed_at` MUST NOT change, it must be emitted only once.
	// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
	// of the episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	ClosedAt() *UtcMs
	// Episode emitter can decide that episode considered closed and will not grow further.
	// `closed_at` MUST NOT change, it must be emitted only once.
	// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
	// of the episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetClosedAt(UtcMs) WatcherEpisodeFace
	// Optional description of the episode. Can be used to provide additional context or details about the episode.
	// Example: Person detected at the main entrance, stayed for 30 seconds
	Description() *string
	// Optional description of the episode. Can be used to provide additional context or details about the episode.
	// Example: Person detected at the main entrance, stayed for 30 seconds
	SetDescription(string) WatcherEpisodeFace
	// Detections associated with this episode
	Detections() []VisionDetectedFace
	// Detections associated with this episode
	SetDetections([]VisionDetectedFace) WatcherEpisodeFace
	// Duration of the episode in milliseconds.
	// Format: milliseconds (milliseconds)
	// Example: 10500
	Duration() *Milliseconds
	// Duration of the episode in milliseconds.
	// Format: milliseconds (milliseconds)
	// Example: 10500
	SetDuration(Milliseconds) WatcherEpisodeFace
	// The time when the episode appeared in the service relative to the server time.
	EpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps
	// The time when the episode appeared in the service relative to the server time.
	SetEpisodeAppearanceTimestamps(EpisodeAppearanceTimestamps) WatcherEpisodeFace
	// Unique identifier of the episode. Must be created by the system that first creates this episode.
	// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
	// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
	// handle very long integers.
	// Format: snowflake_id (snowflake_id)
	// Examples: 1.722279170848854e+18
	EpisodeID() SnowflakeID
	// Unique identifier of the episode. Must be created by the system that first creates this episode.
	// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
	// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
	// handle very long integers.
	// Format: snowflake_id (snowflake_id)
	// Examples: 1.722279170848854e+18
	SetEpisodeID(SnowflakeID) WatcherEpisodeFace
	// Face is detected
	EpisodeType() *string
	// Face is detected
	SetEpisodeType(string) WatcherEpisodeFace
	// The fingerprint of the detected face
	Fingerprint() VisionFaceFingerprint
	// The fingerprint of the detected face
	SetFingerprint(VisionFaceFingerprint) WatcherEpisodeFace
	// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
	// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
	// Format: base64 (base64)
	FramePreview() *Base64
	// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
	// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
	// Format: base64 (base64)
	SetFramePreview(Base64) WatcherEpisodeFace
	// Whether the episode is added to favorites.
	// Example: false
	IsFavorite() *bool
	// Whether the episode is added to favorites.
	// Example: false
	SetIsFavorite(bool) WatcherEpisodeFace
	// List of matched persons with similarity metric.
	// Videoanalytics identification service enriches episode's data and fills this field
	// with the list of persons that are similar to the face detected in this episode.
	MatchedPersons() []VisionPersonMatch
	// List of matched persons with similarity metric.
	// Videoanalytics identification service enriches episode's data and fills this field
	// with the list of persons that are similar to the face detected in this episode.
	SetMatchedPersons([]VisionPersonMatch) WatcherEpisodeFace
	// Stream name on which this episode exists.
	// Format: media_name (media_name)
	Media() MediaName
	// Stream name on which this episode exists.
	// Format: media_name (media_name)
	SetMedia(MediaName) WatcherEpisodeFace
	// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
	// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
	// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
	// sort as by `opened_at`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	OpenedAt() UtcMs
	// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
	// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
	// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
	// sort as by `opened_at`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetOpenedAt(UtcMs) WatcherEpisodeFace
	// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
	// Example: onetime_token
	PlaybackToken() *string
	// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
	// Example: onetime_token
	SetPlaybackToken(string) WatcherEpisodeFace
	// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Preview contains an image of person's face and has a resolution about 200 x 200 pixels with maximum size about 10 kilobytes.
	// Format: base64 (base64)
	Preview() Base64
	// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Preview contains an image of person's face and has a resolution about 200 x 200 pixels with maximum size about 10 kilobytes.
	// Format: base64 (base64)
	SetPreview(Base64) WatcherEpisodeFace
	// The time when the preview of this episode is available.
	// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
	// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
	// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
	// for details.
	// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	PreviewTimestamp() *UtcMs
	// The time when the preview of this episode is available.
	// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
	// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
	// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
	// for details.
	// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetPreviewTimestamp(UtcMs) WatcherEpisodeFace
	// This field can be used as indication of the fact that some system have checked and ensured that
	// this episode has really started at some time, that may differ from `opened_at`.
	// For example video analytics will use this field for the time when this episode was confirmed as confident.
	// May be not relevant for television systems.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	StartedAt() *UtcMs
	// This field can be used as indication of the fact that some system have checked and ensured that
	// this episode has really started at some time, that may differ from `opened_at`.
	// For example video analytics will use this field for the time when this episode was confirmed as confident.
	// May be not relevant for television systems.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetStartedAt(UtcMs) WatcherEpisodeFace
	// Details about stream related to the episode.
	Stream() EpisodeStreamDetailsStream
	// Details about stream related to the episode.
	SetStream(EpisodeStreamDetailsStream) WatcherEpisodeFace
	// HTTP(s) URL that can be used for streaming API of this episode
	// Example: https://streamer.example.com
	StreamingEndpoint() *string
	// HTTP(s) URL that can be used for streaming API of this episode
	// Example: https://streamer.example.com
	SetStreamingEndpoint(string) WatcherEpisodeFace
	// Optional title of the episode. Can be used to provide a human-readable name for the episode.
	// Example: Visitor at main entrance
	Title() *string
	// Optional title of the episode. Can be used to provide a human-readable name for the episode.
	// Example: Visitor at main entrance
	SetTitle(string) WatcherEpisodeFace
	// The time of last change of the episode.
	// System that processes episodes and can send them to other systems, MUST update this field
	// on any changes in this episode.
	// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
	// this `updated_at` can be used as a sort key for fetching fresh updates.
	// Consumer of the episodes can use `updated_at` in the following scenario:
	// * fetch all exisiting episodes from the source
	// * take biggest `updated_at` from this dataset, it will be T
	// * ask source for all episodes with `updated_at > T`
	// This algorithm can be used for fetching update stream from the source.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637098611e+12
	UpdatedAt() UtcMs
	// The time of last change of the episode.
	// System that processes episodes and can send them to other systems, MUST update this field
	// on any changes in this episode.
	// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
	// this `updated_at` can be used as a sort key for fetching fresh updates.
	// Consumer of the episodes can use `updated_at` in the following scenario:
	// * fetch all exisiting episodes from the source
	// * take biggest `updated_at` from this dataset, it will be T
	// * ask source for all episodes with `updated_at > T`
	// This algorithm can be used for fetching update stream from the source.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637098611e+12
	SetUpdatedAt(UtcMs) WatcherEpisodeFace
}

type WatcherEpisodeGeneric interface {
	// The reason for closing the episode.
	CloseReason() *EpisodeCloseReason
	// The reason for closing the episode.
	SetCloseReason(EpisodeCloseReason) WatcherEpisodeGeneric
	// Episode emitter can decide that episode considered closed and will not grow further.
	// `closed_at` MUST NOT change, it must be emitted only once.
	// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
	// of the episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	ClosedAt() *UtcMs
	// Episode emitter can decide that episode considered closed and will not grow further.
	// `closed_at` MUST NOT change, it must be emitted only once.
	// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
	// of the episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetClosedAt(UtcMs) WatcherEpisodeGeneric
	// Optional description of the episode. Can be used to provide additional context or details about the episode.
	// Example: Person detected at the main entrance, stayed for 30 seconds
	Description() *string
	// Optional description of the episode. Can be used to provide additional context or details about the episode.
	// Example: Person detected at the main entrance, stayed for 30 seconds
	SetDescription(string) WatcherEpisodeGeneric
	// Duration of the episode in milliseconds.
	// Format: milliseconds (milliseconds)
	// Example: 10500
	Duration() *Milliseconds
	// Duration of the episode in milliseconds.
	// Format: milliseconds (milliseconds)
	// Example: 10500
	SetDuration(Milliseconds) WatcherEpisodeGeneric
	// The time when the episode appeared in the service relative to the server time.
	EpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps
	// The time when the episode appeared in the service relative to the server time.
	SetEpisodeAppearanceTimestamps(EpisodeAppearanceTimestamps) WatcherEpisodeGeneric
	// Unique identifier of the episode. Must be created by the system that first creates this episode.
	// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
	// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
	// handle very long integers.
	// Format: snowflake_id (snowflake_id)
	// Examples: 1.722279170848854e+18
	EpisodeID() SnowflakeID
	// Unique identifier of the episode. Must be created by the system that first creates this episode.
	// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
	// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
	// handle very long integers.
	// Format: snowflake_id (snowflake_id)
	// Examples: 1.722279170848854e+18
	SetEpisodeID(SnowflakeID) WatcherEpisodeGeneric
	// Generic stream episode
	EpisodeType() *string
	// Generic stream episode
	SetEpisodeType(string) WatcherEpisodeGeneric
	// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
	// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
	// Format: base64 (base64)
	FramePreview() *Base64
	// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
	// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
	// Format: base64 (base64)
	SetFramePreview(Base64) WatcherEpisodeGeneric
	// Whether the episode is added to favorites.
	// Example: false
	IsFavorite() *bool
	// Whether the episode is added to favorites.
	// Example: false
	SetIsFavorite(bool) WatcherEpisodeGeneric
	// Stream name on which this episode exists.
	// Format: media_name (media_name)
	Media() MediaName
	// Stream name on which this episode exists.
	// Format: media_name (media_name)
	SetMedia(MediaName) WatcherEpisodeGeneric
	// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
	// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
	// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
	// sort as by `opened_at`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	OpenedAt() UtcMs
	// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
	// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
	// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
	// sort as by `opened_at`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetOpenedAt(UtcMs) WatcherEpisodeGeneric
	// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
	// Example: onetime_token
	PlaybackToken() *string
	// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
	// Example: onetime_token
	SetPlaybackToken(string) WatcherEpisodeGeneric
	// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Format: base64 (base64)
	Preview() *Base64
	// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Format: base64 (base64)
	SetPreview(Base64) WatcherEpisodeGeneric
	// The time when the preview of this episode is available.
	// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
	// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
	// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
	// for details.
	// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	PreviewTimestamp() *UtcMs
	// The time when the preview of this episode is available.
	// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
	// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
	// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
	// for details.
	// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetPreviewTimestamp(UtcMs) WatcherEpisodeGeneric
	// This field can be used as indication of the fact that some system have checked and ensured that
	// this episode has really started at some time, that may differ from `opened_at`.
	// For example video analytics will use this field for the time when this episode was confirmed as confident.
	// May be not relevant for television systems.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	StartedAt() *UtcMs
	// This field can be used as indication of the fact that some system have checked and ensured that
	// this episode has really started at some time, that may differ from `opened_at`.
	// For example video analytics will use this field for the time when this episode was confirmed as confident.
	// May be not relevant for television systems.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetStartedAt(UtcMs) WatcherEpisodeGeneric
	// Details about stream related to the episode.
	Stream() EpisodeStreamDetailsStream
	// Details about stream related to the episode.
	SetStream(EpisodeStreamDetailsStream) WatcherEpisodeGeneric
	// HTTP(s) URL that can be used for streaming API of this episode
	// Example: https://streamer.example.com
	StreamingEndpoint() *string
	// HTTP(s) URL that can be used for streaming API of this episode
	// Example: https://streamer.example.com
	SetStreamingEndpoint(string) WatcherEpisodeGeneric
	// Optional title of the episode. Can be used to provide a human-readable name for the episode.
	// Example: Visitor at main entrance
	Title() *string
	// Optional title of the episode. Can be used to provide a human-readable name for the episode.
	// Example: Visitor at main entrance
	SetTitle(string) WatcherEpisodeGeneric
	// The time of last change of the episode.
	// System that processes episodes and can send them to other systems, MUST update this field
	// on any changes in this episode.
	// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
	// this `updated_at` can be used as a sort key for fetching fresh updates.
	// Consumer of the episodes can use `updated_at` in the following scenario:
	// * fetch all exisiting episodes from the source
	// * take biggest `updated_at` from this dataset, it will be T
	// * ask source for all episodes with `updated_at > T`
	// This algorithm can be used for fetching update stream from the source.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637098611e+12
	UpdatedAt() UtcMs
	// The time of last change of the episode.
	// System that processes episodes and can send them to other systems, MUST update this field
	// on any changes in this episode.
	// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
	// this `updated_at` can be used as a sort key for fetching fresh updates.
	// Consumer of the episodes can use `updated_at` in the following scenario:
	// * fetch all exisiting episodes from the source
	// * take biggest `updated_at` from this dataset, it will be T
	// * ask source for all episodes with `updated_at > T`
	// This algorithm can be used for fetching update stream from the source.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637098611e+12
	SetUpdatedAt(UtcMs) WatcherEpisodeGeneric
}

type WatcherEpisodeHuman interface {
	// The reason for closing the episode.
	CloseReason() *EpisodeCloseReason
	// The reason for closing the episode.
	SetCloseReason(EpisodeCloseReason) WatcherEpisodeHuman
	// Episode emitter can decide that episode considered closed and will not grow further.
	// `closed_at` MUST NOT change, it must be emitted only once.
	// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
	// of the episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	ClosedAt() *UtcMs
	// Episode emitter can decide that episode considered closed and will not grow further.
	// `closed_at` MUST NOT change, it must be emitted only once.
	// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
	// of the episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetClosedAt(UtcMs) WatcherEpisodeHuman
	// Optional description of the episode. Can be used to provide additional context or details about the episode.
	// Example: Person detected at the main entrance, stayed for 30 seconds
	Description() *string
	// Optional description of the episode. Can be used to provide additional context or details about the episode.
	// Example: Person detected at the main entrance, stayed for 30 seconds
	SetDescription(string) WatcherEpisodeHuman
	// Detections associated with this episode
	Detections() []VisionDetectedObjectBase
	// Detections associated with this episode
	SetDetections([]VisionDetectedObjectBase) WatcherEpisodeHuman
	// Duration of the episode in milliseconds.
	// Format: milliseconds (milliseconds)
	// Example: 10500
	Duration() *Milliseconds
	// Duration of the episode in milliseconds.
	// Format: milliseconds (milliseconds)
	// Example: 10500
	SetDuration(Milliseconds) WatcherEpisodeHuman
	// The time when the episode appeared in the service relative to the server time.
	EpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps
	// The time when the episode appeared in the service relative to the server time.
	SetEpisodeAppearanceTimestamps(EpisodeAppearanceTimestamps) WatcherEpisodeHuman
	// Unique identifier of the episode. Must be created by the system that first creates this episode.
	// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
	// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
	// handle very long integers.
	// Format: snowflake_id (snowflake_id)
	// Examples: 1.722279170848854e+18
	EpisodeID() SnowflakeID
	// Unique identifier of the episode. Must be created by the system that first creates this episode.
	// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
	// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
	// handle very long integers.
	// Format: snowflake_id (snowflake_id)
	// Examples: 1.722279170848854e+18
	SetEpisodeID(SnowflakeID) WatcherEpisodeHuman
	// Human is detected
	EpisodeType() *string
	// Human is detected
	SetEpisodeType(string) WatcherEpisodeHuman
	// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
	// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
	// Format: base64 (base64)
	FramePreview() *Base64
	// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
	// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
	// Format: base64 (base64)
	SetFramePreview(Base64) WatcherEpisodeHuman
	// Whether the episode is added to favorites.
	// Example: false
	IsFavorite() *bool
	// Whether the episode is added to favorites.
	// Example: false
	SetIsFavorite(bool) WatcherEpisodeHuman
	// Stream name on which this episode exists.
	// Format: media_name (media_name)
	Media() MediaName
	// Stream name on which this episode exists.
	// Format: media_name (media_name)
	SetMedia(MediaName) WatcherEpisodeHuman
	// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
	// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
	// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
	// sort as by `opened_at`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	OpenedAt() UtcMs
	// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
	// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
	// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
	// sort as by `opened_at`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetOpenedAt(UtcMs) WatcherEpisodeHuman
	// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
	// Example: onetime_token
	PlaybackToken() *string
	// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
	// Example: onetime_token
	SetPlaybackToken(string) WatcherEpisodeHuman
	// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Format: base64 (base64)
	Preview() *Base64
	// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Format: base64 (base64)
	SetPreview(Base64) WatcherEpisodeHuman
	// The time when the preview of this episode is available.
	// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
	// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
	// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
	// for details.
	// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	PreviewTimestamp() *UtcMs
	// The time when the preview of this episode is available.
	// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
	// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
	// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
	// for details.
	// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetPreviewTimestamp(UtcMs) WatcherEpisodeHuman
	// This field can be used as indication of the fact that some system have checked and ensured that
	// this episode has really started at some time, that may differ from `opened_at`.
	// For example video analytics will use this field for the time when this episode was confirmed as confident.
	// May be not relevant for television systems.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	StartedAt() *UtcMs
	// This field can be used as indication of the fact that some system have checked and ensured that
	// this episode has really started at some time, that may differ from `opened_at`.
	// For example video analytics will use this field for the time when this episode was confirmed as confident.
	// May be not relevant for television systems.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetStartedAt(UtcMs) WatcherEpisodeHuman
	// Details about stream related to the episode.
	Stream() EpisodeStreamDetailsStream
	// Details about stream related to the episode.
	SetStream(EpisodeStreamDetailsStream) WatcherEpisodeHuman
	// HTTP(s) URL that can be used for streaming API of this episode
	// Example: https://streamer.example.com
	StreamingEndpoint() *string
	// HTTP(s) URL that can be used for streaming API of this episode
	// Example: https://streamer.example.com
	SetStreamingEndpoint(string) WatcherEpisodeHuman
	// Optional title of the episode. Can be used to provide a human-readable name for the episode.
	// Example: Visitor at main entrance
	Title() *string
	// Optional title of the episode. Can be used to provide a human-readable name for the episode.
	// Example: Visitor at main entrance
	SetTitle(string) WatcherEpisodeHuman
	// The time of last change of the episode.
	// System that processes episodes and can send them to other systems, MUST update this field
	// on any changes in this episode.
	// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
	// this `updated_at` can be used as a sort key for fetching fresh updates.
	// Consumer of the episodes can use `updated_at` in the following scenario:
	// * fetch all exisiting episodes from the source
	// * take biggest `updated_at` from this dataset, it will be T
	// * ask source for all episodes with `updated_at > T`
	// This algorithm can be used for fetching update stream from the source.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637098611e+12
	UpdatedAt() UtcMs
	// The time of last change of the episode.
	// System that processes episodes and can send them to other systems, MUST update this field
	// on any changes in this episode.
	// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
	// this `updated_at` can be used as a sort key for fetching fresh updates.
	// Consumer of the episodes can use `updated_at` in the following scenario:
	// * fetch all exisiting episodes from the source
	// * take biggest `updated_at` from this dataset, it will be T
	// * ask source for all episodes with `updated_at > T`
	// This algorithm can be used for fetching update stream from the source.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637098611e+12
	SetUpdatedAt(UtcMs) WatcherEpisodeHuman
}

type WatcherEpisodeQrCode interface {
	// The reason for closing the episode.
	CloseReason() *EpisodeCloseReason
	// The reason for closing the episode.
	SetCloseReason(EpisodeCloseReason) WatcherEpisodeQrCode
	// Episode emitter can decide that episode considered closed and will not grow further.
	// `closed_at` MUST NOT change, it must be emitted only once.
	// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
	// of the episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	ClosedAt() *UtcMs
	// Episode emitter can decide that episode considered closed and will not grow further.
	// `closed_at` MUST NOT change, it must be emitted only once.
	// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
	// of the episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetClosedAt(UtcMs) WatcherEpisodeQrCode
	// Optional description of the episode. Can be used to provide additional context or details about the episode.
	// Example: Person detected at the main entrance, stayed for 30 seconds
	Description() *string
	// Optional description of the episode. Can be used to provide additional context or details about the episode.
	// Example: Person detected at the main entrance, stayed for 30 seconds
	SetDescription(string) WatcherEpisodeQrCode
	// Duration of the episode in milliseconds.
	// Format: milliseconds (milliseconds)
	// Example: 10500
	Duration() *Milliseconds
	// Duration of the episode in milliseconds.
	// Format: milliseconds (milliseconds)
	// Example: 10500
	SetDuration(Milliseconds) WatcherEpisodeQrCode
	// The time when the episode appeared in the service relative to the server time.
	EpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps
	// The time when the episode appeared in the service relative to the server time.
	SetEpisodeAppearanceTimestamps(EpisodeAppearanceTimestamps) WatcherEpisodeQrCode
	// Unique identifier of the episode. Must be created by the system that first creates this episode.
	// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
	// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
	// handle very long integers.
	// Format: snowflake_id (snowflake_id)
	// Examples: 1.722279170848854e+18
	EpisodeID() SnowflakeID
	// Unique identifier of the episode. Must be created by the system that first creates this episode.
	// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
	// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
	// handle very long integers.
	// Format: snowflake_id (snowflake_id)
	// Examples: 1.722279170848854e+18
	SetEpisodeID(SnowflakeID) WatcherEpisodeQrCode
	// QR-code is detected
	EpisodeType() *string
	// QR-code is detected
	SetEpisodeType(string) WatcherEpisodeQrCode
	// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
	// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
	// Format: base64 (base64)
	FramePreview() *Base64
	// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
	// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
	// Format: base64 (base64)
	SetFramePreview(Base64) WatcherEpisodeQrCode
	// Whether the episode is added to favorites.
	// Example: false
	IsFavorite() *bool
	// Whether the episode is added to favorites.
	// Example: false
	SetIsFavorite(bool) WatcherEpisodeQrCode
	// Stream name on which this episode exists.
	// Format: media_name (media_name)
	Media() MediaName
	// Stream name on which this episode exists.
	// Format: media_name (media_name)
	SetMedia(MediaName) WatcherEpisodeQrCode
	// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
	// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
	// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
	// sort as by `opened_at`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	OpenedAt() UtcMs
	// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
	// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
	// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
	// sort as by `opened_at`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetOpenedAt(UtcMs) WatcherEpisodeQrCode
	// Raw data extracted from QR-code
	// Example: WIFI:T:WPA;S:MyOfficeWiFi;P:Mypassword;H:;
	Payload() *string
	// Raw data extracted from QR-code
	// Example: WIFI:T:WPA;S:MyOfficeWiFi;P:Mypassword;H:;
	SetPayload(string) WatcherEpisodeQrCode
	// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
	// Example: onetime_token
	PlaybackToken() *string
	// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
	// Example: onetime_token
	SetPlaybackToken(string) WatcherEpisodeQrCode
	// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Format: base64 (base64)
	Preview() *Base64
	// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Format: base64 (base64)
	SetPreview(Base64) WatcherEpisodeQrCode
	// The time when the preview of this episode is available.
	// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
	// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
	// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
	// for details.
	// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	PreviewTimestamp() *UtcMs
	// The time when the preview of this episode is available.
	// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
	// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
	// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
	// for details.
	// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetPreviewTimestamp(UtcMs) WatcherEpisodeQrCode
	// This field can be used as indication of the fact that some system have checked and ensured that
	// this episode has really started at some time, that may differ from `opened_at`.
	// For example video analytics will use this field for the time when this episode was confirmed as confident.
	// May be not relevant for television systems.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	StartedAt() *UtcMs
	// This field can be used as indication of the fact that some system have checked and ensured that
	// this episode has really started at some time, that may differ from `opened_at`.
	// For example video analytics will use this field for the time when this episode was confirmed as confident.
	// May be not relevant for television systems.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetStartedAt(UtcMs) WatcherEpisodeQrCode
	// Details about stream related to the episode.
	Stream() EpisodeStreamDetailsStream
	// Details about stream related to the episode.
	SetStream(EpisodeStreamDetailsStream) WatcherEpisodeQrCode
	// HTTP(s) URL that can be used for streaming API of this episode
	// Example: https://streamer.example.com
	StreamingEndpoint() *string
	// HTTP(s) URL that can be used for streaming API of this episode
	// Example: https://streamer.example.com
	SetStreamingEndpoint(string) WatcherEpisodeQrCode
	// Optional title of the episode. Can be used to provide a human-readable name for the episode.
	// Example: Visitor at main entrance
	Title() *string
	// Optional title of the episode. Can be used to provide a human-readable name for the episode.
	// Example: Visitor at main entrance
	SetTitle(string) WatcherEpisodeQrCode
	// The time of last change of the episode.
	// System that processes episodes and can send them to other systems, MUST update this field
	// on any changes in this episode.
	// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
	// this `updated_at` can be used as a sort key for fetching fresh updates.
	// Consumer of the episodes can use `updated_at` in the following scenario:
	// * fetch all exisiting episodes from the source
	// * take biggest `updated_at` from this dataset, it will be T
	// * ask source for all episodes with `updated_at > T`
	// This algorithm can be used for fetching update stream from the source.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637098611e+12
	UpdatedAt() UtcMs
	// The time of last change of the episode.
	// System that processes episodes and can send them to other systems, MUST update this field
	// on any changes in this episode.
	// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
	// this `updated_at` can be used as a sort key for fetching fresh updates.
	// Consumer of the episodes can use `updated_at` in the following scenario:
	// * fetch all exisiting episodes from the source
	// * take biggest `updated_at` from this dataset, it will be T
	// * ask source for all episodes with `updated_at > T`
	// This algorithm can be used for fetching update stream from the source.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637098611e+12
	SetUpdatedAt(UtcMs) WatcherEpisodeQrCode
}

type WatcherEpisodeVehicle interface {
	// The reason for closing the episode.
	CloseReason() *EpisodeCloseReason
	// The reason for closing the episode.
	SetCloseReason(EpisodeCloseReason) WatcherEpisodeVehicle
	// Episode emitter can decide that episode considered closed and will not grow further.
	// `closed_at` MUST NOT change, it must be emitted only once.
	// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
	// of the episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	ClosedAt() *UtcMs
	// Episode emitter can decide that episode considered closed and will not grow further.
	// `closed_at` MUST NOT change, it must be emitted only once.
	// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
	// of the episode.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetClosedAt(UtcMs) WatcherEpisodeVehicle
	// Optional description of the episode. Can be used to provide additional context or details about the episode.
	// Example: Person detected at the main entrance, stayed for 30 seconds
	Description() *string
	// Optional description of the episode. Can be used to provide additional context or details about the episode.
	// Example: Person detected at the main entrance, stayed for 30 seconds
	SetDescription(string) WatcherEpisodeVehicle
	// Detections associated with this episode
	Detections() []any
	// Detections associated with this episode
	SetDetections([]any) WatcherEpisodeVehicle
	// Duration of the episode in milliseconds.
	// Format: milliseconds (milliseconds)
	// Example: 10500
	Duration() *Milliseconds
	// Duration of the episode in milliseconds.
	// Format: milliseconds (milliseconds)
	// Example: 10500
	SetDuration(Milliseconds) WatcherEpisodeVehicle
	// The time when the episode appeared in the service relative to the server time.
	EpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps
	// The time when the episode appeared in the service relative to the server time.
	SetEpisodeAppearanceTimestamps(EpisodeAppearanceTimestamps) WatcherEpisodeVehicle
	// Unique identifier of the episode. Must be created by the system that first creates this episode.
	// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
	// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
	// handle very long integers.
	// Format: snowflake_id (snowflake_id)
	// Examples: 1.722279170848854e+18
	EpisodeID() SnowflakeID
	// Unique identifier of the episode. Must be created by the system that first creates this episode.
	// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
	// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
	// handle very long integers.
	// Format: snowflake_id (snowflake_id)
	// Examples: 1.722279170848854e+18
	SetEpisodeID(SnowflakeID) WatcherEpisodeVehicle
	// Vehicle is detected
	EpisodeType() *string
	// Vehicle is detected
	SetEpisodeType(string) WatcherEpisodeVehicle
	// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
	// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
	// Format: base64 (base64)
	FramePreview() *Base64
	// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
	// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
	// Format: base64 (base64)
	SetFramePreview(Base64) WatcherEpisodeVehicle
	// Whether the episode is added to favorites.
	// Example: false
	IsFavorite() *bool
	// Whether the episode is added to favorites.
	// Example: false
	SetIsFavorite(bool) WatcherEpisodeVehicle
	// Indicates if no license plate is detected on this vehicle
	LicensePlateMissing() *bool
	// Indicates if no license plate is detected on this vehicle
	SetLicensePlateMissing(bool) WatcherEpisodeVehicle
	// Recognized vehicle's license plate number
	LicensePlateText() *string
	// Recognized vehicle's license plate number
	SetLicensePlateText(string) WatcherEpisodeVehicle
	// Stream name on which this episode exists.
	// Format: media_name (media_name)
	Media() MediaName
	// Stream name on which this episode exists.
	// Format: media_name (media_name)
	SetMedia(MediaName) WatcherEpisodeVehicle
	// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
	// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
	// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
	// sort as by `opened_at`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	OpenedAt() UtcMs
	// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
	// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
	// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
	// sort as by `opened_at`
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetOpenedAt(UtcMs) WatcherEpisodeVehicle
	// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
	// Example: onetime_token
	PlaybackToken() *string
	// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
	// Example: onetime_token
	SetPlaybackToken(string) WatcherEpisodeVehicle
	// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Preview contains an image of vehicle's license plate and has a resolution about 160 x 64 pixels with maximum size about 10 kilobytes.
	// Format: base64 (base64)
	Preview() Base64
	// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
	// Preview contains an image of vehicle's license plate and has a resolution about 160 x 64 pixels with maximum size about 10 kilobytes.
	// Format: base64 (base64)
	SetPreview(Base64) WatcherEpisodeVehicle
	// The time when the preview of this episode is available.
	// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
	// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
	// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
	// for details.
	// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	PreviewTimestamp() *UtcMs
	// The time when the preview of this episode is available.
	// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
	// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
	// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
	// for details.
	// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetPreviewTimestamp(UtcMs) WatcherEpisodeVehicle
	// This field can be used as indication of the fact that some system have checked and ensured that
	// this episode has really started at some time, that may differ from `opened_at`.
	// For example video analytics will use this field for the time when this episode was confirmed as confident.
	// May be not relevant for television systems.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	StartedAt() *UtcMs
	// This field can be used as indication of the fact that some system have checked and ensured that
	// this episode has really started at some time, that may differ from `opened_at`.
	// For example video analytics will use this field for the time when this episode was confirmed as confident.
	// May be not relevant for television systems.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetStartedAt(UtcMs) WatcherEpisodeVehicle
	// Details about stream related to the episode.
	Stream() EpisodeStreamDetailsStream
	// Details about stream related to the episode.
	SetStream(EpisodeStreamDetailsStream) WatcherEpisodeVehicle
	// HTTP(s) URL that can be used for streaming API of this episode
	// Example: https://streamer.example.com
	StreamingEndpoint() *string
	// HTTP(s) URL that can be used for streaming API of this episode
	// Example: https://streamer.example.com
	SetStreamingEndpoint(string) WatcherEpisodeVehicle
	// Optional title of the episode. Can be used to provide a human-readable name for the episode.
	// Example: Visitor at main entrance
	Title() *string
	// Optional title of the episode. Can be used to provide a human-readable name for the episode.
	// Example: Visitor at main entrance
	SetTitle(string) WatcherEpisodeVehicle
	// The time of last change of the episode.
	// System that processes episodes and can send them to other systems, MUST update this field
	// on any changes in this episode.
	// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
	// this `updated_at` can be used as a sort key for fetching fresh updates.
	// Consumer of the episodes can use `updated_at` in the following scenario:
	// * fetch all exisiting episodes from the source
	// * take biggest `updated_at` from this dataset, it will be T
	// * ask source for all episodes with `updated_at > T`
	// This algorithm can be used for fetching update stream from the source.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637098611e+12
	UpdatedAt() UtcMs
	// The time of last change of the episode.
	// System that processes episodes and can send them to other systems, MUST update this field
	// on any changes in this episode.
	// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
	// this `updated_at` can be used as a sort key for fetching fresh updates.
	// Consumer of the episodes can use `updated_at` in the following scenario:
	// * fetch all exisiting episodes from the source
	// * take biggest `updated_at` from this dataset, it will be T
	// * ask source for all episodes with `updated_at > T`
	// This algorithm can be used for fetching update stream from the source.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637098611e+12
	SetUpdatedAt(UtcMs) WatcherEpisodeVehicle
	// Emergency type of the vehicle.
	VehicleEmergencySubtype() *VisionVehicleEmergencySubtype
	// Emergency type of the vehicle.
	SetVehicleEmergencySubtype(VisionVehicleEmergencySubtype) WatcherEpisodeVehicle
	// Shows from which side the vehicle was detected.
	VehicleFacingSide() *VisionVehicleFacingSide
	// Shows from which side the vehicle was detected.
	SetVehicleFacingSide(VisionVehicleFacingSide) WatcherEpisodeVehicle
	// The purpose of the vehicle, e.g. emergency or regular.
	VehiclePurpose() *VisionVehiclePurpose
	// The purpose of the vehicle, e.g. emergency or regular.
	SetVehiclePurpose(VisionVehiclePurpose) WatcherEpisodeVehicle
}

type WatcherStreamConfig interface {
	// Audio settings for the stream.
	Audio() WatcherStreamConfigAudio
	// Audio settings for the stream.
	SetAudio(WatcherStreamConfigAudio) WatcherStreamConfig
	// A publishable stream.
	// Example: false
	CanPublish() *bool
	// A publishable stream.
	// Example: false
	SetCanPublish(bool) WatcherStreamConfig
	// Camera coordinates on a map or a floor plan.
	Coordinates() MapSpec
	// Camera coordinates on a map or a floor plan.
	SetCoordinates(MapSpec) WatcherStreamConfig
	// The date and time when the steam was created.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.672531199e+12
	CreatedAt() *UtcMs
	// The date and time when the steam was created.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Example: 1.672531199e+12
	SetCreatedAt(UtcMs) WatcherStreamConfig
	// Duration of the firmware update. If this field is present, the update process is ongoing.
	// Format: milliseconds (milliseconds)
	FirmwareUpdateDuration() *Milliseconds
	// Duration of the firmware update. If this field is present, the update process is ongoing.
	// Format: milliseconds (milliseconds)
	SetFirmwareUpdateDuration(Milliseconds) WatcherStreamConfig
	// Folder identificator.
	FolderID() *int
	// Folder identificator.
	SetFolderID(int) WatcherStreamConfig
	// The stream is added to favorites list.
	IsFavourite() *bool
	// The stream is added to favorites list.
	SetIsFavourite(bool) WatcherStreamConfig
	// Information about the latest changes made to the camera configuration.
	LastChange() AuditLogRecord
	// Information about the latest changes made to the camera configuration.
	SetLastChange(AuditLogRecord) WatcherStreamConfig
	// The time when the last episode occurred.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	LastEpisodeAt() *UtcMs
	// The time when the last episode occurred.
	// Format: utc_ms (Unix timestamp in milliseconds)
	// Examples: 1.637094994e+12
	SetLastEpisodeAt(UtcMs) WatcherStreamConfig
	// Deprecated field. Will be deleted at 24.12
	// Camera coordinates on a map or a floor plan. Deprecated. Use coordinates instead.
	MapCoordinates() MapSpec
	// Deprecated field. Will be deleted at 24.12
	// Camera coordinates on a map or a floor plan. Deprecated. Use coordinates instead.
	SetMapCoordinates(MapSpec) WatcherStreamConfig
	// Notifications are enabled for the camera.
	NotificationsEnabled() *bool
	// Notifications are enabled for the camera.
	SetNotificationsEnabled(bool) WatcherStreamConfig
	// Onvif configuration
	Onvif() StreamOnvifConfig
	// Onvif configuration
	SetOnvif(StreamOnvifConfig) WatcherStreamConfig
	// Organization the stream belongs to.
	Organization() OrganizationStream
	// Organization the stream belongs to.
	SetOrganization(OrganizationStream) WatcherStreamConfig
	// Deprecated field. Will be deleted at 25.11
	// ID of the organization the stream belongs to.
	// Only organization owner or domain administrator could change it.
	// Example: 9
	OrganizationID() *int
	// Deprecated field. Will be deleted at 25.11
	// ID of the organization the stream belongs to.
	// Only organization owner or domain administrator could change it.
	// Example: 9
	SetOrganizationID(int) WatcherStreamConfig
	// Contains path to stream as a list.
	// Each item of the list can be interpreted as a node in a folders tree.
	Path() []StreamPathItem
	// Contains path to stream as a list.
	// Each item of the list can be interpreted as a node in a folders tree.
	SetPath([]StreamPathItem) WatcherStreamConfig
	// Camera adress on a map.
	PostalAddress() *string
	// Camera adress on a map.
	SetPostalAddress(string) WatcherStreamConfig
	// Preset settings.
	Preset() StreamPreset
	// Preset settings.
	SetPreset(StreamPreset) WatcherStreamConfig
	// Deprecated field. Will be deleted at 26.01
	// Preset identificator.
	PresetID() *int
	// Deprecated field. Will be deleted at 26.01
	// Preset identificator.
	SetPresetID(int) WatcherStreamConfig
}

// Audio settings for the stream.
type WatcherStreamConfigAudio interface {
	// A flag showing if the audio is captured (false) or not (true) from the stream.
	// Example: false
	Disabled() *bool
	// A flag showing if the audio is captured (false) or not (true) from the stream.
	// Example: false
	SetDisabled(bool) WatcherStreamConfigAudio
	// Audio codec (the AAC codec is used by default).
	TranscodeAudioCodec() *FrameAudioCodec
	// Audio codec (the AAC codec is used by default).
	SetTranscodeAudioCodec(FrameAudioCodec) WatcherStreamConfigAudio
}

// WebPush Notifications subscription
// Required: endpoint
type WebPushSubscription interface {
	// Endpoint on which Billing will send Push Messages
	// Format: uri (uri)
	// Example: https://fcm.googleapis.com/fcm/send/${token}
	Endpoint() URI
	// Endpoint on which Billing will send Push Messages
	// Format: uri (uri)
	// Example: https://fcm.googleapis.com/fcm/send/${token}
	SetEndpoint(URI) WebPushSubscription
}

type WebPushSubscriptionCreate interface {
	// Endpoint on which Billing will send Push Messages
	// Format: uri (uri)
	// Example: https://fcm.googleapis.com/fcm/send/${token}
	Endpoint() URI
	// Endpoint on which Billing will send Push Messages
	// Format: uri (uri)
	// Example: https://fcm.googleapis.com/fcm/send/${token}
	SetEndpoint(URI) WebPushSubscriptionCreate
	// Keys that are used to encrypt the payload
	Keys() WebPushSubscriptionCreateKeys
	// Keys that are used to encrypt the payload
	SetKeys(WebPushSubscriptionCreateKeys) WebPushSubscriptionCreate
}

// Keys that are used to encrypt the payload
// Required: p256dh, auth
type WebPushSubscriptionCreateKeys interface {
	// Authentication secret
	Auth() string
	// Authentication secret
	SetAuth(string) WebPushSubscriptionCreateKeys
	// Public key
	P256dh() string
	// Public key
	SetP256dh(string) WebPushSubscriptionCreateKeys
}

// Required: token
type AgentActivationTokenImpl struct {
	StreamNameValue *string `json:"stream_name,omitempty" validate:"omitempty"`
	TokenValue      string  `json:"token" validate:"required"`
}

type AgentActivationTokenRequestImpl struct {
	CommentValue        *string          `json:"comment,omitempty" validate:"omitempty"`
	CoordinatesValue    *CoordinatesImpl `json:"coordinates,omitempty" validate:"omitempty"`
	DvrDepthValue       *int             `json:"dvr_depth,omitempty" validate:"omitempty,min=0"`
	DvrSpaceValue       *int             `json:"dvr_space,omitempty" validate:"omitempty,min=0"`
	EnabledValue        *bool            `json:"enabled,omitempty" validate:"omitempty"`
	FolderIDValue       *int             `json:"folder_id,omitempty" validate:"omitempty"`
	OrganizationIDValue *int             `json:"organization_id,omitempty" validate:"omitempty"`
	PostalAddressValue  *string          `json:"postal_address,omitempty" validate:"omitempty"`
	PresetIDValue       *int             `json:"preset_id,omitempty" validate:"omitempty"`
	StaticValue         *bool            `json:"static,omitempty" validate:"omitempty"`
	TitleValue          *string          `json:"title,omitempty" validate:"omitempty"`
}

// Users apikey for access via API.
type ApikeyImpl struct {
	ApikeyValue *string `json:"apikey,omitempty" validate:"omitempty"`
}

type AuditLogRecordImpl struct {
	CreatedAtValue *UtcMs  `json:"created_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	UserValue      *string `json:"user,omitempty" validate:"omitempty"`
}

// Authentication details configuration
type AuthImpl struct {
	LoginValue    *string `json:"login,omitempty" validate:"omitempty"`
	PasswordValue *string `json:"password,omitempty" validate:"omitempty"`
	PortValue     *int    `json:"port,omitempty" validate:"omitempty"`
}

type CameraConfigImpl struct {
	CameraInfoValue   any `json:"camera_info,omitempty" validate:"omitempty"`
	MediaQualityValue any `json:"media_quality,omitempty" validate:"omitempty"`
	SensorValue       any `json:"sensor,omitempty" validate:"omitempty"`
}

// Camera information
type CameraInfoImpl struct {
	FirmwareValue     *string `json:"firmware,omitempty" validate:"omitempty"`
	ManufacturerValue *string `json:"manufacturer,omitempty" validate:"omitempty"`
	ModelValue        *string `json:"model,omitempty" validate:"omitempty"`
	SerialNumberValue *string `json:"serial_number,omitempty" validate:"omitempty"`
}

type CameraTagWbImpl struct {
}

type ClosedCaptionsImpl struct {
	LanguageValue *string `json:"language,omitempty" validate:"omitempty"`
	NameValue     *string `json:"name,omitempty" validate:"omitempty"`
}

type CollectionResponseImpl struct {
	EstimatedCountValue *int    `json:"estimated_count,omitempty" validate:"omitempty"`
	NextValue           *string `json:"next,omitempty" validate:"omitempty"`
	PrevValue           *string `json:"prev,omitempty" validate:"omitempty"`
	TimingValue         any     `json:"timing,omitempty" validate:"omitempty"`
}

// The camera geographic coordinates: latitude and longitude.
type CoordinatesImpl struct {
	LatitudeValue  *float64 `json:"latitude,omitempty" validate:"omitempty"`
	LongitudeValue *float64 `json:"longitude,omitempty" validate:"omitempty"`
}

// Device info
// Required: platform
type DeviceInfoImpl struct {
	ModelValue    *string `json:"model,omitempty" validate:"omitempty"`
	VersionValue  *string `json:"version,omitempty" validate:"omitempty"`
	PlatformValue string  `json:"platform" validate:"required"`
}

// Generated with firebase token
// Required: token
type DeviceTokenImpl struct {
	DeviceValue *DeviceInfoImpl `json:"device,omitempty" validate:"omitempty"`
	TokenValue  string          `json:"token" validate:"required"`
}

type DvrBaseConfigImpl struct {
	EpisodesExpirationValue *Seconds `json:"episodes_expiration,omitempty" validate:"omitempty"`
	ExpirationValue         *Seconds `json:"expiration,omitempty" validate:"omitempty"`
	StorageLimitValue       *Bytes   `json:"storage_limit,omitempty" validate:"omitempty"`
}

// Required: from, depth, ranges
type DvrInfoImpl struct {
	BytesValue    *Bytes          `json:"bytes,omitempty" validate:"omitempty"`
	DiskSizeValue *Bytes          `json:"disk_size,omitempty" validate:"omitempty"`
	DurationValue *Seconds        `json:"duration,omitempty" validate:"omitempty"`
	RangesValue   []*DvrRangeImpl `json:"ranges" validate:"required"`
	DepthValue    Seconds         `json:"depth" validate:"required"`
	FromValue     Utc             `json:"from" validate:"required,min=1e+09,max=1e+10"`
}

type DvrRangeImpl struct {
	ClosedAtValue *UtcMs   `json:"closed_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	DurationValue *Seconds `json:"duration,omitempty" validate:"omitempty"`
	FromValue     *Utc     `json:"from,omitempty" validate:"omitempty,min=1e+09,max=1e+10"`
	OpenedAtValue *UtcMs   `json:"opened_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
}

type EpisodeAppearanceTimestampsImpl struct {
	CentralTimestampValue   *UtcMs `json:"central_timestamp,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	InferenceTimestampValue *UtcMs `json:"inference_timestamp,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	WatcherTimestampValue   *UtcMs `json:"watcher_timestamp,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
}

// # Definition
// Episode is a record about continious part of one video stream.
// It is used in video analytics, television systems, etc. for describing one continious and logically
// consolidated part of video stream.
// For example, episode can describe one TV show or a part of video when the car with specific license plate
// passed the camera view.
// Different systems in our ecosystem can emit and consume episodes of different `episode_type`.
// # Alternatives
// What episodes are not:
// * they cannot combine multiple streams. If you have multicamera view on the scene, you will have to create many episodes and join then in another system
// * they cannot be multipart. Only one continious uninterrupted episode. However, it is ok for them to overlap.
// # Updates
// Episodes are supposed to be streamable and updatable.
// If you consume episodes, you must be ready to see old `episode_id`
// with new updated data. You MUST overwrite previous data.
// If you emit episodes and you change any fields, you MUST accumulate previous data of episode and send full copy of
// updated episode.
// # Borders
// Episode have two mandatory fields: `opened_at` and `updated_at`, they are default borders of the episode:
// beginning and the end.
// Sometimes you need to look at another fields: `started_at` and `closed_at`.
// `started_at` appears when episode emitter decides that beginning of the episode should be different from `opened_at`,
// for example if video analytics has analysed previous frames and decided that this object appeared earlier.
// `closed_at` can appear if episode source have decided that episode will not continue anymore, for example
// car have run out of camera view. However, `updated_at` can be still changed, if any other system will add
// more data there, for example detected licence plates of some other auxiliary information.
// Required: episode_id, media, opened_at, updated_at
type EpisodeBaseImpl struct {
	CloseReasonValue                 *EpisodeCloseReason              `json:"close_reason,omitempty" validate:"omitempty"`
	ClosedAtValue                    *UtcMs                           `json:"closed_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	EpisodeAppearanceTimestampsValue *EpisodeAppearanceTimestampsImpl `json:"episode_appearance_timestamps,omitempty" validate:"omitempty"`
	FramePreviewValue                *Base64                          `json:"frame_preview,omitempty" validate:"omitempty,base64"`
	PreviewValue                     *Base64                          `json:"preview,omitempty" validate:"omitempty,base64"`
	PreviewTimestampValue            *UtcMs                           `json:"preview_timestamp,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	StartedAtValue                   *UtcMs                           `json:"started_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	MediaValue                       MediaName                        `json:"media" validate:"required"`
	EpisodeIDValue                   SnowflakeID                      `json:"episode_id" validate:"required"`
	OpenedAtValue                    UtcMs                            `json:"opened_at" validate:"required,min=1e+12,max=1e+13"`
	UpdatedAtValue                   UtcMs                            `json:"updated_at" validate:"required,min=1e+12,max=1e+13"`
}

type EpisodeCustomImpl struct {
	PayloadValue                     any                              `json:"payload,omitempty" validate:"omitempty"`
	PreviewValue                     *Base64                          `json:"preview,omitempty" validate:"omitempty,base64"`
	ClosedAtValue                    *UtcMs                           `json:"closed_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	EpisodeAppearanceTimestampsValue *EpisodeAppearanceTimestampsImpl `json:"episode_appearance_timestamps,omitempty" validate:"omitempty"`
	StartedAtValue                   *UtcMs                           `json:"started_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	EpisodeTypeValue                 *string                          `json:"episode_type,omitempty" validate:"omitempty,min=1,max=20"`
	FramePreviewValue                *Base64                          `json:"frame_preview,omitempty" validate:"omitempty,base64"`
	CloseReasonValue                 *EpisodeCloseReason              `json:"close_reason,omitempty" validate:"omitempty"`
	PreviewTimestampValue            *UtcMs                           `json:"preview_timestamp,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	MediaValue                       MediaName                        `json:"media" validate:"required"`
	OpenedAtValue                    UtcMs                            `json:"opened_at" validate:"required,min=1e+12,max=1e+13"`
	EpisodeIDValue                   SnowflakeID                      `json:"episode_id" validate:"required"`
	UpdatedAtValue                   UtcMs                            `json:"updated_at" validate:"required,min=1e+12,max=1e+13"`
}

type EpisodeExtraImpl struct {
	DescriptionValue *string       `json:"description,omitempty" validate:"omitempty,max=256"`
	DurationValue    *Milliseconds `json:"duration,omitempty" validate:"omitempty"`
	IsFavoriteValue  *bool         `json:"is_favorite,omitempty" validate:"omitempty"`
	TitleValue       *string       `json:"title,omitempty" validate:"omitempty,max=64"`
}

type EpisodeGenericImpl struct {
	CloseReasonValue                 *EpisodeCloseReason              `json:"close_reason,omitempty" validate:"omitempty"`
	ClosedAtValue                    *UtcMs                           `json:"closed_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	EpisodeAppearanceTimestampsValue *EpisodeAppearanceTimestampsImpl `json:"episode_appearance_timestamps,omitempty" validate:"omitempty"`
	EpisodeTypeValue                 *string                          `json:"episode_type,omitempty" validate:"omitempty"`
	FramePreviewValue                *Base64                          `json:"frame_preview,omitempty" validate:"omitempty,base64"`
	PreviewValue                     *Base64                          `json:"preview,omitempty" validate:"omitempty,base64"`
	PreviewTimestampValue            *UtcMs                           `json:"preview_timestamp,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	StartedAtValue                   *UtcMs                           `json:"started_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	MediaValue                       MediaName                        `json:"media" validate:"required"`
	EpisodeIDValue                   SnowflakeID                      `json:"episode_id" validate:"required"`
	OpenedAtValue                    UtcMs                            `json:"opened_at" validate:"required,min=1e+12,max=1e+13"`
	UpdatedAtValue                   UtcMs                            `json:"updated_at" validate:"required,min=1e+12,max=1e+13"`
}

type EpisodePlayImpl struct {
	PlaybackTokenValue     *string `json:"playback_token,omitempty" validate:"omitempty"`
	StreamingEndpointValue *string `json:"streaming_endpoint,omitempty" validate:"omitempty"`
}

type EpisodeStreamDetailsImpl struct {
	StreamValue *EpisodeStreamDetailsStreamImpl `json:"stream,omitempty" validate:"omitempty"`
}

// Details about stream related to the episode.
// Required: name
type EpisodeStreamDetailsStreamImpl struct {
	CommentValue        *string             `json:"comment,omitempty" validate:"omitempty"`
	OrganizationIDValue *int                `json:"organization_id,omitempty" validate:"omitempty"`
	ThumbnailsValue     *ThumbnailsSpecImpl `json:"thumbnails,omitempty" validate:"omitempty"`
	TitleValue          *string             `json:"title,omitempty" validate:"omitempty"`
	NameValue           MediaName           `json:"name" validate:"required"`
}

type EpisodesListImpl struct {
	TimingValue         any                   `json:"timing,omitempty" validate:"omitempty"`
	EstimatedCountValue *int                  `json:"estimated_count,omitempty" validate:"omitempty"`
	NextValue           *string               `json:"next,omitempty" validate:"omitempty"`
	PrevValue           *string               `json:"prev,omitempty" validate:"omitempty"`
	EpisodesValue       []*WatcherEpisodeImpl `json:"episodes,omitempty" validate:"omitempty"`
}

type ErrorImpl struct {
	CodeValue   *string           `json:"code,omitempty" validate:"omitempty"`
	IDValue     *string           `json:"id,omitempty" validate:"omitempty"`
	MetaValue   map[string]string `json:"meta,omitempty" validate:"omitempty"`
	SourceValue *ErrorSourceImpl  `json:"source,omitempty" validate:"omitempty"`
	StatusValue *string           `json:"status,omitempty" validate:"omitempty"`
	TitleValue  *string           `json:"title,omitempty" validate:"omitempty"`
}

type ErrorResponseImpl struct {
	ErrorsValue []*ErrorImpl `json:"errors,omitempty" validate:"omitempty"`
}

// an object containing references to the source of the error
type ErrorSourceImpl struct {
	ParameterValue *string `json:"parameter,omitempty" validate:"omitempty"`
	PointerValue   *string `json:"pointer,omitempty" validate:"omitempty"`
}

// Update camera firmware
// Required: image
type FirmwareUpdateImpl struct {
	ImageValue any                  `json:"image" validate:"required"`
	ProtoValue *FirmwareUpdateProto `json:"proto,omitempty" validate:"omitempty,oneof=iris isapi xm sputnik"`
}

// Floor file object
type FloorFileImpl struct {
	B64ContentValue    *string `json:"b64_content,omitempty" validate:"omitempty"`
	BinaryContentValue *string `json:"binary_content,omitempty" validate:"omitempty"`
	MimeTypeValue      *string `json:"mime_type,omitempty" validate:"omitempty"`
	NameValue          *string `json:"name,omitempty" validate:"omitempty"`
	URLValue           *string `json:"url,omitempty" validate:"omitempty"`
}

// Required: id
type FolderImpl struct {
	CoordinatesValue    *MapSpecImpl         `json:"coordinates,omitempty" validate:"omitempty"`
	FloorPlanValue      *FolderFloorPlanImpl `json:"floor_plan,omitempty" validate:"omitempty"`
	HierarchyValue      *FolderHierarchyImpl `json:"hierarchy,omitempty" validate:"omitempty"`
	OrganizationIDValue *int                 `json:"organization_id,omitempty" validate:"omitempty"`
	ParentIDValue       *int                 `json:"parent_id,omitempty" validate:"omitempty"`
	StreamsCountValue   *int                 `json:"streams_count,omitempty" validate:"omitempty"`
	TitleValue          *string              `json:"title,omitempty" validate:"omitempty"`
	IDValue             int                  `json:"id" validate:"required"`
}

// Object of map parameters
type FolderFloorPlanImpl struct {
	BottomleftValue *MapSpecImpl   `json:"bottomleft,omitempty" validate:"omitempty"`
	FileValue       *FloorFileImpl `json:"file,omitempty" validate:"omitempty"`
	TopleftValue    *MapSpecImpl   `json:"topleft,omitempty" validate:"omitempty"`
	ToprightValue   *MapSpecImpl   `json:"topright,omitempty" validate:"omitempty"`
}

// Hierarchy object.
type FolderHierarchyImpl struct {
	LevelValue    *int                      `json:"level,omitempty" validate:"omitempty"`
	OrderNumValue *int                      `json:"order_num,omitempty" validate:"omitempty"`
	ShiftValue    *FolderHierarchyShiftImpl `json:"shift,omitempty" validate:"omitempty"`
}

// This parameters block allows changing the level of the folder in the hierarchy and order of folders
type FolderHierarchyShiftImpl struct {
	DestinationValue *int                           `json:"destination,omitempty" validate:"omitempty"`
	DirectionValue   *FolderHierarchyShiftDirection `json:"direction,omitempty" validate:"omitempty,oneof=after before inside"`
}

type FolderUserImpl struct {
	CanUseActionsValue *bool    `json:"can_use_actions,omitempty" validate:"omitempty"`
	CanUsePtzValue     *bool    `json:"can_use_ptz,omitempty" validate:"omitempty"`
	CanViewValue       *bool    `json:"can_view,omitempty" validate:"omitempty"`
	CanViewDvrValue    *bool    `json:"can_view_dvr,omitempty" validate:"omitempty"`
	DvrDepthLimitValue *Seconds `json:"dvr_depth_limit,omitempty" validate:"omitempty,min=0"`
}

type FolderUsersImpl struct {
	CanUseActionsValue *bool    `json:"can_use_actions,omitempty" validate:"omitempty"`
	CanUsePtzValue     *bool    `json:"can_use_ptz,omitempty" validate:"omitempty"`
	CanViewValue       *bool    `json:"can_view,omitempty" validate:"omitempty"`
	CanViewDvrValue    *bool    `json:"can_view_dvr,omitempty" validate:"omitempty"`
	DvrDepthLimitValue *Seconds `json:"dvr_depth_limit,omitempty" validate:"omitempty,min=0"`
	UserIDValue        *int     `json:"user_id,omitempty" validate:"omitempty"`
}

type FolderUsersListImpl struct {
	EstimatedCountValue *int               `json:"estimated_count,omitempty" validate:"omitempty"`
	NextValue           *string            `json:"next,omitempty" validate:"omitempty"`
	PrevValue           *string            `json:"prev,omitempty" validate:"omitempty"`
	TimingValue         any                `json:"timing,omitempty" validate:"omitempty"`
	UsersValue          []*FolderUsersImpl `json:"users,omitempty" validate:"omitempty"`
}

type FoldersListImpl struct {
	TimingValue         any           `json:"timing,omitempty" validate:"omitempty"`
	EstimatedCountValue *int          `json:"estimated_count,omitempty" validate:"omitempty"`
	NextValue           *string       `json:"next,omitempty" validate:"omitempty"`
	PrevValue           *string       `json:"prev,omitempty" validate:"omitempty"`
	FoldersValue        []*FolderImpl `json:"folders,omitempty" validate:"omitempty"`
}

// Here are counters for h264/h265 decoder.
type H26xDecoderCountersImpl struct {
	DiscardedBrokenNalCountValue        *int `json:"discarded_broken_nal_count,omitempty" validate:"omitempty"`
	DiscardedFuCountValue               *int `json:"discarded_fu_count,omitempty" validate:"omitempty"`
	DiscardedNalCountValue              *int `json:"discarded_nal_count,omitempty" validate:"omitempty"`
	DiscardedNotAllowedNalCountValue    *int `json:"discarded_not_allowed_nal_count,omitempty" validate:"omitempty"`
	DiscardedSeiCountValue              *int `json:"discarded_sei_count,omitempty" validate:"omitempty"`
	FuEndThenMiddleWorkaroundCountValue *int `json:"fu_end_then_middle_workaround_count,omitempty" validate:"omitempty"`
	FuHasBothStartEndBitsCountValue     *int `json:"fu_has_both_start_end_bits_count,omitempty" validate:"omitempty"`
	FuPatternIsBrokenCountValue         *int `json:"fu_pattern_is_broken_count,omitempty" validate:"omitempty"`
	IncompleteNalCountValue             *int `json:"incomplete_nal_count,omitempty" validate:"omitempty"`
	InvalidSeiPayloadCountValue         *int `json:"invalid_sei_payload_count,omitempty" validate:"omitempty"`
	InvalidSeiSizeCountValue            *int `json:"invalid_sei_size_count,omitempty" validate:"omitempty"`
	InvalidSeiTypeCountValue            *int `json:"invalid_sei_type_count,omitempty" validate:"omitempty"`
	NalAggregationCountValue            *int `json:"nal_aggregation_count,omitempty" validate:"omitempty"`
	NalAudCountValue                    *int `json:"nal_aud_count,omitempty" validate:"omitempty"`
	NalCountValue                       *int `json:"nal_count,omitempty" validate:"omitempty"`
	NalFillerCountValue                 *int `json:"nal_filler_count,omitempty" validate:"omitempty"`
	NalFuCountValue                     *int `json:"nal_fu_count,omitempty" validate:"omitempty"`
	NalIdrCountValue                    *int `json:"nal_idr_count,omitempty" validate:"omitempty"`
	NalOtherCountValue                  *int `json:"nal_other_count,omitempty" validate:"omitempty"`
	NalPpsCountValue                    *int `json:"nal_pps_count,omitempty" validate:"omitempty"`
	NalSeiCountValue                    *int `json:"nal_sei_count,omitempty" validate:"omitempty"`
	NalSingleCountValue                 *int `json:"nal_single_count,omitempty" validate:"omitempty"`
	NalSliceCountValue                  *int `json:"nal_slice_count,omitempty" validate:"omitempty"`
	NalSpsCountValue                    *int `json:"nal_sps_count,omitempty" validate:"omitempty"`
	NalStapACountValue                  *int `json:"nal_stap_a_count,omitempty" validate:"omitempty"`
	NalVpsCountValue                    *int `json:"nal_vps_count,omitempty" validate:"omitempty"`
}

// Agent counters
type InputAgentCountersImpl struct {
	ErrorsBufferOverrunValue  *int `json:"errors_buffer_overrun,omitempty" validate:"omitempty"`
	ErrorsConnFailedValue     *int `json:"errors_conn_failed,omitempty" validate:"omitempty"`
	ErrorsInvalidRequestValue *int `json:"errors_invalid_request,omitempty" validate:"omitempty"`
	ErrorsOutOfMemoryValue    *int `json:"errors_out_of_memory,omitempty" validate:"omitempty"`
	ErrorsUnknownValue        *int `json:"errors_unknown,omitempty" validate:"omitempty"`
}

// Here are grouped different counters for sessions: generic and errors
type InputCountersImpl struct {
	ErrorsTSStuckRestartsValue  *int                             `json:"errors_ts_stuck_restarts,omitempty" validate:"omitempty"`
	FramesValue                 *int                             `json:"frames,omitempty" validate:"omitempty"`
	AgentValue                  *InputAgentCountersImpl          `json:"agent,omitempty" validate:"omitempty"`
	BytesValue                  *Bytes                           `json:"bytes,omitempty" validate:"omitempty" openmetrics_metric:"stream_input_bytes"`
	BytesDvrValue               *Bytes                           `json:"bytes_dvr,omitempty" validate:"omitempty"`
	InputSwitchesValue          *int                             `json:"input_switches,omitempty" validate:"omitempty"`
	ErrorsValue                 *int                             `json:"errors,omitempty" validate:"omitempty"`
	Errors403Value              *int                             `json:"errors_403,omitempty" validate:"omitempty"`
	Errors404Value              *int                             `json:"errors_404,omitempty" validate:"omitempty"`
	Errors500Value              *int                             `json:"errors_500,omitempty" validate:"omitempty"`
	ErrorsBrokenPayloadValue    *int                             `json:"errors_broken_payload,omitempty" validate:"omitempty"`
	ErrorsCrashedValue          *int                             `json:"errors_crashed,omitempty" validate:"omitempty"`
	ErrorsDecoderResetValue     *int                             `json:"errors_decoder_reset,omitempty" validate:"omitempty"`
	ErrorsDesyncValue           *int                             `json:"errors_desync,omitempty" validate:"omitempty"`
	ErrorsDroppedFramesValue    *int                             `json:"errors_dropped_frames,omitempty" validate:"omitempty"`
	ErrorsLostPacketsValue      *int                             `json:"errors_lost_packets,omitempty" validate:"omitempty"`
	ErrorsTSPatValue            *int                             `json:"errors_ts_pat,omitempty" validate:"omitempty"`
	ErrorsTSServiceLostValue    *int                             `json:"errors_ts_service_lost,omitempty" validate:"omitempty"`
	AdSplicesInsertedValue      *int                             `json:"ad_splices_inserted,omitempty" validate:"omitempty"`
	AdSplicesIngestedValue      *int                             `json:"ad_splices_ingested,omitempty" validate:"omitempty"`
	ErrorRateValue              *int                             `json:"error_rate,omitempty" validate:"omitempty"`
	InvalidSecondaryInputsValue *int                             `json:"invalid_secondary_inputs,omitempty" validate:"omitempty"`
	MediaInfoChangesValue       *int                             `json:"media_info_changes,omitempty" validate:"omitempty"`
	MotionDetectorValue         *InputMotionDetectorCountersImpl `json:"motion_detector,omitempty" validate:"omitempty"`
	NumSecNoDataValue           *Seconds                         `json:"num_sec_no_data,omitempty" validate:"omitempty"`
	NumSecOnPrimaryInputValue   *Seconds                         `json:"num_sec_on_primary_input,omitempty" validate:"omitempty"`
	NumSecOnSecondaryInputValue *Seconds                         `json:"num_sec_on_secondary_input,omitempty" validate:"omitempty"`
	ValidSecondaryInputsValue   *int                             `json:"valid_secondary_inputs,omitempty" validate:"omitempty"`
	ReorderCountValue           *int                             `json:"reorder_count,omitempty" validate:"omitempty"`
	ResyncCountDriftValue       *int                             `json:"resync_count_drift,omitempty" validate:"omitempty"`
	ResyncCountJumpValue        *int                             `json:"resync_count_jump,omitempty" validate:"omitempty"`
	ResyncCountNormalValue      *int                             `json:"resync_count_normal,omitempty" validate:"omitempty"`
	RetriesValue                *int                             `json:"retries,omitempty" validate:"omitempty"`
	SrtValue                    *InputSrtCountersImpl            `json:"srt,omitempty" validate:"omitempty"`
	SdiValue                    *InputSdiCountersImpl            `json:"sdi,omitempty" validate:"omitempty"`
	RTPChannelsValue            []*InputRTPCountersImpl          `json:"rtp_channels,omitempty" validate:"omitempty"`
	PidsValue                   []*InputPidCountersImpl          `json:"pids,omitempty" validate:"omitempty"`
}

// Specific counters to get insights on current state of getting events from cameras.
// Designed to be used by analyzers, monitoring and alerting tools
type InputMotionDetectorCountersImpl struct {
	EpisodesCountValue                  *int `json:"episodes_count,omitempty" validate:"omitempty"`
	ErrorsBrokenPayloadValue            *int `json:"errors_broken_payload,omitempty" validate:"omitempty"`
	ErrorsIncorrectTimeValuesCountValue *int `json:"errors_incorrect_time_values_count,omitempty" validate:"omitempty"`
	ErrorsNoAgentConnectedValue         *int `json:"errors_no_agent_connected,omitempty" validate:"omitempty"`
	ErrorsNoServiceCountValue           *int `json:"errors_no_service_count,omitempty" validate:"omitempty"`
	ErrorsNotAuthorizedCountValue       *int `json:"errors_not_authorized_count,omitempty" validate:"omitempty"`
	ErrorsURLUnreachableCountValue      *int `json:"errors_url_unreachable_count,omitempty" validate:"omitempty"`
	MotionDetectedCountValue            *int `json:"motion_detected_count,omitempty" validate:"omitempty"`
}

// Required: pid
type InputPidCountersImpl struct {
	ErrorsTSScrambledValue      *int `json:"errors_ts_scrambled,omitempty" validate:"omitempty"`
	PacketsValue                *int `json:"packets,omitempty" validate:"omitempty"`
	CorrectedBackwardPtsValue   *int `json:"corrected_backward_pts,omitempty" validate:"omitempty"`
	CrashedValue                *int `json:"crashed,omitempty" validate:"omitempty"`
	BrokenPesCountValue         *int `json:"broken_pes_count,omitempty" validate:"omitempty"`
	DiscardedBufferSumValue     *int `json:"discarded_buffer_sum,omitempty" validate:"omitempty"`
	DtsGoesBackwardsValue       *int `json:"dts_goes_backwards,omitempty" validate:"omitempty"`
	DtsJumpForwardValue         *int `json:"dts_jump_forward,omitempty" validate:"omitempty"`
	EmptyPacketsValue           *int `json:"empty_packets,omitempty" validate:"omitempty"`
	ErrorsAdaptationBrokenValue *int `json:"errors_adaptation_broken,omitempty" validate:"omitempty"`
	ErrorsPidLostValue          *int `json:"errors_pid_lost,omitempty" validate:"omitempty"`
	ErrorsTSCcValue             *int `json:"errors_ts_cc,omitempty" validate:"omitempty"`
	BrokenPesSumValue           *int `json:"broken_pes_sum,omitempty" validate:"omitempty"`
	TooLargeDtsJumpValue        *int `json:"too_large_dts_jump,omitempty" validate:"omitempty"`
	DiscardedBufferCountValue   *int `json:"discarded_buffer_count,omitempty" validate:"omitempty"`
	ErrorsTSTeiValue            *int `json:"errors_ts_tei,omitempty" validate:"omitempty"`
	FillersCountValue           *int `json:"fillers_count,omitempty" validate:"omitempty"`
	FillersSumValue             *int `json:"fillers_sum,omitempty" validate:"omitempty"`
	FramesValue                 *int `json:"frames,omitempty" validate:"omitempty"`
	ErrorsTSPmtValue            *int `json:"errors_ts_pmt,omitempty" validate:"omitempty"`
	PaddingPesCountValue        *int `json:"padding_pes_count,omitempty" validate:"omitempty"`
	PaddingPesSumValue          *int `json:"padding_pes_sum,omitempty" validate:"omitempty"`
	PcrResyncValue              *int `json:"pcr_resync,omitempty" validate:"omitempty"`
	ErrorsTSPsiChecksumValue    *int `json:"errors_ts_psi_checksum,omitempty" validate:"omitempty"`
	PnrValue                    *int `json:"pnr,omitempty" validate:"omitempty"`
	RepeatedFramesValue         *int `json:"repeated_frames,omitempty" validate:"omitempty"`
	TimeCorrectionsValue        *int `json:"time_corrections,omitempty" validate:"omitempty"`
	PidValue                    int  `json:"pid" validate:"required"`
}

type InputRTPCountersImpl struct {
	NalAudCountValue                    *int    `json:"nal_aud_count,omitempty" validate:"omitempty"`
	IncompleteNalCountValue             *int    `json:"incomplete_nal_count,omitempty" validate:"omitempty"`
	ContentValue                        *string `json:"content,omitempty" validate:"omitempty"`
	DiscardedBrokenNalCountValue        *int    `json:"discarded_broken_nal_count,omitempty" validate:"omitempty"`
	DiscardedFuCountValue               *int    `json:"discarded_fu_count,omitempty" validate:"omitempty"`
	DiscardedNalCountValue              *int    `json:"discarded_nal_count,omitempty" validate:"omitempty"`
	DiscardedNotAllowedNalCountValue    *int    `json:"discarded_not_allowed_nal_count,omitempty" validate:"omitempty"`
	DiscardedSeiCountValue              *int    `json:"discarded_sei_count,omitempty" validate:"omitempty"`
	ErrorsBrokenPayloadValue            *int    `json:"errors_broken_payload,omitempty" validate:"omitempty"`
	ErrorsDtsStuckValue                 *int    `json:"errors_dts_stuck,omitempty" validate:"omitempty"`
	ErrorsLostPacketsValue              *int    `json:"errors_lost_packets,omitempty" validate:"omitempty"`
	FramesValue                         *int    `json:"frames,omitempty" validate:"omitempty"`
	FuEndThenMiddleWorkaroundCountValue *int    `json:"fu_end_then_middle_workaround_count,omitempty" validate:"omitempty"`
	NalFillerCountValue                 *int    `json:"nal_filler_count,omitempty" validate:"omitempty"`
	FuPatternIsBrokenCountValue         *int    `json:"fu_pattern_is_broken_count,omitempty" validate:"omitempty"`
	NalCountValue                       *int    `json:"nal_count,omitempty" validate:"omitempty"`
	InvalidSeiPayloadCountValue         *int    `json:"invalid_sei_payload_count,omitempty" validate:"omitempty"`
	InvalidSeiSizeCountValue            *int    `json:"invalid_sei_size_count,omitempty" validate:"omitempty"`
	InvalidSeiTypeCountValue            *int    `json:"invalid_sei_type_count,omitempty" validate:"omitempty"`
	MarkerPacketsCountValue             *int    `json:"marker_packets_count,omitempty" validate:"omitempty"`
	NackCountValue                      *int    `json:"nack_count,omitempty" validate:"omitempty"`
	NalAggregationCountValue            *int    `json:"nal_aggregation_count,omitempty" validate:"omitempty"`
	TSStuckValue                        *int    `json:"ts_stuck,omitempty" validate:"omitempty"`
	BytesValue                          *int    `json:"bytes,omitempty" validate:"omitempty"`
	FuHasBothStartEndBitsCountValue     *int    `json:"fu_has_both_start_end_bits_count,omitempty" validate:"omitempty"`
	NalFuCountValue                     *int    `json:"nal_fu_count,omitempty" validate:"omitempty"`
	NalIdrCountValue                    *int    `json:"nal_idr_count,omitempty" validate:"omitempty"`
	NalOtherCountValue                  *int    `json:"nal_other_count,omitempty" validate:"omitempty"`
	NalPpsCountValue                    *int    `json:"nal_pps_count,omitempty" validate:"omitempty"`
	NalSeiCountValue                    *int    `json:"nal_sei_count,omitempty" validate:"omitempty"`
	NalSingleCountValue                 *int    `json:"nal_single_count,omitempty" validate:"omitempty"`
	NalSliceCountValue                  *int    `json:"nal_slice_count,omitempty" validate:"omitempty"`
	NalSpsCountValue                    *int    `json:"nal_sps_count,omitempty" validate:"omitempty"`
	NalStapACountValue                  *int    `json:"nal_stap_a_count,omitempty" validate:"omitempty"`
	NalVpsCountValue                    *int    `json:"nal_vps_count,omitempty" validate:"omitempty"`
	NoMarkerModeFlagValue               *bool   `json:"no_marker_mode_flag,omitempty" validate:"omitempty"`
	PtRejectCountValue                  *int    `json:"pt_reject_count,omitempty" validate:"omitempty"`
	PtRejectSumValue                    *int    `json:"pt_reject_sum,omitempty" validate:"omitempty"`
	RtcpPacketsValue                    *int    `json:"rtcp_packets,omitempty" validate:"omitempty"`
	RTPPacketsValue                     *int    `json:"rtp_packets,omitempty" validate:"omitempty"`
	SenderClockDeviationValue           *int    `json:"sender_clock_deviation,omitempty" validate:"omitempty"`
	SrTSStuckValue                      *int    `json:"sr_ts_stuck,omitempty" validate:"omitempty"`
	TSGoesBackwardsValue                *int    `json:"ts_goes_backwards,omitempty" validate:"omitempty"`
	TSJumpForwardValue                  *int    `json:"ts_jump_forward,omitempty" validate:"omitempty"`
	ChannelIDValue                      int     `json:"channel_id" validate:"required"`
}

// SDI,HDMI and other raw input counters
type InputSdiCountersImpl struct {
	AvgRecvDurationValue       *int `json:"avg_recv_duration,omitempty" validate:"omitempty"`
	CompensatedFramesValue     *int `json:"compensated_frames,omitempty" validate:"omitempty"`
	ErrorLostAudioValue        *int `json:"error_lost_audio,omitempty" validate:"omitempty"`
	ErrorsCpuStallValue        *int `json:"errors_cpu_stall,omitempty" validate:"omitempty"`
	ErrorsDuplicateValue       *int `json:"errors_duplicate,omitempty" validate:"omitempty"`
	ErrorsNoSignalValue        *int `json:"errors_no_signal,omitempty" validate:"omitempty"`
	ErrorsTSDuplicateValue     *int `json:"errors_ts_duplicate,omitempty" validate:"omitempty"`
	PeakDurationDeviationValue *int `json:"peak_duration_deviation,omitempty" validate:"omitempty"`
}

// SRT specific counters
type InputSrtCountersImpl struct {
	ErrorDroppedPacketsValue  *int `json:"error_dropped_packets,omitempty" validate:"omitempty"`
	ErrorLostPacketsValue     *int `json:"error_lost_packets,omitempty" validate:"omitempty"`
	LatencyValue              *int `json:"latency,omitempty" validate:"omitempty"`
	PacketsValue              *int `json:"packets,omitempty" validate:"omitempty"`
	RetransmittedPacketsValue *int `json:"retransmitted_packets,omitempty" validate:"omitempty"`
	RttValue                  *int `json:"rtt,omitempty" validate:"omitempty"`
}

type InputStatsImpl struct {
	InvalidSecondaryInputsValue *int                             `json:"invalid_secondary_inputs,omitempty" validate:"omitempty"`
	Errors403Value              *int                             `json:"errors_403,omitempty" validate:"omitempty"`
	AdSplicesInsertedValue      *int                             `json:"ad_splices_inserted,omitempty" validate:"omitempty"`
	AgentValue                  *InputAgentCountersImpl          `json:"agent,omitempty" validate:"omitempty"`
	BytesValue                  *Bytes                           `json:"bytes,omitempty" validate:"omitempty" openmetrics_metric:"stream_input_bytes"`
	BytesDvrValue               *Bytes                           `json:"bytes_dvr,omitempty" validate:"omitempty"`
	DivergentInputsValue        *bool                            `json:"divergent_inputs,omitempty" validate:"omitempty"`
	DvrInfoValue                *DvrInfoImpl                     `json:"dvr_info,omitempty" validate:"omitempty"`
	ErrorRateValue              *int                             `json:"error_rate,omitempty" validate:"omitempty"`
	ActiveValue                 *bool                            `json:"active,omitempty" validate:"omitempty"`
	InputSwitchesValue          *int                             `json:"input_switches,omitempty" validate:"omitempty"`
	Errors404Value              *int                             `json:"errors_404,omitempty" validate:"omitempty"`
	Errors500Value              *int                             `json:"errors_500,omitempty" validate:"omitempty"`
	ErrorsBrokenPayloadValue    *int                             `json:"errors_broken_payload,omitempty" validate:"omitempty"`
	ErrorsCrashedValue          *int                             `json:"errors_crashed,omitempty" validate:"omitempty"`
	ErrorsDecoderResetValue     *int                             `json:"errors_decoder_reset,omitempty" validate:"omitempty"`
	ErrorsDesyncValue           *int                             `json:"errors_desync,omitempty" validate:"omitempty"`
	ErrorsDroppedFramesValue    *int                             `json:"errors_dropped_frames,omitempty" validate:"omitempty"`
	ErrorsLostPacketsValue      *int                             `json:"errors_lost_packets,omitempty" validate:"omitempty"`
	ErrorsTSPatValue            *int                             `json:"errors_ts_pat,omitempty" validate:"omitempty"`
	ErrorsTSServiceLostValue    *int                             `json:"errors_ts_service_lost,omitempty" validate:"omitempty"`
	ErrorsTSStuckRestartsValue  *int                             `json:"errors_ts_stuck_restarts,omitempty" validate:"omitempty"`
	AdSplicesIngestedValue      *int                             `json:"ad_splices_ingested,omitempty" validate:"omitempty"`
	FramesValue                 *int                             `json:"frames,omitempty" validate:"omitempty"`
	ErrorsValue                 *int                             `json:"errors,omitempty" validate:"omitempty"`
	IPValue                     *string                          `json:"ip,omitempty" validate:"omitempty"`
	MediaInfoValue              *MediaInfoImpl                   `json:"media_info,omitempty" validate:"omitempty"`
	MediaInfoChangesValue       *int                             `json:"media_info_changes,omitempty" validate:"omitempty"`
	MotionDetectorValue         *InputMotionDetectorCountersImpl `json:"motion_detector,omitempty" validate:"omitempty"`
	NumSecNoDataValue           *Seconds                         `json:"num_sec_no_data,omitempty" validate:"omitempty"`
	NumSecOnPrimaryInputValue   *Seconds                         `json:"num_sec_on_primary_input,omitempty" validate:"omitempty"`
	NumSecOnSecondaryInputValue *Seconds                         `json:"num_sec_on_secondary_input,omitempty" validate:"omitempty"`
	OpenedAtValue               *UtcMs                           `json:"opened_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	ValidSecondaryInputsValue   *int                             `json:"valid_secondary_inputs,omitempty" validate:"omitempty"`
	ProtoValue                  *Protocol                        `json:"proto,omitempty" validate:"omitempty"`
	ReorderCountValue           *int                             `json:"reorder_count,omitempty" validate:"omitempty"`
	ResyncCountDriftValue       *int                             `json:"resync_count_drift,omitempty" validate:"omitempty"`
	ResyncCountJumpValue        *int                             `json:"resync_count_jump,omitempty" validate:"omitempty"`
	ResyncCountNormalValue      *int                             `json:"resync_count_normal,omitempty" validate:"omitempty"`
	RetriesValue                *int                             `json:"retries,omitempty" validate:"omitempty"`
	UserAgentValue              *string                          `json:"user_agent,omitempty" validate:"omitempty"`
	SdiValue                    *InputSdiCountersImpl            `json:"sdi,omitempty" validate:"omitempty"`
	SrtValue                    *InputSrtCountersImpl            `json:"srt,omitempty" validate:"omitempty"`
	TSDelayValue                *Ticks                           `json:"ts_delay,omitempty" validate:"omitempty"`
	URLValue                    *URL                             `json:"url,omitempty" validate:"omitempty"`
	TSDelayPerTracksValue       []Ticks                          `json:"ts_delay_per_tracks,omitempty" validate:"omitempty"`
	RTPChannelsValue            []*InputRTPCountersImpl          `json:"rtp_channels,omitempty" validate:"omitempty"`
	PidsValue                   []*InputPidCountersImpl          `json:"pids,omitempty" validate:"omitempty"`
}

type LoginInfoAdditionalImpl struct {
	AccessTokenValue  *string `json:"access_token,omitempty" validate:"omitempty"`
	RefreshTokenValue *string `json:"refresh_token,omitempty" validate:"omitempty"`
}

type LoginInfoBaseImpl struct {
	AccessTokenValue  *string `json:"access_token,omitempty" validate:"omitempty"`
	RefreshTokenValue *string `json:"refresh_token,omitempty" validate:"omitempty"`
}

type MapImpl struct {
	APIKeyValue   *string      `json:"api_key,omitempty" validate:"omitempty"`
	CenterValue   *MapSpecImpl `json:"center,omitempty" validate:"omitempty"`
	ProviderValue string       `json:"provider" validate:"required"`
	URLValue      URL          `json:"url" validate:"required"`
}

// Properties of the map
// Required: provider
type MapBaseImpl struct {
	APIKeyValue   *string      `json:"api_key,omitempty" validate:"omitempty"`
	CenterValue   *MapSpecImpl `json:"center,omitempty" validate:"omitempty"`
	ProviderValue string       `json:"provider" validate:"required"`
}

type MapCustomImpl struct {
	APIKeyValue   *string      `json:"api_key,omitempty" validate:"omitempty"`
	CenterValue   *MapSpecImpl `json:"center,omitempty" validate:"omitempty"`
	ProviderValue string       `json:"provider" validate:"required"`
	URLValue      URL          `json:"url" validate:"required"`
}

// Required: latitude, longitude
type MapSpecImpl struct {
	LatitudeValue  float64 `json:"latitude" validate:"required"`
	LongitudeValue float64 `json:"longitude" validate:"required"`
}

type MediaInfoImpl struct {
	DurationValue  *Ticks                     `json:"duration,omitempty" validate:"omitempty"`
	FlowTypeValue  *MediaInfoSpecificFlowType `json:"flow_type,omitempty" validate:"omitempty,oneof=file stream dvr_file dvr_stream"`
	ProgramIDValue *int                       `json:"program_id,omitempty" validate:"omitempty"`
	ProviderValue  *string                    `json:"provider,omitempty" validate:"omitempty"`
	StreamIDValue  *int                       `json:"stream_id,omitempty" validate:"omitempty"`
	TitleValue     *string                    `json:"title,omitempty" validate:"omitempty"`
	TracksValue    []*TrackInfoImpl           `json:"tracks,omitempty" validate:"omitempty"`
}

type MediaInfoCommonImpl struct {
	ProgramIDValue *int    `json:"program_id,omitempty" validate:"omitempty"`
	ProviderValue  *string `json:"provider,omitempty" validate:"omitempty"`
	StreamIDValue  *int    `json:"stream_id,omitempty" validate:"omitempty"`
	TitleValue     *string `json:"title,omitempty" validate:"omitempty"`
}

type MediaInfoSpecificImpl struct {
	DurationValue *Ticks                     `json:"duration,omitempty" validate:"omitempty"`
	FlowTypeValue *MediaInfoSpecificFlowType `json:"flow_type,omitempty" validate:"omitempty,oneof=file stream dvr_file dvr_stream"`
	TracksValue   []*TrackInfoImpl           `json:"tracks,omitempty" validate:"omitempty"`
}

type MessageImpl struct {
	BodyValue        *string            `json:"body,omitempty" validate:"omitempty"`
	IDValue          *int               `json:"id,omitempty" validate:"omitempty"`
	IsDashboardValue *bool              `json:"is_dashboard,omitempty" validate:"omitempty"`
	IsDeletedValue   *bool              `json:"is_deleted,omitempty" validate:"omitempty"`
	IsPushValue      *bool              `json:"is_push,omitempty" validate:"omitempty"`
	SenderValue      *MessageSenderImpl `json:"sender,omitempty" validate:"omitempty"`
	TitleValue       *string            `json:"title,omitempty" validate:"omitempty"`
	TypeValue        *MessageBaseType   `json:"type,omitempty" validate:"omitempty,oneof=info warning danger"`
	UserValue        *MessageUserImpl   `json:"user,omitempty" validate:"omitempty"`
	WasReadValue     *bool              `json:"was_read,omitempty" validate:"omitempty"`
}

// The message that will be sent to the user.
type MessageBaseImpl struct {
	BodyValue        *string          `json:"body,omitempty" validate:"omitempty"`
	IsDashboardValue *bool            `json:"is_dashboard,omitempty" validate:"omitempty"`
	IsPushValue      *bool            `json:"is_push,omitempty" validate:"omitempty"`
	TitleValue       *string          `json:"title,omitempty" validate:"omitempty"`
	TypeValue        *MessageBaseType `json:"type,omitempty" validate:"omitempty,oneof=info warning danger"`
}

type MessageChangeRequestImpl struct {
	BodyValue        *string          `json:"body,omitempty" validate:"omitempty"`
	IsDashboardValue *bool            `json:"is_dashboard,omitempty" validate:"omitempty"`
	IsPushValue      *bool            `json:"is_push,omitempty" validate:"omitempty"`
	TitleValue       *string          `json:"title,omitempty" validate:"omitempty"`
	TypeValue        *MessageBaseType `json:"type,omitempty" validate:"omitempty,oneof=info warning danger"`
	WasReadValue     *bool            `json:"was_read,omitempty" validate:"omitempty"`
}

type MessageResponseImpl struct {
	BodyValue        *string            `json:"body,omitempty" validate:"omitempty"`
	DevicesValue     *int               `json:"devices,omitempty" validate:"omitempty"`
	IDValue          *int               `json:"id,omitempty" validate:"omitempty"`
	IsDashboardValue *bool              `json:"is_dashboard,omitempty" validate:"omitempty"`
	IsDeletedValue   *bool              `json:"is_deleted,omitempty" validate:"omitempty"`
	IsPushValue      *bool              `json:"is_push,omitempty" validate:"omitempty"`
	SenderValue      *MessageSenderImpl `json:"sender,omitempty" validate:"omitempty"`
	TitleValue       *string            `json:"title,omitempty" validate:"omitempty"`
	TypeValue        *MessageBaseType   `json:"type,omitempty" validate:"omitempty,oneof=info warning danger"`
	UserValue        *MessageUserImpl   `json:"user,omitempty" validate:"omitempty"`
	WasReadValue     *bool              `json:"was_read,omitempty" validate:"omitempty"`
}

type MessageSendImpl struct {
	BodyValue        *string          `json:"body,omitempty" validate:"omitempty"`
	IsDashboardValue *bool            `json:"is_dashboard,omitempty" validate:"omitempty"`
	IsPushValue      *bool            `json:"is_push,omitempty" validate:"omitempty"`
	TitleValue       *string          `json:"title,omitempty" validate:"omitempty"`
	TypeValue        *MessageBaseType `json:"type,omitempty" validate:"omitempty,oneof=info warning danger"`
	UserIDValue      *int             `json:"user_id,omitempty" validate:"omitempty"`
}

// Message sender
type MessageSenderImpl struct {
	IDValue   *int    `json:"id,omitempty" validate:"omitempty"`
	NameValue *string `json:"name,omitempty" validate:"omitempty"`
}

// Message recipient
type MessageUserImpl struct {
	IDValue   *int    `json:"id,omitempty" validate:"omitempty"`
	NameValue *string `json:"name,omitempty" validate:"omitempty"`
}

type MessagesImpl struct {
	TimingValue         any            `json:"timing,omitempty" validate:"omitempty"`
	EstimatedCountValue *int           `json:"estimated_count,omitempty" validate:"omitempty"`
	NextValue           *string        `json:"next,omitempty" validate:"omitempty"`
	PrevValue           *string        `json:"prev,omitempty" validate:"omitempty"`
	MessagesValue       []*MessageImpl `json:"messages,omitempty" validate:"omitempty"`
}

type MosaicImpl struct {
	IDValue             *int                `json:"id,omitempty" validate:"omitempty"`
	OrganizationIDValue *int                `json:"organization_id,omitempty" validate:"omitempty"`
	TitleValue          *string             `json:"title,omitempty" validate:"omitempty"`
	TypeValue           *MosaicBaseType     `json:"type,omitempty" validate:"omitempty,oneof=1x7 2x2 3x3 4x4 5x5 6x6 7x7 8x8"`
	StreamsValue        []*MosaicStreamImpl `json:"streams,omitempty" validate:"omitempty"`
}

type MosaicBaseImpl struct {
	OrganizationIDValue *int            `json:"organization_id,omitempty" validate:"omitempty"`
	TitleValue          *string         `json:"title,omitempty" validate:"omitempty"`
	TypeValue           *MosaicBaseType `json:"type,omitempty" validate:"omitempty,oneof=1x7 2x2 3x3 4x4 5x5 6x6 7x7 8x8"`
}

type MosaicSaveImpl struct {
	OrganizationIDValue *int                         `json:"organization_id,omitempty" validate:"omitempty"`
	TitleValue          *string                      `json:"title,omitempty" validate:"omitempty"`
	TypeValue           *MosaicBaseType              `json:"type,omitempty" validate:"omitempty,oneof=1x7 2x2 3x3 4x4 5x5 6x6 7x7 8x8"`
	StreamsValue        []*MosaicSaveStreamsItemImpl `json:"streams,omitempty" validate:"omitempty"`
}

type MosaicSaveStreamsItemImpl struct {
	NameValue *MediaName `json:"name,omitempty" validate:"omitempty"`
}

// The link to the stream.
// There may be an empty object. An empty object corresponds to a cell without a stream.
type MosaicStreamImpl struct {
	AliveValue             *bool      `json:"alive,omitempty" validate:"omitempty"`
	NameValue              *MediaName `json:"name,omitempty" validate:"omitempty"`
	PlaybackTokenValue     *string    `json:"playback_token,omitempty" validate:"omitempty"`
	StreamingEndpointValue *string    `json:"streaming_endpoint,omitempty" validate:"omitempty"`
	TitleValue             *string    `json:"title,omitempty" validate:"omitempty"`
}

type MosaicsListImpl struct {
	TimingValue         any           `json:"timing,omitempty" validate:"omitempty"`
	EstimatedCountValue *int          `json:"estimated_count,omitempty" validate:"omitempty"`
	NextValue           *string       `json:"next,omitempty" validate:"omitempty"`
	PrevValue           *string       `json:"prev,omitempty" validate:"omitempty"`
	MosaicsValue        []*MosaicImpl `json:"mosaics,omitempty" validate:"omitempty"`
}

// Notification data
// Required: title, body
type NotificationsRequestImpl struct {
	BodyValue  string `json:"body" validate:"required"`
	TitleValue string `json:"title" validate:"required"`
}

type OnOffImpl struct {
	ModeValue *OnOffMode `json:"mode,omitempty" validate:"omitempty,oneof=on off"`
}

type OnOffAutoImpl struct {
	ModeValue *OnOffAutoMode `json:"mode,omitempty" validate:"omitempty,oneof=on off auto"`
}

type OrganizationImpl struct {
	CreatedAtValue       *UtcMs                       `json:"created_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	IsDefaultValue       *bool                        `json:"is_default,omitempty" validate:"omitempty"`
	LimitsValue          *OrganizationLimitsImpl      `json:"limits,omitempty" validate:"omitempty"`
	OwnerValue           *OrganizationOwnerImpl       `json:"owner,omitempty" validate:"omitempty"`
	PickpointValue       *OrganizationPickpointImpl   `json:"pickpoint,omitempty" validate:"omitempty"`
	StatsValue           *OrganizationStatsImpl       `json:"stats,omitempty" validate:"omitempty"`
	UserPermissionsValue *OrganizationPermissionsImpl `json:"user_permissions,omitempty" validate:"omitempty"`
	TitleValue           string                       `json:"title" validate:"required"`
	IDValue              int                          `json:"id" validate:"required"`
}

// Required: id, title
type OrganizationBaseImpl struct {
	TitleValue string `json:"title" validate:"required"`
	IDValue    int    `json:"id" validate:"required"`
}

type OrganizationInviteKeyImpl struct {
	InviteKeyValue   *string                                 `json:"invite_key,omitempty" validate:"omitempty"`
	PermissionsValue *OrganizationInviteSetupPermissionsImpl `json:"permissions,omitempty" validate:"omitempty"`
}

type OrganizationInviteSetupImpl struct {
	PermissionsValue *OrganizationInviteSetupPermissionsImpl `json:"permissions,omitempty" validate:"omitempty"`
}

// User permissions in organization.
type OrganizationInviteSetupPermissionsImpl struct {
	CanEditStreamsValue *bool `json:"can_edit_streams,omitempty" validate:"omitempty"`
	CanEditUsersValue   *bool `json:"can_edit_users,omitempty" validate:"omitempty"`
	CanViewStatsValue   *bool `json:"can_view_stats,omitempty" validate:"omitempty"`
	CanViewStreamsValue *bool `json:"can_view_streams,omitempty" validate:"omitempty"`
}

// Limits for properties in organization.
type OrganizationLimitsImpl struct {
	StreamsValue *int `json:"streams,omitempty" validate:"omitempty"`
	UsersValue   *int `json:"users,omitempty" validate:"omitempty"`
}

// Owner properties.
type OrganizationOwnerImpl struct {
	IDValue   *int    `json:"id,omitempty" validate:"omitempty"`
	NameValue *string `json:"name,omitempty" validate:"omitempty"`
}

type OrganizationPermissionsImpl struct {
	CanEditPersonsListsValue *bool `json:"can_edit_persons_lists,omitempty" validate:"omitempty"`
	CanEditStreamsValue      *bool `json:"can_edit_streams,omitempty" validate:"omitempty"`
	CanEditUsersValue        *bool `json:"can_edit_users,omitempty" validate:"omitempty"`
	CanViewPersonsListsValue *bool `json:"can_view_persons_lists,omitempty" validate:"omitempty"`
	CanViewStatsValue        *bool `json:"can_view_stats,omitempty" validate:"omitempty"`
	CanViewStreamsValue      *bool `json:"can_view_streams,omitempty" validate:"omitempty"`
	IsMemberValue            *bool `json:"is_member,omitempty" validate:"omitempty"`
}

type OrganizationPickpointImpl struct {
}

type OrganizationPresetImpl struct {
	PresetIDValue *int `json:"preset_id,omitempty" validate:"omitempty"`
}

// Counts for streams, users and mosaics in organization.
type OrganizationStatsImpl struct {
	MosaicsValue *int `json:"mosaics,omitempty" validate:"omitempty"`
	StreamsValue *int `json:"streams,omitempty" validate:"omitempty"`
	UsersValue   *int `json:"users,omitempty" validate:"omitempty"`
}

type OrganizationStreamImpl struct {
	IDValue    *int    `json:"id,omitempty" validate:"omitempty"`
	TitleValue *string `json:"title,omitempty" validate:"omitempty"`
}

type OrganizationUserImpl struct {
	EmailValue       *string                          `json:"email,omitempty" validate:"omitempty"`
	IDValue          *int                             `json:"id,omitempty" validate:"omitempty"`
	NameValue        *string                          `json:"name,omitempty" validate:"omitempty"`
	PermissionsValue *OrganizationUserPermissionsImpl `json:"permissions,omitempty" validate:"omitempty"`
}

// User permissions
type OrganizationUserPermissionsImpl struct {
	OrganizationValue *OrganizationPermissionsImpl `json:"organization,omitempty" validate:"omitempty"`
	FoldersValue      []any                        `json:"folders,omitempty" validate:"omitempty"`
}

type OrganizationUsersListImpl struct {
	EstimatedCountValue *int                    `json:"estimated_count,omitempty" validate:"omitempty"`
	NextValue           *string                 `json:"next,omitempty" validate:"omitempty"`
	PrevValue           *string                 `json:"prev,omitempty" validate:"omitempty"`
	TimingValue         any                     `json:"timing,omitempty" validate:"omitempty"`
	UsersValue          []*OrganizationUserImpl `json:"users,omitempty" validate:"omitempty"`
}

type OrganizationsListImpl struct {
	TimingValue         any                 `json:"timing,omitempty" validate:"omitempty"`
	EstimatedCountValue *int                `json:"estimated_count,omitempty" validate:"omitempty"`
	NextValue           *string             `json:"next,omitempty" validate:"omitempty"`
	PrevValue           *string             `json:"prev,omitempty" validate:"omitempty"`
	OrganizationsValue  []*OrganizationImpl `json:"organizations,omitempty" validate:"omitempty"`
}

type PasswordRecoveryImpl struct {
	EmailValue *Email `json:"email,omitempty" validate:"omitempty"`
}

type PasswordResetImpl struct {
	PasswordValue *string `json:"password,omitempty" validate:"omitempty,min=5,max=128"`
}

// Person
// Required: person_id, updated_at, originator
type PersonImpl struct {
	DeletedAtValue    *UtcMs                       `json:"deleted_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	ExternalIDValue   *string                      `json:"external_id,omitempty" validate:"omitempty"`
	FirstSeenAtValue  *UtcMs                       `json:"first_seen_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	LastSeenAtValue   *UtcMs                       `json:"last_seen_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	NameValue         *string                      `json:"name,omitempty" validate:"omitempty"`
	OrganizationValue *OrganizationBaseImpl        `json:"organization,omitempty" validate:"omitempty"`
	PersonListValue   *PersonPersonListImpl        `json:"person_list,omitempty" validate:"omitempty"`
	OriginatorValue   VisionPersonOriginator       `json:"originator" validate:"required"`
	PhotosValue       []*VisionImageAttributesImpl `json:"photos,omitempty" validate:"omitempty"`
	PersonIDValue     SnowflakeID                  `json:"person_id" validate:"required"`
	UpdatedAtValue    UtcMs                        `json:"updated_at" validate:"required,min=1e+12,max=1e+13"`
}

type PersonListsImpl struct {
	IDValue           *int                  `json:"id,omitempty" validate:"omitempty"`
	NameValue         *string               `json:"name,omitempty" validate:"omitempty"`
	OrganizationValue *OrganizationBaseImpl `json:"organization,omitempty" validate:"omitempty"`
	StatsValue        *PersonListsStatsImpl `json:"stats,omitempty" validate:"omitempty"`
}

type PersonListsListImpl struct {
	TimingValue         any                `json:"timing,omitempty" validate:"omitempty"`
	EstimatedCountValue *int               `json:"estimated_count,omitempty" validate:"omitempty"`
	NextValue           *string            `json:"next,omitempty" validate:"omitempty"`
	PrevValue           *string            `json:"prev,omitempty" validate:"omitempty"`
	PersonListsValue    []*PersonListsImpl `json:"person_lists,omitempty" validate:"omitempty"`
}

// Counts elements in a list based on specific attributes.
type PersonListsStatsImpl struct {
	CameraValue *int `json:"camera,omitempty" validate:"omitempty"`
	PersonValue *int `json:"person,omitempty" validate:"omitempty"`
}

// Person list details
type PersonPersonListImpl struct {
	IDValue   *int    `json:"id,omitempty" validate:"omitempty"`
	NameValue *string `json:"name,omitempty" validate:"omitempty"`
}

type PersonsListImpl struct {
	TimingValue         any                 `json:"timing,omitempty" validate:"omitempty"`
	EstimatedCountValue *int                `json:"estimated_count,omitempty" validate:"omitempty"`
	NextValue           *string             `json:"next,omitempty" validate:"omitempty"`
	PrevValue           *string             `json:"prev,omitempty" validate:"omitempty"`
	PersonsValue        []*VisionPersonImpl `json:"persons" validate:"required"`
}

// Required: id, title
type PresetImpl struct {
	DvrValue          *StreamDvrSpecImpl     `json:"dvr,omitempty" validate:"omitempty"`
	IsAdjustableValue *bool                  `json:"is_adjustable,omitempty" validate:"omitempty"`
	IsDefaultValue    *bool                  `json:"is_default,omitempty" validate:"omitempty"`
	LastChangeValue   *PresetLastChangeImpl  `json:"last_change,omitempty" validate:"omitempty"`
	StatsValue        *PresetStatsImpl       `json:"stats,omitempty" validate:"omitempty"`
	VisionValue       *VisionSpecPresetsImpl `json:"vision,omitempty" validate:"omitempty"`
	TitleValue        string                 `json:"title" validate:"required"`
	IDValue           int                    `json:"id" validate:"required"`
}

type PresetLastChangeImpl struct {
	UpdatedAtValue *UtcMs                    `json:"updated_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	UserValue      *PresetLastChangeUserImpl `json:"user,omitempty" validate:"omitempty"`
}

// Information about the user who modified.
type PresetLastChangeUserImpl struct {
	IDValue   *int    `json:"id,omitempty" validate:"omitempty"`
	NameValue *string `json:"name,omitempty" validate:"omitempty"`
}

// Statistics of the preset.
type PresetStatsImpl struct {
	OrganizationsCountValue *int `json:"organizations_count,omitempty" validate:"omitempty"`
	StreamsCountValue       *int `json:"streams_count,omitempty" validate:"omitempty"`
}

type PresetsListImpl struct {
	TimingValue         any           `json:"timing,omitempty" validate:"omitempty"`
	EstimatedCountValue *int          `json:"estimated_count,omitempty" validate:"omitempty"`
	NextValue           *string       `json:"next,omitempty" validate:"omitempty"`
	PrevValue           *string       `json:"prev,omitempty" validate:"omitempty"`
	PresetsValue        []*PresetImpl `json:"presets,omitempty" validate:"omitempty"`
}

type ProfileImpl struct {
	ApikeyValue        *string      `json:"apikey,omitempty" validate:"omitempty"`
	CreatedAtValue     *UtcMs       `json:"created_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	EmailValue         *Email       `json:"email,omitempty" validate:"omitempty"`
	FullnameValue      *string      `json:"fullname,omitempty" validate:"omitempty"`
	IsAdminValue       *bool        `json:"is_admin,omitempty" validate:"omitempty"`
	IsDomainAdminValue *bool        `json:"is_domain_admin,omitempty" validate:"omitempty"`
	IsReadonlyValue    *bool        `json:"is_readonly,omitempty" validate:"omitempty"`
	LocaleValue        *ISO6391     `json:"locale,omitempty" validate:"omitempty"`
	MaxSessionsValue   *int         `json:"max_sessions,omitempty" validate:"omitempty"`
	NameValue          *string      `json:"name,omitempty" validate:"omitempty"`
	NoteValue          *string      `json:"note,omitempty" validate:"omitempty"`
	PasswordValue      *string      `json:"password,omitempty" validate:"omitempty"`
	PhoneValue         *PhoneNumber `json:"phone,omitempty" validate:"omitempty"`
}

type PtzCommandImpl struct {
	CommandValue *string `json:"command,omitempty" validate:"omitempty"`
	DownValue    *int    `json:"down,omitempty" validate:"omitempty,min=0,max=100"`
	InValue      *int    `json:"in,omitempty" validate:"omitempty,min=0,max=100"`
	LeftValue    *int    `json:"left,omitempty" validate:"omitempty,min=0,max=100"`
	OutValue     *int    `json:"out,omitempty" validate:"omitempty,min=0,max=100"`
	RightValue   *int    `json:"right,omitempty" validate:"omitempty,min=0,max=100"`
	UpValue      *int    `json:"up,omitempty" validate:"omitempty,min=0,max=100"`
}

type PtzMoveContinuousImpl struct {
	CommandValue *string `json:"command,omitempty" validate:"omitempty"`
	DownValue    *int    `json:"down,omitempty" validate:"omitempty,min=0,max=100"`
	InValue      *int    `json:"in,omitempty" validate:"omitempty,min=0,max=100"`
	LeftValue    *int    `json:"left,omitempty" validate:"omitempty,min=0,max=100"`
	OutValue     *int    `json:"out,omitempty" validate:"omitempty,min=0,max=100"`
	RightValue   *int    `json:"right,omitempty" validate:"omitempty,min=0,max=100"`
	UpValue      *int    `json:"up,omitempty" validate:"omitempty,min=0,max=100"`
}

// Required: channel_id
type RTPCountersBaseImpl struct {
	NackCountValue            *int    `json:"nack_count,omitempty" validate:"omitempty"`
	PtRejectCountValue        *int    `json:"pt_reject_count,omitempty" validate:"omitempty"`
	ContentValue              *string `json:"content,omitempty" validate:"omitempty"`
	NoMarkerModeFlagValue     *bool   `json:"no_marker_mode_flag,omitempty" validate:"omitempty"`
	ErrorsDtsStuckValue       *int    `json:"errors_dts_stuck,omitempty" validate:"omitempty"`
	ErrorsLostPacketsValue    *int    `json:"errors_lost_packets,omitempty" validate:"omitempty"`
	FramesValue               *int    `json:"frames,omitempty" validate:"omitempty"`
	MarkerPacketsCountValue   *int    `json:"marker_packets_count,omitempty" validate:"omitempty"`
	TSStuckValue              *int    `json:"ts_stuck,omitempty" validate:"omitempty"`
	BytesValue                *int    `json:"bytes,omitempty" validate:"omitempty"`
	ErrorsBrokenPayloadValue  *int    `json:"errors_broken_payload,omitempty" validate:"omitempty"`
	PtRejectSumValue          *int    `json:"pt_reject_sum,omitempty" validate:"omitempty"`
	RtcpPacketsValue          *int    `json:"rtcp_packets,omitempty" validate:"omitempty"`
	RTPPacketsValue           *int    `json:"rtp_packets,omitempty" validate:"omitempty"`
	SenderClockDeviationValue *int    `json:"sender_clock_deviation,omitempty" validate:"omitempty"`
	SrTSStuckValue            *int    `json:"sr_ts_stuck,omitempty" validate:"omitempty"`
	TSGoesBackwardsValue      *int    `json:"ts_goes_backwards,omitempty" validate:"omitempty"`
	TSJumpForwardValue        *int    `json:"ts_jump_forward,omitempty" validate:"omitempty"`
	ChannelIDValue            int     `json:"channel_id" validate:"required"`
}

type SensorImpl struct {
	BlacklightCompensationValue *OnOffImpl              `json:"blacklight_compensation,omitempty" validate:"omitempty"`
	BrightnessCorrectionValue   *Percent                `json:"brightness_correction,omitempty" validate:"omitempty,min=0,max=100"`
	ContrastCorrectionValue     *Percent                `json:"contrast_correction,omitempty" validate:"omitempty,min=0,max=100"`
	ImageOrientationValue       *SensorImageOrientation `json:"image_orientation,omitempty" validate:"omitempty,oneof=normal upside_down"`
	InfraredCutoffFilterValue   *OnOffAutoImpl          `json:"infrared_cutoff_filter,omitempty" validate:"omitempty"`
	SaturationValue             *Percent                `json:"saturation,omitempty" validate:"omitempty,min=0,max=100"`
	SharpnessValue              *Percent                `json:"sharpness,omitempty" validate:"omitempty,min=0,max=100"`
	WideDynamicRangeValue       *Percent                `json:"wide_dynamic_range,omitempty" validate:"omitempty,min=0,max=100"`
}

// A stream who has been granted access via stream permissions.
type StreamBaseStreamPermissionsImpl struct {
	NameValue *string `json:"name,omitempty" validate:"omitempty"`
}

type StreamConfigImpl struct {
	LastEpisodeAtValue          *UtcMs                        `json:"last_episode_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	StatsValue                  *StreamStatsImpl              `json:"stats,omitempty" validate:"omitempty"`
	CommentValue                *string                       `json:"comment,omitempty" validate:"omitempty"`
	CoordinatesValue            *MapSpecImpl                  `json:"coordinates,omitempty" validate:"omitempty"`
	CreatedAtValue              *UtcMs                        `json:"created_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	DisabledValue               *bool                         `json:"disabled,omitempty" validate:"omitempty"`
	DvrValue                    *StreamDvrSpecImpl            `json:"dvr,omitempty" validate:"omitempty"`
	FirmwareUpdateDurationValue *Milliseconds                 `json:"firmware_update_duration,omitempty" validate:"omitempty"`
	FolderIDValue               *int                          `json:"folder_id,omitempty" validate:"omitempty"`
	VisionValue                 *VisionSpecImpl               `json:"vision,omitempty" validate:"omitempty"`
	IsFavouriteValue            *bool                         `json:"is_favourite,omitempty" validate:"omitempty"`
	TitleValue                  *string                       `json:"title,omitempty" validate:"omitempty"`
	CanPublishValue             *bool                         `json:"can_publish,omitempty" validate:"omitempty"`
	AudioValue                  *WatcherStreamConfigAudioImpl `json:"audio,omitempty" validate:"omitempty"`
	LastChangeValue             *AuditLogRecordImpl           `json:"last_change,omitempty" validate:"omitempty"`
	NotificationsEnabledValue   *bool                         `json:"notifications_enabled,omitempty" validate:"omitempty"`
	OnvifValue                  *StreamOnvifConfigImpl        `json:"onvif,omitempty" validate:"omitempty"`
	OrganizationValue           *OrganizationStreamImpl       `json:"organization,omitempty" validate:"omitempty"`
	OrganizationIDValue         *int                          `json:"organization_id,omitempty" validate:"omitempty"`
	MapCoordinatesValue         *MapSpecImpl                  `json:"map_coordinates,omitempty" validate:"omitempty"`
	PostalAddressValue          *string                       `json:"postal_address,omitempty" validate:"omitempty"`
	PresetValue                 *StreamPresetImpl             `json:"preset,omitempty" validate:"omitempty"`
	PresetIDValue               *int                          `json:"preset_id,omitempty" validate:"omitempty"`
	StaticValue                 *bool                         `json:"static,omitempty" validate:"omitempty"`
	NameValue                   MediaName                     `json:"name" validate:"required" openmetrics_label:"name"`
	PathValue                   []*StreamPathItemImpl         `json:"path,omitempty" validate:"omitempty"`
	InputsValue                 []StreamInput                 `json:"inputs,omitempty" validate:"omitempty"`
}

type StreamConfigAdditionalImpl struct {
	StatsValue *StreamStatsImpl `json:"stats,omitempty" validate:"omitempty"`
}

type StreamConfigBaseImpl struct {
	DisabledValue *bool `json:"disabled,omitempty" validate:"omitempty"`
	StaticValue   *bool `json:"static,omitempty" validate:"omitempty"`
}

type StreamConfigInputImpl struct {
	InputsValue []StreamInput `json:"inputs,omitempty" validate:"omitempty"`
}

type StreamConfigMediaImpl struct {
	DvrValue *StreamDvrSpecImpl `json:"dvr,omitempty" validate:"omitempty"`
}

type StreamConfigMultieditImpl struct {
	DvrValue      *StreamDvrSpecImpl `json:"dvr,omitempty" validate:"omitempty"`
	NameValue     *string            `json:"name,omitempty" validate:"omitempty"`
	PresetIDValue *int               `json:"preset_id,omitempty" validate:"omitempty"`
}

type StreamConfigOnpremisesImpl struct {
	VisionValue *VisionSpecImpl `json:"vision,omitempty" validate:"omitempty"`
}

// Required: name
type StreamConfigSpecificImpl struct {
	CommentValue *string   `json:"comment,omitempty" validate:"omitempty"`
	TitleValue   *string   `json:"title,omitempty" validate:"omitempty"`
	NameValue    MediaName `json:"name" validate:"required" openmetrics_label:"name"`
}

type StreamDvrSpecImpl struct {
	EpisodesExpirationValue *Seconds `json:"episodes_expiration,omitempty" validate:"omitempty"`
	ExpirationValue         *Seconds `json:"expiration,omitempty" validate:"omitempty"`
	RedundancyFactorValue   *int     `json:"redundancy_factor,omitempty" validate:"omitempty,min=0"`
	StorageLimitValue       *Bytes   `json:"storage_limit,omitempty" validate:"omitempty"`
}

type StreamDvrSpecificSpecImpl struct {
	RedundancyFactorValue *int `json:"redundancy_factor,omitempty" validate:"omitempty,min=0"`
}

type StreamInputBaseImpl struct {
	AllowIfValue                 *string           `json:"allow_if,omitempty" validate:"omitempty"`
	AudioTimeoutValue            *Seconds          `json:"audio_timeout,omitempty" validate:"omitempty"`
	CommentValue                 *string           `json:"comment,omitempty" validate:"omitempty"`
	DenyIfValue                  *string           `json:"deny_if,omitempty" validate:"omitempty"`
	FramesTimeoutValue           *int              `json:"frames_timeout,omitempty" validate:"omitempty"`
	HeadersValue                 map[string]string `json:"headers,omitempty" validate:"omitempty"`
	MaxRetryTimeoutValue         *Seconds          `json:"max_retry_timeout,omitempty" validate:"omitempty,min=1"`
	NoClientsReconnectDelayValue *int              `json:"no_clients_reconnect_delay,omitempty" validate:"omitempty"`
	OutputAudioValue             *OutputAudio      `json:"output_audio,omitempty" validate:"omitempty"`
	PriorityValue                *int              `json:"priority,omitempty" validate:"omitempty"`
	SourceTimeoutValue           any               `json:"source_timeout,omitempty" validate:"omitempty"`
	StatsValue                   *InputStatsImpl   `json:"stats,omitempty" validate:"omitempty"`
	TimeoutValue                 *int              `json:"timeout,omitempty" validate:"omitempty"`
	UserAgentValue               *string           `json:"user_agent,omitempty" validate:"omitempty"`
	ViaValue                     *AgentURL         `json:"via,omitempty" validate:"omitempty"`
	VideoTimeoutValue            *Seconds          `json:"video_timeout,omitempty" validate:"omitempty"`
}

type StreamInputFakeImpl struct {
	SourceTimeoutValue           any               `json:"source_timeout,omitempty" validate:"omitempty"`
	OutputAudioValue             *OutputAudio      `json:"output_audio,omitempty" validate:"omitempty"`
	PriorityValue                *int              `json:"priority,omitempty" validate:"omitempty"`
	CommentValue                 *string           `json:"comment,omitempty" validate:"omitempty"`
	AllowIfValue                 *string           `json:"allow_if,omitempty" validate:"omitempty"`
	FramesTimeoutValue           *int              `json:"frames_timeout,omitempty" validate:"omitempty"`
	HeadersValue                 map[string]string `json:"headers,omitempty" validate:"omitempty"`
	HeightValue                  *int              `json:"height,omitempty" validate:"omitempty"`
	MaxRetryTimeoutValue         *Seconds          `json:"max_retry_timeout,omitempty" validate:"omitempty,min=1"`
	BitrateValue                 *Speed            `json:"bitrate,omitempty" validate:"omitempty"`
	NoClientsReconnectDelayValue *int              `json:"no_clients_reconnect_delay,omitempty" validate:"omitempty"`
	DenyIfValue                  *string           `json:"deny_if,omitempty" validate:"omitempty"`
	AudioTimeoutValue            *Seconds          `json:"audio_timeout,omitempty" validate:"omitempty"`
	StatsValue                   *InputStatsImpl   `json:"stats,omitempty" validate:"omitempty"`
	TimeoutValue                 *int              `json:"timeout,omitempty" validate:"omitempty"`
	WidthValue                   *int              `json:"width,omitempty" validate:"omitempty"`
	UserAgentValue               *string           `json:"user_agent,omitempty" validate:"omitempty"`
	ViaValue                     *AgentURL         `json:"via,omitempty" validate:"omitempty"`
	VideoTimeoutValue            *Seconds          `json:"video_timeout,omitempty" validate:"omitempty"`
	URLValue                     InputURL          `json:"url" validate:"required"`
}

type StreamInputFileImpl struct {
	SourceTimeoutValue           any                                 `json:"source_timeout,omitempty" validate:"omitempty"`
	FramesTimeoutValue           *int                                `json:"frames_timeout,omitempty" validate:"omitempty"`
	PriorityValue                *int                                `json:"priority,omitempty" validate:"omitempty"`
	CommentValue                 *string                             `json:"comment,omitempty" validate:"omitempty"`
	DenyIfValue                  *string                             `json:"deny_if,omitempty" validate:"omitempty"`
	AllowIfValue                 *string                             `json:"allow_if,omitempty" validate:"omitempty"`
	HeadersValue                 map[string]string                   `json:"headers,omitempty" validate:"omitempty"`
	LanguagesValue               map[string]string                   `json:"languages,omitempty" validate:"omitempty"`
	MaxRetryTimeoutValue         *Seconds                            `json:"max_retry_timeout,omitempty" validate:"omitempty,min=1"`
	NoClientsReconnectDelayValue *int                                `json:"no_clients_reconnect_delay,omitempty" validate:"omitempty"`
	VideoTimeoutValue            *Seconds                            `json:"video_timeout,omitempty" validate:"omitempty"`
	ClosedCaptionsValue          map[string]string                   `json:"closed_captions,omitempty" validate:"omitempty"`
	ViaValue                     *AgentURL                           `json:"via,omitempty" validate:"omitempty"`
	OutputAudioValue             *OutputAudio                        `json:"output_audio,omitempty" validate:"omitempty"`
	Scte35Value                  *bool                               `json:"scte35,omitempty" validate:"omitempty"`
	AudioTimeoutValue            *Seconds                            `json:"audio_timeout,omitempty" validate:"omitempty"`
	StatsValue                   *InputStatsImpl                     `json:"stats,omitempty" validate:"omitempty"`
	SubtitlesValue               *StreamInputMpegtsSpecificSubtitles `json:"subtitles,omitempty" validate:"omitempty,oneof=drop accept ocr_replace ocr_add"`
	TimeoutValue                 *int                                `json:"timeout,omitempty" validate:"omitempty"`
	UserAgentValue               *string                             `json:"user_agent,omitempty" validate:"omitempty"`
	URLValue                     InputURL                            `json:"url" validate:"required"`
	PidsValue                    []int                               `json:"pids,omitempty" validate:"omitempty"`
	ProgramsValue                []int                               `json:"programs,omitempty" validate:"omitempty"`
}

type StreamInputMpegtsSpecificImpl struct {
	ClosedCaptionsValue map[string]string                   `json:"closed_captions,omitempty" validate:"omitempty"`
	LanguagesValue      map[string]string                   `json:"languages,omitempty" validate:"omitempty"`
	Scte35Value         *bool                               `json:"scte35,omitempty" validate:"omitempty"`
	SubtitlesValue      *StreamInputMpegtsSpecificSubtitles `json:"subtitles,omitempty" validate:"omitempty,oneof=drop accept ocr_replace ocr_add"`
	PidsValue           []int                               `json:"pids,omitempty" validate:"omitempty"`
	ProgramsValue       []int                               `json:"programs,omitempty" validate:"omitempty"`
}

type StreamInputPublishImpl struct {
	SourceTimeoutValue           any                                     `json:"source_timeout,omitempty" validate:"omitempty"`
	MinBitrateValue              *int                                    `json:"min_bitrate,omitempty" validate:"omitempty"`
	OutputAudioValue             *OutputAudio                            `json:"output_audio,omitempty" validate:"omitempty"`
	AbrLossLowerValue            *float64                                `json:"abr_loss_lower,omitempty" validate:"omitempty"`
	AbrLossUpperValue            *float64                                `json:"abr_loss_upper,omitempty" validate:"omitempty"`
	AbrMaxBitrateValue           *int                                    `json:"abr_max_bitrate,omitempty" validate:"omitempty"`
	AbrModeValue                 *int                                    `json:"abr_mode,omitempty" validate:"omitempty"`
	AbrStepdownValue             *float64                                `json:"abr_stepdown,omitempty" validate:"omitempty"`
	AbrStepupValue               *int                                    `json:"abr_stepup,omitempty" validate:"omitempty"`
	NoClientsReconnectDelayValue *int                                    `json:"no_clients_reconnect_delay,omitempty" validate:"omitempty"`
	AudioTimeoutValue            *Seconds                                `json:"audio_timeout,omitempty" validate:"omitempty"`
	CommentValue                 *string                                 `json:"comment,omitempty" validate:"omitempty"`
	DenyIfValue                  *string                                 `json:"deny_if,omitempty" validate:"omitempty"`
	FramesTimeoutValue           *int                                    `json:"frames_timeout,omitempty" validate:"omitempty"`
	HeadersValue                 map[string]string                       `json:"headers,omitempty" validate:"omitempty"`
	AbrDebugValue                *int                                    `json:"abr_debug,omitempty" validate:"omitempty"`
	MaxRetryTimeoutValue         *Seconds                                `json:"max_retry_timeout,omitempty" validate:"omitempty,min=1"`
	AllowIfValue                 *string                                 `json:"allow_if,omitempty" validate:"omitempty"`
	AbrCorrectionValue           *int                                    `json:"abr_correction,omitempty" validate:"omitempty"`
	PreferCodecValue             *WebrtcPreferVideoCodec                 `json:"prefer_codec,omitempty" validate:"omitempty"`
	PreferVideoCodecValue        *WebrtcPreferVideoCodec                 `json:"prefer_video_codec,omitempty" validate:"omitempty"`
	PriorityValue                *int                                    `json:"priority,omitempty" validate:"omitempty"`
	Scte35Value                  *bool                                   `json:"scte35,omitempty" validate:"omitempty"`
	AbrCyclesValue               *int                                    `json:"abr_cycles,omitempty" validate:"omitempty"`
	StatsValue                   *InputStatsImpl                         `json:"stats,omitempty" validate:"omitempty"`
	SubtitlesValue               *StreamInputSrtPublishSpecificSubtitles `json:"subtitles,omitempty" validate:"omitempty,oneof=drop accept ocr_replace ocr_add"`
	TimeoutValue                 *int                                    `json:"timeout,omitempty" validate:"omitempty"`
	TransportValue               *WebrtcTransport                        `json:"transport,omitempty" validate:"omitempty"`
	WebrtcAbrValue               *bool                                   `json:"webrtc_abr,omitempty" validate:"omitempty"`
	UserAgentValue               *string                                 `json:"user_agent,omitempty" validate:"omitempty"`
	ViaValue                     *AgentURL                               `json:"via,omitempty" validate:"omitempty"`
	VideoTimeoutValue            *Seconds                                `json:"video_timeout,omitempty" validate:"omitempty"`
	URLValue                     InputURL                                `json:"url" validate:"required"`
}

type StreamInputRtspImpl struct {
	SourceTimeoutValue           any               `json:"source_timeout,omitempty" validate:"omitempty"`
	OutputAudioValue             *OutputAudio      `json:"output_audio,omitempty" validate:"omitempty"`
	AudioTimeoutValue            *Seconds          `json:"audio_timeout,omitempty" validate:"omitempty"`
	DenyIfValue                  *string           `json:"deny_if,omitempty" validate:"omitempty"`
	FramesTimeoutValue           *int              `json:"frames_timeout,omitempty" validate:"omitempty"`
	HeadersValue                 map[string]string `json:"headers,omitempty" validate:"omitempty"`
	MaxRetryTimeoutValue         *Seconds          `json:"max_retry_timeout,omitempty" validate:"omitempty,min=1"`
	NoClientsReconnectDelayValue *int              `json:"no_clients_reconnect_delay,omitempty" validate:"omitempty"`
	AllowIfValue                 *string           `json:"allow_if,omitempty" validate:"omitempty"`
	CommentValue                 *string           `json:"comment,omitempty" validate:"omitempty"`
	PriorityValue                *int              `json:"priority,omitempty" validate:"omitempty"`
	RTPValue                     *string           `json:"rtp,omitempty" validate:"omitempty"`
	StatsValue                   *InputStatsImpl   `json:"stats,omitempty" validate:"omitempty"`
	TimeoutValue                 *int              `json:"timeout,omitempty" validate:"omitempty"`
	WaitRtcpValue                *bool             `json:"wait_rtcp,omitempty" validate:"omitempty"`
	UserAgentValue               *string           `json:"user_agent,omitempty" validate:"omitempty"`
	ViaValue                     *AgentURL         `json:"via,omitempty" validate:"omitempty"`
	VideoTimeoutValue            *Seconds          `json:"video_timeout,omitempty" validate:"omitempty"`
	URLValue                     InputURL          `json:"url" validate:"required"`
}

type StreamInputSrtPublishSpecificImpl struct {
	Scte35Value    *bool                                   `json:"scte35,omitempty" validate:"omitempty"`
	SubtitlesValue *StreamInputSrtPublishSpecificSubtitles `json:"subtitles,omitempty" validate:"omitempty,oneof=drop accept ocr_replace ocr_add"`
}

// Title: WebRTC
type StreamInputWebrtcPublishSpecificImpl struct {
	AbrCorrectionValue    *int                    `json:"abr_correction,omitempty" validate:"omitempty"`
	AbrCyclesValue        *int                    `json:"abr_cycles,omitempty" validate:"omitempty"`
	AbrDebugValue         *int                    `json:"abr_debug,omitempty" validate:"omitempty"`
	AbrLossLowerValue     *float64                `json:"abr_loss_lower,omitempty" validate:"omitempty"`
	AbrLossUpperValue     *float64                `json:"abr_loss_upper,omitempty" validate:"omitempty"`
	AbrMaxBitrateValue    *int                    `json:"abr_max_bitrate,omitempty" validate:"omitempty"`
	AbrModeValue          *int                    `json:"abr_mode,omitempty" validate:"omitempty"`
	AbrStepdownValue      *float64                `json:"abr_stepdown,omitempty" validate:"omitempty"`
	AbrStepupValue        *int                    `json:"abr_stepup,omitempty" validate:"omitempty"`
	MinBitrateValue       *int                    `json:"min_bitrate,omitempty" validate:"omitempty"`
	PreferCodecValue      *WebrtcPreferVideoCodec `json:"prefer_codec,omitempty" validate:"omitempty"`
	PreferVideoCodecValue *WebrtcPreferVideoCodec `json:"prefer_video_codec,omitempty" validate:"omitempty"`
	TransportValue        *WebrtcTransport        `json:"transport,omitempty" validate:"omitempty"`
	WebrtcAbrValue        *bool                   `json:"webrtc_abr,omitempty" validate:"omitempty"`
}

type StreamOnvifConfigImpl struct {
	PtzValue *bool `json:"ptz,omitempty" validate:"omitempty"`
}

type StreamPathItemImpl struct {
	IDValue    *int    `json:"id,omitempty" validate:"omitempty"`
	TitleValue *string `json:"title,omitempty" validate:"omitempty"`
}

type StreamPermissionsAccessImpl struct {
	CanUsePtzValue     *bool `json:"can_use_ptz,omitempty" validate:"omitempty"`
	CanViewValue       *bool `json:"can_view,omitempty" validate:"omitempty"`
	CanViewDvrValue    *bool `json:"can_view_dvr,omitempty" validate:"omitempty"`
	DvrDepthLimitValue *int  `json:"dvr_depth_limit,omitempty" validate:"omitempty"`
}

type StreamPresetImpl struct {
	IDValue           *int    `json:"id,omitempty" validate:"omitempty"`
	IsAdjustableValue *bool   `json:"is_adjustable,omitempty" validate:"omitempty"`
	TitleValue        *string `json:"title,omitempty" validate:"omitempty"`
}

type StreamStatsImpl struct {
	AgentStatusValue       *string        `json:"agent_status,omitempty" validate:"omitempty"`
	AliveValue             *bool          `json:"alive,omitempty" validate:"omitempty"`
	BitrateValue           *Speed         `json:"bitrate,omitempty" validate:"omitempty" openmetrics_metric:"stream_bitrate"`
	BytesOutValue          *Bytes         `json:"bytes_out,omitempty" validate:"omitempty" openmetrics_metric:"stream_bytes_out"`
	CurrentAgentIDValue    *AgentID       `json:"current_agent_id,omitempty" validate:"omitempty"`
	DvrInfoValue           *DvrInfoImpl   `json:"dvr_info,omitempty" validate:"omitempty"`
	LastDtsAtValue         *UtcMs         `json:"last_dts_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	LifetimeValue          *Milliseconds  `json:"lifetime,omitempty" validate:"omitempty"`
	MediaInfoValue         *MediaInfoImpl `json:"media_info,omitempty" validate:"omitempty"`
	OnlineClientsValue     *ClientCount   `json:"online_clients,omitempty" validate:"omitempty" openmetrics_metric:"stream_online_clients"`
	PlaybackTokenValue     *string        `json:"playback_token,omitempty" validate:"omitempty"`
	PublishEndpointValue   *string        `json:"publish_endpoint,omitempty" validate:"omitempty"`
	StatusValue            *StreamStatus  `json:"status,omitempty" validate:"omitempty"`
	StreamingEndpointValue *string        `json:"streaming_endpoint,omitempty" validate:"omitempty"`
	TSDelayValue           *Ticks         `json:"ts_delay,omitempty" validate:"omitempty"`
}

type StreamUserPermissionImpl struct {
	PermissionsValue *StreamUserPermissionPermissionsImpl `json:"permissions,omitempty" validate:"omitempty"`
	UserValue        *StreamUserPermissionUserImpl        `json:"user,omitempty" validate:"omitempty"`
}

type StreamUserPermissionPermissionsImpl struct {
	CanUsePtzValue     *bool `json:"can_use_ptz,omitempty" validate:"omitempty"`
	CanViewValue       *bool `json:"can_view,omitempty" validate:"omitempty"`
	CanViewDvrValue    *bool `json:"can_view_dvr,omitempty" validate:"omitempty"`
	DvrDepthLimitValue *int  `json:"dvr_depth_limit,omitempty" validate:"omitempty"`
}

type StreamUserPermissionUserImpl struct {
	IDValue *int `json:"id,omitempty" validate:"omitempty"`
}

type StreamUsersPermissionsListImpl struct {
	EstimatedCountValue   *int                        `json:"estimated_count,omitempty" validate:"omitempty"`
	NextValue             *string                     `json:"next,omitempty" validate:"omitempty"`
	PrevValue             *string                     `json:"prev,omitempty" validate:"omitempty"`
	TimingValue           any                         `json:"timing,omitempty" validate:"omitempty"`
	UsersPermissionsValue []*StreamUserPermissionImpl `json:"users_permissions,omitempty" validate:"omitempty"`
}

type StreamsImportResponseImpl struct {
	CreatedValue *int `json:"created,omitempty" validate:"omitempty"`
	UpdatedValue *int `json:"updated,omitempty" validate:"omitempty"`
}

type StreamsListImpl struct {
	TimingValue         any                 `json:"timing,omitempty" validate:"omitempty"`
	EstimatedCountValue *int                `json:"estimated_count,omitempty" validate:"omitempty"`
	NextValue           *string             `json:"next,omitempty" validate:"omitempty"`
	PrevValue           *string             `json:"prev,omitempty" validate:"omitempty"`
	StreamsValue        []*StreamConfigImpl `json:"streams,omitempty" validate:"omitempty"`
}

// Array of streams with settings
type StreamsMultieditConfigImpl struct {
	StreamsValue []*StreamConfigMultieditImpl `json:"streams,omitempty" validate:"omitempty"`
}

type SubscriptionImpl struct {
	EventTypesValue            *SubscriptionRequestEventTypesImpl `json:"event_types" validate:"required"`
	NotificationFrequencyValue *Seconds                           `json:"notification_frequency,omitempty" validate:"omitempty"`
	NotificationTypeValue      string                             `json:"notification_type" validate:"required"`
	StreamNameValue            string                             `json:"stream_name" validate:"required"`
}

// Required: event_types, notification_type, stream_name
type SubscriptionRequestImpl struct {
	EventTypesValue       *SubscriptionRequestEventTypesImpl `json:"event_types" validate:"required"`
	NotificationTypeValue string                             `json:"notification_type" validate:"required"`
	StreamNameValue       string                             `json:"stream_name" validate:"required"`
}

// Choosing which type of events to subscribe to
type SubscriptionRequestEventTypesImpl struct {
	EpisodeFaceValue    *bool `json:"episode_face,omitempty" validate:"omitempty"`
	EpisodeGenericValue *bool `json:"episode_generic,omitempty" validate:"omitempty"`
	EpisodeVehicleValue *bool `json:"episode_vehicle,omitempty" validate:"omitempty"`
	StreamDeadValue     *bool `json:"stream_dead,omitempty" validate:"omitempty"`
}

type ThumbnailsSpecImpl struct {
	EnabledValue any `json:"enabled,omitempty" validate:"omitempty"`
}

type TrackInfoImpl struct {
	TrackIDValue        any                   `json:"track_id,omitempty" validate:"omitempty"`
	LanguageValue       *string               `json:"language,omitempty" validate:"omitempty"`
	PixFmtValue         *FrameVideoPixFmt     `json:"pix_fmt,omitempty" validate:"omitempty"`
	BframesValue        *int                  `json:"bframes,omitempty" validate:"omitempty"`
	BitrateValue        *Speed                `json:"bitrate,omitempty" validate:"omitempty"`
	ChannelsValue       *int                  `json:"channels,omitempty" validate:"omitempty"`
	WidthValue          *Pixels               `json:"width,omitempty" validate:"omitempty"`
	CodecValue          *FrameCodec           `json:"codec,omitempty" validate:"omitempty"`
	AvgGopValue         *int                  `json:"avg_gop,omitempty" validate:"omitempty"`
	FPSValue            *float64              `json:"fps,omitempty" validate:"omitempty"`
	FrameDurationValue  *Ticks                `json:"frame_duration,omitempty" validate:"omitempty"`
	GopSizeValue        *int                  `json:"gop_size,omitempty" validate:"omitempty"`
	HeightValue         *Pixels               `json:"height,omitempty" validate:"omitempty"`
	IsProgressiveValue  *bool                 `json:"is_progressive,omitempty" validate:"omitempty"`
	AvgFPSValue         *float64              `json:"avg_fps,omitempty" validate:"omitempty"`
	BandwidthValue      *Speed                `json:"bandwidth,omitempty" validate:"omitempty"`
	LevelValue          *string               `json:"level,omitempty" validate:"omitempty"`
	LastGopValue        *int                  `json:"last_gop,omitempty" validate:"omitempty"`
	NumRefsFramesValue  *int                  `json:"num_refs_frames,omitempty" validate:"omitempty,min=0,max=32"`
	PidValue            *int                  `json:"pid,omitempty" validate:"omitempty"`
	LengthSizeValue     *int                  `json:"length_size,omitempty" validate:"omitempty"`
	PixelHeightValue    *Pixels               `json:"pixel_height,omitempty" validate:"omitempty"`
	PixelWidthValue     *Pixels               `json:"pixel_width,omitempty" validate:"omitempty"`
	ProfileValue        *string               `json:"profile,omitempty" validate:"omitempty"`
	SampleRateValue     *int                  `json:"sample_rate,omitempty" validate:"omitempty"`
	SarHeightValue      *int                  `json:"sar_height,omitempty" validate:"omitempty"`
	SarWidthValue       *int                  `json:"sar_width,omitempty" validate:"omitempty"`
	TitleValue          *string               `json:"title,omitempty" validate:"omitempty"`
	ContentValue        FrameContent          `json:"content" validate:"required"`
	ClosedCaptionsValue []*ClosedCaptionsImpl `json:"closed_captions,omitempty" validate:"omitempty"`
}

type TrackInfoApplicationImpl struct {
	TrackIDValue       any          `json:"track_id,omitempty" validate:"omitempty"`
	AvgFPSValue        *float64     `json:"avg_fps,omitempty" validate:"omitempty"`
	BandwidthValue     *Speed       `json:"bandwidth,omitempty" validate:"omitempty"`
	BitrateValue       *Speed       `json:"bitrate,omitempty" validate:"omitempty"`
	CodecValue         *FrameCodec  `json:"codec,omitempty" validate:"omitempty"`
	FrameDurationValue *Ticks       `json:"frame_duration,omitempty" validate:"omitempty"`
	LanguageValue      *string      `json:"language,omitempty" validate:"omitempty"`
	PidValue           *int         `json:"pid,omitempty" validate:"omitempty"`
	TitleValue         *string      `json:"title,omitempty" validate:"omitempty"`
	ContentValue       FrameContent `json:"content" validate:"required"`
}

type TrackInfoApplicationSpecificImpl struct {
	LanguageValue *string `json:"language,omitempty" validate:"omitempty"`
}

type TrackInfoAudioImpl struct {
	TrackIDValue       any          `json:"track_id,omitempty" validate:"omitempty"`
	AvgFPSValue        *float64     `json:"avg_fps,omitempty" validate:"omitempty"`
	BandwidthValue     *Speed       `json:"bandwidth,omitempty" validate:"omitempty"`
	BitrateValue       *Speed       `json:"bitrate,omitempty" validate:"omitempty"`
	ChannelsValue      *int         `json:"channels,omitempty" validate:"omitempty"`
	CodecValue         *FrameCodec  `json:"codec,omitempty" validate:"omitempty"`
	FrameDurationValue *Ticks       `json:"frame_duration,omitempty" validate:"omitempty"`
	LanguageValue      *string      `json:"language,omitempty" validate:"omitempty"`
	PidValue           *int         `json:"pid,omitempty" validate:"omitempty"`
	SampleRateValue    *int         `json:"sample_rate,omitempty" validate:"omitempty"`
	TitleValue         *string      `json:"title,omitempty" validate:"omitempty"`
	ContentValue       FrameContent `json:"content" validate:"required"`
}

type TrackInfoAudioSpecificImpl struct {
	ChannelsValue   *int    `json:"channels,omitempty" validate:"omitempty"`
	LanguageValue   *string `json:"language,omitempty" validate:"omitempty"`
	SampleRateValue *int    `json:"sample_rate,omitempty" validate:"omitempty"`
}

type TrackInfoBaseImpl struct {
	AvgFPSValue        *float64 `json:"avg_fps,omitempty" validate:"omitempty"`
	BandwidthValue     *Speed   `json:"bandwidth,omitempty" validate:"omitempty"`
	FrameDurationValue *Ticks   `json:"frame_duration,omitempty" validate:"omitempty"`
	TrackIDValue       any      `json:"track_id,omitempty" validate:"omitempty"`
}

// Required: content
type TrackInfoBaseConfigurableImpl struct {
	BitrateValue *Speed       `json:"bitrate,omitempty" validate:"omitempty"`
	PidValue     *int         `json:"pid,omitempty" validate:"omitempty"`
	TitleValue   *string      `json:"title,omitempty" validate:"omitempty"`
	ContentValue FrameContent `json:"content" validate:"required"`
}

type TrackInfoMetadataImpl struct {
	TrackIDValue       any          `json:"track_id,omitempty" validate:"omitempty"`
	AvgFPSValue        *float64     `json:"avg_fps,omitempty" validate:"omitempty"`
	BandwidthValue     *Speed       `json:"bandwidth,omitempty" validate:"omitempty"`
	BitrateValue       *Speed       `json:"bitrate,omitempty" validate:"omitempty"`
	CodecValue         *FrameCodec  `json:"codec,omitempty" validate:"omitempty"`
	FrameDurationValue *Ticks       `json:"frame_duration,omitempty" validate:"omitempty"`
	PidValue           *int         `json:"pid,omitempty" validate:"omitempty"`
	TitleValue         *string      `json:"title,omitempty" validate:"omitempty"`
	ContentValue       FrameContent `json:"content" validate:"required"`
}

type TrackInfoTextImpl struct {
	TrackIDValue       any          `json:"track_id,omitempty" validate:"omitempty"`
	AvgFPSValue        *float64     `json:"avg_fps,omitempty" validate:"omitempty"`
	BandwidthValue     *Speed       `json:"bandwidth,omitempty" validate:"omitempty"`
	BitrateValue       *Speed       `json:"bitrate,omitempty" validate:"omitempty"`
	CodecValue         *FrameCodec  `json:"codec,omitempty" validate:"omitempty"`
	FrameDurationValue *Ticks       `json:"frame_duration,omitempty" validate:"omitempty"`
	LanguageValue      *string      `json:"language,omitempty" validate:"omitempty"`
	PidValue           *int         `json:"pid,omitempty" validate:"omitempty"`
	TitleValue         *string      `json:"title,omitempty" validate:"omitempty"`
	ContentValue       FrameContent `json:"content" validate:"required"`
}

type TrackInfoTextSpecificImpl struct {
	LanguageValue *string `json:"language,omitempty" validate:"omitempty"`
}

type TrackInfoVideoImpl struct {
	TrackIDValue        any                   `json:"track_id,omitempty" validate:"omitempty"`
	IsProgressiveValue  *bool                 `json:"is_progressive,omitempty" validate:"omitempty"`
	SarWidthValue       *int                  `json:"sar_width,omitempty" validate:"omitempty"`
	BframesValue        *int                  `json:"bframes,omitempty" validate:"omitempty"`
	BitrateValue        *Speed                `json:"bitrate,omitempty" validate:"omitempty"`
	WidthValue          *Pixels               `json:"width,omitempty" validate:"omitempty"`
	CodecValue          *FrameCodec           `json:"codec,omitempty" validate:"omitempty"`
	AvgGopValue         *int                  `json:"avg_gop,omitempty" validate:"omitempty"`
	FPSValue            *float64              `json:"fps,omitempty" validate:"omitempty"`
	FrameDurationValue  *Ticks                `json:"frame_duration,omitempty" validate:"omitempty"`
	GopSizeValue        *int                  `json:"gop_size,omitempty" validate:"omitempty"`
	HeightValue         *Pixels               `json:"height,omitempty" validate:"omitempty"`
	AvgFPSValue         *float64              `json:"avg_fps,omitempty" validate:"omitempty"`
	BandwidthValue      *Speed                `json:"bandwidth,omitempty" validate:"omitempty"`
	LastGopValue        *int                  `json:"last_gop,omitempty" validate:"omitempty"`
	PixelHeightValue    *Pixels               `json:"pixel_height,omitempty" validate:"omitempty"`
	NumRefsFramesValue  *int                  `json:"num_refs_frames,omitempty" validate:"omitempty,min=0,max=32"`
	PidValue            *int                  `json:"pid,omitempty" validate:"omitempty"`
	PixFmtValue         *FrameVideoPixFmt     `json:"pix_fmt,omitempty" validate:"omitempty"`
	LevelValue          *string               `json:"level,omitempty" validate:"omitempty"`
	PixelWidthValue     *Pixels               `json:"pixel_width,omitempty" validate:"omitempty"`
	ProfileValue        *string               `json:"profile,omitempty" validate:"omitempty"`
	SarHeightValue      *int                  `json:"sar_height,omitempty" validate:"omitempty"`
	LengthSizeValue     *int                  `json:"length_size,omitempty" validate:"omitempty"`
	TitleValue          *string               `json:"title,omitempty" validate:"omitempty"`
	ContentValue        FrameContent          `json:"content" validate:"required"`
	ClosedCaptionsValue []*ClosedCaptionsImpl `json:"closed_captions,omitempty" validate:"omitempty"`
}

type TrackInfoVideoConfigurableImpl struct {
	BframesValue       *int              `json:"bframes,omitempty" validate:"omitempty"`
	FPSValue           *float64          `json:"fps,omitempty" validate:"omitempty"`
	GopSizeValue       *int              `json:"gop_size,omitempty" validate:"omitempty"`
	HeightValue        *Pixels           `json:"height,omitempty" validate:"omitempty"`
	LevelValue         *string           `json:"level,omitempty" validate:"omitempty"`
	NumRefsFramesValue *int              `json:"num_refs_frames,omitempty" validate:"omitempty,min=0,max=32"`
	PixFmtValue        *FrameVideoPixFmt `json:"pix_fmt,omitempty" validate:"omitempty"`
	PixelHeightValue   *Pixels           `json:"pixel_height,omitempty" validate:"omitempty"`
	PixelWidthValue    *Pixels           `json:"pixel_width,omitempty" validate:"omitempty"`
	ProfileValue       *string           `json:"profile,omitempty" validate:"omitempty"`
	SarHeightValue     *int              `json:"sar_height,omitempty" validate:"omitempty"`
	SarWidthValue      *int              `json:"sar_width,omitempty" validate:"omitempty"`
	WidthValue         *Pixels           `json:"width,omitempty" validate:"omitempty"`
}

type TrackInfoVideoSpecificImpl struct {
	AvgGopValue         *int                  `json:"avg_gop,omitempty" validate:"omitempty"`
	IsProgressiveValue  *bool                 `json:"is_progressive,omitempty" validate:"omitempty"`
	LastGopValue        *int                  `json:"last_gop,omitempty" validate:"omitempty"`
	LengthSizeValue     *int                  `json:"length_size,omitempty" validate:"omitempty"`
	ClosedCaptionsValue []*ClosedCaptionsImpl `json:"closed_captions,omitempty" validate:"omitempty"`
}

type UiSettingsConfigImpl struct {
	BrandValue         *string                          `json:"brand,omitempty" validate:"omitempty"`
	ColorsValue        *UiSettingsConfigColorsImpl      `json:"colors,omitempty" validate:"omitempty"`
	CompanyInfoValue   *UiSettingsConfigCompanyInfoImpl `json:"company_info,omitempty" validate:"omitempty"`
	DefaultLocaleValue *ISO6391                         `json:"default_locale,omitempty" validate:"omitempty"`
	FaviconsValue      *UiSettingsConfigFaviconsImpl    `json:"favicons,omitempty" validate:"omitempty"`
	FontsValue         *UiSettingsConfigFontsImpl       `json:"fonts,omitempty" validate:"omitempty"`
	MapValue           *MapImpl                         `json:"map,omitempty" validate:"omitempty"`
	ProductValue       *string                          `json:"product,omitempty" validate:"omitempty"`
	TitleValue         *string                          `json:"title,omitempty" validate:"omitempty"`
	LocalesValue       []ISO6391                        `json:"locales,omitempty" validate:"omitempty"`
}

// The interface colors.
type UiSettingsConfigColorsImpl struct {
	BackgroundValue *string `json:"background,omitempty" validate:"omitempty"`
	PrimaryValue    *string `json:"primary,omitempty" validate:"omitempty"`
	SecondaryValue  *string `json:"secondary,omitempty" validate:"omitempty"`
}

// Contact information for customers to reach the company through various means.
type UiSettingsConfigCompanyInfoImpl struct {
	AddressValue       *string `json:"address,omitempty" validate:"omitempty"`
	BusinessHoursValue *string `json:"business_hours,omitempty" validate:"omitempty"`
	PhoneValue         *string `json:"phone,omitempty" validate:"omitempty"`
}

// The favicons of different sizes for different OSes and browsers.
type UiSettingsConfigFaviconsImpl struct {
	T128Value *Byte `json:"128,omitempty" validate:"omitempty"`
	T16Value  *Byte `json:"16,omitempty" validate:"omitempty"`
	T32Value  *Byte `json:"32,omitempty" validate:"omitempty"`
	T48Value  *Byte `json:"48,omitempty" validate:"omitempty"`
	T64Value  *Byte `json:"64,omitempty" validate:"omitempty"`
}

// The fonts in the UI.
type UiSettingsConfigFontsImpl struct {
	LightValue   *Byte `json:"light,omitempty" validate:"omitempty"`
	MediumValue  *Byte `json:"medium,omitempty" validate:"omitempty"`
	RegularValue *Byte `json:"regular,omitempty" validate:"omitempty"`
}

type UserImpl struct {
	LocaleValue        *ISO6391                          `json:"locale,omitempty" validate:"omitempty"`
	PhoneValue         *PhoneNumber                      `json:"phone,omitempty" validate:"omitempty"`
	DisabledValue      *bool                             `json:"disabled,omitempty" validate:"omitempty"`
	EmailValue         *Email                            `json:"email,omitempty" validate:"omitempty"`
	FullnameValue      *string                           `json:"fullname,omitempty" validate:"omitempty"`
	IDValue            *int                              `json:"id,omitempty" validate:"omitempty"`
	NameValue          *string                           `json:"name,omitempty" validate:"omitempty"`
	AccessLevelValue   *UserAdminAccessLevel             `json:"access_level,omitempty" validate:"omitempty,oneof=generic admin"`
	CreatedAtValue     *UtcMs                            `json:"created_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	NoteValue          *string                           `json:"note,omitempty" validate:"omitempty"`
	ReadonlyValue      *bool                             `json:"readonly,omitempty" validate:"omitempty"`
	PasswordValue      *string                           `json:"password,omitempty" validate:"omitempty"`
	MaxSessionsValue   *int                              `json:"max_sessions,omitempty" validate:"omitempty"`
	OrganizationsValue []*UserAdminOrganizationsItemImpl `json:"organizations,omitempty" validate:"omitempty"`
}

// User Parameters available from Admin API.
type UserAdminImpl struct {
	AccessLevelValue   *UserAdminAccessLevel             `json:"access_level,omitempty" validate:"omitempty,oneof=generic admin"`
	DisabledValue      *bool                             `json:"disabled,omitempty" validate:"omitempty"`
	IDValue            *int                              `json:"id,omitempty" validate:"omitempty"`
	ReadonlyValue      *bool                             `json:"readonly,omitempty" validate:"omitempty"`
	OrganizationsValue []*UserAdminOrganizationsItemImpl `json:"organizations,omitempty" validate:"omitempty"`
}

type UserAdminOrganizationsItemImpl struct {
	IDValue          *int                                 `json:"id,omitempty" validate:"omitempty"`
	OwnerValue       *UserAdminOrganizationsItemOwnerImpl `json:"owner,omitempty" validate:"omitempty"`
	PermissionsValue *OrganizationPermissionsImpl         `json:"permissions,omitempty" validate:"omitempty"`
	TitleValue       *string                              `json:"title,omitempty" validate:"omitempty"`
}

// Owner properties.
type UserAdminOrganizationsItemOwnerImpl struct {
	IDValue   *int    `json:"id,omitempty" validate:"omitempty"`
	NameValue *string `json:"name,omitempty" validate:"omitempty"`
}

// User parameters visible from Admin and Client APIs.
type UserBaseImpl struct {
	CreatedAtValue   *UtcMs       `json:"created_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	EmailValue       *Email       `json:"email,omitempty" validate:"omitempty"`
	FullnameValue    *string      `json:"fullname,omitempty" validate:"omitempty"`
	LocaleValue      *ISO6391     `json:"locale,omitempty" validate:"omitempty"`
	MaxSessionsValue *int         `json:"max_sessions,omitempty" validate:"omitempty"`
	NameValue        *string      `json:"name,omitempty" validate:"omitempty"`
	NoteValue        *string      `json:"note,omitempty" validate:"omitempty"`
	PasswordValue    *string      `json:"password,omitempty" validate:"omitempty"`
	PhoneValue       *PhoneNumber `json:"phone,omitempty" validate:"omitempty"`
}

// A user who has been granted access via stream permissions.
type UserBaseSteamPermissionsImpl struct {
	IDValue *int `json:"id,omitempty" validate:"omitempty"`
}

type UserCreateImpl struct {
	LocaleValue         *ISO6391                          `json:"locale,omitempty" validate:"omitempty"`
	OrganizationIDValue *int                              `json:"organization_id,omitempty" validate:"omitempty"`
	DisabledValue       *bool                             `json:"disabled,omitempty" validate:"omitempty"`
	EmailValue          *Email                            `json:"email,omitempty" validate:"omitempty"`
	FullnameValue       *string                           `json:"fullname,omitempty" validate:"omitempty"`
	IDValue             *int                              `json:"id,omitempty" validate:"omitempty"`
	CreatedAtValue      *UtcMs                            `json:"created_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	NameValue           *string                           `json:"name,omitempty" validate:"omitempty"`
	AccessLevelValue    *UserAdminAccessLevel             `json:"access_level,omitempty" validate:"omitempty,oneof=generic admin"`
	NoteValue           *string                           `json:"note,omitempty" validate:"omitempty"`
	MaxSessionsValue    *int                              `json:"max_sessions,omitempty" validate:"omitempty"`
	ReadonlyValue       *bool                             `json:"readonly,omitempty" validate:"omitempty"`
	PasswordValue       *string                           `json:"password,omitempty" validate:"omitempty"`
	PhoneValue          *PhoneNumber                      `json:"phone,omitempty" validate:"omitempty"`
	OrganizationsValue  []*UserAdminOrganizationsItemImpl `json:"organizations,omitempty" validate:"omitempty"`
}

type UserFolderImpl struct {
	CoordinatesValue    *MapSpecImpl               `json:"coordinates,omitempty" validate:"omitempty"`
	FloorPlanValue      *FolderFloorPlanImpl       `json:"floor_plan,omitempty" validate:"omitempty"`
	HierarchyValue      *FolderHierarchyImpl       `json:"hierarchy,omitempty" validate:"omitempty"`
	OrganizationIDValue *int                       `json:"organization_id,omitempty" validate:"omitempty"`
	ParentIDValue       *int                       `json:"parent_id,omitempty" validate:"omitempty"`
	PermissionsValue    *UserFolderPermissionsImpl `json:"permissions,omitempty" validate:"omitempty"`
	StreamsCountValue   *int                       `json:"streams_count,omitempty" validate:"omitempty"`
	TitleValue          *string                    `json:"title,omitempty" validate:"omitempty"`
	IDValue             int                        `json:"id" validate:"required"`
}

type UserFolderPermissionsImpl struct {
	CanUseActionsValue *bool    `json:"can_use_actions,omitempty" validate:"omitempty"`
	CanUsePtzValue     *bool    `json:"can_use_ptz,omitempty" validate:"omitempty"`
	CanViewValue       *bool    `json:"can_view,omitempty" validate:"omitempty"`
	CanViewDvrValue    *bool    `json:"can_view_dvr,omitempty" validate:"omitempty"`
	DvrDepthLimitValue *Seconds `json:"dvr_depth_limit,omitempty" validate:"omitempty,min=0"`
}

type UserFoldersImpl struct {
	TimingValue         any               `json:"timing,omitempty" validate:"omitempty"`
	EstimatedCountValue *int              `json:"estimated_count,omitempty" validate:"omitempty"`
	NextValue           *string           `json:"next,omitempty" validate:"omitempty"`
	PrevValue           *string           `json:"prev,omitempty" validate:"omitempty"`
	FoldersValue        []*UserFolderImpl `json:"folders,omitempty" validate:"omitempty"`
}

// User parameters visible from Admin and Client APIs.
type UserProfileImpl struct {
	IsAdminValue       *bool `json:"is_admin,omitempty" validate:"omitempty"`
	IsDomainAdminValue *bool `json:"is_domain_admin,omitempty" validate:"omitempty"`
	IsReadonlyValue    *bool `json:"is_readonly,omitempty" validate:"omitempty"`
}

type UserStreamPermissionImpl struct {
	PermissionsValue *UserStreamPermissionPermissionsImpl `json:"permissions,omitempty" validate:"omitempty"`
	StreamValue      *UserStreamPermissionStreamImpl      `json:"stream,omitempty" validate:"omitempty"`
}

type UserStreamPermissionPermissionsImpl struct {
	CanUsePtzValue     *bool `json:"can_use_ptz,omitempty" validate:"omitempty"`
	CanViewValue       *bool `json:"can_view,omitempty" validate:"omitempty"`
	CanViewDvrValue    *bool `json:"can_view_dvr,omitempty" validate:"omitempty"`
	DvrDepthLimitValue *int  `json:"dvr_depth_limit,omitempty" validate:"omitempty"`
}

type UserStreamPermissionStreamImpl struct {
	NameValue *string `json:"name,omitempty" validate:"omitempty"`
}

type UserStreamsPermissionsListImpl struct {
	TimingValue             any                         `json:"timing,omitempty" validate:"omitempty"`
	EstimatedCountValue     *int                        `json:"estimated_count,omitempty" validate:"omitempty"`
	NextValue               *string                     `json:"next,omitempty" validate:"omitempty"`
	PrevValue               *string                     `json:"prev,omitempty" validate:"omitempty"`
	StreamsPermissionsValue []*UserStreamPermissionImpl `json:"streams_permissions,omitempty" validate:"omitempty"`
}

type UsersImpl struct {
	EstimatedCountValue *int        `json:"estimated_count,omitempty" validate:"omitempty"`
	NextValue           *string     `json:"next,omitempty" validate:"omitempty"`
	PrevValue           *string     `json:"prev,omitempty" validate:"omitempty"`
	TimingValue         any         `json:"timing,omitempty" validate:"omitempty"`
	UsersListValue      []*UserImpl `json:"users_list,omitempty" validate:"omitempty"`
}

type VisionAlertsImpl struct {
	LowQualityAtValue          *UtcMs `json:"low_quality_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	NotEnoughDetectionsAtValue *UtcMs `json:"not_enough_detections_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	SmallSizeAtValue           *UtcMs `json:"small_size_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
}

type VisionAppearanceImpl struct {
	BoxValue *VisionBoxImpl `json:"box,omitempty" validate:"omitempty"`
}

// Rectangle
// Required: top, left, bottom, right
type VisionBoxImpl struct {
	BottomValue float64 `json:"bottom" validate:"required,min=0,max=1"`
	LeftValue   float64 `json:"left" validate:"required,min=0,max=1"`
	RightValue  float64 `json:"right" validate:"required,min=0,max=1"`
	TopValue    float64 `json:"top" validate:"required,min=0,max=1"`
}

type VisionDetectedFaceImpl struct {
	AppearanceValue       *VisionAppearanceImpl      `json:"appearance,omitempty" validate:"omitempty"`
	ConfidenceValue       *float64                   `json:"confidence,omitempty" validate:"omitempty"`
	FingerprintValue      *VisionFaceFingerprintImpl `json:"fingerprint,omitempty" validate:"omitempty"`
	ThumbnailValue        *VisionImageAttributesImpl `json:"thumbnail,omitempty" validate:"omitempty"`
	ThumbnailQualityValue *float64                   `json:"thumbnail_quality,omitempty" validate:"omitempty"`
	ObjectClassValue      VisionObjectClass          `json:"object_class" validate:"required"`
	DetectedAtValue       UtcMs                      `json:"detected_at" validate:"required,min=1e+12,max=1e+13"`
}

type VisionDetectedLicensePlateImpl struct {
	AppearanceValue       *VisionAppearanceImpl      `json:"appearance,omitempty" validate:"omitempty"`
	ConfidenceValue       *float64                   `json:"confidence,omitempty" validate:"omitempty"`
	FacingSideValue       *VisionVehicleFacingSide   `json:"facing_side,omitempty" validate:"omitempty"`
	PlateTextValue        *string                    `json:"plate_text,omitempty" validate:"omitempty"`
	ThumbnailValue        *VisionImageAttributesImpl `json:"thumbnail,omitempty" validate:"omitempty"`
	ThumbnailQualityValue *float64                   `json:"thumbnail_quality,omitempty" validate:"omitempty"`
	ObjectClassValue      VisionObjectClass          `json:"object_class" validate:"required"`
	DetectedAtValue       UtcMs                      `json:"detected_at" validate:"required,min=1e+12,max=1e+13"`
}

// Required: detected_at, object_class
type VisionDetectedObjectBaseImpl struct {
	AppearanceValue       *VisionAppearanceImpl      `json:"appearance,omitempty" validate:"omitempty"`
	ConfidenceValue       *float64                   `json:"confidence,omitempty" validate:"omitempty"`
	ThumbnailValue        *VisionImageAttributesImpl `json:"thumbnail,omitempty" validate:"omitempty"`
	ThumbnailQualityValue *float64                   `json:"thumbnail_quality,omitempty" validate:"omitempty"`
	ObjectClassValue      VisionObjectClass          `json:"object_class" validate:"required"`
	DetectedAtValue       UtcMs                      `json:"detected_at" validate:"required,min=1e+12,max=1e+13"`
}

type VisionDetectedVehicleImpl struct {
	AppearanceValue          *VisionAppearanceImpl      `json:"appearance,omitempty" validate:"omitempty"`
	ConfidenceValue          *float64                   `json:"confidence,omitempty" validate:"omitempty"`
	LicensePlateMissingValue *bool                      `json:"license_plate_missing,omitempty" validate:"omitempty"`
	PurposeValue             *VisionVehiclePurpose      `json:"purpose,omitempty" validate:"omitempty"`
	ThumbnailValue           *VisionImageAttributesImpl `json:"thumbnail,omitempty" validate:"omitempty"`
	ThumbnailQualityValue    *float64                   `json:"thumbnail_quality,omitempty" validate:"omitempty"`
	ObjectClassValue         VisionObjectClass          `json:"object_class" validate:"required"`
	DetectedAtValue          UtcMs                      `json:"detected_at" validate:"required,min=1e+12,max=1e+13"`
}

// Required: detector_type, region_id
type VisionDetectorConfigImpl struct {
	DetectorTypeValue      *VisionDetectorConfigDetectorTypeImpl      `json:"detector_type" validate:"required"`
	RegionCoordinatesValue *VisionDetectorConfigRegionCoordinatesImpl `json:"region_coordinates,omitempty" validate:"omitempty"`
	RegionTitleValue       *string                                    `json:"region_title,omitempty" validate:"omitempty"`
	StatsValue             *VisionDetectorStatsImpl                   `json:"stats,omitempty" validate:"omitempty"`
	RegionIDValue          string                                     `json:"region_id" validate:"required"`
}

type VisionDetectorConfigDetectorTypeImpl struct {
}

type VisionDetectorConfigRegionCoordinatesImpl struct {
}

type VisionDetectorStatsImpl struct {
	AlertsValue          *VisionAlertsImpl `json:"alerts,omitempty" validate:"omitempty"`
	LastDetectionAtValue *UtcMs            `json:"last_detection_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
}

type VisionEpisodeContextSearchImpl struct {
	PreviewValue                     *Base64                          `json:"preview,omitempty" validate:"omitempty,base64"`
	ClosedAtValue                    *UtcMs                           `json:"closed_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	EpisodeAppearanceTimestampsValue *EpisodeAppearanceTimestampsImpl `json:"episode_appearance_timestamps,omitempty" validate:"omitempty"`
	EpisodeTypeValue                 *string                          `json:"episode_type,omitempty" validate:"omitempty"`
	FramePreviewValue                *Base64                          `json:"frame_preview,omitempty" validate:"omitempty,base64"`
	MatchScoreValue                  *float64                         `json:"match_score,omitempty" validate:"omitempty"`
	CloseReasonValue                 *EpisodeCloseReason              `json:"close_reason,omitempty" validate:"omitempty"`
	PreviewTimestampValue            *UtcMs                           `json:"preview_timestamp,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	StartedAtValue                   *UtcMs                           `json:"started_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	MediaValue                       MediaName                        `json:"media" validate:"required"`
	EpisodeIDValue                   SnowflakeID                      `json:"episode_id" validate:"required"`
	OpenedAtValue                    UtcMs                            `json:"opened_at" validate:"required,min=1e+12,max=1e+13"`
	UpdatedAtValue                   UtcMs                            `json:"updated_at" validate:"required,min=1e+12,max=1e+13"`
}

type VisionEpisodeFaceImpl struct {
	FingerprintValue                 *VisionFaceFingerprintImpl       `json:"fingerprint,omitempty" validate:"omitempty"`
	PreviewTimestampValue            *UtcMs                           `json:"preview_timestamp,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	EpisodeAppearanceTimestampsValue *EpisodeAppearanceTimestampsImpl `json:"episode_appearance_timestamps,omitempty" validate:"omitempty"`
	EpisodeTypeValue                 *string                          `json:"episode_type,omitempty" validate:"omitempty"`
	ClosedAtValue                    *UtcMs                           `json:"closed_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	StartedAtValue                   *UtcMs                           `json:"started_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	CloseReasonValue                 *EpisodeCloseReason              `json:"close_reason,omitempty" validate:"omitempty"`
	FramePreviewValue                *Base64                          `json:"frame_preview,omitempty" validate:"omitempty,base64"`
	MediaValue                       MediaName                        `json:"media" validate:"required"`
	PreviewValue                     Base64                           `json:"preview" validate:"required,base64"`
	DetectionsValue                  []*VisionDetectedFaceImpl        `json:"detections,omitempty" validate:"omitempty"`
	MatchedPersonsValue              []*VisionPersonMatchImpl         `json:"matched_persons,omitempty" validate:"omitempty"`
	EpisodeIDValue                   SnowflakeID                      `json:"episode_id" validate:"required"`
	OpenedAtValue                    UtcMs                            `json:"opened_at" validate:"required,min=1e+12,max=1e+13"`
	UpdatedAtValue                   UtcMs                            `json:"updated_at" validate:"required,min=1e+12,max=1e+13"`
}

type VisionEpisodeHumanImpl struct {
	FramePreviewValue                *Base64                          `json:"frame_preview,omitempty" validate:"omitempty,base64"`
	ClosedAtValue                    *UtcMs                           `json:"closed_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	EpisodeAppearanceTimestampsValue *EpisodeAppearanceTimestampsImpl `json:"episode_appearance_timestamps,omitempty" validate:"omitempty"`
	EpisodeTypeValue                 *string                          `json:"episode_type,omitempty" validate:"omitempty"`
	CloseReasonValue                 *EpisodeCloseReason              `json:"close_reason,omitempty" validate:"omitempty"`
	PreviewValue                     *Base64                          `json:"preview,omitempty" validate:"omitempty,base64"`
	PreviewTimestampValue            *UtcMs                           `json:"preview_timestamp,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	StartedAtValue                   *UtcMs                           `json:"started_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	MediaValue                       MediaName                        `json:"media" validate:"required"`
	DetectionsValue                  []*VisionDetectedObjectBaseImpl  `json:"detections,omitempty" validate:"omitempty"`
	EpisodeIDValue                   SnowflakeID                      `json:"episode_id" validate:"required"`
	OpenedAtValue                    UtcMs                            `json:"opened_at" validate:"required,min=1e+12,max=1e+13"`
	UpdatedAtValue                   UtcMs                            `json:"updated_at" validate:"required,min=1e+12,max=1e+13"`
}

type VisionEpisodeQrCodeImpl struct {
	PreviewValue                     *Base64                          `json:"preview,omitempty" validate:"omitempty,base64"`
	ClosedAtValue                    *UtcMs                           `json:"closed_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	EpisodeAppearanceTimestampsValue *EpisodeAppearanceTimestampsImpl `json:"episode_appearance_timestamps,omitempty" validate:"omitempty"`
	StartedAtValue                   *UtcMs                           `json:"started_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	EpisodeTypeValue                 *string                          `json:"episode_type,omitempty" validate:"omitempty"`
	FramePreviewValue                *Base64                          `json:"frame_preview,omitempty" validate:"omitempty,base64"`
	CloseReasonValue                 *EpisodeCloseReason              `json:"close_reason,omitempty" validate:"omitempty"`
	PreviewTimestampValue            *UtcMs                           `json:"preview_timestamp,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	PayloadValue                     *string                          `json:"payload,omitempty" validate:"omitempty"`
	MediaValue                       MediaName                        `json:"media" validate:"required"`
	OpenedAtValue                    UtcMs                            `json:"opened_at" validate:"required,min=1e+12,max=1e+13"`
	EpisodeIDValue                   SnowflakeID                      `json:"episode_id" validate:"required"`
	UpdatedAtValue                   UtcMs                            `json:"updated_at" validate:"required,min=1e+12,max=1e+13"`
}

type VisionEpisodeVehicleImpl struct {
	PreviewTimestampValue            *UtcMs                           `json:"preview_timestamp,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	StartedAtValue                   *UtcMs                           `json:"started_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	VehiclePurposeValue              *VisionVehiclePurpose            `json:"vehicle_purpose,omitempty" validate:"omitempty"`
	EpisodeAppearanceTimestampsValue *EpisodeAppearanceTimestampsImpl `json:"episode_appearance_timestamps,omitempty" validate:"omitempty"`
	VehicleFacingSideValue           *VisionVehicleFacingSide         `json:"vehicle_facing_side,omitempty" validate:"omitempty"`
	EpisodeTypeValue                 *string                          `json:"episode_type,omitempty" validate:"omitempty"`
	FramePreviewValue                *Base64                          `json:"frame_preview,omitempty" validate:"omitempty,base64"`
	LicensePlateMissingValue         *bool                            `json:"license_plate_missing,omitempty" validate:"omitempty"`
	ClosedAtValue                    *UtcMs                           `json:"closed_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	VehicleEmergencySubtypeValue     *VisionVehicleEmergencySubtype   `json:"vehicle_emergency_subtype,omitempty" validate:"omitempty"`
	LicensePlateTextValue            *string                          `json:"license_plate_text,omitempty" validate:"omitempty"`
	CloseReasonValue                 *EpisodeCloseReason              `json:"close_reason,omitempty" validate:"omitempty"`
	PreviewValue                     Base64                           `json:"preview" validate:"required,base64"`
	MediaValue                       MediaName                        `json:"media" validate:"required"`
	DetectionsValue                  []any                            `json:"detections,omitempty" validate:"omitempty"`
	UpdatedAtValue                   UtcMs                            `json:"updated_at" validate:"required,min=1e+12,max=1e+13"`
	OpenedAtValue                    UtcMs                            `json:"opened_at" validate:"required,min=1e+12,max=1e+13"`
	EpisodeIDValue                   SnowflakeID                      `json:"episode_id" validate:"required"`
}

type VisionFaceAttributesImpl struct {
	FingerprintValue *VisionFaceFingerprintImpl `json:"fingerprint,omitempty" validate:"omitempty"`
}

// Digital fingerprint of the face
// Required: data, version
type VisionFaceFingerprintImpl struct {
	DataValue    Base64 `json:"data" validate:"required,base64"`
	VersionValue string `json:"version" validate:"required"`
}

// Required: data
type VisionImageAttributesImpl struct {
	MimeTypeValue *VisionImageMimetype `json:"mime_type,omitempty" validate:"omitempty"`
	Sha256Value   *Hexbinary           `json:"sha256,omitempty" validate:"omitempty,min=64,max=64"`
	DataValue     Base64               `json:"data" validate:"required,base64"`
}

// Attributes of the detected vehicle
type VisionLicensePlateAttributesImpl struct {
	FacingSideValue *VisionVehicleFacingSide `json:"facing_side,omitempty" validate:"omitempty"`
	PlateTextValue  *string                  `json:"plate_text,omitempty" validate:"omitempty"`
}

// Person
// Required: person_id, updated_at, originator
type VisionPersonImpl struct {
	DeletedAtValue    *UtcMs                       `json:"deleted_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	ExternalIDValue   *string                      `json:"external_id,omitempty" validate:"omitempty"`
	FirstSeenAtValue  *UtcMs                       `json:"first_seen_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	LastSeenAtValue   *UtcMs                       `json:"last_seen_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	NameValue         *string                      `json:"name,omitempty" validate:"omitempty"`
	OrganizationValue *OrganizationBaseImpl        `json:"organization,omitempty" validate:"omitempty"`
	PersonListValue   *VisionPersonPersonListImpl  `json:"person_list,omitempty" validate:"omitempty"`
	OriginatorValue   VisionPersonOriginator       `json:"originator" validate:"required,oneof=api identification_service"`
	PhotosValue       []*VisionImageAttributesImpl `json:"photos,omitempty" validate:"omitempty"`
	PersonIDValue     SnowflakeID                  `json:"person_id" validate:"required"`
	UpdatedAtValue    UtcMs                        `json:"updated_at" validate:"required,min=1e+12,max=1e+13"`
}

// Person matching information
// Required: person, match_score
type VisionPersonMatchImpl struct {
	PersonValue     *VisionPersonImpl `json:"person" validate:"required"`
	MatchScoreValue float64           `json:"match_score" validate:"required"`
}

// Person list details
type VisionPersonPersonListImpl struct {
	IDValue   *int    `json:"id,omitempty" validate:"omitempty"`
	NameValue *string `json:"name,omitempty" validate:"omitempty"`
}

// 2D point
// Required: x, y
type VisionPointImpl struct {
	XValue float64 `json:"x" validate:"required,min=0,max=1"`
	YValue float64 `json:"y" validate:"required,min=0,max=1"`
}

type VisionSpecImpl struct {
	AlgValue       *VisionSpecAlg              `json:"alg,omitempty" validate:"omitempty,oneof=faces plates"`
	AreasValue     *string                     `json:"areas,omitempty" validate:"omitempty"`
	DetectorsValue []*VisionDetectorConfigImpl `json:"detectors,omitempty" validate:"omitempty"`
}

type VisionSpecPresetsImpl struct {
	AlgValue *VisionSpecPresetsAlg `json:"alg,omitempty" validate:"omitempty,oneof=faces plates"`
}

type VisionVehicleAttributesImpl struct {
	LicensePlateMissingValue *bool                 `json:"license_plate_missing,omitempty" validate:"omitempty"`
	PurposeValue             *VisionVehiclePurpose `json:"purpose,omitempty" validate:"omitempty"`
}

type WatcherEpisodeImpl struct {
	DetectionsValue                  any                              `json:"detections,omitempty" validate:"omitempty"`
	PayloadValue                     any                              `json:"payload,omitempty" validate:"omitempty"`
	StartedAtValue                   *UtcMs                           `json:"started_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	VehicleEmergencySubtypeValue     *VisionVehicleEmergencySubtype   `json:"vehicle_emergency_subtype,omitempty" validate:"omitempty"`
	DurationValue                    *Milliseconds                    `json:"duration,omitempty" validate:"omitempty"`
	EpisodeAppearanceTimestampsValue *EpisodeAppearanceTimestampsImpl `json:"episode_appearance_timestamps,omitempty" validate:"omitempty"`
	VehiclePurposeValue              *VisionVehiclePurpose            `json:"vehicle_purpose,omitempty" validate:"omitempty"`
	EpisodeTypeValue                 *string                          `json:"episode_type,omitempty" validate:"omitempty"`
	FingerprintValue                 *VisionFaceFingerprintImpl       `json:"fingerprint,omitempty" validate:"omitempty"`
	FramePreviewValue                *Base64                          `json:"frame_preview,omitempty" validate:"omitempty,base64"`
	IsFavoriteValue                  *bool                            `json:"is_favorite,omitempty" validate:"omitempty"`
	LicensePlateMissingValue         *bool                            `json:"license_plate_missing,omitempty" validate:"omitempty"`
	LicensePlateTextValue            *string                          `json:"license_plate_text,omitempty" validate:"omitempty"`
	VehicleFacingSideValue           *VisionVehicleFacingSide         `json:"vehicle_facing_side,omitempty" validate:"omitempty"`
	DescriptionValue                 *string                          `json:"description,omitempty" validate:"omitempty,max=256"`
	TitleValue                       *string                          `json:"title,omitempty" validate:"omitempty,max=64"`
	MatchScoreValue                  *float64                         `json:"match_score,omitempty" validate:"omitempty"`
	ClosedAtValue                    *UtcMs                           `json:"closed_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	PlaybackTokenValue               *string                          `json:"playback_token,omitempty" validate:"omitempty"`
	PreviewValue                     *Base64                          `json:"preview,omitempty" validate:"omitempty,base64"`
	PreviewTimestampValue            *UtcMs                           `json:"preview_timestamp,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	CloseReasonValue                 *EpisodeCloseReason              `json:"close_reason,omitempty" validate:"omitempty"`
	StreamValue                      *EpisodeStreamDetailsStreamImpl  `json:"stream,omitempty" validate:"omitempty"`
	StreamingEndpointValue           *string                          `json:"streaming_endpoint,omitempty" validate:"omitempty"`
	MediaValue                       MediaName                        `json:"media" validate:"required"`
	MatchedPersonsValue              []*VisionPersonMatchImpl         `json:"matched_persons,omitempty" validate:"omitempty"`
	UpdatedAtValue                   UtcMs                            `json:"updated_at" validate:"required,min=1e+12,max=1e+13"`
	OpenedAtValue                    UtcMs                            `json:"opened_at" validate:"required,min=1e+12,max=1e+13"`
	EpisodeIDValue                   SnowflakeID                      `json:"episode_id" validate:"required"`
}

// Base properties added by Watcher to all episode types
type WatcherEpisodeBaseImpl struct {
	DescriptionValue       *string                         `json:"description,omitempty" validate:"omitempty,max=256"`
	DurationValue          *Milliseconds                   `json:"duration,omitempty" validate:"omitempty"`
	IsFavoriteValue        *bool                           `json:"is_favorite,omitempty" validate:"omitempty"`
	PlaybackTokenValue     *string                         `json:"playback_token,omitempty" validate:"omitempty"`
	StreamValue            *EpisodeStreamDetailsStreamImpl `json:"stream,omitempty" validate:"omitempty"`
	StreamingEndpointValue *string                         `json:"streaming_endpoint,omitempty" validate:"omitempty"`
	TitleValue             *string                         `json:"title,omitempty" validate:"omitempty,max=64"`
}

type WatcherEpisodeContextSearchImpl struct {
	IsFavoriteValue                  *bool                            `json:"is_favorite,omitempty" validate:"omitempty"`
	MatchScoreValue                  *float64                         `json:"match_score,omitempty" validate:"omitempty"`
	DescriptionValue                 *string                          `json:"description,omitempty" validate:"omitempty,max=256"`
	DurationValue                    *Milliseconds                    `json:"duration,omitempty" validate:"omitempty"`
	EpisodeAppearanceTimestampsValue *EpisodeAppearanceTimestampsImpl `json:"episode_appearance_timestamps,omitempty" validate:"omitempty"`
	TitleValue                       *string                          `json:"title,omitempty" validate:"omitempty,max=64"`
	ClosedAtValue                    *UtcMs                           `json:"closed_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	EpisodeTypeValue                 *string                          `json:"episode_type,omitempty" validate:"omitempty"`
	StreamValue                      *EpisodeStreamDetailsStreamImpl  `json:"stream,omitempty" validate:"omitempty"`
	FramePreviewValue                *Base64                          `json:"frame_preview,omitempty" validate:"omitempty,base64"`
	CloseReasonValue                 *EpisodeCloseReason              `json:"close_reason,omitempty" validate:"omitempty"`
	StreamingEndpointValue           *string                          `json:"streaming_endpoint,omitempty" validate:"omitempty"`
	PlaybackTokenValue               *string                          `json:"playback_token,omitempty" validate:"omitempty"`
	PreviewValue                     *Base64                          `json:"preview,omitempty" validate:"omitempty,base64"`
	PreviewTimestampValue            *UtcMs                           `json:"preview_timestamp,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	StartedAtValue                   *UtcMs                           `json:"started_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	MediaValue                       MediaName                        `json:"media" validate:"required"`
	OpenedAtValue                    UtcMs                            `json:"opened_at" validate:"required,min=1e+12,max=1e+13"`
	EpisodeIDValue                   SnowflakeID                      `json:"episode_id" validate:"required"`
	UpdatedAtValue                   UtcMs                            `json:"updated_at" validate:"required,min=1e+12,max=1e+13"`
}

type WatcherEpisodeCustomImpl struct {
	PayloadValue                     any                              `json:"payload,omitempty" validate:"omitempty"`
	IsFavoriteValue                  *bool                            `json:"is_favorite,omitempty" validate:"omitempty"`
	TitleValue                       *string                          `json:"title,omitempty" validate:"omitempty,max=64"`
	DurationValue                    *Milliseconds                    `json:"duration,omitempty" validate:"omitempty"`
	EpisodeAppearanceTimestampsValue *EpisodeAppearanceTimestampsImpl `json:"episode_appearance_timestamps,omitempty" validate:"omitempty"`
	CloseReasonValue                 *EpisodeCloseReason              `json:"close_reason,omitempty" validate:"omitempty"`
	EpisodeTypeValue                 *string                          `json:"episode_type,omitempty" validate:"omitempty,min=1,max=20"`
	DescriptionValue                 *string                          `json:"description,omitempty" validate:"omitempty,max=256"`
	FramePreviewValue                *Base64                          `json:"frame_preview,omitempty" validate:"omitempty,base64"`
	StreamValue                      *EpisodeStreamDetailsStreamImpl  `json:"stream,omitempty" validate:"omitempty"`
	StreamingEndpointValue           *string                          `json:"streaming_endpoint,omitempty" validate:"omitempty"`
	ClosedAtValue                    *UtcMs                           `json:"closed_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	PlaybackTokenValue               *string                          `json:"playback_token,omitempty" validate:"omitempty"`
	PreviewValue                     *Base64                          `json:"preview,omitempty" validate:"omitempty,base64"`
	PreviewTimestampValue            *UtcMs                           `json:"preview_timestamp,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	StartedAtValue                   *UtcMs                           `json:"started_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	MediaValue                       MediaName                        `json:"media" validate:"required"`
	EpisodeIDValue                   SnowflakeID                      `json:"episode_id" validate:"required"`
	OpenedAtValue                    UtcMs                            `json:"opened_at" validate:"required,min=1e+12,max=1e+13"`
	UpdatedAtValue                   UtcMs                            `json:"updated_at" validate:"required,min=1e+12,max=1e+13"`
}

type WatcherEpisodeFaceImpl struct {
	IsFavoriteValue                  *bool                            `json:"is_favorite,omitempty" validate:"omitempty"`
	StreamValue                      *EpisodeStreamDetailsStreamImpl  `json:"stream,omitempty" validate:"omitempty"`
	DescriptionValue                 *string                          `json:"description,omitempty" validate:"omitempty,max=256"`
	TitleValue                       *string                          `json:"title,omitempty" validate:"omitempty,max=64"`
	DurationValue                    *Milliseconds                    `json:"duration,omitempty" validate:"omitempty"`
	EpisodeAppearanceTimestampsValue *EpisodeAppearanceTimestampsImpl `json:"episode_appearance_timestamps,omitempty" validate:"omitempty"`
	StreamingEndpointValue           *string                          `json:"streaming_endpoint,omitempty" validate:"omitempty"`
	EpisodeTypeValue                 *string                          `json:"episode_type,omitempty" validate:"omitempty"`
	FingerprintValue                 *VisionFaceFingerprintImpl       `json:"fingerprint,omitempty" validate:"omitempty"`
	PreviewTimestampValue            *UtcMs                           `json:"preview_timestamp,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	ClosedAtValue                    *UtcMs                           `json:"closed_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	CloseReasonValue                 *EpisodeCloseReason              `json:"close_reason,omitempty" validate:"omitempty"`
	FramePreviewValue                *Base64                          `json:"frame_preview,omitempty" validate:"omitempty,base64"`
	StartedAtValue                   *UtcMs                           `json:"started_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	PlaybackTokenValue               *string                          `json:"playback_token,omitempty" validate:"omitempty"`
	PreviewValue                     Base64                           `json:"preview" validate:"required,base64"`
	MediaValue                       MediaName                        `json:"media" validate:"required"`
	MatchedPersonsValue              []*VisionPersonMatchImpl         `json:"matched_persons,omitempty" validate:"omitempty"`
	DetectionsValue                  []*VisionDetectedFaceImpl        `json:"detections,omitempty" validate:"omitempty"`
	OpenedAtValue                    UtcMs                            `json:"opened_at" validate:"required,min=1e+12,max=1e+13"`
	EpisodeIDValue                   SnowflakeID                      `json:"episode_id" validate:"required"`
	UpdatedAtValue                   UtcMs                            `json:"updated_at" validate:"required,min=1e+12,max=1e+13"`
}

type WatcherEpisodeGenericImpl struct {
	IsFavoriteValue                  *bool                            `json:"is_favorite,omitempty" validate:"omitempty"`
	FramePreviewValue                *Base64                          `json:"frame_preview,omitempty" validate:"omitempty,base64"`
	DescriptionValue                 *string                          `json:"description,omitempty" validate:"omitempty,max=256"`
	StreamValue                      *EpisodeStreamDetailsStreamImpl  `json:"stream,omitempty" validate:"omitempty"`
	EpisodeAppearanceTimestampsValue *EpisodeAppearanceTimestampsImpl `json:"episode_appearance_timestamps,omitempty" validate:"omitempty"`
	CloseReasonValue                 *EpisodeCloseReason              `json:"close_reason,omitempty" validate:"omitempty"`
	EpisodeTypeValue                 *string                          `json:"episode_type,omitempty" validate:"omitempty"`
	StreamingEndpointValue           *string                          `json:"streaming_endpoint,omitempty" validate:"omitempty"`
	ClosedAtValue                    *UtcMs                           `json:"closed_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	TitleValue                       *string                          `json:"title,omitempty" validate:"omitempty,max=64"`
	DurationValue                    *Milliseconds                    `json:"duration,omitempty" validate:"omitempty"`
	PlaybackTokenValue               *string                          `json:"playback_token,omitempty" validate:"omitempty"`
	PreviewValue                     *Base64                          `json:"preview,omitempty" validate:"omitempty,base64"`
	PreviewTimestampValue            *UtcMs                           `json:"preview_timestamp,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	StartedAtValue                   *UtcMs                           `json:"started_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	MediaValue                       MediaName                        `json:"media" validate:"required"`
	EpisodeIDValue                   SnowflakeID                      `json:"episode_id" validate:"required"`
	OpenedAtValue                    UtcMs                            `json:"opened_at" validate:"required,min=1e+12,max=1e+13"`
	UpdatedAtValue                   UtcMs                            `json:"updated_at" validate:"required,min=1e+12,max=1e+13"`
}

type WatcherEpisodeHumanImpl struct {
	StartedAtValue                   *UtcMs                           `json:"started_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	ClosedAtValue                    *UtcMs                           `json:"closed_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	DescriptionValue                 *string                          `json:"description,omitempty" validate:"omitempty,max=256"`
	TitleValue                       *string                          `json:"title,omitempty" validate:"omitempty,max=64"`
	DurationValue                    *Milliseconds                    `json:"duration,omitempty" validate:"omitempty"`
	EpisodeAppearanceTimestampsValue *EpisodeAppearanceTimestampsImpl `json:"episode_appearance_timestamps,omitempty" validate:"omitempty"`
	StreamingEndpointValue           *string                          `json:"streaming_endpoint,omitempty" validate:"omitempty"`
	EpisodeTypeValue                 *string                          `json:"episode_type,omitempty" validate:"omitempty"`
	IsFavoriteValue                  *bool                            `json:"is_favorite,omitempty" validate:"omitempty"`
	FramePreviewValue                *Base64                          `json:"frame_preview,omitempty" validate:"omitempty,base64"`
	PlaybackTokenValue               *string                          `json:"playback_token,omitempty" validate:"omitempty"`
	StreamValue                      *EpisodeStreamDetailsStreamImpl  `json:"stream,omitempty" validate:"omitempty"`
	CloseReasonValue                 *EpisodeCloseReason              `json:"close_reason,omitempty" validate:"omitempty"`
	PreviewValue                     *Base64                          `json:"preview,omitempty" validate:"omitempty,base64"`
	PreviewTimestampValue            *UtcMs                           `json:"preview_timestamp,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	MediaValue                       MediaName                        `json:"media" validate:"required"`
	DetectionsValue                  []*VisionDetectedObjectBaseImpl  `json:"detections,omitempty" validate:"omitempty"`
	OpenedAtValue                    UtcMs                            `json:"opened_at" validate:"required,min=1e+12,max=1e+13"`
	EpisodeIDValue                   SnowflakeID                      `json:"episode_id" validate:"required"`
	UpdatedAtValue                   UtcMs                            `json:"updated_at" validate:"required,min=1e+12,max=1e+13"`
}

type WatcherEpisodeQrCodeImpl struct {
	IsFavoriteValue                  *bool                            `json:"is_favorite,omitempty" validate:"omitempty"`
	PreviewValue                     *Base64                          `json:"preview,omitempty" validate:"omitempty,base64"`
	DescriptionValue                 *string                          `json:"description,omitempty" validate:"omitempty,max=256"`
	DurationValue                    *Milliseconds                    `json:"duration,omitempty" validate:"omitempty"`
	EpisodeAppearanceTimestampsValue *EpisodeAppearanceTimestampsImpl `json:"episode_appearance_timestamps,omitempty" validate:"omitempty"`
	CloseReasonValue                 *EpisodeCloseReason              `json:"close_reason,omitempty" validate:"omitempty"`
	EpisodeTypeValue                 *string                          `json:"episode_type,omitempty" validate:"omitempty"`
	FramePreviewValue                *Base64                          `json:"frame_preview,omitempty" validate:"omitempty,base64"`
	ClosedAtValue                    *UtcMs                           `json:"closed_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	StreamValue                      *EpisodeStreamDetailsStreamImpl  `json:"stream,omitempty" validate:"omitempty"`
	StreamingEndpointValue           *string                          `json:"streaming_endpoint,omitempty" validate:"omitempty"`
	PayloadValue                     *string                          `json:"payload,omitempty" validate:"omitempty"`
	PlaybackTokenValue               *string                          `json:"playback_token,omitempty" validate:"omitempty"`
	TitleValue                       *string                          `json:"title,omitempty" validate:"omitempty,max=64"`
	PreviewTimestampValue            *UtcMs                           `json:"preview_timestamp,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	StartedAtValue                   *UtcMs                           `json:"started_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	MediaValue                       MediaName                        `json:"media" validate:"required"`
	EpisodeIDValue                   SnowflakeID                      `json:"episode_id" validate:"required"`
	OpenedAtValue                    UtcMs                            `json:"opened_at" validate:"required,min=1e+12,max=1e+13"`
	UpdatedAtValue                   UtcMs                            `json:"updated_at" validate:"required,min=1e+12,max=1e+13"`
}

type WatcherEpisodeVehicleImpl struct {
	FramePreviewValue                *Base64                          `json:"frame_preview,omitempty" validate:"omitempty,base64"`
	LicensePlateMissingValue         *bool                            `json:"license_plate_missing,omitempty" validate:"omitempty"`
	DescriptionValue                 *string                          `json:"description,omitempty" validate:"omitempty,max=256"`
	IsFavoriteValue                  *bool                            `json:"is_favorite,omitempty" validate:"omitempty"`
	DurationValue                    *Milliseconds                    `json:"duration,omitempty" validate:"omitempty"`
	EpisodeAppearanceTimestampsValue *EpisodeAppearanceTimestampsImpl `json:"episode_appearance_timestamps,omitempty" validate:"omitempty"`
	VehicleFacingSideValue           *VisionVehicleFacingSide         `json:"vehicle_facing_side,omitempty" validate:"omitempty"`
	EpisodeTypeValue                 *string                          `json:"episode_type,omitempty" validate:"omitempty"`
	ClosedAtValue                    *UtcMs                           `json:"closed_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	StreamingEndpointValue           *string                          `json:"streaming_endpoint,omitempty" validate:"omitempty"`
	VehiclePurposeValue              *VisionVehiclePurpose            `json:"vehicle_purpose,omitempty" validate:"omitempty"`
	LicensePlateTextValue            *string                          `json:"license_plate_text,omitempty" validate:"omitempty"`
	CloseReasonValue                 *EpisodeCloseReason              `json:"close_reason,omitempty" validate:"omitempty"`
	VehicleEmergencySubtypeValue     *VisionVehicleEmergencySubtype   `json:"vehicle_emergency_subtype,omitempty" validate:"omitempty"`
	PlaybackTokenValue               *string                          `json:"playback_token,omitempty" validate:"omitempty"`
	TitleValue                       *string                          `json:"title,omitempty" validate:"omitempty,max=64"`
	PreviewTimestampValue            *UtcMs                           `json:"preview_timestamp,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	StartedAtValue                   *UtcMs                           `json:"started_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	StreamValue                      *EpisodeStreamDetailsStreamImpl  `json:"stream,omitempty" validate:"omitempty"`
	MediaValue                       MediaName                        `json:"media" validate:"required"`
	PreviewValue                     Base64                           `json:"preview" validate:"required,base64"`
	DetectionsValue                  []any                            `json:"detections,omitempty" validate:"omitempty"`
	UpdatedAtValue                   UtcMs                            `json:"updated_at" validate:"required,min=1e+12,max=1e+13"`
	OpenedAtValue                    UtcMs                            `json:"opened_at" validate:"required,min=1e+12,max=1e+13"`
	EpisodeIDValue                   SnowflakeID                      `json:"episode_id" validate:"required"`
}

type WatcherStreamConfigImpl struct {
	LastEpisodeAtValue          *UtcMs                        `json:"last_episode_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	NotificationsEnabledValue   *bool                         `json:"notifications_enabled,omitempty" validate:"omitempty"`
	CoordinatesValue            *MapSpecImpl                  `json:"coordinates,omitempty" validate:"omitempty"`
	CreatedAtValue              *UtcMs                        `json:"created_at,omitempty" validate:"omitempty,min=1e+12,max=1e+13"`
	FirmwareUpdateDurationValue *Milliseconds                 `json:"firmware_update_duration,omitempty" validate:"omitempty"`
	FolderIDValue               *int                          `json:"folder_id,omitempty" validate:"omitempty"`
	IsFavouriteValue            *bool                         `json:"is_favourite,omitempty" validate:"omitempty"`
	LastChangeValue             *AuditLogRecordImpl           `json:"last_change,omitempty" validate:"omitempty"`
	CanPublishValue             *bool                         `json:"can_publish,omitempty" validate:"omitempty"`
	AudioValue                  *WatcherStreamConfigAudioImpl `json:"audio,omitempty" validate:"omitempty"`
	MapCoordinatesValue         *MapSpecImpl                  `json:"map_coordinates,omitempty" validate:"omitempty"`
	OnvifValue                  *StreamOnvifConfigImpl        `json:"onvif,omitempty" validate:"omitempty"`
	OrganizationValue           *OrganizationStreamImpl       `json:"organization,omitempty" validate:"omitempty"`
	OrganizationIDValue         *int                          `json:"organization_id,omitempty" validate:"omitempty"`
	PresetIDValue               *int                          `json:"preset_id,omitempty" validate:"omitempty"`
	PostalAddressValue          *string                       `json:"postal_address,omitempty" validate:"omitempty"`
	PresetValue                 *StreamPresetImpl             `json:"preset,omitempty" validate:"omitempty"`
	PathValue                   []*StreamPathItemImpl         `json:"path,omitempty" validate:"omitempty"`
}

// Audio settings for the stream.
type WatcherStreamConfigAudioImpl struct {
	DisabledValue            *bool            `json:"disabled,omitempty" validate:"omitempty"`
	TranscodeAudioCodecValue *FrameAudioCodec `json:"transcode_audio_codec,omitempty" validate:"omitempty"`
}

// WebPush Notifications subscription
// Required: endpoint
type WebPushSubscriptionImpl struct {
	EndpointValue URI `json:"endpoint" validate:"required"`
}

type WebPushSubscriptionCreateImpl struct {
	KeysValue     *WebPushSubscriptionCreateKeysImpl `json:"keys" validate:"required"`
	EndpointValue URI                                `json:"endpoint" validate:"required"`
}

// Keys that are used to encrypt the payload
// Required: p256dh, auth
type WebPushSubscriptionCreateKeysImpl struct {
	AuthValue   string `json:"auth" validate:"required,min=1"`
	P256dhValue string `json:"p256dh" validate:"required,min=1"`
}

// NewAgentActivationToken creates a new AgentActivationToken instance
func NewAgentActivationToken() AgentActivationToken {
	return &AgentActivationTokenImpl{}
}

// A unique stream name. Its presence notifies about the binding of the agent token to the stream.
func (s AgentActivationTokenImpl) StreamName() *string {
	return s.StreamNameValue
}

// A unique stream name. Its presence notifies about the binding of the agent token to the stream.
func (s *AgentActivationTokenImpl) SetStreamName(v string) AgentActivationToken {
	if s == nil {
		return nil
	}
	s.StreamNameValue = &v
	return s
}

// Agent activation token.
func (s AgentActivationTokenImpl) Token() string {
	return s.TokenValue
}

// Agent activation token.
func (s *AgentActivationTokenImpl) SetToken(v string) AgentActivationToken {
	if s == nil {
		return nil
	}
	s.TokenValue = v
	return s
}

// NewAgentActivationTokenRequest creates a new AgentActivationTokenRequest instance
func NewAgentActivationTokenRequest() AgentActivationTokenRequest {
	return &AgentActivationTokenRequestImpl{}
}

// Any text note about the camera.
func (s AgentActivationTokenRequestImpl) Comment() *string {
	return s.CommentValue
}

// Any text note about the camera.
func (s *AgentActivationTokenRequestImpl) SetComment(v string) AgentActivationTokenRequest {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

func (s AgentActivationTokenRequestImpl) Coordinates() Coordinates {
	return s.CoordinatesValue
}

func (s *AgentActivationTokenRequestImpl) SetCoordinates(v Coordinates) AgentActivationTokenRequest {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*CoordinatesImpl); ok {
		s.CoordinatesValue = impl
	}
	return s
}

// The archive depth for the camera (the number of days).
func (s AgentActivationTokenRequestImpl) DvrDepth() *int {
	return s.DvrDepthValue
}

// The archive depth for the camera (the number of days).
func (s *AgentActivationTokenRequestImpl) SetDvrDepth(v int) AgentActivationTokenRequest {
	if s == nil {
		return nil
	}
	s.DvrDepthValue = &v
	return s
}

// The maximum storage space for the camera's archive, in Gigabytes.
func (s AgentActivationTokenRequestImpl) DvrSpace() *int {
	return s.DvrSpaceValue
}

// The maximum storage space for the camera's archive, in Gigabytes.
func (s *AgentActivationTokenRequestImpl) SetDvrSpace(v int) AgentActivationTokenRequest {
	if s == nil {
		return nil
	}
	s.DvrSpaceValue = &v
	return s
}

// Shows if the camera enabled or not. If the camera is enabled (the parameter is true), video from it is captured by the streamer.
func (s AgentActivationTokenRequestImpl) Enabled() *bool {
	return s.EnabledValue
}

// Shows if the camera enabled or not. If the camera is enabled (the parameter is true), video from it is captured by the streamer.
func (s *AgentActivationTokenRequestImpl) SetEnabled(v bool) AgentActivationTokenRequest {
	if s == nil {
		return nil
	}
	s.EnabledValue = &v
	return s
}

// The identifier of a folder to which the camera is added.
func (s AgentActivationTokenRequestImpl) FolderID() *int {
	return s.FolderIDValue
}

// The identifier of a folder to which the camera is added.
func (s *AgentActivationTokenRequestImpl) SetFolderID(v int) AgentActivationTokenRequest {
	if s == nil {
		return nil
	}
	s.FolderIDValue = &v
	return s
}

// The identifier of the Organization to which the camera belongs.
// The user activating the camera must have the right to control the cameras in this organization.
// If user belongs to only one organization, camera will be automatically added to this organization.
// If user belongs to multiple organizations, this parameter is required.
func (s AgentActivationTokenRequestImpl) OrganizationID() *int {
	return s.OrganizationIDValue
}

// The identifier of the Organization to which the camera belongs.
// The user activating the camera must have the right to control the cameras in this organization.
// If user belongs to only one organization, camera will be automatically added to this organization.
// If user belongs to multiple organizations, this parameter is required.
func (s *AgentActivationTokenRequestImpl) SetOrganizationID(v int) AgentActivationTokenRequest {
	if s == nil {
		return nil
	}
	s.OrganizationIDValue = &v
	return s
}

// The postal address of the camera.
func (s AgentActivationTokenRequestImpl) PostalAddress() *string {
	return s.PostalAddressValue
}

// The postal address of the camera.
func (s *AgentActivationTokenRequestImpl) SetPostalAddress(v string) AgentActivationTokenRequest {
	if s == nil {
		return nil
	}
	s.PostalAddressValue = &v
	return s
}

// The identifier of the preset assigned to the camera.
// If this parameter is not specified, the camera will be added with default preset.
func (s AgentActivationTokenRequestImpl) PresetID() *int {
	return s.PresetIDValue
}

// The identifier of the preset assigned to the camera.
// If this parameter is not specified, the camera will be added with default preset.
func (s *AgentActivationTokenRequestImpl) SetPresetID(v int) AgentActivationTokenRequest {
	if s == nil {
		return nil
	}
	s.PresetIDValue = &v
	return s
}

// If true, the video is captured continuously; if false, the camera is in "On-demand" mode.
func (s AgentActivationTokenRequestImpl) Static() *bool {
	return s.StaticValue
}

// If true, the video is captured continuously; if false, the camera is in "On-demand" mode.
func (s *AgentActivationTokenRequestImpl) SetStatic(v bool) AgentActivationTokenRequest {
	if s == nil {
		return nil
	}
	s.StaticValue = &v
	return s
}

// Human readable title of the camera as displayed in the UI. If not specified, title will be automatically generated.
func (s AgentActivationTokenRequestImpl) Title() *string {
	return s.TitleValue
}

// Human readable title of the camera as displayed in the UI. If not specified, title will be automatically generated.
func (s *AgentActivationTokenRequestImpl) SetTitle(v string) AgentActivationTokenRequest {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// NewApikey creates a new Apikey instance
func NewApikey() Apikey {
	return &ApikeyImpl{}
}

// Apikey for users access via API.
func (s ApikeyImpl) Apikey() *string {
	return s.ApikeyValue
}

// Apikey for users access via API.
func (s *ApikeyImpl) SetApikey(v string) Apikey {
	if s == nil {
		return nil
	}
	s.ApikeyValue = &v
	return s
}

// NewAuditLogRecord creates a new AuditLogRecord instance
func NewAuditLogRecord() AuditLogRecord {
	return &AuditLogRecordImpl{}
}

// The time when the last changes were made.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s AuditLogRecordImpl) CreatedAt() *UtcMs {
	return s.CreatedAtValue
}

// The time when the last changes were made.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *AuditLogRecordImpl) SetCreatedAt(v UtcMs) AuditLogRecord {
	if s == nil {
		return nil
	}
	s.CreatedAtValue = &v
	return s
}

// Who initiated the last changes.
// Examples: admin
func (s AuditLogRecordImpl) User() *string {
	return s.UserValue
}

// Who initiated the last changes.
// Examples: admin
func (s *AuditLogRecordImpl) SetUser(v string) AuditLogRecord {
	if s == nil {
		return nil
	}
	s.UserValue = &v
	return s
}

// NewAuth creates a new Auth instance
func NewAuth() Auth {
	return &AuthImpl{}
}

// Username authentication
func (s AuthImpl) Login() *string {
	return s.LoginValue
}

// Username authentication
func (s *AuthImpl) SetLogin(v string) Auth {
	if s == nil {
		return nil
	}
	s.LoginValue = &v
	return s
}

// Password authentication
func (s AuthImpl) Password() *string {
	return s.PasswordValue
}

// Password authentication
func (s *AuthImpl) SetPassword(v string) Auth {
	if s == nil {
		return nil
	}
	s.PasswordValue = &v
	return s
}

// Service port on which Onvif/PSIA is accessible, default is 80
func (s AuthImpl) Port() *int {
	return s.PortValue
}

// Service port on which Onvif/PSIA is accessible, default is 80
func (s *AuthImpl) SetPort(v int) Auth {
	if s == nil {
		return nil
	}
	s.PortValue = &v
	return s
}

// NewCameraConfig creates a new CameraConfig instance
func NewCameraConfig() CameraConfig {
	return &CameraConfigImpl{}
}

// Describes camera information.
func (s CameraConfigImpl) CameraInfo() any {
	return s.CameraInfoValue
}

// Describes camera information.
func (s *CameraConfigImpl) SetCameraInfo(v any) CameraConfig {
	if s == nil {
		return nil
	}
	s.CameraInfoValue = v
	return s
}

// These parameters allow optimizing media quality and performance based on device capabilities and network conditions.
func (s CameraConfigImpl) MediaQuality() any {
	return s.MediaQualityValue
}

// These parameters allow optimizing media quality and performance based on device capabilities and network conditions.
func (s *CameraConfigImpl) SetMediaQuality(v any) CameraConfig {
	if s == nil {
		return nil
	}
	s.MediaQualityValue = v
	return s
}

// Describes sensor configuration.
func (s CameraConfigImpl) Sensor() any {
	return s.SensorValue
}

// Describes sensor configuration.
func (s *CameraConfigImpl) SetSensor(v any) CameraConfig {
	if s == nil {
		return nil
	}
	s.SensorValue = v
	return s
}

// NewCameraInfo creates a new CameraInfo instance
func NewCameraInfo() CameraInfo {
	return &CameraInfoImpl{}
}

// Firmware version
func (s CameraInfoImpl) Firmware() *string {
	return s.FirmwareValue
}

// Firmware version
func (s *CameraInfoImpl) SetFirmware(v string) CameraInfo {
	if s == nil {
		return nil
	}
	s.FirmwareValue = &v
	return s
}

// Manufacturer name
func (s CameraInfoImpl) Manufacturer() *string {
	return s.ManufacturerValue
}

// Manufacturer name
func (s *CameraInfoImpl) SetManufacturer(v string) CameraInfo {
	if s == nil {
		return nil
	}
	s.ManufacturerValue = &v
	return s
}

// Model name
func (s CameraInfoImpl) Model() *string {
	return s.ModelValue
}

// Model name
func (s *CameraInfoImpl) SetModel(v string) CameraInfo {
	if s == nil {
		return nil
	}
	s.ModelValue = &v
	return s
}

// Serial number
func (s CameraInfoImpl) SerialNumber() *string {
	return s.SerialNumberValue
}

// Serial number
func (s *CameraInfoImpl) SetSerialNumber(v string) CameraInfo {
	if s == nil {
		return nil
	}
	s.SerialNumberValue = &v
	return s
}

// NewCameraTagWb creates a new CameraTagWb instance
func NewCameraTagWb() CameraTagWb {
	return &CameraTagWbImpl{}
}

// NewClosedCaptions creates a new ClosedCaptions instance
func NewClosedCaptions() ClosedCaptions {
	return &ClosedCaptionsImpl{}
}

// Language of closed captions.
// Example: eng
func (s ClosedCaptionsImpl) Language() *string {
	return s.LanguageValue
}

// Language of closed captions.
// Example: eng
func (s *ClosedCaptionsImpl) SetLanguage(v string) ClosedCaptions {
	if s == nil {
		return nil
	}
	s.LanguageValue = &v
	return s
}

// Under what name the audio track will be displayed on the player.
// Example: English
func (s ClosedCaptionsImpl) Name() *string {
	return s.NameValue
}

// Under what name the audio track will be displayed on the player.
// Example: English
func (s *ClosedCaptionsImpl) SetName(v string) ClosedCaptions {
	if s == nil {
		return nil
	}
	s.NameValue = &v
	return s
}

// NewCollectionResponse creates a new CollectionResponse instance
func NewCollectionResponse() CollectionResponse {
	return &CollectionResponseImpl{}
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s CollectionResponseImpl) EstimatedCount() *int {
	return s.EstimatedCountValue
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s *CollectionResponseImpl) SetEstimatedCount(v int) CollectionResponse {
	if s == nil {
		return nil
	}
	s.EstimatedCountValue = &v
	return s
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s CollectionResponseImpl) Next() *string {
	return s.NextValue
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s *CollectionResponseImpl) SetNext(v string) CollectionResponse {
	if s == nil {
		return nil
	}
	s.NextValue = &v
	return s
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s CollectionResponseImpl) Prev() *string {
	return s.PrevValue
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s *CollectionResponseImpl) SetPrev(v string) CollectionResponse {
	if s == nil {
		return nil
	}
	s.PrevValue = &v
	return s
}

// An object with a list of different timings measured during this API call.
func (s CollectionResponseImpl) Timing() any {
	return s.TimingValue
}

// An object with a list of different timings measured during this API call.
func (s *CollectionResponseImpl) SetTiming(v any) CollectionResponse {
	if s == nil {
		return nil
	}
	s.TimingValue = v
	return s
}

// NewCoordinates creates a new Coordinates instance
func NewCoordinates() Coordinates {
	return &CoordinatesImpl{}
}

// Latitude.
func (s CoordinatesImpl) Latitude() *float64 {
	return s.LatitudeValue
}

// Latitude.
func (s *CoordinatesImpl) SetLatitude(v float64) Coordinates {
	if s == nil {
		return nil
	}
	s.LatitudeValue = &v
	return s
}

// Longitude.
func (s CoordinatesImpl) Longitude() *float64 {
	return s.LongitudeValue
}

// Longitude.
func (s *CoordinatesImpl) SetLongitude(v float64) Coordinates {
	if s == nil {
		return nil
	}
	s.LongitudeValue = &v
	return s
}

// NewDeviceInfo creates a new DeviceInfo instance
func NewDeviceInfo() DeviceInfo {
	return &DeviceInfoImpl{}
}

// Device model
func (s DeviceInfoImpl) Model() *string {
	return s.ModelValue
}

// Device model
func (s *DeviceInfoImpl) SetModel(v string) DeviceInfo {
	if s == nil {
		return nil
	}
	s.ModelValue = &v
	return s
}

// Device platform
func (s DeviceInfoImpl) Platform() string {
	return s.PlatformValue
}

// Device platform
func (s *DeviceInfoImpl) SetPlatform(v string) DeviceInfo {
	if s == nil {
		return nil
	}
	s.PlatformValue = v
	return s
}

// Device platform version
func (s DeviceInfoImpl) Version() *string {
	return s.VersionValue
}

// Device platform version
func (s *DeviceInfoImpl) SetVersion(v string) DeviceInfo {
	if s == nil {
		return nil
	}
	s.VersionValue = &v
	return s
}

// NewDeviceToken creates a new DeviceToken instance
func NewDeviceToken() DeviceToken {
	return &DeviceTokenImpl{}
}

func (s DeviceTokenImpl) Device() DeviceInfo {
	return s.DeviceValue
}

func (s *DeviceTokenImpl) SetDevice(v DeviceInfo) DeviceToken {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*DeviceInfoImpl); ok {
		s.DeviceValue = impl
	}
	return s
}

// Device token. You can read how to create it here: https://firebase.google.com/docs/cloud-messaging/android/client?hl=en#sample-register
func (s DeviceTokenImpl) Token() string {
	return s.TokenValue
}

// Device token. You can read how to create it here: https://firebase.google.com/docs/cloud-messaging/android/client?hl=en#sample-register
func (s *DeviceTokenImpl) SetToken(v string) DeviceToken {
	if s == nil {
		return nil
	}
	s.TokenValue = v
	return s
}

// NewDvrBaseConfig creates a new DvrBaseConfig instance
func NewDvrBaseConfig() DvrBaseConfig {
	return &DvrBaseConfigImpl{}
}

// Additional archive depth in seconds for episodes. If set, episodes and their corresponding DVR record
// will be saved for `expiration + episodes_expiration` seconds.
// The archive clean-up within `[expiration, expiration+episodes_expiration]` seconds of the
// recording performed depending on [external_episodes_list](https://flussonic.com/doc/api/config-external/#tag/dvr/operation/external_episodes_list)
// response of `episodes_url`.
// Anything older than `expiration+episodes_expiration` seconds will
// be cleaned even if `episodes_url` does not respond.
// Format: seconds (seconds)
// Examples: 6.048e+06
func (s DvrBaseConfigImpl) EpisodesExpiration() *Seconds {
	return s.EpisodesExpirationValue
}

// Additional archive depth in seconds for episodes. If set, episodes and their corresponding DVR record
// will be saved for `expiration + episodes_expiration` seconds.
// The archive clean-up within `[expiration, expiration+episodes_expiration]` seconds of the
// recording performed depending on [external_episodes_list](https://flussonic.com/doc/api/config-external/#tag/dvr/operation/external_episodes_list)
// response of `episodes_url`.
// Anything older than `expiration+episodes_expiration` seconds will
// be cleaned even if `episodes_url` does not respond.
// Format: seconds (seconds)
// Examples: 6.048e+06
func (s *DvrBaseConfigImpl) SetEpisodesExpiration(v Seconds) DvrBaseConfig {
	if s == nil {
		return nil
	}
	s.EpisodesExpirationValue = &v
	return s
}

// Archive depth - a period (in seconds) back from the current moment during which the
// contigious part of archive is stored.
// As time goes, the parts of the recording which are older than the archive depth are deleted.
// If you have option `episodes_expiration` enabled, then some parts of DVR that are
// locked by episode signalling mechanism may be kept more than this `expiration` depth.
// If `episodes_url` does not respond, the archive clean-up by `expiration` is not performed;
// only the archive with expired episodes (`episodes_expiration`) is cleaned up until the `episodes_url` restores.
// Format: seconds (seconds)
// Examples: 604800
func (s DvrBaseConfigImpl) Expiration() *Seconds {
	return s.ExpirationValue
}

// Archive depth - a period (in seconds) back from the current moment during which the
// contigious part of archive is stored.
// As time goes, the parts of the recording which are older than the archive depth are deleted.
// If you have option `episodes_expiration` enabled, then some parts of DVR that are
// locked by episode signalling mechanism may be kept more than this `expiration` depth.
// If `episodes_url` does not respond, the archive clean-up by `expiration` is not performed;
// only the archive with expired episodes (`episodes_expiration`) is cleaned up until the `episodes_url` restores.
// Format: seconds (seconds)
// Examples: 604800
func (s *DvrBaseConfigImpl) SetExpiration(v Seconds) DvrBaseConfig {
	if s == nil {
		return nil
	}
	s.ExpirationValue = &v
	return s
}

// Maximum disk consumption in bytes. When this limit is reached,
// the oldest segment of the recording will be overridden by later data.
// This option affects both continuous recording and locked episodes (see `episodes_url`).
// If `episodes_url` does not respond, the archive clean-up by `storage_limit` is not performed
// to avoid deleting the recordings that should not be deleted.
// Format: bytes (bytes)
// Example: 4e+11
func (s DvrBaseConfigImpl) StorageLimit() *Bytes {
	return s.StorageLimitValue
}

// Maximum disk consumption in bytes. When this limit is reached,
// the oldest segment of the recording will be overridden by later data.
// This option affects both continuous recording and locked episodes (see `episodes_url`).
// If `episodes_url` does not respond, the archive clean-up by `storage_limit` is not performed
// to avoid deleting the recordings that should not be deleted.
// Format: bytes (bytes)
// Example: 4e+11
func (s *DvrBaseConfigImpl) SetStorageLimit(v Bytes) DvrBaseConfig {
	if s == nil {
		return nil
	}
	s.StorageLimitValue = &v
	return s
}

// NewDvrInfo creates a new DvrInfo instance
func NewDvrInfo() DvrInfo {
	return &DvrInfoImpl{}
}

// The size of the recorded archive.
// Format: bytes (bytes)
// Example: 1.296e+11
func (s DvrInfoImpl) Bytes() *Bytes {
	return s.BytesValue
}

// The size of the recorded archive.
// Format: bytes (bytes)
// Example: 1.296e+11
func (s *DvrInfoImpl) SetBytes(v Bytes) DvrInfo {
	if s == nil {
		return nil
	}
	s.BytesValue = &v
	return s
}

// The time interval between the start of the *first* recording segment and the end of the *last* one.
// Format: seconds (seconds)
// Example: 259200
func (s DvrInfoImpl) Depth() Seconds {
	return s.DepthValue
}

// The time interval between the start of the *first* recording segment and the end of the *last* one.
// Format: seconds (seconds)
// Example: 259200
func (s *DvrInfoImpl) SetDepth(v Seconds) DvrInfo {
	if s == nil {
		return nil
	}
	s.DepthValue = v
	return s
}

// Deprecated field. Will be deleted at 25.07
// The size of the recorded archive. Please, use bytes instead.
// Format: bytes (bytes)
// Example: 1.099511627776e+12
func (s DvrInfoImpl) DiskSize() *Bytes {
	return s.DiskSizeValue
}

// Deprecated field. Will be deleted at 25.07
// The size of the recorded archive. Please, use bytes instead.
// Format: bytes (bytes)
// Example: 1.099511627776e+12
func (s *DvrInfoImpl) SetDiskSize(v Bytes) DvrInfo {
	if s == nil {
		return nil
	}
	s.DiskSizeValue = &v
	return s
}

// A total duration of the recorded segments, excluding recording gaps.
// It can be smaller than depth if you have gaps.
// Format: seconds (seconds)
// Example: 172800
func (s DvrInfoImpl) Duration() *Seconds {
	return s.DurationValue
}

// A total duration of the recorded segments, excluding recording gaps.
// It can be smaller than depth if you have gaps.
// Format: seconds (seconds)
// Example: 172800
func (s *DvrInfoImpl) SetDuration(v Seconds) DvrInfo {
	if s == nil {
		return nil
	}
	s.DurationValue = &v
	return s
}

// The UTC timestamp of the first recording in this archive.
// Format: utc (Unix timestamp in seconds)
// Example: 1.641045644e+09
func (s DvrInfoImpl) From() Utc {
	return s.FromValue
}

// The UTC timestamp of the first recording in this archive.
// Format: utc (Unix timestamp in seconds)
// Example: 1.641045644e+09
func (s *DvrInfoImpl) SetFrom(v Utc) DvrInfo {
	if s == nil {
		return nil
	}
	s.FromValue = v
	return s
}

// Deprecated field. Will be deleted at 24.09
// The list of DVR ranges. The param is replaced with `ranges_list` method.
func (s DvrInfoImpl) Ranges() []DvrRange {
	if s.RangesValue == nil {
		return nil
	}
	result := make([]DvrRange, len(s.RangesValue))
	for i, item := range s.RangesValue {
		result[i] = item
	}
	return result
}

// Deprecated field. Will be deleted at 24.09
// The list of DVR ranges. The param is replaced with `ranges_list` method.
func (s *DvrInfoImpl) SetRanges(v []DvrRange) DvrInfo {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*DvrRangeImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*DvrRangeImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.RangesValue = impl
	}
	return s
}

// NewDvrRange creates a new DvrRange instance
func NewDvrRange() DvrRange {
	return &DvrRangeImpl{}
}

// The the of the last recorded data.
// Please notice that closed_at could be changed. There are two reasons.
// - Cleaner process reduced data. Read [more](https://flussonic.com/doc/api/reference/#tag/stream/operation/stream_get/response%7Cdvr%7Cepisodes_url).
// - Recording is still working. Near real-time value means that DVR is active at the moment.
// This is a replacement for `duration` field
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s DvrRangeImpl) ClosedAt() *UtcMs {
	return s.ClosedAtValue
}

// The the of the last recorded data.
// Please notice that closed_at could be changed. There are two reasons.
// - Cleaner process reduced data. Read [more](https://flussonic.com/doc/api/reference/#tag/stream/operation/stream_get/response%7Cdvr%7Cepisodes_url).
// - Recording is still working. Near real-time value means that DVR is active at the moment.
// This is a replacement for `duration` field
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *DvrRangeImpl) SetClosedAt(v UtcMs) DvrRange {
	if s == nil {
		return nil
	}
	s.ClosedAtValue = &v
	return s
}

// Deprecated field. Will be deleted at 24.11
// The duration of the recorded DVR range.
// Use closed_at instead of this field.
// Format: seconds (seconds)
// Example: 28800
func (s DvrRangeImpl) Duration() *Seconds {
	return s.DurationValue
}

// Deprecated field. Will be deleted at 24.11
// The duration of the recorded DVR range.
// Use closed_at instead of this field.
// Format: seconds (seconds)
// Example: 28800
func (s *DvrRangeImpl) SetDuration(v Seconds) DvrRange {
	if s == nil {
		return nil
	}
	s.DurationValue = &v
	return s
}

// Deprecated field. Will be deleted at 24.11
// The beginning of the recorded DVR range. Use opened_at instead.
// Mention that opened_at has milliseconds
// Format: utc (Unix timestamp in seconds)
// Example: 1.525186456e+09
func (s DvrRangeImpl) From() *Utc {
	return s.FromValue
}

// Deprecated field. Will be deleted at 24.11
// The beginning of the recorded DVR range. Use opened_at instead.
// Mention that opened_at has milliseconds
// Format: utc (Unix timestamp in seconds)
// Example: 1.525186456e+09
func (s *DvrRangeImpl) SetFrom(v Utc) DvrRange {
	if s == nil {
		return nil
	}
	s.FromValue = &v
	return s
}

// The time when this range was started. Naming is standard for whole flussonic ecosystem.
// Is a replacement for field `from`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s DvrRangeImpl) OpenedAt() *UtcMs {
	return s.OpenedAtValue
}

// The time when this range was started. Naming is standard for whole flussonic ecosystem.
// Is a replacement for field `from`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *DvrRangeImpl) SetOpenedAt(v UtcMs) DvrRange {
	if s == nil {
		return nil
	}
	s.OpenedAtValue = &v
	return s
}

// NewEpisodeAppearanceTimestamps creates a new EpisodeAppearanceTimestamps instance
func NewEpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps {
	return &EpisodeAppearanceTimestampsImpl{}
}

// The time when this episode was fetched by Central.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637098611e+12
func (s EpisodeAppearanceTimestampsImpl) CentralTimestamp() *UtcMs {
	return s.CentralTimestampValue
}

// The time when this episode was fetched by Central.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637098611e+12
func (s *EpisodeAppearanceTimestampsImpl) SetCentralTimestamp(v UtcMs) EpisodeAppearanceTimestamps {
	if s == nil {
		return nil
	}
	s.CentralTimestampValue = &v
	return s
}

// The time when this episode was created in inference service.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s EpisodeAppearanceTimestampsImpl) InferenceTimestamp() *UtcMs {
	return s.InferenceTimestampValue
}

// The time when this episode was created in inference service.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s *EpisodeAppearanceTimestampsImpl) SetInferenceTimestamp(v UtcMs) EpisodeAppearanceTimestamps {
	if s == nil {
		return nil
	}
	s.InferenceTimestampValue = &v
	return s
}

// The time when this episode was fetched by Watcher.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s EpisodeAppearanceTimestampsImpl) WatcherTimestamp() *UtcMs {
	return s.WatcherTimestampValue
}

// The time when this episode was fetched by Watcher.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s *EpisodeAppearanceTimestampsImpl) SetWatcherTimestamp(v UtcMs) EpisodeAppearanceTimestamps {
	if s == nil {
		return nil
	}
	s.WatcherTimestampValue = &v
	return s
}

// NewEpisodeBase creates a new EpisodeBase instance
func NewEpisodeBase() EpisodeBase {
	return &EpisodeBaseImpl{}
}

// The reason for closing the episode.
func (s EpisodeBaseImpl) CloseReason() *EpisodeCloseReason {
	return s.CloseReasonValue
}

// The reason for closing the episode.
func (s *EpisodeBaseImpl) SetCloseReason(v EpisodeCloseReason) EpisodeBase {
	if s == nil {
		return nil
	}
	s.CloseReasonValue = &v
	return s
}

// Episode emitter can decide that episode considered closed and will not grow further.
// `closed_at` MUST NOT change, it must be emitted only once.
// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
// of the episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s EpisodeBaseImpl) ClosedAt() *UtcMs {
	return s.ClosedAtValue
}

// Episode emitter can decide that episode considered closed and will not grow further.
// `closed_at` MUST NOT change, it must be emitted only once.
// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
// of the episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *EpisodeBaseImpl) SetClosedAt(v UtcMs) EpisodeBase {
	if s == nil {
		return nil
	}
	s.ClosedAtValue = &v
	return s
}

// The time when the episode appeared in the service relative to the server time.
func (s EpisodeBaseImpl) EpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps {
	return s.EpisodeAppearanceTimestampsValue
}

// The time when the episode appeared in the service relative to the server time.
func (s *EpisodeBaseImpl) SetEpisodeAppearanceTimestamps(v EpisodeAppearanceTimestamps) EpisodeBase {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*EpisodeAppearanceTimestampsImpl); ok {
		s.EpisodeAppearanceTimestampsValue = impl
	}
	return s
}

// Unique identifier of the episode. Must be created by the system that first creates this episode.
// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
// handle very long integers.
// Format: snowflake_id (snowflake_id)
// Examples: 1.722279170848854e+18
func (s EpisodeBaseImpl) EpisodeID() SnowflakeID {
	return s.EpisodeIDValue
}

// Unique identifier of the episode. Must be created by the system that first creates this episode.
// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
// handle very long integers.
// Format: snowflake_id (snowflake_id)
// Examples: 1.722279170848854e+18
func (s *EpisodeBaseImpl) SetEpisodeID(v SnowflakeID) EpisodeBase {
	if s == nil {
		return nil
	}
	s.EpisodeIDValue = v
	return s
}

// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
// Format: base64 (base64)
func (s EpisodeBaseImpl) FramePreview() *Base64 {
	return s.FramePreviewValue
}

// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
// Format: base64 (base64)
func (s *EpisodeBaseImpl) SetFramePreview(v Base64) EpisodeBase {
	if s == nil {
		return nil
	}
	s.FramePreviewValue = &v
	return s
}

// Stream name on which this episode exists.
// Format: media_name (media_name)
func (s EpisodeBaseImpl) Media() MediaName {
	return s.MediaValue
}

// Stream name on which this episode exists.
// Format: media_name (media_name)
func (s *EpisodeBaseImpl) SetMedia(v MediaName) EpisodeBase {
	if s == nil {
		return nil
	}
	s.MediaValue = v
	return s
}

// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
// sort as by `opened_at`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s EpisodeBaseImpl) OpenedAt() UtcMs {
	return s.OpenedAtValue
}

// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
// sort as by `opened_at`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *EpisodeBaseImpl) SetOpenedAt(v UtcMs) EpisodeBase {
	if s == nil {
		return nil
	}
	s.OpenedAtValue = v
	return s
}

// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Format: base64 (base64)
func (s EpisodeBaseImpl) Preview() *Base64 {
	return s.PreviewValue
}

// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Format: base64 (base64)
func (s *EpisodeBaseImpl) SetPreview(v Base64) EpisodeBase {
	if s == nil {
		return nil
	}
	s.PreviewValue = &v
	return s
}

// The time when the preview of this episode is available.
// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
// for details.
// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s EpisodeBaseImpl) PreviewTimestamp() *UtcMs {
	return s.PreviewTimestampValue
}

// The time when the preview of this episode is available.
// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
// for details.
// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *EpisodeBaseImpl) SetPreviewTimestamp(v UtcMs) EpisodeBase {
	if s == nil {
		return nil
	}
	s.PreviewTimestampValue = &v
	return s
}

// This field can be used as indication of the fact that some system have checked and ensured that
// this episode has really started at some time, that may differ from `opened_at`.
// For example video analytics will use this field for the time when this episode was confirmed as confident.
// May be not relevant for television systems.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s EpisodeBaseImpl) StartedAt() *UtcMs {
	return s.StartedAtValue
}

// This field can be used as indication of the fact that some system have checked and ensured that
// this episode has really started at some time, that may differ from `opened_at`.
// For example video analytics will use this field for the time when this episode was confirmed as confident.
// May be not relevant for television systems.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *EpisodeBaseImpl) SetStartedAt(v UtcMs) EpisodeBase {
	if s == nil {
		return nil
	}
	s.StartedAtValue = &v
	return s
}

// The time of last change of the episode.
// System that processes episodes and can send them to other systems, MUST update this field
// on any changes in this episode.
// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
// this `updated_at` can be used as a sort key for fetching fresh updates.
// Consumer of the episodes can use `updated_at` in the following scenario:
// * fetch all exisiting episodes from the source
// * take biggest `updated_at` from this dataset, it will be T
// * ask source for all episodes with `updated_at > T`
// This algorithm can be used for fetching update stream from the source.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637098611e+12
func (s EpisodeBaseImpl) UpdatedAt() UtcMs {
	return s.UpdatedAtValue
}

// The time of last change of the episode.
// System that processes episodes and can send them to other systems, MUST update this field
// on any changes in this episode.
// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
// this `updated_at` can be used as a sort key for fetching fresh updates.
// Consumer of the episodes can use `updated_at` in the following scenario:
// * fetch all exisiting episodes from the source
// * take biggest `updated_at` from this dataset, it will be T
// * ask source for all episodes with `updated_at > T`
// This algorithm can be used for fetching update stream from the source.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637098611e+12
func (s *EpisodeBaseImpl) SetUpdatedAt(v UtcMs) EpisodeBase {
	if s == nil {
		return nil
	}
	s.UpdatedAtValue = v
	return s
}

// NewEpisodeCustom creates a new EpisodeCustom instance
func NewEpisodeCustom() EpisodeCustom {
	return &EpisodeCustomImpl{}
}

// The reason for closing the episode.
func (s EpisodeCustomImpl) CloseReason() *EpisodeCloseReason {
	return s.CloseReasonValue
}

// The reason for closing the episode.
func (s *EpisodeCustomImpl) SetCloseReason(v EpisodeCloseReason) EpisodeCustom {
	if s == nil {
		return nil
	}
	s.CloseReasonValue = &v
	return s
}

// Episode emitter can decide that episode considered closed and will not grow further.
// `closed_at` MUST NOT change, it must be emitted only once.
// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
// of the episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s EpisodeCustomImpl) ClosedAt() *UtcMs {
	return s.ClosedAtValue
}

// Episode emitter can decide that episode considered closed and will not grow further.
// `closed_at` MUST NOT change, it must be emitted only once.
// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
// of the episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *EpisodeCustomImpl) SetClosedAt(v UtcMs) EpisodeCustom {
	if s == nil {
		return nil
	}
	s.ClosedAtValue = &v
	return s
}

// The time when the episode appeared in the service relative to the server time.
func (s EpisodeCustomImpl) EpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps {
	return s.EpisodeAppearanceTimestampsValue
}

// The time when the episode appeared in the service relative to the server time.
func (s *EpisodeCustomImpl) SetEpisodeAppearanceTimestamps(v EpisodeAppearanceTimestamps) EpisodeCustom {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*EpisodeAppearanceTimestampsImpl); ok {
		s.EpisodeAppearanceTimestampsValue = impl
	}
	return s
}

// Unique identifier of the episode. Must be created by the system that first creates this episode.
// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
// handle very long integers.
// Format: snowflake_id (snowflake_id)
// Examples: 1.722279170848854e+18
func (s EpisodeCustomImpl) EpisodeID() SnowflakeID {
	return s.EpisodeIDValue
}

// Unique identifier of the episode. Must be created by the system that first creates this episode.
// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
// handle very long integers.
// Format: snowflake_id (snowflake_id)
// Examples: 1.722279170848854e+18
func (s *EpisodeCustomImpl) SetEpisodeID(v SnowflakeID) EpisodeCustom {
	if s == nil {
		return nil
	}
	s.EpisodeIDValue = v
	return s
}

// Custom episode type.
// Use this field to define your own episode types when integrating custom analytics.
// If episode type is not specified, episode will be saved with `generic` type.
func (s EpisodeCustomImpl) EpisodeType() *string {
	return s.EpisodeTypeValue
}

// Custom episode type.
// Use this field to define your own episode types when integrating custom analytics.
// If episode type is not specified, episode will be saved with `generic` type.
func (s *EpisodeCustomImpl) SetEpisodeType(v string) EpisodeCustom {
	if s == nil {
		return nil
	}
	s.EpisodeTypeValue = &v
	return s
}

// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
// Format: base64 (base64)
func (s EpisodeCustomImpl) FramePreview() *Base64 {
	return s.FramePreviewValue
}

// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
// Format: base64 (base64)
func (s *EpisodeCustomImpl) SetFramePreview(v Base64) EpisodeCustom {
	if s == nil {
		return nil
	}
	s.FramePreviewValue = &v
	return s
}

// Stream name on which this episode exists.
// Format: media_name (media_name)
func (s EpisodeCustomImpl) Media() MediaName {
	return s.MediaValue
}

// Stream name on which this episode exists.
// Format: media_name (media_name)
func (s *EpisodeCustomImpl) SetMedia(v MediaName) EpisodeCustom {
	if s == nil {
		return nil
	}
	s.MediaValue = v
	return s
}

// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
// sort as by `opened_at`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s EpisodeCustomImpl) OpenedAt() UtcMs {
	return s.OpenedAtValue
}

// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
// sort as by `opened_at`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *EpisodeCustomImpl) SetOpenedAt(v UtcMs) EpisodeCustom {
	if s == nil {
		return nil
	}
	s.OpenedAtValue = v
	return s
}

// Custom episode payload. Use this field to provide additional information about the episode.
func (s EpisodeCustomImpl) Payload() any {
	return s.PayloadValue
}

// Custom episode payload. Use this field to provide additional information about the episode.
func (s *EpisodeCustomImpl) SetPayload(v any) EpisodeCustom {
	if s == nil {
		return nil
	}
	s.PayloadValue = v
	return s
}

// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Format: base64 (base64)
func (s EpisodeCustomImpl) Preview() *Base64 {
	return s.PreviewValue
}

// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Format: base64 (base64)
func (s *EpisodeCustomImpl) SetPreview(v Base64) EpisodeCustom {
	if s == nil {
		return nil
	}
	s.PreviewValue = &v
	return s
}

// The time when the preview of this episode is available.
// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
// for details.
// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s EpisodeCustomImpl) PreviewTimestamp() *UtcMs {
	return s.PreviewTimestampValue
}

// The time when the preview of this episode is available.
// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
// for details.
// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *EpisodeCustomImpl) SetPreviewTimestamp(v UtcMs) EpisodeCustom {
	if s == nil {
		return nil
	}
	s.PreviewTimestampValue = &v
	return s
}

// This field can be used as indication of the fact that some system have checked and ensured that
// this episode has really started at some time, that may differ from `opened_at`.
// For example video analytics will use this field for the time when this episode was confirmed as confident.
// May be not relevant for television systems.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s EpisodeCustomImpl) StartedAt() *UtcMs {
	return s.StartedAtValue
}

// This field can be used as indication of the fact that some system have checked and ensured that
// this episode has really started at some time, that may differ from `opened_at`.
// For example video analytics will use this field for the time when this episode was confirmed as confident.
// May be not relevant for television systems.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *EpisodeCustomImpl) SetStartedAt(v UtcMs) EpisodeCustom {
	if s == nil {
		return nil
	}
	s.StartedAtValue = &v
	return s
}

// The time of last change of the episode.
// System that processes episodes and can send them to other systems, MUST update this field
// on any changes in this episode.
// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
// this `updated_at` can be used as a sort key for fetching fresh updates.
// Consumer of the episodes can use `updated_at` in the following scenario:
// * fetch all exisiting episodes from the source
// * take biggest `updated_at` from this dataset, it will be T
// * ask source for all episodes with `updated_at > T`
// This algorithm can be used for fetching update stream from the source.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637098611e+12
func (s EpisodeCustomImpl) UpdatedAt() UtcMs {
	return s.UpdatedAtValue
}

// The time of last change of the episode.
// System that processes episodes and can send them to other systems, MUST update this field
// on any changes in this episode.
// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
// this `updated_at` can be used as a sort key for fetching fresh updates.
// Consumer of the episodes can use `updated_at` in the following scenario:
// * fetch all exisiting episodes from the source
// * take biggest `updated_at` from this dataset, it will be T
// * ask source for all episodes with `updated_at > T`
// This algorithm can be used for fetching update stream from the source.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637098611e+12
func (s *EpisodeCustomImpl) SetUpdatedAt(v UtcMs) EpisodeCustom {
	if s == nil {
		return nil
	}
	s.UpdatedAtValue = v
	return s
}

// NewEpisodeExtra creates a new EpisodeExtra instance
func NewEpisodeExtra() EpisodeExtra {
	return &EpisodeExtraImpl{}
}

// Optional description of the episode. Can be used to provide additional context or details about the episode.
// Example: Person detected at the main entrance, stayed for 30 seconds
func (s EpisodeExtraImpl) Description() *string {
	return s.DescriptionValue
}

// Optional description of the episode. Can be used to provide additional context or details about the episode.
// Example: Person detected at the main entrance, stayed for 30 seconds
func (s *EpisodeExtraImpl) SetDescription(v string) EpisodeExtra {
	if s == nil {
		return nil
	}
	s.DescriptionValue = &v
	return s
}

// Duration of the episode in milliseconds.
// Format: milliseconds (milliseconds)
// Example: 10500
func (s EpisodeExtraImpl) Duration() *Milliseconds {
	return s.DurationValue
}

// Duration of the episode in milliseconds.
// Format: milliseconds (milliseconds)
// Example: 10500
func (s *EpisodeExtraImpl) SetDuration(v Milliseconds) EpisodeExtra {
	if s == nil {
		return nil
	}
	s.DurationValue = &v
	return s
}

// Whether the episode is added to favorites.
// Example: false
func (s EpisodeExtraImpl) IsFavorite() *bool {
	return s.IsFavoriteValue
}

// Whether the episode is added to favorites.
// Example: false
func (s *EpisodeExtraImpl) SetIsFavorite(v bool) EpisodeExtra {
	if s == nil {
		return nil
	}
	s.IsFavoriteValue = &v
	return s
}

// Optional title of the episode. Can be used to provide a human-readable name for the episode.
// Example: Visitor at main entrance
func (s EpisodeExtraImpl) Title() *string {
	return s.TitleValue
}

// Optional title of the episode. Can be used to provide a human-readable name for the episode.
// Example: Visitor at main entrance
func (s *EpisodeExtraImpl) SetTitle(v string) EpisodeExtra {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// NewEpisodeGeneric creates a new EpisodeGeneric instance
func NewEpisodeGeneric() EpisodeGeneric {
	return &EpisodeGenericImpl{}
}

// The reason for closing the episode.
func (s EpisodeGenericImpl) CloseReason() *EpisodeCloseReason {
	return s.CloseReasonValue
}

// The reason for closing the episode.
func (s *EpisodeGenericImpl) SetCloseReason(v EpisodeCloseReason) EpisodeGeneric {
	if s == nil {
		return nil
	}
	s.CloseReasonValue = &v
	return s
}

// Episode emitter can decide that episode considered closed and will not grow further.
// `closed_at` MUST NOT change, it must be emitted only once.
// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
// of the episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s EpisodeGenericImpl) ClosedAt() *UtcMs {
	return s.ClosedAtValue
}

// Episode emitter can decide that episode considered closed and will not grow further.
// `closed_at` MUST NOT change, it must be emitted only once.
// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
// of the episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *EpisodeGenericImpl) SetClosedAt(v UtcMs) EpisodeGeneric {
	if s == nil {
		return nil
	}
	s.ClosedAtValue = &v
	return s
}

// The time when the episode appeared in the service relative to the server time.
func (s EpisodeGenericImpl) EpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps {
	return s.EpisodeAppearanceTimestampsValue
}

// The time when the episode appeared in the service relative to the server time.
func (s *EpisodeGenericImpl) SetEpisodeAppearanceTimestamps(v EpisodeAppearanceTimestamps) EpisodeGeneric {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*EpisodeAppearanceTimestampsImpl); ok {
		s.EpisodeAppearanceTimestampsValue = impl
	}
	return s
}

// Unique identifier of the episode. Must be created by the system that first creates this episode.
// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
// handle very long integers.
// Format: snowflake_id (snowflake_id)
// Examples: 1.722279170848854e+18
func (s EpisodeGenericImpl) EpisodeID() SnowflakeID {
	return s.EpisodeIDValue
}

// Unique identifier of the episode. Must be created by the system that first creates this episode.
// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
// handle very long integers.
// Format: snowflake_id (snowflake_id)
// Examples: 1.722279170848854e+18
func (s *EpisodeGenericImpl) SetEpisodeID(v SnowflakeID) EpisodeGeneric {
	if s == nil {
		return nil
	}
	s.EpisodeIDValue = v
	return s
}

// Generic stream episode
func (s EpisodeGenericImpl) EpisodeType() *string {
	return s.EpisodeTypeValue
}

// Generic stream episode
func (s *EpisodeGenericImpl) SetEpisodeType(v string) EpisodeGeneric {
	if s == nil {
		return nil
	}
	s.EpisodeTypeValue = &v
	return s
}

// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
// Format: base64 (base64)
func (s EpisodeGenericImpl) FramePreview() *Base64 {
	return s.FramePreviewValue
}

// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
// Format: base64 (base64)
func (s *EpisodeGenericImpl) SetFramePreview(v Base64) EpisodeGeneric {
	if s == nil {
		return nil
	}
	s.FramePreviewValue = &v
	return s
}

// Stream name on which this episode exists.
// Format: media_name (media_name)
func (s EpisodeGenericImpl) Media() MediaName {
	return s.MediaValue
}

// Stream name on which this episode exists.
// Format: media_name (media_name)
func (s *EpisodeGenericImpl) SetMedia(v MediaName) EpisodeGeneric {
	if s == nil {
		return nil
	}
	s.MediaValue = v
	return s
}

// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
// sort as by `opened_at`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s EpisodeGenericImpl) OpenedAt() UtcMs {
	return s.OpenedAtValue
}

// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
// sort as by `opened_at`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *EpisodeGenericImpl) SetOpenedAt(v UtcMs) EpisodeGeneric {
	if s == nil {
		return nil
	}
	s.OpenedAtValue = v
	return s
}

// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Format: base64 (base64)
func (s EpisodeGenericImpl) Preview() *Base64 {
	return s.PreviewValue
}

// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Format: base64 (base64)
func (s *EpisodeGenericImpl) SetPreview(v Base64) EpisodeGeneric {
	if s == nil {
		return nil
	}
	s.PreviewValue = &v
	return s
}

// The time when the preview of this episode is available.
// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
// for details.
// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s EpisodeGenericImpl) PreviewTimestamp() *UtcMs {
	return s.PreviewTimestampValue
}

// The time when the preview of this episode is available.
// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
// for details.
// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *EpisodeGenericImpl) SetPreviewTimestamp(v UtcMs) EpisodeGeneric {
	if s == nil {
		return nil
	}
	s.PreviewTimestampValue = &v
	return s
}

// This field can be used as indication of the fact that some system have checked and ensured that
// this episode has really started at some time, that may differ from `opened_at`.
// For example video analytics will use this field for the time when this episode was confirmed as confident.
// May be not relevant for television systems.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s EpisodeGenericImpl) StartedAt() *UtcMs {
	return s.StartedAtValue
}

// This field can be used as indication of the fact that some system have checked and ensured that
// this episode has really started at some time, that may differ from `opened_at`.
// For example video analytics will use this field for the time when this episode was confirmed as confident.
// May be not relevant for television systems.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *EpisodeGenericImpl) SetStartedAt(v UtcMs) EpisodeGeneric {
	if s == nil {
		return nil
	}
	s.StartedAtValue = &v
	return s
}

// The time of last change of the episode.
// System that processes episodes and can send them to other systems, MUST update this field
// on any changes in this episode.
// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
// this `updated_at` can be used as a sort key for fetching fresh updates.
// Consumer of the episodes can use `updated_at` in the following scenario:
// * fetch all exisiting episodes from the source
// * take biggest `updated_at` from this dataset, it will be T
// * ask source for all episodes with `updated_at > T`
// This algorithm can be used for fetching update stream from the source.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637098611e+12
func (s EpisodeGenericImpl) UpdatedAt() UtcMs {
	return s.UpdatedAtValue
}

// The time of last change of the episode.
// System that processes episodes and can send them to other systems, MUST update this field
// on any changes in this episode.
// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
// this `updated_at` can be used as a sort key for fetching fresh updates.
// Consumer of the episodes can use `updated_at` in the following scenario:
// * fetch all exisiting episodes from the source
// * take biggest `updated_at` from this dataset, it will be T
// * ask source for all episodes with `updated_at > T`
// This algorithm can be used for fetching update stream from the source.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637098611e+12
func (s *EpisodeGenericImpl) SetUpdatedAt(v UtcMs) EpisodeGeneric {
	if s == nil {
		return nil
	}
	s.UpdatedAtValue = v
	return s
}

// NewEpisodePlay creates a new EpisodePlay instance
func NewEpisodePlay() EpisodePlay {
	return &EpisodePlayImpl{}
}

// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
// Example: onetime_token
func (s EpisodePlayImpl) PlaybackToken() *string {
	return s.PlaybackTokenValue
}

// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
// Example: onetime_token
func (s *EpisodePlayImpl) SetPlaybackToken(v string) EpisodePlay {
	if s == nil {
		return nil
	}
	s.PlaybackTokenValue = &v
	return s
}

// HTTP(s) URL that can be used for streaming API of this episode
// Example: https://streamer.example.com
func (s EpisodePlayImpl) StreamingEndpoint() *string {
	return s.StreamingEndpointValue
}

// HTTP(s) URL that can be used for streaming API of this episode
// Example: https://streamer.example.com
func (s *EpisodePlayImpl) SetStreamingEndpoint(v string) EpisodePlay {
	if s == nil {
		return nil
	}
	s.StreamingEndpointValue = &v
	return s
}

// NewEpisodeStreamDetails creates a new EpisodeStreamDetails instance
func NewEpisodeStreamDetails() EpisodeStreamDetails {
	return &EpisodeStreamDetailsImpl{}
}

// Details about stream related to the episode.
func (s EpisodeStreamDetailsImpl) Stream() EpisodeStreamDetailsStream {
	return s.StreamValue
}

// Details about stream related to the episode.
func (s *EpisodeStreamDetailsImpl) SetStream(v EpisodeStreamDetailsStream) EpisodeStreamDetails {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*EpisodeStreamDetailsStreamImpl); ok {
		s.StreamValue = impl
	}
	return s
}

// NewEpisodeStreamDetailsStream creates a new EpisodeStreamDetailsStream instance
func NewEpisodeStreamDetailsStream() EpisodeStreamDetailsStream {
	return &EpisodeStreamDetailsStreamImpl{}
}

// Human-readable description of the stream.
// Example: This is a test stream
func (s EpisodeStreamDetailsStreamImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the stream.
// Example: This is a test stream
func (s *EpisodeStreamDetailsStreamImpl) SetComment(v string) EpisodeStreamDetailsStream {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Globally unique stream name.
// Note that the name could not be changed after the stream is created.
// Format: media_name (media_name)
// Examples: Decklink-Stream, Dektec-Stream, hockey1, mylive/bunny, test_stream
func (s EpisodeStreamDetailsStreamImpl) Name() MediaName {
	return s.NameValue
}

// Globally unique stream name.
// Note that the name could not be changed after the stream is created.
// Format: media_name (media_name)
// Examples: Decklink-Stream, Dektec-Stream, hockey1, mylive/bunny, test_stream
func (s *EpisodeStreamDetailsStreamImpl) SetName(v MediaName) EpisodeStreamDetailsStream {
	if s == nil {
		return nil
	}
	s.NameValue = v
	return s
}

// ID of the organization the stream belongs to.
// Example: 9
func (s EpisodeStreamDetailsStreamImpl) OrganizationID() *int {
	return s.OrganizationIDValue
}

// ID of the organization the stream belongs to.
// Example: 9
func (s *EpisodeStreamDetailsStreamImpl) SetOrganizationID(v int) EpisodeStreamDetailsStream {
	if s == nil {
		return nil
	}
	s.OrganizationIDValue = &v
	return s
}

// Configuration of thumbnail of the stream.
func (s EpisodeStreamDetailsStreamImpl) Thumbnails() ThumbnailsSpec {
	return s.ThumbnailsValue
}

// Configuration of thumbnail of the stream.
func (s *EpisodeStreamDetailsStreamImpl) SetThumbnails(v ThumbnailsSpec) EpisodeStreamDetailsStream {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ThumbnailsSpecImpl); ok {
		s.ThumbnailsValue = impl
	}
	return s
}

// Human-readable title of the stream. Provided for SDT MPEG-TS table or
// SDP RTSP title parameter.
// Example: Hockey channel
func (s EpisodeStreamDetailsStreamImpl) Title() *string {
	return s.TitleValue
}

// Human-readable title of the stream. Provided for SDT MPEG-TS table or
// SDP RTSP title parameter.
// Example: Hockey channel
func (s *EpisodeStreamDetailsStreamImpl) SetTitle(v string) EpisodeStreamDetailsStream {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// NewEpisodesList creates a new EpisodesList instance
func NewEpisodesList() EpisodesList {
	return &EpisodesListImpl{}
}

// The list of Episodes fetched according to the query parameters.
func (s EpisodesListImpl) Episodes() []WatcherEpisode {
	if s.EpisodesValue == nil {
		return nil
	}
	result := make([]WatcherEpisode, len(s.EpisodesValue))
	for i, item := range s.EpisodesValue {
		result[i] = item
	}
	return result
}

// The list of Episodes fetched according to the query parameters.
func (s *EpisodesListImpl) SetEpisodes(v []WatcherEpisode) EpisodesList {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*WatcherEpisodeImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*WatcherEpisodeImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.EpisodesValue = impl
	}
	return s
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s EpisodesListImpl) EstimatedCount() *int {
	return s.EstimatedCountValue
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s *EpisodesListImpl) SetEstimatedCount(v int) EpisodesList {
	if s == nil {
		return nil
	}
	s.EstimatedCountValue = &v
	return s
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s EpisodesListImpl) Next() *string {
	return s.NextValue
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s *EpisodesListImpl) SetNext(v string) EpisodesList {
	if s == nil {
		return nil
	}
	s.NextValue = &v
	return s
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s EpisodesListImpl) Prev() *string {
	return s.PrevValue
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s *EpisodesListImpl) SetPrev(v string) EpisodesList {
	if s == nil {
		return nil
	}
	s.PrevValue = &v
	return s
}

// An object with a list of different timings measured during this API call.
func (s EpisodesListImpl) Timing() any {
	return s.TimingValue
}

// An object with a list of different timings measured during this API call.
func (s *EpisodesListImpl) SetTiming(v any) EpisodesList {
	if s == nil {
		return nil
	}
	s.TimingValue = v
	return s
}

// Collection returns the collection items from EpisodesList
func (s EpisodesListImpl) Collection() []WatcherEpisode {
	return s.Episodes()
}

// NewError creates a new Error instance
func NewError() Error {
	return &ErrorImpl{}
}

// an application-specific error code, expressed as a string value
func (s ErrorImpl) Code() *string {
	return s.CodeValue
}

// an application-specific error code, expressed as a string value
func (s *ErrorImpl) SetCode(v string) Error {
	if s == nil {
		return nil
	}
	s.CodeValue = &v
	return s
}

// a unique identifier for this particular occurrence of the problem
func (s ErrorImpl) ID() *string {
	return s.IDValue
}

// a unique identifier for this particular occurrence of the problem
func (s *ErrorImpl) SetID(v string) Error {
	if s == nil {
		return nil
	}
	s.IDValue = &v
	return s
}

// a meta object containing non-standard meta-information about the error.
func (s ErrorImpl) Meta() map[string]string {
	return s.MetaValue
}

// a meta object containing non-standard meta-information about the error.
func (s *ErrorImpl) SetMeta(v map[string]string) Error {
	if s == nil {
		return nil
	}
	s.MetaValue = v
	return s
}

// an object containing references to the source of the error
func (s ErrorImpl) Source() ErrorSource {
	return s.SourceValue
}

// an object containing references to the source of the error
func (s *ErrorImpl) SetSource(v ErrorSource) Error {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*ErrorSourceImpl); ok {
		s.SourceValue = impl
	}
	return s
}

// the HTTP status code applicable to this problem, expressed as a string value
func (s ErrorImpl) Status() *string {
	return s.StatusValue
}

// the HTTP status code applicable to this problem, expressed as a string value
func (s *ErrorImpl) SetStatus(v string) Error {
	if s == nil {
		return nil
	}
	s.StatusValue = &v
	return s
}

// a short, human-readable summary of the problem that SHOULD NOT change from
// occurrence to occurrence of the problem, except for purposes of localization
func (s ErrorImpl) Title() *string {
	return s.TitleValue
}

// a short, human-readable summary of the problem that SHOULD NOT change from
// occurrence to occurrence of the problem, except for purposes of localization
func (s *ErrorImpl) SetTitle(v string) Error {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// NewErrorResponse creates a new ErrorResponse instance
func NewErrorResponse() ErrorResponse {
	return &ErrorResponseImpl{}
}

// List of structured errors
func (s ErrorResponseImpl) Errors() []Error {
	if s.ErrorsValue == nil {
		return nil
	}
	result := make([]Error, len(s.ErrorsValue))
	for i, item := range s.ErrorsValue {
		result[i] = item
	}
	return result
}

// List of structured errors
func (s *ErrorResponseImpl) SetErrors(v []Error) ErrorResponse {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*ErrorImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*ErrorImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.ErrorsValue = impl
	}
	return s
}

// NewErrorSource creates a new ErrorSource instance
func NewErrorSource() ErrorSource {
	return &ErrorSourceImpl{}
}

// a string indicating which URI query parameter caused the error.
func (s ErrorSourceImpl) Parameter() *string {
	return s.ParameterValue
}

// a string indicating which URI query parameter caused the error.
func (s *ErrorSourceImpl) SetParameter(v string) ErrorSource {
	if s == nil {
		return nil
	}
	s.ParameterValue = &v
	return s
}

// a JSON Pointer [RFC6901] to the associated entity in the request document
// [e.g. `"/data"` for a primary data object, or `"/data/attributes/title"` for a specific attribute].
func (s ErrorSourceImpl) Pointer() *string {
	return s.PointerValue
}

// a JSON Pointer [RFC6901] to the associated entity in the request document
// [e.g. `"/data"` for a primary data object, or `"/data/attributes/title"` for a specific attribute].
func (s *ErrorSourceImpl) SetPointer(v string) ErrorSource {
	if s == nil {
		return nil
	}
	s.PointerValue = &v
	return s
}

// NewFirmwareUpdate creates a new FirmwareUpdate instance
func NewFirmwareUpdate() FirmwareUpdate {
	return &FirmwareUpdateImpl{}
}

// Image for updating camera. Documentation for updating cameras: https://flussonic.com/doc/flussonic-home-v1/#upgrade.
// Format: binary (binary)
// Example: b'DL'
func (s FirmwareUpdateImpl) Image() any {
	return s.ImageValue
}

// Image for updating camera. Documentation for updating cameras: https://flussonic.com/doc/flussonic-home-v1/#upgrade.
// Format: binary (binary)
// Example: b'DL'
func (s *FirmwareUpdateImpl) SetImage(v any) FirmwareUpdate {
	if s == nil {
		return nil
	}
	s.ImageValue = v
	return s
}

// Protocol for connecting to camera.
// Example: iris
func (s FirmwareUpdateImpl) Proto() *FirmwareUpdateProto {
	return s.ProtoValue
}

// Protocol for connecting to camera.
// Example: iris
func (s *FirmwareUpdateImpl) SetProto(v FirmwareUpdateProto) FirmwareUpdate {
	if s == nil {
		return nil
	}
	s.ProtoValue = &v
	return s
}

// NewFloorFile creates a new FloorFile instance
func NewFloorFile() FloorFile {
	return &FloorFileImpl{}
}

// Image data in base64 format
func (s FloorFileImpl) B64Content() *string {
	return s.B64ContentValue
}

// Image data in base64 format
func (s *FloorFileImpl) SetB64Content(v string) FloorFile {
	if s == nil {
		return nil
	}
	s.B64ContentValue = &v
	return s
}

// Image data in binary format
func (s FloorFileImpl) BinaryContent() *string {
	return s.BinaryContentValue
}

// Image data in binary format
func (s *FloorFileImpl) SetBinaryContent(v string) FloorFile {
	if s == nil {
		return nil
	}
	s.BinaryContentValue = &v
	return s
}

// Mime type of the image
func (s FloorFileImpl) MimeType() *string {
	return s.MimeTypeValue
}

// Mime type of the image
func (s *FloorFileImpl) SetMimeType(v string) FloorFile {
	if s == nil {
		return nil
	}
	s.MimeTypeValue = &v
	return s
}

// File name
// Example: 1-maps-2_07957af5f132243350a0f5546a675cb006354b69
func (s FloorFileImpl) Name() *string {
	return s.NameValue
}

// File name
// Example: 1-maps-2_07957af5f132243350a0f5546a675cb006354b69
func (s *FloorFileImpl) SetName(v string) FloorFile {
	if s == nil {
		return nil
	}
	s.NameValue = &v
	return s
}

// Deprecated field. Will be deleted at 25.09
// Image URL
func (s FloorFileImpl) URL() *string {
	return s.URLValue
}

// Deprecated field. Will be deleted at 25.09
// Image URL
func (s *FloorFileImpl) SetURL(v string) FloorFile {
	if s == nil {
		return nil
	}
	s.URLValue = &v
	return s
}

// NewFolder creates a new Folder instance
func NewFolder() Folder {
	return &FolderImpl{}
}

// The folder may have a floor plan attached to it to be shown on the map.
// This parameter sets the image center coordinates: latitude and longitude.
func (s FolderImpl) Coordinates() MapSpec {
	return s.CoordinatesValue
}

// The folder may have a floor plan attached to it to be shown on the map.
// This parameter sets the image center coordinates: latitude and longitude.
func (s *FolderImpl) SetCoordinates(v MapSpec) Folder {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*MapSpecImpl); ok {
		s.CoordinatesValue = impl
	}
	return s
}

// Object of map parameters
func (s FolderImpl) FloorPlan() FolderFloorPlan {
	return s.FloorPlanValue
}

// Object of map parameters
func (s *FolderImpl) SetFloorPlan(v FolderFloorPlan) Folder {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*FolderFloorPlanImpl); ok {
		s.FloorPlanValue = impl
	}
	return s
}

// Hierarchy object.
func (s FolderImpl) Hierarchy() FolderHierarchy {
	return s.HierarchyValue
}

// Hierarchy object.
func (s *FolderImpl) SetHierarchy(v FolderHierarchy) Folder {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*FolderHierarchyImpl); ok {
		s.HierarchyValue = impl
	}
	return s
}

// The folder ID.
func (s FolderImpl) ID() int {
	return s.IDValue
}

// The folder ID.
func (s *FolderImpl) SetID(v int) Folder {
	if s == nil {
		return nil
	}
	s.IDValue = v
	return s
}

// The identifier of the Organization to which the folder belongs.
func (s FolderImpl) OrganizationID() *int {
	return s.OrganizationIDValue
}

// The identifier of the Organization to which the folder belongs.
func (s *FolderImpl) SetOrganizationID(v int) Folder {
	if s == nil {
		return nil
	}
	s.OrganizationIDValue = &v
	return s
}

// The identifier of the parent folder.
func (s FolderImpl) ParentID() *int {
	return s.ParentIDValue
}

// The identifier of the parent folder.
func (s *FolderImpl) SetParentID(v int) Folder {
	if s == nil {
		return nil
	}
	s.ParentIDValue = &v
	return s
}

// The number of streams in the folder.
// Example: 2
func (s FolderImpl) StreamsCount() *int {
	return s.StreamsCountValue
}

// The number of streams in the folder.
// Example: 2
func (s *FolderImpl) SetStreamsCount(v int) Folder {
	if s == nil {
		return nil
	}
	s.StreamsCountValue = &v
	return s
}

// The folder name.
func (s FolderImpl) Title() *string {
	return s.TitleValue
}

// The folder name.
func (s *FolderImpl) SetTitle(v string) Folder {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// NewFolderFloorPlan creates a new FolderFloorPlan instance
func NewFolderFloorPlan() FolderFloorPlan {
	return &FolderFloorPlanImpl{}
}

// The coordinates of the bottom left corner of the floor plan image.
func (s FolderFloorPlanImpl) Bottomleft() MapSpec {
	return s.BottomleftValue
}

// The coordinates of the bottom left corner of the floor plan image.
func (s *FolderFloorPlanImpl) SetBottomleft(v MapSpec) FolderFloorPlan {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*MapSpecImpl); ok {
		s.BottomleftValue = impl
	}
	return s
}

func (s FolderFloorPlanImpl) File() FloorFile {
	return s.FileValue
}

func (s *FolderFloorPlanImpl) SetFile(v FloorFile) FolderFloorPlan {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*FloorFileImpl); ok {
		s.FileValue = impl
	}
	return s
}

// The coordinates of the top left corner of the floor plan image.
func (s FolderFloorPlanImpl) Topleft() MapSpec {
	return s.TopleftValue
}

// The coordinates of the top left corner of the floor plan image.
func (s *FolderFloorPlanImpl) SetTopleft(v MapSpec) FolderFloorPlan {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*MapSpecImpl); ok {
		s.TopleftValue = impl
	}
	return s
}

// The coordinates of the top right corner of the floor plan image.
func (s FolderFloorPlanImpl) Topright() MapSpec {
	return s.ToprightValue
}

// The coordinates of the top right corner of the floor plan image.
func (s *FolderFloorPlanImpl) SetTopright(v MapSpec) FolderFloorPlan {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*MapSpecImpl); ok {
		s.ToprightValue = impl
	}
	return s
}

// NewFolderHierarchy creates a new FolderHierarchy instance
func NewFolderHierarchy() FolderHierarchy {
	return &FolderHierarchyImpl{}
}

// The folder level in the hierarchy. The default (main) folder of the Organization is level 0.
// The child folder of the default folder is level 1, etc.
func (s FolderHierarchyImpl) Level() *int {
	return s.LevelValue
}

// The folder level in the hierarchy. The default (main) folder of the Organization is level 0.
// The child folder of the default folder is level 1, etc.
func (s *FolderHierarchyImpl) SetLevel(v int) FolderHierarchy {
	if s == nil {
		return nil
	}
	s.LevelValue = &v
	return s
}

// The index number of the folder within the parent folder. This number can be used for ordering folders.
func (s FolderHierarchyImpl) OrderNum() *int {
	return s.OrderNumValue
}

// The index number of the folder within the parent folder. This number can be used for ordering folders.
func (s *FolderHierarchyImpl) SetOrderNum(v int) FolderHierarchy {
	if s == nil {
		return nil
	}
	s.OrderNumValue = &v
	return s
}

// This parameters block allows changing the level of the folder in the hierarchy and order of folders
func (s FolderHierarchyImpl) Shift() FolderHierarchyShift {
	return s.ShiftValue
}

// This parameters block allows changing the level of the folder in the hierarchy and order of folders
func (s *FolderHierarchyImpl) SetShift(v FolderHierarchyShift) FolderHierarchy {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*FolderHierarchyShiftImpl); ok {
		s.ShiftValue = impl
	}
	return s
}

// NewFolderHierarchyShift creates a new FolderHierarchyShift instance
func NewFolderHierarchyShift() FolderHierarchyShift {
	return &FolderHierarchyShiftImpl{}
}

// The Id of destination folder.
func (s FolderHierarchyShiftImpl) Destination() *int {
	return s.DestinationValue
}

// The Id of destination folder.
func (s *FolderHierarchyShiftImpl) SetDestination(v int) FolderHierarchyShift {
	if s == nil {
		return nil
	}
	s.DestinationValue = &v
	return s
}

func (s FolderHierarchyShiftImpl) Direction() *FolderHierarchyShiftDirection {
	return s.DirectionValue
}

func (s *FolderHierarchyShiftImpl) SetDirection(v FolderHierarchyShiftDirection) FolderHierarchyShift {
	if s == nil {
		return nil
	}
	s.DirectionValue = &v
	return s
}

// NewFolderUser creates a new FolderUser instance
func NewFolderUser() FolderUser {
	return &FolderUserImpl{}
}

// The flag showing if the user can manage and execute actions on the streams in the folder.
func (s FolderUserImpl) CanUseActions() *bool {
	return s.CanUseActionsValue
}

// The flag showing if the user can manage and execute actions on the streams in the folder.
func (s *FolderUserImpl) SetCanUseActions(v bool) FolderUser {
	if s == nil {
		return nil
	}
	s.CanUseActionsValue = &v
	return s
}

// The flag if the user can use PTZ controls.
func (s FolderUserImpl) CanUsePtz() *bool {
	return s.CanUsePtzValue
}

// The flag if the user can use PTZ controls.
func (s *FolderUserImpl) SetCanUsePtz(v bool) FolderUser {
	if s == nil {
		return nil
	}
	s.CanUsePtzValue = &v
	return s
}

// The flag showing if the user can view only live on the streams in the folder and the list of streams.
func (s FolderUserImpl) CanView() *bool {
	return s.CanViewValue
}

// The flag showing if the user can view only live on the streams in the folder and the list of streams.
func (s *FolderUserImpl) SetCanView(v bool) FolderUser {
	if s == nil {
		return nil
	}
	s.CanViewValue = &v
	return s
}

// The flag showing if the user can view archive on the streams in the folder.
func (s FolderUserImpl) CanViewDvr() *bool {
	return s.CanViewDvrValue
}

// The flag showing if the user can view archive on the streams in the folder.
func (s *FolderUserImpl) SetCanViewDvr(v bool) FolderUser {
	if s == nil {
		return nil
	}
	s.CanViewDvrValue = &v
	return s
}

// The dvr depth limit allows to:
// Set the maximum recording depth, which determines how far back recorded materials can be viewed.
// Manage access to archived data, ensuring security and control over who can access records.
// if set to 0, the user has unlimited access to the archive.
// Format: seconds (seconds)
// Example: 3600
func (s FolderUserImpl) DvrDepthLimit() *Seconds {
	return s.DvrDepthLimitValue
}

// The dvr depth limit allows to:
// Set the maximum recording depth, which determines how far back recorded materials can be viewed.
// Manage access to archived data, ensuring security and control over who can access records.
// if set to 0, the user has unlimited access to the archive.
// Format: seconds (seconds)
// Example: 3600
func (s *FolderUserImpl) SetDvrDepthLimit(v Seconds) FolderUser {
	if s == nil {
		return nil
	}
	s.DvrDepthLimitValue = &v
	return s
}

// NewFolderUsers creates a new FolderUsers instance
func NewFolderUsers() FolderUsers {
	return &FolderUsersImpl{}
}

// The flag showing if the user can manage and execute actions on the streams in the folder.
func (s FolderUsersImpl) CanUseActions() *bool {
	return s.CanUseActionsValue
}

// The flag showing if the user can manage and execute actions on the streams in the folder.
func (s *FolderUsersImpl) SetCanUseActions(v bool) FolderUsers {
	if s == nil {
		return nil
	}
	s.CanUseActionsValue = &v
	return s
}

// The flag if the user can use PTZ controls.
func (s FolderUsersImpl) CanUsePtz() *bool {
	return s.CanUsePtzValue
}

// The flag if the user can use PTZ controls.
func (s *FolderUsersImpl) SetCanUsePtz(v bool) FolderUsers {
	if s == nil {
		return nil
	}
	s.CanUsePtzValue = &v
	return s
}

// The flag showing if the user can view only live on the streams in the folder and the list of streams.
func (s FolderUsersImpl) CanView() *bool {
	return s.CanViewValue
}

// The flag showing if the user can view only live on the streams in the folder and the list of streams.
func (s *FolderUsersImpl) SetCanView(v bool) FolderUsers {
	if s == nil {
		return nil
	}
	s.CanViewValue = &v
	return s
}

// The flag showing if the user can view archive on the streams in the folder.
func (s FolderUsersImpl) CanViewDvr() *bool {
	return s.CanViewDvrValue
}

// The flag showing if the user can view archive on the streams in the folder.
func (s *FolderUsersImpl) SetCanViewDvr(v bool) FolderUsers {
	if s == nil {
		return nil
	}
	s.CanViewDvrValue = &v
	return s
}

// The dvr depth limit allows to:
// Set the maximum recording depth, which determines how far back recorded materials can be viewed.
// Manage access to archived data, ensuring security and control over who can access records.
// if set to 0, the user has unlimited access to the archive.
// Format: seconds (seconds)
// Example: 3600
func (s FolderUsersImpl) DvrDepthLimit() *Seconds {
	return s.DvrDepthLimitValue
}

// The dvr depth limit allows to:
// Set the maximum recording depth, which determines how far back recorded materials can be viewed.
// Manage access to archived data, ensuring security and control over who can access records.
// if set to 0, the user has unlimited access to the archive.
// Format: seconds (seconds)
// Example: 3600
func (s *FolderUsersImpl) SetDvrDepthLimit(v Seconds) FolderUsers {
	if s == nil {
		return nil
	}
	s.DvrDepthLimitValue = &v
	return s
}

// User identifier
func (s FolderUsersImpl) UserID() *int {
	return s.UserIDValue
}

// User identifier
func (s *FolderUsersImpl) SetUserID(v int) FolderUsers {
	if s == nil {
		return nil
	}
	s.UserIDValue = &v
	return s
}

// NewFolderUsersList creates a new FolderUsersList instance
func NewFolderUsersList() FolderUsersList {
	return &FolderUsersListImpl{}
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s FolderUsersListImpl) EstimatedCount() *int {
	return s.EstimatedCountValue
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s *FolderUsersListImpl) SetEstimatedCount(v int) FolderUsersList {
	if s == nil {
		return nil
	}
	s.EstimatedCountValue = &v
	return s
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s FolderUsersListImpl) Next() *string {
	return s.NextValue
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s *FolderUsersListImpl) SetNext(v string) FolderUsersList {
	if s == nil {
		return nil
	}
	s.NextValue = &v
	return s
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s FolderUsersListImpl) Prev() *string {
	return s.PrevValue
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s *FolderUsersListImpl) SetPrev(v string) FolderUsersList {
	if s == nil {
		return nil
	}
	s.PrevValue = &v
	return s
}

// An object with a list of different timings measured during this API call.
func (s FolderUsersListImpl) Timing() any {
	return s.TimingValue
}

// An object with a list of different timings measured during this API call.
func (s *FolderUsersListImpl) SetTiming(v any) FolderUsersList {
	if s == nil {
		return nil
	}
	s.TimingValue = v
	return s
}

// List of fetched users in a folder according to the query parameters.
func (s FolderUsersListImpl) Users() []FolderUsers {
	if s.UsersValue == nil {
		return nil
	}
	result := make([]FolderUsers, len(s.UsersValue))
	for i, item := range s.UsersValue {
		result[i] = item
	}
	return result
}

// List of fetched users in a folder according to the query parameters.
func (s *FolderUsersListImpl) SetUsers(v []FolderUsers) FolderUsersList {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*FolderUsersImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*FolderUsersImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.UsersValue = impl
	}
	return s
}

// Collection returns the collection items from FolderUsersList
func (s FolderUsersListImpl) Collection() []FolderUsers {
	return s.Users()
}

// NewFoldersList creates a new FoldersList instance
func NewFoldersList() FoldersList {
	return &FoldersListImpl{}
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s FoldersListImpl) EstimatedCount() *int {
	return s.EstimatedCountValue
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s *FoldersListImpl) SetEstimatedCount(v int) FoldersList {
	if s == nil {
		return nil
	}
	s.EstimatedCountValue = &v
	return s
}

// List of folders.
func (s FoldersListImpl) Folders() []Folder {
	if s.FoldersValue == nil {
		return nil
	}
	result := make([]Folder, len(s.FoldersValue))
	for i, item := range s.FoldersValue {
		result[i] = item
	}
	return result
}

// List of folders.
func (s *FoldersListImpl) SetFolders(v []Folder) FoldersList {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*FolderImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*FolderImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.FoldersValue = impl
	}
	return s
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s FoldersListImpl) Next() *string {
	return s.NextValue
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s *FoldersListImpl) SetNext(v string) FoldersList {
	if s == nil {
		return nil
	}
	s.NextValue = &v
	return s
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s FoldersListImpl) Prev() *string {
	return s.PrevValue
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s *FoldersListImpl) SetPrev(v string) FoldersList {
	if s == nil {
		return nil
	}
	s.PrevValue = &v
	return s
}

// An object with a list of different timings measured during this API call.
func (s FoldersListImpl) Timing() any {
	return s.TimingValue
}

// An object with a list of different timings measured during this API call.
func (s *FoldersListImpl) SetTiming(v any) FoldersList {
	if s == nil {
		return nil
	}
	s.TimingValue = v
	return s
}

// Collection returns the collection items from FoldersList
func (s FoldersListImpl) Collection() []Folder {
	return s.Folders()
}

// NewH26xDecoderCounters creates a new H26xDecoderCounters instance
func NewH26xDecoderCounters() H26xDecoderCounters {
	return &H26xDecoderCountersImpl{}
}

// Number of NAL units, which `forbidden_zero_bit` is set to one.
func (s H26xDecoderCountersImpl) DiscardedBrokenNalCount() *int {
	return s.DiscardedBrokenNalCountValue
}

// Number of NAL units, which `forbidden_zero_bit` is set to one.
func (s *H26xDecoderCountersImpl) SetDiscardedBrokenNalCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.DiscardedBrokenNalCountValue = &v
	return s
}

// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
// This counter shows number of discarded `Fragmentation Units`
func (s H26xDecoderCountersImpl) DiscardedFuCount() *int {
	return s.DiscardedFuCountValue
}

// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
// This counter shows number of discarded `Fragmentation Units`
func (s *H26xDecoderCountersImpl) SetDiscardedFuCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.DiscardedFuCountValue = &v
	return s
}

// Number of discarded NAL units.
func (s H26xDecoderCountersImpl) DiscardedNalCount() *int {
	return s.DiscardedNalCountValue
}

// Number of discarded NAL units.
func (s *H26xDecoderCountersImpl) SetDiscardedNalCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.DiscardedNalCountValue = &v
	return s
}

// Number of NAL units, which type is not allowed in `non-interleaved packetization mode`.
func (s H26xDecoderCountersImpl) DiscardedNotAllowedNalCount() *int {
	return s.DiscardedNotAllowedNalCountValue
}

// Number of NAL units, which type is not allowed in `non-interleaved packetization mode`.
func (s *H26xDecoderCountersImpl) SetDiscardedNotAllowedNalCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.DiscardedNotAllowedNalCountValue = &v
	return s
}

// Number of discarded `SEI` NAL units
func (s H26xDecoderCountersImpl) DiscardedSeiCount() *int {
	return s.DiscardedSeiCountValue
}

// Number of discarded `SEI` NAL units
func (s *H26xDecoderCountersImpl) SetDiscardedSeiCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.DiscardedSeiCountValue = &v
	return s
}

// There is workaround to not interrupt `FU` sequence if `end-FU` followed by `middle-FU`.
// This counter shows how many time the workaround was applied.
func (s H26xDecoderCountersImpl) FuEndThenMiddleWorkaroundCount() *int {
	return s.FuEndThenMiddleWorkaroundCountValue
}

// There is workaround to not interrupt `FU` sequence if `end-FU` followed by `middle-FU`.
// This counter shows how many time the workaround was applied.
func (s *H26xDecoderCountersImpl) SetFuEndThenMiddleWorkaroundCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.FuEndThenMiddleWorkaroundCountValue = &v
	return s
}

// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
// This counter shows number of `Fragmentation Units` which `Start bit` and `End bit` are set to one in the same `FU` header
func (s H26xDecoderCountersImpl) FuHasBothStartEndBitsCount() *int {
	return s.FuHasBothStartEndBitsCountValue
}

// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
// This counter shows number of `Fragmentation Units` which `Start bit` and `End bit` are set to one in the same `FU` header
func (s *H26xDecoderCountersImpl) SetFuHasBothStartEndBitsCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.FuHasBothStartEndBitsCountValue = &v
	return s
}

// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
// `Fragmentation Units` pattern must have a `Start FU`, `End FU` and could have `FUs` between these ones.
// This counter indicates how many times pattern was broken.
func (s H26xDecoderCountersImpl) FuPatternIsBrokenCount() *int {
	return s.FuPatternIsBrokenCountValue
}

// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
// `Fragmentation Units` pattern must have a `Start FU`, `End FU` and could have `FUs` between these ones.
// This counter indicates how many times pattern was broken.
func (s *H26xDecoderCountersImpl) SetFuPatternIsBrokenCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.FuPatternIsBrokenCountValue = &v
	return s
}

// NAL deframentation could be interrupted by unexpected NAL or broken/incomplete packet.
// If NAL deframentation is interrupted then incomplete fragment of NAL is not discarded and used in decoding process.
// This counter indicates how many incomplete NALs were used.
func (s H26xDecoderCountersImpl) IncompleteNalCount() *int {
	return s.IncompleteNalCountValue
}

// NAL deframentation could be interrupted by unexpected NAL or broken/incomplete packet.
// If NAL deframentation is interrupted then incomplete fragment of NAL is not discarded and used in decoding process.
// This counter indicates how many incomplete NALs were used.
func (s *H26xDecoderCountersImpl) SetIncompleteNalCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.IncompleteNalCountValue = &v
	return s
}

// Number of `SEI` NAL units with bad payload
func (s H26xDecoderCountersImpl) InvalidSeiPayloadCount() *int {
	return s.InvalidSeiPayloadCountValue
}

// Number of `SEI` NAL units with bad payload
func (s *H26xDecoderCountersImpl) SetInvalidSeiPayloadCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.InvalidSeiPayloadCountValue = &v
	return s
}

// Number of `SEI` NAL units with invalid size
func (s H26xDecoderCountersImpl) InvalidSeiSizeCount() *int {
	return s.InvalidSeiSizeCountValue
}

// Number of `SEI` NAL units with invalid size
func (s *H26xDecoderCountersImpl) SetInvalidSeiSizeCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.InvalidSeiSizeCountValue = &v
	return s
}

// Number of `SEI` NAL units with invalid type
func (s H26xDecoderCountersImpl) InvalidSeiTypeCount() *int {
	return s.InvalidSeiTypeCountValue
}

// Number of `SEI` NAL units with invalid type
func (s *H26xDecoderCountersImpl) SetInvalidSeiTypeCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.InvalidSeiTypeCountValue = &v
	return s
}

// How many NAL `AGGREGATION` units handled by this decoder.
func (s H26xDecoderCountersImpl) NalAggregationCount() *int {
	return s.NalAggregationCountValue
}

// How many NAL `AGGREGATION` units handled by this decoder.
func (s *H26xDecoderCountersImpl) SetNalAggregationCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.NalAggregationCountValue = &v
	return s
}

// How many NAL `AUD` units handled by this decoder.
func (s H26xDecoderCountersImpl) NalAudCount() *int {
	return s.NalAudCountValue
}

// How many NAL `AUD` units handled by this decoder.
func (s *H26xDecoderCountersImpl) SetNalAudCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.NalAudCountValue = &v
	return s
}

// How many NAL units handled by this decoder.
func (s H26xDecoderCountersImpl) NalCount() *int {
	return s.NalCountValue
}

// How many NAL units handled by this decoder.
func (s *H26xDecoderCountersImpl) SetNalCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.NalCountValue = &v
	return s
}

// How many NAL `FILLER` units handled by this decoder.
func (s H26xDecoderCountersImpl) NalFillerCount() *int {
	return s.NalFillerCountValue
}

// How many NAL `FILLER` units handled by this decoder.
func (s *H26xDecoderCountersImpl) SetNalFillerCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.NalFillerCountValue = &v
	return s
}

// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
// This counter shows how many `Fragmentation Units` handled by this decoder.
func (s H26xDecoderCountersImpl) NalFuCount() *int {
	return s.NalFuCountValue
}

// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
// This counter shows how many `Fragmentation Units` handled by this decoder.
func (s *H26xDecoderCountersImpl) SetNalFuCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.NalFuCountValue = &v
	return s
}

// How many NAL `IDR` units handled by this decoder.
func (s H26xDecoderCountersImpl) NalIdrCount() *int {
	return s.NalIdrCountValue
}

// How many NAL `IDR` units handled by this decoder.
func (s *H26xDecoderCountersImpl) SetNalIdrCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.NalIdrCountValue = &v
	return s
}

// How many other NAL units handled by this decoder.
func (s H26xDecoderCountersImpl) NalOtherCount() *int {
	return s.NalOtherCountValue
}

// How many other NAL units handled by this decoder.
func (s *H26xDecoderCountersImpl) SetNalOtherCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.NalOtherCountValue = &v
	return s
}

// How many NAL `PPS` units handled by this decoder.
func (s H26xDecoderCountersImpl) NalPpsCount() *int {
	return s.NalPpsCountValue
}

// How many NAL `PPS` units handled by this decoder.
func (s *H26xDecoderCountersImpl) SetNalPpsCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.NalPpsCountValue = &v
	return s
}

// How many NAL `SEI` units handled by this decoder.
func (s H26xDecoderCountersImpl) NalSeiCount() *int {
	return s.NalSeiCountValue
}

// How many NAL `SEI` units handled by this decoder.
func (s *H26xDecoderCountersImpl) SetNalSeiCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.NalSeiCountValue = &v
	return s
}

// How many NAL `SINGLE` units handled by this decoder.
func (s H26xDecoderCountersImpl) NalSingleCount() *int {
	return s.NalSingleCountValue
}

// How many NAL `SINGLE` units handled by this decoder.
func (s *H26xDecoderCountersImpl) SetNalSingleCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.NalSingleCountValue = &v
	return s
}

// How many NAL `SLICE` units handled by this decoder.
func (s H26xDecoderCountersImpl) NalSliceCount() *int {
	return s.NalSliceCountValue
}

// How many NAL `SLICE` units handled by this decoder.
func (s *H26xDecoderCountersImpl) SetNalSliceCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.NalSliceCountValue = &v
	return s
}

// How many NAL `SPS` units handled by this decoder.
func (s H26xDecoderCountersImpl) NalSpsCount() *int {
	return s.NalSpsCountValue
}

// How many NAL `SPS` units handled by this decoder.
func (s *H26xDecoderCountersImpl) SetNalSpsCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.NalSpsCountValue = &v
	return s
}

// How many NAL `STAP_A` units handled by this decoder.
func (s H26xDecoderCountersImpl) NalStapACount() *int {
	return s.NalStapACountValue
}

// How many NAL `STAP_A` units handled by this decoder.
func (s *H26xDecoderCountersImpl) SetNalStapACount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.NalStapACountValue = &v
	return s
}

// How many NAL `VPS` units handled by this decoder.
func (s H26xDecoderCountersImpl) NalVpsCount() *int {
	return s.NalVpsCountValue
}

// How many NAL `VPS` units handled by this decoder.
func (s *H26xDecoderCountersImpl) SetNalVpsCount(v int) H26xDecoderCounters {
	if s == nil {
		return nil
	}
	s.NalVpsCountValue = &v
	return s
}

// NewInputAgentCounters creates a new InputAgentCounters instance
func NewInputAgentCounters() InputAgentCounters {
	return &InputAgentCountersImpl{}
}

// These errors indicate that the agent does not have enough buffer size to handle outgoing traffic.
func (s InputAgentCountersImpl) ErrorsBufferOverrun() *int {
	return s.ErrorsBufferOverrunValue
}

// These errors indicate that the agent does not have enough buffer size to handle outgoing traffic.
func (s *InputAgentCountersImpl) SetErrorsBufferOverrun(v int) InputAgentCounters {
	if s == nil {
		return nil
	}
	s.ErrorsBufferOverrunValue = &v
	return s
}

// The agent was unable to open the requested connection. These errors may indicate problems opening the TCP socket on the agent or the remote host is unreacheable.
func (s InputAgentCountersImpl) ErrorsConnFailed() *int {
	return s.ErrorsConnFailedValue
}

// The agent was unable to open the requested connection. These errors may indicate problems opening the TCP socket on the agent or the remote host is unreacheable.
func (s *InputAgentCountersImpl) SetErrorsConnFailed(v int) InputAgentCounters {
	if s == nil {
		return nil
	}
	s.ErrorsConnFailedValue = &v
	return s
}

// These errors indicate that the agent is receiving invalid requests.
func (s InputAgentCountersImpl) ErrorsInvalidRequest() *int {
	return s.ErrorsInvalidRequestValue
}

// These errors indicate that the agent is receiving invalid requests.
func (s *InputAgentCountersImpl) SetErrorsInvalidRequest(v int) InputAgentCounters {
	if s == nil {
		return nil
	}
	s.ErrorsInvalidRequestValue = &v
	return s
}

// These errors indicate that the agent does not have enough memory to establish a connection to the remote host.
func (s InputAgentCountersImpl) ErrorsOutOfMemory() *int {
	return s.ErrorsOutOfMemoryValue
}

// These errors indicate that the agent does not have enough memory to establish a connection to the remote host.
func (s *InputAgentCountersImpl) SetErrorsOutOfMemory(v int) InputAgentCounters {
	if s == nil {
		return nil
	}
	s.ErrorsOutOfMemoryValue = &v
	return s
}

// Unknown errors counter.
func (s InputAgentCountersImpl) ErrorsUnknown() *int {
	return s.ErrorsUnknownValue
}

// Unknown errors counter.
func (s *InputAgentCountersImpl) SetErrorsUnknown(v int) InputAgentCounters {
	if s == nil {
		return nil
	}
	s.ErrorsUnknownValue = &v
	return s
}

// NewInputCounters creates a new InputCounters instance
func NewInputCounters() InputCounters {
	return &InputCountersImpl{}
}

// How many Ad markers passed to this stream from the inputs.
func (s InputCountersImpl) AdSplicesIngested() *int {
	return s.AdSplicesIngestedValue
}

// How many Ad markers passed to this stream from the inputs.
func (s *InputCountersImpl) SetAdSplicesIngested(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.AdSplicesIngestedValue = &v
	return s
}

// How many Ad markers inserted to this stream by user.
func (s InputCountersImpl) AdSplicesInserted() *int {
	return s.AdSplicesInsertedValue
}

// How many Ad markers inserted to this stream by user.
func (s *InputCountersImpl) SetAdSplicesInserted(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.AdSplicesInsertedValue = &v
	return s
}

func (s InputCountersImpl) Agent() InputAgentCounters {
	return s.AgentValue
}

func (s *InputCountersImpl) SetAgent(v InputAgentCounters) InputCounters {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputAgentCountersImpl); ok {
		s.AgentValue = impl
	}
	return s
}

// Number of bytes received by this stream from live sources.
// It will be counted before transcoding and will sum all inputs working together.
// Format: bytes (bytes)
func (s InputCountersImpl) Bytes() *Bytes {
	return s.BytesValue
}

// Number of bytes received by this stream from live sources.
// It will be counted before transcoding and will sum all inputs working together.
// Format: bytes (bytes)
func (s *InputCountersImpl) SetBytes(v Bytes) InputCounters {
	if s == nil {
		return nil
	}
	s.BytesValue = &v
	return s
}

// Number of bytes received by this stream when downloading from remote DVR.
// Format: bytes (bytes)
func (s InputCountersImpl) BytesDvr() *Bytes {
	return s.BytesDvrValue
}

// Number of bytes received by this stream when downloading from remote DVR.
// Format: bytes (bytes)
func (s *InputCountersImpl) SetBytesDvr(v Bytes) InputCounters {
	if s == nil {
		return nil
	}
	s.BytesDvrValue = &v
	return s
}

// Sum of all other specific errors in the last minute
// Example: 0
func (s InputCountersImpl) ErrorRate() *int {
	return s.ErrorRateValue
}

// Sum of all other specific errors in the last minute
// Example: 0
func (s *InputCountersImpl) SetErrorRate(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.ErrorRateValue = &v
	return s
}

// Sum of all other specific errors. Can be used for triggering alert on any error
// Example: 0
func (s InputCountersImpl) Errors() *int {
	return s.ErrorsValue
}

// Sum of all other specific errors. Can be used for triggering alert on any error
// Example: 0
func (s *InputCountersImpl) SetErrors(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.ErrorsValue = &v
	return s
}

// How many times we've got 403 (eaccess).
func (s InputCountersImpl) Errors403() *int {
	return s.Errors403Value
}

// How many times we've got 403 (eaccess).
func (s *InputCountersImpl) SetErrors403(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.Errors403Value = &v
	return s
}

// How many times we've got 404 (enoent).
func (s InputCountersImpl) Errors404() *int {
	return s.Errors404Value
}

// How many times we've got 404 (enoent).
func (s *InputCountersImpl) SetErrors404(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.Errors404Value = &v
	return s
}

// How many times we've got 500 (backend error).
func (s InputCountersImpl) Errors500() *int {
	return s.Errors500Value
}

// How many times we've got 500 (backend error).
func (s *InputCountersImpl) SetErrors500(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.Errors500Value = &v
	return s
}

// Demultiplexing was done right, but content is broken.
func (s InputCountersImpl) ErrorsBrokenPayload() *int {
	return s.ErrorsBrokenPayloadValue
}

// Demultiplexing was done right, but content is broken.
func (s *InputCountersImpl) SetErrorsBrokenPayload(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.ErrorsBrokenPayloadValue = &v
	return s
}

// How many times input was restarted due to internal crash.
// This may happen due to unhandled input.
func (s InputCountersImpl) ErrorsCrashed() *int {
	return s.ErrorsCrashedValue
}

// How many times input was restarted due to internal crash.
// This may happen due to unhandled input.
func (s *InputCountersImpl) SetErrorsCrashed(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.ErrorsCrashedValue = &v
	return s
}

// Decoder reset count due to abnormal DTS change. Can happen in MPEG-TS, RTP.
func (s InputCountersImpl) ErrorsDecoderReset() *int {
	return s.ErrorsDecoderResetValue
}

// Decoder reset count due to abnormal DTS change. Can happen in MPEG-TS, RTP.
func (s *InputCountersImpl) SetErrorsDecoderReset(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.ErrorsDecoderResetValue = &v
	return s
}

// This can be used as a `TS_sync_loss` - how many times MPEG-TS sync was lost.
// Also this counter refers to RTSP desync, when camera starts dropping TCP data and
// we have to find packet boundaries.
// Here we write count of such resynchronizations.
func (s InputCountersImpl) ErrorsDesync() *int {
	return s.ErrorsDesyncValue
}

// This can be used as a `TS_sync_loss` - how many times MPEG-TS sync was lost.
// Also this counter refers to RTSP desync, when camera starts dropping TCP data and
// we have to find packet boundaries.
// Here we write count of such resynchronizations.
func (s *InputCountersImpl) SetErrorsDesync(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.ErrorsDesyncValue = &v
	return s
}

// Dropped frames count due timestamp adjustment.
func (s InputCountersImpl) ErrorsDroppedFrames() *int {
	return s.ErrorsDroppedFramesValue
}

// Dropped frames count due timestamp adjustment.
func (s *InputCountersImpl) SetErrorsDroppedFrames(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.ErrorsDroppedFramesValue = &v
	return s
}

// RTP, MPEG-TS or other protocols have enough information to tell how many packets were lost
func (s InputCountersImpl) ErrorsLostPackets() *int {
	return s.ErrorsLostPacketsValue
}

// RTP, MPEG-TS or other protocols have enough information to tell how many packets were lost
func (s *InputCountersImpl) SetErrorsLostPackets(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.ErrorsLostPacketsValue = &v
	return s
}

// how many times PAT was missing during 0,5 seconds or pid 0 misses PAT
// `PAT_error`
func (s InputCountersImpl) ErrorsTSPat() *int {
	return s.ErrorsTSPatValue
}

// how many times PAT was missing during 0,5 seconds or pid 0 misses PAT
// `PAT_error`
func (s *InputCountersImpl) SetErrorsTSPat(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.ErrorsTSPatValue = &v
	return s
}

// How many times have received PAT that was missing required service (program)
func (s InputCountersImpl) ErrorsTSServiceLost() *int {
	return s.ErrorsTSServiceLostValue
}

// How many times have received PAT that was missing required service (program)
func (s *InputCountersImpl) SetErrorsTSServiceLost(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.ErrorsTSServiceLostValue = &v
	return s
}

// Number of connection restarts to fix ts_stuck issue. Can happen in RTSP.
func (s InputCountersImpl) ErrorsTSStuckRestarts() *int {
	return s.ErrorsTSStuckRestartsValue
}

// Number of connection restarts to fix ts_stuck issue. Can happen in RTSP.
func (s *InputCountersImpl) SetErrorsTSStuckRestarts(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.ErrorsTSStuckRestartsValue = &v
	return s
}

// Number of frames passed to this stream from the inputs.
func (s InputCountersImpl) Frames() *int {
	return s.FramesValue
}

// Number of frames passed to this stream from the inputs.
func (s *InputCountersImpl) SetFrames(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.FramesValue = &v
	return s
}

// Aggregated: how many times this stream has switched between different inputs.
// Individual input: number of times switched to this input.
func (s InputCountersImpl) InputSwitches() *int {
	return s.InputSwitchesValue
}

// Aggregated: how many times this stream has switched between different inputs.
// Individual input: number of times switched to this input.
func (s *InputCountersImpl) SetInputSwitches(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.InputSwitchesValue = &v
	return s
}

// Number of secondary inputs that have some problems.
// Example: 0
func (s InputCountersImpl) InvalidSecondaryInputs() *int {
	return s.InvalidSecondaryInputsValue
}

// Number of secondary inputs that have some problems.
// Example: 0
func (s *InputCountersImpl) SetInvalidSecondaryInputs(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.InvalidSecondaryInputsValue = &v
	return s
}

// Indicates, how often does media_info changes
func (s InputCountersImpl) MediaInfoChanges() *int {
	return s.MediaInfoChangesValue
}

// Indicates, how often does media_info changes
func (s *InputCountersImpl) SetMediaInfoChanges(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.MediaInfoChangesValue = &v
	return s
}

func (s InputCountersImpl) MotionDetector() InputMotionDetectorCounters {
	return s.MotionDetectorValue
}

func (s *InputCountersImpl) SetMotionDetector(v InputMotionDetectorCounters) InputCounters {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputMotionDetectorCountersImpl); ok {
		s.MotionDetectorValue = impl
	}
	return s
}

// How many seconds has this stream had no frames.
// Format: seconds (seconds)
func (s InputCountersImpl) NumSecNoData() *Seconds {
	return s.NumSecNoDataValue
}

// How many seconds has this stream had no frames.
// Format: seconds (seconds)
func (s *InputCountersImpl) SetNumSecNoData(v Seconds) InputCounters {
	if s == nil {
		return nil
	}
	s.NumSecNoDataValue = &v
	return s
}

// How many seconds has this stream played from primary input.
// Format: seconds (seconds)
func (s InputCountersImpl) NumSecOnPrimaryInput() *Seconds {
	return s.NumSecOnPrimaryInputValue
}

// How many seconds has this stream played from primary input.
// Format: seconds (seconds)
func (s *InputCountersImpl) SetNumSecOnPrimaryInput(v Seconds) InputCounters {
	if s == nil {
		return nil
	}
	s.NumSecOnPrimaryInputValue = &v
	return s
}

// How many seconds has this stream played from secondary inputs.
// Format: seconds (seconds)
func (s InputCountersImpl) NumSecOnSecondaryInput() *Seconds {
	return s.NumSecOnSecondaryInputValue
}

// How many seconds has this stream played from secondary inputs.
// Format: seconds (seconds)
func (s *InputCountersImpl) SetNumSecOnSecondaryInput(v Seconds) InputCounters {
	if s == nil {
		return nil
	}
	s.NumSecOnSecondaryInputValue = &v
	return s
}

// Per pid statistics calculated for MPEG-TS input
func (s InputCountersImpl) Pids() []InputPidCounters {
	if s.PidsValue == nil {
		return nil
	}
	result := make([]InputPidCounters, len(s.PidsValue))
	for i, item := range s.PidsValue {
		result[i] = item
	}
	return result
}

// Per pid statistics calculated for MPEG-TS input
func (s *InputCountersImpl) SetPids(v []InputPidCounters) InputCounters {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*InputPidCountersImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*InputPidCountersImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.PidsValue = impl
	}
	return s
}

// Source may send frames not in the order they should be played. It will be catched and reordered.
// This counter indicates how many times did it happened.
func (s InputCountersImpl) ReorderCount() *int {
	return s.ReorderCountValue
}

// Source may send frames not in the order they should be played. It will be catched and reordered.
// This counter indicates how many times did it happened.
func (s *InputCountersImpl) SetReorderCount(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.ReorderCountValue = &v
	return s
}

// Source may send frames timestamps faster or slower than realtime.
// Live stream will catch it and resync. This counter indicates how many times did it happened.
func (s InputCountersImpl) ResyncCountDrift() *int {
	return s.ResyncCountDriftValue
}

// Source may send frames timestamps faster or slower than realtime.
// Live stream will catch it and resync. This counter indicates how many times did it happened.
func (s *InputCountersImpl) SetResyncCountDrift(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.ResyncCountDriftValue = &v
	return s
}

// Source may change timestamps without any signalling. This counter indicates how bad is the source
func (s InputCountersImpl) ResyncCountJump() *int {
	return s.ResyncCountJumpValue
}

// Source may change timestamps without any signalling. This counter indicates how bad is the source
func (s *InputCountersImpl) SetResyncCountJump(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.ResyncCountJumpValue = &v
	return s
}

// Stream timestamps are synchronized with real time. This counter tells, how many times
// it was syncronized after source reconnect.
func (s InputCountersImpl) ResyncCountNormal() *int {
	return s.ResyncCountNormalValue
}

// Stream timestamps are synchronized with real time. This counter tells, how many times
// it was syncronized after source reconnect.
func (s *InputCountersImpl) SetResyncCountNormal(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.ResyncCountNormalValue = &v
	return s
}

// How many times has this stream retried to connect to source
func (s InputCountersImpl) Retries() *int {
	return s.RetriesValue
}

// How many times has this stream retried to connect to source
func (s *InputCountersImpl) SetRetries(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.RetriesValue = &v
	return s
}

// Per channel statistics calculated for RTP input
func (s InputCountersImpl) RTPChannels() []InputRTPCounters {
	if s.RTPChannelsValue == nil {
		return nil
	}
	result := make([]InputRTPCounters, len(s.RTPChannelsValue))
	for i, item := range s.RTPChannelsValue {
		result[i] = item
	}
	return result
}

// Per channel statistics calculated for RTP input
func (s *InputCountersImpl) SetRTPChannels(v []InputRTPCounters) InputCounters {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*InputRTPCountersImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*InputRTPCountersImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.RTPChannelsValue = impl
	}
	return s
}

func (s InputCountersImpl) Sdi() InputSdiCounters {
	return s.SdiValue
}

func (s *InputCountersImpl) SetSdi(v InputSdiCounters) InputCounters {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputSdiCountersImpl); ok {
		s.SdiValue = impl
	}
	return s
}

func (s InputCountersImpl) Srt() InputSrtCounters {
	return s.SrtValue
}

func (s *InputCountersImpl) SetSrt(v InputSrtCounters) InputCounters {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputSrtCountersImpl); ok {
		s.SrtValue = impl
	}
	return s
}

// Number of secondary inputs that have no problems.
// Example: 2
func (s InputCountersImpl) ValidSecondaryInputs() *int {
	return s.ValidSecondaryInputsValue
}

// Number of secondary inputs that have no problems.
// Example: 2
func (s *InputCountersImpl) SetValidSecondaryInputs(v int) InputCounters {
	if s == nil {
		return nil
	}
	s.ValidSecondaryInputsValue = &v
	return s
}

// NewInputMotionDetectorCounters creates a new InputMotionDetectorCounters instance
func NewInputMotionDetectorCounters() InputMotionDetectorCounters {
	return &InputMotionDetectorCountersImpl{}
}

// Number of collected episodes.
func (s InputMotionDetectorCountersImpl) EpisodesCount() *int {
	return s.EpisodesCountValue
}

// Number of collected episodes.
func (s *InputMotionDetectorCountersImpl) SetEpisodesCount(v int) InputMotionDetectorCounters {
	if s == nil {
		return nil
	}
	s.EpisodesCountValue = &v
	return s
}

// Number of responses with broken content.
func (s InputMotionDetectorCountersImpl) ErrorsBrokenPayload() *int {
	return s.ErrorsBrokenPayloadValue
}

// Number of responses with broken content.
func (s *InputMotionDetectorCountersImpl) SetErrorsBrokenPayload(v int) InputMotionDetectorCounters {
	if s == nil {
		return nil
	}
	s.ErrorsBrokenPayloadValue = &v
	return s
}

// `ONVIF Event Handling Test Specification` says that valid values for `CurrentTime` and `TerminationTime` are
// `TerminationTime >= CurrentTime + InitialTerminationTime`.
// How many responses did not met the condition.
func (s InputMotionDetectorCountersImpl) ErrorsIncorrectTimeValuesCount() *int {
	return s.ErrorsIncorrectTimeValuesCountValue
}

// `ONVIF Event Handling Test Specification` says that valid values for `CurrentTime` and `TerminationTime` are
// `TerminationTime >= CurrentTime + InitialTerminationTime`.
// How many responses did not met the condition.
func (s *InputMotionDetectorCountersImpl) SetErrorsIncorrectTimeValuesCount(v int) InputMotionDetectorCounters {
	if s == nil {
		return nil
	}
	s.ErrorsIncorrectTimeValuesCountValue = &v
	return s
}

// Number of failed request attempts because of no agent connected.
func (s InputMotionDetectorCountersImpl) ErrorsNoAgentConnected() *int {
	return s.ErrorsNoAgentConnectedValue
}

// Number of failed request attempts because of no agent connected.
func (s *InputMotionDetectorCountersImpl) SetErrorsNoAgentConnected(v int) InputMotionDetectorCounters {
	if s == nil {
		return nil
	}
	s.ErrorsNoAgentConnectedValue = &v
	return s
}

// Number of attempts to request disabled or unsupported ONVIF service
func (s InputMotionDetectorCountersImpl) ErrorsNoServiceCount() *int {
	return s.ErrorsNoServiceCountValue
}

// Number of attempts to request disabled or unsupported ONVIF service
func (s *InputMotionDetectorCountersImpl) SetErrorsNoServiceCount(v int) InputMotionDetectorCounters {
	if s == nil {
		return nil
	}
	s.ErrorsNoServiceCountValue = &v
	return s
}

// Number of not authorized requests
func (s InputMotionDetectorCountersImpl) ErrorsNotAuthorizedCount() *int {
	return s.ErrorsNotAuthorizedCountValue
}

// Number of not authorized requests
func (s *InputMotionDetectorCountersImpl) SetErrorsNotAuthorizedCount(v int) InputMotionDetectorCounters {
	if s == nil {
		return nil
	}
	s.ErrorsNotAuthorizedCountValue = &v
	return s
}

// Number of failed requests because of bad url or network issues.
func (s InputMotionDetectorCountersImpl) ErrorsURLUnreachableCount() *int {
	return s.ErrorsURLUnreachableCountValue
}

// Number of failed requests because of bad url or network issues.
func (s *InputMotionDetectorCountersImpl) SetErrorsURLUnreachableCount(v int) InputMotionDetectorCounters {
	if s == nil {
		return nil
	}
	s.ErrorsURLUnreachableCountValue = &v
	return s
}

// Number of detected motions.
func (s InputMotionDetectorCountersImpl) MotionDetectedCount() *int {
	return s.MotionDetectedCountValue
}

// Number of detected motions.
func (s *InputMotionDetectorCountersImpl) SetMotionDetectedCount(v int) InputMotionDetectorCounters {
	if s == nil {
		return nil
	}
	s.MotionDetectedCountValue = &v
	return s
}

// NewInputPidCounters creates a new InputPidCounters instance
func NewInputPidCounters() InputPidCounters {
	return &InputPidCountersImpl{}
}

// How many PES packets were started not from startcode
func (s InputPidCountersImpl) BrokenPesCount() *int {
	return s.BrokenPesCountValue
}

// How many PES packets were started not from startcode
func (s *InputPidCountersImpl) SetBrokenPesCount(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.BrokenPesCountValue = &v
	return s
}

// How many bytes were discarded due to lack of PES startcode
func (s InputPidCountersImpl) BrokenPesSum() *int {
	return s.BrokenPesSumValue
}

// How many bytes were discarded due to lack of PES startcode
func (s *InputPidCountersImpl) SetBrokenPesSum(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.BrokenPesSumValue = &v
	return s
}

// How many times PTS was less than PCR or previous PTS
func (s InputPidCountersImpl) CorrectedBackwardPts() *int {
	return s.CorrectedBackwardPtsValue
}

// How many times PTS was less than PCR or previous PTS
func (s *InputPidCountersImpl) SetCorrectedBackwardPts(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.CorrectedBackwardPtsValue = &v
	return s
}

// Unhandled crashes inside mpegts decoding process due
func (s InputPidCountersImpl) Crashed() *int {
	return s.CrashedValue
}

// Unhandled crashes inside mpegts decoding process due
func (s *InputPidCountersImpl) SetCrashed(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.CrashedValue = &v
	return s
}

// How many times was discarded too big ES buffer without making a frame of it
func (s InputPidCountersImpl) DiscardedBufferCount() *int {
	return s.DiscardedBufferCountValue
}

// How many times was discarded too big ES buffer without making a frame of it
func (s *InputPidCountersImpl) SetDiscardedBufferCount(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.DiscardedBufferCountValue = &v
	return s
}

// How many bytes were lost due to discarding ES buffer
func (s InputPidCountersImpl) DiscardedBufferSum() *int {
	return s.DiscardedBufferSumValue
}

// How many bytes were lost due to discarding ES buffer
func (s *InputPidCountersImpl) SetDiscardedBufferSum(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.DiscardedBufferSumValue = &v
	return s
}

// Time on this PID jumped back from reference PTS and it was not a roll over zero
func (s InputPidCountersImpl) DtsGoesBackwards() *int {
	return s.DtsGoesBackwardsValue
}

// Time on this PID jumped back from reference PTS and it was not a roll over zero
func (s *InputPidCountersImpl) SetDtsGoesBackwards(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.DtsGoesBackwardsValue = &v
	return s
}

// Time on this PID jumped forward too far away from reference PTS
func (s InputPidCountersImpl) DtsJumpForward() *int {
	return s.DtsJumpForwardValue
}

// Time on this PID jumped forward too far away from reference PTS
func (s *InputPidCountersImpl) SetDtsJumpForward(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.DtsJumpForwardValue = &v
	return s
}

// Packets without payload and adaptation field
func (s InputPidCountersImpl) EmptyPackets() *int {
	return s.EmptyPacketsValue
}

// Packets without payload and adaptation field
func (s *InputPidCountersImpl) SetEmptyPackets(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.EmptyPacketsValue = &v
	return s
}

// Packets with adaptation field larger than packet size
func (s InputPidCountersImpl) ErrorsAdaptationBroken() *int {
	return s.ErrorsAdaptationBrokenValue
}

// Packets with adaptation field larger than packet size
func (s *InputPidCountersImpl) SetErrorsAdaptationBroken(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.ErrorsAdaptationBrokenValue = &v
	return s
}

// How many times pid has been lost
func (s InputPidCountersImpl) ErrorsPidLost() *int {
	return s.ErrorsPidLostValue
}

// How many times pid has been lost
func (s *InputPidCountersImpl) SetErrorsPidLost(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.ErrorsPidLostValue = &v
	return s
}

// how many MPEG-TS packets were received with non-contigious contiuity counters.
// `Continuity_count_error`
// Example: 0
func (s InputPidCountersImpl) ErrorsTSCc() *int {
	return s.ErrorsTSCcValue
}

// how many MPEG-TS packets were received with non-contigious contiuity counters.
// `Continuity_count_error`
// Example: 0
func (s *InputPidCountersImpl) SetErrorsTSCc(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.ErrorsTSCcValue = &v
	return s
}

// how many times PMT was not received after 0,5 seconds
// `PMT_error`
func (s InputPidCountersImpl) ErrorsTSPmt() *int {
	return s.ErrorsTSPmtValue
}

// how many times PMT was not received after 0,5 seconds
// `PMT_error`
func (s *InputPidCountersImpl) SetErrorsTSPmt(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.ErrorsTSPmtValue = &v
	return s
}

// How many times have received PSI entry with broken checksum
// `CRC_error`
func (s InputPidCountersImpl) ErrorsTSPsiChecksum() *int {
	return s.ErrorsTSPsiChecksumValue
}

// How many times have received PSI entry with broken checksum
// `CRC_error`
func (s *InputPidCountersImpl) SetErrorsTSPsiChecksum(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.ErrorsTSPsiChecksumValue = &v
	return s
}

// Amount of scrambled TS packets
func (s InputPidCountersImpl) ErrorsTSScrambled() *int {
	return s.ErrorsTSScrambledValue
}

// Amount of scrambled TS packets
func (s *InputPidCountersImpl) SetErrorsTSScrambled(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.ErrorsTSScrambledValue = &v
	return s
}

// How many MPEG-TS packets with Transport Error Indicator were received
// `Transport_error`, 2.1
func (s InputPidCountersImpl) ErrorsTSTei() *int {
	return s.ErrorsTSTeiValue
}

// How many MPEG-TS packets with Transport Error Indicator were received
// `Transport_error`, 2.1
func (s *InputPidCountersImpl) SetErrorsTSTei(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.ErrorsTSTeiValue = &v
	return s
}

// How many H264(5) NAL fillers were seen in the input
func (s InputPidCountersImpl) FillersCount() *int {
	return s.FillersCountValue
}

// How many H264(5) NAL fillers were seen in the input
func (s *InputPidCountersImpl) SetFillersCount(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.FillersCountValue = &v
	return s
}

// How many bytes were seen in NAL fillers
func (s InputPidCountersImpl) FillersSum() *int {
	return s.FillersSumValue
}

// How many bytes were seen in NAL fillers
func (s *InputPidCountersImpl) SetFillersSum(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.FillersSumValue = &v
	return s
}

// Frame count on this pid
func (s InputPidCountersImpl) Frames() *int {
	return s.FramesValue
}

// Frame count on this pid
func (s *InputPidCountersImpl) SetFrames(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.FramesValue = &v
	return s
}

// How many MPEG-TS packets with 188 bytes on this pid received
func (s InputPidCountersImpl) Packets() *int {
	return s.PacketsValue
}

// How many MPEG-TS packets with 188 bytes on this pid received
func (s *InputPidCountersImpl) SetPackets(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.PacketsValue = &v
	return s
}

// How many PES packets were on the Padding streamId
func (s InputPidCountersImpl) PaddingPesCount() *int {
	return s.PaddingPesCountValue
}

// How many PES packets were on the Padding streamId
func (s *InputPidCountersImpl) SetPaddingPesCount(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.PaddingPesCountValue = &v
	return s
}

// How many bytes were in PES packets on the Padding streamId
func (s InputPidCountersImpl) PaddingPesSum() *int {
	return s.PaddingPesSumValue
}

// How many bytes were in PES packets on the Padding streamId
func (s *InputPidCountersImpl) SetPaddingPesSum(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.PaddingPesSumValue = &v
	return s
}

// If PTS is drifting away from PCR, it can be resynchronized with PCR. This is a resync count
func (s InputPidCountersImpl) PcrResync() *int {
	return s.PcrResyncValue
}

// If PTS is drifting away from PCR, it can be resynchronized with PCR. This is a resync count
func (s *InputPidCountersImpl) SetPcrResync(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.PcrResyncValue = &v
	return s
}

// Related MPEG-TS pid with following problems
func (s InputPidCountersImpl) Pid() int {
	return s.PidValue
}

// Related MPEG-TS pid with following problems
func (s *InputPidCountersImpl) SetPid(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.PidValue = v
	return s
}

// What program does have this pid
func (s InputPidCountersImpl) Pnr() *int {
	return s.PnrValue
}

// What program does have this pid
func (s *InputPidCountersImpl) SetPnr(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.PnrValue = &v
	return s
}

// In case of CC error last frame can be repeated. This is a count of repeated frames
func (s InputPidCountersImpl) RepeatedFrames() *int {
	return s.RepeatedFramesValue
}

// In case of CC error last frame can be repeated. This is a count of repeated frames
func (s *InputPidCountersImpl) SetRepeatedFrames(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.RepeatedFramesValue = &v
	return s
}

// Jumps of timestamps inside a MPEG-TS stream
func (s InputPidCountersImpl) TimeCorrections() *int {
	return s.TimeCorrectionsValue
}

// Jumps of timestamps inside a MPEG-TS stream
func (s *InputPidCountersImpl) SetTimeCorrections(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.TimeCorrectionsValue = &v
	return s
}

// Jump of the PTS was so big from previous, that had to flush all frames and restart parsing
func (s InputPidCountersImpl) TooLargeDtsJump() *int {
	return s.TooLargeDtsJumpValue
}

// Jump of the PTS was so big from previous, that had to flush all frames and restart parsing
func (s *InputPidCountersImpl) SetTooLargeDtsJump(v int) InputPidCounters {
	if s == nil {
		return nil
	}
	s.TooLargeDtsJumpValue = &v
	return s
}

// NewInputRTPCounters creates a new InputRTPCounters instance
func NewInputRTPCounters() InputRTPCounters {
	return &InputRTPCountersImpl{}
}

// How many bytes received for this channel
func (s InputRTPCountersImpl) Bytes() *int {
	return s.BytesValue
}

// How many bytes received for this channel
func (s *InputRTPCountersImpl) SetBytes(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.BytesValue = &v
	return s
}

// RTP channel number
// Example: 0
func (s InputRTPCountersImpl) ChannelID() int {
	return s.ChannelIDValue
}

// RTP channel number
// Example: 0
func (s *InputRTPCountersImpl) SetChannelID(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.ChannelIDValue = v
	return s
}

// Content of the track transmitted in the channel
// Example: video
func (s InputRTPCountersImpl) Content() *string {
	return s.ContentValue
}

// Content of the track transmitted in the channel
// Example: video
func (s *InputRTPCountersImpl) SetContent(v string) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.ContentValue = &v
	return s
}

// Number of NAL units, which `forbidden_zero_bit` is set to one.
func (s InputRTPCountersImpl) DiscardedBrokenNalCount() *int {
	return s.DiscardedBrokenNalCountValue
}

// Number of NAL units, which `forbidden_zero_bit` is set to one.
func (s *InputRTPCountersImpl) SetDiscardedBrokenNalCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.DiscardedBrokenNalCountValue = &v
	return s
}

// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
// This counter shows number of discarded `Fragmentation Units`
func (s InputRTPCountersImpl) DiscardedFuCount() *int {
	return s.DiscardedFuCountValue
}

// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
// This counter shows number of discarded `Fragmentation Units`
func (s *InputRTPCountersImpl) SetDiscardedFuCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.DiscardedFuCountValue = &v
	return s
}

// Number of discarded NAL units.
func (s InputRTPCountersImpl) DiscardedNalCount() *int {
	return s.DiscardedNalCountValue
}

// Number of discarded NAL units.
func (s *InputRTPCountersImpl) SetDiscardedNalCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.DiscardedNalCountValue = &v
	return s
}

// Number of NAL units, which type is not allowed in `non-interleaved packetization mode`.
func (s InputRTPCountersImpl) DiscardedNotAllowedNalCount() *int {
	return s.DiscardedNotAllowedNalCountValue
}

// Number of NAL units, which type is not allowed in `non-interleaved packetization mode`.
func (s *InputRTPCountersImpl) SetDiscardedNotAllowedNalCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.DiscardedNotAllowedNalCountValue = &v
	return s
}

// Number of discarded `SEI` NAL units
func (s InputRTPCountersImpl) DiscardedSeiCount() *int {
	return s.DiscardedSeiCountValue
}

// Number of discarded `SEI` NAL units
func (s *InputRTPCountersImpl) SetDiscardedSeiCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.DiscardedSeiCountValue = &v
	return s
}

// Demultiplexing was done right, but content is broken.
func (s InputRTPCountersImpl) ErrorsBrokenPayload() *int {
	return s.ErrorsBrokenPayloadValue
}

// Demultiplexing was done right, but content is broken.
func (s *InputRTPCountersImpl) SetErrorsBrokenPayload(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.ErrorsBrokenPayloadValue = &v
	return s
}

// Number of frames which dts is same as previous frame dts.
func (s InputRTPCountersImpl) ErrorsDtsStuck() *int {
	return s.ErrorsDtsStuckValue
}

// Number of frames which dts is same as previous frame dts.
func (s *InputRTPCountersImpl) SetErrorsDtsStuck(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.ErrorsDtsStuckValue = &v
	return s
}

// RTP have enough information to tell how many packets were lost
func (s InputRTPCountersImpl) ErrorsLostPackets() *int {
	return s.ErrorsLostPacketsValue
}

// RTP have enough information to tell how many packets were lost
func (s *InputRTPCountersImpl) SetErrorsLostPackets(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.ErrorsLostPacketsValue = &v
	return s
}

// How many frames received for this channel
func (s InputRTPCountersImpl) Frames() *int {
	return s.FramesValue
}

// How many frames received for this channel
func (s *InputRTPCountersImpl) SetFrames(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.FramesValue = &v
	return s
}

// There is workaround to not interrupt `FU` sequence if `end-FU` followed by `middle-FU`.
// This counter shows how many time the workaround was applied.
func (s InputRTPCountersImpl) FuEndThenMiddleWorkaroundCount() *int {
	return s.FuEndThenMiddleWorkaroundCountValue
}

// There is workaround to not interrupt `FU` sequence if `end-FU` followed by `middle-FU`.
// This counter shows how many time the workaround was applied.
func (s *InputRTPCountersImpl) SetFuEndThenMiddleWorkaroundCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.FuEndThenMiddleWorkaroundCountValue = &v
	return s
}

// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
// This counter shows number of `Fragmentation Units` which `Start bit` and `End bit` are set to one in the same `FU` header
func (s InputRTPCountersImpl) FuHasBothStartEndBitsCount() *int {
	return s.FuHasBothStartEndBitsCountValue
}

// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
// This counter shows number of `Fragmentation Units` which `Start bit` and `End bit` are set to one in the same `FU` header
func (s *InputRTPCountersImpl) SetFuHasBothStartEndBitsCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.FuHasBothStartEndBitsCountValue = &v
	return s
}

// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
// `Fragmentation Units` pattern must have a `Start FU`, `End FU` and could have `FUs` between these ones.
// This counter indicates how many times pattern was broken.
func (s InputRTPCountersImpl) FuPatternIsBrokenCount() *int {
	return s.FuPatternIsBrokenCountValue
}

// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
// `Fragmentation Units` pattern must have a `Start FU`, `End FU` and could have `FUs` between these ones.
// This counter indicates how many times pattern was broken.
func (s *InputRTPCountersImpl) SetFuPatternIsBrokenCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.FuPatternIsBrokenCountValue = &v
	return s
}

// NAL deframentation could be interrupted by unexpected NAL or broken/incomplete packet.
// If NAL deframentation is interrupted then incomplete fragment of NAL is not discarded and used in decoding process.
// This counter indicates how many incomplete NALs were used.
func (s InputRTPCountersImpl) IncompleteNalCount() *int {
	return s.IncompleteNalCountValue
}

// NAL deframentation could be interrupted by unexpected NAL or broken/incomplete packet.
// If NAL deframentation is interrupted then incomplete fragment of NAL is not discarded and used in decoding process.
// This counter indicates how many incomplete NALs were used.
func (s *InputRTPCountersImpl) SetIncompleteNalCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.IncompleteNalCountValue = &v
	return s
}

// Number of `SEI` NAL units with bad payload
func (s InputRTPCountersImpl) InvalidSeiPayloadCount() *int {
	return s.InvalidSeiPayloadCountValue
}

// Number of `SEI` NAL units with bad payload
func (s *InputRTPCountersImpl) SetInvalidSeiPayloadCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.InvalidSeiPayloadCountValue = &v
	return s
}

// Number of `SEI` NAL units with invalid size
func (s InputRTPCountersImpl) InvalidSeiSizeCount() *int {
	return s.InvalidSeiSizeCountValue
}

// Number of `SEI` NAL units with invalid size
func (s *InputRTPCountersImpl) SetInvalidSeiSizeCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.InvalidSeiSizeCountValue = &v
	return s
}

// Number of `SEI` NAL units with invalid type
func (s InputRTPCountersImpl) InvalidSeiTypeCount() *int {
	return s.InvalidSeiTypeCountValue
}

// Number of `SEI` NAL units with invalid type
func (s *InputRTPCountersImpl) SetInvalidSeiTypeCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.InvalidSeiTypeCountValue = &v
	return s
}

// Number of RTP packets which marker bit is set to one.
func (s InputRTPCountersImpl) MarkerPacketsCount() *int {
	return s.MarkerPacketsCountValue
}

// Number of RTP packets which marker bit is set to one.
func (s *InputRTPCountersImpl) SetMarkerPacketsCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.MarkerPacketsCountValue = &v
	return s
}

// How many NACK messages are sent for this channel
func (s InputRTPCountersImpl) NackCount() *int {
	return s.NackCountValue
}

// How many NACK messages are sent for this channel
func (s *InputRTPCountersImpl) SetNackCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.NackCountValue = &v
	return s
}

// How many NAL `AGGREGATION` units handled by this decoder.
func (s InputRTPCountersImpl) NalAggregationCount() *int {
	return s.NalAggregationCountValue
}

// How many NAL `AGGREGATION` units handled by this decoder.
func (s *InputRTPCountersImpl) SetNalAggregationCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.NalAggregationCountValue = &v
	return s
}

// How many NAL `AUD` units handled by this decoder.
func (s InputRTPCountersImpl) NalAudCount() *int {
	return s.NalAudCountValue
}

// How many NAL `AUD` units handled by this decoder.
func (s *InputRTPCountersImpl) SetNalAudCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.NalAudCountValue = &v
	return s
}

// How many NAL units handled by this decoder.
func (s InputRTPCountersImpl) NalCount() *int {
	return s.NalCountValue
}

// How many NAL units handled by this decoder.
func (s *InputRTPCountersImpl) SetNalCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.NalCountValue = &v
	return s
}

// How many NAL `FILLER` units handled by this decoder.
func (s InputRTPCountersImpl) NalFillerCount() *int {
	return s.NalFillerCountValue
}

// How many NAL `FILLER` units handled by this decoder.
func (s *InputRTPCountersImpl) SetNalFillerCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.NalFillerCountValue = &v
	return s
}

// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
// This counter shows how many `Fragmentation Units` handled by this decoder.
func (s InputRTPCountersImpl) NalFuCount() *int {
	return s.NalFuCountValue
}

// `Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.
// `H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.
// This counter shows how many `Fragmentation Units` handled by this decoder.
func (s *InputRTPCountersImpl) SetNalFuCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.NalFuCountValue = &v
	return s
}

// How many NAL `IDR` units handled by this decoder.
func (s InputRTPCountersImpl) NalIdrCount() *int {
	return s.NalIdrCountValue
}

// How many NAL `IDR` units handled by this decoder.
func (s *InputRTPCountersImpl) SetNalIdrCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.NalIdrCountValue = &v
	return s
}

// How many other NAL units handled by this decoder.
func (s InputRTPCountersImpl) NalOtherCount() *int {
	return s.NalOtherCountValue
}

// How many other NAL units handled by this decoder.
func (s *InputRTPCountersImpl) SetNalOtherCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.NalOtherCountValue = &v
	return s
}

// How many NAL `PPS` units handled by this decoder.
func (s InputRTPCountersImpl) NalPpsCount() *int {
	return s.NalPpsCountValue
}

// How many NAL `PPS` units handled by this decoder.
func (s *InputRTPCountersImpl) SetNalPpsCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.NalPpsCountValue = &v
	return s
}

// How many NAL `SEI` units handled by this decoder.
func (s InputRTPCountersImpl) NalSeiCount() *int {
	return s.NalSeiCountValue
}

// How many NAL `SEI` units handled by this decoder.
func (s *InputRTPCountersImpl) SetNalSeiCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.NalSeiCountValue = &v
	return s
}

// How many NAL `SINGLE` units handled by this decoder.
func (s InputRTPCountersImpl) NalSingleCount() *int {
	return s.NalSingleCountValue
}

// How many NAL `SINGLE` units handled by this decoder.
func (s *InputRTPCountersImpl) SetNalSingleCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.NalSingleCountValue = &v
	return s
}

// How many NAL `SLICE` units handled by this decoder.
func (s InputRTPCountersImpl) NalSliceCount() *int {
	return s.NalSliceCountValue
}

// How many NAL `SLICE` units handled by this decoder.
func (s *InputRTPCountersImpl) SetNalSliceCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.NalSliceCountValue = &v
	return s
}

// How many NAL `SPS` units handled by this decoder.
func (s InputRTPCountersImpl) NalSpsCount() *int {
	return s.NalSpsCountValue
}

// How many NAL `SPS` units handled by this decoder.
func (s *InputRTPCountersImpl) SetNalSpsCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.NalSpsCountValue = &v
	return s
}

// How many NAL `STAP_A` units handled by this decoder.
func (s InputRTPCountersImpl) NalStapACount() *int {
	return s.NalStapACountValue
}

// How many NAL `STAP_A` units handled by this decoder.
func (s *InputRTPCountersImpl) SetNalStapACount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.NalStapACountValue = &v
	return s
}

// How many NAL `VPS` units handled by this decoder.
func (s InputRTPCountersImpl) NalVpsCount() *int {
	return s.NalVpsCountValue
}

// How many NAL `VPS` units handled by this decoder.
func (s *InputRTPCountersImpl) SetNalVpsCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.NalVpsCountValue = &v
	return s
}

// If no marker bit packet is received after 400 RTP packets then decoder switches to `no_marker_mode` and
// makes frame on each timecode change.
// This flag shows if decoder works in `no_marker_mode`.
func (s InputRTPCountersImpl) NoMarkerModeFlag() *bool {
	return s.NoMarkerModeFlagValue
}

// If no marker bit packet is received after 400 RTP packets then decoder switches to `no_marker_mode` and
// makes frame on each timecode change.
// This flag shows if decoder works in `no_marker_mode`.
func (s *InputRTPCountersImpl) SetNoMarkerModeFlag(v bool) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.NoMarkerModeFlagValue = &v
	return s
}

// Number of rtp packets rejected due to wrong payload type
func (s InputRTPCountersImpl) PtRejectCount() *int {
	return s.PtRejectCountValue
}

// Number of rtp packets rejected due to wrong payload type
func (s *InputRTPCountersImpl) SetPtRejectCount(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.PtRejectCountValue = &v
	return s
}

// Total size of rejected packets due to wrong payload type (pt_reject_count) rtp packets
func (s InputRTPCountersImpl) PtRejectSum() *int {
	return s.PtRejectSumValue
}

// Total size of rejected packets due to wrong payload type (pt_reject_count) rtp packets
func (s *InputRTPCountersImpl) SetPtRejectSum(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.PtRejectSumValue = &v
	return s
}

// How many RTCP packets received for this channel
func (s InputRTPCountersImpl) RtcpPackets() *int {
	return s.RtcpPacketsValue
}

// How many RTCP packets received for this channel
func (s *InputRTPCountersImpl) SetRtcpPackets(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.RtcpPacketsValue = &v
	return s
}

// How many RTP packets received for this channel
func (s InputRTPCountersImpl) RTPPackets() *int {
	return s.RTPPacketsValue
}

// How many RTP packets received for this channel
func (s *InputRTPCountersImpl) SetRTPPackets(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.RTPPacketsValue = &v
	return s
}

// Sender wallclock deviation from server time in ms. Positive value means that sender time is ahead of server time.
func (s InputRTPCountersImpl) SenderClockDeviation() *int {
	return s.SenderClockDeviationValue
}

// Sender wallclock deviation from server time in ms. Positive value means that sender time is ahead of server time.
func (s *InputRTPCountersImpl) SetSenderClockDeviation(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.SenderClockDeviationValue = &v
	return s
}

// Number of rtcp SR packets which `RTP timestamp` is equal to the previous rtcp SR packet `RTP timestamp`.
func (s InputRTPCountersImpl) SrTSStuck() *int {
	return s.SrTSStuckValue
}

// Number of rtcp SR packets which `RTP timestamp` is equal to the previous rtcp SR packet `RTP timestamp`.
func (s *InputRTPCountersImpl) SetSrTSStuck(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.SrTSStuckValue = &v
	return s
}

// Time on this channel is jumped back from reference wallclock.
func (s InputRTPCountersImpl) TSGoesBackwards() *int {
	return s.TSGoesBackwardsValue
}

// Time on this channel is jumped back from reference wallclock.
func (s *InputRTPCountersImpl) SetTSGoesBackwards(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.TSGoesBackwardsValue = &v
	return s
}

// Time on this channel is jumped forward from reference wallclock.
func (s InputRTPCountersImpl) TSJumpForward() *int {
	return s.TSJumpForwardValue
}

// Time on this channel is jumped forward from reference wallclock.
func (s *InputRTPCountersImpl) SetTSJumpForward(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.TSJumpForwardValue = &v
	return s
}

// https://datatracker.ietf.org/doc/html/rfc6184#section-4.1
// access unit: A set of NAL units always containing a primary coded picture.  In addition to the primary coded
// picture, an access unit may also contain one or more redundant coded pictures or other NAL units not containing
// slices or slice data partitions of a coded picture.  The decoding of an access unit always results in a
// decoded picture.
// There is `marker bit` in RTP packet which is set for the very last packet of the access unit indicated by the RTP timestamp.
// It is protocol violation if received RTP packet has the same timestamp as previous marker bit packet.
// This counter is a number of RTP packets which `RTP timestamp` is equal to previous RTP marker bit packet.
func (s InputRTPCountersImpl) TSStuck() *int {
	return s.TSStuckValue
}

// https://datatracker.ietf.org/doc/html/rfc6184#section-4.1
// access unit: A set of NAL units always containing a primary coded picture.  In addition to the primary coded
// picture, an access unit may also contain one or more redundant coded pictures or other NAL units not containing
// slices or slice data partitions of a coded picture.  The decoding of an access unit always results in a
// decoded picture.
// There is `marker bit` in RTP packet which is set for the very last packet of the access unit indicated by the RTP timestamp.
// It is protocol violation if received RTP packet has the same timestamp as previous marker bit packet.
// This counter is a number of RTP packets which `RTP timestamp` is equal to previous RTP marker bit packet.
func (s *InputRTPCountersImpl) SetTSStuck(v int) InputRTPCounters {
	if s == nil {
		return nil
	}
	s.TSStuckValue = &v
	return s
}

// NewInputSdiCounters creates a new InputSdiCounters instance
func NewInputSdiCounters() InputSdiCounters {
	return &InputSdiCountersImpl{}
}

// Gauge of average duration of incoming frame calculated in real time.
func (s InputSdiCountersImpl) AvgRecvDuration() *int {
	return s.AvgRecvDurationValue
}

// Gauge of average duration of incoming frame calculated in real time.
func (s *InputSdiCountersImpl) SetAvgRecvDuration(v int) InputSdiCounters {
	if s == nil {
		return nil
	}
	s.AvgRecvDurationValue = &v
	return s
}

// Frames injected to fix client-side SDI stream drift.
func (s InputSdiCountersImpl) CompensatedFrames() *int {
	return s.CompensatedFramesValue
}

// Frames injected to fix client-side SDI stream drift.
func (s *InputSdiCountersImpl) SetCompensatedFrames(v int) InputSdiCounters {
	if s == nil {
		return nil
	}
	s.CompensatedFramesValue = &v
	return s
}

// Counter of configured audio sdi channels without samples or non valid.
func (s InputSdiCountersImpl) ErrorLostAudio() *int {
	return s.ErrorLostAudioValue
}

// Counter of configured audio sdi channels without samples or non valid.
func (s *InputSdiCountersImpl) SetErrorLostAudio(v int) InputSdiCounters {
	if s == nil {
		return nil
	}
	s.ErrorLostAudioValue = &v
	return s
}

// The frame was dropped due to too high CPU load.
func (s InputSdiCountersImpl) ErrorsCpuStall() *int {
	return s.ErrorsCpuStallValue
}

// The frame was dropped due to too high CPU load.
func (s *InputSdiCountersImpl) SetErrorsCpuStall(v int) InputSdiCounters {
	if s == nil {
		return nil
	}
	s.ErrorsCpuStallValue = &v
	return s
}

// Frame data is duplicated from previous frame because the input was too slow.
func (s InputSdiCountersImpl) ErrorsDuplicate() *int {
	return s.ErrorsDuplicateValue
}

// Frame data is duplicated from previous frame because the input was too slow.
func (s *InputSdiCountersImpl) SetErrorsDuplicate(v int) InputSdiCounters {
	if s == nil {
		return nil
	}
	s.ErrorsDuplicateValue = &v
	return s
}

// Frames dropped due to 'No signal'.
func (s InputSdiCountersImpl) ErrorsNoSignal() *int {
	return s.ErrorsNoSignalValue
}

// Frames dropped due to 'No signal'.
func (s *InputSdiCountersImpl) SetErrorsNoSignal(v int) InputSdiCounters {
	if s == nil {
		return nil
	}
	s.ErrorsNoSignalValue = &v
	return s
}

// Frame time is the same as the previous frame.
func (s InputSdiCountersImpl) ErrorsTSDuplicate() *int {
	return s.ErrorsTSDuplicateValue
}

// Frame time is the same as the previous frame.
func (s *InputSdiCountersImpl) SetErrorsTSDuplicate(v int) InputSdiCounters {
	if s == nil {
		return nil
	}
	s.ErrorsTSDuplicateValue = &v
	return s
}

// Gauge of maximum deviation from the estimated frame duration.
func (s InputSdiCountersImpl) PeakDurationDeviation() *int {
	return s.PeakDurationDeviationValue
}

// Gauge of maximum deviation from the estimated frame duration.
func (s *InputSdiCountersImpl) SetPeakDurationDeviation(v int) InputSdiCounters {
	if s == nil {
		return nil
	}
	s.PeakDurationDeviationValue = &v
	return s
}

// NewInputSrtCounters creates a new InputSrtCounters instance
func NewInputSrtCounters() InputSrtCounters {
	return &InputSrtCountersImpl{}
}

// How many SRT packets were dropped by various reasons
func (s InputSrtCountersImpl) ErrorDroppedPackets() *int {
	return s.ErrorDroppedPacketsValue
}

// How many SRT packets were dropped by various reasons
func (s *InputSrtCountersImpl) SetErrorDroppedPackets(v int) InputSrtCounters {
	if s == nil {
		return nil
	}
	s.ErrorDroppedPacketsValue = &v
	return s
}

// How many SRT packets were lost
func (s InputSrtCountersImpl) ErrorLostPackets() *int {
	return s.ErrorLostPacketsValue
}

// How many SRT packets were lost
func (s *InputSrtCountersImpl) SetErrorLostPackets(v int) InputSrtCounters {
	if s == nil {
		return nil
	}
	s.ErrorLostPacketsValue = &v
	return s
}

// Receiver buffering delay
func (s InputSrtCountersImpl) Latency() *int {
	return s.LatencyValue
}

// Receiver buffering delay
func (s *InputSrtCountersImpl) SetLatency(v int) InputSrtCounters {
	if s == nil {
		return nil
	}
	s.LatencyValue = &v
	return s
}

// Total incoming SRT packets counter
func (s InputSrtCountersImpl) Packets() *int {
	return s.PacketsValue
}

// Total incoming SRT packets counter
func (s *InputSrtCountersImpl) SetPackets(v int) InputSrtCounters {
	if s == nil {
		return nil
	}
	s.PacketsValue = &v
	return s
}

// How many packets were retransmitted
func (s InputSrtCountersImpl) RetransmittedPackets() *int {
	return s.RetransmittedPacketsValue
}

// How many packets were retransmitted
func (s *InputSrtCountersImpl) SetRetransmittedPackets(v int) InputSrtCounters {
	if s == nil {
		return nil
	}
	s.RetransmittedPacketsValue = &v
	return s
}

// Round-trip time
func (s InputSrtCountersImpl) Rtt() *int {
	return s.RttValue
}

// Round-trip time
func (s *InputSrtCountersImpl) SetRtt(v int) InputSrtCounters {
	if s == nil {
		return nil
	}
	s.RttValue = &v
	return s
}

// NewInputStats creates a new InputStats instance
func NewInputStats() InputStats {
	return &InputStatsImpl{}
}

// Whether this input is selected as active for the stream.
// Example: true
func (s InputStatsImpl) Active() *bool {
	return s.ActiveValue
}

// Whether this input is selected as active for the stream.
// Example: true
func (s *InputStatsImpl) SetActive(v bool) InputStats {
	if s == nil {
		return nil
	}
	s.ActiveValue = &v
	return s
}

// How many Ad markers passed to this stream from the inputs.
func (s InputStatsImpl) AdSplicesIngested() *int {
	return s.AdSplicesIngestedValue
}

// How many Ad markers passed to this stream from the inputs.
func (s *InputStatsImpl) SetAdSplicesIngested(v int) InputStats {
	if s == nil {
		return nil
	}
	s.AdSplicesIngestedValue = &v
	return s
}

// How many Ad markers inserted to this stream by user.
func (s InputStatsImpl) AdSplicesInserted() *int {
	return s.AdSplicesInsertedValue
}

// How many Ad markers inserted to this stream by user.
func (s *InputStatsImpl) SetAdSplicesInserted(v int) InputStats {
	if s == nil {
		return nil
	}
	s.AdSplicesInsertedValue = &v
	return s
}

func (s InputStatsImpl) Agent() InputAgentCounters {
	return s.AgentValue
}

func (s *InputStatsImpl) SetAgent(v InputAgentCounters) InputStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputAgentCountersImpl); ok {
		s.AgentValue = impl
	}
	return s
}

// Number of bytes received by this stream from live sources.
// It will be counted before transcoding and will sum all inputs working together.
// Format: bytes (bytes)
func (s InputStatsImpl) Bytes() *Bytes {
	return s.BytesValue
}

// Number of bytes received by this stream from live sources.
// It will be counted before transcoding and will sum all inputs working together.
// Format: bytes (bytes)
func (s *InputStatsImpl) SetBytes(v Bytes) InputStats {
	if s == nil {
		return nil
	}
	s.BytesValue = &v
	return s
}

// Number of bytes received by this stream when downloading from remote DVR.
// Format: bytes (bytes)
func (s InputStatsImpl) BytesDvr() *Bytes {
	return s.BytesDvrValue
}

// Number of bytes received by this stream when downloading from remote DVR.
// Format: bytes (bytes)
func (s *InputStatsImpl) SetBytesDvr(v Bytes) InputStats {
	if s == nil {
		return nil
	}
	s.BytesDvrValue = &v
	return s
}

// Indicates that the stream sources have different track sets, which may cause switching problems. The list of tracks to be compared is obtained only when the sources are checked or started, until then the stream is considered normal.
func (s InputStatsImpl) DivergentInputs() *bool {
	return s.DivergentInputsValue
}

// Indicates that the stream sources have different track sets, which may cause switching problems. The list of tracks to be compared is obtained only when the sources are checked or started, until then the stream is considered normal.
func (s *InputStatsImpl) SetDivergentInputs(v bool) InputStats {
	if s == nil {
		return nil
	}
	s.DivergentInputsValue = &v
	return s
}

// Information about DVR that this input has
func (s InputStatsImpl) DvrInfo() DvrInfo {
	return s.DvrInfoValue
}

// Information about DVR that this input has
func (s *InputStatsImpl) SetDvrInfo(v DvrInfo) InputStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*DvrInfoImpl); ok {
		s.DvrInfoValue = impl
	}
	return s
}

// Sum of all other specific errors in the last minute
// Example: 0
func (s InputStatsImpl) ErrorRate() *int {
	return s.ErrorRateValue
}

// Sum of all other specific errors in the last minute
// Example: 0
func (s *InputStatsImpl) SetErrorRate(v int) InputStats {
	if s == nil {
		return nil
	}
	s.ErrorRateValue = &v
	return s
}

// Sum of all other specific errors. Can be used for triggering alert on any error
// Example: 0
func (s InputStatsImpl) Errors() *int {
	return s.ErrorsValue
}

// Sum of all other specific errors. Can be used for triggering alert on any error
// Example: 0
func (s *InputStatsImpl) SetErrors(v int) InputStats {
	if s == nil {
		return nil
	}
	s.ErrorsValue = &v
	return s
}

// How many times we've got 403 (eaccess).
func (s InputStatsImpl) Errors403() *int {
	return s.Errors403Value
}

// How many times we've got 403 (eaccess).
func (s *InputStatsImpl) SetErrors403(v int) InputStats {
	if s == nil {
		return nil
	}
	s.Errors403Value = &v
	return s
}

// How many times we've got 404 (enoent).
func (s InputStatsImpl) Errors404() *int {
	return s.Errors404Value
}

// How many times we've got 404 (enoent).
func (s *InputStatsImpl) SetErrors404(v int) InputStats {
	if s == nil {
		return nil
	}
	s.Errors404Value = &v
	return s
}

// How many times we've got 500 (backend error).
func (s InputStatsImpl) Errors500() *int {
	return s.Errors500Value
}

// How many times we've got 500 (backend error).
func (s *InputStatsImpl) SetErrors500(v int) InputStats {
	if s == nil {
		return nil
	}
	s.Errors500Value = &v
	return s
}

// Demultiplexing was done right, but content is broken.
func (s InputStatsImpl) ErrorsBrokenPayload() *int {
	return s.ErrorsBrokenPayloadValue
}

// Demultiplexing was done right, but content is broken.
func (s *InputStatsImpl) SetErrorsBrokenPayload(v int) InputStats {
	if s == nil {
		return nil
	}
	s.ErrorsBrokenPayloadValue = &v
	return s
}

// How many times input was restarted due to internal crash.
// This may happen due to unhandled input.
func (s InputStatsImpl) ErrorsCrashed() *int {
	return s.ErrorsCrashedValue
}

// How many times input was restarted due to internal crash.
// This may happen due to unhandled input.
func (s *InputStatsImpl) SetErrorsCrashed(v int) InputStats {
	if s == nil {
		return nil
	}
	s.ErrorsCrashedValue = &v
	return s
}

// Decoder reset count due to abnormal DTS change. Can happen in MPEG-TS, RTP.
func (s InputStatsImpl) ErrorsDecoderReset() *int {
	return s.ErrorsDecoderResetValue
}

// Decoder reset count due to abnormal DTS change. Can happen in MPEG-TS, RTP.
func (s *InputStatsImpl) SetErrorsDecoderReset(v int) InputStats {
	if s == nil {
		return nil
	}
	s.ErrorsDecoderResetValue = &v
	return s
}

// This can be used as a `TS_sync_loss` - how many times MPEG-TS sync was lost.
// Also this counter refers to RTSP desync, when camera starts dropping TCP data and
// we have to find packet boundaries.
// Here we write count of such resynchronizations.
func (s InputStatsImpl) ErrorsDesync() *int {
	return s.ErrorsDesyncValue
}

// This can be used as a `TS_sync_loss` - how many times MPEG-TS sync was lost.
// Also this counter refers to RTSP desync, when camera starts dropping TCP data and
// we have to find packet boundaries.
// Here we write count of such resynchronizations.
func (s *InputStatsImpl) SetErrorsDesync(v int) InputStats {
	if s == nil {
		return nil
	}
	s.ErrorsDesyncValue = &v
	return s
}

// Dropped frames count due timestamp adjustment.
func (s InputStatsImpl) ErrorsDroppedFrames() *int {
	return s.ErrorsDroppedFramesValue
}

// Dropped frames count due timestamp adjustment.
func (s *InputStatsImpl) SetErrorsDroppedFrames(v int) InputStats {
	if s == nil {
		return nil
	}
	s.ErrorsDroppedFramesValue = &v
	return s
}

// RTP, MPEG-TS or other protocols have enough information to tell how many packets were lost
func (s InputStatsImpl) ErrorsLostPackets() *int {
	return s.ErrorsLostPacketsValue
}

// RTP, MPEG-TS or other protocols have enough information to tell how many packets were lost
func (s *InputStatsImpl) SetErrorsLostPackets(v int) InputStats {
	if s == nil {
		return nil
	}
	s.ErrorsLostPacketsValue = &v
	return s
}

// how many times PAT was missing during 0,5 seconds or pid 0 misses PAT
// `PAT_error`
func (s InputStatsImpl) ErrorsTSPat() *int {
	return s.ErrorsTSPatValue
}

// how many times PAT was missing during 0,5 seconds or pid 0 misses PAT
// `PAT_error`
func (s *InputStatsImpl) SetErrorsTSPat(v int) InputStats {
	if s == nil {
		return nil
	}
	s.ErrorsTSPatValue = &v
	return s
}

// How many times have received PAT that was missing required service (program)
func (s InputStatsImpl) ErrorsTSServiceLost() *int {
	return s.ErrorsTSServiceLostValue
}

// How many times have received PAT that was missing required service (program)
func (s *InputStatsImpl) SetErrorsTSServiceLost(v int) InputStats {
	if s == nil {
		return nil
	}
	s.ErrorsTSServiceLostValue = &v
	return s
}

// Number of connection restarts to fix ts_stuck issue. Can happen in RTSP.
func (s InputStatsImpl) ErrorsTSStuckRestarts() *int {
	return s.ErrorsTSStuckRestartsValue
}

// Number of connection restarts to fix ts_stuck issue. Can happen in RTSP.
func (s *InputStatsImpl) SetErrorsTSStuckRestarts(v int) InputStats {
	if s == nil {
		return nil
	}
	s.ErrorsTSStuckRestartsValue = &v
	return s
}

// Number of frames passed to this stream from the inputs.
func (s InputStatsImpl) Frames() *int {
	return s.FramesValue
}

// Number of frames passed to this stream from the inputs.
func (s *InputStatsImpl) SetFrames(v int) InputStats {
	if s == nil {
		return nil
	}
	s.FramesValue = &v
	return s
}

// Aggregated: how many times this stream has switched between different inputs.
// Individual input: number of times switched to this input.
func (s InputStatsImpl) InputSwitches() *int {
	return s.InputSwitchesValue
}

// Aggregated: how many times this stream has switched between different inputs.
// Individual input: number of times switched to this input.
func (s *InputStatsImpl) SetInputSwitches(v int) InputStats {
	if s == nil {
		return nil
	}
	s.InputSwitchesValue = &v
	return s
}

// Number of secondary inputs that have some problems.
// Example: 0
func (s InputStatsImpl) InvalidSecondaryInputs() *int {
	return s.InvalidSecondaryInputsValue
}

// Number of secondary inputs that have some problems.
// Example: 0
func (s *InputStatsImpl) SetInvalidSecondaryInputs(v int) InputStats {
	if s == nil {
		return nil
	}
	s.InvalidSecondaryInputsValue = &v
	return s
}

// IP address of the connected peer.
// Example: 172.16.25.73
func (s InputStatsImpl) IP() *string {
	return s.IPValue
}

// IP address of the connected peer.
// Example: 172.16.25.73
func (s *InputStatsImpl) SetIP(v string) InputStats {
	if s == nil {
		return nil
	}
	s.IPValue = &v
	return s
}

// Technical description of the input content.
func (s InputStatsImpl) MediaInfo() MediaInfo {
	return s.MediaInfoValue
}

// Technical description of the input content.
func (s *InputStatsImpl) SetMediaInfo(v MediaInfo) InputStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*MediaInfoImpl); ok {
		s.MediaInfoValue = impl
	}
	return s
}

// Indicates, how often does media_info changes
func (s InputStatsImpl) MediaInfoChanges() *int {
	return s.MediaInfoChangesValue
}

// Indicates, how often does media_info changes
func (s *InputStatsImpl) SetMediaInfoChanges(v int) InputStats {
	if s == nil {
		return nil
	}
	s.MediaInfoChangesValue = &v
	return s
}

func (s InputStatsImpl) MotionDetector() InputMotionDetectorCounters {
	return s.MotionDetectorValue
}

func (s *InputStatsImpl) SetMotionDetector(v InputMotionDetectorCounters) InputStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputMotionDetectorCountersImpl); ok {
		s.MotionDetectorValue = impl
	}
	return s
}

// How many seconds has this stream had no frames.
// Format: seconds (seconds)
func (s InputStatsImpl) NumSecNoData() *Seconds {
	return s.NumSecNoDataValue
}

// How many seconds has this stream had no frames.
// Format: seconds (seconds)
func (s *InputStatsImpl) SetNumSecNoData(v Seconds) InputStats {
	if s == nil {
		return nil
	}
	s.NumSecNoDataValue = &v
	return s
}

// How many seconds has this stream played from primary input.
// Format: seconds (seconds)
func (s InputStatsImpl) NumSecOnPrimaryInput() *Seconds {
	return s.NumSecOnPrimaryInputValue
}

// How many seconds has this stream played from primary input.
// Format: seconds (seconds)
func (s *InputStatsImpl) SetNumSecOnPrimaryInput(v Seconds) InputStats {
	if s == nil {
		return nil
	}
	s.NumSecOnPrimaryInputValue = &v
	return s
}

// How many seconds has this stream played from secondary inputs.
// Format: seconds (seconds)
func (s InputStatsImpl) NumSecOnSecondaryInput() *Seconds {
	return s.NumSecOnSecondaryInputValue
}

// How many seconds has this stream played from secondary inputs.
// Format: seconds (seconds)
func (s *InputStatsImpl) SetNumSecOnSecondaryInput(v Seconds) InputStats {
	if s == nil {
		return nil
	}
	s.NumSecOnSecondaryInputValue = &v
	return s
}

// The time when this session was created.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s InputStatsImpl) OpenedAt() *UtcMs {
	return s.OpenedAtValue
}

// The time when this session was created.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s *InputStatsImpl) SetOpenedAt(v UtcMs) InputStats {
	if s == nil {
		return nil
	}
	s.OpenedAtValue = &v
	return s
}

// Per pid statistics calculated for MPEG-TS input
func (s InputStatsImpl) Pids() []InputPidCounters {
	if s.PidsValue == nil {
		return nil
	}
	result := make([]InputPidCounters, len(s.PidsValue))
	for i, item := range s.PidsValue {
		result[i] = item
	}
	return result
}

// Per pid statistics calculated for MPEG-TS input
func (s *InputStatsImpl) SetPids(v []InputPidCounters) InputStats {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*InputPidCountersImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*InputPidCountersImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.PidsValue = impl
	}
	return s
}

// Protocol used for the data transmission in the session.
// Example: dash
func (s InputStatsImpl) Proto() *Protocol {
	return s.ProtoValue
}

// Protocol used for the data transmission in the session.
// Example: dash
func (s *InputStatsImpl) SetProto(v Protocol) InputStats {
	if s == nil {
		return nil
	}
	s.ProtoValue = &v
	return s
}

// Source may send frames not in the order they should be played. It will be catched and reordered.
// This counter indicates how many times did it happened.
func (s InputStatsImpl) ReorderCount() *int {
	return s.ReorderCountValue
}

// Source may send frames not in the order they should be played. It will be catched and reordered.
// This counter indicates how many times did it happened.
func (s *InputStatsImpl) SetReorderCount(v int) InputStats {
	if s == nil {
		return nil
	}
	s.ReorderCountValue = &v
	return s
}

// Source may send frames timestamps faster or slower than realtime.
// Live stream will catch it and resync. This counter indicates how many times did it happened.
func (s InputStatsImpl) ResyncCountDrift() *int {
	return s.ResyncCountDriftValue
}

// Source may send frames timestamps faster or slower than realtime.
// Live stream will catch it and resync. This counter indicates how many times did it happened.
func (s *InputStatsImpl) SetResyncCountDrift(v int) InputStats {
	if s == nil {
		return nil
	}
	s.ResyncCountDriftValue = &v
	return s
}

// Source may change timestamps without any signalling. This counter indicates how bad is the source
func (s InputStatsImpl) ResyncCountJump() *int {
	return s.ResyncCountJumpValue
}

// Source may change timestamps without any signalling. This counter indicates how bad is the source
func (s *InputStatsImpl) SetResyncCountJump(v int) InputStats {
	if s == nil {
		return nil
	}
	s.ResyncCountJumpValue = &v
	return s
}

// Stream timestamps are synchronized with real time. This counter tells, how many times
// it was syncronized after source reconnect.
func (s InputStatsImpl) ResyncCountNormal() *int {
	return s.ResyncCountNormalValue
}

// Stream timestamps are synchronized with real time. This counter tells, how many times
// it was syncronized after source reconnect.
func (s *InputStatsImpl) SetResyncCountNormal(v int) InputStats {
	if s == nil {
		return nil
	}
	s.ResyncCountNormalValue = &v
	return s
}

// How many times has this stream retried to connect to source
func (s InputStatsImpl) Retries() *int {
	return s.RetriesValue
}

// How many times has this stream retried to connect to source
func (s *InputStatsImpl) SetRetries(v int) InputStats {
	if s == nil {
		return nil
	}
	s.RetriesValue = &v
	return s
}

// Per channel statistics calculated for RTP input
func (s InputStatsImpl) RTPChannels() []InputRTPCounters {
	if s.RTPChannelsValue == nil {
		return nil
	}
	result := make([]InputRTPCounters, len(s.RTPChannelsValue))
	for i, item := range s.RTPChannelsValue {
		result[i] = item
	}
	return result
}

// Per channel statistics calculated for RTP input
func (s *InputStatsImpl) SetRTPChannels(v []InputRTPCounters) InputStats {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*InputRTPCountersImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*InputRTPCountersImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.RTPChannelsValue = impl
	}
	return s
}

func (s InputStatsImpl) Sdi() InputSdiCounters {
	return s.SdiValue
}

func (s *InputStatsImpl) SetSdi(v InputSdiCounters) InputStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputSdiCountersImpl); ok {
		s.SdiValue = impl
	}
	return s
}

func (s InputStatsImpl) Srt() InputSrtCounters {
	return s.SrtValue
}

func (s *InputStatsImpl) SetSrt(v InputSrtCounters) InputStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputSrtCountersImpl); ok {
		s.SrtValue = impl
	}
	return s
}

// The time period during which no frames were received from the stream's input.
// Format: ticks (ticks)
// Example: 1284
func (s InputStatsImpl) TSDelay() *Ticks {
	return s.TSDelayValue
}

// The time period during which no frames were received from the stream's input.
// Format: ticks (ticks)
// Example: 1284
func (s *InputStatsImpl) SetTSDelay(v Ticks) InputStats {
	if s == nil {
		return nil
	}
	s.TSDelayValue = &v
	return s
}

// The time period during which no frames were received per each track according to `media_info`
// Example: [1284]
func (s InputStatsImpl) TSDelayPerTracks() []Ticks {
	return s.TSDelayPerTracksValue
}

// The time period during which no frames were received per each track according to `media_info`
// Example: [1284]
func (s *InputStatsImpl) SetTSDelayPerTracks(v []Ticks) InputStats {
	if s == nil {
		return nil
	}
	s.TSDelayPerTracksValue = v
	return s
}

// Deprecated field. Will be deleted at 25.03
// Final URL after redirects.
// Deprecated because was never actually used.
// Format: url (url)
// Example: udp://239.0.0.1:1234
func (s InputStatsImpl) URL() *URL {
	return s.URLValue
}

// Deprecated field. Will be deleted at 25.03
// Final URL after redirects.
// Deprecated because was never actually used.
// Format: url (url)
// Example: udp://239.0.0.1:1234
func (s *InputStatsImpl) SetURL(v URL) InputStats {
	if s == nil {
		return nil
	}
	s.URLValue = &v
	return s
}

// Client's user agent for selected protocol.
// Example: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML. like Gecko) Chrome/90.0.4430.72 Safari/537.36
func (s InputStatsImpl) UserAgent() *string {
	return s.UserAgentValue
}

// Client's user agent for selected protocol.
// Example: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML. like Gecko) Chrome/90.0.4430.72 Safari/537.36
func (s *InputStatsImpl) SetUserAgent(v string) InputStats {
	if s == nil {
		return nil
	}
	s.UserAgentValue = &v
	return s
}

// Number of secondary inputs that have no problems.
// Example: 2
func (s InputStatsImpl) ValidSecondaryInputs() *int {
	return s.ValidSecondaryInputsValue
}

// Number of secondary inputs that have no problems.
// Example: 2
func (s *InputStatsImpl) SetValidSecondaryInputs(v int) InputStats {
	if s == nil {
		return nil
	}
	s.ValidSecondaryInputsValue = &v
	return s
}

// NewLoginInfoAdditional creates a new LoginInfoAdditional instance
func NewLoginInfoAdditional() LoginInfoAdditional {
	return &LoginInfoAdditionalImpl{}
}

// A JWT token with a limited lifetime duration. JWT algorithm is RS256.
// Example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
func (s LoginInfoAdditionalImpl) AccessToken() *string {
	return s.AccessTokenValue
}

// A JWT token with a limited lifetime duration. JWT algorithm is RS256.
// Example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
func (s *LoginInfoAdditionalImpl) SetAccessToken(v string) LoginInfoAdditional {
	if s == nil {
		return nil
	}
	s.AccessTokenValue = &v
	return s
}

// A token used to get a new access_token after expiration.
// It works with `/login` request only.
// Example: 3637e790-5530-11ed-bdc3-0242ac120002
func (s LoginInfoAdditionalImpl) RefreshToken() *string {
	return s.RefreshTokenValue
}

// A token used to get a new access_token after expiration.
// It works with `/login` request only.
// Example: 3637e790-5530-11ed-bdc3-0242ac120002
func (s *LoginInfoAdditionalImpl) SetRefreshToken(v string) LoginInfoAdditional {
	if s == nil {
		return nil
	}
	s.RefreshTokenValue = &v
	return s
}

// NewLoginInfoBase creates a new LoginInfoBase instance
func NewLoginInfoBase() LoginInfoBase {
	return &LoginInfoBaseImpl{}
}

// A JWT token with a limited lifetime duration. JWT algorithm is RS256.
// Example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
func (s LoginInfoBaseImpl) AccessToken() *string {
	return s.AccessTokenValue
}

// A JWT token with a limited lifetime duration. JWT algorithm is RS256.
// Example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
func (s *LoginInfoBaseImpl) SetAccessToken(v string) LoginInfoBase {
	if s == nil {
		return nil
	}
	s.AccessTokenValue = &v
	return s
}

// A token used to get a new access_token after expiration.
// It works with `/login` request only.
// Example: 3637e790-5530-11ed-bdc3-0242ac120002
func (s LoginInfoBaseImpl) RefreshToken() *string {
	return s.RefreshTokenValue
}

// A token used to get a new access_token after expiration.
// It works with `/login` request only.
// Example: 3637e790-5530-11ed-bdc3-0242ac120002
func (s *LoginInfoBaseImpl) SetRefreshToken(v string) LoginInfoBase {
	if s == nil {
		return nil
	}
	s.RefreshTokenValue = &v
	return s
}

// NewMap creates a new Map instance
func NewMap() Map {
	return &MapImpl{}
}

// Map server API Key if required.
func (s MapImpl) APIKey() *string {
	return s.APIKeyValue
}

// Map server API Key if required.
func (s *MapImpl) SetAPIKey(v string) Map {
	if s == nil {
		return nil
	}
	s.APIKeyValue = &v
	return s
}

// Coordinates of map center.
func (s MapImpl) Center() MapSpec {
	return s.CenterValue
}

// Coordinates of map center.
func (s *MapImpl) SetCenter(v MapSpec) Map {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*MapSpecImpl); ok {
		s.CenterValue = impl
	}
	return s
}

// Provider of the maps.
func (s MapImpl) Provider() string {
	return s.ProviderValue
}

// Provider of the maps.
func (s *MapImpl) SetProvider(v string) Map {
	if s == nil {
		return nil
	}
	s.ProviderValue = v
	return s
}

// Custom map server url.
// Format: url (url)
func (s MapImpl) URL() URL {
	return s.URLValue
}

// Custom map server url.
// Format: url (url)
func (s *MapImpl) SetURL(v URL) Map {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// NewMapBase creates a new MapBase instance
func NewMapBase() MapBase {
	return &MapBaseImpl{}
}

// Map server API Key if required.
func (s MapBaseImpl) APIKey() *string {
	return s.APIKeyValue
}

// Map server API Key if required.
func (s *MapBaseImpl) SetAPIKey(v string) MapBase {
	if s == nil {
		return nil
	}
	s.APIKeyValue = &v
	return s
}

// Coordinates of map center.
func (s MapBaseImpl) Center() MapSpec {
	return s.CenterValue
}

// Coordinates of map center.
func (s *MapBaseImpl) SetCenter(v MapSpec) MapBase {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*MapSpecImpl); ok {
		s.CenterValue = impl
	}
	return s
}

// Provider of the maps.
func (s MapBaseImpl) Provider() string {
	return s.ProviderValue
}

// Provider of the maps.
func (s *MapBaseImpl) SetProvider(v string) MapBase {
	if s == nil {
		return nil
	}
	s.ProviderValue = v
	return s
}

// NewMapCustom creates a new MapCustom instance
func NewMapCustom() MapCustom {
	return &MapCustomImpl{}
}

// Map server API Key if required.
func (s MapCustomImpl) APIKey() *string {
	return s.APIKeyValue
}

// Map server API Key if required.
func (s *MapCustomImpl) SetAPIKey(v string) MapCustom {
	if s == nil {
		return nil
	}
	s.APIKeyValue = &v
	return s
}

// Coordinates of map center.
func (s MapCustomImpl) Center() MapSpec {
	return s.CenterValue
}

// Coordinates of map center.
func (s *MapCustomImpl) SetCenter(v MapSpec) MapCustom {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*MapSpecImpl); ok {
		s.CenterValue = impl
	}
	return s
}

// Provider of the maps.
func (s MapCustomImpl) Provider() string {
	return s.ProviderValue
}

// Provider of the maps.
func (s *MapCustomImpl) SetProvider(v string) MapCustom {
	if s == nil {
		return nil
	}
	s.ProviderValue = v
	return s
}

// Custom map server url.
// Format: url (url)
func (s MapCustomImpl) URL() URL {
	return s.URLValue
}

// Custom map server url.
// Format: url (url)
func (s *MapCustomImpl) SetURL(v URL) MapCustom {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// NewMapSpec creates a new MapSpec instance
func NewMapSpec() MapSpec {
	return &MapSpecImpl{}
}

// Geographic latitude.
// Example: 55.7512
func (s MapSpecImpl) Latitude() float64 {
	return s.LatitudeValue
}

// Geographic latitude.
// Example: 55.7512
func (s *MapSpecImpl) SetLatitude(v float64) MapSpec {
	if s == nil {
		return nil
	}
	s.LatitudeValue = v
	return s
}

// Geographic longitude.
// Example: 37.6184
func (s MapSpecImpl) Longitude() float64 {
	return s.LongitudeValue
}

// Geographic longitude.
// Example: 37.6184
func (s *MapSpecImpl) SetLongitude(v float64) MapSpec {
	if s == nil {
		return nil
	}
	s.LongitudeValue = v
	return s
}

// NewMediaInfo creates a new MediaInfo instance
func NewMediaInfo() MediaInfo {
	return &MediaInfoImpl{}
}

// Duration of the media, if applicable.
// Format: ticks (ticks)
func (s MediaInfoImpl) Duration() *Ticks {
	return s.DurationValue
}

// Duration of the media, if applicable.
// Format: ticks (ticks)
func (s *MediaInfoImpl) SetDuration(v Ticks) MediaInfo {
	if s == nil {
		return nil
	}
	s.DurationValue = &v
	return s
}

// Whether it is a file with a finite start and end time or a live stream.
// Example: stream
func (s MediaInfoImpl) FlowType() *MediaInfoSpecificFlowType {
	return s.FlowTypeValue
}

// Whether it is a file with a finite start and end time or a live stream.
// Example: stream
func (s *MediaInfoImpl) SetFlowType(v MediaInfoSpecificFlowType) MediaInfo {
	if s == nil {
		return nil
	}
	s.FlowTypeValue = &v
	return s
}

// The program ID for MPEG TS streams.
// Example: 110
func (s MediaInfoImpl) ProgramID() *int {
	return s.ProgramIDValue
}

// The program ID for MPEG TS streams.
// Example: 110
func (s *MediaInfoImpl) SetProgramID(v int) MediaInfo {
	if s == nil {
		return nil
	}
	s.ProgramIDValue = &v
	return s
}

// The media provider of this content.
// Example: Netflix
func (s MediaInfoImpl) Provider() *string {
	return s.ProviderValue
}

// The media provider of this content.
// Example: Netflix
func (s *MediaInfoImpl) SetProvider(v string) MediaInfo {
	if s == nil {
		return nil
	}
	s.ProviderValue = &v
	return s
}

// The identifier of the transport stream for MPEG TS streams.
// Example: 253
func (s MediaInfoImpl) StreamID() *int {
	return s.StreamIDValue
}

// The identifier of the transport stream for MPEG TS streams.
// Example: 253
func (s *MediaInfoImpl) SetStreamID(v int) MediaInfo {
	if s == nil {
		return nil
	}
	s.StreamIDValue = &v
	return s
}

// Human-readable title of the media.
// Example: Bunny
func (s MediaInfoImpl) Title() *string {
	return s.TitleValue
}

// Human-readable title of the media.
// Example: Bunny
func (s *MediaInfoImpl) SetTitle(v string) MediaInfo {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// Information about available tracks (video, audio, or text).
func (s MediaInfoImpl) Tracks() []TrackInfo {
	if s.TracksValue == nil {
		return nil
	}
	result := make([]TrackInfo, len(s.TracksValue))
	for i, item := range s.TracksValue {
		result[i] = item
	}
	return result
}

// Information about available tracks (video, audio, or text).
func (s *MediaInfoImpl) SetTracks(v []TrackInfo) MediaInfo {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*TrackInfoImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*TrackInfoImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.TracksValue = impl
	}
	return s
}

// NewMediaInfoCommon creates a new MediaInfoCommon instance
func NewMediaInfoCommon() MediaInfoCommon {
	return &MediaInfoCommonImpl{}
}

// The program ID for MPEG TS streams.
// Example: 110
func (s MediaInfoCommonImpl) ProgramID() *int {
	return s.ProgramIDValue
}

// The program ID for MPEG TS streams.
// Example: 110
func (s *MediaInfoCommonImpl) SetProgramID(v int) MediaInfoCommon {
	if s == nil {
		return nil
	}
	s.ProgramIDValue = &v
	return s
}

// The media provider of this content.
// Example: Netflix
func (s MediaInfoCommonImpl) Provider() *string {
	return s.ProviderValue
}

// The media provider of this content.
// Example: Netflix
func (s *MediaInfoCommonImpl) SetProvider(v string) MediaInfoCommon {
	if s == nil {
		return nil
	}
	s.ProviderValue = &v
	return s
}

// The identifier of the transport stream for MPEG TS streams.
// Example: 253
func (s MediaInfoCommonImpl) StreamID() *int {
	return s.StreamIDValue
}

// The identifier of the transport stream for MPEG TS streams.
// Example: 253
func (s *MediaInfoCommonImpl) SetStreamID(v int) MediaInfoCommon {
	if s == nil {
		return nil
	}
	s.StreamIDValue = &v
	return s
}

// Human-readable title of the media.
// Example: Bunny
func (s MediaInfoCommonImpl) Title() *string {
	return s.TitleValue
}

// Human-readable title of the media.
// Example: Bunny
func (s *MediaInfoCommonImpl) SetTitle(v string) MediaInfoCommon {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// NewMediaInfoSpecific creates a new MediaInfoSpecific instance
func NewMediaInfoSpecific() MediaInfoSpecific {
	return &MediaInfoSpecificImpl{}
}

// Duration of the media, if applicable.
// Format: ticks (ticks)
func (s MediaInfoSpecificImpl) Duration() *Ticks {
	return s.DurationValue
}

// Duration of the media, if applicable.
// Format: ticks (ticks)
func (s *MediaInfoSpecificImpl) SetDuration(v Ticks) MediaInfoSpecific {
	if s == nil {
		return nil
	}
	s.DurationValue = &v
	return s
}

// Whether it is a file with a finite start and end time or a live stream.
// Example: stream
func (s MediaInfoSpecificImpl) FlowType() *MediaInfoSpecificFlowType {
	return s.FlowTypeValue
}

// Whether it is a file with a finite start and end time or a live stream.
// Example: stream
func (s *MediaInfoSpecificImpl) SetFlowType(v MediaInfoSpecificFlowType) MediaInfoSpecific {
	if s == nil {
		return nil
	}
	s.FlowTypeValue = &v
	return s
}

// Information about available tracks (video, audio, or text).
func (s MediaInfoSpecificImpl) Tracks() []TrackInfo {
	if s.TracksValue == nil {
		return nil
	}
	result := make([]TrackInfo, len(s.TracksValue))
	for i, item := range s.TracksValue {
		result[i] = item
	}
	return result
}

// Information about available tracks (video, audio, or text).
func (s *MediaInfoSpecificImpl) SetTracks(v []TrackInfo) MediaInfoSpecific {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*TrackInfoImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*TrackInfoImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.TracksValue = impl
	}
	return s
}

// NewMessage creates a new Message instance
func NewMessage() Message {
	return &MessageImpl{}
}

func (s MessageImpl) Body() *string {
	return s.BodyValue
}

func (s *MessageImpl) SetBody(v string) Message {
	if s == nil {
		return nil
	}
	s.BodyValue = &v
	return s
}

// Identifier of the message.
// Example: 1
func (s MessageImpl) ID() *int {
	return s.IDValue
}

// Identifier of the message.
// Example: 1
func (s *MessageImpl) SetID(v int) Message {
	if s == nil {
		return nil
	}
	s.IDValue = &v
	return s
}

// Whether to display the notification on the information panel or not
// Example: false
func (s MessageImpl) IsDashboard() *bool {
	return s.IsDashboardValue
}

// Whether to display the notification on the information panel or not
// Example: false
func (s *MessageImpl) SetIsDashboard(v bool) Message {
	if s == nil {
		return nil
	}
	s.IsDashboardValue = &v
	return s
}

// This parameter indicates whether the message is deleted or not.
// Example: false
func (s MessageImpl) IsDeleted() *bool {
	return s.IsDeletedValue
}

// This parameter indicates whether the message is deleted or not.
// Example: false
func (s *MessageImpl) SetIsDeleted(v bool) Message {
	if s == nil {
		return nil
	}
	s.IsDeletedValue = &v
	return s
}

// Whether to send a push notification to mobile devices or not
// Example: false
func (s MessageImpl) IsPush() *bool {
	return s.IsPushValue
}

// Whether to send a push notification to mobile devices or not
// Example: false
func (s *MessageImpl) SetIsPush(v bool) Message {
	if s == nil {
		return nil
	}
	s.IsPushValue = &v
	return s
}

// Message sender
func (s MessageImpl) Sender() MessageSender {
	return s.SenderValue
}

// Message sender
func (s *MessageImpl) SetSender(v MessageSender) Message {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*MessageSenderImpl); ok {
		s.SenderValue = impl
	}
	return s
}

func (s MessageImpl) Title() *string {
	return s.TitleValue
}

func (s *MessageImpl) SetTitle(v string) Message {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// The type of a message.
// Example: warning
func (s MessageImpl) Type() *MessageBaseType {
	return s.TypeValue
}

// The type of a message.
// Example: warning
func (s *MessageImpl) SetType(v MessageBaseType) Message {
	if s == nil {
		return nil
	}
	s.TypeValue = &v
	return s
}

// Message recipient
func (s MessageImpl) User() MessageUser {
	return s.UserValue
}

// Message recipient
func (s *MessageImpl) SetUser(v MessageUser) Message {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*MessageUserImpl); ok {
		s.UserValue = impl
	}
	return s
}

// This parameter indicates whether the message has been read or not.
// Example: false
func (s MessageImpl) WasRead() *bool {
	return s.WasReadValue
}

// This parameter indicates whether the message has been read or not.
// Example: false
func (s *MessageImpl) SetWasRead(v bool) Message {
	if s == nil {
		return nil
	}
	s.WasReadValue = &v
	return s
}

// NewMessageBase creates a new MessageBase instance
func NewMessageBase() MessageBase {
	return &MessageBaseImpl{}
}

func (s MessageBaseImpl) Body() *string {
	return s.BodyValue
}

func (s *MessageBaseImpl) SetBody(v string) MessageBase {
	if s == nil {
		return nil
	}
	s.BodyValue = &v
	return s
}

// Whether to display the notification on the information panel or not
// Example: false
func (s MessageBaseImpl) IsDashboard() *bool {
	return s.IsDashboardValue
}

// Whether to display the notification on the information panel or not
// Example: false
func (s *MessageBaseImpl) SetIsDashboard(v bool) MessageBase {
	if s == nil {
		return nil
	}
	s.IsDashboardValue = &v
	return s
}

// Whether to send a push notification to mobile devices or not
// Example: false
func (s MessageBaseImpl) IsPush() *bool {
	return s.IsPushValue
}

// Whether to send a push notification to mobile devices or not
// Example: false
func (s *MessageBaseImpl) SetIsPush(v bool) MessageBase {
	if s == nil {
		return nil
	}
	s.IsPushValue = &v
	return s
}

func (s MessageBaseImpl) Title() *string {
	return s.TitleValue
}

func (s *MessageBaseImpl) SetTitle(v string) MessageBase {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// The type of a message.
// Example: warning
func (s MessageBaseImpl) Type() *MessageBaseType {
	return s.TypeValue
}

// The type of a message.
// Example: warning
func (s *MessageBaseImpl) SetType(v MessageBaseType) MessageBase {
	if s == nil {
		return nil
	}
	s.TypeValue = &v
	return s
}

// NewMessageChangeRequest creates a new MessageChangeRequest instance
func NewMessageChangeRequest() MessageChangeRequest {
	return &MessageChangeRequestImpl{}
}

func (s MessageChangeRequestImpl) Body() *string {
	return s.BodyValue
}

func (s *MessageChangeRequestImpl) SetBody(v string) MessageChangeRequest {
	if s == nil {
		return nil
	}
	s.BodyValue = &v
	return s
}

// Whether to display the notification on the information panel or not
// Example: false
func (s MessageChangeRequestImpl) IsDashboard() *bool {
	return s.IsDashboardValue
}

// Whether to display the notification on the information panel or not
// Example: false
func (s *MessageChangeRequestImpl) SetIsDashboard(v bool) MessageChangeRequest {
	if s == nil {
		return nil
	}
	s.IsDashboardValue = &v
	return s
}

// Whether to send a push notification to mobile devices or not
// Example: false
func (s MessageChangeRequestImpl) IsPush() *bool {
	return s.IsPushValue
}

// Whether to send a push notification to mobile devices or not
// Example: false
func (s *MessageChangeRequestImpl) SetIsPush(v bool) MessageChangeRequest {
	if s == nil {
		return nil
	}
	s.IsPushValue = &v
	return s
}

func (s MessageChangeRequestImpl) Title() *string {
	return s.TitleValue
}

func (s *MessageChangeRequestImpl) SetTitle(v string) MessageChangeRequest {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// The type of a message.
// Example: warning
func (s MessageChangeRequestImpl) Type() *MessageBaseType {
	return s.TypeValue
}

// The type of a message.
// Example: warning
func (s *MessageChangeRequestImpl) SetType(v MessageBaseType) MessageChangeRequest {
	if s == nil {
		return nil
	}
	s.TypeValue = &v
	return s
}

// This parameter indicates whether the message has been read or not.
// Example: false
func (s MessageChangeRequestImpl) WasRead() *bool {
	return s.WasReadValue
}

// This parameter indicates whether the message has been read or not.
// Example: false
func (s *MessageChangeRequestImpl) SetWasRead(v bool) MessageChangeRequest {
	if s == nil {
		return nil
	}
	s.WasReadValue = &v
	return s
}

// NewMessageResponse creates a new MessageResponse instance
func NewMessageResponse() MessageResponse {
	return &MessageResponseImpl{}
}

func (s MessageResponseImpl) Body() *string {
	return s.BodyValue
}

func (s *MessageResponseImpl) SetBody(v string) MessageResponse {
	if s == nil {
		return nil
	}
	s.BodyValue = &v
	return s
}

// The number of devices to which push notifications were sent. If the flag `is_push` is set to `true` and no devices are returned,
// it means the user has no devices registered for push notifications.
// Example: 3
func (s MessageResponseImpl) Devices() *int {
	return s.DevicesValue
}

// The number of devices to which push notifications were sent. If the flag `is_push` is set to `true` and no devices are returned,
// it means the user has no devices registered for push notifications.
// Example: 3
func (s *MessageResponseImpl) SetDevices(v int) MessageResponse {
	if s == nil {
		return nil
	}
	s.DevicesValue = &v
	return s
}

// Identifier of the message.
// Example: 1
func (s MessageResponseImpl) ID() *int {
	return s.IDValue
}

// Identifier of the message.
// Example: 1
func (s *MessageResponseImpl) SetID(v int) MessageResponse {
	if s == nil {
		return nil
	}
	s.IDValue = &v
	return s
}

// Whether to display the notification on the information panel or not
// Example: false
func (s MessageResponseImpl) IsDashboard() *bool {
	return s.IsDashboardValue
}

// Whether to display the notification on the information panel or not
// Example: false
func (s *MessageResponseImpl) SetIsDashboard(v bool) MessageResponse {
	if s == nil {
		return nil
	}
	s.IsDashboardValue = &v
	return s
}

// This parameter indicates whether the message is deleted or not.
// Example: false
func (s MessageResponseImpl) IsDeleted() *bool {
	return s.IsDeletedValue
}

// This parameter indicates whether the message is deleted or not.
// Example: false
func (s *MessageResponseImpl) SetIsDeleted(v bool) MessageResponse {
	if s == nil {
		return nil
	}
	s.IsDeletedValue = &v
	return s
}

// Whether to send a push notification to mobile devices or not
// Example: false
func (s MessageResponseImpl) IsPush() *bool {
	return s.IsPushValue
}

// Whether to send a push notification to mobile devices or not
// Example: false
func (s *MessageResponseImpl) SetIsPush(v bool) MessageResponse {
	if s == nil {
		return nil
	}
	s.IsPushValue = &v
	return s
}

// Message sender
func (s MessageResponseImpl) Sender() MessageSender {
	return s.SenderValue
}

// Message sender
func (s *MessageResponseImpl) SetSender(v MessageSender) MessageResponse {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*MessageSenderImpl); ok {
		s.SenderValue = impl
	}
	return s
}

func (s MessageResponseImpl) Title() *string {
	return s.TitleValue
}

func (s *MessageResponseImpl) SetTitle(v string) MessageResponse {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// The type of a message.
// Example: warning
func (s MessageResponseImpl) Type() *MessageBaseType {
	return s.TypeValue
}

// The type of a message.
// Example: warning
func (s *MessageResponseImpl) SetType(v MessageBaseType) MessageResponse {
	if s == nil {
		return nil
	}
	s.TypeValue = &v
	return s
}

// Message recipient
func (s MessageResponseImpl) User() MessageUser {
	return s.UserValue
}

// Message recipient
func (s *MessageResponseImpl) SetUser(v MessageUser) MessageResponse {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*MessageUserImpl); ok {
		s.UserValue = impl
	}
	return s
}

// This parameter indicates whether the message has been read or not.
// Example: false
func (s MessageResponseImpl) WasRead() *bool {
	return s.WasReadValue
}

// This parameter indicates whether the message has been read or not.
// Example: false
func (s *MessageResponseImpl) SetWasRead(v bool) MessageResponse {
	if s == nil {
		return nil
	}
	s.WasReadValue = &v
	return s
}

// NewMessageSend creates a new MessageSend instance
func NewMessageSend() MessageSend {
	return &MessageSendImpl{}
}

func (s MessageSendImpl) Body() *string {
	return s.BodyValue
}

func (s *MessageSendImpl) SetBody(v string) MessageSend {
	if s == nil {
		return nil
	}
	s.BodyValue = &v
	return s
}

// Whether to display the notification on the information panel or not
// Example: false
func (s MessageSendImpl) IsDashboard() *bool {
	return s.IsDashboardValue
}

// Whether to display the notification on the information panel or not
// Example: false
func (s *MessageSendImpl) SetIsDashboard(v bool) MessageSend {
	if s == nil {
		return nil
	}
	s.IsDashboardValue = &v
	return s
}

// Whether to send a push notification to mobile devices or not
// Example: false
func (s MessageSendImpl) IsPush() *bool {
	return s.IsPushValue
}

// Whether to send a push notification to mobile devices or not
// Example: false
func (s *MessageSendImpl) SetIsPush(v bool) MessageSend {
	if s == nil {
		return nil
	}
	s.IsPushValue = &v
	return s
}

func (s MessageSendImpl) Title() *string {
	return s.TitleValue
}

func (s *MessageSendImpl) SetTitle(v string) MessageSend {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// The type of a message.
// Example: warning
func (s MessageSendImpl) Type() *MessageBaseType {
	return s.TypeValue
}

// The type of a message.
// Example: warning
func (s *MessageSendImpl) SetType(v MessageBaseType) MessageSend {
	if s == nil {
		return nil
	}
	s.TypeValue = &v
	return s
}

// Identifier of the user to whom the message will be sent.
// Example: 1
func (s MessageSendImpl) UserID() *int {
	return s.UserIDValue
}

// Identifier of the user to whom the message will be sent.
// Example: 1
func (s *MessageSendImpl) SetUserID(v int) MessageSend {
	if s == nil {
		return nil
	}
	s.UserIDValue = &v
	return s
}

// NewMessageSender creates a new MessageSender instance
func NewMessageSender() MessageSender {
	return &MessageSenderImpl{}
}

// User ID who sent the message
// Example: 1
func (s MessageSenderImpl) ID() *int {
	return s.IDValue
}

// User ID who sent the message
// Example: 1
func (s *MessageSenderImpl) SetID(v int) MessageSender {
	if s == nil {
		return nil
	}
	s.IDValue = &v
	return s
}

// User name who sent the message
// Example: admin
func (s MessageSenderImpl) Name() *string {
	return s.NameValue
}

// User name who sent the message
// Example: admin
func (s *MessageSenderImpl) SetName(v string) MessageSender {
	if s == nil {
		return nil
	}
	s.NameValue = &v
	return s
}

// NewMessageUser creates a new MessageUser instance
func NewMessageUser() MessageUser {
	return &MessageUserImpl{}
}

// User ID to whom the message was sent
// Example: 1
func (s MessageUserImpl) ID() *int {
	return s.IDValue
}

// User ID to whom the message was sent
// Example: 1
func (s *MessageUserImpl) SetID(v int) MessageUser {
	if s == nil {
		return nil
	}
	s.IDValue = &v
	return s
}

// User name to whom the message was sent
// Example: support
func (s MessageUserImpl) Name() *string {
	return s.NameValue
}

// User name to whom the message was sent
// Example: support
func (s *MessageUserImpl) SetName(v string) MessageUser {
	if s == nil {
		return nil
	}
	s.NameValue = &v
	return s
}

// NewMessages creates a new Messages instance
func NewMessages() Messages {
	return &MessagesImpl{}
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s MessagesImpl) EstimatedCount() *int {
	return s.EstimatedCountValue
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s *MessagesImpl) SetEstimatedCount(v int) Messages {
	if s == nil {
		return nil
	}
	s.EstimatedCountValue = &v
	return s
}

// List of fetched messages according to the query parameters.
func (s MessagesImpl) Messages() []Message {
	if s.MessagesValue == nil {
		return nil
	}
	result := make([]Message, len(s.MessagesValue))
	for i, item := range s.MessagesValue {
		result[i] = item
	}
	return result
}

// List of fetched messages according to the query parameters.
func (s *MessagesImpl) SetMessages(v []Message) Messages {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*MessageImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*MessageImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.MessagesValue = impl
	}
	return s
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s MessagesImpl) Next() *string {
	return s.NextValue
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s *MessagesImpl) SetNext(v string) Messages {
	if s == nil {
		return nil
	}
	s.NextValue = &v
	return s
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s MessagesImpl) Prev() *string {
	return s.PrevValue
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s *MessagesImpl) SetPrev(v string) Messages {
	if s == nil {
		return nil
	}
	s.PrevValue = &v
	return s
}

// An object with a list of different timings measured during this API call.
func (s MessagesImpl) Timing() any {
	return s.TimingValue
}

// An object with a list of different timings measured during this API call.
func (s *MessagesImpl) SetTiming(v any) Messages {
	if s == nil {
		return nil
	}
	s.TimingValue = v
	return s
}

// Collection returns the collection items from Messages
func (s MessagesImpl) Collection() []Message {
	return s.Messages()
}

// NewMosaic creates a new Mosaic instance
func NewMosaic() Mosaic {
	return &MosaicImpl{}
}

// Mosaic identifier.
// Example: 7
func (s MosaicImpl) ID() *int {
	return s.IDValue
}

// Mosaic identifier.
// Example: 7
func (s *MosaicImpl) SetID(v int) Mosaic {
	if s == nil {
		return nil
	}
	s.IDValue = &v
	return s
}

// The identifier of organization that the mosaic is linked to.
// Example: 9
func (s MosaicImpl) OrganizationID() *int {
	return s.OrganizationIDValue
}

// The identifier of organization that the mosaic is linked to.
// Example: 9
func (s *MosaicImpl) SetOrganizationID(v int) Mosaic {
	if s == nil {
		return nil
	}
	s.OrganizationIDValue = &v
	return s
}

// The list of streams from which the mosaic is formed.
// The array is contiguously filled in the order of the streams' arrangement on the mosaic.
// An empty element corresponds to a cell without a stream.
func (s MosaicImpl) Streams() []MosaicStream {
	if s.StreamsValue == nil {
		return nil
	}
	result := make([]MosaicStream, len(s.StreamsValue))
	for i, item := range s.StreamsValue {
		result[i] = item
	}
	return result
}

// The list of streams from which the mosaic is formed.
// The array is contiguously filled in the order of the streams' arrangement on the mosaic.
// An empty element corresponds to a cell without a stream.
func (s *MosaicImpl) SetStreams(v []MosaicStream) Mosaic {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*MosaicStreamImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*MosaicStreamImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.StreamsValue = impl
	}
	return s
}

// Human-readable mosaic name.
func (s MosaicImpl) Title() *string {
	return s.TitleValue
}

// Human-readable mosaic name.
func (s *MosaicImpl) SetTitle(v string) Mosaic {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// Use this parameter to specify mosaic display mode and size.
// Example: 2x2
func (s MosaicImpl) Type() *MosaicBaseType {
	return s.TypeValue
}

// Use this parameter to specify mosaic display mode and size.
// Example: 2x2
func (s *MosaicImpl) SetType(v MosaicBaseType) Mosaic {
	if s == nil {
		return nil
	}
	s.TypeValue = &v
	return s
}

// NewMosaicBase creates a new MosaicBase instance
func NewMosaicBase() MosaicBase {
	return &MosaicBaseImpl{}
}

// The identifier of organization that the mosaic is linked to.
// Example: 9
func (s MosaicBaseImpl) OrganizationID() *int {
	return s.OrganizationIDValue
}

// The identifier of organization that the mosaic is linked to.
// Example: 9
func (s *MosaicBaseImpl) SetOrganizationID(v int) MosaicBase {
	if s == nil {
		return nil
	}
	s.OrganizationIDValue = &v
	return s
}

// Human-readable mosaic name.
func (s MosaicBaseImpl) Title() *string {
	return s.TitleValue
}

// Human-readable mosaic name.
func (s *MosaicBaseImpl) SetTitle(v string) MosaicBase {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// Use this parameter to specify mosaic display mode and size.
// Example: 2x2
func (s MosaicBaseImpl) Type() *MosaicBaseType {
	return s.TypeValue
}

// Use this parameter to specify mosaic display mode and size.
// Example: 2x2
func (s *MosaicBaseImpl) SetType(v MosaicBaseType) MosaicBase {
	if s == nil {
		return nil
	}
	s.TypeValue = &v
	return s
}

// NewMosaicSave creates a new MosaicSave instance
func NewMosaicSave() MosaicSave {
	return &MosaicSaveImpl{}
}

// The identifier of organization that the mosaic is linked to.
// Example: 9
func (s MosaicSaveImpl) OrganizationID() *int {
	return s.OrganizationIDValue
}

// The identifier of organization that the mosaic is linked to.
// Example: 9
func (s *MosaicSaveImpl) SetOrganizationID(v int) MosaicSave {
	if s == nil {
		return nil
	}
	s.OrganizationIDValue = &v
	return s
}

// The list of streams from which the mosaic is formed.
// The array is contiguously filled in the order of the streams' arrangement on the mosaic.
// An empty element corresponds to a cell without a stream.
func (s MosaicSaveImpl) Streams() []MosaicSaveStreamsItem {
	if s.StreamsValue == nil {
		return nil
	}
	result := make([]MosaicSaveStreamsItem, len(s.StreamsValue))
	for i, item := range s.StreamsValue {
		result[i] = item
	}
	return result
}

// The list of streams from which the mosaic is formed.
// The array is contiguously filled in the order of the streams' arrangement on the mosaic.
// An empty element corresponds to a cell without a stream.
func (s *MosaicSaveImpl) SetStreams(v []MosaicSaveStreamsItem) MosaicSave {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*MosaicSaveStreamsItemImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*MosaicSaveStreamsItemImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.StreamsValue = impl
	}
	return s
}

// Human-readable mosaic name.
func (s MosaicSaveImpl) Title() *string {
	return s.TitleValue
}

// Human-readable mosaic name.
func (s *MosaicSaveImpl) SetTitle(v string) MosaicSave {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// Use this parameter to specify mosaic display mode and size.
// Example: 2x2
func (s MosaicSaveImpl) Type() *MosaicBaseType {
	return s.TypeValue
}

// Use this parameter to specify mosaic display mode and size.
// Example: 2x2
func (s *MosaicSaveImpl) SetType(v MosaicBaseType) MosaicSave {
	if s == nil {
		return nil
	}
	s.TypeValue = &v
	return s
}

// NewMosaicSaveStreamsItem creates a new MosaicSaveStreamsItem instance
func NewMosaicSaveStreamsItem() MosaicSaveStreamsItem {
	return &MosaicSaveStreamsItemImpl{}
}

// Globally unique stream name.
// Format: media_name (media_name)
// Example: ag-12345
func (s MosaicSaveStreamsItemImpl) Name() *MediaName {
	return s.NameValue
}

// Globally unique stream name.
// Format: media_name (media_name)
// Example: ag-12345
func (s *MosaicSaveStreamsItemImpl) SetName(v MediaName) MosaicSaveStreamsItem {
	if s == nil {
		return nil
	}
	s.NameValue = &v
	return s
}

// NewMosaicStream creates a new MosaicStream instance
func NewMosaicStream() MosaicStream {
	return &MosaicStreamImpl{}
}

// A flag indicating if the current stream of the camera is available (true) or not (false).
func (s MosaicStreamImpl) Alive() *bool {
	return s.AliveValue
}

// A flag indicating if the current stream of the camera is available (true) or not (false).
func (s *MosaicStreamImpl) SetAlive(v bool) MosaicStream {
	if s == nil {
		return nil
	}
	s.AliveValue = &v
	return s
}

// Globally unique stream name.
// Format: media_name (media_name)
// Example: ag-12345
func (s MosaicStreamImpl) Name() *MediaName {
	return s.NameValue
}

// Globally unique stream name.
// Format: media_name (media_name)
// Example: ag-12345
func (s *MosaicStreamImpl) SetName(v MediaName) MosaicStream {
	if s == nil {
		return nil
	}
	s.NameValue = &v
	return s
}

// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
// Example: onetime_token
func (s MosaicStreamImpl) PlaybackToken() *string {
	return s.PlaybackTokenValue
}

// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
// Example: onetime_token
func (s *MosaicStreamImpl) SetPlaybackToken(v string) MosaicStream {
	if s == nil {
		return nil
	}
	s.PlaybackTokenValue = &v
	return s
}

// HTTP(s) URL that can be used for streaming API of this stream
// Example: https://ms.example.com
func (s MosaicStreamImpl) StreamingEndpoint() *string {
	return s.StreamingEndpointValue
}

// HTTP(s) URL that can be used for streaming API of this stream
// Example: https://ms.example.com
func (s *MosaicStreamImpl) SetStreamingEndpoint(v string) MosaicStream {
	if s == nil {
		return nil
	}
	s.StreamingEndpointValue = &v
	return s
}

// Human-readable title of the stream. Provided for SDT MPEG-TS table or
// SDP RTSP title parameter.
// Example: Hockey channel
func (s MosaicStreamImpl) Title() *string {
	return s.TitleValue
}

// Human-readable title of the stream. Provided for SDT MPEG-TS table or
// SDP RTSP title parameter.
// Example: Hockey channel
func (s *MosaicStreamImpl) SetTitle(v string) MosaicStream {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// NewMosaicsList creates a new MosaicsList instance
func NewMosaicsList() MosaicsList {
	return &MosaicsListImpl{}
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s MosaicsListImpl) EstimatedCount() *int {
	return s.EstimatedCountValue
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s *MosaicsListImpl) SetEstimatedCount(v int) MosaicsList {
	if s == nil {
		return nil
	}
	s.EstimatedCountValue = &v
	return s
}

// List of mosaics
func (s MosaicsListImpl) Mosaics() []Mosaic {
	if s.MosaicsValue == nil {
		return nil
	}
	result := make([]Mosaic, len(s.MosaicsValue))
	for i, item := range s.MosaicsValue {
		result[i] = item
	}
	return result
}

// List of mosaics
func (s *MosaicsListImpl) SetMosaics(v []Mosaic) MosaicsList {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*MosaicImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*MosaicImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.MosaicsValue = impl
	}
	return s
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s MosaicsListImpl) Next() *string {
	return s.NextValue
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s *MosaicsListImpl) SetNext(v string) MosaicsList {
	if s == nil {
		return nil
	}
	s.NextValue = &v
	return s
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s MosaicsListImpl) Prev() *string {
	return s.PrevValue
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s *MosaicsListImpl) SetPrev(v string) MosaicsList {
	if s == nil {
		return nil
	}
	s.PrevValue = &v
	return s
}

// An object with a list of different timings measured during this API call.
func (s MosaicsListImpl) Timing() any {
	return s.TimingValue
}

// An object with a list of different timings measured during this API call.
func (s *MosaicsListImpl) SetTiming(v any) MosaicsList {
	if s == nil {
		return nil
	}
	s.TimingValue = v
	return s
}

// Collection returns the collection items from MosaicsList
func (s MosaicsListImpl) Collection() []Mosaic {
	return s.Mosaics()
}

// NewNotificationsRequest creates a new NotificationsRequest instance
func NewNotificationsRequest() NotificationsRequest {
	return &NotificationsRequestImpl{}
}

// Body of notification
func (s NotificationsRequestImpl) Body() string {
	return s.BodyValue
}

// Body of notification
func (s *NotificationsRequestImpl) SetBody(v string) NotificationsRequest {
	if s == nil {
		return nil
	}
	s.BodyValue = v
	return s
}

// Title of notification
func (s NotificationsRequestImpl) Title() string {
	return s.TitleValue
}

// Title of notification
func (s *NotificationsRequestImpl) SetTitle(v string) NotificationsRequest {
	if s == nil {
		return nil
	}
	s.TitleValue = v
	return s
}

// NewOnOff creates a new OnOff instance
func NewOnOff() OnOff {
	return &OnOffImpl{}
}

func (s OnOffImpl) Mode() *OnOffMode {
	return s.ModeValue
}

func (s *OnOffImpl) SetMode(v OnOffMode) OnOff {
	if s == nil {
		return nil
	}
	s.ModeValue = &v
	return s
}

// NewOnOffAuto creates a new OnOffAuto instance
func NewOnOffAuto() OnOffAuto {
	return &OnOffAutoImpl{}
}

func (s OnOffAutoImpl) Mode() *OnOffAutoMode {
	return s.ModeValue
}

func (s *OnOffAutoImpl) SetMode(v OnOffAutoMode) OnOffAuto {
	if s == nil {
		return nil
	}
	s.ModeValue = &v
	return s
}

// NewOrganization creates a new Organization instance
func NewOrganization() Organization {
	return &OrganizationImpl{}
}

// The date and time when the organization was created.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.672531199e+12
func (s OrganizationImpl) CreatedAt() *UtcMs {
	return s.CreatedAtValue
}

// The date and time when the organization was created.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.672531199e+12
func (s *OrganizationImpl) SetCreatedAt(v UtcMs) Organization {
	if s == nil {
		return nil
	}
	s.CreatedAtValue = &v
	return s
}

// Organization identifier.
// Example: 7
func (s OrganizationImpl) ID() int {
	return s.IDValue
}

// Organization identifier.
// Example: 7
func (s *OrganizationImpl) SetID(v int) Organization {
	if s == nil {
		return nil
	}
	s.IDValue = v
	return s
}

// Is that organization is default for new users.
// Example: true
func (s OrganizationImpl) IsDefault() *bool {
	return s.IsDefaultValue
}

// Is that organization is default for new users.
// Example: true
func (s *OrganizationImpl) SetIsDefault(v bool) Organization {
	if s == nil {
		return nil
	}
	s.IsDefaultValue = &v
	return s
}

// Limits for properties in organization.
func (s OrganizationImpl) Limits() OrganizationLimits {
	return s.LimitsValue
}

// Limits for properties in organization.
func (s *OrganizationImpl) SetLimits(v OrganizationLimits) Organization {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*OrganizationLimitsImpl); ok {
		s.LimitsValue = impl
	}
	return s
}

// Owner properties.
func (s OrganizationImpl) Owner() OrganizationOwner {
	return s.OwnerValue
}

// Owner properties.
func (s *OrganizationImpl) SetOwner(v OrganizationOwner) Organization {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*OrganizationOwnerImpl); ok {
		s.OwnerValue = impl
	}
	return s
}

// Pickpoint properties.
func (s OrganizationImpl) Pickpoint() OrganizationPickpoint {
	return s.PickpointValue
}

// Pickpoint properties.
func (s *OrganizationImpl) SetPickpoint(v OrganizationPickpoint) Organization {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*OrganizationPickpointImpl); ok {
		s.PickpointValue = impl
	}
	return s
}

// Counts for streams, users and mosaics in organization.
func (s OrganizationImpl) Stats() OrganizationStats {
	return s.StatsValue
}

// Counts for streams, users and mosaics in organization.
func (s *OrganizationImpl) SetStats(v OrganizationStats) Organization {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*OrganizationStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// Human-readable name of the organization.
// Example: Example LLC
func (s OrganizationImpl) Title() string {
	return s.TitleValue
}

// Human-readable name of the organization.
// Example: Example LLC
func (s *OrganizationImpl) SetTitle(v string) Organization {
	if s == nil {
		return nil
	}
	s.TitleValue = v
	return s
}

// User permissions in organization.
func (s OrganizationImpl) UserPermissions() OrganizationPermissions {
	return s.UserPermissionsValue
}

// User permissions in organization.
func (s *OrganizationImpl) SetUserPermissions(v OrganizationPermissions) Organization {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*OrganizationPermissionsImpl); ok {
		s.UserPermissionsValue = impl
	}
	return s
}

// NewOrganizationBase creates a new OrganizationBase instance
func NewOrganizationBase() OrganizationBase {
	return &OrganizationBaseImpl{}
}

// Organization identifier.
// Example: 7
func (s OrganizationBaseImpl) ID() int {
	return s.IDValue
}

// Organization identifier.
// Example: 7
func (s *OrganizationBaseImpl) SetID(v int) OrganizationBase {
	if s == nil {
		return nil
	}
	s.IDValue = v
	return s
}

// Human-readable name of the organization.
// Example: Example LLC
func (s OrganizationBaseImpl) Title() string {
	return s.TitleValue
}

// Human-readable name of the organization.
// Example: Example LLC
func (s *OrganizationBaseImpl) SetTitle(v string) OrganizationBase {
	if s == nil {
		return nil
	}
	s.TitleValue = v
	return s
}

// NewOrganizationInviteKey creates a new OrganizationInviteKey instance
func NewOrganizationInviteKey() OrganizationInviteKey {
	return &OrganizationInviteKeyImpl{}
}

// Unique invitation key that can be used to invite users to the organization.
func (s OrganizationInviteKeyImpl) InviteKey() *string {
	return s.InviteKeyValue
}

// Unique invitation key that can be used to invite users to the organization.
func (s *OrganizationInviteKeyImpl) SetInviteKey(v string) OrganizationInviteKey {
	if s == nil {
		return nil
	}
	s.InviteKeyValue = &v
	return s
}

// User permissions in organization.
func (s OrganizationInviteKeyImpl) Permissions() OrganizationInviteSetupPermissions {
	return s.PermissionsValue
}

// User permissions in organization.
func (s *OrganizationInviteKeyImpl) SetPermissions(v OrganizationInviteSetupPermissions) OrganizationInviteKey {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*OrganizationInviteSetupPermissionsImpl); ok {
		s.PermissionsValue = impl
	}
	return s
}

// NewOrganizationInviteSetup creates a new OrganizationInviteSetup instance
func NewOrganizationInviteSetup() OrganizationInviteSetup {
	return &OrganizationInviteSetupImpl{}
}

// User permissions in organization.
func (s OrganizationInviteSetupImpl) Permissions() OrganizationInviteSetupPermissions {
	return s.PermissionsValue
}

// User permissions in organization.
func (s *OrganizationInviteSetupImpl) SetPermissions(v OrganizationInviteSetupPermissions) OrganizationInviteSetup {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*OrganizationInviteSetupPermissionsImpl); ok {
		s.PermissionsValue = impl
	}
	return s
}

// NewOrganizationInviteSetupPermissions creates a new OrganizationInviteSetupPermissions instance
func NewOrganizationInviteSetupPermissions() OrganizationInviteSetupPermissions {
	return &OrganizationInviteSetupPermissionsImpl{}
}

// An indicator of whether the user has control over the streams.
func (s OrganizationInviteSetupPermissionsImpl) CanEditStreams() *bool {
	return s.CanEditStreamsValue
}

// An indicator of whether the user has control over the streams.
func (s *OrganizationInviteSetupPermissionsImpl) SetCanEditStreams(v bool) OrganizationInviteSetupPermissions {
	if s == nil {
		return nil
	}
	s.CanEditStreamsValue = &v
	return s
}

// An indicator of whether the user has control over the users.
func (s OrganizationInviteSetupPermissionsImpl) CanEditUsers() *bool {
	return s.CanEditUsersValue
}

// An indicator of whether the user has control over the users.
func (s *OrganizationInviteSetupPermissionsImpl) SetCanEditUsers(v bool) OrganizationInviteSetupPermissions {
	if s == nil {
		return nil
	}
	s.CanEditUsersValue = &v
	return s
}

// An indicator of whether the user can view statistics of organization.
func (s OrganizationInviteSetupPermissionsImpl) CanViewStats() *bool {
	return s.CanViewStatsValue
}

// An indicator of whether the user can view statistics of organization.
func (s *OrganizationInviteSetupPermissionsImpl) SetCanViewStats(v bool) OrganizationInviteSetupPermissions {
	if s == nil {
		return nil
	}
	s.CanViewStatsValue = &v
	return s
}

// An indicator of whether the user can view the streams.
func (s OrganizationInviteSetupPermissionsImpl) CanViewStreams() *bool {
	return s.CanViewStreamsValue
}

// An indicator of whether the user can view the streams.
func (s *OrganizationInviteSetupPermissionsImpl) SetCanViewStreams(v bool) OrganizationInviteSetupPermissions {
	if s == nil {
		return nil
	}
	s.CanViewStreamsValue = &v
	return s
}

// NewOrganizationLimits creates a new OrganizationLimits instance
func NewOrganizationLimits() OrganizationLimits {
	return &OrganizationLimitsImpl{}
}

// Streams limit in organization. Maximum amount of streams for organization.
// Example: 50
func (s OrganizationLimitsImpl) Streams() *int {
	return s.StreamsValue
}

// Streams limit in organization. Maximum amount of streams for organization.
// Example: 50
func (s *OrganizationLimitsImpl) SetStreams(v int) OrganizationLimits {
	if s == nil {
		return nil
	}
	s.StreamsValue = &v
	return s
}

// Owner cannot add users above this limit.
// Example: 50
func (s OrganizationLimitsImpl) Users() *int {
	return s.UsersValue
}

// Owner cannot add users above this limit.
// Example: 50
func (s *OrganizationLimitsImpl) SetUsers(v int) OrganizationLimits {
	if s == nil {
		return nil
	}
	s.UsersValue = &v
	return s
}

// NewOrganizationOwner creates a new OrganizationOwner instance
func NewOrganizationOwner() OrganizationOwner {
	return &OrganizationOwnerImpl{}
}

// ID of the organizations owner.
// Example: 2
func (s OrganizationOwnerImpl) ID() *int {
	return s.IDValue
}

// ID of the organizations owner.
// Example: 2
func (s *OrganizationOwnerImpl) SetID(v int) OrganizationOwner {
	if s == nil {
		return nil
	}
	s.IDValue = &v
	return s
}

// Name of the organizations owner.
// Example: admin
func (s OrganizationOwnerImpl) Name() *string {
	return s.NameValue
}

// Name of the organizations owner.
// Example: admin
func (s *OrganizationOwnerImpl) SetName(v string) OrganizationOwner {
	if s == nil {
		return nil
	}
	s.NameValue = &v
	return s
}

// NewOrganizationPermissions creates a new OrganizationPermissions instance
func NewOrganizationPermissions() OrganizationPermissions {
	return &OrganizationPermissionsImpl{}
}

// An indicator of whether the user has control over the persons list in organization.
// Example: true
func (s OrganizationPermissionsImpl) CanEditPersonsLists() *bool {
	return s.CanEditPersonsListsValue
}

// An indicator of whether the user has control over the persons list in organization.
// Example: true
func (s *OrganizationPermissionsImpl) SetCanEditPersonsLists(v bool) OrganizationPermissions {
	if s == nil {
		return nil
	}
	s.CanEditPersonsListsValue = &v
	return s
}

// An indicator of whether the user has control over the streams.
// Example: true
func (s OrganizationPermissionsImpl) CanEditStreams() *bool {
	return s.CanEditStreamsValue
}

// An indicator of whether the user has control over the streams.
// Example: true
func (s *OrganizationPermissionsImpl) SetCanEditStreams(v bool) OrganizationPermissions {
	if s == nil {
		return nil
	}
	s.CanEditStreamsValue = &v
	return s
}

// An indicator of whether the user has control over the users.
// Example: true
func (s OrganizationPermissionsImpl) CanEditUsers() *bool {
	return s.CanEditUsersValue
}

// An indicator of whether the user has control over the users.
// Example: true
func (s *OrganizationPermissionsImpl) SetCanEditUsers(v bool) OrganizationPermissions {
	if s == nil {
		return nil
	}
	s.CanEditUsersValue = &v
	return s
}

// An indicator of whether the user can view persons list in organization.
// Example: true
func (s OrganizationPermissionsImpl) CanViewPersonsLists() *bool {
	return s.CanViewPersonsListsValue
}

// An indicator of whether the user can view persons list in organization.
// Example: true
func (s *OrganizationPermissionsImpl) SetCanViewPersonsLists(v bool) OrganizationPermissions {
	if s == nil {
		return nil
	}
	s.CanViewPersonsListsValue = &v
	return s
}

// An indicator of whether the user can view statistics of organization.
// Example: true
func (s OrganizationPermissionsImpl) CanViewStats() *bool {
	return s.CanViewStatsValue
}

// An indicator of whether the user can view statistics of organization.
// Example: true
func (s *OrganizationPermissionsImpl) SetCanViewStats(v bool) OrganizationPermissions {
	if s == nil {
		return nil
	}
	s.CanViewStatsValue = &v
	return s
}

// An indicator of whether the user can view the streams.
// Example: true
func (s OrganizationPermissionsImpl) CanViewStreams() *bool {
	return s.CanViewStreamsValue
}

// An indicator of whether the user can view the streams.
// Example: true
func (s *OrganizationPermissionsImpl) SetCanViewStreams(v bool) OrganizationPermissions {
	if s == nil {
		return nil
	}
	s.CanViewStreamsValue = &v
	return s
}

// Is the user a member of the organization.
// Example: true
func (s OrganizationPermissionsImpl) IsMember() *bool {
	return s.IsMemberValue
}

// Is the user a member of the organization.
// Example: true
func (s *OrganizationPermissionsImpl) SetIsMember(v bool) OrganizationPermissions {
	if s == nil {
		return nil
	}
	s.IsMemberValue = &v
	return s
}

// NewOrganizationPickpoint creates a new OrganizationPickpoint instance
func NewOrganizationPickpoint() OrganizationPickpoint {
	return &OrganizationPickpointImpl{}
}

// NewOrganizationPreset creates a new OrganizationPreset instance
func NewOrganizationPreset() OrganizationPreset {
	return &OrganizationPresetImpl{}
}

// Preset identifier
// Example: 7
func (s OrganizationPresetImpl) PresetID() *int {
	return s.PresetIDValue
}

// Preset identifier
// Example: 7
func (s *OrganizationPresetImpl) SetPresetID(v int) OrganizationPreset {
	if s == nil {
		return nil
	}
	s.PresetIDValue = &v
	return s
}

// NewOrganizationStats creates a new OrganizationStats instance
func NewOrganizationStats() OrganizationStats {
	return &OrganizationStatsImpl{}
}

// Count of mosaics in organization.
// Example: 2
func (s OrganizationStatsImpl) Mosaics() *int {
	return s.MosaicsValue
}

// Count of mosaics in organization.
// Example: 2
func (s *OrganizationStatsImpl) SetMosaics(v int) OrganizationStats {
	if s == nil {
		return nil
	}
	s.MosaicsValue = &v
	return s
}

// Count of streams in organization.
// Example: 12
func (s OrganizationStatsImpl) Streams() *int {
	return s.StreamsValue
}

// Count of streams in organization.
// Example: 12
func (s *OrganizationStatsImpl) SetStreams(v int) OrganizationStats {
	if s == nil {
		return nil
	}
	s.StreamsValue = &v
	return s
}

// Count of users in organization.
// Example: 12
func (s OrganizationStatsImpl) Users() *int {
	return s.UsersValue
}

// Count of users in organization.
// Example: 12
func (s *OrganizationStatsImpl) SetUsers(v int) OrganizationStats {
	if s == nil {
		return nil
	}
	s.UsersValue = &v
	return s
}

// NewOrganizationStream creates a new OrganizationStream instance
func NewOrganizationStream() OrganizationStream {
	return &OrganizationStreamImpl{}
}

// ID of the organization. Only organization owner or domain administrator could change it.
// Example: 9
func (s OrganizationStreamImpl) ID() *int {
	return s.IDValue
}

// ID of the organization. Only organization owner or domain administrator could change it.
// Example: 9
func (s *OrganizationStreamImpl) SetID(v int) OrganizationStream {
	if s == nil {
		return nil
	}
	s.IDValue = &v
	return s
}

// Title of the organization.
// Example: Organization 1
func (s OrganizationStreamImpl) Title() *string {
	return s.TitleValue
}

// Title of the organization.
// Example: Organization 1
func (s *OrganizationStreamImpl) SetTitle(v string) OrganizationStream {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// NewOrganizationUser creates a new OrganizationUser instance
func NewOrganizationUser() OrganizationUser {
	return &OrganizationUserImpl{}
}

// User email
// Example: user@example.com
func (s OrganizationUserImpl) Email() *string {
	return s.EmailValue
}

// User email
// Example: user@example.com
func (s *OrganizationUserImpl) SetEmail(v string) OrganizationUser {
	if s == nil {
		return nil
	}
	s.EmailValue = &v
	return s
}

// User identifier
// Example: 7
func (s OrganizationUserImpl) ID() *int {
	return s.IDValue
}

// User identifier
// Example: 7
func (s *OrganizationUserImpl) SetID(v int) OrganizationUser {
	if s == nil {
		return nil
	}
	s.IDValue = &v
	return s
}

// User name
// Example: Example LLC
func (s OrganizationUserImpl) Name() *string {
	return s.NameValue
}

// User name
// Example: Example LLC
func (s *OrganizationUserImpl) SetName(v string) OrganizationUser {
	if s == nil {
		return nil
	}
	s.NameValue = &v
	return s
}

// User permissions
func (s OrganizationUserImpl) Permissions() OrganizationUserPermissions {
	return s.PermissionsValue
}

// User permissions
func (s *OrganizationUserImpl) SetPermissions(v OrganizationUserPermissions) OrganizationUser {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*OrganizationUserPermissionsImpl); ok {
		s.PermissionsValue = impl
	}
	return s
}

// NewOrganizationUserPermissions creates a new OrganizationUserPermissions instance
func NewOrganizationUserPermissions() OrganizationUserPermissions {
	return &OrganizationUserPermissionsImpl{}
}

// List of permissions in [Folders](https://flussonic.com/doc/api/watcher-client/#tag/folder)
func (s OrganizationUserPermissionsImpl) Folders() []any {
	return s.FoldersValue
}

// List of permissions in [Folders](https://flussonic.com/doc/api/watcher-client/#tag/folder)
func (s *OrganizationUserPermissionsImpl) SetFolders(v []any) OrganizationUserPermissions {
	if s == nil {
		return nil
	}
	s.FoldersValue = v
	return s
}

// User permissions in [Organization](https://flussonic.com/doc/api/watcher-client/#tag/organization)
func (s OrganizationUserPermissionsImpl) Organization() OrganizationPermissions {
	return s.OrganizationValue
}

// User permissions in [Organization](https://flussonic.com/doc/api/watcher-client/#tag/organization)
func (s *OrganizationUserPermissionsImpl) SetOrganization(v OrganizationPermissions) OrganizationUserPermissions {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*OrganizationPermissionsImpl); ok {
		s.OrganizationValue = impl
	}
	return s
}

// NewOrganizationUsersList creates a new OrganizationUsersList instance
func NewOrganizationUsersList() OrganizationUsersList {
	return &OrganizationUsersListImpl{}
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s OrganizationUsersListImpl) EstimatedCount() *int {
	return s.EstimatedCountValue
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s *OrganizationUsersListImpl) SetEstimatedCount(v int) OrganizationUsersList {
	if s == nil {
		return nil
	}
	s.EstimatedCountValue = &v
	return s
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s OrganizationUsersListImpl) Next() *string {
	return s.NextValue
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s *OrganizationUsersListImpl) SetNext(v string) OrganizationUsersList {
	if s == nil {
		return nil
	}
	s.NextValue = &v
	return s
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s OrganizationUsersListImpl) Prev() *string {
	return s.PrevValue
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s *OrganizationUsersListImpl) SetPrev(v string) OrganizationUsersList {
	if s == nil {
		return nil
	}
	s.PrevValue = &v
	return s
}

// An object with a list of different timings measured during this API call.
func (s OrganizationUsersListImpl) Timing() any {
	return s.TimingValue
}

// An object with a list of different timings measured during this API call.
func (s *OrganizationUsersListImpl) SetTiming(v any) OrganizationUsersList {
	if s == nil {
		return nil
	}
	s.TimingValue = v
	return s
}

// List of users in organizations.
func (s OrganizationUsersListImpl) Users() []OrganizationUser {
	if s.UsersValue == nil {
		return nil
	}
	result := make([]OrganizationUser, len(s.UsersValue))
	for i, item := range s.UsersValue {
		result[i] = item
	}
	return result
}

// List of users in organizations.
func (s *OrganizationUsersListImpl) SetUsers(v []OrganizationUser) OrganizationUsersList {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*OrganizationUserImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*OrganizationUserImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.UsersValue = impl
	}
	return s
}

// Collection returns the collection items from OrganizationUsersList
func (s OrganizationUsersListImpl) Collection() []OrganizationUser {
	return s.Users()
}

// NewOrganizationsList creates a new OrganizationsList instance
func NewOrganizationsList() OrganizationsList {
	return &OrganizationsListImpl{}
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s OrganizationsListImpl) EstimatedCount() *int {
	return s.EstimatedCountValue
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s *OrganizationsListImpl) SetEstimatedCount(v int) OrganizationsList {
	if s == nil {
		return nil
	}
	s.EstimatedCountValue = &v
	return s
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s OrganizationsListImpl) Next() *string {
	return s.NextValue
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s *OrganizationsListImpl) SetNext(v string) OrganizationsList {
	if s == nil {
		return nil
	}
	s.NextValue = &v
	return s
}

// List of organizations.
func (s OrganizationsListImpl) Organizations() []Organization {
	if s.OrganizationsValue == nil {
		return nil
	}
	result := make([]Organization, len(s.OrganizationsValue))
	for i, item := range s.OrganizationsValue {
		result[i] = item
	}
	return result
}

// List of organizations.
func (s *OrganizationsListImpl) SetOrganizations(v []Organization) OrganizationsList {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*OrganizationImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*OrganizationImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.OrganizationsValue = impl
	}
	return s
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s OrganizationsListImpl) Prev() *string {
	return s.PrevValue
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s *OrganizationsListImpl) SetPrev(v string) OrganizationsList {
	if s == nil {
		return nil
	}
	s.PrevValue = &v
	return s
}

// An object with a list of different timings measured during this API call.
func (s OrganizationsListImpl) Timing() any {
	return s.TimingValue
}

// An object with a list of different timings measured during this API call.
func (s *OrganizationsListImpl) SetTiming(v any) OrganizationsList {
	if s == nil {
		return nil
	}
	s.TimingValue = v
	return s
}

// Collection returns the collection items from OrganizationsList
func (s OrganizationsListImpl) Collection() []Organization {
	return s.Organizations()
}

// NewPasswordRecovery creates a new PasswordRecovery instance
func NewPasswordRecovery() PasswordRecovery {
	return &PasswordRecoveryImpl{}
}

// Email address to which instructions will be sent
// Format: email (email)
// Example: user@example.com
func (s PasswordRecoveryImpl) Email() *Email {
	return s.EmailValue
}

// Email address to which instructions will be sent
// Format: email (email)
// Example: user@example.com
func (s *PasswordRecoveryImpl) SetEmail(v Email) PasswordRecovery {
	if s == nil {
		return nil
	}
	s.EmailValue = &v
	return s
}

// NewPasswordReset creates a new PasswordReset instance
func NewPasswordReset() PasswordReset {
	return &PasswordResetImpl{}
}

// New password
func (s PasswordResetImpl) Password() *string {
	return s.PasswordValue
}

// New password
func (s *PasswordResetImpl) SetPassword(v string) PasswordReset {
	if s == nil {
		return nil
	}
	s.PasswordValue = &v
	return s
}

// NewPerson creates a new Person instance
func NewPerson() Person {
	return &PersonImpl{}
}

// When this person was marked as deleted
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637095014573e+12
func (s PersonImpl) DeletedAt() *UtcMs {
	return s.DeletedAtValue
}

// When this person was marked as deleted
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637095014573e+12
func (s *PersonImpl) SetDeletedAt(v UtcMs) Person {
	if s == nil {
		return nil
	}
	s.DeletedAtValue = &v
	return s
}

// Identifier of the person in the external system.
// Use it when supplying the recognition results further into the external system
// (e.g. for access level check) if the person identifiers in the external system
// are different from the ones in Flussonic Identification database.
// This field may contain `null` when video analytics detects a new person
// which explicitly has no association in the external system (i.e. if `originator=identification_service`).
// Examples: dedcc8e8
func (s PersonImpl) ExternalID() *string {
	return s.ExternalIDValue
}

// Identifier of the person in the external system.
// Use it when supplying the recognition results further into the external system
// (e.g. for access level check) if the person identifiers in the external system
// are different from the ones in Flussonic Identification database.
// This field may contain `null` when video analytics detects a new person
// which explicitly has no association in the external system (i.e. if `originator=identification_service`).
// Examples: dedcc8e8
func (s *PersonImpl) SetExternalID(v string) Person {
	if s == nil {
		return nil
	}
	s.ExternalIDValue = &v
	return s
}

// When this person was first seen
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637034282845e+12
func (s PersonImpl) FirstSeenAt() *UtcMs {
	return s.FirstSeenAtValue
}

// When this person was first seen
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637034282845e+12
func (s *PersonImpl) SetFirstSeenAt(v UtcMs) Person {
	if s == nil {
		return nil
	}
	s.FirstSeenAtValue = &v
	return s
}

// When this person was last seen
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637095014573e+12
func (s PersonImpl) LastSeenAt() *UtcMs {
	return s.LastSeenAtValue
}

// When this person was last seen
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637095014573e+12
func (s *PersonImpl) SetLastSeenAt(v UtcMs) Person {
	if s == nil {
		return nil
	}
	s.LastSeenAtValue = &v
	return s
}

// The name of the person filled in manually or automatically if not recognized
// Examples: John Doe, Unknown ABC
func (s PersonImpl) Name() *string {
	return s.NameValue
}

// The name of the person filled in manually or automatically if not recognized
// Examples: John Doe, Unknown ABC
func (s *PersonImpl) SetName(v string) Person {
	if s == nil {
		return nil
	}
	s.NameValue = &v
	return s
}

// Organization information.
func (s PersonImpl) Organization() OrganizationBase {
	return s.OrganizationValue
}

// Organization information.
func (s *PersonImpl) SetOrganization(v OrganizationBase) Person {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*OrganizationBaseImpl); ok {
		s.OrganizationValue = impl
	}
	return s
}

// Indicates the way this person was created:
// manually via an api or automatically in the identification service.
func (s PersonImpl) Originator() VisionPersonOriginator {
	return s.OriginatorValue
}

// Indicates the way this person was created:
// manually via an api or automatically in the identification service.
func (s *PersonImpl) SetOriginator(v VisionPersonOriginator) Person {
	if s == nil {
		return nil
	}
	s.OriginatorValue = v
	return s
}

// Identifier of the person
// Format: snowflake_id (snowflake_id)
// Examples: 7.036001172460667e+18
func (s PersonImpl) PersonID() SnowflakeID {
	return s.PersonIDValue
}

// Identifier of the person
// Format: snowflake_id (snowflake_id)
// Examples: 7.036001172460667e+18
func (s *PersonImpl) SetPersonID(v SnowflakeID) Person {
	if s == nil {
		return nil
	}
	s.PersonIDValue = v
	return s
}

// Person list details
func (s PersonImpl) PersonList() PersonPersonList {
	return s.PersonListValue
}

// Person list details
func (s *PersonImpl) SetPersonList(v PersonPersonList) Person {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*PersonPersonListImpl); ok {
		s.PersonListValue = impl
	}
	return s
}

// Person's photos. External system uploads images
// which are being processed by videoanalytics
// to get digital fingerprint of the person
func (s PersonImpl) Photos() []VisionImageAttributes {
	if s.PhotosValue == nil {
		return nil
	}
	result := make([]VisionImageAttributes, len(s.PhotosValue))
	for i, item := range s.PhotosValue {
		result[i] = item
	}
	return result
}

// Person's photos. External system uploads images
// which are being processed by videoanalytics
// to get digital fingerprint of the person
func (s *PersonImpl) SetPhotos(v []VisionImageAttributes) Person {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*VisionImageAttributesImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*VisionImageAttributesImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.PhotosValue = impl
	}
	return s
}

// When this person was last updated
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637034282845e+12
func (s PersonImpl) UpdatedAt() UtcMs {
	return s.UpdatedAtValue
}

// When this person was last updated
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637034282845e+12
func (s *PersonImpl) SetUpdatedAt(v UtcMs) Person {
	if s == nil {
		return nil
	}
	s.UpdatedAtValue = v
	return s
}

// NewPersonLists creates a new PersonLists instance
func NewPersonLists() PersonLists {
	return &PersonListsImpl{}
}

// Identifier of the person list.
// Example: 1
func (s PersonListsImpl) ID() *int {
	return s.IDValue
}

// Identifier of the person list.
// Example: 1
func (s *PersonListsImpl) SetID(v int) PersonLists {
	if s == nil {
		return nil
	}
	s.IDValue = &v
	return s
}

// The person list name.
// Example: List 1
func (s PersonListsImpl) Name() *string {
	return s.NameValue
}

// The person list name.
// Example: List 1
func (s *PersonListsImpl) SetName(v string) PersonLists {
	if s == nil {
		return nil
	}
	s.NameValue = &v
	return s
}

// Organization information.
func (s PersonListsImpl) Organization() OrganizationBase {
	return s.OrganizationValue
}

// Organization information.
func (s *PersonListsImpl) SetOrganization(v OrganizationBase) PersonLists {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*OrganizationBaseImpl); ok {
		s.OrganizationValue = impl
	}
	return s
}

// Counts elements in a list based on specific attributes.
func (s PersonListsImpl) Stats() PersonListsStats {
	return s.StatsValue
}

// Counts elements in a list based on specific attributes.
func (s *PersonListsImpl) SetStats(v PersonListsStats) PersonLists {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*PersonListsStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// NewPersonListsList creates a new PersonListsList instance
func NewPersonListsList() PersonListsList {
	return &PersonListsListImpl{}
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s PersonListsListImpl) EstimatedCount() *int {
	return s.EstimatedCountValue
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s *PersonListsListImpl) SetEstimatedCount(v int) PersonListsList {
	if s == nil {
		return nil
	}
	s.EstimatedCountValue = &v
	return s
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s PersonListsListImpl) Next() *string {
	return s.NextValue
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s *PersonListsListImpl) SetNext(v string) PersonListsList {
	if s == nil {
		return nil
	}
	s.NextValue = &v
	return s
}

// List of fetched person lists according to the query parameters.
func (s PersonListsListImpl) PersonLists() []PersonLists {
	if s.PersonListsValue == nil {
		return nil
	}
	result := make([]PersonLists, len(s.PersonListsValue))
	for i, item := range s.PersonListsValue {
		result[i] = item
	}
	return result
}

// List of fetched person lists according to the query parameters.
func (s *PersonListsListImpl) SetPersonLists(v []PersonLists) PersonListsList {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*PersonListsImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*PersonListsImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.PersonListsValue = impl
	}
	return s
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s PersonListsListImpl) Prev() *string {
	return s.PrevValue
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s *PersonListsListImpl) SetPrev(v string) PersonListsList {
	if s == nil {
		return nil
	}
	s.PrevValue = &v
	return s
}

// An object with a list of different timings measured during this API call.
func (s PersonListsListImpl) Timing() any {
	return s.TimingValue
}

// An object with a list of different timings measured during this API call.
func (s *PersonListsListImpl) SetTiming(v any) PersonListsList {
	if s == nil {
		return nil
	}
	s.TimingValue = v
	return s
}

// Collection returns the collection items from PersonListsList
func (s PersonListsListImpl) Collection() []PersonLists {
	return s.PersonLists()
}

// NewPersonListsStats creates a new PersonListsStats instance
func NewPersonListsStats() PersonListsStats {
	return &PersonListsStatsImpl{}
}

// The number of camera in the person list.
// Example: 1
func (s PersonListsStatsImpl) Camera() *int {
	return s.CameraValue
}

// The number of camera in the person list.
// Example: 1
func (s *PersonListsStatsImpl) SetCamera(v int) PersonListsStats {
	if s == nil {
		return nil
	}
	s.CameraValue = &v
	return s
}

// The number of person in the person list.
// Example: 1
func (s PersonListsStatsImpl) Person() *int {
	return s.PersonValue
}

// The number of person in the person list.
// Example: 1
func (s *PersonListsStatsImpl) SetPerson(v int) PersonListsStats {
	if s == nil {
		return nil
	}
	s.PersonValue = &v
	return s
}

// NewPersonPersonList creates a new PersonPersonList instance
func NewPersonPersonList() PersonPersonList {
	return &PersonPersonListImpl{}
}

// Person list identifier
// Example: 3
func (s PersonPersonListImpl) ID() *int {
	return s.IDValue
}

// Person list identifier
// Example: 3
func (s *PersonPersonListImpl) SetID(v int) PersonPersonList {
	if s == nil {
		return nil
	}
	s.IDValue = &v
	return s
}

// Person list name
// Example: List 1
func (s PersonPersonListImpl) Name() *string {
	return s.NameValue
}

// Person list name
// Example: List 1
func (s *PersonPersonListImpl) SetName(v string) PersonPersonList {
	if s == nil {
		return nil
	}
	s.NameValue = &v
	return s
}

// NewPersonsList creates a new PersonsList instance
func NewPersonsList() PersonsList {
	return &PersonsListImpl{}
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s PersonsListImpl) EstimatedCount() *int {
	return s.EstimatedCountValue
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s *PersonsListImpl) SetEstimatedCount(v int) PersonsList {
	if s == nil {
		return nil
	}
	s.EstimatedCountValue = &v
	return s
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s PersonsListImpl) Next() *string {
	return s.NextValue
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s *PersonsListImpl) SetNext(v string) PersonsList {
	if s == nil {
		return nil
	}
	s.NextValue = &v
	return s
}

// List of fetched persons according to the query parameters.
func (s PersonsListImpl) Persons() []VisionPerson {
	if s.PersonsValue == nil {
		return nil
	}
	result := make([]VisionPerson, len(s.PersonsValue))
	for i, item := range s.PersonsValue {
		result[i] = item
	}
	return result
}

// List of fetched persons according to the query parameters.
func (s *PersonsListImpl) SetPersons(v []VisionPerson) PersonsList {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*VisionPersonImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*VisionPersonImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.PersonsValue = impl
	}
	return s
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s PersonsListImpl) Prev() *string {
	return s.PrevValue
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s *PersonsListImpl) SetPrev(v string) PersonsList {
	if s == nil {
		return nil
	}
	s.PrevValue = &v
	return s
}

// An object with a list of different timings measured during this API call.
func (s PersonsListImpl) Timing() any {
	return s.TimingValue
}

// An object with a list of different timings measured during this API call.
func (s *PersonsListImpl) SetTiming(v any) PersonsList {
	if s == nil {
		return nil
	}
	s.TimingValue = v
	return s
}

// Collection returns the collection items from PersonsList
func (s PersonsListImpl) Collection() []VisionPerson {
	return s.Persons()
}

// NewPreset creates a new Preset instance
func NewPreset() Preset {
	return &PresetImpl{}
}

// DVR configuration
func (s PresetImpl) Dvr() StreamDvrSpec {
	return s.DvrValue
}

// DVR configuration
func (s *PresetImpl) SetDvr(v StreamDvrSpec) Preset {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*StreamDvrSpecImpl); ok {
		s.DvrValue = impl
	}
	return s
}

// Preset identifier
// Example: 7
func (s PresetImpl) ID() int {
	return s.IDValue
}

// Preset identifier
// Example: 7
func (s *PresetImpl) SetID(v int) Preset {
	if s == nil {
		return nil
	}
	s.IDValue = v
	return s
}

// Shows if the preset is adjustable.
// ```is_adjustable``` is needed for a situation where presets are managed by external billing.
// If ```is_adjustable: true``` user can change camera settings meanwhile using this preset.
// If ```is_adjustable: false``` user can not change camera settings meanwhile using this preset.
// If the camera has a non-adjustable presets, the DVR and analytics parameters from PUT requests will not be applied.
// In this case, either make the preset adjustable, or change the preset itself to achieve the required configuration.
// Example: true
func (s PresetImpl) IsAdjustable() *bool {
	return s.IsAdjustableValue
}

// Shows if the preset is adjustable.
// ```is_adjustable``` is needed for a situation where presets are managed by external billing.
// If ```is_adjustable: true``` user can change camera settings meanwhile using this preset.
// If ```is_adjustable: false``` user can not change camera settings meanwhile using this preset.
// If the camera has a non-adjustable presets, the DVR and analytics parameters from PUT requests will not be applied.
// In this case, either make the preset adjustable, or change the preset itself to achieve the required configuration.
// Example: true
func (s *PresetImpl) SetIsAdjustable(v bool) Preset {
	if s == nil {
		return nil
	}
	s.IsAdjustableValue = &v
	return s
}

// Shows if the preset is available in all Organizations.
func (s PresetImpl) IsDefault() *bool {
	return s.IsDefaultValue
}

// Shows if the preset is available in all Organizations.
func (s *PresetImpl) SetIsDefault(v bool) Preset {
	if s == nil {
		return nil
	}
	s.IsDefaultValue = &v
	return s
}

// Information about the latest changes made to the preset configuration.
func (s PresetImpl) LastChange() PresetLastChange {
	return s.LastChangeValue
}

// Information about the latest changes made to the preset configuration.
func (s *PresetImpl) SetLastChange(v PresetLastChange) Preset {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*PresetLastChangeImpl); ok {
		s.LastChangeValue = impl
	}
	return s
}

// Statistics of the preset.
func (s PresetImpl) Stats() PresetStats {
	return s.StatsValue
}

// Statistics of the preset.
func (s *PresetImpl) SetStats(v PresetStats) Preset {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*PresetStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// Human-readable name of the preset.
// Example: Example preset name
func (s PresetImpl) Title() string {
	return s.TitleValue
}

// Human-readable name of the preset.
// Example: Example preset name
func (s *PresetImpl) SetTitle(v string) Preset {
	if s == nil {
		return nil
	}
	s.TitleValue = v
	return s
}

// Vision configuration
func (s PresetImpl) Vision() VisionSpecPresets {
	return s.VisionValue
}

// Vision configuration
func (s *PresetImpl) SetVision(v VisionSpecPresets) Preset {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionSpecPresetsImpl); ok {
		s.VisionValue = impl
	}
	return s
}

// NewPresetLastChange creates a new PresetLastChange instance
func NewPresetLastChange() PresetLastChange {
	return &PresetLastChangeImpl{}
}

// The time when the last changes were made.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.672531199e+12
func (s PresetLastChangeImpl) UpdatedAt() *UtcMs {
	return s.UpdatedAtValue
}

// The time when the last changes were made.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.672531199e+12
func (s *PresetLastChangeImpl) SetUpdatedAt(v UtcMs) PresetLastChange {
	if s == nil {
		return nil
	}
	s.UpdatedAtValue = &v
	return s
}

// Information about the user who modified.
func (s PresetLastChangeImpl) User() PresetLastChangeUser {
	return s.UserValue
}

// Information about the user who modified.
func (s *PresetLastChangeImpl) SetUser(v PresetLastChangeUser) PresetLastChange {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*PresetLastChangeUserImpl); ok {
		s.UserValue = impl
	}
	return s
}

// NewPresetLastChangeUser creates a new PresetLastChangeUser instance
func NewPresetLastChangeUser() PresetLastChangeUser {
	return &PresetLastChangeUserImpl{}
}

// Identifier of the user.
// Example: 1
func (s PresetLastChangeUserImpl) ID() *int {
	return s.IDValue
}

// Identifier of the user.
// Example: 1
func (s *PresetLastChangeUserImpl) SetID(v int) PresetLastChangeUser {
	if s == nil {
		return nil
	}
	s.IDValue = &v
	return s
}

// User name (login)
// Example: admin
func (s PresetLastChangeUserImpl) Name() *string {
	return s.NameValue
}

// User name (login)
// Example: admin
func (s *PresetLastChangeUserImpl) SetName(v string) PresetLastChangeUser {
	if s == nil {
		return nil
	}
	s.NameValue = &v
	return s
}

// NewPresetStats creates a new PresetStats instance
func NewPresetStats() PresetStats {
	return &PresetStatsImpl{}
}

// Count of organizations are currently using this preset.
// Example: 12
func (s PresetStatsImpl) OrganizationsCount() *int {
	return s.OrganizationsCountValue
}

// Count of organizations are currently using this preset.
// Example: 12
func (s *PresetStatsImpl) SetOrganizationsCount(v int) PresetStats {
	if s == nil {
		return nil
	}
	s.OrganizationsCountValue = &v
	return s
}

// Count of streams are currently using this preset.
// Example: 12
func (s PresetStatsImpl) StreamsCount() *int {
	return s.StreamsCountValue
}

// Count of streams are currently using this preset.
// Example: 12
func (s *PresetStatsImpl) SetStreamsCount(v int) PresetStats {
	if s == nil {
		return nil
	}
	s.StreamsCountValue = &v
	return s
}

// NewPresetsList creates a new PresetsList instance
func NewPresetsList() PresetsList {
	return &PresetsListImpl{}
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s PresetsListImpl) EstimatedCount() *int {
	return s.EstimatedCountValue
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s *PresetsListImpl) SetEstimatedCount(v int) PresetsList {
	if s == nil {
		return nil
	}
	s.EstimatedCountValue = &v
	return s
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s PresetsListImpl) Next() *string {
	return s.NextValue
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s *PresetsListImpl) SetNext(v string) PresetsList {
	if s == nil {
		return nil
	}
	s.NextValue = &v
	return s
}

// List of presets.
func (s PresetsListImpl) Presets() []Preset {
	if s.PresetsValue == nil {
		return nil
	}
	result := make([]Preset, len(s.PresetsValue))
	for i, item := range s.PresetsValue {
		result[i] = item
	}
	return result
}

// List of presets.
func (s *PresetsListImpl) SetPresets(v []Preset) PresetsList {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*PresetImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*PresetImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.PresetsValue = impl
	}
	return s
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s PresetsListImpl) Prev() *string {
	return s.PrevValue
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s *PresetsListImpl) SetPrev(v string) PresetsList {
	if s == nil {
		return nil
	}
	s.PrevValue = &v
	return s
}

// An object with a list of different timings measured during this API call.
func (s PresetsListImpl) Timing() any {
	return s.TimingValue
}

// An object with a list of different timings measured during this API call.
func (s *PresetsListImpl) SetTiming(v any) PresetsList {
	if s == nil {
		return nil
	}
	s.TimingValue = v
	return s
}

// Collection returns the collection items from PresetsList
func (s PresetsListImpl) Collection() []Preset {
	return s.Presets()
}

// NewProfile creates a new Profile instance
func NewProfile() Profile {
	return &ProfileImpl{}
}

// Apikey for users access via API.
func (s ProfileImpl) Apikey() *string {
	return s.ApikeyValue
}

// Apikey for users access via API.
func (s *ProfileImpl) SetApikey(v string) Profile {
	if s == nil {
		return nil
	}
	s.ApikeyValue = &v
	return s
}

// The date and time when the user was created.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.672531199e+12
func (s ProfileImpl) CreatedAt() *UtcMs {
	return s.CreatedAtValue
}

// The date and time when the user was created.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.672531199e+12
func (s *ProfileImpl) SetCreatedAt(v UtcMs) Profile {
	if s == nil {
		return nil
	}
	s.CreatedAtValue = &v
	return s
}

// User's email. Required for password recovery.
// Format: email (email)
// Example: user@example.com
func (s ProfileImpl) Email() *Email {
	return s.EmailValue
}

// User's email. Required for password recovery.
// Format: email (email)
// Example: user@example.com
func (s *ProfileImpl) SetEmail(v Email) Profile {
	if s == nil {
		return nil
	}
	s.EmailValue = &v
	return s
}

// The user's full name.
func (s ProfileImpl) Fullname() *string {
	return s.FullnameValue
}

// The user's full name.
func (s *ProfileImpl) SetFullname(v string) Profile {
	if s == nil {
		return nil
	}
	s.FullnameValue = &v
	return s
}

// Indicates that user has access_level equal "admin".
func (s ProfileImpl) IsAdmin() *bool {
	return s.IsAdminValue
}

// Indicates that user has access_level equal "admin".
func (s *ProfileImpl) SetIsAdmin(v bool) Profile {
	if s == nil {
		return nil
	}
	s.IsAdminValue = &v
	return s
}

// Indicates that user has access_level equal "domain admin".
func (s ProfileImpl) IsDomainAdmin() *bool {
	return s.IsDomainAdminValue
}

// Indicates that user has access_level equal "domain admin".
func (s *ProfileImpl) SetIsDomainAdmin(v bool) Profile {
	if s == nil {
		return nil
	}
	s.IsDomainAdminValue = &v
	return s
}

// Indicates that the user has a read-only access level.
// Example: true
func (s ProfileImpl) IsReadonly() *bool {
	return s.IsReadonlyValue
}

// Indicates that the user has a read-only access level.
// Example: true
func (s *ProfileImpl) SetIsReadonly(v bool) Profile {
	if s == nil {
		return nil
	}
	s.IsReadonlyValue = &v
	return s
}

// The language, selected by user.
// Format: ISO 639-1
// Example: en
func (s ProfileImpl) Locale() *ISO6391 {
	return s.LocaleValue
}

// The language, selected by user.
// Format: ISO 639-1
// Example: en
func (s *ProfileImpl) SetLocale(v ISO6391) Profile {
	if s == nil {
		return nil
	}
	s.LocaleValue = &v
	return s
}

// The maximum number of sessions the user can have simultaneously.
func (s ProfileImpl) MaxSessions() *int {
	return s.MaxSessionsValue
}

// The maximum number of sessions the user can have simultaneously.
func (s *ProfileImpl) SetMaxSessions(v int) Profile {
	if s == nil {
		return nil
	}
	s.MaxSessionsValue = &v
	return s
}

// User name (login)
func (s ProfileImpl) Name() *string {
	return s.NameValue
}

// User name (login)
func (s *ProfileImpl) SetName(v string) Profile {
	if s == nil {
		return nil
	}
	s.NameValue = &v
	return s
}

// Additional information or notes about the user.
func (s ProfileImpl) Note() *string {
	return s.NoteValue
}

// Additional information or notes about the user.
func (s *ProfileImpl) SetNote(v string) Profile {
	if s == nil {
		return nil
	}
	s.NoteValue = &v
	return s
}

// The specified password will be saved as a hash, used only for writing
func (s ProfileImpl) Password() *string {
	return s.PasswordValue
}

// The specified password will be saved as a hash, used only for writing
func (s *ProfileImpl) SetPassword(v string) Profile {
	if s == nil {
		return nil
	}
	s.PasswordValue = &v
	return s
}

// User's phone number
// Format: phone-number (phone-number)
// Example: +78007778413
func (s ProfileImpl) Phone() *PhoneNumber {
	return s.PhoneValue
}

// User's phone number
// Format: phone-number (phone-number)
// Example: +78007778413
func (s *ProfileImpl) SetPhone(v PhoneNumber) Profile {
	if s == nil {
		return nil
	}
	s.PhoneValue = &v
	return s
}

// NewPtzCommand creates a new PtzCommand instance
func NewPtzCommand() PtzCommand {
	return &PtzCommandImpl{}
}

// start PTZ continuous move
// Example: move_continuous
func (s PtzCommandImpl) Command() *string {
	return s.CommandValue
}

// start PTZ continuous move
// Example: move_continuous
func (s *PtzCommandImpl) SetCommand(v string) PtzCommand {
	if s == nil {
		return nil
	}
	s.CommandValue = &v
	return s
}

// Speed to move the camera down. Percentage of the maximum pan speed.
// Example: 50
func (s PtzCommandImpl) Down() *int {
	return s.DownValue
}

// Speed to move the camera down. Percentage of the maximum pan speed.
// Example: 50
func (s *PtzCommandImpl) SetDown(v int) PtzCommand {
	if s == nil {
		return nil
	}
	s.DownValue = &v
	return s
}

// Speed to zoom in the camera. Percentage of the maximum zoom speed.
// Example: 20
func (s PtzCommandImpl) In() *int {
	return s.InValue
}

// Speed to zoom in the camera. Percentage of the maximum zoom speed.
// Example: 20
func (s *PtzCommandImpl) SetIn(v int) PtzCommand {
	if s == nil {
		return nil
	}
	s.InValue = &v
	return s
}

// Speed to move the camera left. Percentage of the maximum tilt speed.
// Example: 50
func (s PtzCommandImpl) Left() *int {
	return s.LeftValue
}

// Speed to move the camera left. Percentage of the maximum tilt speed.
// Example: 50
func (s *PtzCommandImpl) SetLeft(v int) PtzCommand {
	if s == nil {
		return nil
	}
	s.LeftValue = &v
	return s
}

// Speed to zoom out the camera. Percentage of the maximum zoom speed.
// Example: 0
func (s PtzCommandImpl) Out() *int {
	return s.OutValue
}

// Speed to zoom out the camera. Percentage of the maximum zoom speed.
// Example: 0
func (s *PtzCommandImpl) SetOut(v int) PtzCommand {
	if s == nil {
		return nil
	}
	s.OutValue = &v
	return s
}

// Speed to move the camera right. Percentage of the maximum tilt speed.
// Example: 0
func (s PtzCommandImpl) Right() *int {
	return s.RightValue
}

// Speed to move the camera right. Percentage of the maximum tilt speed.
// Example: 0
func (s *PtzCommandImpl) SetRight(v int) PtzCommand {
	if s == nil {
		return nil
	}
	s.RightValue = &v
	return s
}

// Speed to move the camera up. Percentage of the maximum pan speed.
// Example: 0
func (s PtzCommandImpl) Up() *int {
	return s.UpValue
}

// Speed to move the camera up. Percentage of the maximum pan speed.
// Example: 0
func (s *PtzCommandImpl) SetUp(v int) PtzCommand {
	if s == nil {
		return nil
	}
	s.UpValue = &v
	return s
}

// NewPtzMoveContinuous creates a new PtzMoveContinuous instance
func NewPtzMoveContinuous() PtzMoveContinuous {
	return &PtzMoveContinuousImpl{}
}

// start PTZ continuous move
// Example: move_continuous
func (s PtzMoveContinuousImpl) Command() *string {
	return s.CommandValue
}

// start PTZ continuous move
// Example: move_continuous
func (s *PtzMoveContinuousImpl) SetCommand(v string) PtzMoveContinuous {
	if s == nil {
		return nil
	}
	s.CommandValue = &v
	return s
}

// Speed to move the camera down. Percentage of the maximum pan speed.
// Example: 50
func (s PtzMoveContinuousImpl) Down() *int {
	return s.DownValue
}

// Speed to move the camera down. Percentage of the maximum pan speed.
// Example: 50
func (s *PtzMoveContinuousImpl) SetDown(v int) PtzMoveContinuous {
	if s == nil {
		return nil
	}
	s.DownValue = &v
	return s
}

// Speed to zoom in the camera. Percentage of the maximum zoom speed.
// Example: 20
func (s PtzMoveContinuousImpl) In() *int {
	return s.InValue
}

// Speed to zoom in the camera. Percentage of the maximum zoom speed.
// Example: 20
func (s *PtzMoveContinuousImpl) SetIn(v int) PtzMoveContinuous {
	if s == nil {
		return nil
	}
	s.InValue = &v
	return s
}

// Speed to move the camera left. Percentage of the maximum tilt speed.
// Example: 50
func (s PtzMoveContinuousImpl) Left() *int {
	return s.LeftValue
}

// Speed to move the camera left. Percentage of the maximum tilt speed.
// Example: 50
func (s *PtzMoveContinuousImpl) SetLeft(v int) PtzMoveContinuous {
	if s == nil {
		return nil
	}
	s.LeftValue = &v
	return s
}

// Speed to zoom out the camera. Percentage of the maximum zoom speed.
// Example: 0
func (s PtzMoveContinuousImpl) Out() *int {
	return s.OutValue
}

// Speed to zoom out the camera. Percentage of the maximum zoom speed.
// Example: 0
func (s *PtzMoveContinuousImpl) SetOut(v int) PtzMoveContinuous {
	if s == nil {
		return nil
	}
	s.OutValue = &v
	return s
}

// Speed to move the camera right. Percentage of the maximum tilt speed.
// Example: 0
func (s PtzMoveContinuousImpl) Right() *int {
	return s.RightValue
}

// Speed to move the camera right. Percentage of the maximum tilt speed.
// Example: 0
func (s *PtzMoveContinuousImpl) SetRight(v int) PtzMoveContinuous {
	if s == nil {
		return nil
	}
	s.RightValue = &v
	return s
}

// Speed to move the camera up. Percentage of the maximum pan speed.
// Example: 0
func (s PtzMoveContinuousImpl) Up() *int {
	return s.UpValue
}

// Speed to move the camera up. Percentage of the maximum pan speed.
// Example: 0
func (s *PtzMoveContinuousImpl) SetUp(v int) PtzMoveContinuous {
	if s == nil {
		return nil
	}
	s.UpValue = &v
	return s
}

// NewRTPCountersBase creates a new RTPCountersBase instance
func NewRTPCountersBase() RTPCountersBase {
	return &RTPCountersBaseImpl{}
}

// How many bytes received for this channel
func (s RTPCountersBaseImpl) Bytes() *int {
	return s.BytesValue
}

// How many bytes received for this channel
func (s *RTPCountersBaseImpl) SetBytes(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.BytesValue = &v
	return s
}

// RTP channel number
// Example: 0
func (s RTPCountersBaseImpl) ChannelID() int {
	return s.ChannelIDValue
}

// RTP channel number
// Example: 0
func (s *RTPCountersBaseImpl) SetChannelID(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.ChannelIDValue = v
	return s
}

// Content of the track transmitted in the channel
// Example: video
func (s RTPCountersBaseImpl) Content() *string {
	return s.ContentValue
}

// Content of the track transmitted in the channel
// Example: video
func (s *RTPCountersBaseImpl) SetContent(v string) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.ContentValue = &v
	return s
}

// Demultiplexing was done right, but content is broken.
func (s RTPCountersBaseImpl) ErrorsBrokenPayload() *int {
	return s.ErrorsBrokenPayloadValue
}

// Demultiplexing was done right, but content is broken.
func (s *RTPCountersBaseImpl) SetErrorsBrokenPayload(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.ErrorsBrokenPayloadValue = &v
	return s
}

// Number of frames which dts is same as previous frame dts.
func (s RTPCountersBaseImpl) ErrorsDtsStuck() *int {
	return s.ErrorsDtsStuckValue
}

// Number of frames which dts is same as previous frame dts.
func (s *RTPCountersBaseImpl) SetErrorsDtsStuck(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.ErrorsDtsStuckValue = &v
	return s
}

// RTP have enough information to tell how many packets were lost
func (s RTPCountersBaseImpl) ErrorsLostPackets() *int {
	return s.ErrorsLostPacketsValue
}

// RTP have enough information to tell how many packets were lost
func (s *RTPCountersBaseImpl) SetErrorsLostPackets(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.ErrorsLostPacketsValue = &v
	return s
}

// How many frames received for this channel
func (s RTPCountersBaseImpl) Frames() *int {
	return s.FramesValue
}

// How many frames received for this channel
func (s *RTPCountersBaseImpl) SetFrames(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.FramesValue = &v
	return s
}

// Number of RTP packets which marker bit is set to one.
func (s RTPCountersBaseImpl) MarkerPacketsCount() *int {
	return s.MarkerPacketsCountValue
}

// Number of RTP packets which marker bit is set to one.
func (s *RTPCountersBaseImpl) SetMarkerPacketsCount(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.MarkerPacketsCountValue = &v
	return s
}

// How many NACK messages are sent for this channel
func (s RTPCountersBaseImpl) NackCount() *int {
	return s.NackCountValue
}

// How many NACK messages are sent for this channel
func (s *RTPCountersBaseImpl) SetNackCount(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.NackCountValue = &v
	return s
}

// If no marker bit packet is received after 400 RTP packets then decoder switches to `no_marker_mode` and
// makes frame on each timecode change.
// This flag shows if decoder works in `no_marker_mode`.
func (s RTPCountersBaseImpl) NoMarkerModeFlag() *bool {
	return s.NoMarkerModeFlagValue
}

// If no marker bit packet is received after 400 RTP packets then decoder switches to `no_marker_mode` and
// makes frame on each timecode change.
// This flag shows if decoder works in `no_marker_mode`.
func (s *RTPCountersBaseImpl) SetNoMarkerModeFlag(v bool) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.NoMarkerModeFlagValue = &v
	return s
}

// Number of rtp packets rejected due to wrong payload type
func (s RTPCountersBaseImpl) PtRejectCount() *int {
	return s.PtRejectCountValue
}

// Number of rtp packets rejected due to wrong payload type
func (s *RTPCountersBaseImpl) SetPtRejectCount(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.PtRejectCountValue = &v
	return s
}

// Total size of rejected packets due to wrong payload type (pt_reject_count) rtp packets
func (s RTPCountersBaseImpl) PtRejectSum() *int {
	return s.PtRejectSumValue
}

// Total size of rejected packets due to wrong payload type (pt_reject_count) rtp packets
func (s *RTPCountersBaseImpl) SetPtRejectSum(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.PtRejectSumValue = &v
	return s
}

// How many RTCP packets received for this channel
func (s RTPCountersBaseImpl) RtcpPackets() *int {
	return s.RtcpPacketsValue
}

// How many RTCP packets received for this channel
func (s *RTPCountersBaseImpl) SetRtcpPackets(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.RtcpPacketsValue = &v
	return s
}

// How many RTP packets received for this channel
func (s RTPCountersBaseImpl) RTPPackets() *int {
	return s.RTPPacketsValue
}

// How many RTP packets received for this channel
func (s *RTPCountersBaseImpl) SetRTPPackets(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.RTPPacketsValue = &v
	return s
}

// Sender wallclock deviation from server time in ms. Positive value means that sender time is ahead of server time.
func (s RTPCountersBaseImpl) SenderClockDeviation() *int {
	return s.SenderClockDeviationValue
}

// Sender wallclock deviation from server time in ms. Positive value means that sender time is ahead of server time.
func (s *RTPCountersBaseImpl) SetSenderClockDeviation(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.SenderClockDeviationValue = &v
	return s
}

// Number of rtcp SR packets which `RTP timestamp` is equal to the previous rtcp SR packet `RTP timestamp`.
func (s RTPCountersBaseImpl) SrTSStuck() *int {
	return s.SrTSStuckValue
}

// Number of rtcp SR packets which `RTP timestamp` is equal to the previous rtcp SR packet `RTP timestamp`.
func (s *RTPCountersBaseImpl) SetSrTSStuck(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.SrTSStuckValue = &v
	return s
}

// Time on this channel is jumped back from reference wallclock.
func (s RTPCountersBaseImpl) TSGoesBackwards() *int {
	return s.TSGoesBackwardsValue
}

// Time on this channel is jumped back from reference wallclock.
func (s *RTPCountersBaseImpl) SetTSGoesBackwards(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.TSGoesBackwardsValue = &v
	return s
}

// Time on this channel is jumped forward from reference wallclock.
func (s RTPCountersBaseImpl) TSJumpForward() *int {
	return s.TSJumpForwardValue
}

// Time on this channel is jumped forward from reference wallclock.
func (s *RTPCountersBaseImpl) SetTSJumpForward(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.TSJumpForwardValue = &v
	return s
}

// https://datatracker.ietf.org/doc/html/rfc6184#section-4.1
// access unit: A set of NAL units always containing a primary coded picture.  In addition to the primary coded
// picture, an access unit may also contain one or more redundant coded pictures or other NAL units not containing
// slices or slice data partitions of a coded picture.  The decoding of an access unit always results in a
// decoded picture.
// There is `marker bit` in RTP packet which is set for the very last packet of the access unit indicated by the RTP timestamp.
// It is protocol violation if received RTP packet has the same timestamp as previous marker bit packet.
// This counter is a number of RTP packets which `RTP timestamp` is equal to previous RTP marker bit packet.
func (s RTPCountersBaseImpl) TSStuck() *int {
	return s.TSStuckValue
}

// https://datatracker.ietf.org/doc/html/rfc6184#section-4.1
// access unit: A set of NAL units always containing a primary coded picture.  In addition to the primary coded
// picture, an access unit may also contain one or more redundant coded pictures or other NAL units not containing
// slices or slice data partitions of a coded picture.  The decoding of an access unit always results in a
// decoded picture.
// There is `marker bit` in RTP packet which is set for the very last packet of the access unit indicated by the RTP timestamp.
// It is protocol violation if received RTP packet has the same timestamp as previous marker bit packet.
// This counter is a number of RTP packets which `RTP timestamp` is equal to previous RTP marker bit packet.
func (s *RTPCountersBaseImpl) SetTSStuck(v int) RTPCountersBase {
	if s == nil {
		return nil
	}
	s.TSStuckValue = &v
	return s
}

// NewSensor creates a new Sensor instance
func NewSensor() Sensor {
	return &SensorImpl{}
}

// Image blacklight compensation correction
func (s SensorImpl) BlacklightCompensation() OnOff {
	return s.BlacklightCompensationValue
}

// Image blacklight compensation correction
func (s *SensorImpl) SetBlacklightCompensation(v OnOff) Sensor {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*OnOffImpl); ok {
		s.BlacklightCompensationValue = impl
	}
	return s
}

// Image brightness correction.
// The value is indicated as a percentage from 0 to 100.
// Format: percent (percent)
func (s SensorImpl) BrightnessCorrection() *Percent {
	return s.BrightnessCorrectionValue
}

// Image brightness correction.
// The value is indicated as a percentage from 0 to 100.
// Format: percent (percent)
func (s *SensorImpl) SetBrightnessCorrection(v Percent) Sensor {
	if s == nil {
		return nil
	}
	s.BrightnessCorrectionValue = &v
	return s
}

// Image contrast correction.
// The value is indicated as a percentage from 0 to 100.
// Format: percent (percent)
func (s SensorImpl) ContrastCorrection() *Percent {
	return s.ContrastCorrectionValue
}

// Image contrast correction.
// The value is indicated as a percentage from 0 to 100.
// Format: percent (percent)
func (s *SensorImpl) SetContrastCorrection(v Percent) Sensor {
	if s == nil {
		return nil
	}
	s.ContrastCorrectionValue = &v
	return s
}

// Installation position of the camera
func (s SensorImpl) ImageOrientation() *SensorImageOrientation {
	return s.ImageOrientationValue
}

// Installation position of the camera
func (s *SensorImpl) SetImageOrientation(v SensorImageOrientation) Sensor {
	if s == nil {
		return nil
	}
	s.ImageOrientationValue = &v
	return s
}

// Infrared cut-of filter
func (s SensorImpl) InfraredCutoffFilter() OnOffAuto {
	return s.InfraredCutoffFilterValue
}

// Infrared cut-of filter
func (s *SensorImpl) SetInfraredCutoffFilter(v OnOffAuto) Sensor {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*OnOffAutoImpl); ok {
		s.InfraredCutoffFilterValue = impl
	}
	return s
}

// Image saturation correction.
// The value is indicated as a percentage from 0 to 100.
// Format: percent (percent)
func (s SensorImpl) Saturation() *Percent {
	return s.SaturationValue
}

// Image saturation correction.
// The value is indicated as a percentage from 0 to 100.
// Format: percent (percent)
func (s *SensorImpl) SetSaturation(v Percent) Sensor {
	if s == nil {
		return nil
	}
	s.SaturationValue = &v
	return s
}

// Sharpness / edges contrast enhancement level.
// The value is indicated as a percentage from 0 to 100.
// Format: percent (percent)
func (s SensorImpl) Sharpness() *Percent {
	return s.SharpnessValue
}

// Sharpness / edges contrast enhancement level.
// The value is indicated as a percentage from 0 to 100.
// Format: percent (percent)
func (s *SensorImpl) SetSharpness(v Percent) Sensor {
	if s == nil {
		return nil
	}
	s.SharpnessValue = &v
	return s
}

// Image wide dynamic range correction.
// The value is indicated as a percentage from 0 to 100.
// Format: percent (percent)
func (s SensorImpl) WideDynamicRange() *Percent {
	return s.WideDynamicRangeValue
}

// Image wide dynamic range correction.
// The value is indicated as a percentage from 0 to 100.
// Format: percent (percent)
func (s *SensorImpl) SetWideDynamicRange(v Percent) Sensor {
	if s == nil {
		return nil
	}
	s.WideDynamicRangeValue = &v
	return s
}

// NewStreamBaseStreamPermissions creates a new StreamBaseStreamPermissions instance
func NewStreamBaseStreamPermissions() StreamBaseStreamPermissions {
	return &StreamBaseStreamPermissionsImpl{}
}

// Stream name
func (s StreamBaseStreamPermissionsImpl) Name() *string {
	return s.NameValue
}

// Stream name
func (s *StreamBaseStreamPermissionsImpl) SetName(v string) StreamBaseStreamPermissions {
	if s == nil {
		return nil
	}
	s.NameValue = &v
	return s
}

// NewStreamConfig creates a new StreamConfig instance
func NewStreamConfig() StreamConfig {
	return &StreamConfigImpl{}
}

// Audio settings for the stream.
func (s StreamConfigImpl) Audio() WatcherStreamConfigAudio {
	return s.AudioValue
}

// Audio settings for the stream.
func (s *StreamConfigImpl) SetAudio(v WatcherStreamConfigAudio) StreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*WatcherStreamConfigAudioImpl); ok {
		s.AudioValue = impl
	}
	return s
}

// A publishable stream.
// Example: false
func (s StreamConfigImpl) CanPublish() *bool {
	return s.CanPublishValue
}

// A publishable stream.
// Example: false
func (s *StreamConfigImpl) SetCanPublish(v bool) StreamConfig {
	if s == nil {
		return nil
	}
	s.CanPublishValue = &v
	return s
}

// Human-readable description of the stream.
// Example: This is a test stream
func (s StreamConfigImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the stream.
// Example: This is a test stream
func (s *StreamConfigImpl) SetComment(v string) StreamConfig {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Camera coordinates on a map or a floor plan.
func (s StreamConfigImpl) Coordinates() MapSpec {
	return s.CoordinatesValue
}

// Camera coordinates on a map or a floor plan.
func (s *StreamConfigImpl) SetCoordinates(v MapSpec) StreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*MapSpecImpl); ok {
		s.CoordinatesValue = impl
	}
	return s
}

// The date and time when the steam was created.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.672531199e+12
func (s StreamConfigImpl) CreatedAt() *UtcMs {
	return s.CreatedAtValue
}

// The date and time when the steam was created.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.672531199e+12
func (s *StreamConfigImpl) SetCreatedAt(v UtcMs) StreamConfig {
	if s == nil {
		return nil
	}
	s.CreatedAtValue = &v
	return s
}

// Whether a stream is disabled. Disabled streams are inactive and do not run.
// Displayed only with the API calls.
// Example: false
func (s StreamConfigImpl) Disabled() *bool {
	return s.DisabledValue
}

// Whether a stream is disabled. Disabled streams are inactive and do not run.
// Displayed only with the API calls.
// Example: false
func (s *StreamConfigImpl) SetDisabled(v bool) StreamConfig {
	if s == nil {
		return nil
	}
	s.DisabledValue = &v
	return s
}

// DVR configuraton.
func (s StreamConfigImpl) Dvr() StreamDvrSpec {
	return s.DvrValue
}

// DVR configuraton.
func (s *StreamConfigImpl) SetDvr(v StreamDvrSpec) StreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*StreamDvrSpecImpl); ok {
		s.DvrValue = impl
	}
	return s
}

// Duration of the firmware update. If this field is present, the update process is ongoing.
// Format: milliseconds (milliseconds)
func (s StreamConfigImpl) FirmwareUpdateDuration() *Milliseconds {
	return s.FirmwareUpdateDurationValue
}

// Duration of the firmware update. If this field is present, the update process is ongoing.
// Format: milliseconds (milliseconds)
func (s *StreamConfigImpl) SetFirmwareUpdateDuration(v Milliseconds) StreamConfig {
	if s == nil {
		return nil
	}
	s.FirmwareUpdateDurationValue = &v
	return s
}

// Folder identificator.
func (s StreamConfigImpl) FolderID() *int {
	return s.FolderIDValue
}

// Folder identificator.
func (s *StreamConfigImpl) SetFolderID(v int) StreamConfig {
	if s == nil {
		return nil
	}
	s.FolderIDValue = &v
	return s
}

// List of stream inputs.
// ***Important:*** A stream without any inputs can receive video frames **only** if backup file is specified.
func (s StreamConfigImpl) Inputs() []StreamInput {
	return s.InputsValue
}

// List of stream inputs.
// ***Important:*** A stream without any inputs can receive video frames **only** if backup file is specified.
func (s *StreamConfigImpl) SetInputs(v []StreamInput) StreamConfig {
	if s == nil {
		return nil
	}
	s.InputsValue = v
	return s
}

// The stream is added to favorites list.
func (s StreamConfigImpl) IsFavourite() *bool {
	return s.IsFavouriteValue
}

// The stream is added to favorites list.
func (s *StreamConfigImpl) SetIsFavourite(v bool) StreamConfig {
	if s == nil {
		return nil
	}
	s.IsFavouriteValue = &v
	return s
}

// Information about the latest changes made to the camera configuration.
func (s StreamConfigImpl) LastChange() AuditLogRecord {
	return s.LastChangeValue
}

// Information about the latest changes made to the camera configuration.
func (s *StreamConfigImpl) SetLastChange(v AuditLogRecord) StreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*AuditLogRecordImpl); ok {
		s.LastChangeValue = impl
	}
	return s
}

// The time when the last episode occurred.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s StreamConfigImpl) LastEpisodeAt() *UtcMs {
	return s.LastEpisodeAtValue
}

// The time when the last episode occurred.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *StreamConfigImpl) SetLastEpisodeAt(v UtcMs) StreamConfig {
	if s == nil {
		return nil
	}
	s.LastEpisodeAtValue = &v
	return s
}

// Deprecated field. Will be deleted at 24.12
// Camera coordinates on a map or a floor plan. Deprecated. Use coordinates instead.
func (s StreamConfigImpl) MapCoordinates() MapSpec {
	return s.MapCoordinatesValue
}

// Deprecated field. Will be deleted at 24.12
// Camera coordinates on a map or a floor plan. Deprecated. Use coordinates instead.
func (s *StreamConfigImpl) SetMapCoordinates(v MapSpec) StreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*MapSpecImpl); ok {
		s.MapCoordinatesValue = impl
	}
	return s
}

// Globally unique stream name.
// Note that the name could not be changed after the stream is created.
// Format: media_name (media_name)
// Examples: Decklink-Stream, Dektec-Stream, hockey1, mylive/bunny, test_stream
func (s StreamConfigImpl) Name() MediaName {
	return s.NameValue
}

// Globally unique stream name.
// Note that the name could not be changed after the stream is created.
// Format: media_name (media_name)
// Examples: Decklink-Stream, Dektec-Stream, hockey1, mylive/bunny, test_stream
func (s *StreamConfigImpl) SetName(v MediaName) StreamConfig {
	if s == nil {
		return nil
	}
	s.NameValue = v
	return s
}

// Notifications are enabled for the camera.
func (s StreamConfigImpl) NotificationsEnabled() *bool {
	return s.NotificationsEnabledValue
}

// Notifications are enabled for the camera.
func (s *StreamConfigImpl) SetNotificationsEnabled(v bool) StreamConfig {
	if s == nil {
		return nil
	}
	s.NotificationsEnabledValue = &v
	return s
}

// Onvif configuration
func (s StreamConfigImpl) Onvif() StreamOnvifConfig {
	return s.OnvifValue
}

// Onvif configuration
func (s *StreamConfigImpl) SetOnvif(v StreamOnvifConfig) StreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*StreamOnvifConfigImpl); ok {
		s.OnvifValue = impl
	}
	return s
}

// Organization the stream belongs to.
func (s StreamConfigImpl) Organization() OrganizationStream {
	return s.OrganizationValue
}

// Organization the stream belongs to.
func (s *StreamConfigImpl) SetOrganization(v OrganizationStream) StreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*OrganizationStreamImpl); ok {
		s.OrganizationValue = impl
	}
	return s
}

// Deprecated field. Will be deleted at 25.11
// ID of the organization the stream belongs to.
// Only organization owner or domain administrator could change it.
// Example: 9
func (s StreamConfigImpl) OrganizationID() *int {
	return s.OrganizationIDValue
}

// Deprecated field. Will be deleted at 25.11
// ID of the organization the stream belongs to.
// Only organization owner or domain administrator could change it.
// Example: 9
func (s *StreamConfigImpl) SetOrganizationID(v int) StreamConfig {
	if s == nil {
		return nil
	}
	s.OrganizationIDValue = &v
	return s
}

// Contains path to stream as a list.
// Each item of the list can be interpreted as a node in a folders tree.
func (s StreamConfigImpl) Path() []StreamPathItem {
	if s.PathValue == nil {
		return nil
	}
	result := make([]StreamPathItem, len(s.PathValue))
	for i, item := range s.PathValue {
		result[i] = item
	}
	return result
}

// Contains path to stream as a list.
// Each item of the list can be interpreted as a node in a folders tree.
func (s *StreamConfigImpl) SetPath(v []StreamPathItem) StreamConfig {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*StreamPathItemImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*StreamPathItemImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.PathValue = impl
	}
	return s
}

// Camera adress on a map.
func (s StreamConfigImpl) PostalAddress() *string {
	return s.PostalAddressValue
}

// Camera adress on a map.
func (s *StreamConfigImpl) SetPostalAddress(v string) StreamConfig {
	if s == nil {
		return nil
	}
	s.PostalAddressValue = &v
	return s
}

// Preset settings.
func (s StreamConfigImpl) Preset() StreamPreset {
	return s.PresetValue
}

// Preset settings.
func (s *StreamConfigImpl) SetPreset(v StreamPreset) StreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*StreamPresetImpl); ok {
		s.PresetValue = impl
	}
	return s
}

// Deprecated field. Will be deleted at 26.01
// Preset identificator.
func (s StreamConfigImpl) PresetID() *int {
	return s.PresetIDValue
}

// Deprecated field. Will be deleted at 26.01
// Preset identificator.
func (s *StreamConfigImpl) SetPresetID(v int) StreamConfig {
	if s == nil {
		return nil
	}
	s.PresetIDValue = &v
	return s
}

// Whether a stream is `static` or not.
// If set to `True` the server will try to keep this stream running even if
// there are no viewers or errors encountered.
// Streamer restarts *all* `static` streams even if any internal errors occur
// and the `static` streams crash.
// Example: true
func (s StreamConfigImpl) Static() *bool {
	return s.StaticValue
}

// Whether a stream is `static` or not.
// If set to `True` the server will try to keep this stream running even if
// there are no viewers or errors encountered.
// Streamer restarts *all* `static` streams even if any internal errors occur
// and the `static` streams crash.
// Example: true
func (s *StreamConfigImpl) SetStatic(v bool) StreamConfig {
	if s == nil {
		return nil
	}
	s.StaticValue = &v
	return s
}

// Stream's metrics and other statistical information.
func (s StreamConfigImpl) Stats() StreamStats {
	return s.StatsValue
}

// Stream's metrics and other statistical information.
func (s *StreamConfigImpl) SetStats(v StreamStats) StreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*StreamStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// Human-readable title of the stream. Provided for SDT MPEG-TS table or
// SDP RTSP title parameter.
// Example: Hockey channel
func (s StreamConfigImpl) Title() *string {
	return s.TitleValue
}

// Human-readable title of the stream. Provided for SDT MPEG-TS table or
// SDP RTSP title parameter.
// Example: Hockey channel
func (s *StreamConfigImpl) SetTitle(v string) StreamConfig {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// Video analytics parameters.
func (s StreamConfigImpl) Vision() VisionSpec {
	return s.VisionValue
}

// Video analytics parameters.
func (s *StreamConfigImpl) SetVision(v VisionSpec) StreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionSpecImpl); ok {
		s.VisionValue = impl
	}
	return s
}

// NewStreamConfigAdditional creates a new StreamConfigAdditional instance
func NewStreamConfigAdditional() StreamConfigAdditional {
	return &StreamConfigAdditionalImpl{}
}

// Stream's metrics and other statistical information.
func (s StreamConfigAdditionalImpl) Stats() StreamStats {
	return s.StatsValue
}

// Stream's metrics and other statistical information.
func (s *StreamConfigAdditionalImpl) SetStats(v StreamStats) StreamConfigAdditional {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*StreamStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// NewStreamConfigBase creates a new StreamConfigBase instance
func NewStreamConfigBase() StreamConfigBase {
	return &StreamConfigBaseImpl{}
}

// Whether a stream is disabled. Disabled streams are inactive and do not run.
// Displayed only with the API calls.
// Example: false
func (s StreamConfigBaseImpl) Disabled() *bool {
	return s.DisabledValue
}

// Whether a stream is disabled. Disabled streams are inactive and do not run.
// Displayed only with the API calls.
// Example: false
func (s *StreamConfigBaseImpl) SetDisabled(v bool) StreamConfigBase {
	if s == nil {
		return nil
	}
	s.DisabledValue = &v
	return s
}

// Whether a stream is `static` or not.
// If set to `True` the server will try to keep this stream running even if
// there are no viewers or errors encountered.
// Streamer restarts *all* `static` streams even if any internal errors occur
// and the `static` streams crash.
// Example: true
func (s StreamConfigBaseImpl) Static() *bool {
	return s.StaticValue
}

// Whether a stream is `static` or not.
// If set to `True` the server will try to keep this stream running even if
// there are no viewers or errors encountered.
// Streamer restarts *all* `static` streams even if any internal errors occur
// and the `static` streams crash.
// Example: true
func (s *StreamConfigBaseImpl) SetStatic(v bool) StreamConfigBase {
	if s == nil {
		return nil
	}
	s.StaticValue = &v
	return s
}

// NewStreamConfigInput creates a new StreamConfigInput instance
func NewStreamConfigInput() StreamConfigInput {
	return &StreamConfigInputImpl{}
}

// List of stream inputs.
// ***Important:*** A stream without any inputs can receive video frames **only** if backup file is specified.
func (s StreamConfigInputImpl) Inputs() []StreamInput {
	return s.InputsValue
}

// List of stream inputs.
// ***Important:*** A stream without any inputs can receive video frames **only** if backup file is specified.
func (s *StreamConfigInputImpl) SetInputs(v []StreamInput) StreamConfigInput {
	if s == nil {
		return nil
	}
	s.InputsValue = v
	return s
}

// NewStreamConfigMedia creates a new StreamConfigMedia instance
func NewStreamConfigMedia() StreamConfigMedia {
	return &StreamConfigMediaImpl{}
}

// DVR configuraton.
func (s StreamConfigMediaImpl) Dvr() StreamDvrSpec {
	return s.DvrValue
}

// DVR configuraton.
func (s *StreamConfigMediaImpl) SetDvr(v StreamDvrSpec) StreamConfigMedia {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*StreamDvrSpecImpl); ok {
		s.DvrValue = impl
	}
	return s
}

// NewStreamConfigMultiedit creates a new StreamConfigMultiedit instance
func NewStreamConfigMultiedit() StreamConfigMultiedit {
	return &StreamConfigMultieditImpl{}
}

// DVR configuration.
func (s StreamConfigMultieditImpl) Dvr() StreamDvrSpec {
	return s.DvrValue
}

// DVR configuration.
func (s *StreamConfigMultieditImpl) SetDvr(v StreamDvrSpec) StreamConfigMultiedit {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*StreamDvrSpecImpl); ok {
		s.DvrValue = impl
	}
	return s
}

// Stream name
func (s StreamConfigMultieditImpl) Name() *string {
	return s.NameValue
}

// Stream name
func (s *StreamConfigMultieditImpl) SetName(v string) StreamConfigMultiedit {
	if s == nil {
		return nil
	}
	s.NameValue = &v
	return s
}

// Preset identificator.
func (s StreamConfigMultieditImpl) PresetID() *int {
	return s.PresetIDValue
}

// Preset identificator.
func (s *StreamConfigMultieditImpl) SetPresetID(v int) StreamConfigMultiedit {
	if s == nil {
		return nil
	}
	s.PresetIDValue = &v
	return s
}

// NewStreamConfigOnpremises creates a new StreamConfigOnpremises instance
func NewStreamConfigOnpremises() StreamConfigOnpremises {
	return &StreamConfigOnpremisesImpl{}
}

// Video analytics parameters.
func (s StreamConfigOnpremisesImpl) Vision() VisionSpec {
	return s.VisionValue
}

// Video analytics parameters.
func (s *StreamConfigOnpremisesImpl) SetVision(v VisionSpec) StreamConfigOnpremises {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionSpecImpl); ok {
		s.VisionValue = impl
	}
	return s
}

// NewStreamConfigSpecific creates a new StreamConfigSpecific instance
func NewStreamConfigSpecific() StreamConfigSpecific {
	return &StreamConfigSpecificImpl{}
}

// Human-readable description of the stream.
// Example: This is a test stream
func (s StreamConfigSpecificImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the stream.
// Example: This is a test stream
func (s *StreamConfigSpecificImpl) SetComment(v string) StreamConfigSpecific {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Globally unique stream name.
// Note that the name could not be changed after the stream is created.
// Format: media_name (media_name)
// Examples: Decklink-Stream, Dektec-Stream, hockey1, mylive/bunny, test_stream
func (s StreamConfigSpecificImpl) Name() MediaName {
	return s.NameValue
}

// Globally unique stream name.
// Note that the name could not be changed after the stream is created.
// Format: media_name (media_name)
// Examples: Decklink-Stream, Dektec-Stream, hockey1, mylive/bunny, test_stream
func (s *StreamConfigSpecificImpl) SetName(v MediaName) StreamConfigSpecific {
	if s == nil {
		return nil
	}
	s.NameValue = v
	return s
}

// Human-readable title of the stream. Provided for SDT MPEG-TS table or
// SDP RTSP title parameter.
// Example: Hockey channel
func (s StreamConfigSpecificImpl) Title() *string {
	return s.TitleValue
}

// Human-readable title of the stream. Provided for SDT MPEG-TS table or
// SDP RTSP title parameter.
// Example: Hockey channel
func (s *StreamConfigSpecificImpl) SetTitle(v string) StreamConfigSpecific {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// NewStreamDvrSpec creates a new StreamDvrSpec instance
func NewStreamDvrSpec() StreamDvrSpec {
	return &StreamDvrSpecImpl{}
}

// Additional archive depth in seconds for episodes. If set, episodes and their corresponding DVR record
// will be saved for `expiration + episodes_expiration` seconds.
// The archive clean-up within `[expiration, expiration+episodes_expiration]` seconds of the
// recording performed depending on [external_episodes_list](https://flussonic.com/doc/api/config-external/#tag/dvr/operation/external_episodes_list)
// response of `episodes_url`.
// Anything older than `expiration+episodes_expiration` seconds will
// be cleaned even if `episodes_url` does not respond.
// Format: seconds (seconds)
// Examples: 6.048e+06
func (s StreamDvrSpecImpl) EpisodesExpiration() *Seconds {
	return s.EpisodesExpirationValue
}

// Additional archive depth in seconds for episodes. If set, episodes and their corresponding DVR record
// will be saved for `expiration + episodes_expiration` seconds.
// The archive clean-up within `[expiration, expiration+episodes_expiration]` seconds of the
// recording performed depending on [external_episodes_list](https://flussonic.com/doc/api/config-external/#tag/dvr/operation/external_episodes_list)
// response of `episodes_url`.
// Anything older than `expiration+episodes_expiration` seconds will
// be cleaned even if `episodes_url` does not respond.
// Format: seconds (seconds)
// Examples: 6.048e+06
func (s *StreamDvrSpecImpl) SetEpisodesExpiration(v Seconds) StreamDvrSpec {
	if s == nil {
		return nil
	}
	s.EpisodesExpirationValue = &v
	return s
}

// Archive depth - a period (in seconds) back from the current moment during which the
// contigious part of archive is stored.
// As time goes, the parts of the recording which are older than the archive depth are deleted.
// If you have option `episodes_expiration` enabled, then some parts of DVR that are
// locked by episode signalling mechanism may be kept more than this `expiration` depth.
// If `episodes_url` does not respond, the archive clean-up by `expiration` is not performed;
// only the archive with expired episodes (`episodes_expiration`) is cleaned up until the `episodes_url` restores.
// Format: seconds (seconds)
// Examples: 604800
func (s StreamDvrSpecImpl) Expiration() *Seconds {
	return s.ExpirationValue
}

// Archive depth - a period (in seconds) back from the current moment during which the
// contigious part of archive is stored.
// As time goes, the parts of the recording which are older than the archive depth are deleted.
// If you have option `episodes_expiration` enabled, then some parts of DVR that are
// locked by episode signalling mechanism may be kept more than this `expiration` depth.
// If `episodes_url` does not respond, the archive clean-up by `expiration` is not performed;
// only the archive with expired episodes (`episodes_expiration`) is cleaned up until the `episodes_url` restores.
// Format: seconds (seconds)
// Examples: 604800
func (s *StreamDvrSpecImpl) SetExpiration(v Seconds) StreamDvrSpec {
	if s == nil {
		return nil
	}
	s.ExpirationValue = &v
	return s
}

// How many servers will contain a copy of the DVR archive.
// You can find more information [here](https://flussonic.com/doc/api/layouter/#tag/stream/operation/streams_list/response%7Cstreams%7Cdvr%7Credundancy_factor)
// Example: 1
func (s StreamDvrSpecImpl) RedundancyFactor() *int {
	return s.RedundancyFactorValue
}

// How many servers will contain a copy of the DVR archive.
// You can find more information [here](https://flussonic.com/doc/api/layouter/#tag/stream/operation/streams_list/response%7Cstreams%7Cdvr%7Credundancy_factor)
// Example: 1
func (s *StreamDvrSpecImpl) SetRedundancyFactor(v int) StreamDvrSpec {
	if s == nil {
		return nil
	}
	s.RedundancyFactorValue = &v
	return s
}

// Maximum disk consumption in bytes. When this limit is reached,
// the oldest segment of the recording will be overridden by later data.
// This option affects both continuous recording and locked episodes (see `episodes_url`).
// If `episodes_url` does not respond, the archive clean-up by `storage_limit` is not performed
// to avoid deleting the recordings that should not be deleted.
// Format: bytes (bytes)
// Example: 4e+11
func (s StreamDvrSpecImpl) StorageLimit() *Bytes {
	return s.StorageLimitValue
}

// Maximum disk consumption in bytes. When this limit is reached,
// the oldest segment of the recording will be overridden by later data.
// This option affects both continuous recording and locked episodes (see `episodes_url`).
// If `episodes_url` does not respond, the archive clean-up by `storage_limit` is not performed
// to avoid deleting the recordings that should not be deleted.
// Format: bytes (bytes)
// Example: 4e+11
func (s *StreamDvrSpecImpl) SetStorageLimit(v Bytes) StreamDvrSpec {
	if s == nil {
		return nil
	}
	s.StorageLimitValue = &v
	return s
}

// NewStreamDvrSpecificSpec creates a new StreamDvrSpecificSpec instance
func NewStreamDvrSpecificSpec() StreamDvrSpecificSpec {
	return &StreamDvrSpecificSpecImpl{}
}

// How many servers will contain a copy of the DVR archive.
// You can find more information [here](https://flussonic.com/doc/api/layouter/#tag/stream/operation/streams_list/response%7Cstreams%7Cdvr%7Credundancy_factor)
// Example: 1
func (s StreamDvrSpecificSpecImpl) RedundancyFactor() *int {
	return s.RedundancyFactorValue
}

// How many servers will contain a copy of the DVR archive.
// You can find more information [here](https://flussonic.com/doc/api/layouter/#tag/stream/operation/streams_list/response%7Cstreams%7Cdvr%7Credundancy_factor)
// Example: 1
func (s *StreamDvrSpecificSpecImpl) SetRedundancyFactor(v int) StreamDvrSpecificSpec {
	if s == nil {
		return nil
	}
	s.RedundancyFactorValue = &v
	return s
}

// NewStreamInputBase creates a new StreamInputBase instance
func NewStreamInputBase() StreamInputBase {
	return &StreamInputBaseImpl{}
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s StreamInputBaseImpl) AllowIf() *string {
	return s.AllowIfValue
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s *StreamInputBaseImpl) SetAllowIf(v string) StreamInputBase {
	if s == nil {
		return nil
	}
	s.AllowIfValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputBaseImpl) AudioTimeout() *Seconds {
	return s.AudioTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputBaseImpl) SetAudioTimeout(v Seconds) StreamInputBase {
	if s == nil {
		return nil
	}
	s.AudioTimeoutValue = &v
	return s
}

// Human-readable description of the input.
// Example: This is a test input
func (s StreamInputBaseImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the input.
// Example: This is a test input
func (s *StreamInputBaseImpl) SetComment(v string) StreamInputBase {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s StreamInputBaseImpl) DenyIf() *string {
	return s.DenyIfValue
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s *StreamInputBaseImpl) SetDenyIf(v string) StreamInputBase {
	if s == nil {
		return nil
	}
	s.DenyIfValue = &v
	return s
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s StreamInputBaseImpl) FramesTimeout() *int {
	return s.FramesTimeoutValue
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s *StreamInputBaseImpl) SetFramesTimeout(v int) StreamInputBase {
	if s == nil {
		return nil
	}
	s.FramesTimeoutValue = &v
	return s
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s StreamInputBaseImpl) Headers() map[string]string {
	return s.HeadersValue
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s *StreamInputBaseImpl) SetHeaders(v map[string]string) StreamInputBase {
	if s == nil {
		return nil
	}
	s.HeadersValue = v
	return s
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s StreamInputBaseImpl) MaxRetryTimeout() *Seconds {
	return s.MaxRetryTimeoutValue
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s *StreamInputBaseImpl) SetMaxRetryTimeout(v Seconds) StreamInputBase {
	if s == nil {
		return nil
	}
	s.MaxRetryTimeoutValue = &v
	return s
}

// Skip input start if the stream has no clients.
func (s StreamInputBaseImpl) NoClientsReconnectDelay() *int {
	return s.NoClientsReconnectDelayValue
}

// Skip input start if the stream has no clients.
func (s *StreamInputBaseImpl) SetNoClientsReconnectDelay(v int) StreamInputBase {
	if s == nil {
		return nil
	}
	s.NoClientsReconnectDelayValue = &v
	return s
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s StreamInputBaseImpl) OutputAudio() *OutputAudio {
	return s.OutputAudioValue
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s *StreamInputBaseImpl) SetOutputAudio(v OutputAudio) StreamInputBase {
	if s == nil {
		return nil
	}
	s.OutputAudioValue = &v
	return s
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s StreamInputBaseImpl) Priority() *int {
	return s.PriorityValue
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s *StreamInputBaseImpl) SetPriority(v int) StreamInputBase {
	if s == nil {
		return nil
	}
	s.PriorityValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s StreamInputBaseImpl) SourceTimeout() any {
	return s.SourceTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s *StreamInputBaseImpl) SetSourceTimeout(v any) StreamInputBase {
	if s == nil {
		return nil
	}
	s.SourceTimeoutValue = v
	return s
}

// Detailed runtime information about the input.
func (s StreamInputBaseImpl) Stats() InputStats {
	return s.StatsValue
}

// Detailed runtime information about the input.
func (s *StreamInputBaseImpl) SetStats(v InputStats) StreamInputBase {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s StreamInputBaseImpl) Timeout() *int {
	return s.TimeoutValue
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s *StreamInputBaseImpl) SetTimeout(v int) StreamInputBase {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// User agent. Can be modified if a protocol allows it.
func (s StreamInputBaseImpl) UserAgent() *string {
	return s.UserAgentValue
}

// User agent. Can be modified if a protocol allows it.
func (s *StreamInputBaseImpl) SetUserAgent(v string) StreamInputBase {
	if s == nil {
		return nil
	}
	s.UserAgentValue = &v
	return s
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s StreamInputBaseImpl) Via() *AgentURL {
	return s.ViaValue
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s *StreamInputBaseImpl) SetVia(v AgentURL) StreamInputBase {
	if s == nil {
		return nil
	}
	s.ViaValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputBaseImpl) VideoTimeout() *Seconds {
	return s.VideoTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputBaseImpl) SetVideoTimeout(v Seconds) StreamInputBase {
	if s == nil {
		return nil
	}
	s.VideoTimeoutValue = &v
	return s
}

// NewStreamInputFake creates a new StreamInputFake instance
func NewStreamInputFake() StreamInputFake {
	return &StreamInputFakeImpl{}
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s StreamInputFakeImpl) AllowIf() *string {
	return s.AllowIfValue
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s *StreamInputFakeImpl) SetAllowIf(v string) StreamInputFake {
	if s == nil {
		return nil
	}
	s.AllowIfValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputFakeImpl) AudioTimeout() *Seconds {
	return s.AudioTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputFakeImpl) SetAudioTimeout(v Seconds) StreamInputFake {
	if s == nil {
		return nil
	}
	s.AudioTimeoutValue = &v
	return s
}

// Bitrate of an artificially created test video stream.
// Applicable to the `fake://fake` URL.
// Format: speed (speed)
func (s StreamInputFakeImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// Bitrate of an artificially created test video stream.
// Applicable to the `fake://fake` URL.
// Format: speed (speed)
func (s *StreamInputFakeImpl) SetBitrate(v Speed) StreamInputFake {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// Human-readable description of the input.
// Example: This is a test input
func (s StreamInputFakeImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the input.
// Example: This is a test input
func (s *StreamInputFakeImpl) SetComment(v string) StreamInputFake {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s StreamInputFakeImpl) DenyIf() *string {
	return s.DenyIfValue
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s *StreamInputFakeImpl) SetDenyIf(v string) StreamInputFake {
	if s == nil {
		return nil
	}
	s.DenyIfValue = &v
	return s
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s StreamInputFakeImpl) FramesTimeout() *int {
	return s.FramesTimeoutValue
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s *StreamInputFakeImpl) SetFramesTimeout(v int) StreamInputFake {
	if s == nil {
		return nil
	}
	s.FramesTimeoutValue = &v
	return s
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s StreamInputFakeImpl) Headers() map[string]string {
	return s.HeadersValue
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s *StreamInputFakeImpl) SetHeaders(v map[string]string) StreamInputFake {
	if s == nil {
		return nil
	}
	s.HeadersValue = v
	return s
}

// Height of an artificially created test video stream.
// Applicable to the `fake://fake` URL.
func (s StreamInputFakeImpl) Height() *int {
	return s.HeightValue
}

// Height of an artificially created test video stream.
// Applicable to the `fake://fake` URL.
func (s *StreamInputFakeImpl) SetHeight(v int) StreamInputFake {
	if s == nil {
		return nil
	}
	s.HeightValue = &v
	return s
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s StreamInputFakeImpl) MaxRetryTimeout() *Seconds {
	return s.MaxRetryTimeoutValue
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s *StreamInputFakeImpl) SetMaxRetryTimeout(v Seconds) StreamInputFake {
	if s == nil {
		return nil
	}
	s.MaxRetryTimeoutValue = &v
	return s
}

// Skip input start if the stream has no clients.
func (s StreamInputFakeImpl) NoClientsReconnectDelay() *int {
	return s.NoClientsReconnectDelayValue
}

// Skip input start if the stream has no clients.
func (s *StreamInputFakeImpl) SetNoClientsReconnectDelay(v int) StreamInputFake {
	if s == nil {
		return nil
	}
	s.NoClientsReconnectDelayValue = &v
	return s
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s StreamInputFakeImpl) OutputAudio() *OutputAudio {
	return s.OutputAudioValue
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s *StreamInputFakeImpl) SetOutputAudio(v OutputAudio) StreamInputFake {
	if s == nil {
		return nil
	}
	s.OutputAudioValue = &v
	return s
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s StreamInputFakeImpl) Priority() *int {
	return s.PriorityValue
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s *StreamInputFakeImpl) SetPriority(v int) StreamInputFake {
	if s == nil {
		return nil
	}
	s.PriorityValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s StreamInputFakeImpl) SourceTimeout() any {
	return s.SourceTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s *StreamInputFakeImpl) SetSourceTimeout(v any) StreamInputFake {
	if s == nil {
		return nil
	}
	s.SourceTimeoutValue = v
	return s
}

// Detailed runtime information about the input.
func (s StreamInputFakeImpl) Stats() InputStats {
	return s.StatsValue
}

// Detailed runtime information about the input.
func (s *StreamInputFakeImpl) SetStats(v InputStats) StreamInputFake {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s StreamInputFakeImpl) Timeout() *int {
	return s.TimeoutValue
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s *StreamInputFakeImpl) SetTimeout(v int) StreamInputFake {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// URL to get a demo stream.
// Format: input_url (input_url)
// Pattern: ^fake://.*$
// Example: fake://fake
func (s StreamInputFakeImpl) URL() InputURL {
	return s.URLValue
}

// URL to get a demo stream.
// Format: input_url (input_url)
// Pattern: ^fake://.*$
// Example: fake://fake
func (s *StreamInputFakeImpl) SetURL(v InputURL) StreamInputFake {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// User agent. Can be modified if a protocol allows it.
func (s StreamInputFakeImpl) UserAgent() *string {
	return s.UserAgentValue
}

// User agent. Can be modified if a protocol allows it.
func (s *StreamInputFakeImpl) SetUserAgent(v string) StreamInputFake {
	if s == nil {
		return nil
	}
	s.UserAgentValue = &v
	return s
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s StreamInputFakeImpl) Via() *AgentURL {
	return s.ViaValue
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s *StreamInputFakeImpl) SetVia(v AgentURL) StreamInputFake {
	if s == nil {
		return nil
	}
	s.ViaValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputFakeImpl) VideoTimeout() *Seconds {
	return s.VideoTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputFakeImpl) SetVideoTimeout(v Seconds) StreamInputFake {
	if s == nil {
		return nil
	}
	s.VideoTimeoutValue = &v
	return s
}

// Width of an artificially created test video stream.
// Applicable to the `fake://fake` URL.
func (s StreamInputFakeImpl) Width() *int {
	return s.WidthValue
}

// Width of an artificially created test video stream.
// Applicable to the `fake://fake` URL.
func (s *StreamInputFakeImpl) SetWidth(v int) StreamInputFake {
	if s == nil {
		return nil
	}
	s.WidthValue = &v
	return s
}

// NewStreamInputFile creates a new StreamInputFile instance
func NewStreamInputFile() StreamInputFile {
	return &StreamInputFileImpl{}
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s StreamInputFileImpl) AllowIf() *string {
	return s.AllowIfValue
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s *StreamInputFileImpl) SetAllowIf(v string) StreamInputFile {
	if s == nil {
		return nil
	}
	s.AllowIfValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputFileImpl) AudioTimeout() *Seconds {
	return s.AudioTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputFileImpl) SetAudioTimeout(v Seconds) StreamInputFile {
	if s == nil {
		return nil
	}
	s.AudioTimeoutValue = &v
	return s
}

// The rules for handling the closed captions.
func (s StreamInputFileImpl) ClosedCaptions() map[string]string {
	return s.ClosedCaptionsValue
}

// The rules for handling the closed captions.
func (s *StreamInputFileImpl) SetClosedCaptions(v map[string]string) StreamInputFile {
	if s == nil {
		return nil
	}
	s.ClosedCaptionsValue = v
	return s
}

// Human-readable description of the input.
// Example: This is a test input
func (s StreamInputFileImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the input.
// Example: This is a test input
func (s *StreamInputFileImpl) SetComment(v string) StreamInputFile {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s StreamInputFileImpl) DenyIf() *string {
	return s.DenyIfValue
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s *StreamInputFileImpl) SetDenyIf(v string) StreamInputFile {
	if s == nil {
		return nil
	}
	s.DenyIfValue = &v
	return s
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s StreamInputFileImpl) FramesTimeout() *int {
	return s.FramesTimeoutValue
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s *StreamInputFileImpl) SetFramesTimeout(v int) StreamInputFile {
	if s == nil {
		return nil
	}
	s.FramesTimeoutValue = &v
	return s
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s StreamInputFileImpl) Headers() map[string]string {
	return s.HeadersValue
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s *StreamInputFileImpl) SetHeaders(v map[string]string) StreamInputFile {
	if s == nil {
		return nil
	}
	s.HeadersValue = v
	return s
}

// An array of MPEG-TS language descriptors in format `[{key: track, value: language}]`
func (s StreamInputFileImpl) Languages() map[string]string {
	return s.LanguagesValue
}

// An array of MPEG-TS language descriptors in format `[{key: track, value: language}]`
func (s *StreamInputFileImpl) SetLanguages(v map[string]string) StreamInputFile {
	if s == nil {
		return nil
	}
	s.LanguagesValue = v
	return s
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s StreamInputFileImpl) MaxRetryTimeout() *Seconds {
	return s.MaxRetryTimeoutValue
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s *StreamInputFileImpl) SetMaxRetryTimeout(v Seconds) StreamInputFile {
	if s == nil {
		return nil
	}
	s.MaxRetryTimeoutValue = &v
	return s
}

// Skip input start if the stream has no clients.
func (s StreamInputFileImpl) NoClientsReconnectDelay() *int {
	return s.NoClientsReconnectDelayValue
}

// Skip input start if the stream has no clients.
func (s *StreamInputFileImpl) SetNoClientsReconnectDelay(v int) StreamInputFile {
	if s == nil {
		return nil
	}
	s.NoClientsReconnectDelayValue = &v
	return s
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s StreamInputFileImpl) OutputAudio() *OutputAudio {
	return s.OutputAudioValue
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s *StreamInputFileImpl) SetOutputAudio(v OutputAudio) StreamInputFile {
	if s == nil {
		return nil
	}
	s.OutputAudioValue = &v
	return s
}

// Choose a specific PID to ingest from an MPEG-TS stream.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Example: [211]
func (s StreamInputFileImpl) Pids() []int {
	return s.PidsValue
}

// Choose a specific PID to ingest from an MPEG-TS stream.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Example: [211]
func (s *StreamInputFileImpl) SetPids(v []int) StreamInputFile {
	if s == nil {
		return nil
	}
	s.PidsValue = v
	return s
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s StreamInputFileImpl) Priority() *int {
	return s.PriorityValue
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s *StreamInputFileImpl) SetPriority(v int) StreamInputFile {
	if s == nil {
		return nil
	}
	s.PriorityValue = &v
	return s
}

// Choose a program to ingest from an MPEG-TS stream.
// Example: [1]
func (s StreamInputFileImpl) Programs() []int {
	return s.ProgramsValue
}

// Choose a program to ingest from an MPEG-TS stream.
// Example: [1]
func (s *StreamInputFileImpl) SetPrograms(v []int) StreamInputFile {
	if s == nil {
		return nil
	}
	s.ProgramsValue = v
	return s
}

// Deprecated field. Will be deleted at 23.09
// This option disables processing of SCTE-35 markers from an MPEG-TS input stream.
// Deprecated since 22.12.
// Available ways to disable processing of SCTE-35 markers:
// 1. pids option to select tracks without SCTE-35 markers
// 2. hls_scte35 option from stream_config_media for hls output
// 3. performing appropriate tuning pids in the transponder
// Example: true
func (s StreamInputFileImpl) Scte35() *bool {
	return s.Scte35Value
}

// Deprecated field. Will be deleted at 23.09
// This option disables processing of SCTE-35 markers from an MPEG-TS input stream.
// Deprecated since 22.12.
// Available ways to disable processing of SCTE-35 markers:
// 1. pids option to select tracks without SCTE-35 markers
// 2. hls_scte35 option from stream_config_media for hls output
// 3. performing appropriate tuning pids in the transponder
// Example: true
func (s *StreamInputFileImpl) SetScte35(v bool) StreamInputFile {
	if s == nil {
		return nil
	}
	s.Scte35Value = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s StreamInputFileImpl) SourceTimeout() any {
	return s.SourceTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s *StreamInputFileImpl) SetSourceTimeout(v any) StreamInputFile {
	if s == nil {
		return nil
	}
	s.SourceTimeoutValue = v
	return s
}

// Detailed runtime information about the input.
func (s StreamInputFileImpl) Stats() InputStats {
	return s.StatsValue
}

// Detailed runtime information about the input.
func (s *StreamInputFileImpl) SetStats(v InputStats) StreamInputFile {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// Deprecated field. Will be deleted at 25.03
// This configuration is deprecated. Use `dvbocr` configuration field in stream.
// This parameter allows to manage subtitles in an output stream.
// Example: drop
func (s StreamInputFileImpl) Subtitles() *StreamInputMpegtsSpecificSubtitles {
	return s.SubtitlesValue
}

// Deprecated field. Will be deleted at 25.03
// This configuration is deprecated. Use `dvbocr` configuration field in stream.
// This parameter allows to manage subtitles in an output stream.
// Example: drop
func (s *StreamInputFileImpl) SetSubtitles(v StreamInputMpegtsSpecificSubtitles) StreamInputFile {
	if s == nil {
		return nil
	}
	s.SubtitlesValue = &v
	return s
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s StreamInputFileImpl) Timeout() *int {
	return s.TimeoutValue
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s *StreamInputFileImpl) SetTimeout(v int) StreamInputFile {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// URL to get a stream from file.
// Format: input_url (input_url)
// Pattern: ^file://.*$
// Example: file://vod/bunny.mp4
func (s StreamInputFileImpl) URL() InputURL {
	return s.URLValue
}

// URL to get a stream from file.
// Format: input_url (input_url)
// Pattern: ^file://.*$
// Example: file://vod/bunny.mp4
func (s *StreamInputFileImpl) SetURL(v InputURL) StreamInputFile {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// User agent. Can be modified if a protocol allows it.
func (s StreamInputFileImpl) UserAgent() *string {
	return s.UserAgentValue
}

// User agent. Can be modified if a protocol allows it.
func (s *StreamInputFileImpl) SetUserAgent(v string) StreamInputFile {
	if s == nil {
		return nil
	}
	s.UserAgentValue = &v
	return s
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s StreamInputFileImpl) Via() *AgentURL {
	return s.ViaValue
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s *StreamInputFileImpl) SetVia(v AgentURL) StreamInputFile {
	if s == nil {
		return nil
	}
	s.ViaValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputFileImpl) VideoTimeout() *Seconds {
	return s.VideoTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputFileImpl) SetVideoTimeout(v Seconds) StreamInputFile {
	if s == nil {
		return nil
	}
	s.VideoTimeoutValue = &v
	return s
}

// NewStreamInputMpegtsSpecific creates a new StreamInputMpegtsSpecific instance
func NewStreamInputMpegtsSpecific() StreamInputMpegtsSpecific {
	return &StreamInputMpegtsSpecificImpl{}
}

// The rules for handling the closed captions.
func (s StreamInputMpegtsSpecificImpl) ClosedCaptions() map[string]string {
	return s.ClosedCaptionsValue
}

// The rules for handling the closed captions.
func (s *StreamInputMpegtsSpecificImpl) SetClosedCaptions(v map[string]string) StreamInputMpegtsSpecific {
	if s == nil {
		return nil
	}
	s.ClosedCaptionsValue = v
	return s
}

// An array of MPEG-TS language descriptors in format `[{key: track, value: language}]`
func (s StreamInputMpegtsSpecificImpl) Languages() map[string]string {
	return s.LanguagesValue
}

// An array of MPEG-TS language descriptors in format `[{key: track, value: language}]`
func (s *StreamInputMpegtsSpecificImpl) SetLanguages(v map[string]string) StreamInputMpegtsSpecific {
	if s == nil {
		return nil
	}
	s.LanguagesValue = v
	return s
}

// Choose a specific PID to ingest from an MPEG-TS stream.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Example: [211]
func (s StreamInputMpegtsSpecificImpl) Pids() []int {
	return s.PidsValue
}

// Choose a specific PID to ingest from an MPEG-TS stream.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Example: [211]
func (s *StreamInputMpegtsSpecificImpl) SetPids(v []int) StreamInputMpegtsSpecific {
	if s == nil {
		return nil
	}
	s.PidsValue = v
	return s
}

// Choose a program to ingest from an MPEG-TS stream.
// Example: [1]
func (s StreamInputMpegtsSpecificImpl) Programs() []int {
	return s.ProgramsValue
}

// Choose a program to ingest from an MPEG-TS stream.
// Example: [1]
func (s *StreamInputMpegtsSpecificImpl) SetPrograms(v []int) StreamInputMpegtsSpecific {
	if s == nil {
		return nil
	}
	s.ProgramsValue = v
	return s
}

// Deprecated field. Will be deleted at 23.09
// This option disables processing of SCTE-35 markers from an MPEG-TS input stream.
// Deprecated since 22.12.
// Available ways to disable processing of SCTE-35 markers:
// 1. pids option to select tracks without SCTE-35 markers
// 2. hls_scte35 option from stream_config_media for hls output
// 3. performing appropriate tuning pids in the transponder
// Example: true
func (s StreamInputMpegtsSpecificImpl) Scte35() *bool {
	return s.Scte35Value
}

// Deprecated field. Will be deleted at 23.09
// This option disables processing of SCTE-35 markers from an MPEG-TS input stream.
// Deprecated since 22.12.
// Available ways to disable processing of SCTE-35 markers:
// 1. pids option to select tracks without SCTE-35 markers
// 2. hls_scte35 option from stream_config_media for hls output
// 3. performing appropriate tuning pids in the transponder
// Example: true
func (s *StreamInputMpegtsSpecificImpl) SetScte35(v bool) StreamInputMpegtsSpecific {
	if s == nil {
		return nil
	}
	s.Scte35Value = &v
	return s
}

// Deprecated field. Will be deleted at 25.03
// This configuration is deprecated. Use `dvbocr` configuration field in stream.
// This parameter allows to manage subtitles in an output stream.
// Example: drop
func (s StreamInputMpegtsSpecificImpl) Subtitles() *StreamInputMpegtsSpecificSubtitles {
	return s.SubtitlesValue
}

// Deprecated field. Will be deleted at 25.03
// This configuration is deprecated. Use `dvbocr` configuration field in stream.
// This parameter allows to manage subtitles in an output stream.
// Example: drop
func (s *StreamInputMpegtsSpecificImpl) SetSubtitles(v StreamInputMpegtsSpecificSubtitles) StreamInputMpegtsSpecific {
	if s == nil {
		return nil
	}
	s.SubtitlesValue = &v
	return s
}

// NewStreamInputPublish creates a new StreamInputPublish instance
func NewStreamInputPublish() StreamInputPublish {
	return &StreamInputPublishImpl{}
}

// The correction between the target bitrate (Receiver Estimated Maximum Bitrate, calculated in Flussonic) and browser bitrate, in kbit/s.
// Flussonic sends the target bitrate to the browser from which the publication is carried out so that the browser adjusts the bitrate of the publication by this value.
// The default value is 300 kbit/s.
// Example: 200
func (s StreamInputPublishImpl) AbrCorrection() *int {
	return s.AbrCorrectionValue
}

// The correction between the target bitrate (Receiver Estimated Maximum Bitrate, calculated in Flussonic) and browser bitrate, in kbit/s.
// Flussonic sends the target bitrate to the browser from which the publication is carried out so that the browser adjusts the bitrate of the publication by this value.
// The default value is 300 kbit/s.
// Example: 200
func (s *StreamInputPublishImpl) SetAbrCorrection(v int) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.AbrCorrectionValue = &v
	return s
}

// The number of cycles of bitrate auto-adjustment.
// After the specified number of auto-adjustment cycles passes, Flussonic considers the bitrate to be optimal, and it is no longer analyzed.
// By default, `abr_cycles`=5.
// If `abr_cycles`=0, the adjustment process takes place all the time while the publication lasts.
// Example: 3
func (s StreamInputPublishImpl) AbrCycles() *int {
	return s.AbrCyclesValue
}

// The number of cycles of bitrate auto-adjustment.
// After the specified number of auto-adjustment cycles passes, Flussonic considers the bitrate to be optimal, and it is no longer analyzed.
// By default, `abr_cycles`=5.
// If `abr_cycles`=0, the adjustment process takes place all the time while the publication lasts.
// Example: 3
func (s *StreamInputPublishImpl) SetAbrCycles(v int) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.AbrCyclesValue = &v
	return s
}

// Whether adaptive bitrate process is logged.
// Example: 1
func (s StreamInputPublishImpl) AbrDebug() *int {
	return s.AbrDebugValue
}

// Whether adaptive bitrate process is logged.
// Example: 1
func (s *StreamInputPublishImpl) SetAbrDebug(v int) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.AbrDebugValue = &v
	return s
}

// The lower limit of packet loss. When it is reached, Flussonic raises the bitrate.
// That is, if packet loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup` percent.
// Example: 2
func (s StreamInputPublishImpl) AbrLossLower() *float64 {
	return s.AbrLossLowerValue
}

// The lower limit of packet loss. When it is reached, Flussonic raises the bitrate.
// That is, if packet loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup` percent.
// Example: 2
func (s *StreamInputPublishImpl) SetAbrLossLower(v float64) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.AbrLossLowerValue = &v
	return s
}

// The upper limit of packet loss. When it is reached, Flussonic reduces the bitrate.
// That is, if packet loss is greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.
// Example: 10
func (s StreamInputPublishImpl) AbrLossUpper() *float64 {
	return s.AbrLossUpperValue
}

// The upper limit of packet loss. When it is reached, Flussonic reduces the bitrate.
// That is, if packet loss is greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.
// Example: 10
func (s *StreamInputPublishImpl) SetAbrLossUpper(v float64) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.AbrLossUpperValue = &v
	return s
}

// Maximum bitrate for adjustment process, in kbit/s.
// Flussonic will keep the publication bitrate equal or below of the specified value.
// Example: 1000
func (s StreamInputPublishImpl) AbrMaxBitrate() *int {
	return s.AbrMaxBitrateValue
}

// Maximum bitrate for adjustment process, in kbit/s.
// Flussonic will keep the publication bitrate equal or below of the specified value.
// Example: 1000
func (s *StreamInputPublishImpl) SetAbrMaxBitrate(v int) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.AbrMaxBitrateValue = &v
	return s
}

// The algorithm for determining the need to change the bitrate of the published stream and for calculating the target bitrate.
// Two options are possible:
// * `abr_mode=0` - This mode takes into account the packet losses, target bitrate, browser bitrate and the number of auto-adjustment cycles.
// * `abr_mode=1` - This mode considers only packet losses and target bitrate.
// Example: 1
func (s StreamInputPublishImpl) AbrMode() *int {
	return s.AbrModeValue
}

// The algorithm for determining the need to change the bitrate of the published stream and for calculating the target bitrate.
// Two options are possible:
// * `abr_mode=0` - This mode takes into account the packet losses, target bitrate, browser bitrate and the number of auto-adjustment cycles.
// * `abr_mode=1` - This mode considers only packet losses and target bitrate.
// Example: 1
func (s *StreamInputPublishImpl) SetAbrMode(v int) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.AbrModeValue = &v
	return s
}

// A step of reducing the bitrate to the minimum.
// If packet losses are greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.
func (s StreamInputPublishImpl) AbrStepdown() *float64 {
	return s.AbrStepdownValue
}

// A step of reducing the bitrate to the minimum.
// If packet losses are greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.
func (s *StreamInputPublishImpl) SetAbrStepdown(v float64) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.AbrStepdownValue = &v
	return s
}

// Increment step for raising the bitrate to the maximum, in percent. The default step is 30%.
// If the loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup percent`.
func (s StreamInputPublishImpl) AbrStepup() *int {
	return s.AbrStepupValue
}

// Increment step for raising the bitrate to the maximum, in percent. The default step is 30%.
// If the loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup percent`.
func (s *StreamInputPublishImpl) SetAbrStepup(v int) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.AbrStepupValue = &v
	return s
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s StreamInputPublishImpl) AllowIf() *string {
	return s.AllowIfValue
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s *StreamInputPublishImpl) SetAllowIf(v string) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.AllowIfValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputPublishImpl) AudioTimeout() *Seconds {
	return s.AudioTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputPublishImpl) SetAudioTimeout(v Seconds) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.AudioTimeoutValue = &v
	return s
}

// Human-readable description of the input.
// Example: This is a test input
func (s StreamInputPublishImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the input.
// Example: This is a test input
func (s *StreamInputPublishImpl) SetComment(v string) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s StreamInputPublishImpl) DenyIf() *string {
	return s.DenyIfValue
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s *StreamInputPublishImpl) SetDenyIf(v string) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.DenyIfValue = &v
	return s
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s StreamInputPublishImpl) FramesTimeout() *int {
	return s.FramesTimeoutValue
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s *StreamInputPublishImpl) SetFramesTimeout(v int) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.FramesTimeoutValue = &v
	return s
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s StreamInputPublishImpl) Headers() map[string]string {
	return s.HeadersValue
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s *StreamInputPublishImpl) SetHeaders(v map[string]string) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.HeadersValue = v
	return s
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s StreamInputPublishImpl) MaxRetryTimeout() *Seconds {
	return s.MaxRetryTimeoutValue
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s *StreamInputPublishImpl) SetMaxRetryTimeout(v Seconds) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.MaxRetryTimeoutValue = &v
	return s
}

// The minimum bitrate threshold, in kbit/s. The default value is 100 kbit/s.
// Example: 150
func (s StreamInputPublishImpl) MinBitrate() *int {
	return s.MinBitrateValue
}

// The minimum bitrate threshold, in kbit/s. The default value is 100 kbit/s.
// Example: 150
func (s *StreamInputPublishImpl) SetMinBitrate(v int) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.MinBitrateValue = &v
	return s
}

// Skip input start if the stream has no clients.
func (s StreamInputPublishImpl) NoClientsReconnectDelay() *int {
	return s.NoClientsReconnectDelayValue
}

// Skip input start if the stream has no clients.
func (s *StreamInputPublishImpl) SetNoClientsReconnectDelay(v int) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.NoClientsReconnectDelayValue = &v
	return s
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s StreamInputPublishImpl) OutputAudio() *OutputAudio {
	return s.OutputAudioValue
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s *StreamInputPublishImpl) SetOutputAudio(v OutputAudio) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.OutputAudioValue = &v
	return s
}

// Deprecated field. Will be deleted at 24.11
// Choose one of the listed video codecs at the start of the publication via WebRTC.
// Example: av1
func (s StreamInputPublishImpl) PreferCodec() *WebrtcPreferVideoCodec {
	return s.PreferCodecValue
}

// Deprecated field. Will be deleted at 24.11
// Choose one of the listed video codecs at the start of the publication via WebRTC.
// Example: av1
func (s *StreamInputPublishImpl) SetPreferCodec(v WebrtcPreferVideoCodec) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.PreferCodecValue = &v
	return s
}

// Prefer one of the listed video codecs at the start of the publication via WebRTC.
// Example: av1
func (s StreamInputPublishImpl) PreferVideoCodec() *WebrtcPreferVideoCodec {
	return s.PreferVideoCodecValue
}

// Prefer one of the listed video codecs at the start of the publication via WebRTC.
// Example: av1
func (s *StreamInputPublishImpl) SetPreferVideoCodec(v WebrtcPreferVideoCodec) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.PreferVideoCodecValue = &v
	return s
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s StreamInputPublishImpl) Priority() *int {
	return s.PriorityValue
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s *StreamInputPublishImpl) SetPriority(v int) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.PriorityValue = &v
	return s
}

// This option disables processing of SCTE-35 markers from SRT input stream.
// Example: true
func (s StreamInputPublishImpl) Scte35() *bool {
	return s.Scte35Value
}

// This option disables processing of SCTE-35 markers from SRT input stream.
// Example: true
func (s *StreamInputPublishImpl) SetScte35(v bool) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.Scte35Value = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s StreamInputPublishImpl) SourceTimeout() any {
	return s.SourceTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s *StreamInputPublishImpl) SetSourceTimeout(v any) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.SourceTimeoutValue = v
	return s
}

// Detailed runtime information about the input.
func (s StreamInputPublishImpl) Stats() InputStats {
	return s.StatsValue
}

// Detailed runtime information about the input.
func (s *StreamInputPublishImpl) SetStats(v InputStats) StreamInputPublish {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// Deprecated field. Will be deleted at 25.03
// This configuration is deprecated. Use `dvbocr` configuration field in stream.
// This parameter allows to manage subtitles in an output stream.
// Example: drop
func (s StreamInputPublishImpl) Subtitles() *StreamInputSrtPublishSpecificSubtitles {
	return s.SubtitlesValue
}

// Deprecated field. Will be deleted at 25.03
// This configuration is deprecated. Use `dvbocr` configuration field in stream.
// This parameter allows to manage subtitles in an output stream.
// Example: drop
func (s *StreamInputPublishImpl) SetSubtitles(v StreamInputSrtPublishSpecificSubtitles) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.SubtitlesValue = &v
	return s
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s StreamInputPublishImpl) Timeout() *int {
	return s.TimeoutValue
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s *StreamInputPublishImpl) SetTimeout(v int) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// Choose the prefered transport of the publication via WebRTC: UDP or TCP.
// Example: udp
func (s StreamInputPublishImpl) Transport() *WebrtcTransport {
	return s.TransportValue
}

// Choose the prefered transport of the publication via WebRTC: UDP or TCP.
// Example: udp
func (s *StreamInputPublishImpl) SetTransport(v WebrtcTransport) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.TransportValue = &v
	return s
}

// The publish:// URL used to indicate where this stream started in publish mode.
// You can publish videos to Flussonic using the following URLs:
// __RTSP__: rtsp://FLUSSONIC-IP/stream_name
// __HTTP MPEG-TS__: http://FLUSSONIC-IP/stream_name/mpegts
// __RTMP__: rtmp://flussonic-ip/published or rtmp://flussonic-ip/static/published
// __WebRTC__: http://FLUSSONIC-IP/stream_name/whip
// __SRT__: srt://FLUSSONIC-IP:SRT_PORT?streamid=#!::r=STREAM_NAME,m=publish
// Format: input_url (input_url)
// Pattern: ^publish://.*$
// Example: publish://
func (s StreamInputPublishImpl) URL() InputURL {
	return s.URLValue
}

// The publish:// URL used to indicate where this stream started in publish mode.
// You can publish videos to Flussonic using the following URLs:
// __RTSP__: rtsp://FLUSSONIC-IP/stream_name
// __HTTP MPEG-TS__: http://FLUSSONIC-IP/stream_name/mpegts
// __RTMP__: rtmp://flussonic-ip/published or rtmp://flussonic-ip/static/published
// __WebRTC__: http://FLUSSONIC-IP/stream_name/whip
// __SRT__: srt://FLUSSONIC-IP:SRT_PORT?streamid=#!::r=STREAM_NAME,m=publish
// Format: input_url (input_url)
// Pattern: ^publish://.*$
// Example: publish://
func (s *StreamInputPublishImpl) SetURL(v InputURL) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// User agent. Can be modified if a protocol allows it.
func (s StreamInputPublishImpl) UserAgent() *string {
	return s.UserAgentValue
}

// User agent. Can be modified if a protocol allows it.
func (s *StreamInputPublishImpl) SetUserAgent(v string) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.UserAgentValue = &v
	return s
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s StreamInputPublishImpl) Via() *AgentURL {
	return s.ViaValue
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s *StreamInputPublishImpl) SetVia(v AgentURL) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.ViaValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputPublishImpl) VideoTimeout() *Seconds {
	return s.VideoTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputPublishImpl) SetVideoTimeout(v Seconds) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.VideoTimeoutValue = &v
	return s
}

// Whether the adaptive bitrate mechanism is used for WebRTC publications.
// Example: true
func (s StreamInputPublishImpl) WebrtcAbr() *bool {
	return s.WebrtcAbrValue
}

// Whether the adaptive bitrate mechanism is used for WebRTC publications.
// Example: true
func (s *StreamInputPublishImpl) SetWebrtcAbr(v bool) StreamInputPublish {
	if s == nil {
		return nil
	}
	s.WebrtcAbrValue = &v
	return s
}

// NewStreamInputRtsp creates a new StreamInputRtsp instance
func NewStreamInputRtsp() StreamInputRtsp {
	return &StreamInputRtspImpl{}
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s StreamInputRtspImpl) AllowIf() *string {
	return s.AllowIfValue
}

// Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.
// When you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.
// If no such file, the input is allowed.
func (s *StreamInputRtspImpl) SetAllowIf(v string) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.AllowIfValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputRtspImpl) AudioTimeout() *Seconds {
	return s.AudioTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputRtspImpl) SetAudioTimeout(v Seconds) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.AudioTimeoutValue = &v
	return s
}

// Human-readable description of the input.
// Example: This is a test input
func (s StreamInputRtspImpl) Comment() *string {
	return s.CommentValue
}

// Human-readable description of the input.
// Example: This is a test input
func (s *StreamInputRtspImpl) SetComment(v string) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.CommentValue = &v
	return s
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s StreamInputRtspImpl) DenyIf() *string {
	return s.DenyIfValue
}

// Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).
// This option allows you to manage inputs without API requests.
// For example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.
// The `/path/to/file` file contains only the digit `1`.
// That means that the first input will not be used when you play the stream, so the second one will.
// When you put `0` to the `/path/to/file` file, the first input is allowed to be played.
// If no such file, the input is allowed.
func (s *StreamInputRtspImpl) SetDenyIf(v string) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.DenyIfValue = &v
	return s
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s StreamInputRtspImpl) FramesTimeout() *int {
	return s.FramesTimeoutValue
}

// Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost.
// This period of time must be smaller than `source_timeout`.
// If frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.
// Example: 3
func (s *StreamInputRtspImpl) SetFramesTimeout(v int) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.FramesTimeoutValue = &v
	return s
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s StreamInputRtspImpl) Headers() map[string]string {
	return s.HeadersValue
}

// Request headers as key-value pairs.
// Example: map[Authorization:Basic dXNlcjpwYXNzd29yZA== User-Agent:curl/7.85.0]
func (s *StreamInputRtspImpl) SetHeaders(v map[string]string) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.HeadersValue = v
	return s
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s StreamInputRtspImpl) MaxRetryTimeout() *Seconds {
	return s.MaxRetryTimeoutValue
}

// The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.
// The time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.
// Format: seconds (seconds)
// Example: 30
func (s *StreamInputRtspImpl) SetMaxRetryTimeout(v Seconds) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.MaxRetryTimeoutValue = &v
	return s
}

// Skip input start if the stream has no clients.
func (s StreamInputRtspImpl) NoClientsReconnectDelay() *int {
	return s.NoClientsReconnectDelayValue
}

// Skip input start if the stream has no clients.
func (s *StreamInputRtspImpl) SetNoClientsReconnectDelay(v int) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.NoClientsReconnectDelayValue = &v
	return s
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s StreamInputRtspImpl) OutputAudio() *OutputAudio {
	return s.OutputAudioValue
}

// Enables transcoding of the published audio to another codec.
// The option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.
func (s *StreamInputRtspImpl) SetOutputAudio(v OutputAudio) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.OutputAudioValue = &v
	return s
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s StreamInputRtspImpl) Priority() *int {
	return s.PriorityValue
}

// The priority that Media Server takes into account when switching to another source.
// The source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.
// By default, the first source in the list has the highest priority and the last source in the list has the lowest priority.
// If priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied.
// Example: 1
func (s *StreamInputRtspImpl) SetPriority(v int) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.PriorityValue = &v
	return s
}

// Whether to force UDP to capture a video from RTSP cameras.
func (s StreamInputRtspImpl) RTP() *string {
	return s.RTPValue
}

// Whether to force UDP to capture a video from RTSP cameras.
func (s *StreamInputRtspImpl) SetRTP(v string) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.RTPValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s StreamInputRtspImpl) SourceTimeout() any {
	return s.SourceTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.
// Example: 20
func (s *StreamInputRtspImpl) SetSourceTimeout(v any) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.SourceTimeoutValue = v
	return s
}

// Detailed runtime information about the input.
func (s StreamInputRtspImpl) Stats() InputStats {
	return s.StatsValue
}

// Detailed runtime information about the input.
func (s *StreamInputRtspImpl) SetStats(v InputStats) StreamInputRtsp {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*InputStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s StreamInputRtspImpl) Timeout() *int {
	return s.TimeoutValue
}

// The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio).
// The important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.
// Example: 10
func (s *StreamInputRtspImpl) SetTimeout(v int) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.TimeoutValue = &v
	return s
}

// URL to connect to the RTSP source and get the stream.
// Format: input_url (input_url)
// Pattern: ^(rtsp|rtsps|rtsp-udp|rtsp2)://.*$
// Examples: rtsp-udp://remote.host.com/example, rtsp2://remote.host.com/example, rtsp://remote.host.com/example, rtsps://remote.host.com/example
func (s StreamInputRtspImpl) URL() InputURL {
	return s.URLValue
}

// URL to connect to the RTSP source and get the stream.
// Format: input_url (input_url)
// Pattern: ^(rtsp|rtsps|rtsp-udp|rtsp2)://.*$
// Examples: rtsp-udp://remote.host.com/example, rtsp2://remote.host.com/example, rtsp://remote.host.com/example, rtsps://remote.host.com/example
func (s *StreamInputRtspImpl) SetURL(v InputURL) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.URLValue = v
	return s
}

// User agent. Can be modified if a protocol allows it.
func (s StreamInputRtspImpl) UserAgent() *string {
	return s.UserAgentValue
}

// User agent. Can be modified if a protocol allows it.
func (s *StreamInputRtspImpl) SetUserAgent(v string) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.UserAgentValue = &v
	return s
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s StreamInputRtspImpl) Via() *AgentURL {
	return s.ViaValue
}

// Agent ID. Used as a proxy to connect to the input server.
// Format: agent_url (agent://ID identification for `via` configuration option)
func (s *StreamInputRtspImpl) SetVia(v AgentURL) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.ViaValue = &v
	return s
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s StreamInputRtspImpl) VideoTimeout() *Seconds {
	return s.VideoTimeoutValue
}

// The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.
// Format: seconds (seconds)
// Example: 20
func (s *StreamInputRtspImpl) SetVideoTimeout(v Seconds) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.VideoTimeoutValue = &v
	return s
}

// Whether to wait for the full RTP time synchronization before the processing of frames from the RTSP camera.
func (s StreamInputRtspImpl) WaitRtcp() *bool {
	return s.WaitRtcpValue
}

// Whether to wait for the full RTP time synchronization before the processing of frames from the RTSP camera.
func (s *StreamInputRtspImpl) SetWaitRtcp(v bool) StreamInputRtsp {
	if s == nil {
		return nil
	}
	s.WaitRtcpValue = &v
	return s
}

// NewStreamInputSrtPublishSpecific creates a new StreamInputSrtPublishSpecific instance
func NewStreamInputSrtPublishSpecific() StreamInputSrtPublishSpecific {
	return &StreamInputSrtPublishSpecificImpl{}
}

// This option disables processing of SCTE-35 markers from SRT input stream.
// Example: true
func (s StreamInputSrtPublishSpecificImpl) Scte35() *bool {
	return s.Scte35Value
}

// This option disables processing of SCTE-35 markers from SRT input stream.
// Example: true
func (s *StreamInputSrtPublishSpecificImpl) SetScte35(v bool) StreamInputSrtPublishSpecific {
	if s == nil {
		return nil
	}
	s.Scte35Value = &v
	return s
}

// Deprecated field. Will be deleted at 25.03
// This configuration is deprecated. Use `dvbocr` configuration field in stream.
// This parameter allows to manage subtitles in an output stream.
// Example: drop
func (s StreamInputSrtPublishSpecificImpl) Subtitles() *StreamInputSrtPublishSpecificSubtitles {
	return s.SubtitlesValue
}

// Deprecated field. Will be deleted at 25.03
// This configuration is deprecated. Use `dvbocr` configuration field in stream.
// This parameter allows to manage subtitles in an output stream.
// Example: drop
func (s *StreamInputSrtPublishSpecificImpl) SetSubtitles(v StreamInputSrtPublishSpecificSubtitles) StreamInputSrtPublishSpecific {
	if s == nil {
		return nil
	}
	s.SubtitlesValue = &v
	return s
}

// NewStreamInputWebrtcPublishSpecific creates a new StreamInputWebrtcPublishSpecific instance
func NewStreamInputWebrtcPublishSpecific() StreamInputWebrtcPublishSpecific {
	return &StreamInputWebrtcPublishSpecificImpl{}
}

// The correction between the target bitrate (Receiver Estimated Maximum Bitrate, calculated in Flussonic) and browser bitrate, in kbit/s.
// Flussonic sends the target bitrate to the browser from which the publication is carried out so that the browser adjusts the bitrate of the publication by this value.
// The default value is 300 kbit/s.
// Example: 200
func (s StreamInputWebrtcPublishSpecificImpl) AbrCorrection() *int {
	return s.AbrCorrectionValue
}

// The correction between the target bitrate (Receiver Estimated Maximum Bitrate, calculated in Flussonic) and browser bitrate, in kbit/s.
// Flussonic sends the target bitrate to the browser from which the publication is carried out so that the browser adjusts the bitrate of the publication by this value.
// The default value is 300 kbit/s.
// Example: 200
func (s *StreamInputWebrtcPublishSpecificImpl) SetAbrCorrection(v int) StreamInputWebrtcPublishSpecific {
	if s == nil {
		return nil
	}
	s.AbrCorrectionValue = &v
	return s
}

// The number of cycles of bitrate auto-adjustment.
// After the specified number of auto-adjustment cycles passes, Flussonic considers the bitrate to be optimal, and it is no longer analyzed.
// By default, `abr_cycles`=5.
// If `abr_cycles`=0, the adjustment process takes place all the time while the publication lasts.
// Example: 3
func (s StreamInputWebrtcPublishSpecificImpl) AbrCycles() *int {
	return s.AbrCyclesValue
}

// The number of cycles of bitrate auto-adjustment.
// After the specified number of auto-adjustment cycles passes, Flussonic considers the bitrate to be optimal, and it is no longer analyzed.
// By default, `abr_cycles`=5.
// If `abr_cycles`=0, the adjustment process takes place all the time while the publication lasts.
// Example: 3
func (s *StreamInputWebrtcPublishSpecificImpl) SetAbrCycles(v int) StreamInputWebrtcPublishSpecific {
	if s == nil {
		return nil
	}
	s.AbrCyclesValue = &v
	return s
}

// Whether adaptive bitrate process is logged.
// Example: 1
func (s StreamInputWebrtcPublishSpecificImpl) AbrDebug() *int {
	return s.AbrDebugValue
}

// Whether adaptive bitrate process is logged.
// Example: 1
func (s *StreamInputWebrtcPublishSpecificImpl) SetAbrDebug(v int) StreamInputWebrtcPublishSpecific {
	if s == nil {
		return nil
	}
	s.AbrDebugValue = &v
	return s
}

// The lower limit of packet loss. When it is reached, Flussonic raises the bitrate.
// That is, if packet loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup` percent.
// Example: 2
func (s StreamInputWebrtcPublishSpecificImpl) AbrLossLower() *float64 {
	return s.AbrLossLowerValue
}

// The lower limit of packet loss. When it is reached, Flussonic raises the bitrate.
// That is, if packet loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup` percent.
// Example: 2
func (s *StreamInputWebrtcPublishSpecificImpl) SetAbrLossLower(v float64) StreamInputWebrtcPublishSpecific {
	if s == nil {
		return nil
	}
	s.AbrLossLowerValue = &v
	return s
}

// The upper limit of packet loss. When it is reached, Flussonic reduces the bitrate.
// That is, if packet loss is greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.
// Example: 10
func (s StreamInputWebrtcPublishSpecificImpl) AbrLossUpper() *float64 {
	return s.AbrLossUpperValue
}

// The upper limit of packet loss. When it is reached, Flussonic reduces the bitrate.
// That is, if packet loss is greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.
// Example: 10
func (s *StreamInputWebrtcPublishSpecificImpl) SetAbrLossUpper(v float64) StreamInputWebrtcPublishSpecific {
	if s == nil {
		return nil
	}
	s.AbrLossUpperValue = &v
	return s
}

// Maximum bitrate for adjustment process, in kbit/s.
// Flussonic will keep the publication bitrate equal or below of the specified value.
// Example: 1000
func (s StreamInputWebrtcPublishSpecificImpl) AbrMaxBitrate() *int {
	return s.AbrMaxBitrateValue
}

// Maximum bitrate for adjustment process, in kbit/s.
// Flussonic will keep the publication bitrate equal or below of the specified value.
// Example: 1000
func (s *StreamInputWebrtcPublishSpecificImpl) SetAbrMaxBitrate(v int) StreamInputWebrtcPublishSpecific {
	if s == nil {
		return nil
	}
	s.AbrMaxBitrateValue = &v
	return s
}

// The algorithm for determining the need to change the bitrate of the published stream and for calculating the target bitrate.
// Two options are possible:
// * `abr_mode=0` - This mode takes into account the packet losses, target bitrate, browser bitrate and the number of auto-adjustment cycles.
// * `abr_mode=1` - This mode considers only packet losses and target bitrate.
// Example: 1
func (s StreamInputWebrtcPublishSpecificImpl) AbrMode() *int {
	return s.AbrModeValue
}

// The algorithm for determining the need to change the bitrate of the published stream and for calculating the target bitrate.
// Two options are possible:
// * `abr_mode=0` - This mode takes into account the packet losses, target bitrate, browser bitrate and the number of auto-adjustment cycles.
// * `abr_mode=1` - This mode considers only packet losses and target bitrate.
// Example: 1
func (s *StreamInputWebrtcPublishSpecificImpl) SetAbrMode(v int) StreamInputWebrtcPublishSpecific {
	if s == nil {
		return nil
	}
	s.AbrModeValue = &v
	return s
}

// A step of reducing the bitrate to the minimum.
// If packet losses are greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.
func (s StreamInputWebrtcPublishSpecificImpl) AbrStepdown() *float64 {
	return s.AbrStepdownValue
}

// A step of reducing the bitrate to the minimum.
// If packet losses are greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.
func (s *StreamInputWebrtcPublishSpecificImpl) SetAbrStepdown(v float64) StreamInputWebrtcPublishSpecific {
	if s == nil {
		return nil
	}
	s.AbrStepdownValue = &v
	return s
}

// Increment step for raising the bitrate to the maximum, in percent. The default step is 30%.
// If the loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup percent`.
func (s StreamInputWebrtcPublishSpecificImpl) AbrStepup() *int {
	return s.AbrStepupValue
}

// Increment step for raising the bitrate to the maximum, in percent. The default step is 30%.
// If the loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup percent`.
func (s *StreamInputWebrtcPublishSpecificImpl) SetAbrStepup(v int) StreamInputWebrtcPublishSpecific {
	if s == nil {
		return nil
	}
	s.AbrStepupValue = &v
	return s
}

// The minimum bitrate threshold, in kbit/s. The default value is 100 kbit/s.
// Example: 150
func (s StreamInputWebrtcPublishSpecificImpl) MinBitrate() *int {
	return s.MinBitrateValue
}

// The minimum bitrate threshold, in kbit/s. The default value is 100 kbit/s.
// Example: 150
func (s *StreamInputWebrtcPublishSpecificImpl) SetMinBitrate(v int) StreamInputWebrtcPublishSpecific {
	if s == nil {
		return nil
	}
	s.MinBitrateValue = &v
	return s
}

// Deprecated field. Will be deleted at 24.11
// Choose one of the listed video codecs at the start of the publication via WebRTC.
// Example: av1
func (s StreamInputWebrtcPublishSpecificImpl) PreferCodec() *WebrtcPreferVideoCodec {
	return s.PreferCodecValue
}

// Deprecated field. Will be deleted at 24.11
// Choose one of the listed video codecs at the start of the publication via WebRTC.
// Example: av1
func (s *StreamInputWebrtcPublishSpecificImpl) SetPreferCodec(v WebrtcPreferVideoCodec) StreamInputWebrtcPublishSpecific {
	if s == nil {
		return nil
	}
	s.PreferCodecValue = &v
	return s
}

// Prefer one of the listed video codecs at the start of the publication via WebRTC.
// Example: av1
func (s StreamInputWebrtcPublishSpecificImpl) PreferVideoCodec() *WebrtcPreferVideoCodec {
	return s.PreferVideoCodecValue
}

// Prefer one of the listed video codecs at the start of the publication via WebRTC.
// Example: av1
func (s *StreamInputWebrtcPublishSpecificImpl) SetPreferVideoCodec(v WebrtcPreferVideoCodec) StreamInputWebrtcPublishSpecific {
	if s == nil {
		return nil
	}
	s.PreferVideoCodecValue = &v
	return s
}

// Choose the prefered transport of the publication via WebRTC: UDP or TCP.
// Example: udp
func (s StreamInputWebrtcPublishSpecificImpl) Transport() *WebrtcTransport {
	return s.TransportValue
}

// Choose the prefered transport of the publication via WebRTC: UDP or TCP.
// Example: udp
func (s *StreamInputWebrtcPublishSpecificImpl) SetTransport(v WebrtcTransport) StreamInputWebrtcPublishSpecific {
	if s == nil {
		return nil
	}
	s.TransportValue = &v
	return s
}

// Whether the adaptive bitrate mechanism is used for WebRTC publications.
// Example: true
func (s StreamInputWebrtcPublishSpecificImpl) WebrtcAbr() *bool {
	return s.WebrtcAbrValue
}

// Whether the adaptive bitrate mechanism is used for WebRTC publications.
// Example: true
func (s *StreamInputWebrtcPublishSpecificImpl) SetWebrtcAbr(v bool) StreamInputWebrtcPublishSpecific {
	if s == nil {
		return nil
	}
	s.WebrtcAbrValue = &v
	return s
}

// NewStreamOnvifConfig creates a new StreamOnvifConfig instance
func NewStreamOnvifConfig() StreamOnvifConfig {
	return &StreamOnvifConfigImpl{}
}

// Shows if PTZ control should be enabled for the camera.
// The PTZ function must be supported and enabled on the ONVIF camera
// in order to be able to actually control PTZ from Watcher or your UI.
func (s StreamOnvifConfigImpl) Ptz() *bool {
	return s.PtzValue
}

// Shows if PTZ control should be enabled for the camera.
// The PTZ function must be supported and enabled on the ONVIF camera
// in order to be able to actually control PTZ from Watcher or your UI.
func (s *StreamOnvifConfigImpl) SetPtz(v bool) StreamOnvifConfig {
	if s == nil {
		return nil
	}
	s.PtzValue = &v
	return s
}

// NewStreamPathItem creates a new StreamPathItem instance
func NewStreamPathItem() StreamPathItem {
	return &StreamPathItemImpl{}
}

// ID of the path item the stream is included in.
func (s StreamPathItemImpl) ID() *int {
	return s.IDValue
}

// ID of the path item the stream is included in.
func (s *StreamPathItemImpl) SetID(v int) StreamPathItem {
	if s == nil {
		return nil
	}
	s.IDValue = &v
	return s
}

// Title of path item the stream is included in.
func (s StreamPathItemImpl) Title() *string {
	return s.TitleValue
}

// Title of path item the stream is included in.
func (s *StreamPathItemImpl) SetTitle(v string) StreamPathItem {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// NewStreamPermissionsAccess creates a new StreamPermissionsAccess instance
func NewStreamPermissionsAccess() StreamPermissionsAccess {
	return &StreamPermissionsAccessImpl{}
}

// Whether the user can control PTZ cameras
func (s StreamPermissionsAccessImpl) CanUsePtz() *bool {
	return s.CanUsePtzValue
}

// Whether the user can control PTZ cameras
func (s *StreamPermissionsAccessImpl) SetCanUsePtz(v bool) StreamPermissionsAccess {
	if s == nil {
		return nil
	}
	s.CanUsePtzValue = &v
	return s
}

// Whether the user can view the stream
func (s StreamPermissionsAccessImpl) CanView() *bool {
	return s.CanViewValue
}

// Whether the user can view the stream
func (s *StreamPermissionsAccessImpl) SetCanView(v bool) StreamPermissionsAccess {
	if s == nil {
		return nil
	}
	s.CanViewValue = &v
	return s
}

// Whether the user can view the stream archive
func (s StreamPermissionsAccessImpl) CanViewDvr() *bool {
	return s.CanViewDvrValue
}

// Whether the user can view the stream archive
func (s *StreamPermissionsAccessImpl) SetCanViewDvr(v bool) StreamPermissionsAccess {
	if s == nil {
		return nil
	}
	s.CanViewDvrValue = &v
	return s
}

// Maximum archive depth in seconds that user can access
func (s StreamPermissionsAccessImpl) DvrDepthLimit() *int {
	return s.DvrDepthLimitValue
}

// Maximum archive depth in seconds that user can access
func (s *StreamPermissionsAccessImpl) SetDvrDepthLimit(v int) StreamPermissionsAccess {
	if s == nil {
		return nil
	}
	s.DvrDepthLimitValue = &v
	return s
}

// NewStreamPreset creates a new StreamPreset instance
func NewStreamPreset() StreamPreset {
	return &StreamPresetImpl{}
}

// Preset identificator.
func (s StreamPresetImpl) ID() *int {
	return s.IDValue
}

// Preset identificator.
func (s *StreamPresetImpl) SetID(v int) StreamPreset {
	if s == nil {
		return nil
	}
	s.IDValue = &v
	return s
}

// Shows if the preset is adjustable.
// ```is_adjustable``` is needed for a situation where presets are managed by external billing.
// If ```is_adjustable: true``` user can change camera settings meanwhile using this preset.
// If ```is_adjustable: false``` user can not change camera settings meanwhile using this preset.
// If the camera has a non-adjustable presets, the DVR and analytics parameters from PUT requests will not be applied.
// In this case, either make the preset adjustable, or change the preset itself to achieve the required configuration.
// Example: true
func (s StreamPresetImpl) IsAdjustable() *bool {
	return s.IsAdjustableValue
}

// Shows if the preset is adjustable.
// ```is_adjustable``` is needed for a situation where presets are managed by external billing.
// If ```is_adjustable: true``` user can change camera settings meanwhile using this preset.
// If ```is_adjustable: false``` user can not change camera settings meanwhile using this preset.
// If the camera has a non-adjustable presets, the DVR and analytics parameters from PUT requests will not be applied.
// In this case, either make the preset adjustable, or change the preset itself to achieve the required configuration.
// Example: true
func (s *StreamPresetImpl) SetIsAdjustable(v bool) StreamPreset {
	if s == nil {
		return nil
	}
	s.IsAdjustableValue = &v
	return s
}

// Human-readable name of the preset.
// Example: Example preset name
func (s StreamPresetImpl) Title() *string {
	return s.TitleValue
}

// Human-readable name of the preset.
// Example: Example preset name
func (s *StreamPresetImpl) SetTitle(v string) StreamPreset {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// NewStreamStats creates a new StreamStats instance
func NewStreamStats() StreamStats {
	return &StreamStatsImpl{}
}

// The status of the Agent serving the stream.
func (s StreamStatsImpl) AgentStatus() *string {
	return s.AgentStatusValue
}

// The status of the Agent serving the stream.
func (s *StreamStatsImpl) SetAgentStatus(v string) StreamStats {
	if s == nil {
		return nil
	}
	s.AgentStatusValue = &v
	return s
}

// Becomes `false` when `ts_delay` > 12000 (= 12 seconds)
// Example: true
func (s StreamStatsImpl) Alive() *bool {
	return s.AliveValue
}

// Becomes `false` when `ts_delay` > 12000 (= 12 seconds)
// Example: true
func (s *StreamStatsImpl) SetAlive(v bool) StreamStats {
	if s == nil {
		return nil
	}
	s.AliveValue = &v
	return s
}

// Stream bitrate.
// Format: speed (speed)
// Example: 186
func (s StreamStatsImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// Stream bitrate.
// Format: speed (speed)
// Example: 186
func (s *StreamStatsImpl) SetBitrate(v Speed) StreamStats {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// The amount of stream data sent to the clients.
// Format: bytes (bytes)
// Example: 0
func (s StreamStatsImpl) BytesOut() *Bytes {
	return s.BytesOutValue
}

// The amount of stream data sent to the clients.
// Format: bytes (bytes)
// Example: 0
func (s *StreamStatsImpl) SetBytesOut(v Bytes) StreamStats {
	if s == nil {
		return nil
	}
	s.BytesOutValue = &v
	return s
}

// The identifier of the Agent that is currently serving the stream.
// Format: agent_id (agent_id)
func (s StreamStatsImpl) CurrentAgentID() *AgentID {
	return s.CurrentAgentIDValue
}

// The identifier of the Agent that is currently serving the stream.
// Format: agent_id (agent_id)
func (s *StreamStatsImpl) SetCurrentAgentID(v AgentID) StreamStats {
	if s == nil {
		return nil
	}
	s.CurrentAgentIDValue = &v
	return s
}

// The information about the recorded DVR archive.
func (s StreamStatsImpl) DvrInfo() DvrInfo {
	return s.DvrInfoValue
}

// The information about the recorded DVR archive.
func (s *StreamStatsImpl) SetDvrInfo(v DvrInfo) StreamStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*DvrInfoImpl); ok {
		s.DvrInfoValue = impl
	}
	return s
}

// The time when the last time frame was sent to the stream output (in UTC).
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.636383841974e+12
func (s StreamStatsImpl) LastDtsAt() *UtcMs {
	return s.LastDtsAtValue
}

// The time when the last time frame was sent to the stream output (in UTC).
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.636383841974e+12
func (s *StreamStatsImpl) SetLastDtsAt(v UtcMs) StreamStats {
	if s == nil {
		return nil
	}
	s.LastDtsAtValue = &v
	return s
}

// The time period in seconds during which the stream is being captured.
// Can be calculated from `opened_at`
// Format: milliseconds (milliseconds)
// Example: 71977
func (s StreamStatsImpl) Lifetime() *Milliseconds {
	return s.LifetimeValue
}

// The time period in seconds during which the stream is being captured.
// Can be calculated from `opened_at`
// Format: milliseconds (milliseconds)
// Example: 71977
func (s *StreamStatsImpl) SetLifetime(v Milliseconds) StreamStats {
	if s == nil {
		return nil
	}
	s.LifetimeValue = &v
	return s
}

// Technical information about the output media content.
func (s StreamStatsImpl) MediaInfo() MediaInfo {
	return s.MediaInfoValue
}

// Technical information about the output media content.
func (s *StreamStatsImpl) SetMediaInfo(v MediaInfo) StreamStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*MediaInfoImpl); ok {
		s.MediaInfoValue = impl
	}
	return s
}

// Deprecated field. Will be deleted at 25.04
// The number of clients receiving the stream.
// Use play.play_opened_sessions instead
// Format: client_count (client_count)
// Example: 3
func (s StreamStatsImpl) OnlineClients() *ClientCount {
	return s.OnlineClientsValue
}

// Deprecated field. Will be deleted at 25.04
// The number of clients receiving the stream.
// Use play.play_opened_sessions instead
// Format: client_count (client_count)
// Example: 3
func (s *StreamStatsImpl) SetOnlineClients(v ClientCount) StreamStats {
	if s == nil {
		return nil
	}
	s.OnlineClientsValue = &v
	return s
}

// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
// Example: onetime_token
func (s StreamStatsImpl) PlaybackToken() *string {
	return s.PlaybackTokenValue
}

// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
// Example: onetime_token
func (s *StreamStatsImpl) SetPlaybackToken(v string) StreamStats {
	if s == nil {
		return nil
	}
	s.PlaybackTokenValue = &v
	return s
}

// Publish endpoint. Used to publish the stream.
func (s StreamStatsImpl) PublishEndpoint() *string {
	return s.PublishEndpointValue
}

// Publish endpoint. Used to publish the stream.
func (s *StreamStatsImpl) SetPublishEndpoint(v string) StreamStats {
	if s == nil {
		return nil
	}
	s.PublishEndpointValue = &v
	return s
}

// Indicates the status of the stream.
func (s StreamStatsImpl) Status() *StreamStatus {
	return s.StatusValue
}

// Indicates the status of the stream.
func (s *StreamStatsImpl) SetStatus(v StreamStatus) StreamStats {
	if s == nil {
		return nil
	}
	s.StatusValue = &v
	return s
}

// HTTP(s) URL that can be used for streaming API of this stream
func (s StreamStatsImpl) StreamingEndpoint() *string {
	return s.StreamingEndpointValue
}

// HTTP(s) URL that can be used for streaming API of this stream
func (s *StreamStatsImpl) SetStreamingEndpoint(v string) StreamStats {
	if s == nil {
		return nil
	}
	s.StreamingEndpointValue = &v
	return s
}

// The time period during which no frames were received from the stream's input.
// Format: ticks (ticks)
// Example: 1284
func (s StreamStatsImpl) TSDelay() *Ticks {
	return s.TSDelayValue
}

// The time period during which no frames were received from the stream's input.
// Format: ticks (ticks)
// Example: 1284
func (s *StreamStatsImpl) SetTSDelay(v Ticks) StreamStats {
	if s == nil {
		return nil
	}
	s.TSDelayValue = &v
	return s
}

// NewStreamUserPermission creates a new StreamUserPermission instance
func NewStreamUserPermission() StreamUserPermission {
	return &StreamUserPermissionImpl{}
}

func (s StreamUserPermissionImpl) Permissions() StreamUserPermissionPermissions {
	return s.PermissionsValue
}

func (s *StreamUserPermissionImpl) SetPermissions(v StreamUserPermissionPermissions) StreamUserPermission {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*StreamUserPermissionPermissionsImpl); ok {
		s.PermissionsValue = impl
	}
	return s
}

func (s StreamUserPermissionImpl) User() StreamUserPermissionUser {
	return s.UserValue
}

func (s *StreamUserPermissionImpl) SetUser(v StreamUserPermissionUser) StreamUserPermission {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*StreamUserPermissionUserImpl); ok {
		s.UserValue = impl
	}
	return s
}

// NewStreamUserPermissionPermissions creates a new StreamUserPermissionPermissions instance
func NewStreamUserPermissionPermissions() StreamUserPermissionPermissions {
	return &StreamUserPermissionPermissionsImpl{}
}

// Whether the user can control PTZ cameras
func (s StreamUserPermissionPermissionsImpl) CanUsePtz() *bool {
	return s.CanUsePtzValue
}

// Whether the user can control PTZ cameras
func (s *StreamUserPermissionPermissionsImpl) SetCanUsePtz(v bool) StreamUserPermissionPermissions {
	if s == nil {
		return nil
	}
	s.CanUsePtzValue = &v
	return s
}

// Whether the user can view the stream
func (s StreamUserPermissionPermissionsImpl) CanView() *bool {
	return s.CanViewValue
}

// Whether the user can view the stream
func (s *StreamUserPermissionPermissionsImpl) SetCanView(v bool) StreamUserPermissionPermissions {
	if s == nil {
		return nil
	}
	s.CanViewValue = &v
	return s
}

// Whether the user can view the stream archive
func (s StreamUserPermissionPermissionsImpl) CanViewDvr() *bool {
	return s.CanViewDvrValue
}

// Whether the user can view the stream archive
func (s *StreamUserPermissionPermissionsImpl) SetCanViewDvr(v bool) StreamUserPermissionPermissions {
	if s == nil {
		return nil
	}
	s.CanViewDvrValue = &v
	return s
}

// Maximum archive depth in seconds that user can access
func (s StreamUserPermissionPermissionsImpl) DvrDepthLimit() *int {
	return s.DvrDepthLimitValue
}

// Maximum archive depth in seconds that user can access
func (s *StreamUserPermissionPermissionsImpl) SetDvrDepthLimit(v int) StreamUserPermissionPermissions {
	if s == nil {
		return nil
	}
	s.DvrDepthLimitValue = &v
	return s
}

// NewStreamUserPermissionUser creates a new StreamUserPermissionUser instance
func NewStreamUserPermissionUser() StreamUserPermissionUser {
	return &StreamUserPermissionUserImpl{}
}

// User identifier
func (s StreamUserPermissionUserImpl) ID() *int {
	return s.IDValue
}

// User identifier
func (s *StreamUserPermissionUserImpl) SetID(v int) StreamUserPermissionUser {
	if s == nil {
		return nil
	}
	s.IDValue = &v
	return s
}

// NewStreamUsersPermissionsList creates a new StreamUsersPermissionsList instance
func NewStreamUsersPermissionsList() StreamUsersPermissionsList {
	return &StreamUsersPermissionsListImpl{}
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s StreamUsersPermissionsListImpl) EstimatedCount() *int {
	return s.EstimatedCountValue
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s *StreamUsersPermissionsListImpl) SetEstimatedCount(v int) StreamUsersPermissionsList {
	if s == nil {
		return nil
	}
	s.EstimatedCountValue = &v
	return s
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s StreamUsersPermissionsListImpl) Next() *string {
	return s.NextValue
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s *StreamUsersPermissionsListImpl) SetNext(v string) StreamUsersPermissionsList {
	if s == nil {
		return nil
	}
	s.NextValue = &v
	return s
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s StreamUsersPermissionsListImpl) Prev() *string {
	return s.PrevValue
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s *StreamUsersPermissionsListImpl) SetPrev(v string) StreamUsersPermissionsList {
	if s == nil {
		return nil
	}
	s.PrevValue = &v
	return s
}

// An object with a list of different timings measured during this API call.
func (s StreamUsersPermissionsListImpl) Timing() any {
	return s.TimingValue
}

// An object with a list of different timings measured during this API call.
func (s *StreamUsersPermissionsListImpl) SetTiming(v any) StreamUsersPermissionsList {
	if s == nil {
		return nil
	}
	s.TimingValue = v
	return s
}

// List of users
func (s StreamUsersPermissionsListImpl) UsersPermissions() []StreamUserPermission {
	if s.UsersPermissionsValue == nil {
		return nil
	}
	result := make([]StreamUserPermission, len(s.UsersPermissionsValue))
	for i, item := range s.UsersPermissionsValue {
		result[i] = item
	}
	return result
}

// List of users
func (s *StreamUsersPermissionsListImpl) SetUsersPermissions(v []StreamUserPermission) StreamUsersPermissionsList {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*StreamUserPermissionImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*StreamUserPermissionImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.UsersPermissionsValue = impl
	}
	return s
}

// Collection returns the collection items from StreamUsersPermissionsList
func (s StreamUsersPermissionsListImpl) Collection() []StreamUserPermission {
	return s.UsersPermissions()
}

// NewStreamsImportResponse creates a new StreamsImportResponse instance
func NewStreamsImportResponse() StreamsImportResponse {
	return &StreamsImportResponseImpl{}
}

// The number of streams created
func (s StreamsImportResponseImpl) Created() *int {
	return s.CreatedValue
}

// The number of streams created
func (s *StreamsImportResponseImpl) SetCreated(v int) StreamsImportResponse {
	if s == nil {
		return nil
	}
	s.CreatedValue = &v
	return s
}

// The number of streams updated
func (s StreamsImportResponseImpl) Updated() *int {
	return s.UpdatedValue
}

// The number of streams updated
func (s *StreamsImportResponseImpl) SetUpdated(v int) StreamsImportResponse {
	if s == nil {
		return nil
	}
	s.UpdatedValue = &v
	return s
}

// NewStreamsList creates a new StreamsList instance
func NewStreamsList() StreamsList {
	return &StreamsListImpl{}
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s StreamsListImpl) EstimatedCount() *int {
	return s.EstimatedCountValue
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s *StreamsListImpl) SetEstimatedCount(v int) StreamsList {
	if s == nil {
		return nil
	}
	s.EstimatedCountValue = &v
	return s
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s StreamsListImpl) Next() *string {
	return s.NextValue
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s *StreamsListImpl) SetNext(v string) StreamsList {
	if s == nil {
		return nil
	}
	s.NextValue = &v
	return s
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s StreamsListImpl) Prev() *string {
	return s.PrevValue
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s *StreamsListImpl) SetPrev(v string) StreamsList {
	if s == nil {
		return nil
	}
	s.PrevValue = &v
	return s
}

// List of fetched streams according to the query parameters.
func (s StreamsListImpl) Streams() []StreamConfig {
	if s.StreamsValue == nil {
		return nil
	}
	result := make([]StreamConfig, len(s.StreamsValue))
	for i, item := range s.StreamsValue {
		result[i] = item
	}
	return result
}

// List of fetched streams according to the query parameters.
func (s *StreamsListImpl) SetStreams(v []StreamConfig) StreamsList {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*StreamConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*StreamConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.StreamsValue = impl
	}
	return s
}

// An object with a list of different timings measured during this API call.
func (s StreamsListImpl) Timing() any {
	return s.TimingValue
}

// An object with a list of different timings measured during this API call.
func (s *StreamsListImpl) SetTiming(v any) StreamsList {
	if s == nil {
		return nil
	}
	s.TimingValue = v
	return s
}

// Collection returns the collection items from StreamsList
func (s StreamsListImpl) Collection() []StreamConfig {
	return s.Streams()
}

// NewStreamsMultieditConfig creates a new StreamsMultieditConfig instance
func NewStreamsMultieditConfig() StreamsMultieditConfig {
	return &StreamsMultieditConfigImpl{}
}

// List of streams with their settings
func (s StreamsMultieditConfigImpl) Streams() []StreamConfigMultiedit {
	if s.StreamsValue == nil {
		return nil
	}
	result := make([]StreamConfigMultiedit, len(s.StreamsValue))
	for i, item := range s.StreamsValue {
		result[i] = item
	}
	return result
}

// List of streams with their settings
func (s *StreamsMultieditConfigImpl) SetStreams(v []StreamConfigMultiedit) StreamsMultieditConfig {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*StreamConfigMultieditImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*StreamConfigMultieditImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.StreamsValue = impl
	}
	return s
}

// NewSubscription creates a new Subscription instance
func NewSubscription() Subscription {
	return &SubscriptionImpl{}
}

// Choosing which type of events to subscribe to
func (s SubscriptionImpl) EventTypes() SubscriptionRequestEventTypes {
	return s.EventTypesValue
}

// Choosing which type of events to subscribe to
func (s *SubscriptionImpl) SetEventTypes(v SubscriptionRequestEventTypes) Subscription {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*SubscriptionRequestEventTypesImpl); ok {
		s.EventTypesValue = impl
	}
	return s
}

// notification frequency in seconds
// Format: seconds (seconds)
func (s SubscriptionImpl) NotificationFrequency() *Seconds {
	return s.NotificationFrequencyValue
}

// notification frequency in seconds
// Format: seconds (seconds)
func (s *SubscriptionImpl) SetNotificationFrequency(v Seconds) Subscription {
	if s == nil {
		return nil
	}
	s.NotificationFrequencyValue = &v
	return s
}

// Type of notification
func (s SubscriptionImpl) NotificationType() string {
	return s.NotificationTypeValue
}

// Type of notification
func (s *SubscriptionImpl) SetNotificationType(v string) Subscription {
	if s == nil {
		return nil
	}
	s.NotificationTypeValue = v
	return s
}

// stream identificator
func (s SubscriptionImpl) StreamName() string {
	return s.StreamNameValue
}

// stream identificator
func (s *SubscriptionImpl) SetStreamName(v string) Subscription {
	if s == nil {
		return nil
	}
	s.StreamNameValue = v
	return s
}

// NewSubscriptionRequest creates a new SubscriptionRequest instance
func NewSubscriptionRequest() SubscriptionRequest {
	return &SubscriptionRequestImpl{}
}

// Choosing which type of events to subscribe to
func (s SubscriptionRequestImpl) EventTypes() SubscriptionRequestEventTypes {
	return s.EventTypesValue
}

// Choosing which type of events to subscribe to
func (s *SubscriptionRequestImpl) SetEventTypes(v SubscriptionRequestEventTypes) SubscriptionRequest {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*SubscriptionRequestEventTypesImpl); ok {
		s.EventTypesValue = impl
	}
	return s
}

// Type of notification
func (s SubscriptionRequestImpl) NotificationType() string {
	return s.NotificationTypeValue
}

// Type of notification
func (s *SubscriptionRequestImpl) SetNotificationType(v string) SubscriptionRequest {
	if s == nil {
		return nil
	}
	s.NotificationTypeValue = v
	return s
}

// stream identificator
func (s SubscriptionRequestImpl) StreamName() string {
	return s.StreamNameValue
}

// stream identificator
func (s *SubscriptionRequestImpl) SetStreamName(v string) SubscriptionRequest {
	if s == nil {
		return nil
	}
	s.StreamNameValue = v
	return s
}

// NewSubscriptionRequestEventTypes creates a new SubscriptionRequestEventTypes instance
func NewSubscriptionRequestEventTypes() SubscriptionRequestEventTypes {
	return &SubscriptionRequestEventTypesImpl{}
}

// Face episode
// Example: true
func (s SubscriptionRequestEventTypesImpl) EpisodeFace() *bool {
	return s.EpisodeFaceValue
}

// Face episode
// Example: true
func (s *SubscriptionRequestEventTypesImpl) SetEpisodeFace(v bool) SubscriptionRequestEventTypes {
	if s == nil {
		return nil
	}
	s.EpisodeFaceValue = &v
	return s
}

// Generic episode
// Example: true
func (s SubscriptionRequestEventTypesImpl) EpisodeGeneric() *bool {
	return s.EpisodeGenericValue
}

// Generic episode
// Example: true
func (s *SubscriptionRequestEventTypesImpl) SetEpisodeGeneric(v bool) SubscriptionRequestEventTypes {
	if s == nil {
		return nil
	}
	s.EpisodeGenericValue = &v
	return s
}

// Vehicle episode
// Example: false
func (s SubscriptionRequestEventTypesImpl) EpisodeVehicle() *bool {
	return s.EpisodeVehicleValue
}

// Vehicle episode
// Example: false
func (s *SubscriptionRequestEventTypesImpl) SetEpisodeVehicle(v bool) SubscriptionRequestEventTypes {
	if s == nil {
		return nil
	}
	s.EpisodeVehicleValue = &v
	return s
}

// Get notified when a stream goes offline
// Example: true
func (s SubscriptionRequestEventTypesImpl) StreamDead() *bool {
	return s.StreamDeadValue
}

// Get notified when a stream goes offline
// Example: true
func (s *SubscriptionRequestEventTypesImpl) SetStreamDead(v bool) SubscriptionRequestEventTypes {
	if s == nil {
		return nil
	}
	s.StreamDeadValue = &v
	return s
}

// NewThumbnailsSpec creates a new ThumbnailsSpec instance
func NewThumbnailsSpec() ThumbnailsSpec {
	return &ThumbnailsSpecImpl{}
}

// Whether to generate thumbnails from the video stream.
func (s ThumbnailsSpecImpl) Enabled() any {
	return s.EnabledValue
}

// Whether to generate thumbnails from the video stream.
func (s *ThumbnailsSpecImpl) SetEnabled(v any) ThumbnailsSpec {
	if s == nil {
		return nil
	}
	s.EnabledValue = v
	return s
}

// NewTrackInfo creates a new TrackInfo instance
func NewTrackInfo() TrackInfo {
	return &TrackInfoImpl{}
}

// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
// The higher FPS is, the smoother the video playback is.
// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
func (s TrackInfoImpl) AvgFPS() *float64 {
	return s.AvgFPSValue
}

// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
// The higher FPS is, the smoother the video playback is.
// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
func (s *TrackInfoImpl) SetAvgFPS(v float64) TrackInfo {
	if s == nil {
		return nil
	}
	s.AvgFPSValue = &v
	return s
}

// Average GOP size (expressed in number of frames) of the last 1000-2000 frames.
// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
// If this value is floating, this means that your transcoder is working in flexible GOP size mode and some players may have problems.
// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
// Example: 25
func (s TrackInfoImpl) AvgGop() *int {
	return s.AvgGopValue
}

// Average GOP size (expressed in number of frames) of the last 1000-2000 frames.
// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
// If this value is floating, this means that your transcoder is working in flexible GOP size mode and some players may have problems.
// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
// Example: 25
func (s *TrackInfoImpl) SetAvgGop(v int) TrackInfo {
	if s == nil {
		return nil
	}
	s.AvgGopValue = &v
	return s
}

// Bandwidth necessary to transfer this track.
// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
// Format: speed (speed)
// Example: 2600
func (s TrackInfoImpl) Bandwidth() *Speed {
	return s.BandwidthValue
}

// Bandwidth necessary to transfer this track.
// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
// Format: speed (speed)
// Example: 2600
func (s *TrackInfoImpl) SetBandwidth(v Speed) TrackInfo {
	if s == nil {
		return nil
	}
	s.BandwidthValue = &v
	return s
}

// Average number of B-frames in a GOP. B-frames contain links to keyframes and P-frames before and after themselves.
// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
// Example: 3
func (s TrackInfoImpl) Bframes() *int {
	return s.BframesValue
}

// Average number of B-frames in a GOP. B-frames contain links to keyframes and P-frames before and after themselves.
// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
// Example: 3
func (s *TrackInfoImpl) SetBframes(v int) TrackInfo {
	if s == nil {
		return nil
	}
	s.BframesValue = &v
	return s
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s TrackInfoImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s *TrackInfoImpl) SetBitrate(v Speed) TrackInfo {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// The number of audio channels.
// Example: 2
func (s TrackInfoImpl) Channels() *int {
	return s.ChannelsValue
}

// The number of audio channels.
// Example: 2
func (s *TrackInfoImpl) SetChannels(v int) TrackInfo {
	if s == nil {
		return nil
	}
	s.ChannelsValue = &v
	return s
}

// Parameters of closed captions.
func (s TrackInfoImpl) ClosedCaptions() []ClosedCaptions {
	if s.ClosedCaptionsValue == nil {
		return nil
	}
	result := make([]ClosedCaptions, len(s.ClosedCaptionsValue))
	for i, item := range s.ClosedCaptionsValue {
		result[i] = item
	}
	return result
}

// Parameters of closed captions.
func (s *TrackInfoImpl) SetClosedCaptions(v []ClosedCaptions) TrackInfo {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*ClosedCaptionsImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*ClosedCaptionsImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.ClosedCaptionsValue = impl
	}
	return s
}

// Codec of the track. Different codecs do **not** get the same track.
// Example: h264
func (s TrackInfoImpl) Codec() *FrameCodec {
	return s.CodecValue
}

// Codec of the track. Different codecs do **not** get the same track.
// Example: h264
func (s *TrackInfoImpl) SetCodec(v FrameCodec) TrackInfo {
	if s == nil {
		return nil
	}
	s.CodecValue = &v
	return s
}

// Content of the track (audio, video, or text).
func (s TrackInfoImpl) Content() FrameContent {
	return s.ContentValue
}

// Content of the track (audio, video, or text).
func (s *TrackInfoImpl) SetContent(v FrameContent) TrackInfo {
	if s == nil {
		return nil
	}
	s.ContentValue = v
	return s
}

// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
// Higher frame rates capture more images per second, which makes for smoother video.
// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
func (s TrackInfoImpl) FPS() *float64 {
	return s.FPSValue
}

// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
// Higher frame rates capture more images per second, which makes for smoother video.
// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
func (s *TrackInfoImpl) SetFPS(v float64) TrackInfo {
	if s == nil {
		return nil
	}
	s.FPSValue = &v
	return s
}

// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
// However, sometimes (when the connection is broken) video breakups are possible.
// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
// This situation is considered as a frame gap and is handled differently across different protocols.
// Format: ticks (ticks)
func (s TrackInfoImpl) FrameDuration() *Ticks {
	return s.FrameDurationValue
}

// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
// However, sometimes (when the connection is broken) video breakups are possible.
// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
// This situation is considered as a frame gap and is handled differently across different protocols.
// Format: ticks (ticks)
func (s *TrackInfoImpl) SetFrameDuration(v Ticks) TrackInfo {
	if s == nil {
		return nil
	}
	s.FrameDurationValue = &v
	return s
}

// The number of frames in a group of pictures (GOP).
// The encoder will create all GOPs of an exactly identical size - as specified in this option.
// A bigger GOP can be good for video compression but it can result in big zap-time (the duration of time between changing a channel and displaying a new channel.)
func (s TrackInfoImpl) GopSize() *int {
	return s.GopSizeValue
}

// The number of frames in a group of pictures (GOP).
// The encoder will create all GOPs of an exactly identical size - as specified in this option.
// A bigger GOP can be good for video compression but it can result in big zap-time (the duration of time between changing a channel and displaying a new channel.)
func (s *TrackInfoImpl) SetGopSize(v int) TrackInfo {
	if s == nil {
		return nil
	}
	s.GopSizeValue = &v
	return s
}

// The picture height in pixels on the display where it will be played by a player.
// If you need to insert a web-player into a web page, use this value for choosing the player size.
// Format: pixels (pixels)
func (s TrackInfoImpl) Height() *Pixels {
	return s.HeightValue
}

// The picture height in pixels on the display where it will be played by a player.
// If you need to insert a web-player into a web page, use this value for choosing the player size.
// Format: pixels (pixels)
func (s *TrackInfoImpl) SetHeight(v Pixels) TrackInfo {
	if s == nil {
		return nil
	}
	s.HeightValue = &v
	return s
}

// Indicates if progressive scanning method is used for all frames of the track
func (s TrackInfoImpl) IsProgressive() *bool {
	return s.IsProgressiveValue
}

// Indicates if progressive scanning method is used for all frames of the track
func (s *TrackInfoImpl) SetIsProgressive(v bool) TrackInfo {
	if s == nil {
		return nil
	}
	s.IsProgressiveValue = &v
	return s
}

// Language value of the track, if applicable.
// Example: eng
func (s TrackInfoImpl) Language() *string {
	return s.LanguageValue
}

// Language value of the track, if applicable.
// Example: eng
func (s *TrackInfoImpl) SetLanguage(v string) TrackInfo {
	if s == nil {
		return nil
	}
	s.LanguageValue = &v
	return s
}

// Last GOP size (expressed in number of frames).
// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
// If this value is floating, this means that your transcoder is working in a flexible GOP size mode and some players may have problems.
// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
// Example: 28
func (s TrackInfoImpl) LastGop() *int {
	return s.LastGopValue
}

// Last GOP size (expressed in number of frames).
// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
// If this value is floating, this means that your transcoder is working in a flexible GOP size mode and some players may have problems.
// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
// Example: 28
func (s *TrackInfoImpl) SetLastGop(v int) TrackInfo {
	if s == nil {
		return nil
	}
	s.LastGopValue = &v
	return s
}

// The size of the length field for H264 bitstream without start codes.
func (s TrackInfoImpl) LengthSize() *int {
	return s.LengthSizeValue
}

// The size of the length field for H264 bitstream without start codes.
func (s *TrackInfoImpl) SetLengthSize(v int) TrackInfo {
	if s == nil {
		return nil
	}
	s.LengthSizeValue = &v
	return s
}

// A set of constraints that indicate a degree of required decoder performance.
// This parameter is used for compatibility with old devices.
func (s TrackInfoImpl) Level() *string {
	return s.LevelValue
}

// A set of constraints that indicate a degree of required decoder performance.
// This parameter is used for compatibility with old devices.
func (s *TrackInfoImpl) SetLevel(v string) TrackInfo {
	if s == nil {
		return nil
	}
	s.LevelValue = &v
	return s
}

// The number of I-frames to be used for encoding.
func (s TrackInfoImpl) NumRefsFrames() *int {
	return s.NumRefsFramesValue
}

// The number of I-frames to be used for encoding.
func (s *TrackInfoImpl) SetNumRefsFrames(v int) TrackInfo {
	if s == nil {
		return nil
	}
	s.NumRefsFramesValue = &v
	return s
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s TrackInfoImpl) Pid() *int {
	return s.PidValue
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s *TrackInfoImpl) SetPid(v int) TrackInfo {
	if s == nil {
		return nil
	}
	s.PidValue = &v
	return s
}

// The color model of the video.
func (s TrackInfoImpl) PixFmt() *FrameVideoPixFmt {
	return s.PixFmtValue
}

// The color model of the video.
func (s *TrackInfoImpl) SetPixFmt(v FrameVideoPixFmt) TrackInfo {
	if s == nil {
		return nil
	}
	s.PixFmtValue = &v
	return s
}

// The picture width in pixels of the original video before transcoding.
// Format: pixels (pixels)
func (s TrackInfoImpl) PixelHeight() *Pixels {
	return s.PixelHeightValue
}

// The picture width in pixels of the original video before transcoding.
// Format: pixels (pixels)
func (s *TrackInfoImpl) SetPixelHeight(v Pixels) TrackInfo {
	if s == nil {
		return nil
	}
	s.PixelHeightValue = &v
	return s
}

// The picture width in pixels of the original video before transcoding.
// Format: pixels (pixels)
func (s TrackInfoImpl) PixelWidth() *Pixels {
	return s.PixelWidthValue
}

// The picture width in pixels of the original video before transcoding.
// Format: pixels (pixels)
func (s *TrackInfoImpl) SetPixelWidth(v Pixels) TrackInfo {
	if s == nil {
		return nil
	}
	s.PixelWidthValue = &v
	return s
}

// A specific codec-dependent profile of the output video.
// The profile allows to assume if the track can be played on a particular device.
func (s TrackInfoImpl) Profile() *string {
	return s.ProfileValue
}

// A specific codec-dependent profile of the output video.
// The profile allows to assume if the track can be played on a particular device.
func (s *TrackInfoImpl) SetProfile(v string) TrackInfo {
	if s == nil {
		return nil
	}
	s.ProfileValue = &v
	return s
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// Example: 8000
func (s TrackInfoImpl) SampleRate() *int {
	return s.SampleRateValue
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// Example: 8000
func (s *TrackInfoImpl) SetSampleRate(v int) TrackInfo {
	if s == nil {
		return nil
	}
	s.SampleRateValue = &v
	return s
}

// The second number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
// SAR is used for creating non-anamorphic video from anamorphic video.
func (s TrackInfoImpl) SarHeight() *int {
	return s.SarHeightValue
}

// The second number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
// SAR is used for creating non-anamorphic video from anamorphic video.
func (s *TrackInfoImpl) SetSarHeight(v int) TrackInfo {
	if s == nil {
		return nil
	}
	s.SarHeightValue = &v
	return s
}

// The first number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
// SAR is used for creating non-anamorphic video from anamorphic video.
func (s TrackInfoImpl) SarWidth() *int {
	return s.SarWidthValue
}

// The first number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
// SAR is used for creating non-anamorphic video from anamorphic video.
func (s *TrackInfoImpl) SetSarWidth(v int) TrackInfo {
	if s == nil {
		return nil
	}
	s.SarWidthValue = &v
	return s
}

// Human-readable localized title of the track.
// Example: Video1
func (s TrackInfoImpl) Title() *string {
	return s.TitleValue
}

// Human-readable localized title of the track.
// Example: Video1
func (s *TrackInfoImpl) SetTitle(v string) TrackInfo {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// Track identifier assigned by Flussonic.
// Example: v1
func (s TrackInfoImpl) TrackID() any {
	return s.TrackIDValue
}

// Track identifier assigned by Flussonic.
// Example: v1
func (s *TrackInfoImpl) SetTrackID(v any) TrackInfo {
	if s == nil {
		return nil
	}
	s.TrackIDValue = v
	return s
}

// The picture width in pixels on the display where it will be played by a player.
// If you need to insert a web-player into a web page, use this value for choosing the player size.
// Format: pixels (pixels)
func (s TrackInfoImpl) Width() *Pixels {
	return s.WidthValue
}

// The picture width in pixels on the display where it will be played by a player.
// If you need to insert a web-player into a web page, use this value for choosing the player size.
// Format: pixels (pixels)
func (s *TrackInfoImpl) SetWidth(v Pixels) TrackInfo {
	if s == nil {
		return nil
	}
	s.WidthValue = &v
	return s
}

// NewTrackInfoApplication creates a new TrackInfoApplication instance
func NewTrackInfoApplication() TrackInfoApplication {
	return &TrackInfoApplicationImpl{}
}

// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
// The higher FPS is, the smoother the video playback is.
// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
func (s TrackInfoApplicationImpl) AvgFPS() *float64 {
	return s.AvgFPSValue
}

// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
// The higher FPS is, the smoother the video playback is.
// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
func (s *TrackInfoApplicationImpl) SetAvgFPS(v float64) TrackInfoApplication {
	if s == nil {
		return nil
	}
	s.AvgFPSValue = &v
	return s
}

// Bandwidth necessary to transfer this track.
// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
// Format: speed (speed)
// Example: 2600
func (s TrackInfoApplicationImpl) Bandwidth() *Speed {
	return s.BandwidthValue
}

// Bandwidth necessary to transfer this track.
// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
// Format: speed (speed)
// Example: 2600
func (s *TrackInfoApplicationImpl) SetBandwidth(v Speed) TrackInfoApplication {
	if s == nil {
		return nil
	}
	s.BandwidthValue = &v
	return s
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s TrackInfoApplicationImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s *TrackInfoApplicationImpl) SetBitrate(v Speed) TrackInfoApplication {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// Codec of the track. Different codecs do **not** get the same track.
// Example: h264
func (s TrackInfoApplicationImpl) Codec() *FrameCodec {
	return s.CodecValue
}

// Codec of the track. Different codecs do **not** get the same track.
// Example: h264
func (s *TrackInfoApplicationImpl) SetCodec(v FrameCodec) TrackInfoApplication {
	if s == nil {
		return nil
	}
	s.CodecValue = &v
	return s
}

// Content of the track (audio, video, or text).
func (s TrackInfoApplicationImpl) Content() FrameContent {
	return s.ContentValue
}

// Content of the track (audio, video, or text).
func (s *TrackInfoApplicationImpl) SetContent(v FrameContent) TrackInfoApplication {
	if s == nil {
		return nil
	}
	s.ContentValue = v
	return s
}

// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
// However, sometimes (when the connection is broken) video breakups are possible.
// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
// This situation is considered as a frame gap and is handled differently across different protocols.
// Format: ticks (ticks)
func (s TrackInfoApplicationImpl) FrameDuration() *Ticks {
	return s.FrameDurationValue
}

// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
// However, sometimes (when the connection is broken) video breakups are possible.
// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
// This situation is considered as a frame gap and is handled differently across different protocols.
// Format: ticks (ticks)
func (s *TrackInfoApplicationImpl) SetFrameDuration(v Ticks) TrackInfoApplication {
	if s == nil {
		return nil
	}
	s.FrameDurationValue = &v
	return s
}

// Language value of the track, if applicable.
// Example: eng
func (s TrackInfoApplicationImpl) Language() *string {
	return s.LanguageValue
}

// Language value of the track, if applicable.
// Example: eng
func (s *TrackInfoApplicationImpl) SetLanguage(v string) TrackInfoApplication {
	if s == nil {
		return nil
	}
	s.LanguageValue = &v
	return s
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s TrackInfoApplicationImpl) Pid() *int {
	return s.PidValue
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s *TrackInfoApplicationImpl) SetPid(v int) TrackInfoApplication {
	if s == nil {
		return nil
	}
	s.PidValue = &v
	return s
}

// Human-readable localized title of the track.
// Example: Video1
func (s TrackInfoApplicationImpl) Title() *string {
	return s.TitleValue
}

// Human-readable localized title of the track.
// Example: Video1
func (s *TrackInfoApplicationImpl) SetTitle(v string) TrackInfoApplication {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// Track identifier assigned by Flussonic.
// Example: v1
func (s TrackInfoApplicationImpl) TrackID() any {
	return s.TrackIDValue
}

// Track identifier assigned by Flussonic.
// Example: v1
func (s *TrackInfoApplicationImpl) SetTrackID(v any) TrackInfoApplication {
	if s == nil {
		return nil
	}
	s.TrackIDValue = v
	return s
}

// NewTrackInfoApplicationSpecific creates a new TrackInfoApplicationSpecific instance
func NewTrackInfoApplicationSpecific() TrackInfoApplicationSpecific {
	return &TrackInfoApplicationSpecificImpl{}
}

// Language value of the track, if applicable.
// Example: eng
func (s TrackInfoApplicationSpecificImpl) Language() *string {
	return s.LanguageValue
}

// Language value of the track, if applicable.
// Example: eng
func (s *TrackInfoApplicationSpecificImpl) SetLanguage(v string) TrackInfoApplicationSpecific {
	if s == nil {
		return nil
	}
	s.LanguageValue = &v
	return s
}

// NewTrackInfoAudio creates a new TrackInfoAudio instance
func NewTrackInfoAudio() TrackInfoAudio {
	return &TrackInfoAudioImpl{}
}

// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
// The higher FPS is, the smoother the video playback is.
// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
func (s TrackInfoAudioImpl) AvgFPS() *float64 {
	return s.AvgFPSValue
}

// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
// The higher FPS is, the smoother the video playback is.
// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
func (s *TrackInfoAudioImpl) SetAvgFPS(v float64) TrackInfoAudio {
	if s == nil {
		return nil
	}
	s.AvgFPSValue = &v
	return s
}

// Bandwidth necessary to transfer this track.
// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
// Format: speed (speed)
// Example: 2600
func (s TrackInfoAudioImpl) Bandwidth() *Speed {
	return s.BandwidthValue
}

// Bandwidth necessary to transfer this track.
// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
// Format: speed (speed)
// Example: 2600
func (s *TrackInfoAudioImpl) SetBandwidth(v Speed) TrackInfoAudio {
	if s == nil {
		return nil
	}
	s.BandwidthValue = &v
	return s
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s TrackInfoAudioImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s *TrackInfoAudioImpl) SetBitrate(v Speed) TrackInfoAudio {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// The number of audio channels.
// Example: 2
func (s TrackInfoAudioImpl) Channels() *int {
	return s.ChannelsValue
}

// The number of audio channels.
// Example: 2
func (s *TrackInfoAudioImpl) SetChannels(v int) TrackInfoAudio {
	if s == nil {
		return nil
	}
	s.ChannelsValue = &v
	return s
}

// Codec of the track. Different codecs do **not** get the same track.
// Example: h264
func (s TrackInfoAudioImpl) Codec() *FrameCodec {
	return s.CodecValue
}

// Codec of the track. Different codecs do **not** get the same track.
// Example: h264
func (s *TrackInfoAudioImpl) SetCodec(v FrameCodec) TrackInfoAudio {
	if s == nil {
		return nil
	}
	s.CodecValue = &v
	return s
}

// Content of the track (audio, video, or text).
func (s TrackInfoAudioImpl) Content() FrameContent {
	return s.ContentValue
}

// Content of the track (audio, video, or text).
func (s *TrackInfoAudioImpl) SetContent(v FrameContent) TrackInfoAudio {
	if s == nil {
		return nil
	}
	s.ContentValue = v
	return s
}

// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
// However, sometimes (when the connection is broken) video breakups are possible.
// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
// This situation is considered as a frame gap and is handled differently across different protocols.
// Format: ticks (ticks)
func (s TrackInfoAudioImpl) FrameDuration() *Ticks {
	return s.FrameDurationValue
}

// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
// However, sometimes (when the connection is broken) video breakups are possible.
// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
// This situation is considered as a frame gap and is handled differently across different protocols.
// Format: ticks (ticks)
func (s *TrackInfoAudioImpl) SetFrameDuration(v Ticks) TrackInfoAudio {
	if s == nil {
		return nil
	}
	s.FrameDurationValue = &v
	return s
}

// Language value of the track, if applicable.
// Example: eng
func (s TrackInfoAudioImpl) Language() *string {
	return s.LanguageValue
}

// Language value of the track, if applicable.
// Example: eng
func (s *TrackInfoAudioImpl) SetLanguage(v string) TrackInfoAudio {
	if s == nil {
		return nil
	}
	s.LanguageValue = &v
	return s
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s TrackInfoAudioImpl) Pid() *int {
	return s.PidValue
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s *TrackInfoAudioImpl) SetPid(v int) TrackInfoAudio {
	if s == nil {
		return nil
	}
	s.PidValue = &v
	return s
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// Example: 8000
func (s TrackInfoAudioImpl) SampleRate() *int {
	return s.SampleRateValue
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// Example: 8000
func (s *TrackInfoAudioImpl) SetSampleRate(v int) TrackInfoAudio {
	if s == nil {
		return nil
	}
	s.SampleRateValue = &v
	return s
}

// Human-readable localized title of the track.
// Example: Video1
func (s TrackInfoAudioImpl) Title() *string {
	return s.TitleValue
}

// Human-readable localized title of the track.
// Example: Video1
func (s *TrackInfoAudioImpl) SetTitle(v string) TrackInfoAudio {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// Track identifier assigned by Flussonic.
// Example: v1
func (s TrackInfoAudioImpl) TrackID() any {
	return s.TrackIDValue
}

// Track identifier assigned by Flussonic.
// Example: v1
func (s *TrackInfoAudioImpl) SetTrackID(v any) TrackInfoAudio {
	if s == nil {
		return nil
	}
	s.TrackIDValue = v
	return s
}

// NewTrackInfoAudioSpecific creates a new TrackInfoAudioSpecific instance
func NewTrackInfoAudioSpecific() TrackInfoAudioSpecific {
	return &TrackInfoAudioSpecificImpl{}
}

// The number of audio channels.
// Example: 2
func (s TrackInfoAudioSpecificImpl) Channels() *int {
	return s.ChannelsValue
}

// The number of audio channels.
// Example: 2
func (s *TrackInfoAudioSpecificImpl) SetChannels(v int) TrackInfoAudioSpecific {
	if s == nil {
		return nil
	}
	s.ChannelsValue = &v
	return s
}

// Language value of the track, if applicable.
// Example: eng
func (s TrackInfoAudioSpecificImpl) Language() *string {
	return s.LanguageValue
}

// Language value of the track, if applicable.
// Example: eng
func (s *TrackInfoAudioSpecificImpl) SetLanguage(v string) TrackInfoAudioSpecific {
	if s == nil {
		return nil
	}
	s.LanguageValue = &v
	return s
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// Example: 8000
func (s TrackInfoAudioSpecificImpl) SampleRate() *int {
	return s.SampleRateValue
}

// Sample rate, in hertz -
// the number of samples per second taken from a continuous signal to make a discrete or digital signal.
// Example: 8000
func (s *TrackInfoAudioSpecificImpl) SetSampleRate(v int) TrackInfoAudioSpecific {
	if s == nil {
		return nil
	}
	s.SampleRateValue = &v
	return s
}

// NewTrackInfoBase creates a new TrackInfoBase instance
func NewTrackInfoBase() TrackInfoBase {
	return &TrackInfoBaseImpl{}
}

// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
// The higher FPS is, the smoother the video playback is.
// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
func (s TrackInfoBaseImpl) AvgFPS() *float64 {
	return s.AvgFPSValue
}

// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
// The higher FPS is, the smoother the video playback is.
// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
func (s *TrackInfoBaseImpl) SetAvgFPS(v float64) TrackInfoBase {
	if s == nil {
		return nil
	}
	s.AvgFPSValue = &v
	return s
}

// Bandwidth necessary to transfer this track.
// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
// Format: speed (speed)
// Example: 2600
func (s TrackInfoBaseImpl) Bandwidth() *Speed {
	return s.BandwidthValue
}

// Bandwidth necessary to transfer this track.
// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
// Format: speed (speed)
// Example: 2600
func (s *TrackInfoBaseImpl) SetBandwidth(v Speed) TrackInfoBase {
	if s == nil {
		return nil
	}
	s.BandwidthValue = &v
	return s
}

// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
// However, sometimes (when the connection is broken) video breakups are possible.
// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
// This situation is considered as a frame gap and is handled differently across different protocols.
// Format: ticks (ticks)
func (s TrackInfoBaseImpl) FrameDuration() *Ticks {
	return s.FrameDurationValue
}

// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
// However, sometimes (when the connection is broken) video breakups are possible.
// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
// This situation is considered as a frame gap and is handled differently across different protocols.
// Format: ticks (ticks)
func (s *TrackInfoBaseImpl) SetFrameDuration(v Ticks) TrackInfoBase {
	if s == nil {
		return nil
	}
	s.FrameDurationValue = &v
	return s
}

// Track identifier assigned by Flussonic.
// Example: v1
func (s TrackInfoBaseImpl) TrackID() any {
	return s.TrackIDValue
}

// Track identifier assigned by Flussonic.
// Example: v1
func (s *TrackInfoBaseImpl) SetTrackID(v any) TrackInfoBase {
	if s == nil {
		return nil
	}
	s.TrackIDValue = v
	return s
}

// NewTrackInfoBaseConfigurable creates a new TrackInfoBaseConfigurable instance
func NewTrackInfoBaseConfigurable() TrackInfoBaseConfigurable {
	return &TrackInfoBaseConfigurableImpl{}
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s TrackInfoBaseConfigurableImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s *TrackInfoBaseConfigurableImpl) SetBitrate(v Speed) TrackInfoBaseConfigurable {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// Content of the track (audio, video, or text).
func (s TrackInfoBaseConfigurableImpl) Content() FrameContent {
	return s.ContentValue
}

// Content of the track (audio, video, or text).
func (s *TrackInfoBaseConfigurableImpl) SetContent(v FrameContent) TrackInfoBaseConfigurable {
	if s == nil {
		return nil
	}
	s.ContentValue = v
	return s
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s TrackInfoBaseConfigurableImpl) Pid() *int {
	return s.PidValue
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s *TrackInfoBaseConfigurableImpl) SetPid(v int) TrackInfoBaseConfigurable {
	if s == nil {
		return nil
	}
	s.PidValue = &v
	return s
}

// Human-readable localized title of the track.
// Example: Video1
func (s TrackInfoBaseConfigurableImpl) Title() *string {
	return s.TitleValue
}

// Human-readable localized title of the track.
// Example: Video1
func (s *TrackInfoBaseConfigurableImpl) SetTitle(v string) TrackInfoBaseConfigurable {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// NewTrackInfoMetadata creates a new TrackInfoMetadata instance
func NewTrackInfoMetadata() TrackInfoMetadata {
	return &TrackInfoMetadataImpl{}
}

// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
// The higher FPS is, the smoother the video playback is.
// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
func (s TrackInfoMetadataImpl) AvgFPS() *float64 {
	return s.AvgFPSValue
}

// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
// The higher FPS is, the smoother the video playback is.
// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
func (s *TrackInfoMetadataImpl) SetAvgFPS(v float64) TrackInfoMetadata {
	if s == nil {
		return nil
	}
	s.AvgFPSValue = &v
	return s
}

// Bandwidth necessary to transfer this track.
// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
// Format: speed (speed)
// Example: 2600
func (s TrackInfoMetadataImpl) Bandwidth() *Speed {
	return s.BandwidthValue
}

// Bandwidth necessary to transfer this track.
// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
// Format: speed (speed)
// Example: 2600
func (s *TrackInfoMetadataImpl) SetBandwidth(v Speed) TrackInfoMetadata {
	if s == nil {
		return nil
	}
	s.BandwidthValue = &v
	return s
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s TrackInfoMetadataImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s *TrackInfoMetadataImpl) SetBitrate(v Speed) TrackInfoMetadata {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// Codec of the track. Different codecs do **not** get the same track.
// Example: h264
func (s TrackInfoMetadataImpl) Codec() *FrameCodec {
	return s.CodecValue
}

// Codec of the track. Different codecs do **not** get the same track.
// Example: h264
func (s *TrackInfoMetadataImpl) SetCodec(v FrameCodec) TrackInfoMetadata {
	if s == nil {
		return nil
	}
	s.CodecValue = &v
	return s
}

// Content of the track (audio, video, or text).
func (s TrackInfoMetadataImpl) Content() FrameContent {
	return s.ContentValue
}

// Content of the track (audio, video, or text).
func (s *TrackInfoMetadataImpl) SetContent(v FrameContent) TrackInfoMetadata {
	if s == nil {
		return nil
	}
	s.ContentValue = v
	return s
}

// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
// However, sometimes (when the connection is broken) video breakups are possible.
// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
// This situation is considered as a frame gap and is handled differently across different protocols.
// Format: ticks (ticks)
func (s TrackInfoMetadataImpl) FrameDuration() *Ticks {
	return s.FrameDurationValue
}

// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
// However, sometimes (when the connection is broken) video breakups are possible.
// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
// This situation is considered as a frame gap and is handled differently across different protocols.
// Format: ticks (ticks)
func (s *TrackInfoMetadataImpl) SetFrameDuration(v Ticks) TrackInfoMetadata {
	if s == nil {
		return nil
	}
	s.FrameDurationValue = &v
	return s
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s TrackInfoMetadataImpl) Pid() *int {
	return s.PidValue
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s *TrackInfoMetadataImpl) SetPid(v int) TrackInfoMetadata {
	if s == nil {
		return nil
	}
	s.PidValue = &v
	return s
}

// Human-readable localized title of the track.
// Example: Video1
func (s TrackInfoMetadataImpl) Title() *string {
	return s.TitleValue
}

// Human-readable localized title of the track.
// Example: Video1
func (s *TrackInfoMetadataImpl) SetTitle(v string) TrackInfoMetadata {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// Track identifier assigned by Flussonic.
// Example: v1
func (s TrackInfoMetadataImpl) TrackID() any {
	return s.TrackIDValue
}

// Track identifier assigned by Flussonic.
// Example: v1
func (s *TrackInfoMetadataImpl) SetTrackID(v any) TrackInfoMetadata {
	if s == nil {
		return nil
	}
	s.TrackIDValue = v
	return s
}

// NewTrackInfoText creates a new TrackInfoText instance
func NewTrackInfoText() TrackInfoText {
	return &TrackInfoTextImpl{}
}

// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
// The higher FPS is, the smoother the video playback is.
// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
func (s TrackInfoTextImpl) AvgFPS() *float64 {
	return s.AvgFPSValue
}

// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
// The higher FPS is, the smoother the video playback is.
// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
func (s *TrackInfoTextImpl) SetAvgFPS(v float64) TrackInfoText {
	if s == nil {
		return nil
	}
	s.AvgFPSValue = &v
	return s
}

// Bandwidth necessary to transfer this track.
// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
// Format: speed (speed)
// Example: 2600
func (s TrackInfoTextImpl) Bandwidth() *Speed {
	return s.BandwidthValue
}

// Bandwidth necessary to transfer this track.
// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
// Format: speed (speed)
// Example: 2600
func (s *TrackInfoTextImpl) SetBandwidth(v Speed) TrackInfoText {
	if s == nil {
		return nil
	}
	s.BandwidthValue = &v
	return s
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s TrackInfoTextImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s *TrackInfoTextImpl) SetBitrate(v Speed) TrackInfoText {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// Codec of the track. Different codecs do **not** get the same track.
// Example: h264
func (s TrackInfoTextImpl) Codec() *FrameCodec {
	return s.CodecValue
}

// Codec of the track. Different codecs do **not** get the same track.
// Example: h264
func (s *TrackInfoTextImpl) SetCodec(v FrameCodec) TrackInfoText {
	if s == nil {
		return nil
	}
	s.CodecValue = &v
	return s
}

// Content of the track (audio, video, or text).
func (s TrackInfoTextImpl) Content() FrameContent {
	return s.ContentValue
}

// Content of the track (audio, video, or text).
func (s *TrackInfoTextImpl) SetContent(v FrameContent) TrackInfoText {
	if s == nil {
		return nil
	}
	s.ContentValue = v
	return s
}

// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
// However, sometimes (when the connection is broken) video breakups are possible.
// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
// This situation is considered as a frame gap and is handled differently across different protocols.
// Format: ticks (ticks)
func (s TrackInfoTextImpl) FrameDuration() *Ticks {
	return s.FrameDurationValue
}

// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
// However, sometimes (when the connection is broken) video breakups are possible.
// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
// This situation is considered as a frame gap and is handled differently across different protocols.
// Format: ticks (ticks)
func (s *TrackInfoTextImpl) SetFrameDuration(v Ticks) TrackInfoText {
	if s == nil {
		return nil
	}
	s.FrameDurationValue = &v
	return s
}

// Language value of the track, if applicable.
// Example: eng
func (s TrackInfoTextImpl) Language() *string {
	return s.LanguageValue
}

// Language value of the track, if applicable.
// Example: eng
func (s *TrackInfoTextImpl) SetLanguage(v string) TrackInfoText {
	if s == nil {
		return nil
	}
	s.LanguageValue = &v
	return s
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s TrackInfoTextImpl) Pid() *int {
	return s.PidValue
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s *TrackInfoTextImpl) SetPid(v int) TrackInfoText {
	if s == nil {
		return nil
	}
	s.PidValue = &v
	return s
}

// Human-readable localized title of the track.
// Example: Video1
func (s TrackInfoTextImpl) Title() *string {
	return s.TitleValue
}

// Human-readable localized title of the track.
// Example: Video1
func (s *TrackInfoTextImpl) SetTitle(v string) TrackInfoText {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// Track identifier assigned by Flussonic.
// Example: v1
func (s TrackInfoTextImpl) TrackID() any {
	return s.TrackIDValue
}

// Track identifier assigned by Flussonic.
// Example: v1
func (s *TrackInfoTextImpl) SetTrackID(v any) TrackInfoText {
	if s == nil {
		return nil
	}
	s.TrackIDValue = v
	return s
}

// NewTrackInfoTextSpecific creates a new TrackInfoTextSpecific instance
func NewTrackInfoTextSpecific() TrackInfoTextSpecific {
	return &TrackInfoTextSpecificImpl{}
}

// Language value of the track, if applicable.
// Example: eng
func (s TrackInfoTextSpecificImpl) Language() *string {
	return s.LanguageValue
}

// Language value of the track, if applicable.
// Example: eng
func (s *TrackInfoTextSpecificImpl) SetLanguage(v string) TrackInfoTextSpecific {
	if s == nil {
		return nil
	}
	s.LanguageValue = &v
	return s
}

// NewTrackInfoVideo creates a new TrackInfoVideo instance
func NewTrackInfoVideo() TrackInfoVideo {
	return &TrackInfoVideoImpl{}
}

// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
// The higher FPS is, the smoother the video playback is.
// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
func (s TrackInfoVideoImpl) AvgFPS() *float64 {
	return s.AvgFPSValue
}

// Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).
// The higher FPS is, the smoother the video playback is.
// Usually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).
func (s *TrackInfoVideoImpl) SetAvgFPS(v float64) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.AvgFPSValue = &v
	return s
}

// Average GOP size (expressed in number of frames) of the last 1000-2000 frames.
// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
// If this value is floating, this means that your transcoder is working in flexible GOP size mode and some players may have problems.
// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
// Example: 25
func (s TrackInfoVideoImpl) AvgGop() *int {
	return s.AvgGopValue
}

// Average GOP size (expressed in number of frames) of the last 1000-2000 frames.
// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
// If this value is floating, this means that your transcoder is working in flexible GOP size mode and some players may have problems.
// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
// Example: 25
func (s *TrackInfoVideoImpl) SetAvgGop(v int) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.AvgGopValue = &v
	return s
}

// Bandwidth necessary to transfer this track.
// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
// Format: speed (speed)
// Example: 2600
func (s TrackInfoVideoImpl) Bandwidth() *Speed {
	return s.BandwidthValue
}

// Bandwidth necessary to transfer this track.
// This is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead
// Format: speed (speed)
// Example: 2600
func (s *TrackInfoVideoImpl) SetBandwidth(v Speed) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.BandwidthValue = &v
	return s
}

// Average number of B-frames in a GOP. B-frames contain links to keyframes and P-frames before and after themselves.
// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
// Example: 3
func (s TrackInfoVideoImpl) Bframes() *int {
	return s.BframesValue
}

// Average number of B-frames in a GOP. B-frames contain links to keyframes and P-frames before and after themselves.
// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
// Example: 3
func (s *TrackInfoVideoImpl) SetBframes(v int) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.BframesValue = &v
	return s
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s TrackInfoVideoImpl) Bitrate() *Speed {
	return s.BitrateValue
}

// Bitrate of the track in kbit/s.
// When using sdtv/hdtv/uhdtv transcoder target, for video tracks
// this field sets the desired transport bandwidth instead of raw video bitrate.
// Format: speed (speed)
// Example: 2543
func (s *TrackInfoVideoImpl) SetBitrate(v Speed) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.BitrateValue = &v
	return s
}

// Parameters of closed captions.
func (s TrackInfoVideoImpl) ClosedCaptions() []ClosedCaptions {
	if s.ClosedCaptionsValue == nil {
		return nil
	}
	result := make([]ClosedCaptions, len(s.ClosedCaptionsValue))
	for i, item := range s.ClosedCaptionsValue {
		result[i] = item
	}
	return result
}

// Parameters of closed captions.
func (s *TrackInfoVideoImpl) SetClosedCaptions(v []ClosedCaptions) TrackInfoVideo {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*ClosedCaptionsImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*ClosedCaptionsImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.ClosedCaptionsValue = impl
	}
	return s
}

// Codec of the track. Different codecs do **not** get the same track.
// Example: h264
func (s TrackInfoVideoImpl) Codec() *FrameCodec {
	return s.CodecValue
}

// Codec of the track. Different codecs do **not** get the same track.
// Example: h264
func (s *TrackInfoVideoImpl) SetCodec(v FrameCodec) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.CodecValue = &v
	return s
}

// Content of the track (audio, video, or text).
func (s TrackInfoVideoImpl) Content() FrameContent {
	return s.ContentValue
}

// Content of the track (audio, video, or text).
func (s *TrackInfoVideoImpl) SetContent(v FrameContent) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.ContentValue = v
	return s
}

// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
// Higher frame rates capture more images per second, which makes for smoother video.
// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
func (s TrackInfoVideoImpl) FPS() *float64 {
	return s.FPSValue
}

// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
// Higher frame rates capture more images per second, which makes for smoother video.
// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
func (s *TrackInfoVideoImpl) SetFPS(v float64) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.FPSValue = &v
	return s
}

// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
// However, sometimes (when the connection is broken) video breakups are possible.
// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
// This situation is considered as a frame gap and is handled differently across different protocols.
// Format: ticks (ticks)
func (s TrackInfoVideoImpl) FrameDuration() *Ticks {
	return s.FrameDurationValue
}

// For video track, it is the time between the beginning of a frame and the beginning of the next frame.
// This parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.
// However, sometimes (when the connection is broken) video breakups are possible.
// As result, the delta between two consequent frame timestamps will not be equal to the frame duration.
// This situation is considered as a frame gap and is handled differently across different protocols.
// Format: ticks (ticks)
func (s *TrackInfoVideoImpl) SetFrameDuration(v Ticks) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.FrameDurationValue = &v
	return s
}

// The number of frames in a group of pictures (GOP).
// The encoder will create all GOPs of an exactly identical size - as specified in this option.
// A bigger GOP can be good for video compression but it can result in big zap-time (the duration of time between changing a channel and displaying a new channel.)
func (s TrackInfoVideoImpl) GopSize() *int {
	return s.GopSizeValue
}

// The number of frames in a group of pictures (GOP).
// The encoder will create all GOPs of an exactly identical size - as specified in this option.
// A bigger GOP can be good for video compression but it can result in big zap-time (the duration of time between changing a channel and displaying a new channel.)
func (s *TrackInfoVideoImpl) SetGopSize(v int) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.GopSizeValue = &v
	return s
}

// The picture height in pixels on the display where it will be played by a player.
// If you need to insert a web-player into a web page, use this value for choosing the player size.
// Format: pixels (pixels)
func (s TrackInfoVideoImpl) Height() *Pixels {
	return s.HeightValue
}

// The picture height in pixels on the display where it will be played by a player.
// If you need to insert a web-player into a web page, use this value for choosing the player size.
// Format: pixels (pixels)
func (s *TrackInfoVideoImpl) SetHeight(v Pixels) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.HeightValue = &v
	return s
}

// Indicates if progressive scanning method is used for all frames of the track
func (s TrackInfoVideoImpl) IsProgressive() *bool {
	return s.IsProgressiveValue
}

// Indicates if progressive scanning method is used for all frames of the track
func (s *TrackInfoVideoImpl) SetIsProgressive(v bool) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.IsProgressiveValue = &v
	return s
}

// Last GOP size (expressed in number of frames).
// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
// If this value is floating, this means that your transcoder is working in a flexible GOP size mode and some players may have problems.
// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
// Example: 28
func (s TrackInfoVideoImpl) LastGop() *int {
	return s.LastGopValue
}

// Last GOP size (expressed in number of frames).
// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
// If this value is floating, this means that your transcoder is working in a flexible GOP size mode and some players may have problems.
// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
// Example: 28
func (s *TrackInfoVideoImpl) SetLastGop(v int) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.LastGopValue = &v
	return s
}

// The size of the length field for H264 bitstream without start codes.
func (s TrackInfoVideoImpl) LengthSize() *int {
	return s.LengthSizeValue
}

// The size of the length field for H264 bitstream without start codes.
func (s *TrackInfoVideoImpl) SetLengthSize(v int) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.LengthSizeValue = &v
	return s
}

// A set of constraints that indicate a degree of required decoder performance.
// This parameter is used for compatibility with old devices.
func (s TrackInfoVideoImpl) Level() *string {
	return s.LevelValue
}

// A set of constraints that indicate a degree of required decoder performance.
// This parameter is used for compatibility with old devices.
func (s *TrackInfoVideoImpl) SetLevel(v string) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.LevelValue = &v
	return s
}

// The number of I-frames to be used for encoding.
func (s TrackInfoVideoImpl) NumRefsFrames() *int {
	return s.NumRefsFramesValue
}

// The number of I-frames to be used for encoding.
func (s *TrackInfoVideoImpl) SetNumRefsFrames(v int) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.NumRefsFramesValue = &v
	return s
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s TrackInfoVideoImpl) Pid() *int {
	return s.PidValue
}

// This parameter sets PIDs values for outgoing MPEG-TS streams.
// PID identifies separate data stream inside the multiplexed MPEG-TS stream.
// It is possible to set PID values for PMT, SDT, video, and audio tracks.
// Tracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.
// It is possible to set the base index for the tracks of a certain type using the 0 (zero) index.
// For example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.
// Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.
func (s *TrackInfoVideoImpl) SetPid(v int) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.PidValue = &v
	return s
}

// The color model of the video.
func (s TrackInfoVideoImpl) PixFmt() *FrameVideoPixFmt {
	return s.PixFmtValue
}

// The color model of the video.
func (s *TrackInfoVideoImpl) SetPixFmt(v FrameVideoPixFmt) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.PixFmtValue = &v
	return s
}

// The picture width in pixels of the original video before transcoding.
// Format: pixels (pixels)
func (s TrackInfoVideoImpl) PixelHeight() *Pixels {
	return s.PixelHeightValue
}

// The picture width in pixels of the original video before transcoding.
// Format: pixels (pixels)
func (s *TrackInfoVideoImpl) SetPixelHeight(v Pixels) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.PixelHeightValue = &v
	return s
}

// The picture width in pixels of the original video before transcoding.
// Format: pixels (pixels)
func (s TrackInfoVideoImpl) PixelWidth() *Pixels {
	return s.PixelWidthValue
}

// The picture width in pixels of the original video before transcoding.
// Format: pixels (pixels)
func (s *TrackInfoVideoImpl) SetPixelWidth(v Pixels) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.PixelWidthValue = &v
	return s
}

// A specific codec-dependent profile of the output video.
// The profile allows to assume if the track can be played on a particular device.
func (s TrackInfoVideoImpl) Profile() *string {
	return s.ProfileValue
}

// A specific codec-dependent profile of the output video.
// The profile allows to assume if the track can be played on a particular device.
func (s *TrackInfoVideoImpl) SetProfile(v string) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.ProfileValue = &v
	return s
}

// The second number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
// SAR is used for creating non-anamorphic video from anamorphic video.
func (s TrackInfoVideoImpl) SarHeight() *int {
	return s.SarHeightValue
}

// The second number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
// SAR is used for creating non-anamorphic video from anamorphic video.
func (s *TrackInfoVideoImpl) SetSarHeight(v int) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.SarHeightValue = &v
	return s
}

// The first number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
// SAR is used for creating non-anamorphic video from anamorphic video.
func (s TrackInfoVideoImpl) SarWidth() *int {
	return s.SarWidthValue
}

// The first number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
// SAR is used for creating non-anamorphic video from anamorphic video.
func (s *TrackInfoVideoImpl) SetSarWidth(v int) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.SarWidthValue = &v
	return s
}

// Human-readable localized title of the track.
// Example: Video1
func (s TrackInfoVideoImpl) Title() *string {
	return s.TitleValue
}

// Human-readable localized title of the track.
// Example: Video1
func (s *TrackInfoVideoImpl) SetTitle(v string) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// Track identifier assigned by Flussonic.
// Example: v1
func (s TrackInfoVideoImpl) TrackID() any {
	return s.TrackIDValue
}

// Track identifier assigned by Flussonic.
// Example: v1
func (s *TrackInfoVideoImpl) SetTrackID(v any) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.TrackIDValue = v
	return s
}

// The picture width in pixels on the display where it will be played by a player.
// If you need to insert a web-player into a web page, use this value for choosing the player size.
// Format: pixels (pixels)
func (s TrackInfoVideoImpl) Width() *Pixels {
	return s.WidthValue
}

// The picture width in pixels on the display where it will be played by a player.
// If you need to insert a web-player into a web page, use this value for choosing the player size.
// Format: pixels (pixels)
func (s *TrackInfoVideoImpl) SetWidth(v Pixels) TrackInfoVideo {
	if s == nil {
		return nil
	}
	s.WidthValue = &v
	return s
}

// NewTrackInfoVideoConfigurable creates a new TrackInfoVideoConfigurable instance
func NewTrackInfoVideoConfigurable() TrackInfoVideoConfigurable {
	return &TrackInfoVideoConfigurableImpl{}
}

// Average number of B-frames in a GOP. B-frames contain links to keyframes and P-frames before and after themselves.
// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
// Example: 3
func (s TrackInfoVideoConfigurableImpl) Bframes() *int {
	return s.BframesValue
}

// Average number of B-frames in a GOP. B-frames contain links to keyframes and P-frames before and after themselves.
// B-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.
// This value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.
// Example: 3
func (s *TrackInfoVideoConfigurableImpl) SetBframes(v int) TrackInfoVideoConfigurable {
	if s == nil {
		return nil
	}
	s.BframesValue = &v
	return s
}

// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
// Higher frame rates capture more images per second, which makes for smoother video.
// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
func (s TrackInfoVideoConfigurableImpl) FPS() *float64 {
	return s.FPSValue
}

// Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.
// Higher frame rates capture more images per second, which makes for smoother video.
// The standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.
// The standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps
// (a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)
// If interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,
// but the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).
func (s *TrackInfoVideoConfigurableImpl) SetFPS(v float64) TrackInfoVideoConfigurable {
	if s == nil {
		return nil
	}
	s.FPSValue = &v
	return s
}

// The number of frames in a group of pictures (GOP).
// The encoder will create all GOPs of an exactly identical size - as specified in this option.
// A bigger GOP can be good for video compression but it can result in big zap-time (the duration of time between changing a channel and displaying a new channel.)
func (s TrackInfoVideoConfigurableImpl) GopSize() *int {
	return s.GopSizeValue
}

// The number of frames in a group of pictures (GOP).
// The encoder will create all GOPs of an exactly identical size - as specified in this option.
// A bigger GOP can be good for video compression but it can result in big zap-time (the duration of time between changing a channel and displaying a new channel.)
func (s *TrackInfoVideoConfigurableImpl) SetGopSize(v int) TrackInfoVideoConfigurable {
	if s == nil {
		return nil
	}
	s.GopSizeValue = &v
	return s
}

// The picture height in pixels on the display where it will be played by a player.
// If you need to insert a web-player into a web page, use this value for choosing the player size.
// Format: pixels (pixels)
func (s TrackInfoVideoConfigurableImpl) Height() *Pixels {
	return s.HeightValue
}

// The picture height in pixels on the display where it will be played by a player.
// If you need to insert a web-player into a web page, use this value for choosing the player size.
// Format: pixels (pixels)
func (s *TrackInfoVideoConfigurableImpl) SetHeight(v Pixels) TrackInfoVideoConfigurable {
	if s == nil {
		return nil
	}
	s.HeightValue = &v
	return s
}

// A set of constraints that indicate a degree of required decoder performance.
// This parameter is used for compatibility with old devices.
func (s TrackInfoVideoConfigurableImpl) Level() *string {
	return s.LevelValue
}

// A set of constraints that indicate a degree of required decoder performance.
// This parameter is used for compatibility with old devices.
func (s *TrackInfoVideoConfigurableImpl) SetLevel(v string) TrackInfoVideoConfigurable {
	if s == nil {
		return nil
	}
	s.LevelValue = &v
	return s
}

// The number of I-frames to be used for encoding.
func (s TrackInfoVideoConfigurableImpl) NumRefsFrames() *int {
	return s.NumRefsFramesValue
}

// The number of I-frames to be used for encoding.
func (s *TrackInfoVideoConfigurableImpl) SetNumRefsFrames(v int) TrackInfoVideoConfigurable {
	if s == nil {
		return nil
	}
	s.NumRefsFramesValue = &v
	return s
}

// The color model of the video.
func (s TrackInfoVideoConfigurableImpl) PixFmt() *FrameVideoPixFmt {
	return s.PixFmtValue
}

// The color model of the video.
func (s *TrackInfoVideoConfigurableImpl) SetPixFmt(v FrameVideoPixFmt) TrackInfoVideoConfigurable {
	if s == nil {
		return nil
	}
	s.PixFmtValue = &v
	return s
}

// The picture width in pixels of the original video before transcoding.
// Format: pixels (pixels)
func (s TrackInfoVideoConfigurableImpl) PixelHeight() *Pixels {
	return s.PixelHeightValue
}

// The picture width in pixels of the original video before transcoding.
// Format: pixels (pixels)
func (s *TrackInfoVideoConfigurableImpl) SetPixelHeight(v Pixels) TrackInfoVideoConfigurable {
	if s == nil {
		return nil
	}
	s.PixelHeightValue = &v
	return s
}

// The picture width in pixels of the original video before transcoding.
// Format: pixels (pixels)
func (s TrackInfoVideoConfigurableImpl) PixelWidth() *Pixels {
	return s.PixelWidthValue
}

// The picture width in pixels of the original video before transcoding.
// Format: pixels (pixels)
func (s *TrackInfoVideoConfigurableImpl) SetPixelWidth(v Pixels) TrackInfoVideoConfigurable {
	if s == nil {
		return nil
	}
	s.PixelWidthValue = &v
	return s
}

// A specific codec-dependent profile of the output video.
// The profile allows to assume if the track can be played on a particular device.
func (s TrackInfoVideoConfigurableImpl) Profile() *string {
	return s.ProfileValue
}

// A specific codec-dependent profile of the output video.
// The profile allows to assume if the track can be played on a particular device.
func (s *TrackInfoVideoConfigurableImpl) SetProfile(v string) TrackInfoVideoConfigurable {
	if s == nil {
		return nil
	}
	s.ProfileValue = &v
	return s
}

// The second number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
// SAR is used for creating non-anamorphic video from anamorphic video.
func (s TrackInfoVideoConfigurableImpl) SarHeight() *int {
	return s.SarHeightValue
}

// The second number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
// SAR is used for creating non-anamorphic video from anamorphic video.
func (s *TrackInfoVideoConfigurableImpl) SetSarHeight(v int) TrackInfoVideoConfigurable {
	if s == nil {
		return nil
	}
	s.SarHeightValue = &v
	return s
}

// The first number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
// SAR is used for creating non-anamorphic video from anamorphic video.
func (s TrackInfoVideoConfigurableImpl) SarWidth() *int {
	return s.SarWidthValue
}

// The first number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.
// SAR is used for creating non-anamorphic video from anamorphic video.
func (s *TrackInfoVideoConfigurableImpl) SetSarWidth(v int) TrackInfoVideoConfigurable {
	if s == nil {
		return nil
	}
	s.SarWidthValue = &v
	return s
}

// The picture width in pixels on the display where it will be played by a player.
// If you need to insert a web-player into a web page, use this value for choosing the player size.
// Format: pixels (pixels)
func (s TrackInfoVideoConfigurableImpl) Width() *Pixels {
	return s.WidthValue
}

// The picture width in pixels on the display where it will be played by a player.
// If you need to insert a web-player into a web page, use this value for choosing the player size.
// Format: pixels (pixels)
func (s *TrackInfoVideoConfigurableImpl) SetWidth(v Pixels) TrackInfoVideoConfigurable {
	if s == nil {
		return nil
	}
	s.WidthValue = &v
	return s
}

// NewTrackInfoVideoSpecific creates a new TrackInfoVideoSpecific instance
func NewTrackInfoVideoSpecific() TrackInfoVideoSpecific {
	return &TrackInfoVideoSpecificImpl{}
}

// Average GOP size (expressed in number of frames) of the last 1000-2000 frames.
// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
// If this value is floating, this means that your transcoder is working in flexible GOP size mode and some players may have problems.
// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
// Example: 25
func (s TrackInfoVideoSpecificImpl) AvgGop() *int {
	return s.AvgGopValue
}

// Average GOP size (expressed in number of frames) of the last 1000-2000 frames.
// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
// If this value is floating, this means that your transcoder is working in flexible GOP size mode and some players may have problems.
// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
// Example: 25
func (s *TrackInfoVideoSpecificImpl) SetAvgGop(v int) TrackInfoVideoSpecific {
	if s == nil {
		return nil
	}
	s.AvgGopValue = &v
	return s
}

// Parameters of closed captions.
func (s TrackInfoVideoSpecificImpl) ClosedCaptions() []ClosedCaptions {
	if s.ClosedCaptionsValue == nil {
		return nil
	}
	result := make([]ClosedCaptions, len(s.ClosedCaptionsValue))
	for i, item := range s.ClosedCaptionsValue {
		result[i] = item
	}
	return result
}

// Parameters of closed captions.
func (s *TrackInfoVideoSpecificImpl) SetClosedCaptions(v []ClosedCaptions) TrackInfoVideoSpecific {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*ClosedCaptionsImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*ClosedCaptionsImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.ClosedCaptionsValue = impl
	}
	return s
}

// Indicates if progressive scanning method is used for all frames of the track
func (s TrackInfoVideoSpecificImpl) IsProgressive() *bool {
	return s.IsProgressiveValue
}

// Indicates if progressive scanning method is used for all frames of the track
func (s *TrackInfoVideoSpecificImpl) SetIsProgressive(v bool) TrackInfoVideoSpecific {
	if s == nil {
		return nil
	}
	s.IsProgressiveValue = &v
	return s
}

// Last GOP size (expressed in number of frames).
// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
// If this value is floating, this means that your transcoder is working in a flexible GOP size mode and some players may have problems.
// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
// Example: 28
func (s TrackInfoVideoSpecificImpl) LastGop() *int {
	return s.LastGopValue
}

// Last GOP size (expressed in number of frames).
// This parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.
// If this value is floating, this means that your transcoder is working in a flexible GOP size mode and some players may have problems.
// This is not acceptable by most ABR usecases and it will not pass DVB validation protocol.
// Example: 28
func (s *TrackInfoVideoSpecificImpl) SetLastGop(v int) TrackInfoVideoSpecific {
	if s == nil {
		return nil
	}
	s.LastGopValue = &v
	return s
}

// The size of the length field for H264 bitstream without start codes.
func (s TrackInfoVideoSpecificImpl) LengthSize() *int {
	return s.LengthSizeValue
}

// The size of the length field for H264 bitstream without start codes.
func (s *TrackInfoVideoSpecificImpl) SetLengthSize(v int) TrackInfoVideoSpecific {
	if s == nil {
		return nil
	}
	s.LengthSizeValue = &v
	return s
}

// NewUiSettingsConfig creates a new UiSettingsConfig instance
func NewUiSettingsConfig() UiSettingsConfig {
	return &UiSettingsConfigImpl{}
}

// The product brand.
// Examples: Central, Cloud, Streamer
func (s UiSettingsConfigImpl) Brand() *string {
	return s.BrandValue
}

// The product brand.
// Examples: Central, Cloud, Streamer
func (s *UiSettingsConfigImpl) SetBrand(v string) UiSettingsConfig {
	if s == nil {
		return nil
	}
	s.BrandValue = &v
	return s
}

// The interface colors.
func (s UiSettingsConfigImpl) Colors() UiSettingsConfigColors {
	return s.ColorsValue
}

// The interface colors.
func (s *UiSettingsConfigImpl) SetColors(v UiSettingsConfigColors) UiSettingsConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*UiSettingsConfigColorsImpl); ok {
		s.ColorsValue = impl
	}
	return s
}

// Contact information for customers to reach the company through various means.
func (s UiSettingsConfigImpl) CompanyInfo() UiSettingsConfigCompanyInfo {
	return s.CompanyInfoValue
}

// Contact information for customers to reach the company through various means.
func (s *UiSettingsConfigImpl) SetCompanyInfo(v UiSettingsConfigCompanyInfo) UiSettingsConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*UiSettingsConfigCompanyInfoImpl); ok {
		s.CompanyInfoValue = impl
	}
	return s
}

// The default locale
func (s UiSettingsConfigImpl) DefaultLocale() *ISO6391 {
	return s.DefaultLocaleValue
}

// The default locale
func (s *UiSettingsConfigImpl) SetDefaultLocale(v ISO6391) UiSettingsConfig {
	if s == nil {
		return nil
	}
	s.DefaultLocaleValue = &v
	return s
}

// The favicons of different sizes for different OSes and browsers.
func (s UiSettingsConfigImpl) Favicons() UiSettingsConfigFavicons {
	return s.FaviconsValue
}

// The favicons of different sizes for different OSes and browsers.
func (s *UiSettingsConfigImpl) SetFavicons(v UiSettingsConfigFavicons) UiSettingsConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*UiSettingsConfigFaviconsImpl); ok {
		s.FaviconsValue = impl
	}
	return s
}

// The fonts in the UI.
func (s UiSettingsConfigImpl) Fonts() UiSettingsConfigFonts {
	return s.FontsValue
}

// The fonts in the UI.
func (s *UiSettingsConfigImpl) SetFonts(v UiSettingsConfigFonts) UiSettingsConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*UiSettingsConfigFontsImpl); ok {
		s.FontsValue = impl
	}
	return s
}

// The list of possible locales
// Example: [en ru]
func (s UiSettingsConfigImpl) Locales() []ISO6391 {
	return s.LocalesValue
}

// The list of possible locales
// Example: [en ru]
func (s *UiSettingsConfigImpl) SetLocales(v []ISO6391) UiSettingsConfig {
	if s == nil {
		return nil
	}
	s.LocalesValue = v
	return s
}

// Map settings for displaying streams with specified coordinates.
func (s UiSettingsConfigImpl) Map() Map {
	return s.MapValue
}

// Map settings for displaying streams with specified coordinates.
func (s *UiSettingsConfigImpl) SetMap(v Map) UiSettingsConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*MapImpl); ok {
		s.MapValue = impl
	}
	return s
}

// The product type.
// Examples: central, cloud, streamer
func (s UiSettingsConfigImpl) Product() *string {
	return s.ProductValue
}

// The product type.
// Examples: central, cloud, streamer
func (s *UiSettingsConfigImpl) SetProduct(v string) UiSettingsConfig {
	if s == nil {
		return nil
	}
	s.ProductValue = &v
	return s
}

// The product title.
// Examples: Billing, Central, Cloud, Streamer
func (s UiSettingsConfigImpl) Title() *string {
	return s.TitleValue
}

// The product title.
// Examples: Billing, Central, Cloud, Streamer
func (s *UiSettingsConfigImpl) SetTitle(v string) UiSettingsConfig {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// NewUiSettingsConfigColors creates a new UiSettingsConfigColors instance
func NewUiSettingsConfigColors() UiSettingsConfigColors {
	return &UiSettingsConfigColorsImpl{}
}

// The background color.
// Example: #fff
func (s UiSettingsConfigColorsImpl) Background() *string {
	return s.BackgroundValue
}

// The background color.
// Example: #fff
func (s *UiSettingsConfigColorsImpl) SetBackground(v string) UiSettingsConfigColors {
	if s == nil {
		return nil
	}
	s.BackgroundValue = &v
	return s
}

// Primary color for interface elements like selection in the main menu, info icons, buttons, etc.
// Examples: #002DAB, #002DAB, #4549F2, #4549F2
func (s UiSettingsConfigColorsImpl) Primary() *string {
	return s.PrimaryValue
}

// Primary color for interface elements like selection in the main menu, info icons, buttons, etc.
// Examples: #002DAB, #002DAB, #4549F2, #4549F2
func (s *UiSettingsConfigColorsImpl) SetPrimary(v string) UiSettingsConfigColors {
	if s == nil {
		return nil
	}
	s.PrimaryValue = &v
	return s
}

// Secondary color for obsolete interface elements like active tab.
// Examples: #E91E63, #E91E63, #FF0D70, #FF0D70
func (s UiSettingsConfigColorsImpl) Secondary() *string {
	return s.SecondaryValue
}

// Secondary color for obsolete interface elements like active tab.
// Examples: #E91E63, #E91E63, #FF0D70, #FF0D70
func (s *UiSettingsConfigColorsImpl) SetSecondary(v string) UiSettingsConfigColors {
	if s == nil {
		return nil
	}
	s.SecondaryValue = &v
	return s
}

// NewUiSettingsConfigCompanyInfo creates a new UiSettingsConfigCompanyInfo instance
func NewUiSettingsConfigCompanyInfo() UiSettingsConfigCompanyInfo {
	return &UiSettingsConfigCompanyInfoImpl{}
}

// Details enabling customers to locate the company's physical location.
func (s UiSettingsConfigCompanyInfoImpl) Address() *string {
	return s.AddressValue
}

// Details enabling customers to locate the company's physical location.
func (s *UiSettingsConfigCompanyInfoImpl) SetAddress(v string) UiSettingsConfigCompanyInfo {
	if s == nil {
		return nil
	}
	s.AddressValue = &v
	return s
}

// Notify your users if you are not ready to answer phone calls and emails 24/7.
func (s UiSettingsConfigCompanyInfoImpl) BusinessHours() *string {
	return s.BusinessHoursValue
}

// Notify your users if you are not ready to answer phone calls and emails 24/7.
func (s *UiSettingsConfigCompanyInfoImpl) SetBusinessHours(v string) UiSettingsConfigCompanyInfo {
	if s == nil {
		return nil
	}
	s.BusinessHoursValue = &v
	return s
}

// Telephone contact information for reaching out to the company.
func (s UiSettingsConfigCompanyInfoImpl) Phone() *string {
	return s.PhoneValue
}

// Telephone contact information for reaching out to the company.
func (s *UiSettingsConfigCompanyInfoImpl) SetPhone(v string) UiSettingsConfigCompanyInfo {
	if s == nil {
		return nil
	}
	s.PhoneValue = &v
	return s
}

// NewUiSettingsConfigFavicons creates a new UiSettingsConfigFavicons instance
func NewUiSettingsConfigFavicons() UiSettingsConfigFavicons {
	return &UiSettingsConfigFaviconsImpl{}
}

// 128x128 pixels favicon.
// Format: byte (byte)
// Example: icons/favicon-128.png
func (s UiSettingsConfigFaviconsImpl) T128() *Byte {
	return s.T128Value
}

// 128x128 pixels favicon.
// Format: byte (byte)
// Example: icons/favicon-128.png
func (s *UiSettingsConfigFaviconsImpl) SetT128(v Byte) UiSettingsConfigFavicons {
	if s == nil {
		return nil
	}
	s.T128Value = &v
	return s
}

// 16x16 pixels favicon.
// Format: byte (byte)
// Example: icons/favicon-16.png
func (s UiSettingsConfigFaviconsImpl) T16() *Byte {
	return s.T16Value
}

// 16x16 pixels favicon.
// Format: byte (byte)
// Example: icons/favicon-16.png
func (s *UiSettingsConfigFaviconsImpl) SetT16(v Byte) UiSettingsConfigFavicons {
	if s == nil {
		return nil
	}
	s.T16Value = &v
	return s
}

// 32x32 pixels favicon.
// Format: byte (byte)
// Example: icons/favicon-32.png
func (s UiSettingsConfigFaviconsImpl) T32() *Byte {
	return s.T32Value
}

// 32x32 pixels favicon.
// Format: byte (byte)
// Example: icons/favicon-32.png
func (s *UiSettingsConfigFaviconsImpl) SetT32(v Byte) UiSettingsConfigFavicons {
	if s == nil {
		return nil
	}
	s.T32Value = &v
	return s
}

// 48x48 pixels favicon.
// Format: byte (byte)
// Example: icons/favicon-48.png
func (s UiSettingsConfigFaviconsImpl) T48() *Byte {
	return s.T48Value
}

// 48x48 pixels favicon.
// Format: byte (byte)
// Example: icons/favicon-48.png
func (s *UiSettingsConfigFaviconsImpl) SetT48(v Byte) UiSettingsConfigFavicons {
	if s == nil {
		return nil
	}
	s.T48Value = &v
	return s
}

// 64x64 pixels favicon.
// Format: byte (byte)
// Example: icons/favicon-64.png
func (s UiSettingsConfigFaviconsImpl) T64() *Byte {
	return s.T64Value
}

// 64x64 pixels favicon.
// Format: byte (byte)
// Example: icons/favicon-64.png
func (s *UiSettingsConfigFaviconsImpl) SetT64(v Byte) UiSettingsConfigFavicons {
	if s == nil {
		return nil
	}
	s.T64Value = &v
	return s
}

// NewUiSettingsConfigFonts creates a new UiSettingsConfigFonts instance
func NewUiSettingsConfigFonts() UiSettingsConfigFonts {
	return &UiSettingsConfigFontsImpl{}
}

// The light font style.
// Format: byte (byte)
// Example: fira-sans-300.woff2
func (s UiSettingsConfigFontsImpl) Light() *Byte {
	return s.LightValue
}

// The light font style.
// Format: byte (byte)
// Example: fira-sans-300.woff2
func (s *UiSettingsConfigFontsImpl) SetLight(v Byte) UiSettingsConfigFonts {
	if s == nil {
		return nil
	}
	s.LightValue = &v
	return s
}

// The medium font style.
// Format: byte (byte)
// Example: fira-sans-500.woff2
func (s UiSettingsConfigFontsImpl) Medium() *Byte {
	return s.MediumValue
}

// The medium font style.
// Format: byte (byte)
// Example: fira-sans-500.woff2
func (s *UiSettingsConfigFontsImpl) SetMedium(v Byte) UiSettingsConfigFonts {
	if s == nil {
		return nil
	}
	s.MediumValue = &v
	return s
}

// The regular font style.
// Format: byte (byte)
// Example: fira-sans-400.woff2
func (s UiSettingsConfigFontsImpl) Regular() *Byte {
	return s.RegularValue
}

// The regular font style.
// Format: byte (byte)
// Example: fira-sans-400.woff2
func (s *UiSettingsConfigFontsImpl) SetRegular(v Byte) UiSettingsConfigFonts {
	if s == nil {
		return nil
	}
	s.RegularValue = &v
	return s
}

// NewUser creates a new User instance
func NewUser() User {
	return &UserImpl{}
}

// The parameter regulates the rights for the user
// Example: generic
func (s UserImpl) AccessLevel() *UserAdminAccessLevel {
	return s.AccessLevelValue
}

// The parameter regulates the rights for the user
// Example: generic
func (s *UserImpl) SetAccessLevel(v UserAdminAccessLevel) User {
	if s == nil {
		return nil
	}
	s.AccessLevelValue = &v
	return s
}

// The date and time when the user was created.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.672531199e+12
func (s UserImpl) CreatedAt() *UtcMs {
	return s.CreatedAtValue
}

// The date and time when the user was created.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.672531199e+12
func (s *UserImpl) SetCreatedAt(v UtcMs) User {
	if s == nil {
		return nil
	}
	s.CreatedAtValue = &v
	return s
}

// A parameter that allows you to enable/disable the user
// Example: false
func (s UserImpl) Disabled() *bool {
	return s.DisabledValue
}

// A parameter that allows you to enable/disable the user
// Example: false
func (s *UserImpl) SetDisabled(v bool) User {
	if s == nil {
		return nil
	}
	s.DisabledValue = &v
	return s
}

// User's email. Required for password recovery.
// Format: email (email)
// Example: user@example.com
func (s UserImpl) Email() *Email {
	return s.EmailValue
}

// User's email. Required for password recovery.
// Format: email (email)
// Example: user@example.com
func (s *UserImpl) SetEmail(v Email) User {
	if s == nil {
		return nil
	}
	s.EmailValue = &v
	return s
}

// The user's full name.
func (s UserImpl) Fullname() *string {
	return s.FullnameValue
}

// The user's full name.
func (s *UserImpl) SetFullname(v string) User {
	if s == nil {
		return nil
	}
	s.FullnameValue = &v
	return s
}

// Identifier of the user.
// Example: 1
func (s UserImpl) ID() *int {
	return s.IDValue
}

// Identifier of the user.
// Example: 1
func (s *UserImpl) SetID(v int) User {
	if s == nil {
		return nil
	}
	s.IDValue = &v
	return s
}

// The language, selected by user.
// Format: ISO 639-1
// Example: en
func (s UserImpl) Locale() *ISO6391 {
	return s.LocaleValue
}

// The language, selected by user.
// Format: ISO 639-1
// Example: en
func (s *UserImpl) SetLocale(v ISO6391) User {
	if s == nil {
		return nil
	}
	s.LocaleValue = &v
	return s
}

// The maximum number of sessions the user can have simultaneously.
func (s UserImpl) MaxSessions() *int {
	return s.MaxSessionsValue
}

// The maximum number of sessions the user can have simultaneously.
func (s *UserImpl) SetMaxSessions(v int) User {
	if s == nil {
		return nil
	}
	s.MaxSessionsValue = &v
	return s
}

// User name (login)
func (s UserImpl) Name() *string {
	return s.NameValue
}

// User name (login)
func (s *UserImpl) SetName(v string) User {
	if s == nil {
		return nil
	}
	s.NameValue = &v
	return s
}

// Additional information or notes about the user.
func (s UserImpl) Note() *string {
	return s.NoteValue
}

// Additional information or notes about the user.
func (s *UserImpl) SetNote(v string) User {
	if s == nil {
		return nil
	}
	s.NoteValue = &v
	return s
}

// A parameter indicating that the user belongs to certain organizations
func (s UserImpl) Organizations() []UserAdminOrganizationsItem {
	if s.OrganizationsValue == nil {
		return nil
	}
	result := make([]UserAdminOrganizationsItem, len(s.OrganizationsValue))
	for i, item := range s.OrganizationsValue {
		result[i] = item
	}
	return result
}

// A parameter indicating that the user belongs to certain organizations
func (s *UserImpl) SetOrganizations(v []UserAdminOrganizationsItem) User {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*UserAdminOrganizationsItemImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*UserAdminOrganizationsItemImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.OrganizationsValue = impl
	}
	return s
}

// The specified password will be saved as a hash, used only for writing
func (s UserImpl) Password() *string {
	return s.PasswordValue
}

// The specified password will be saved as a hash, used only for writing
func (s *UserImpl) SetPassword(v string) User {
	if s == nil {
		return nil
	}
	s.PasswordValue = &v
	return s
}

// User's phone number
// Format: phone-number (phone-number)
// Example: +78007778413
func (s UserImpl) Phone() *PhoneNumber {
	return s.PhoneValue
}

// User's phone number
// Format: phone-number (phone-number)
// Example: +78007778413
func (s *UserImpl) SetPhone(v PhoneNumber) User {
	if s == nil {
		return nil
	}
	s.PhoneValue = &v
	return s
}

// A flag indicating that the user has read-only access and cannot modify their own data.
// Example: false
func (s UserImpl) Readonly() *bool {
	return s.ReadonlyValue
}

// A flag indicating that the user has read-only access and cannot modify their own data.
// Example: false
func (s *UserImpl) SetReadonly(v bool) User {
	if s == nil {
		return nil
	}
	s.ReadonlyValue = &v
	return s
}

// NewUserAdmin creates a new UserAdmin instance
func NewUserAdmin() UserAdmin {
	return &UserAdminImpl{}
}

// The parameter regulates the rights for the user
// Example: generic
func (s UserAdminImpl) AccessLevel() *UserAdminAccessLevel {
	return s.AccessLevelValue
}

// The parameter regulates the rights for the user
// Example: generic
func (s *UserAdminImpl) SetAccessLevel(v UserAdminAccessLevel) UserAdmin {
	if s == nil {
		return nil
	}
	s.AccessLevelValue = &v
	return s
}

// A parameter that allows you to enable/disable the user
// Example: false
func (s UserAdminImpl) Disabled() *bool {
	return s.DisabledValue
}

// A parameter that allows you to enable/disable the user
// Example: false
func (s *UserAdminImpl) SetDisabled(v bool) UserAdmin {
	if s == nil {
		return nil
	}
	s.DisabledValue = &v
	return s
}

// Identifier of the user.
// Example: 1
func (s UserAdminImpl) ID() *int {
	return s.IDValue
}

// Identifier of the user.
// Example: 1
func (s *UserAdminImpl) SetID(v int) UserAdmin {
	if s == nil {
		return nil
	}
	s.IDValue = &v
	return s
}

// A parameter indicating that the user belongs to certain organizations
func (s UserAdminImpl) Organizations() []UserAdminOrganizationsItem {
	if s.OrganizationsValue == nil {
		return nil
	}
	result := make([]UserAdminOrganizationsItem, len(s.OrganizationsValue))
	for i, item := range s.OrganizationsValue {
		result[i] = item
	}
	return result
}

// A parameter indicating that the user belongs to certain organizations
func (s *UserAdminImpl) SetOrganizations(v []UserAdminOrganizationsItem) UserAdmin {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*UserAdminOrganizationsItemImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*UserAdminOrganizationsItemImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.OrganizationsValue = impl
	}
	return s
}

// A flag indicating that the user has read-only access and cannot modify their own data.
// Example: false
func (s UserAdminImpl) Readonly() *bool {
	return s.ReadonlyValue
}

// A flag indicating that the user has read-only access and cannot modify their own data.
// Example: false
func (s *UserAdminImpl) SetReadonly(v bool) UserAdmin {
	if s == nil {
		return nil
	}
	s.ReadonlyValue = &v
	return s
}

// NewUserAdminOrganizationsItem creates a new UserAdminOrganizationsItem instance
func NewUserAdminOrganizationsItem() UserAdminOrganizationsItem {
	return &UserAdminOrganizationsItemImpl{}
}

// Id of the organization
// Example: 1
func (s UserAdminOrganizationsItemImpl) ID() *int {
	return s.IDValue
}

// Id of the organization
// Example: 1
func (s *UserAdminOrganizationsItemImpl) SetID(v int) UserAdminOrganizationsItem {
	if s == nil {
		return nil
	}
	s.IDValue = &v
	return s
}

// Owner properties.
func (s UserAdminOrganizationsItemImpl) Owner() UserAdminOrganizationsItemOwner {
	return s.OwnerValue
}

// Owner properties.
func (s *UserAdminOrganizationsItemImpl) SetOwner(v UserAdminOrganizationsItemOwner) UserAdminOrganizationsItem {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*UserAdminOrganizationsItemOwnerImpl); ok {
		s.OwnerValue = impl
	}
	return s
}

// Organization permissions
func (s UserAdminOrganizationsItemImpl) Permissions() OrganizationPermissions {
	return s.PermissionsValue
}

// Organization permissions
func (s *UserAdminOrganizationsItemImpl) SetPermissions(v OrganizationPermissions) UserAdminOrganizationsItem {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*OrganizationPermissionsImpl); ok {
		s.PermissionsValue = impl
	}
	return s
}

// Display title of the organization
// Example: Cameras
func (s UserAdminOrganizationsItemImpl) Title() *string {
	return s.TitleValue
}

// Display title of the organization
// Example: Cameras
func (s *UserAdminOrganizationsItemImpl) SetTitle(v string) UserAdminOrganizationsItem {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// NewUserAdminOrganizationsItemOwner creates a new UserAdminOrganizationsItemOwner instance
func NewUserAdminOrganizationsItemOwner() UserAdminOrganizationsItemOwner {
	return &UserAdminOrganizationsItemOwnerImpl{}
}

// ID of the organizations owner.
// Example: 2
func (s UserAdminOrganizationsItemOwnerImpl) ID() *int {
	return s.IDValue
}

// ID of the organizations owner.
// Example: 2
func (s *UserAdminOrganizationsItemOwnerImpl) SetID(v int) UserAdminOrganizationsItemOwner {
	if s == nil {
		return nil
	}
	s.IDValue = &v
	return s
}

// Name of the organizations owner.
// Example: admin
func (s UserAdminOrganizationsItemOwnerImpl) Name() *string {
	return s.NameValue
}

// Name of the organizations owner.
// Example: admin
func (s *UserAdminOrganizationsItemOwnerImpl) SetName(v string) UserAdminOrganizationsItemOwner {
	if s == nil {
		return nil
	}
	s.NameValue = &v
	return s
}

// NewUserBase creates a new UserBase instance
func NewUserBase() UserBase {
	return &UserBaseImpl{}
}

// The date and time when the user was created.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.672531199e+12
func (s UserBaseImpl) CreatedAt() *UtcMs {
	return s.CreatedAtValue
}

// The date and time when the user was created.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.672531199e+12
func (s *UserBaseImpl) SetCreatedAt(v UtcMs) UserBase {
	if s == nil {
		return nil
	}
	s.CreatedAtValue = &v
	return s
}

// User's email. Required for password recovery.
// Format: email (email)
// Example: user@example.com
func (s UserBaseImpl) Email() *Email {
	return s.EmailValue
}

// User's email. Required for password recovery.
// Format: email (email)
// Example: user@example.com
func (s *UserBaseImpl) SetEmail(v Email) UserBase {
	if s == nil {
		return nil
	}
	s.EmailValue = &v
	return s
}

// The user's full name.
func (s UserBaseImpl) Fullname() *string {
	return s.FullnameValue
}

// The user's full name.
func (s *UserBaseImpl) SetFullname(v string) UserBase {
	if s == nil {
		return nil
	}
	s.FullnameValue = &v
	return s
}

// The language, selected by user.
// Format: ISO 639-1
// Example: en
func (s UserBaseImpl) Locale() *ISO6391 {
	return s.LocaleValue
}

// The language, selected by user.
// Format: ISO 639-1
// Example: en
func (s *UserBaseImpl) SetLocale(v ISO6391) UserBase {
	if s == nil {
		return nil
	}
	s.LocaleValue = &v
	return s
}

// The maximum number of sessions the user can have simultaneously.
func (s UserBaseImpl) MaxSessions() *int {
	return s.MaxSessionsValue
}

// The maximum number of sessions the user can have simultaneously.
func (s *UserBaseImpl) SetMaxSessions(v int) UserBase {
	if s == nil {
		return nil
	}
	s.MaxSessionsValue = &v
	return s
}

// User name (login)
func (s UserBaseImpl) Name() *string {
	return s.NameValue
}

// User name (login)
func (s *UserBaseImpl) SetName(v string) UserBase {
	if s == nil {
		return nil
	}
	s.NameValue = &v
	return s
}

// Additional information or notes about the user.
func (s UserBaseImpl) Note() *string {
	return s.NoteValue
}

// Additional information or notes about the user.
func (s *UserBaseImpl) SetNote(v string) UserBase {
	if s == nil {
		return nil
	}
	s.NoteValue = &v
	return s
}

// The specified password will be saved as a hash, used only for writing
func (s UserBaseImpl) Password() *string {
	return s.PasswordValue
}

// The specified password will be saved as a hash, used only for writing
func (s *UserBaseImpl) SetPassword(v string) UserBase {
	if s == nil {
		return nil
	}
	s.PasswordValue = &v
	return s
}

// User's phone number
// Format: phone-number (phone-number)
// Example: +78007778413
func (s UserBaseImpl) Phone() *PhoneNumber {
	return s.PhoneValue
}

// User's phone number
// Format: phone-number (phone-number)
// Example: +78007778413
func (s *UserBaseImpl) SetPhone(v PhoneNumber) UserBase {
	if s == nil {
		return nil
	}
	s.PhoneValue = &v
	return s
}

// NewUserBaseSteamPermissions creates a new UserBaseSteamPermissions instance
func NewUserBaseSteamPermissions() UserBaseSteamPermissions {
	return &UserBaseSteamPermissionsImpl{}
}

// User identifier
func (s UserBaseSteamPermissionsImpl) ID() *int {
	return s.IDValue
}

// User identifier
func (s *UserBaseSteamPermissionsImpl) SetID(v int) UserBaseSteamPermissions {
	if s == nil {
		return nil
	}
	s.IDValue = &v
	return s
}

// NewUserCreate creates a new UserCreate instance
func NewUserCreate() UserCreate {
	return &UserCreateImpl{}
}

// The parameter regulates the rights for the user
// Example: generic
func (s UserCreateImpl) AccessLevel() *UserAdminAccessLevel {
	return s.AccessLevelValue
}

// The parameter regulates the rights for the user
// Example: generic
func (s *UserCreateImpl) SetAccessLevel(v UserAdminAccessLevel) UserCreate {
	if s == nil {
		return nil
	}
	s.AccessLevelValue = &v
	return s
}

// The date and time when the user was created.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.672531199e+12
func (s UserCreateImpl) CreatedAt() *UtcMs {
	return s.CreatedAtValue
}

// The date and time when the user was created.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.672531199e+12
func (s *UserCreateImpl) SetCreatedAt(v UtcMs) UserCreate {
	if s == nil {
		return nil
	}
	s.CreatedAtValue = &v
	return s
}

// A parameter that allows you to enable/disable the user
// Example: false
func (s UserCreateImpl) Disabled() *bool {
	return s.DisabledValue
}

// A parameter that allows you to enable/disable the user
// Example: false
func (s *UserCreateImpl) SetDisabled(v bool) UserCreate {
	if s == nil {
		return nil
	}
	s.DisabledValue = &v
	return s
}

// User's email. Required for password recovery.
// Format: email (email)
// Example: user@example.com
func (s UserCreateImpl) Email() *Email {
	return s.EmailValue
}

// User's email. Required for password recovery.
// Format: email (email)
// Example: user@example.com
func (s *UserCreateImpl) SetEmail(v Email) UserCreate {
	if s == nil {
		return nil
	}
	s.EmailValue = &v
	return s
}

// The user's full name.
func (s UserCreateImpl) Fullname() *string {
	return s.FullnameValue
}

// The user's full name.
func (s *UserCreateImpl) SetFullname(v string) UserCreate {
	if s == nil {
		return nil
	}
	s.FullnameValue = &v
	return s
}

// Identifier of the user.
// Example: 1
func (s UserCreateImpl) ID() *int {
	return s.IDValue
}

// Identifier of the user.
// Example: 1
func (s *UserCreateImpl) SetID(v int) UserCreate {
	if s == nil {
		return nil
	}
	s.IDValue = &v
	return s
}

// The language, selected by user.
// Format: ISO 639-1
// Example: en
func (s UserCreateImpl) Locale() *ISO6391 {
	return s.LocaleValue
}

// The language, selected by user.
// Format: ISO 639-1
// Example: en
func (s *UserCreateImpl) SetLocale(v ISO6391) UserCreate {
	if s == nil {
		return nil
	}
	s.LocaleValue = &v
	return s
}

// The maximum number of sessions the user can have simultaneously.
func (s UserCreateImpl) MaxSessions() *int {
	return s.MaxSessionsValue
}

// The maximum number of sessions the user can have simultaneously.
func (s *UserCreateImpl) SetMaxSessions(v int) UserCreate {
	if s == nil {
		return nil
	}
	s.MaxSessionsValue = &v
	return s
}

// User name (login)
func (s UserCreateImpl) Name() *string {
	return s.NameValue
}

// User name (login)
func (s *UserCreateImpl) SetName(v string) UserCreate {
	if s == nil {
		return nil
	}
	s.NameValue = &v
	return s
}

// Additional information or notes about the user.
func (s UserCreateImpl) Note() *string {
	return s.NoteValue
}

// Additional information or notes about the user.
func (s *UserCreateImpl) SetNote(v string) UserCreate {
	if s == nil {
		return nil
	}
	s.NoteValue = &v
	return s
}

// The identifier of the Organization to which the user should be added.
// If no organization_id - first organization where user has permissions for managing users.
// Example: 12
func (s UserCreateImpl) OrganizationID() *int {
	return s.OrganizationIDValue
}

// The identifier of the Organization to which the user should be added.
// If no organization_id - first organization where user has permissions for managing users.
// Example: 12
func (s *UserCreateImpl) SetOrganizationID(v int) UserCreate {
	if s == nil {
		return nil
	}
	s.OrganizationIDValue = &v
	return s
}

// A parameter indicating that the user belongs to certain organizations
func (s UserCreateImpl) Organizations() []UserAdminOrganizationsItem {
	if s.OrganizationsValue == nil {
		return nil
	}
	result := make([]UserAdminOrganizationsItem, len(s.OrganizationsValue))
	for i, item := range s.OrganizationsValue {
		result[i] = item
	}
	return result
}

// A parameter indicating that the user belongs to certain organizations
func (s *UserCreateImpl) SetOrganizations(v []UserAdminOrganizationsItem) UserCreate {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*UserAdminOrganizationsItemImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*UserAdminOrganizationsItemImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.OrganizationsValue = impl
	}
	return s
}

// The specified password will be saved as a hash, used only for writing
func (s UserCreateImpl) Password() *string {
	return s.PasswordValue
}

// The specified password will be saved as a hash, used only for writing
func (s *UserCreateImpl) SetPassword(v string) UserCreate {
	if s == nil {
		return nil
	}
	s.PasswordValue = &v
	return s
}

// User's phone number
// Format: phone-number (phone-number)
// Example: +78007778413
func (s UserCreateImpl) Phone() *PhoneNumber {
	return s.PhoneValue
}

// User's phone number
// Format: phone-number (phone-number)
// Example: +78007778413
func (s *UserCreateImpl) SetPhone(v PhoneNumber) UserCreate {
	if s == nil {
		return nil
	}
	s.PhoneValue = &v
	return s
}

// A flag indicating that the user has read-only access and cannot modify their own data.
// Example: false
func (s UserCreateImpl) Readonly() *bool {
	return s.ReadonlyValue
}

// A flag indicating that the user has read-only access and cannot modify their own data.
// Example: false
func (s *UserCreateImpl) SetReadonly(v bool) UserCreate {
	if s == nil {
		return nil
	}
	s.ReadonlyValue = &v
	return s
}

// NewUserFolder creates a new UserFolder instance
func NewUserFolder() UserFolder {
	return &UserFolderImpl{}
}

// The folder may have a floor plan attached to it to be shown on the map.
// This parameter sets the image center coordinates: latitude and longitude.
func (s UserFolderImpl) Coordinates() MapSpec {
	return s.CoordinatesValue
}

// The folder may have a floor plan attached to it to be shown on the map.
// This parameter sets the image center coordinates: latitude and longitude.
func (s *UserFolderImpl) SetCoordinates(v MapSpec) UserFolder {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*MapSpecImpl); ok {
		s.CoordinatesValue = impl
	}
	return s
}

// Object of map parameters
func (s UserFolderImpl) FloorPlan() FolderFloorPlan {
	return s.FloorPlanValue
}

// Object of map parameters
func (s *UserFolderImpl) SetFloorPlan(v FolderFloorPlan) UserFolder {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*FolderFloorPlanImpl); ok {
		s.FloorPlanValue = impl
	}
	return s
}

// Hierarchy object.
func (s UserFolderImpl) Hierarchy() FolderHierarchy {
	return s.HierarchyValue
}

// Hierarchy object.
func (s *UserFolderImpl) SetHierarchy(v FolderHierarchy) UserFolder {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*FolderHierarchyImpl); ok {
		s.HierarchyValue = impl
	}
	return s
}

// The folder ID.
func (s UserFolderImpl) ID() int {
	return s.IDValue
}

// The folder ID.
func (s *UserFolderImpl) SetID(v int) UserFolder {
	if s == nil {
		return nil
	}
	s.IDValue = v
	return s
}

// The identifier of the Organization to which the folder belongs.
func (s UserFolderImpl) OrganizationID() *int {
	return s.OrganizationIDValue
}

// The identifier of the Organization to which the folder belongs.
func (s *UserFolderImpl) SetOrganizationID(v int) UserFolder {
	if s == nil {
		return nil
	}
	s.OrganizationIDValue = &v
	return s
}

// The identifier of the parent folder.
func (s UserFolderImpl) ParentID() *int {
	return s.ParentIDValue
}

// The identifier of the parent folder.
func (s *UserFolderImpl) SetParentID(v int) UserFolder {
	if s == nil {
		return nil
	}
	s.ParentIDValue = &v
	return s
}

func (s UserFolderImpl) Permissions() UserFolderPermissions {
	return s.PermissionsValue
}

func (s *UserFolderImpl) SetPermissions(v UserFolderPermissions) UserFolder {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*UserFolderPermissionsImpl); ok {
		s.PermissionsValue = impl
	}
	return s
}

// The number of streams in the folder.
// Example: 2
func (s UserFolderImpl) StreamsCount() *int {
	return s.StreamsCountValue
}

// The number of streams in the folder.
// Example: 2
func (s *UserFolderImpl) SetStreamsCount(v int) UserFolder {
	if s == nil {
		return nil
	}
	s.StreamsCountValue = &v
	return s
}

// The folder name.
func (s UserFolderImpl) Title() *string {
	return s.TitleValue
}

// The folder name.
func (s *UserFolderImpl) SetTitle(v string) UserFolder {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// NewUserFolderPermissions creates a new UserFolderPermissions instance
func NewUserFolderPermissions() UserFolderPermissions {
	return &UserFolderPermissionsImpl{}
}

// The flag showing if the user can manage and execute actions on the streams in the folder.
func (s UserFolderPermissionsImpl) CanUseActions() *bool {
	return s.CanUseActionsValue
}

// The flag showing if the user can manage and execute actions on the streams in the folder.
func (s *UserFolderPermissionsImpl) SetCanUseActions(v bool) UserFolderPermissions {
	if s == nil {
		return nil
	}
	s.CanUseActionsValue = &v
	return s
}

// The flag if the user can use PTZ controls.
func (s UserFolderPermissionsImpl) CanUsePtz() *bool {
	return s.CanUsePtzValue
}

// The flag if the user can use PTZ controls.
func (s *UserFolderPermissionsImpl) SetCanUsePtz(v bool) UserFolderPermissions {
	if s == nil {
		return nil
	}
	s.CanUsePtzValue = &v
	return s
}

// The flag showing if the user can view only live on the streams in the folder and the list of streams.
func (s UserFolderPermissionsImpl) CanView() *bool {
	return s.CanViewValue
}

// The flag showing if the user can view only live on the streams in the folder and the list of streams.
func (s *UserFolderPermissionsImpl) SetCanView(v bool) UserFolderPermissions {
	if s == nil {
		return nil
	}
	s.CanViewValue = &v
	return s
}

// The flag showing if the user can view archive on the streams in the folder.
func (s UserFolderPermissionsImpl) CanViewDvr() *bool {
	return s.CanViewDvrValue
}

// The flag showing if the user can view archive on the streams in the folder.
func (s *UserFolderPermissionsImpl) SetCanViewDvr(v bool) UserFolderPermissions {
	if s == nil {
		return nil
	}
	s.CanViewDvrValue = &v
	return s
}

// The dvr depth limit allows to:
// Set the maximum recording depth, which determines how far back recorded materials can be viewed.
// Manage access to archived data, ensuring security and control over who can access records.
// if set to 0, the user has unlimited access to the archive.
// Format: seconds (seconds)
// Example: 3600
func (s UserFolderPermissionsImpl) DvrDepthLimit() *Seconds {
	return s.DvrDepthLimitValue
}

// The dvr depth limit allows to:
// Set the maximum recording depth, which determines how far back recorded materials can be viewed.
// Manage access to archived data, ensuring security and control over who can access records.
// if set to 0, the user has unlimited access to the archive.
// Format: seconds (seconds)
// Example: 3600
func (s *UserFolderPermissionsImpl) SetDvrDepthLimit(v Seconds) UserFolderPermissions {
	if s == nil {
		return nil
	}
	s.DvrDepthLimitValue = &v
	return s
}

// NewUserFolders creates a new UserFolders instance
func NewUserFolders() UserFolders {
	return &UserFoldersImpl{}
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s UserFoldersImpl) EstimatedCount() *int {
	return s.EstimatedCountValue
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s *UserFoldersImpl) SetEstimatedCount(v int) UserFolders {
	if s == nil {
		return nil
	}
	s.EstimatedCountValue = &v
	return s
}

// List of fetched user folders according to the query parameters.
func (s UserFoldersImpl) Folders() []UserFolder {
	if s.FoldersValue == nil {
		return nil
	}
	result := make([]UserFolder, len(s.FoldersValue))
	for i, item := range s.FoldersValue {
		result[i] = item
	}
	return result
}

// List of fetched user folders according to the query parameters.
func (s *UserFoldersImpl) SetFolders(v []UserFolder) UserFolders {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*UserFolderImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*UserFolderImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.FoldersValue = impl
	}
	return s
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s UserFoldersImpl) Next() *string {
	return s.NextValue
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s *UserFoldersImpl) SetNext(v string) UserFolders {
	if s == nil {
		return nil
	}
	s.NextValue = &v
	return s
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s UserFoldersImpl) Prev() *string {
	return s.PrevValue
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s *UserFoldersImpl) SetPrev(v string) UserFolders {
	if s == nil {
		return nil
	}
	s.PrevValue = &v
	return s
}

// An object with a list of different timings measured during this API call.
func (s UserFoldersImpl) Timing() any {
	return s.TimingValue
}

// An object with a list of different timings measured during this API call.
func (s *UserFoldersImpl) SetTiming(v any) UserFolders {
	if s == nil {
		return nil
	}
	s.TimingValue = v
	return s
}

// Collection returns the collection items from UserFolders
func (s UserFoldersImpl) Collection() []UserFolder {
	return s.Folders()
}

// NewUserProfile creates a new UserProfile instance
func NewUserProfile() UserProfile {
	return &UserProfileImpl{}
}

// Indicates that user has access_level equal "admin".
func (s UserProfileImpl) IsAdmin() *bool {
	return s.IsAdminValue
}

// Indicates that user has access_level equal "admin".
func (s *UserProfileImpl) SetIsAdmin(v bool) UserProfile {
	if s == nil {
		return nil
	}
	s.IsAdminValue = &v
	return s
}

// Indicates that user has access_level equal "domain admin".
func (s UserProfileImpl) IsDomainAdmin() *bool {
	return s.IsDomainAdminValue
}

// Indicates that user has access_level equal "domain admin".
func (s *UserProfileImpl) SetIsDomainAdmin(v bool) UserProfile {
	if s == nil {
		return nil
	}
	s.IsDomainAdminValue = &v
	return s
}

// Indicates that the user has a read-only access level.
// Example: true
func (s UserProfileImpl) IsReadonly() *bool {
	return s.IsReadonlyValue
}

// Indicates that the user has a read-only access level.
// Example: true
func (s *UserProfileImpl) SetIsReadonly(v bool) UserProfile {
	if s == nil {
		return nil
	}
	s.IsReadonlyValue = &v
	return s
}

// NewUserStreamPermission creates a new UserStreamPermission instance
func NewUserStreamPermission() UserStreamPermission {
	return &UserStreamPermissionImpl{}
}

func (s UserStreamPermissionImpl) Permissions() UserStreamPermissionPermissions {
	return s.PermissionsValue
}

func (s *UserStreamPermissionImpl) SetPermissions(v UserStreamPermissionPermissions) UserStreamPermission {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*UserStreamPermissionPermissionsImpl); ok {
		s.PermissionsValue = impl
	}
	return s
}

func (s UserStreamPermissionImpl) Stream() UserStreamPermissionStream {
	return s.StreamValue
}

func (s *UserStreamPermissionImpl) SetStream(v UserStreamPermissionStream) UserStreamPermission {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*UserStreamPermissionStreamImpl); ok {
		s.StreamValue = impl
	}
	return s
}

// NewUserStreamPermissionPermissions creates a new UserStreamPermissionPermissions instance
func NewUserStreamPermissionPermissions() UserStreamPermissionPermissions {
	return &UserStreamPermissionPermissionsImpl{}
}

// Whether the user can control PTZ cameras
func (s UserStreamPermissionPermissionsImpl) CanUsePtz() *bool {
	return s.CanUsePtzValue
}

// Whether the user can control PTZ cameras
func (s *UserStreamPermissionPermissionsImpl) SetCanUsePtz(v bool) UserStreamPermissionPermissions {
	if s == nil {
		return nil
	}
	s.CanUsePtzValue = &v
	return s
}

// Whether the user can view the stream
func (s UserStreamPermissionPermissionsImpl) CanView() *bool {
	return s.CanViewValue
}

// Whether the user can view the stream
func (s *UserStreamPermissionPermissionsImpl) SetCanView(v bool) UserStreamPermissionPermissions {
	if s == nil {
		return nil
	}
	s.CanViewValue = &v
	return s
}

// Whether the user can view the stream archive
func (s UserStreamPermissionPermissionsImpl) CanViewDvr() *bool {
	return s.CanViewDvrValue
}

// Whether the user can view the stream archive
func (s *UserStreamPermissionPermissionsImpl) SetCanViewDvr(v bool) UserStreamPermissionPermissions {
	if s == nil {
		return nil
	}
	s.CanViewDvrValue = &v
	return s
}

// Maximum archive depth in seconds that user can access
func (s UserStreamPermissionPermissionsImpl) DvrDepthLimit() *int {
	return s.DvrDepthLimitValue
}

// Maximum archive depth in seconds that user can access
func (s *UserStreamPermissionPermissionsImpl) SetDvrDepthLimit(v int) UserStreamPermissionPermissions {
	if s == nil {
		return nil
	}
	s.DvrDepthLimitValue = &v
	return s
}

// NewUserStreamPermissionStream creates a new UserStreamPermissionStream instance
func NewUserStreamPermissionStream() UserStreamPermissionStream {
	return &UserStreamPermissionStreamImpl{}
}

// Stream name
func (s UserStreamPermissionStreamImpl) Name() *string {
	return s.NameValue
}

// Stream name
func (s *UserStreamPermissionStreamImpl) SetName(v string) UserStreamPermissionStream {
	if s == nil {
		return nil
	}
	s.NameValue = &v
	return s
}

// NewUserStreamsPermissionsList creates a new UserStreamsPermissionsList instance
func NewUserStreamsPermissionsList() UserStreamsPermissionsList {
	return &UserStreamsPermissionsListImpl{}
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s UserStreamsPermissionsListImpl) EstimatedCount() *int {
	return s.EstimatedCountValue
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s *UserStreamsPermissionsListImpl) SetEstimatedCount(v int) UserStreamsPermissionsList {
	if s == nil {
		return nil
	}
	s.EstimatedCountValue = &v
	return s
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s UserStreamsPermissionsListImpl) Next() *string {
	return s.NextValue
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s *UserStreamsPermissionsListImpl) SetNext(v string) UserStreamsPermissionsList {
	if s == nil {
		return nil
	}
	s.NextValue = &v
	return s
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s UserStreamsPermissionsListImpl) Prev() *string {
	return s.PrevValue
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s *UserStreamsPermissionsListImpl) SetPrev(v string) UserStreamsPermissionsList {
	if s == nil {
		return nil
	}
	s.PrevValue = &v
	return s
}

// List of streams
func (s UserStreamsPermissionsListImpl) StreamsPermissions() []UserStreamPermission {
	if s.StreamsPermissionsValue == nil {
		return nil
	}
	result := make([]UserStreamPermission, len(s.StreamsPermissionsValue))
	for i, item := range s.StreamsPermissionsValue {
		result[i] = item
	}
	return result
}

// List of streams
func (s *UserStreamsPermissionsListImpl) SetStreamsPermissions(v []UserStreamPermission) UserStreamsPermissionsList {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*UserStreamPermissionImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*UserStreamPermissionImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.StreamsPermissionsValue = impl
	}
	return s
}

// An object with a list of different timings measured during this API call.
func (s UserStreamsPermissionsListImpl) Timing() any {
	return s.TimingValue
}

// An object with a list of different timings measured during this API call.
func (s *UserStreamsPermissionsListImpl) SetTiming(v any) UserStreamsPermissionsList {
	if s == nil {
		return nil
	}
	s.TimingValue = v
	return s
}

// Collection returns the collection items from UserStreamsPermissionsList
func (s UserStreamsPermissionsListImpl) Collection() []UserStreamPermission {
	return s.StreamsPermissions()
}

// NewUsers creates a new Users instance
func NewUsers() Users {
	return &UsersImpl{}
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s UsersImpl) EstimatedCount() *int {
	return s.EstimatedCountValue
}

// Estimated total number of records for the query (regardless of the cursors).
// Example: 5
func (s *UsersImpl) SetEstimatedCount(v int) Users {
	if s == nil {
		return nil
	}
	s.EstimatedCountValue = &v
	return s
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s UsersImpl) Next() *string {
	return s.NextValue
}

// Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fZ3Q9MA==
func (s *UsersImpl) SetNext(v string) Users {
	if s == nil {
		return nil
	}
	s.NextValue = &v
	return s
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s UsersImpl) Prev() *string {
	return s.PrevValue
}

// Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.
// Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).
// Example: JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl
func (s *UsersImpl) SetPrev(v string) Users {
	if s == nil {
		return nil
	}
	s.PrevValue = &v
	return s
}

// An object with a list of different timings measured during this API call.
func (s UsersImpl) Timing() any {
	return s.TimingValue
}

// An object with a list of different timings measured during this API call.
func (s *UsersImpl) SetTiming(v any) Users {
	if s == nil {
		return nil
	}
	s.TimingValue = v
	return s
}

// List of fetched users according to the query parameters.
func (s UsersImpl) UsersList() []User {
	if s.UsersListValue == nil {
		return nil
	}
	result := make([]User, len(s.UsersListValue))
	for i, item := range s.UsersListValue {
		result[i] = item
	}
	return result
}

// List of fetched users according to the query parameters.
func (s *UsersImpl) SetUsersList(v []User) Users {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*UserImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*UserImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.UsersListValue = impl
	}
	return s
}

// Collection returns the collection items from Users
func (s UsersImpl) Collection() []User {
	return s.UsersList()
}

// NewVisionAlerts creates a new VisionAlerts instance
func NewVisionAlerts() VisionAlerts {
	return &VisionAlertsImpl{}
}

// The time when an episode could not be created due to low detection quality (on blurry or noisy frames).
// It may be caused by uncertainty when the picture is not clear enough.
// Try adjusting the shutter speed parameters on your camera.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s VisionAlertsImpl) LowQualityAt() *UtcMs {
	return s.LowQualityAtValue
}

// The time when an episode could not be created due to low detection quality (on blurry or noisy frames).
// It may be caused by uncertainty when the picture is not clear enough.
// Try adjusting the shutter speed parameters on your camera.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s *VisionAlertsImpl) SetLowQualityAt(v UtcMs) VisionAlerts {
	if s == nil {
		return nil
	}
	s.LowQualityAtValue = &v
	return s
}

// The time when an episode could not be created due to insufficient detections.
// The issue occurs when the selected detector is unable to find the target object enough times.
// It is possible that the target object appears shortly or is obscured by something.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s VisionAlertsImpl) NotEnoughDetectionsAt() *UtcMs {
	return s.NotEnoughDetectionsAtValue
}

// The time when an episode could not be created due to insufficient detections.
// The issue occurs when the selected detector is unable to find the target object enough times.
// It is possible that the target object appears shortly or is obscured by something.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s *VisionAlertsImpl) SetNotEnoughDetectionsAt(v UtcMs) VisionAlerts {
	if s == nil {
		return nil
	}
	s.NotEnoughDetectionsAtValue = &v
	return s
}

// The time when an episode could not be created due to the small size of detections relative to the detector internal settings.
// The camera placement may need to be adjusted closer to the target objects.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s VisionAlertsImpl) SmallSizeAt() *UtcMs {
	return s.SmallSizeAtValue
}

// The time when an episode could not be created due to the small size of detections relative to the detector internal settings.
// The camera placement may need to be adjusted closer to the target objects.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s *VisionAlertsImpl) SetSmallSizeAt(v UtcMs) VisionAlerts {
	if s == nil {
		return nil
	}
	s.SmallSizeAtValue = &v
	return s
}

// NewVisionAppearance creates a new VisionAppearance instance
func NewVisionAppearance() VisionAppearance {
	return &VisionAppearanceImpl{}
}

// Position of the objects at the frame
func (s VisionAppearanceImpl) Box() VisionBox {
	return s.BoxValue
}

// Position of the objects at the frame
func (s *VisionAppearanceImpl) SetBox(v VisionBox) VisionAppearance {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionBoxImpl); ok {
		s.BoxValue = impl
	}
	return s
}

// NewVisionBox creates a new VisionBox instance
func NewVisionBox() VisionBox {
	return &VisionBoxImpl{}
}

// Bottom border of the bounding box. Fraction of full frame height
func (s VisionBoxImpl) Bottom() float64 {
	return s.BottomValue
}

// Bottom border of the bounding box. Fraction of full frame height
func (s *VisionBoxImpl) SetBottom(v float64) VisionBox {
	if s == nil {
		return nil
	}
	s.BottomValue = v
	return s
}

// Left border of the bounding box. Fraction of full frame width
func (s VisionBoxImpl) Left() float64 {
	return s.LeftValue
}

// Left border of the bounding box. Fraction of full frame width
func (s *VisionBoxImpl) SetLeft(v float64) VisionBox {
	if s == nil {
		return nil
	}
	s.LeftValue = v
	return s
}

// Right border of the bounding box. Fraction of full frame width
func (s VisionBoxImpl) Right() float64 {
	return s.RightValue
}

// Right border of the bounding box. Fraction of full frame width
func (s *VisionBoxImpl) SetRight(v float64) VisionBox {
	if s == nil {
		return nil
	}
	s.RightValue = v
	return s
}

// Top border of the bounding box. Fraction of full frame height
func (s VisionBoxImpl) Top() float64 {
	return s.TopValue
}

// Top border of the bounding box. Fraction of full frame height
func (s *VisionBoxImpl) SetTop(v float64) VisionBox {
	if s == nil {
		return nil
	}
	s.TopValue = v
	return s
}

// NewVisionDetectedFace creates a new VisionDetectedFace instance
func NewVisionDetectedFace() VisionDetectedFace {
	return &VisionDetectedFaceImpl{}
}

// Appearance attributes of the detected object
func (s VisionDetectedFaceImpl) Appearance() VisionAppearance {
	return s.AppearanceValue
}

// Appearance attributes of the detected object
func (s *VisionDetectedFaceImpl) SetAppearance(v VisionAppearance) VisionDetectedFace {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionAppearanceImpl); ok {
		s.AppearanceValue = impl
	}
	return s
}

// Confidence level of object detection
func (s VisionDetectedFaceImpl) Confidence() *float64 {
	return s.ConfidenceValue
}

// Confidence level of object detection
func (s *VisionDetectedFaceImpl) SetConfidence(v float64) VisionDetectedFace {
	if s == nil {
		return nil
	}
	s.ConfidenceValue = &v
	return s
}

// Timestamp when the object was detected
// Format: utc_ms (Unix timestamp in milliseconds)
func (s VisionDetectedFaceImpl) DetectedAt() UtcMs {
	return s.DetectedAtValue
}

// Timestamp when the object was detected
// Format: utc_ms (Unix timestamp in milliseconds)
func (s *VisionDetectedFaceImpl) SetDetectedAt(v UtcMs) VisionDetectedFace {
	if s == nil {
		return nil
	}
	s.DetectedAtValue = v
	return s
}

// The fingerprint of the detected face
func (s VisionDetectedFaceImpl) Fingerprint() VisionFaceFingerprint {
	return s.FingerprintValue
}

// The fingerprint of the detected face
func (s *VisionDetectedFaceImpl) SetFingerprint(v VisionFaceFingerprint) VisionDetectedFace {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionFaceFingerprintImpl); ok {
		s.FingerprintValue = impl
	}
	return s
}

// Class of the detected object
func (s VisionDetectedFaceImpl) ObjectClass() VisionObjectClass {
	return s.ObjectClassValue
}

// Class of the detected object
func (s *VisionDetectedFaceImpl) SetObjectClass(v VisionObjectClass) VisionDetectedFace {
	if s == nil {
		return nil
	}
	s.ObjectClassValue = v
	return s
}

// Preview of the detected object
func (s VisionDetectedFaceImpl) Thumbnail() VisionImageAttributes {
	return s.ThumbnailValue
}

// Preview of the detected object
func (s *VisionDetectedFaceImpl) SetThumbnail(v VisionImageAttributes) VisionDetectedFace {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionImageAttributesImpl); ok {
		s.ThumbnailValue = impl
	}
	return s
}

// Quality of the thumbnail
func (s VisionDetectedFaceImpl) ThumbnailQuality() *float64 {
	return s.ThumbnailQualityValue
}

// Quality of the thumbnail
func (s *VisionDetectedFaceImpl) SetThumbnailQuality(v float64) VisionDetectedFace {
	if s == nil {
		return nil
	}
	s.ThumbnailQualityValue = &v
	return s
}

// NewVisionDetectedLicensePlate creates a new VisionDetectedLicensePlate instance
func NewVisionDetectedLicensePlate() VisionDetectedLicensePlate {
	return &VisionDetectedLicensePlateImpl{}
}

// Appearance attributes of the detected object
func (s VisionDetectedLicensePlateImpl) Appearance() VisionAppearance {
	return s.AppearanceValue
}

// Appearance attributes of the detected object
func (s *VisionDetectedLicensePlateImpl) SetAppearance(v VisionAppearance) VisionDetectedLicensePlate {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionAppearanceImpl); ok {
		s.AppearanceValue = impl
	}
	return s
}

// Confidence level of object detection
func (s VisionDetectedLicensePlateImpl) Confidence() *float64 {
	return s.ConfidenceValue
}

// Confidence level of object detection
func (s *VisionDetectedLicensePlateImpl) SetConfidence(v float64) VisionDetectedLicensePlate {
	if s == nil {
		return nil
	}
	s.ConfidenceValue = &v
	return s
}

// Timestamp when the object was detected
// Format: utc_ms (Unix timestamp in milliseconds)
func (s VisionDetectedLicensePlateImpl) DetectedAt() UtcMs {
	return s.DetectedAtValue
}

// Timestamp when the object was detected
// Format: utc_ms (Unix timestamp in milliseconds)
func (s *VisionDetectedLicensePlateImpl) SetDetectedAt(v UtcMs) VisionDetectedLicensePlate {
	if s == nil {
		return nil
	}
	s.DetectedAtValue = v
	return s
}

// Shows from which side the vehicle was detected.
func (s VisionDetectedLicensePlateImpl) FacingSide() *VisionVehicleFacingSide {
	return s.FacingSideValue
}

// Shows from which side the vehicle was detected.
func (s *VisionDetectedLicensePlateImpl) SetFacingSide(v VisionVehicleFacingSide) VisionDetectedLicensePlate {
	if s == nil {
		return nil
	}
	s.FacingSideValue = &v
	return s
}

// Class of the detected object
func (s VisionDetectedLicensePlateImpl) ObjectClass() VisionObjectClass {
	return s.ObjectClassValue
}

// Class of the detected object
func (s *VisionDetectedLicensePlateImpl) SetObjectClass(v VisionObjectClass) VisionDetectedLicensePlate {
	if s == nil {
		return nil
	}
	s.ObjectClassValue = v
	return s
}

// Recognized vehicle's license plate number
func (s VisionDetectedLicensePlateImpl) PlateText() *string {
	return s.PlateTextValue
}

// Recognized vehicle's license plate number
func (s *VisionDetectedLicensePlateImpl) SetPlateText(v string) VisionDetectedLicensePlate {
	if s == nil {
		return nil
	}
	s.PlateTextValue = &v
	return s
}

// Preview of the detected object
func (s VisionDetectedLicensePlateImpl) Thumbnail() VisionImageAttributes {
	return s.ThumbnailValue
}

// Preview of the detected object
func (s *VisionDetectedLicensePlateImpl) SetThumbnail(v VisionImageAttributes) VisionDetectedLicensePlate {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionImageAttributesImpl); ok {
		s.ThumbnailValue = impl
	}
	return s
}

// Quality of the thumbnail
func (s VisionDetectedLicensePlateImpl) ThumbnailQuality() *float64 {
	return s.ThumbnailQualityValue
}

// Quality of the thumbnail
func (s *VisionDetectedLicensePlateImpl) SetThumbnailQuality(v float64) VisionDetectedLicensePlate {
	if s == nil {
		return nil
	}
	s.ThumbnailQualityValue = &v
	return s
}

// NewVisionDetectedObjectBase creates a new VisionDetectedObjectBase instance
func NewVisionDetectedObjectBase() VisionDetectedObjectBase {
	return &VisionDetectedObjectBaseImpl{}
}

// Appearance attributes of the detected object
func (s VisionDetectedObjectBaseImpl) Appearance() VisionAppearance {
	return s.AppearanceValue
}

// Appearance attributes of the detected object
func (s *VisionDetectedObjectBaseImpl) SetAppearance(v VisionAppearance) VisionDetectedObjectBase {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionAppearanceImpl); ok {
		s.AppearanceValue = impl
	}
	return s
}

// Confidence level of object detection
func (s VisionDetectedObjectBaseImpl) Confidence() *float64 {
	return s.ConfidenceValue
}

// Confidence level of object detection
func (s *VisionDetectedObjectBaseImpl) SetConfidence(v float64) VisionDetectedObjectBase {
	if s == nil {
		return nil
	}
	s.ConfidenceValue = &v
	return s
}

// Timestamp when the object was detected
// Format: utc_ms (Unix timestamp in milliseconds)
func (s VisionDetectedObjectBaseImpl) DetectedAt() UtcMs {
	return s.DetectedAtValue
}

// Timestamp when the object was detected
// Format: utc_ms (Unix timestamp in milliseconds)
func (s *VisionDetectedObjectBaseImpl) SetDetectedAt(v UtcMs) VisionDetectedObjectBase {
	if s == nil {
		return nil
	}
	s.DetectedAtValue = v
	return s
}

// Class of the detected object
func (s VisionDetectedObjectBaseImpl) ObjectClass() VisionObjectClass {
	return s.ObjectClassValue
}

// Class of the detected object
func (s *VisionDetectedObjectBaseImpl) SetObjectClass(v VisionObjectClass) VisionDetectedObjectBase {
	if s == nil {
		return nil
	}
	s.ObjectClassValue = v
	return s
}

// Preview of the detected object
func (s VisionDetectedObjectBaseImpl) Thumbnail() VisionImageAttributes {
	return s.ThumbnailValue
}

// Preview of the detected object
func (s *VisionDetectedObjectBaseImpl) SetThumbnail(v VisionImageAttributes) VisionDetectedObjectBase {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionImageAttributesImpl); ok {
		s.ThumbnailValue = impl
	}
	return s
}

// Quality of the thumbnail
func (s VisionDetectedObjectBaseImpl) ThumbnailQuality() *float64 {
	return s.ThumbnailQualityValue
}

// Quality of the thumbnail
func (s *VisionDetectedObjectBaseImpl) SetThumbnailQuality(v float64) VisionDetectedObjectBase {
	if s == nil {
		return nil
	}
	s.ThumbnailQualityValue = &v
	return s
}

// NewVisionDetectedVehicle creates a new VisionDetectedVehicle instance
func NewVisionDetectedVehicle() VisionDetectedVehicle {
	return &VisionDetectedVehicleImpl{}
}

// Appearance attributes of the detected object
func (s VisionDetectedVehicleImpl) Appearance() VisionAppearance {
	return s.AppearanceValue
}

// Appearance attributes of the detected object
func (s *VisionDetectedVehicleImpl) SetAppearance(v VisionAppearance) VisionDetectedVehicle {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionAppearanceImpl); ok {
		s.AppearanceValue = impl
	}
	return s
}

// Confidence level of object detection
func (s VisionDetectedVehicleImpl) Confidence() *float64 {
	return s.ConfidenceValue
}

// Confidence level of object detection
func (s *VisionDetectedVehicleImpl) SetConfidence(v float64) VisionDetectedVehicle {
	if s == nil {
		return nil
	}
	s.ConfidenceValue = &v
	return s
}

// Timestamp when the object was detected
// Format: utc_ms (Unix timestamp in milliseconds)
func (s VisionDetectedVehicleImpl) DetectedAt() UtcMs {
	return s.DetectedAtValue
}

// Timestamp when the object was detected
// Format: utc_ms (Unix timestamp in milliseconds)
func (s *VisionDetectedVehicleImpl) SetDetectedAt(v UtcMs) VisionDetectedVehicle {
	if s == nil {
		return nil
	}
	s.DetectedAtValue = v
	return s
}

// Indicates if no license plate is detected on this vehicle
func (s VisionDetectedVehicleImpl) LicensePlateMissing() *bool {
	return s.LicensePlateMissingValue
}

// Indicates if no license plate is detected on this vehicle
func (s *VisionDetectedVehicleImpl) SetLicensePlateMissing(v bool) VisionDetectedVehicle {
	if s == nil {
		return nil
	}
	s.LicensePlateMissingValue = &v
	return s
}

// Class of the detected object
func (s VisionDetectedVehicleImpl) ObjectClass() VisionObjectClass {
	return s.ObjectClassValue
}

// Class of the detected object
func (s *VisionDetectedVehicleImpl) SetObjectClass(v VisionObjectClass) VisionDetectedVehicle {
	if s == nil {
		return nil
	}
	s.ObjectClassValue = v
	return s
}

// The purpose of the vehicle, e.g. emergency or regular.
func (s VisionDetectedVehicleImpl) Purpose() *VisionVehiclePurpose {
	return s.PurposeValue
}

// The purpose of the vehicle, e.g. emergency or regular.
func (s *VisionDetectedVehicleImpl) SetPurpose(v VisionVehiclePurpose) VisionDetectedVehicle {
	if s == nil {
		return nil
	}
	s.PurposeValue = &v
	return s
}

// Preview of the detected object
func (s VisionDetectedVehicleImpl) Thumbnail() VisionImageAttributes {
	return s.ThumbnailValue
}

// Preview of the detected object
func (s *VisionDetectedVehicleImpl) SetThumbnail(v VisionImageAttributes) VisionDetectedVehicle {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionImageAttributesImpl); ok {
		s.ThumbnailValue = impl
	}
	return s
}

// Quality of the thumbnail
func (s VisionDetectedVehicleImpl) ThumbnailQuality() *float64 {
	return s.ThumbnailQualityValue
}

// Quality of the thumbnail
func (s *VisionDetectedVehicleImpl) SetThumbnailQuality(v float64) VisionDetectedVehicle {
	if s == nil {
		return nil
	}
	s.ThumbnailQualityValue = &v
	return s
}

// NewVisionDetectorConfig creates a new VisionDetectorConfig instance
func NewVisionDetectorConfig() VisionDetectorConfig {
	return &VisionDetectorConfigImpl{}
}

func (s VisionDetectorConfigImpl) DetectorType() VisionDetectorConfigDetectorType {
	return s.DetectorTypeValue
}

func (s *VisionDetectorConfigImpl) SetDetectorType(v VisionDetectorConfigDetectorType) VisionDetectorConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionDetectorConfigDetectorTypeImpl); ok {
		s.DetectorTypeValue = impl
	}
	return s
}

func (s VisionDetectorConfigImpl) RegionCoordinates() VisionDetectorConfigRegionCoordinates {
	return s.RegionCoordinatesValue
}

func (s *VisionDetectorConfigImpl) SetRegionCoordinates(v VisionDetectorConfigRegionCoordinates) VisionDetectorConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionDetectorConfigRegionCoordinatesImpl); ok {
		s.RegionCoordinatesValue = impl
	}
	return s
}

// Identifier of the detection area.
// It is used to distinguish episodes from various regions of interest within the frame.
// For instance, it can be used with a single camera facing two entrances to count visitors independently at each entrance.
func (s VisionDetectorConfigImpl) RegionID() string {
	return s.RegionIDValue
}

// Identifier of the detection area.
// It is used to distinguish episodes from various regions of interest within the frame.
// For instance, it can be used with a single camera facing two entrances to count visitors independently at each entrance.
func (s *VisionDetectorConfigImpl) SetRegionID(v string) VisionDetectorConfig {
	if s == nil {
		return nil
	}
	s.RegionIDValue = v
	return s
}

// Name of the detection area
// Example: Zone 1
func (s VisionDetectorConfigImpl) RegionTitle() *string {
	return s.RegionTitleValue
}

// Name of the detection area
// Example: Zone 1
func (s *VisionDetectorConfigImpl) SetRegionTitle(v string) VisionDetectorConfig {
	if s == nil {
		return nil
	}
	s.RegionTitleValue = &v
	return s
}

// Runtime information about the vision process.
func (s VisionDetectorConfigImpl) Stats() VisionDetectorStats {
	return s.StatsValue
}

// Runtime information about the vision process.
func (s *VisionDetectorConfigImpl) SetStats(v VisionDetectorStats) VisionDetectorConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionDetectorStatsImpl); ok {
		s.StatsValue = impl
	}
	return s
}

// NewVisionDetectorConfigDetectorType creates a new VisionDetectorConfigDetectorType instance
func NewVisionDetectorConfigDetectorType() VisionDetectorConfigDetectorType {
	return &VisionDetectorConfigDetectorTypeImpl{}
}

// NewVisionDetectorConfigRegionCoordinates creates a new VisionDetectorConfigRegionCoordinates instance
func NewVisionDetectorConfigRegionCoordinates() VisionDetectorConfigRegionCoordinates {
	return &VisionDetectorConfigRegionCoordinatesImpl{}
}

// NewVisionDetectorStats creates a new VisionDetectorStats instance
func NewVisionDetectorStats() VisionDetectorStats {
	return &VisionDetectorStatsImpl{}
}

// Identifies analytics issues related to frames in a stream that impact episode creation
func (s VisionDetectorStatsImpl) Alerts() VisionAlerts {
	return s.AlertsValue
}

// Identifies analytics issues related to frames in a stream that impact episode creation
func (s *VisionDetectorStatsImpl) SetAlerts(v VisionAlerts) VisionDetectorStats {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionAlertsImpl); ok {
		s.AlertsValue = impl
	}
	return s
}

// The time when there was the last detection. Constant updates mean that analytics can detect objects on frames.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s VisionDetectorStatsImpl) LastDetectionAt() *UtcMs {
	return s.LastDetectionAtValue
}

// The time when there was the last detection. Constant updates mean that analytics can detect objects on frames.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637094994e+12
func (s *VisionDetectorStatsImpl) SetLastDetectionAt(v UtcMs) VisionDetectorStats {
	if s == nil {
		return nil
	}
	s.LastDetectionAtValue = &v
	return s
}

// NewVisionEpisodeContextSearch creates a new VisionEpisodeContextSearch instance
func NewVisionEpisodeContextSearch() VisionEpisodeContextSearch {
	return &VisionEpisodeContextSearchImpl{}
}

// The reason for closing the episode.
func (s VisionEpisodeContextSearchImpl) CloseReason() *EpisodeCloseReason {
	return s.CloseReasonValue
}

// The reason for closing the episode.
func (s *VisionEpisodeContextSearchImpl) SetCloseReason(v EpisodeCloseReason) VisionEpisodeContextSearch {
	if s == nil {
		return nil
	}
	s.CloseReasonValue = &v
	return s
}

// Episode emitter can decide that episode considered closed and will not grow further.
// `closed_at` MUST NOT change, it must be emitted only once.
// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
// of the episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s VisionEpisodeContextSearchImpl) ClosedAt() *UtcMs {
	return s.ClosedAtValue
}

// Episode emitter can decide that episode considered closed and will not grow further.
// `closed_at` MUST NOT change, it must be emitted only once.
// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
// of the episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *VisionEpisodeContextSearchImpl) SetClosedAt(v UtcMs) VisionEpisodeContextSearch {
	if s == nil {
		return nil
	}
	s.ClosedAtValue = &v
	return s
}

// The time when the episode appeared in the service relative to the server time.
func (s VisionEpisodeContextSearchImpl) EpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps {
	return s.EpisodeAppearanceTimestampsValue
}

// The time when the episode appeared in the service relative to the server time.
func (s *VisionEpisodeContextSearchImpl) SetEpisodeAppearanceTimestamps(v EpisodeAppearanceTimestamps) VisionEpisodeContextSearch {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*EpisodeAppearanceTimestampsImpl); ok {
		s.EpisodeAppearanceTimestampsValue = impl
	}
	return s
}

// Unique identifier of the episode. Must be created by the system that first creates this episode.
// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
// handle very long integers.
// Format: snowflake_id (snowflake_id)
// Examples: 1.722279170848854e+18
func (s VisionEpisodeContextSearchImpl) EpisodeID() SnowflakeID {
	return s.EpisodeIDValue
}

// Unique identifier of the episode. Must be created by the system that first creates this episode.
// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
// handle very long integers.
// Format: snowflake_id (snowflake_id)
// Examples: 1.722279170848854e+18
func (s *VisionEpisodeContextSearchImpl) SetEpisodeID(v SnowflakeID) VisionEpisodeContextSearch {
	if s == nil {
		return nil
	}
	s.EpisodeIDValue = v
	return s
}

// Episode matches context search text query
func (s VisionEpisodeContextSearchImpl) EpisodeType() *string {
	return s.EpisodeTypeValue
}

// Episode matches context search text query
func (s *VisionEpisodeContextSearchImpl) SetEpisodeType(v string) VisionEpisodeContextSearch {
	if s == nil {
		return nil
	}
	s.EpisodeTypeValue = &v
	return s
}

// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
// Format: base64 (base64)
func (s VisionEpisodeContextSearchImpl) FramePreview() *Base64 {
	return s.FramePreviewValue
}

// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
// Format: base64 (base64)
func (s *VisionEpisodeContextSearchImpl) SetFramePreview(v Base64) VisionEpisodeContextSearch {
	if s == nil {
		return nil
	}
	s.FramePreviewValue = &v
	return s
}

// Maximum matching score between the text query and episode.
// Examples: 0.2345
func (s VisionEpisodeContextSearchImpl) MatchScore() *float64 {
	return s.MatchScoreValue
}

// Maximum matching score between the text query and episode.
// Examples: 0.2345
func (s *VisionEpisodeContextSearchImpl) SetMatchScore(v float64) VisionEpisodeContextSearch {
	if s == nil {
		return nil
	}
	s.MatchScoreValue = &v
	return s
}

// Stream name on which this episode exists.
// Format: media_name (media_name)
func (s VisionEpisodeContextSearchImpl) Media() MediaName {
	return s.MediaValue
}

// Stream name on which this episode exists.
// Format: media_name (media_name)
func (s *VisionEpisodeContextSearchImpl) SetMedia(v MediaName) VisionEpisodeContextSearch {
	if s == nil {
		return nil
	}
	s.MediaValue = v
	return s
}

// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
// sort as by `opened_at`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s VisionEpisodeContextSearchImpl) OpenedAt() UtcMs {
	return s.OpenedAtValue
}

// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
// sort as by `opened_at`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *VisionEpisodeContextSearchImpl) SetOpenedAt(v UtcMs) VisionEpisodeContextSearch {
	if s == nil {
		return nil
	}
	s.OpenedAtValue = v
	return s
}

// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Format: base64 (base64)
func (s VisionEpisodeContextSearchImpl) Preview() *Base64 {
	return s.PreviewValue
}

// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Format: base64 (base64)
func (s *VisionEpisodeContextSearchImpl) SetPreview(v Base64) VisionEpisodeContextSearch {
	if s == nil {
		return nil
	}
	s.PreviewValue = &v
	return s
}

// The time when the preview of this episode is available.
// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
// for details.
// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s VisionEpisodeContextSearchImpl) PreviewTimestamp() *UtcMs {
	return s.PreviewTimestampValue
}

// The time when the preview of this episode is available.
// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
// for details.
// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *VisionEpisodeContextSearchImpl) SetPreviewTimestamp(v UtcMs) VisionEpisodeContextSearch {
	if s == nil {
		return nil
	}
	s.PreviewTimestampValue = &v
	return s
}

// This field can be used as indication of the fact that some system have checked and ensured that
// this episode has really started at some time, that may differ from `opened_at`.
// For example video analytics will use this field for the time when this episode was confirmed as confident.
// May be not relevant for television systems.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s VisionEpisodeContextSearchImpl) StartedAt() *UtcMs {
	return s.StartedAtValue
}

// This field can be used as indication of the fact that some system have checked and ensured that
// this episode has really started at some time, that may differ from `opened_at`.
// For example video analytics will use this field for the time when this episode was confirmed as confident.
// May be not relevant for television systems.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *VisionEpisodeContextSearchImpl) SetStartedAt(v UtcMs) VisionEpisodeContextSearch {
	if s == nil {
		return nil
	}
	s.StartedAtValue = &v
	return s
}

// The time of last change of the episode.
// System that processes episodes and can send them to other systems, MUST update this field
// on any changes in this episode.
// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
// this `updated_at` can be used as a sort key for fetching fresh updates.
// Consumer of the episodes can use `updated_at` in the following scenario:
// * fetch all exisiting episodes from the source
// * take biggest `updated_at` from this dataset, it will be T
// * ask source for all episodes with `updated_at > T`
// This algorithm can be used for fetching update stream from the source.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637098611e+12
func (s VisionEpisodeContextSearchImpl) UpdatedAt() UtcMs {
	return s.UpdatedAtValue
}

// The time of last change of the episode.
// System that processes episodes and can send them to other systems, MUST update this field
// on any changes in this episode.
// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
// this `updated_at` can be used as a sort key for fetching fresh updates.
// Consumer of the episodes can use `updated_at` in the following scenario:
// * fetch all exisiting episodes from the source
// * take biggest `updated_at` from this dataset, it will be T
// * ask source for all episodes with `updated_at > T`
// This algorithm can be used for fetching update stream from the source.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637098611e+12
func (s *VisionEpisodeContextSearchImpl) SetUpdatedAt(v UtcMs) VisionEpisodeContextSearch {
	if s == nil {
		return nil
	}
	s.UpdatedAtValue = v
	return s
}

// NewVisionEpisodeFace creates a new VisionEpisodeFace instance
func NewVisionEpisodeFace() VisionEpisodeFace {
	return &VisionEpisodeFaceImpl{}
}

// The reason for closing the episode.
func (s VisionEpisodeFaceImpl) CloseReason() *EpisodeCloseReason {
	return s.CloseReasonValue
}

// The reason for closing the episode.
func (s *VisionEpisodeFaceImpl) SetCloseReason(v EpisodeCloseReason) VisionEpisodeFace {
	if s == nil {
		return nil
	}
	s.CloseReasonValue = &v
	return s
}

// Episode emitter can decide that episode considered closed and will not grow further.
// `closed_at` MUST NOT change, it must be emitted only once.
// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
// of the episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s VisionEpisodeFaceImpl) ClosedAt() *UtcMs {
	return s.ClosedAtValue
}

// Episode emitter can decide that episode considered closed and will not grow further.
// `closed_at` MUST NOT change, it must be emitted only once.
// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
// of the episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *VisionEpisodeFaceImpl) SetClosedAt(v UtcMs) VisionEpisodeFace {
	if s == nil {
		return nil
	}
	s.ClosedAtValue = &v
	return s
}

// Detections associated with this episode
func (s VisionEpisodeFaceImpl) Detections() []VisionDetectedFace {
	if s.DetectionsValue == nil {
		return nil
	}
	result := make([]VisionDetectedFace, len(s.DetectionsValue))
	for i, item := range s.DetectionsValue {
		result[i] = item
	}
	return result
}

// Detections associated with this episode
func (s *VisionEpisodeFaceImpl) SetDetections(v []VisionDetectedFace) VisionEpisodeFace {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*VisionDetectedFaceImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*VisionDetectedFaceImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.DetectionsValue = impl
	}
	return s
}

// The time when the episode appeared in the service relative to the server time.
func (s VisionEpisodeFaceImpl) EpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps {
	return s.EpisodeAppearanceTimestampsValue
}

// The time when the episode appeared in the service relative to the server time.
func (s *VisionEpisodeFaceImpl) SetEpisodeAppearanceTimestamps(v EpisodeAppearanceTimestamps) VisionEpisodeFace {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*EpisodeAppearanceTimestampsImpl); ok {
		s.EpisodeAppearanceTimestampsValue = impl
	}
	return s
}

// Unique identifier of the episode. Must be created by the system that first creates this episode.
// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
// handle very long integers.
// Format: snowflake_id (snowflake_id)
// Examples: 1.722279170848854e+18
func (s VisionEpisodeFaceImpl) EpisodeID() SnowflakeID {
	return s.EpisodeIDValue
}

// Unique identifier of the episode. Must be created by the system that first creates this episode.
// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
// handle very long integers.
// Format: snowflake_id (snowflake_id)
// Examples: 1.722279170848854e+18
func (s *VisionEpisodeFaceImpl) SetEpisodeID(v SnowflakeID) VisionEpisodeFace {
	if s == nil {
		return nil
	}
	s.EpisodeIDValue = v
	return s
}

// Face is detected
func (s VisionEpisodeFaceImpl) EpisodeType() *string {
	return s.EpisodeTypeValue
}

// Face is detected
func (s *VisionEpisodeFaceImpl) SetEpisodeType(v string) VisionEpisodeFace {
	if s == nil {
		return nil
	}
	s.EpisodeTypeValue = &v
	return s
}

// The fingerprint of the detected face
func (s VisionEpisodeFaceImpl) Fingerprint() VisionFaceFingerprint {
	return s.FingerprintValue
}

// The fingerprint of the detected face
func (s *VisionEpisodeFaceImpl) SetFingerprint(v VisionFaceFingerprint) VisionEpisodeFace {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionFaceFingerprintImpl); ok {
		s.FingerprintValue = impl
	}
	return s
}

// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
// Format: base64 (base64)
func (s VisionEpisodeFaceImpl) FramePreview() *Base64 {
	return s.FramePreviewValue
}

// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
// Format: base64 (base64)
func (s *VisionEpisodeFaceImpl) SetFramePreview(v Base64) VisionEpisodeFace {
	if s == nil {
		return nil
	}
	s.FramePreviewValue = &v
	return s
}

// List of matched persons with similarity metric.
// Videoanalytics identification service enriches episode's data and fills this field
// with the list of persons that are similar to the face detected in this episode.
func (s VisionEpisodeFaceImpl) MatchedPersons() []VisionPersonMatch {
	if s.MatchedPersonsValue == nil {
		return nil
	}
	result := make([]VisionPersonMatch, len(s.MatchedPersonsValue))
	for i, item := range s.MatchedPersonsValue {
		result[i] = item
	}
	return result
}

// List of matched persons with similarity metric.
// Videoanalytics identification service enriches episode's data and fills this field
// with the list of persons that are similar to the face detected in this episode.
func (s *VisionEpisodeFaceImpl) SetMatchedPersons(v []VisionPersonMatch) VisionEpisodeFace {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*VisionPersonMatchImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*VisionPersonMatchImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.MatchedPersonsValue = impl
	}
	return s
}

// Stream name on which this episode exists.
// Format: media_name (media_name)
func (s VisionEpisodeFaceImpl) Media() MediaName {
	return s.MediaValue
}

// Stream name on which this episode exists.
// Format: media_name (media_name)
func (s *VisionEpisodeFaceImpl) SetMedia(v MediaName) VisionEpisodeFace {
	if s == nil {
		return nil
	}
	s.MediaValue = v
	return s
}

// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
// sort as by `opened_at`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s VisionEpisodeFaceImpl) OpenedAt() UtcMs {
	return s.OpenedAtValue
}

// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
// sort as by `opened_at`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *VisionEpisodeFaceImpl) SetOpenedAt(v UtcMs) VisionEpisodeFace {
	if s == nil {
		return nil
	}
	s.OpenedAtValue = v
	return s
}

// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Preview contains an image of person's face and has a resolution about 200 x 200 pixels with maximum size about 10 kilobytes.
// Format: base64 (base64)
func (s VisionEpisodeFaceImpl) Preview() Base64 {
	return s.PreviewValue
}

// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Preview contains an image of person's face and has a resolution about 200 x 200 pixels with maximum size about 10 kilobytes.
// Format: base64 (base64)
func (s *VisionEpisodeFaceImpl) SetPreview(v Base64) VisionEpisodeFace {
	if s == nil {
		return nil
	}
	s.PreviewValue = v
	return s
}

// The time when the preview of this episode is available.
// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
// for details.
// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s VisionEpisodeFaceImpl) PreviewTimestamp() *UtcMs {
	return s.PreviewTimestampValue
}

// The time when the preview of this episode is available.
// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
// for details.
// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *VisionEpisodeFaceImpl) SetPreviewTimestamp(v UtcMs) VisionEpisodeFace {
	if s == nil {
		return nil
	}
	s.PreviewTimestampValue = &v
	return s
}

// This field can be used as indication of the fact that some system have checked and ensured that
// this episode has really started at some time, that may differ from `opened_at`.
// For example video analytics will use this field for the time when this episode was confirmed as confident.
// May be not relevant for television systems.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s VisionEpisodeFaceImpl) StartedAt() *UtcMs {
	return s.StartedAtValue
}

// This field can be used as indication of the fact that some system have checked and ensured that
// this episode has really started at some time, that may differ from `opened_at`.
// For example video analytics will use this field for the time when this episode was confirmed as confident.
// May be not relevant for television systems.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *VisionEpisodeFaceImpl) SetStartedAt(v UtcMs) VisionEpisodeFace {
	if s == nil {
		return nil
	}
	s.StartedAtValue = &v
	return s
}

// The time of last change of the episode.
// System that processes episodes and can send them to other systems, MUST update this field
// on any changes in this episode.
// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
// this `updated_at` can be used as a sort key for fetching fresh updates.
// Consumer of the episodes can use `updated_at` in the following scenario:
// * fetch all exisiting episodes from the source
// * take biggest `updated_at` from this dataset, it will be T
// * ask source for all episodes with `updated_at > T`
// This algorithm can be used for fetching update stream from the source.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637098611e+12
func (s VisionEpisodeFaceImpl) UpdatedAt() UtcMs {
	return s.UpdatedAtValue
}

// The time of last change of the episode.
// System that processes episodes and can send them to other systems, MUST update this field
// on any changes in this episode.
// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
// this `updated_at` can be used as a sort key for fetching fresh updates.
// Consumer of the episodes can use `updated_at` in the following scenario:
// * fetch all exisiting episodes from the source
// * take biggest `updated_at` from this dataset, it will be T
// * ask source for all episodes with `updated_at > T`
// This algorithm can be used for fetching update stream from the source.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637098611e+12
func (s *VisionEpisodeFaceImpl) SetUpdatedAt(v UtcMs) VisionEpisodeFace {
	if s == nil {
		return nil
	}
	s.UpdatedAtValue = v
	return s
}

// NewVisionEpisodeHuman creates a new VisionEpisodeHuman instance
func NewVisionEpisodeHuman() VisionEpisodeHuman {
	return &VisionEpisodeHumanImpl{}
}

// The reason for closing the episode.
func (s VisionEpisodeHumanImpl) CloseReason() *EpisodeCloseReason {
	return s.CloseReasonValue
}

// The reason for closing the episode.
func (s *VisionEpisodeHumanImpl) SetCloseReason(v EpisodeCloseReason) VisionEpisodeHuman {
	if s == nil {
		return nil
	}
	s.CloseReasonValue = &v
	return s
}

// Episode emitter can decide that episode considered closed and will not grow further.
// `closed_at` MUST NOT change, it must be emitted only once.
// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
// of the episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s VisionEpisodeHumanImpl) ClosedAt() *UtcMs {
	return s.ClosedAtValue
}

// Episode emitter can decide that episode considered closed and will not grow further.
// `closed_at` MUST NOT change, it must be emitted only once.
// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
// of the episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *VisionEpisodeHumanImpl) SetClosedAt(v UtcMs) VisionEpisodeHuman {
	if s == nil {
		return nil
	}
	s.ClosedAtValue = &v
	return s
}

// Detections associated with this episode
func (s VisionEpisodeHumanImpl) Detections() []VisionDetectedObjectBase {
	if s.DetectionsValue == nil {
		return nil
	}
	result := make([]VisionDetectedObjectBase, len(s.DetectionsValue))
	for i, item := range s.DetectionsValue {
		result[i] = item
	}
	return result
}

// Detections associated with this episode
func (s *VisionEpisodeHumanImpl) SetDetections(v []VisionDetectedObjectBase) VisionEpisodeHuman {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*VisionDetectedObjectBaseImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*VisionDetectedObjectBaseImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.DetectionsValue = impl
	}
	return s
}

// The time when the episode appeared in the service relative to the server time.
func (s VisionEpisodeHumanImpl) EpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps {
	return s.EpisodeAppearanceTimestampsValue
}

// The time when the episode appeared in the service relative to the server time.
func (s *VisionEpisodeHumanImpl) SetEpisodeAppearanceTimestamps(v EpisodeAppearanceTimestamps) VisionEpisodeHuman {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*EpisodeAppearanceTimestampsImpl); ok {
		s.EpisodeAppearanceTimestampsValue = impl
	}
	return s
}

// Unique identifier of the episode. Must be created by the system that first creates this episode.
// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
// handle very long integers.
// Format: snowflake_id (snowflake_id)
// Examples: 1.722279170848854e+18
func (s VisionEpisodeHumanImpl) EpisodeID() SnowflakeID {
	return s.EpisodeIDValue
}

// Unique identifier of the episode. Must be created by the system that first creates this episode.
// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
// handle very long integers.
// Format: snowflake_id (snowflake_id)
// Examples: 1.722279170848854e+18
func (s *VisionEpisodeHumanImpl) SetEpisodeID(v SnowflakeID) VisionEpisodeHuman {
	if s == nil {
		return nil
	}
	s.EpisodeIDValue = v
	return s
}

// Human is detected
func (s VisionEpisodeHumanImpl) EpisodeType() *string {
	return s.EpisodeTypeValue
}

// Human is detected
func (s *VisionEpisodeHumanImpl) SetEpisodeType(v string) VisionEpisodeHuman {
	if s == nil {
		return nil
	}
	s.EpisodeTypeValue = &v
	return s
}

// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
// Format: base64 (base64)
func (s VisionEpisodeHumanImpl) FramePreview() *Base64 {
	return s.FramePreviewValue
}

// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
// Format: base64 (base64)
func (s *VisionEpisodeHumanImpl) SetFramePreview(v Base64) VisionEpisodeHuman {
	if s == nil {
		return nil
	}
	s.FramePreviewValue = &v
	return s
}

// Stream name on which this episode exists.
// Format: media_name (media_name)
func (s VisionEpisodeHumanImpl) Media() MediaName {
	return s.MediaValue
}

// Stream name on which this episode exists.
// Format: media_name (media_name)
func (s *VisionEpisodeHumanImpl) SetMedia(v MediaName) VisionEpisodeHuman {
	if s == nil {
		return nil
	}
	s.MediaValue = v
	return s
}

// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
// sort as by `opened_at`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s VisionEpisodeHumanImpl) OpenedAt() UtcMs {
	return s.OpenedAtValue
}

// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
// sort as by `opened_at`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *VisionEpisodeHumanImpl) SetOpenedAt(v UtcMs) VisionEpisodeHuman {
	if s == nil {
		return nil
	}
	s.OpenedAtValue = v
	return s
}

// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Format: base64 (base64)
func (s VisionEpisodeHumanImpl) Preview() *Base64 {
	return s.PreviewValue
}

// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Format: base64 (base64)
func (s *VisionEpisodeHumanImpl) SetPreview(v Base64) VisionEpisodeHuman {
	if s == nil {
		return nil
	}
	s.PreviewValue = &v
	return s
}

// The time when the preview of this episode is available.
// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
// for details.
// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s VisionEpisodeHumanImpl) PreviewTimestamp() *UtcMs {
	return s.PreviewTimestampValue
}

// The time when the preview of this episode is available.
// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
// for details.
// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *VisionEpisodeHumanImpl) SetPreviewTimestamp(v UtcMs) VisionEpisodeHuman {
	if s == nil {
		return nil
	}
	s.PreviewTimestampValue = &v
	return s
}

// This field can be used as indication of the fact that some system have checked and ensured that
// this episode has really started at some time, that may differ from `opened_at`.
// For example video analytics will use this field for the time when this episode was confirmed as confident.
// May be not relevant for television systems.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s VisionEpisodeHumanImpl) StartedAt() *UtcMs {
	return s.StartedAtValue
}

// This field can be used as indication of the fact that some system have checked and ensured that
// this episode has really started at some time, that may differ from `opened_at`.
// For example video analytics will use this field for the time when this episode was confirmed as confident.
// May be not relevant for television systems.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *VisionEpisodeHumanImpl) SetStartedAt(v UtcMs) VisionEpisodeHuman {
	if s == nil {
		return nil
	}
	s.StartedAtValue = &v
	return s
}

// The time of last change of the episode.
// System that processes episodes and can send them to other systems, MUST update this field
// on any changes in this episode.
// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
// this `updated_at` can be used as a sort key for fetching fresh updates.
// Consumer of the episodes can use `updated_at` in the following scenario:
// * fetch all exisiting episodes from the source
// * take biggest `updated_at` from this dataset, it will be T
// * ask source for all episodes with `updated_at > T`
// This algorithm can be used for fetching update stream from the source.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637098611e+12
func (s VisionEpisodeHumanImpl) UpdatedAt() UtcMs {
	return s.UpdatedAtValue
}

// The time of last change of the episode.
// System that processes episodes and can send them to other systems, MUST update this field
// on any changes in this episode.
// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
// this `updated_at` can be used as a sort key for fetching fresh updates.
// Consumer of the episodes can use `updated_at` in the following scenario:
// * fetch all exisiting episodes from the source
// * take biggest `updated_at` from this dataset, it will be T
// * ask source for all episodes with `updated_at > T`
// This algorithm can be used for fetching update stream from the source.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637098611e+12
func (s *VisionEpisodeHumanImpl) SetUpdatedAt(v UtcMs) VisionEpisodeHuman {
	if s == nil {
		return nil
	}
	s.UpdatedAtValue = v
	return s
}

// NewVisionEpisodeQrCode creates a new VisionEpisodeQrCode instance
func NewVisionEpisodeQrCode() VisionEpisodeQrCode {
	return &VisionEpisodeQrCodeImpl{}
}

// The reason for closing the episode.
func (s VisionEpisodeQrCodeImpl) CloseReason() *EpisodeCloseReason {
	return s.CloseReasonValue
}

// The reason for closing the episode.
func (s *VisionEpisodeQrCodeImpl) SetCloseReason(v EpisodeCloseReason) VisionEpisodeQrCode {
	if s == nil {
		return nil
	}
	s.CloseReasonValue = &v
	return s
}

// Episode emitter can decide that episode considered closed and will not grow further.
// `closed_at` MUST NOT change, it must be emitted only once.
// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
// of the episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s VisionEpisodeQrCodeImpl) ClosedAt() *UtcMs {
	return s.ClosedAtValue
}

// Episode emitter can decide that episode considered closed and will not grow further.
// `closed_at` MUST NOT change, it must be emitted only once.
// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
// of the episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *VisionEpisodeQrCodeImpl) SetClosedAt(v UtcMs) VisionEpisodeQrCode {
	if s == nil {
		return nil
	}
	s.ClosedAtValue = &v
	return s
}

// The time when the episode appeared in the service relative to the server time.
func (s VisionEpisodeQrCodeImpl) EpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps {
	return s.EpisodeAppearanceTimestampsValue
}

// The time when the episode appeared in the service relative to the server time.
func (s *VisionEpisodeQrCodeImpl) SetEpisodeAppearanceTimestamps(v EpisodeAppearanceTimestamps) VisionEpisodeQrCode {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*EpisodeAppearanceTimestampsImpl); ok {
		s.EpisodeAppearanceTimestampsValue = impl
	}
	return s
}

// Unique identifier of the episode. Must be created by the system that first creates this episode.
// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
// handle very long integers.
// Format: snowflake_id (snowflake_id)
// Examples: 1.722279170848854e+18
func (s VisionEpisodeQrCodeImpl) EpisodeID() SnowflakeID {
	return s.EpisodeIDValue
}

// Unique identifier of the episode. Must be created by the system that first creates this episode.
// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
// handle very long integers.
// Format: snowflake_id (snowflake_id)
// Examples: 1.722279170848854e+18
func (s *VisionEpisodeQrCodeImpl) SetEpisodeID(v SnowflakeID) VisionEpisodeQrCode {
	if s == nil {
		return nil
	}
	s.EpisodeIDValue = v
	return s
}

// QR-code is detected
func (s VisionEpisodeQrCodeImpl) EpisodeType() *string {
	return s.EpisodeTypeValue
}

// QR-code is detected
func (s *VisionEpisodeQrCodeImpl) SetEpisodeType(v string) VisionEpisodeQrCode {
	if s == nil {
		return nil
	}
	s.EpisodeTypeValue = &v
	return s
}

// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
// Format: base64 (base64)
func (s VisionEpisodeQrCodeImpl) FramePreview() *Base64 {
	return s.FramePreviewValue
}

// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
// Format: base64 (base64)
func (s *VisionEpisodeQrCodeImpl) SetFramePreview(v Base64) VisionEpisodeQrCode {
	if s == nil {
		return nil
	}
	s.FramePreviewValue = &v
	return s
}

// Stream name on which this episode exists.
// Format: media_name (media_name)
func (s VisionEpisodeQrCodeImpl) Media() MediaName {
	return s.MediaValue
}

// Stream name on which this episode exists.
// Format: media_name (media_name)
func (s *VisionEpisodeQrCodeImpl) SetMedia(v MediaName) VisionEpisodeQrCode {
	if s == nil {
		return nil
	}
	s.MediaValue = v
	return s
}

// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
// sort as by `opened_at`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s VisionEpisodeQrCodeImpl) OpenedAt() UtcMs {
	return s.OpenedAtValue
}

// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
// sort as by `opened_at`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *VisionEpisodeQrCodeImpl) SetOpenedAt(v UtcMs) VisionEpisodeQrCode {
	if s == nil {
		return nil
	}
	s.OpenedAtValue = v
	return s
}

// Raw data extracted from QR-code
// Example: WIFI:T:WPA;S:MyOfficeWiFi;P:Mypassword;H:;
func (s VisionEpisodeQrCodeImpl) Payload() *string {
	return s.PayloadValue
}

// Raw data extracted from QR-code
// Example: WIFI:T:WPA;S:MyOfficeWiFi;P:Mypassword;H:;
func (s *VisionEpisodeQrCodeImpl) SetPayload(v string) VisionEpisodeQrCode {
	if s == nil {
		return nil
	}
	s.PayloadValue = &v
	return s
}

// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Format: base64 (base64)
func (s VisionEpisodeQrCodeImpl) Preview() *Base64 {
	return s.PreviewValue
}

// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Format: base64 (base64)
func (s *VisionEpisodeQrCodeImpl) SetPreview(v Base64) VisionEpisodeQrCode {
	if s == nil {
		return nil
	}
	s.PreviewValue = &v
	return s
}

// The time when the preview of this episode is available.
// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
// for details.
// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s VisionEpisodeQrCodeImpl) PreviewTimestamp() *UtcMs {
	return s.PreviewTimestampValue
}

// The time when the preview of this episode is available.
// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
// for details.
// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *VisionEpisodeQrCodeImpl) SetPreviewTimestamp(v UtcMs) VisionEpisodeQrCode {
	if s == nil {
		return nil
	}
	s.PreviewTimestampValue = &v
	return s
}

// This field can be used as indication of the fact that some system have checked and ensured that
// this episode has really started at some time, that may differ from `opened_at`.
// For example video analytics will use this field for the time when this episode was confirmed as confident.
// May be not relevant for television systems.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s VisionEpisodeQrCodeImpl) StartedAt() *UtcMs {
	return s.StartedAtValue
}

// This field can be used as indication of the fact that some system have checked and ensured that
// this episode has really started at some time, that may differ from `opened_at`.
// For example video analytics will use this field for the time when this episode was confirmed as confident.
// May be not relevant for television systems.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *VisionEpisodeQrCodeImpl) SetStartedAt(v UtcMs) VisionEpisodeQrCode {
	if s == nil {
		return nil
	}
	s.StartedAtValue = &v
	return s
}

// The time of last change of the episode.
// System that processes episodes and can send them to other systems, MUST update this field
// on any changes in this episode.
// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
// this `updated_at` can be used as a sort key for fetching fresh updates.
// Consumer of the episodes can use `updated_at` in the following scenario:
// * fetch all exisiting episodes from the source
// * take biggest `updated_at` from this dataset, it will be T
// * ask source for all episodes with `updated_at > T`
// This algorithm can be used for fetching update stream from the source.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637098611e+12
func (s VisionEpisodeQrCodeImpl) UpdatedAt() UtcMs {
	return s.UpdatedAtValue
}

// The time of last change of the episode.
// System that processes episodes and can send them to other systems, MUST update this field
// on any changes in this episode.
// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
// this `updated_at` can be used as a sort key for fetching fresh updates.
// Consumer of the episodes can use `updated_at` in the following scenario:
// * fetch all exisiting episodes from the source
// * take biggest `updated_at` from this dataset, it will be T
// * ask source for all episodes with `updated_at > T`
// This algorithm can be used for fetching update stream from the source.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637098611e+12
func (s *VisionEpisodeQrCodeImpl) SetUpdatedAt(v UtcMs) VisionEpisodeQrCode {
	if s == nil {
		return nil
	}
	s.UpdatedAtValue = v
	return s
}

// NewVisionEpisodeVehicle creates a new VisionEpisodeVehicle instance
func NewVisionEpisodeVehicle() VisionEpisodeVehicle {
	return &VisionEpisodeVehicleImpl{}
}

// The reason for closing the episode.
func (s VisionEpisodeVehicleImpl) CloseReason() *EpisodeCloseReason {
	return s.CloseReasonValue
}

// The reason for closing the episode.
func (s *VisionEpisodeVehicleImpl) SetCloseReason(v EpisodeCloseReason) VisionEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.CloseReasonValue = &v
	return s
}

// Episode emitter can decide that episode considered closed and will not grow further.
// `closed_at` MUST NOT change, it must be emitted only once.
// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
// of the episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s VisionEpisodeVehicleImpl) ClosedAt() *UtcMs {
	return s.ClosedAtValue
}

// Episode emitter can decide that episode considered closed and will not grow further.
// `closed_at` MUST NOT change, it must be emitted only once.
// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
// of the episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *VisionEpisodeVehicleImpl) SetClosedAt(v UtcMs) VisionEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.ClosedAtValue = &v
	return s
}

// Detections associated with this episode
func (s VisionEpisodeVehicleImpl) Detections() []any {
	return s.DetectionsValue
}

// Detections associated with this episode
func (s *VisionEpisodeVehicleImpl) SetDetections(v []any) VisionEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.DetectionsValue = v
	return s
}

// The time when the episode appeared in the service relative to the server time.
func (s VisionEpisodeVehicleImpl) EpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps {
	return s.EpisodeAppearanceTimestampsValue
}

// The time when the episode appeared in the service relative to the server time.
func (s *VisionEpisodeVehicleImpl) SetEpisodeAppearanceTimestamps(v EpisodeAppearanceTimestamps) VisionEpisodeVehicle {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*EpisodeAppearanceTimestampsImpl); ok {
		s.EpisodeAppearanceTimestampsValue = impl
	}
	return s
}

// Unique identifier of the episode. Must be created by the system that first creates this episode.
// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
// handle very long integers.
// Format: snowflake_id (snowflake_id)
// Examples: 1.722279170848854e+18
func (s VisionEpisodeVehicleImpl) EpisodeID() SnowflakeID {
	return s.EpisodeIDValue
}

// Unique identifier of the episode. Must be created by the system that first creates this episode.
// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
// handle very long integers.
// Format: snowflake_id (snowflake_id)
// Examples: 1.722279170848854e+18
func (s *VisionEpisodeVehicleImpl) SetEpisodeID(v SnowflakeID) VisionEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.EpisodeIDValue = v
	return s
}

// Vehicle is detected
func (s VisionEpisodeVehicleImpl) EpisodeType() *string {
	return s.EpisodeTypeValue
}

// Vehicle is detected
func (s *VisionEpisodeVehicleImpl) SetEpisodeType(v string) VisionEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.EpisodeTypeValue = &v
	return s
}

// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
// Format: base64 (base64)
func (s VisionEpisodeVehicleImpl) FramePreview() *Base64 {
	return s.FramePreviewValue
}

// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
// Format: base64 (base64)
func (s *VisionEpisodeVehicleImpl) SetFramePreview(v Base64) VisionEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.FramePreviewValue = &v
	return s
}

// Indicates if no license plate is detected on this vehicle
func (s VisionEpisodeVehicleImpl) LicensePlateMissing() *bool {
	return s.LicensePlateMissingValue
}

// Indicates if no license plate is detected on this vehicle
func (s *VisionEpisodeVehicleImpl) SetLicensePlateMissing(v bool) VisionEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.LicensePlateMissingValue = &v
	return s
}

// Recognized vehicle's license plate number
func (s VisionEpisodeVehicleImpl) LicensePlateText() *string {
	return s.LicensePlateTextValue
}

// Recognized vehicle's license plate number
func (s *VisionEpisodeVehicleImpl) SetLicensePlateText(v string) VisionEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.LicensePlateTextValue = &v
	return s
}

// Stream name on which this episode exists.
// Format: media_name (media_name)
func (s VisionEpisodeVehicleImpl) Media() MediaName {
	return s.MediaValue
}

// Stream name on which this episode exists.
// Format: media_name (media_name)
func (s *VisionEpisodeVehicleImpl) SetMedia(v MediaName) VisionEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.MediaValue = v
	return s
}

// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
// sort as by `opened_at`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s VisionEpisodeVehicleImpl) OpenedAt() UtcMs {
	return s.OpenedAtValue
}

// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
// sort as by `opened_at`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *VisionEpisodeVehicleImpl) SetOpenedAt(v UtcMs) VisionEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.OpenedAtValue = v
	return s
}

// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Preview contains an image of vehicle's license plate and has a resolution about 160 x 64 pixels with maximum size about 10 kilobytes.
// Format: base64 (base64)
func (s VisionEpisodeVehicleImpl) Preview() Base64 {
	return s.PreviewValue
}

// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Preview contains an image of vehicle's license plate and has a resolution about 160 x 64 pixels with maximum size about 10 kilobytes.
// Format: base64 (base64)
func (s *VisionEpisodeVehicleImpl) SetPreview(v Base64) VisionEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.PreviewValue = v
	return s
}

// The time when the preview of this episode is available.
// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
// for details.
// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s VisionEpisodeVehicleImpl) PreviewTimestamp() *UtcMs {
	return s.PreviewTimestampValue
}

// The time when the preview of this episode is available.
// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
// for details.
// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *VisionEpisodeVehicleImpl) SetPreviewTimestamp(v UtcMs) VisionEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.PreviewTimestampValue = &v
	return s
}

// This field can be used as indication of the fact that some system have checked and ensured that
// this episode has really started at some time, that may differ from `opened_at`.
// For example video analytics will use this field for the time when this episode was confirmed as confident.
// May be not relevant for television systems.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s VisionEpisodeVehicleImpl) StartedAt() *UtcMs {
	return s.StartedAtValue
}

// This field can be used as indication of the fact that some system have checked and ensured that
// this episode has really started at some time, that may differ from `opened_at`.
// For example video analytics will use this field for the time when this episode was confirmed as confident.
// May be not relevant for television systems.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *VisionEpisodeVehicleImpl) SetStartedAt(v UtcMs) VisionEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.StartedAtValue = &v
	return s
}

// The time of last change of the episode.
// System that processes episodes and can send them to other systems, MUST update this field
// on any changes in this episode.
// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
// this `updated_at` can be used as a sort key for fetching fresh updates.
// Consumer of the episodes can use `updated_at` in the following scenario:
// * fetch all exisiting episodes from the source
// * take biggest `updated_at` from this dataset, it will be T
// * ask source for all episodes with `updated_at > T`
// This algorithm can be used for fetching update stream from the source.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637098611e+12
func (s VisionEpisodeVehicleImpl) UpdatedAt() UtcMs {
	return s.UpdatedAtValue
}

// The time of last change of the episode.
// System that processes episodes and can send them to other systems, MUST update this field
// on any changes in this episode.
// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
// this `updated_at` can be used as a sort key for fetching fresh updates.
// Consumer of the episodes can use `updated_at` in the following scenario:
// * fetch all exisiting episodes from the source
// * take biggest `updated_at` from this dataset, it will be T
// * ask source for all episodes with `updated_at > T`
// This algorithm can be used for fetching update stream from the source.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637098611e+12
func (s *VisionEpisodeVehicleImpl) SetUpdatedAt(v UtcMs) VisionEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.UpdatedAtValue = v
	return s
}

// Emergency type of the vehicle.
func (s VisionEpisodeVehicleImpl) VehicleEmergencySubtype() *VisionVehicleEmergencySubtype {
	return s.VehicleEmergencySubtypeValue
}

// Emergency type of the vehicle.
func (s *VisionEpisodeVehicleImpl) SetVehicleEmergencySubtype(v VisionVehicleEmergencySubtype) VisionEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.VehicleEmergencySubtypeValue = &v
	return s
}

// Shows from which side the vehicle was detected.
func (s VisionEpisodeVehicleImpl) VehicleFacingSide() *VisionVehicleFacingSide {
	return s.VehicleFacingSideValue
}

// Shows from which side the vehicle was detected.
func (s *VisionEpisodeVehicleImpl) SetVehicleFacingSide(v VisionVehicleFacingSide) VisionEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.VehicleFacingSideValue = &v
	return s
}

// The purpose of the vehicle, e.g. emergency or regular.
func (s VisionEpisodeVehicleImpl) VehiclePurpose() *VisionVehiclePurpose {
	return s.VehiclePurposeValue
}

// The purpose of the vehicle, e.g. emergency or regular.
func (s *VisionEpisodeVehicleImpl) SetVehiclePurpose(v VisionVehiclePurpose) VisionEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.VehiclePurposeValue = &v
	return s
}

// NewVisionFaceAttributes creates a new VisionFaceAttributes instance
func NewVisionFaceAttributes() VisionFaceAttributes {
	return &VisionFaceAttributesImpl{}
}

// The fingerprint of the detected face
func (s VisionFaceAttributesImpl) Fingerprint() VisionFaceFingerprint {
	return s.FingerprintValue
}

// The fingerprint of the detected face
func (s *VisionFaceAttributesImpl) SetFingerprint(v VisionFaceFingerprint) VisionFaceAttributes {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionFaceFingerprintImpl); ok {
		s.FingerprintValue = impl
	}
	return s
}

// NewVisionFaceFingerprint creates a new VisionFaceFingerprint instance
func NewVisionFaceFingerprint() VisionFaceFingerprint {
	return &VisionFaceFingerprintImpl{}
}

// Base64 encoded representation of the fingerprint
// Format: base64 (base64)
func (s VisionFaceFingerprintImpl) Data() Base64 {
	return s.DataValue
}

// Base64 encoded representation of the fingerprint
// Format: base64 (base64)
func (s *VisionFaceFingerprintImpl) SetData(v Base64) VisionFaceFingerprint {
	if s == nil {
		return nil
	}
	s.DataValue = v
	return s
}

// Version identifier of the fingerprint's data. The version is assigned automatically.
// Fingerprints of different versions cannot be compared to each other.
// Examples: aabbccdd, c6ba4246
func (s VisionFaceFingerprintImpl) Version() string {
	return s.VersionValue
}

// Version identifier of the fingerprint's data. The version is assigned automatically.
// Fingerprints of different versions cannot be compared to each other.
// Examples: aabbccdd, c6ba4246
func (s *VisionFaceFingerprintImpl) SetVersion(v string) VisionFaceFingerprint {
	if s == nil {
		return nil
	}
	s.VersionValue = v
	return s
}

// NewVisionImageAttributes creates a new VisionImageAttributes instance
func NewVisionImageAttributes() VisionImageAttributes {
	return &VisionImageAttributesImpl{}
}

// Base64-encoded image data
// Format: base64 (base64)
func (s VisionImageAttributesImpl) Data() Base64 {
	return s.DataValue
}

// Base64-encoded image data
// Format: base64 (base64)
func (s *VisionImageAttributesImpl) SetData(v Base64) VisionImageAttributes {
	if s == nil {
		return nil
	}
	s.DataValue = v
	return s
}

// MIME type of the image
func (s VisionImageAttributesImpl) MimeType() *VisionImageMimetype {
	return s.MimeTypeValue
}

// MIME type of the image
func (s *VisionImageAttributesImpl) SetMimeType(v VisionImageMimetype) VisionImageAttributes {
	if s == nil {
		return nil
	}
	s.MimeTypeValue = &v
	return s
}

// Checksum of this image
// Format: hexbinary (hexbinary)
func (s VisionImageAttributesImpl) Sha256() *Hexbinary {
	return s.Sha256Value
}

// Checksum of this image
// Format: hexbinary (hexbinary)
func (s *VisionImageAttributesImpl) SetSha256(v Hexbinary) VisionImageAttributes {
	if s == nil {
		return nil
	}
	s.Sha256Value = &v
	return s
}

// NewVisionLicensePlateAttributes creates a new VisionLicensePlateAttributes instance
func NewVisionLicensePlateAttributes() VisionLicensePlateAttributes {
	return &VisionLicensePlateAttributesImpl{}
}

// Shows from which side the vehicle was detected.
func (s VisionLicensePlateAttributesImpl) FacingSide() *VisionVehicleFacingSide {
	return s.FacingSideValue
}

// Shows from which side the vehicle was detected.
func (s *VisionLicensePlateAttributesImpl) SetFacingSide(v VisionVehicleFacingSide) VisionLicensePlateAttributes {
	if s == nil {
		return nil
	}
	s.FacingSideValue = &v
	return s
}

// Recognized vehicle's license plate number
func (s VisionLicensePlateAttributesImpl) PlateText() *string {
	return s.PlateTextValue
}

// Recognized vehicle's license plate number
func (s *VisionLicensePlateAttributesImpl) SetPlateText(v string) VisionLicensePlateAttributes {
	if s == nil {
		return nil
	}
	s.PlateTextValue = &v
	return s
}

// NewVisionPerson creates a new VisionPerson instance
func NewVisionPerson() VisionPerson {
	return &VisionPersonImpl{}
}

// When this person was marked as deleted
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637095014573e+12
func (s VisionPersonImpl) DeletedAt() *UtcMs {
	return s.DeletedAtValue
}

// When this person was marked as deleted
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637095014573e+12
func (s *VisionPersonImpl) SetDeletedAt(v UtcMs) VisionPerson {
	if s == nil {
		return nil
	}
	s.DeletedAtValue = &v
	return s
}

// Identifier of the person in the external system.
// Use it when supplying the recognition results further into the external system
// (e.g. for access level check) if the person identifiers in the external system
// are different from the ones in Flussonic Identification database.
// This field may contain `null` when video analytics detects a new person
// which explicitly has no association in the external system (i.e. if `originator=identification_service`).
// Examples: dedcc8e8
func (s VisionPersonImpl) ExternalID() *string {
	return s.ExternalIDValue
}

// Identifier of the person in the external system.
// Use it when supplying the recognition results further into the external system
// (e.g. for access level check) if the person identifiers in the external system
// are different from the ones in Flussonic Identification database.
// This field may contain `null` when video analytics detects a new person
// which explicitly has no association in the external system (i.e. if `originator=identification_service`).
// Examples: dedcc8e8
func (s *VisionPersonImpl) SetExternalID(v string) VisionPerson {
	if s == nil {
		return nil
	}
	s.ExternalIDValue = &v
	return s
}

// When this person was first seen
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637034282845e+12
func (s VisionPersonImpl) FirstSeenAt() *UtcMs {
	return s.FirstSeenAtValue
}

// When this person was first seen
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637034282845e+12
func (s *VisionPersonImpl) SetFirstSeenAt(v UtcMs) VisionPerson {
	if s == nil {
		return nil
	}
	s.FirstSeenAtValue = &v
	return s
}

// When this person was last seen
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637095014573e+12
func (s VisionPersonImpl) LastSeenAt() *UtcMs {
	return s.LastSeenAtValue
}

// When this person was last seen
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637095014573e+12
func (s *VisionPersonImpl) SetLastSeenAt(v UtcMs) VisionPerson {
	if s == nil {
		return nil
	}
	s.LastSeenAtValue = &v
	return s
}

// The name of the person filled in manually or automatically if not recognized
// Examples: John Doe, Unknown ABC
func (s VisionPersonImpl) Name() *string {
	return s.NameValue
}

// The name of the person filled in manually or automatically if not recognized
// Examples: John Doe, Unknown ABC
func (s *VisionPersonImpl) SetName(v string) VisionPerson {
	if s == nil {
		return nil
	}
	s.NameValue = &v
	return s
}

// Organization information.
func (s VisionPersonImpl) Organization() OrganizationBase {
	return s.OrganizationValue
}

// Organization information.
func (s *VisionPersonImpl) SetOrganization(v OrganizationBase) VisionPerson {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*OrganizationBaseImpl); ok {
		s.OrganizationValue = impl
	}
	return s
}

// Indicates the way this person was created:
// manually via an api or automatically in the identification service.
func (s VisionPersonImpl) Originator() VisionPersonOriginator {
	return s.OriginatorValue
}

// Indicates the way this person was created:
// manually via an api or automatically in the identification service.
func (s *VisionPersonImpl) SetOriginator(v VisionPersonOriginator) VisionPerson {
	if s == nil {
		return nil
	}
	s.OriginatorValue = v
	return s
}

// Identifier of the person
// Format: snowflake_id (snowflake_id)
// Examples: 7.036001172460667e+18
func (s VisionPersonImpl) PersonID() SnowflakeID {
	return s.PersonIDValue
}

// Identifier of the person
// Format: snowflake_id (snowflake_id)
// Examples: 7.036001172460667e+18
func (s *VisionPersonImpl) SetPersonID(v SnowflakeID) VisionPerson {
	if s == nil {
		return nil
	}
	s.PersonIDValue = v
	return s
}

// Person list details
func (s VisionPersonImpl) PersonList() VisionPersonPersonList {
	return s.PersonListValue
}

// Person list details
func (s *VisionPersonImpl) SetPersonList(v VisionPersonPersonList) VisionPerson {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionPersonPersonListImpl); ok {
		s.PersonListValue = impl
	}
	return s
}

// Person's photos. External system uploads images
// which are being processed by videoanalytics
// to get digital fingerprint of the person
func (s VisionPersonImpl) Photos() []VisionImageAttributes {
	if s.PhotosValue == nil {
		return nil
	}
	result := make([]VisionImageAttributes, len(s.PhotosValue))
	for i, item := range s.PhotosValue {
		result[i] = item
	}
	return result
}

// Person's photos. External system uploads images
// which are being processed by videoanalytics
// to get digital fingerprint of the person
func (s *VisionPersonImpl) SetPhotos(v []VisionImageAttributes) VisionPerson {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*VisionImageAttributesImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*VisionImageAttributesImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.PhotosValue = impl
	}
	return s
}

// When this person was last updated
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637034282845e+12
func (s VisionPersonImpl) UpdatedAt() UtcMs {
	return s.UpdatedAtValue
}

// When this person was last updated
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.637034282845e+12
func (s *VisionPersonImpl) SetUpdatedAt(v UtcMs) VisionPerson {
	if s == nil {
		return nil
	}
	s.UpdatedAtValue = v
	return s
}

// NewVisionPersonMatch creates a new VisionPersonMatch instance
func NewVisionPersonMatch() VisionPersonMatch {
	return &VisionPersonMatchImpl{}
}

// Score of the match with person. 1.0 means absolute match
func (s VisionPersonMatchImpl) MatchScore() float64 {
	return s.MatchScoreValue
}

// Score of the match with person. 1.0 means absolute match
func (s *VisionPersonMatchImpl) SetMatchScore(v float64) VisionPersonMatch {
	if s == nil {
		return nil
	}
	s.MatchScoreValue = v
	return s
}

// Matched person
func (s VisionPersonMatchImpl) Person() VisionPerson {
	return s.PersonValue
}

// Matched person
func (s *VisionPersonMatchImpl) SetPerson(v VisionPerson) VisionPersonMatch {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionPersonImpl); ok {
		s.PersonValue = impl
	}
	return s
}

// NewVisionPersonPersonList creates a new VisionPersonPersonList instance
func NewVisionPersonPersonList() VisionPersonPersonList {
	return &VisionPersonPersonListImpl{}
}

// Person list identifier
// Example: 3
func (s VisionPersonPersonListImpl) ID() *int {
	return s.IDValue
}

// Person list identifier
// Example: 3
func (s *VisionPersonPersonListImpl) SetID(v int) VisionPersonPersonList {
	if s == nil {
		return nil
	}
	s.IDValue = &v
	return s
}

// Person list name
// Example: List 1
func (s VisionPersonPersonListImpl) Name() *string {
	return s.NameValue
}

// Person list name
// Example: List 1
func (s *VisionPersonPersonListImpl) SetName(v string) VisionPersonPersonList {
	if s == nil {
		return nil
	}
	s.NameValue = &v
	return s
}

// NewVisionPoint creates a new VisionPoint instance
func NewVisionPoint() VisionPoint {
	return &VisionPointImpl{}
}

// X coordinate. Fraction of full frame width
// Examples: 0.54, 0.78
func (s VisionPointImpl) X() float64 {
	return s.XValue
}

// X coordinate. Fraction of full frame width
// Examples: 0.54, 0.78
func (s *VisionPointImpl) SetX(v float64) VisionPoint {
	if s == nil {
		return nil
	}
	s.XValue = v
	return s
}

// Y coordinate. Fraction of full frame height
// Examples: 0.12, 0.38
func (s VisionPointImpl) Y() float64 {
	return s.YValue
}

// Y coordinate. Fraction of full frame height
// Examples: 0.12, 0.38
func (s *VisionPointImpl) SetY(v float64) VisionPoint {
	if s == nil {
		return nil
	}
	s.YValue = v
	return s
}

// NewVisionSpec creates a new VisionSpec instance
func NewVisionSpec() VisionSpec {
	return &VisionSpecImpl{}
}

// The algorithm used for video analytics.
// Example: faces
func (s VisionSpecImpl) Alg() *VisionSpecAlg {
	return s.AlgValue
}

// The algorithm used for video analytics.
// Example: faces
func (s *VisionSpecImpl) SetAlg(v VisionSpecAlg) VisionSpec {
	if s == nil {
		return nil
	}
	s.AlgValue = &v
	return s
}

// This parameter allows you to select specific polygonal area(s) for detection.
// By default, it is empty, and the recognition system searches over the entire camera field of view.
// Each area is specified as a sequence of comma-separated coordinates of vertices of the polygon: `x0,y0,x1,y1,x2,y2,...`.
// The vertices are specified in a counter-clockwise direction. Multiple areas are separated by `:`.
func (s VisionSpecImpl) Areas() *string {
	return s.AreasValue
}

// This parameter allows you to select specific polygonal area(s) for detection.
// By default, it is empty, and the recognition system searches over the entire camera field of view.
// Each area is specified as a sequence of comma-separated coordinates of vertices of the polygon: `x0,y0,x1,y1,x2,y2,...`.
// The vertices are specified in a counter-clockwise direction. Multiple areas are separated by `:`.
func (s *VisionSpecImpl) SetAreas(v string) VisionSpec {
	if s == nil {
		return nil
	}
	s.AreasValue = &v
	return s
}

// Configuration of videoanalytics modules.
// This configuration supersedes `alg` and `areas` parameters.
// If this field is specified, values of `alg` and `areas` fields are being ignored.
func (s VisionSpecImpl) Detectors() []VisionDetectorConfig {
	if s.DetectorsValue == nil {
		return nil
	}
	result := make([]VisionDetectorConfig, len(s.DetectorsValue))
	for i, item := range s.DetectorsValue {
		result[i] = item
	}
	return result
}

// Configuration of videoanalytics modules.
// This configuration supersedes `alg` and `areas` parameters.
// If this field is specified, values of `alg` and `areas` fields are being ignored.
func (s *VisionSpecImpl) SetDetectors(v []VisionDetectorConfig) VisionSpec {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*VisionDetectorConfigImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*VisionDetectorConfigImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.DetectorsValue = impl
	}
	return s
}

// NewVisionSpecPresets creates a new VisionSpecPresets instance
func NewVisionSpecPresets() VisionSpecPresets {
	return &VisionSpecPresetsImpl{}
}

// The algorithm used for video analytics.
// Example: faces
func (s VisionSpecPresetsImpl) Alg() *VisionSpecPresetsAlg {
	return s.AlgValue
}

// The algorithm used for video analytics.
// Example: faces
func (s *VisionSpecPresetsImpl) SetAlg(v VisionSpecPresetsAlg) VisionSpecPresets {
	if s == nil {
		return nil
	}
	s.AlgValue = &v
	return s
}

// NewVisionVehicleAttributes creates a new VisionVehicleAttributes instance
func NewVisionVehicleAttributes() VisionVehicleAttributes {
	return &VisionVehicleAttributesImpl{}
}

// Indicates if no license plate is detected on this vehicle
func (s VisionVehicleAttributesImpl) LicensePlateMissing() *bool {
	return s.LicensePlateMissingValue
}

// Indicates if no license plate is detected on this vehicle
func (s *VisionVehicleAttributesImpl) SetLicensePlateMissing(v bool) VisionVehicleAttributes {
	if s == nil {
		return nil
	}
	s.LicensePlateMissingValue = &v
	return s
}

// The purpose of the vehicle, e.g. emergency or regular.
func (s VisionVehicleAttributesImpl) Purpose() *VisionVehiclePurpose {
	return s.PurposeValue
}

// The purpose of the vehicle, e.g. emergency or regular.
func (s *VisionVehicleAttributesImpl) SetPurpose(v VisionVehiclePurpose) VisionVehicleAttributes {
	if s == nil {
		return nil
	}
	s.PurposeValue = &v
	return s
}

// NewWatcherEpisode creates a new WatcherEpisode instance
func NewWatcherEpisode() WatcherEpisode {
	return &WatcherEpisodeImpl{}
}

// The reason for closing the episode.
func (s WatcherEpisodeImpl) CloseReason() *EpisodeCloseReason {
	return s.CloseReasonValue
}

// The reason for closing the episode.
func (s *WatcherEpisodeImpl) SetCloseReason(v EpisodeCloseReason) WatcherEpisode {
	if s == nil {
		return nil
	}
	s.CloseReasonValue = &v
	return s
}

// Episode emitter can decide that episode considered closed and will not grow further.
// `closed_at` MUST NOT change, it must be emitted only once.
// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
// of the episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s WatcherEpisodeImpl) ClosedAt() *UtcMs {
	return s.ClosedAtValue
}

// Episode emitter can decide that episode considered closed and will not grow further.
// `closed_at` MUST NOT change, it must be emitted only once.
// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
// of the episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *WatcherEpisodeImpl) SetClosedAt(v UtcMs) WatcherEpisode {
	if s == nil {
		return nil
	}
	s.ClosedAtValue = &v
	return s
}

// Optional description of the episode. Can be used to provide additional context or details about the episode.
// Example: Person detected at the main entrance, stayed for 30 seconds
func (s WatcherEpisodeImpl) Description() *string {
	return s.DescriptionValue
}

// Optional description of the episode. Can be used to provide additional context or details about the episode.
// Example: Person detected at the main entrance, stayed for 30 seconds
func (s *WatcherEpisodeImpl) SetDescription(v string) WatcherEpisode {
	if s == nil {
		return nil
	}
	s.DescriptionValue = &v
	return s
}

// Detections associated with this episode
func (s WatcherEpisodeImpl) Detections() any {
	return s.DetectionsValue
}

// Detections associated with this episode
func (s *WatcherEpisodeImpl) SetDetections(v any) WatcherEpisode {
	if s == nil {
		return nil
	}
	s.DetectionsValue = v
	return s
}

// Duration of the episode in milliseconds.
// Format: milliseconds (milliseconds)
// Example: 10500
func (s WatcherEpisodeImpl) Duration() *Milliseconds {
	return s.DurationValue
}

// Duration of the episode in milliseconds.
// Format: milliseconds (milliseconds)
// Example: 10500
func (s *WatcherEpisodeImpl) SetDuration(v Milliseconds) WatcherEpisode {
	if s == nil {
		return nil
	}
	s.DurationValue = &v
	return s
}

// The time when the episode appeared in the service relative to the server time.
func (s WatcherEpisodeImpl) EpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps {
	return s.EpisodeAppearanceTimestampsValue
}

// The time when the episode appeared in the service relative to the server time.
func (s *WatcherEpisodeImpl) SetEpisodeAppearanceTimestamps(v EpisodeAppearanceTimestamps) WatcherEpisode {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*EpisodeAppearanceTimestampsImpl); ok {
		s.EpisodeAppearanceTimestampsValue = impl
	}
	return s
}

// Unique identifier of the episode. Must be created by the system that first creates this episode.
// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
// handle very long integers.
// Format: snowflake_id (snowflake_id)
// Examples: 1.722279170848854e+18
func (s WatcherEpisodeImpl) EpisodeID() SnowflakeID {
	return s.EpisodeIDValue
}

// Unique identifier of the episode. Must be created by the system that first creates this episode.
// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
// handle very long integers.
// Format: snowflake_id (snowflake_id)
// Examples: 1.722279170848854e+18
func (s *WatcherEpisodeImpl) SetEpisodeID(v SnowflakeID) WatcherEpisode {
	if s == nil {
		return nil
	}
	s.EpisodeIDValue = v
	return s
}

// Generic stream episode/Face is detected/Vehicle is detected/Human is detected/Episode matches context search text query/QR-code is detected/Custom episode type.
// Use this field to define your own episode types when integrating custom analytics.
// If episode type is not specified, episode will be saved with `generic` type.
func (s WatcherEpisodeImpl) EpisodeType() *string {
	return s.EpisodeTypeValue
}

// Generic stream episode/Face is detected/Vehicle is detected/Human is detected/Episode matches context search text query/QR-code is detected/Custom episode type.
// Use this field to define your own episode types when integrating custom analytics.
// If episode type is not specified, episode will be saved with `generic` type.
func (s *WatcherEpisodeImpl) SetEpisodeType(v string) WatcherEpisode {
	if s == nil {
		return nil
	}
	s.EpisodeTypeValue = &v
	return s
}

// The fingerprint of the detected face
func (s WatcherEpisodeImpl) Fingerprint() VisionFaceFingerprint {
	return s.FingerprintValue
}

// The fingerprint of the detected face
func (s *WatcherEpisodeImpl) SetFingerprint(v VisionFaceFingerprint) WatcherEpisode {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionFaceFingerprintImpl); ok {
		s.FingerprintValue = impl
	}
	return s
}

// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
// Format: base64 (base64)
func (s WatcherEpisodeImpl) FramePreview() *Base64 {
	return s.FramePreviewValue
}

// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
// Format: base64 (base64)
func (s *WatcherEpisodeImpl) SetFramePreview(v Base64) WatcherEpisode {
	if s == nil {
		return nil
	}
	s.FramePreviewValue = &v
	return s
}

// Whether the episode is added to favorites.
// Example: false
func (s WatcherEpisodeImpl) IsFavorite() *bool {
	return s.IsFavoriteValue
}

// Whether the episode is added to favorites.
// Example: false
func (s *WatcherEpisodeImpl) SetIsFavorite(v bool) WatcherEpisode {
	if s == nil {
		return nil
	}
	s.IsFavoriteValue = &v
	return s
}

// Indicates if no license plate is detected on this vehicle
func (s WatcherEpisodeImpl) LicensePlateMissing() *bool {
	return s.LicensePlateMissingValue
}

// Indicates if no license plate is detected on this vehicle
func (s *WatcherEpisodeImpl) SetLicensePlateMissing(v bool) WatcherEpisode {
	if s == nil {
		return nil
	}
	s.LicensePlateMissingValue = &v
	return s
}

// Recognized vehicle's license plate number
func (s WatcherEpisodeImpl) LicensePlateText() *string {
	return s.LicensePlateTextValue
}

// Recognized vehicle's license plate number
func (s *WatcherEpisodeImpl) SetLicensePlateText(v string) WatcherEpisode {
	if s == nil {
		return nil
	}
	s.LicensePlateTextValue = &v
	return s
}

// Maximum matching score between the text query and episode.
// Examples: 0.2345
func (s WatcherEpisodeImpl) MatchScore() *float64 {
	return s.MatchScoreValue
}

// Maximum matching score between the text query and episode.
// Examples: 0.2345
func (s *WatcherEpisodeImpl) SetMatchScore(v float64) WatcherEpisode {
	if s == nil {
		return nil
	}
	s.MatchScoreValue = &v
	return s
}

// List of matched persons with similarity metric.
// Videoanalytics identification service enriches episode's data and fills this field
// with the list of persons that are similar to the face detected in this episode.
func (s WatcherEpisodeImpl) MatchedPersons() []VisionPersonMatch {
	if s.MatchedPersonsValue == nil {
		return nil
	}
	result := make([]VisionPersonMatch, len(s.MatchedPersonsValue))
	for i, item := range s.MatchedPersonsValue {
		result[i] = item
	}
	return result
}

// List of matched persons with similarity metric.
// Videoanalytics identification service enriches episode's data and fills this field
// with the list of persons that are similar to the face detected in this episode.
func (s *WatcherEpisodeImpl) SetMatchedPersons(v []VisionPersonMatch) WatcherEpisode {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*VisionPersonMatchImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*VisionPersonMatchImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.MatchedPersonsValue = impl
	}
	return s
}

// Stream name on which this episode exists.
// Format: media_name (media_name)
func (s WatcherEpisodeImpl) Media() MediaName {
	return s.MediaValue
}

// Stream name on which this episode exists.
// Format: media_name (media_name)
func (s *WatcherEpisodeImpl) SetMedia(v MediaName) WatcherEpisode {
	if s == nil {
		return nil
	}
	s.MediaValue = v
	return s
}

// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
// sort as by `opened_at`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s WatcherEpisodeImpl) OpenedAt() UtcMs {
	return s.OpenedAtValue
}

// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
// sort as by `opened_at`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *WatcherEpisodeImpl) SetOpenedAt(v UtcMs) WatcherEpisode {
	if s == nil {
		return nil
	}
	s.OpenedAtValue = v
	return s
}

// Raw data extracted from QR-code/Custom episode payload. Use this field to provide additional information about the episode.
func (s WatcherEpisodeImpl) Payload() any {
	return s.PayloadValue
}

// Raw data extracted from QR-code/Custom episode payload. Use this field to provide additional information about the episode.
func (s *WatcherEpisodeImpl) SetPayload(v any) WatcherEpisode {
	if s == nil {
		return nil
	}
	s.PayloadValue = v
	return s
}

// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
// Example: onetime_token
func (s WatcherEpisodeImpl) PlaybackToken() *string {
	return s.PlaybackTokenValue
}

// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
// Example: onetime_token
func (s *WatcherEpisodeImpl) SetPlaybackToken(v string) WatcherEpisode {
	if s == nil {
		return nil
	}
	s.PlaybackTokenValue = &v
	return s
}

// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// /Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Preview contains an image of person's face and has a resolution about 200 x 200 pixels with maximum size about 10 kilobytes.
// /Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Preview contains an image of vehicle's license plate and has a resolution about 160 x 64 pixels with maximum size about 10 kilobytes.
func (s WatcherEpisodeImpl) Preview() *Base64 {
	return s.PreviewValue
}

// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// /Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Preview contains an image of person's face and has a resolution about 200 x 200 pixels with maximum size about 10 kilobytes.
// /Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Preview contains an image of vehicle's license plate and has a resolution about 160 x 64 pixels with maximum size about 10 kilobytes.
func (s *WatcherEpisodeImpl) SetPreview(v Base64) WatcherEpisode {
	if s == nil {
		return nil
	}
	s.PreviewValue = &v
	return s
}

// The time when the preview of this episode is available.
// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
// for details.
// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s WatcherEpisodeImpl) PreviewTimestamp() *UtcMs {
	return s.PreviewTimestampValue
}

// The time when the preview of this episode is available.
// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
// for details.
// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *WatcherEpisodeImpl) SetPreviewTimestamp(v UtcMs) WatcherEpisode {
	if s == nil {
		return nil
	}
	s.PreviewTimestampValue = &v
	return s
}

// This field can be used as indication of the fact that some system have checked and ensured that
// this episode has really started at some time, that may differ from `opened_at`.
// For example video analytics will use this field for the time when this episode was confirmed as confident.
// May be not relevant for television systems.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s WatcherEpisodeImpl) StartedAt() *UtcMs {
	return s.StartedAtValue
}

// This field can be used as indication of the fact that some system have checked and ensured that
// this episode has really started at some time, that may differ from `opened_at`.
// For example video analytics will use this field for the time when this episode was confirmed as confident.
// May be not relevant for television systems.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *WatcherEpisodeImpl) SetStartedAt(v UtcMs) WatcherEpisode {
	if s == nil {
		return nil
	}
	s.StartedAtValue = &v
	return s
}

// Details about stream related to the episode.
func (s WatcherEpisodeImpl) Stream() EpisodeStreamDetailsStream {
	return s.StreamValue
}

// Details about stream related to the episode.
func (s *WatcherEpisodeImpl) SetStream(v EpisodeStreamDetailsStream) WatcherEpisode {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*EpisodeStreamDetailsStreamImpl); ok {
		s.StreamValue = impl
	}
	return s
}

// HTTP(s) URL that can be used for streaming API of this episode
// Example: https://streamer.example.com
func (s WatcherEpisodeImpl) StreamingEndpoint() *string {
	return s.StreamingEndpointValue
}

// HTTP(s) URL that can be used for streaming API of this episode
// Example: https://streamer.example.com
func (s *WatcherEpisodeImpl) SetStreamingEndpoint(v string) WatcherEpisode {
	if s == nil {
		return nil
	}
	s.StreamingEndpointValue = &v
	return s
}

// Optional title of the episode. Can be used to provide a human-readable name for the episode.
// Example: Visitor at main entrance
func (s WatcherEpisodeImpl) Title() *string {
	return s.TitleValue
}

// Optional title of the episode. Can be used to provide a human-readable name for the episode.
// Example: Visitor at main entrance
func (s *WatcherEpisodeImpl) SetTitle(v string) WatcherEpisode {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// The time of last change of the episode.
// System that processes episodes and can send them to other systems, MUST update this field
// on any changes in this episode.
// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
// this `updated_at` can be used as a sort key for fetching fresh updates.
// Consumer of the episodes can use `updated_at` in the following scenario:
// * fetch all exisiting episodes from the source
// * take biggest `updated_at` from this dataset, it will be T
// * ask source for all episodes with `updated_at > T`
// This algorithm can be used for fetching update stream from the source.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637098611e+12
func (s WatcherEpisodeImpl) UpdatedAt() UtcMs {
	return s.UpdatedAtValue
}

// The time of last change of the episode.
// System that processes episodes and can send them to other systems, MUST update this field
// on any changes in this episode.
// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
// this `updated_at` can be used as a sort key for fetching fresh updates.
// Consumer of the episodes can use `updated_at` in the following scenario:
// * fetch all exisiting episodes from the source
// * take biggest `updated_at` from this dataset, it will be T
// * ask source for all episodes with `updated_at > T`
// This algorithm can be used for fetching update stream from the source.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637098611e+12
func (s *WatcherEpisodeImpl) SetUpdatedAt(v UtcMs) WatcherEpisode {
	if s == nil {
		return nil
	}
	s.UpdatedAtValue = v
	return s
}

// Emergency type of the vehicle.
func (s WatcherEpisodeImpl) VehicleEmergencySubtype() *VisionVehicleEmergencySubtype {
	return s.VehicleEmergencySubtypeValue
}

// Emergency type of the vehicle.
func (s *WatcherEpisodeImpl) SetVehicleEmergencySubtype(v VisionVehicleEmergencySubtype) WatcherEpisode {
	if s == nil {
		return nil
	}
	s.VehicleEmergencySubtypeValue = &v
	return s
}

// Shows from which side the vehicle was detected.
func (s WatcherEpisodeImpl) VehicleFacingSide() *VisionVehicleFacingSide {
	return s.VehicleFacingSideValue
}

// Shows from which side the vehicle was detected.
func (s *WatcherEpisodeImpl) SetVehicleFacingSide(v VisionVehicleFacingSide) WatcherEpisode {
	if s == nil {
		return nil
	}
	s.VehicleFacingSideValue = &v
	return s
}

// The purpose of the vehicle, e.g. emergency or regular.
func (s WatcherEpisodeImpl) VehiclePurpose() *VisionVehiclePurpose {
	return s.VehiclePurposeValue
}

// The purpose of the vehicle, e.g. emergency or regular.
func (s *WatcherEpisodeImpl) SetVehiclePurpose(v VisionVehiclePurpose) WatcherEpisode {
	if s == nil {
		return nil
	}
	s.VehiclePurposeValue = &v
	return s
}

// NewWatcherEpisodeBase creates a new WatcherEpisodeBase instance
func NewWatcherEpisodeBase() WatcherEpisodeBase {
	return &WatcherEpisodeBaseImpl{}
}

// Optional description of the episode. Can be used to provide additional context or details about the episode.
// Example: Person detected at the main entrance, stayed for 30 seconds
func (s WatcherEpisodeBaseImpl) Description() *string {
	return s.DescriptionValue
}

// Optional description of the episode. Can be used to provide additional context or details about the episode.
// Example: Person detected at the main entrance, stayed for 30 seconds
func (s *WatcherEpisodeBaseImpl) SetDescription(v string) WatcherEpisodeBase {
	if s == nil {
		return nil
	}
	s.DescriptionValue = &v
	return s
}

// Duration of the episode in milliseconds.
// Format: milliseconds (milliseconds)
// Example: 10500
func (s WatcherEpisodeBaseImpl) Duration() *Milliseconds {
	return s.DurationValue
}

// Duration of the episode in milliseconds.
// Format: milliseconds (milliseconds)
// Example: 10500
func (s *WatcherEpisodeBaseImpl) SetDuration(v Milliseconds) WatcherEpisodeBase {
	if s == nil {
		return nil
	}
	s.DurationValue = &v
	return s
}

// Whether the episode is added to favorites.
// Example: false
func (s WatcherEpisodeBaseImpl) IsFavorite() *bool {
	return s.IsFavoriteValue
}

// Whether the episode is added to favorites.
// Example: false
func (s *WatcherEpisodeBaseImpl) SetIsFavorite(v bool) WatcherEpisodeBase {
	if s == nil {
		return nil
	}
	s.IsFavoriteValue = &v
	return s
}

// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
// Example: onetime_token
func (s WatcherEpisodeBaseImpl) PlaybackToken() *string {
	return s.PlaybackTokenValue
}

// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
// Example: onetime_token
func (s *WatcherEpisodeBaseImpl) SetPlaybackToken(v string) WatcherEpisodeBase {
	if s == nil {
		return nil
	}
	s.PlaybackTokenValue = &v
	return s
}

// Details about stream related to the episode.
func (s WatcherEpisodeBaseImpl) Stream() EpisodeStreamDetailsStream {
	return s.StreamValue
}

// Details about stream related to the episode.
func (s *WatcherEpisodeBaseImpl) SetStream(v EpisodeStreamDetailsStream) WatcherEpisodeBase {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*EpisodeStreamDetailsStreamImpl); ok {
		s.StreamValue = impl
	}
	return s
}

// HTTP(s) URL that can be used for streaming API of this episode
// Example: https://streamer.example.com
func (s WatcherEpisodeBaseImpl) StreamingEndpoint() *string {
	return s.StreamingEndpointValue
}

// HTTP(s) URL that can be used for streaming API of this episode
// Example: https://streamer.example.com
func (s *WatcherEpisodeBaseImpl) SetStreamingEndpoint(v string) WatcherEpisodeBase {
	if s == nil {
		return nil
	}
	s.StreamingEndpointValue = &v
	return s
}

// Optional title of the episode. Can be used to provide a human-readable name for the episode.
// Example: Visitor at main entrance
func (s WatcherEpisodeBaseImpl) Title() *string {
	return s.TitleValue
}

// Optional title of the episode. Can be used to provide a human-readable name for the episode.
// Example: Visitor at main entrance
func (s *WatcherEpisodeBaseImpl) SetTitle(v string) WatcherEpisodeBase {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// NewWatcherEpisodeContextSearch creates a new WatcherEpisodeContextSearch instance
func NewWatcherEpisodeContextSearch() WatcherEpisodeContextSearch {
	return &WatcherEpisodeContextSearchImpl{}
}

// The reason for closing the episode.
func (s WatcherEpisodeContextSearchImpl) CloseReason() *EpisodeCloseReason {
	return s.CloseReasonValue
}

// The reason for closing the episode.
func (s *WatcherEpisodeContextSearchImpl) SetCloseReason(v EpisodeCloseReason) WatcherEpisodeContextSearch {
	if s == nil {
		return nil
	}
	s.CloseReasonValue = &v
	return s
}

// Episode emitter can decide that episode considered closed and will not grow further.
// `closed_at` MUST NOT change, it must be emitted only once.
// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
// of the episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s WatcherEpisodeContextSearchImpl) ClosedAt() *UtcMs {
	return s.ClosedAtValue
}

// Episode emitter can decide that episode considered closed and will not grow further.
// `closed_at` MUST NOT change, it must be emitted only once.
// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
// of the episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *WatcherEpisodeContextSearchImpl) SetClosedAt(v UtcMs) WatcherEpisodeContextSearch {
	if s == nil {
		return nil
	}
	s.ClosedAtValue = &v
	return s
}

// Optional description of the episode. Can be used to provide additional context or details about the episode.
// Example: Person detected at the main entrance, stayed for 30 seconds
func (s WatcherEpisodeContextSearchImpl) Description() *string {
	return s.DescriptionValue
}

// Optional description of the episode. Can be used to provide additional context or details about the episode.
// Example: Person detected at the main entrance, stayed for 30 seconds
func (s *WatcherEpisodeContextSearchImpl) SetDescription(v string) WatcherEpisodeContextSearch {
	if s == nil {
		return nil
	}
	s.DescriptionValue = &v
	return s
}

// Duration of the episode in milliseconds.
// Format: milliseconds (milliseconds)
// Example: 10500
func (s WatcherEpisodeContextSearchImpl) Duration() *Milliseconds {
	return s.DurationValue
}

// Duration of the episode in milliseconds.
// Format: milliseconds (milliseconds)
// Example: 10500
func (s *WatcherEpisodeContextSearchImpl) SetDuration(v Milliseconds) WatcherEpisodeContextSearch {
	if s == nil {
		return nil
	}
	s.DurationValue = &v
	return s
}

// The time when the episode appeared in the service relative to the server time.
func (s WatcherEpisodeContextSearchImpl) EpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps {
	return s.EpisodeAppearanceTimestampsValue
}

// The time when the episode appeared in the service relative to the server time.
func (s *WatcherEpisodeContextSearchImpl) SetEpisodeAppearanceTimestamps(v EpisodeAppearanceTimestamps) WatcherEpisodeContextSearch {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*EpisodeAppearanceTimestampsImpl); ok {
		s.EpisodeAppearanceTimestampsValue = impl
	}
	return s
}

// Unique identifier of the episode. Must be created by the system that first creates this episode.
// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
// handle very long integers.
// Format: snowflake_id (snowflake_id)
// Examples: 1.722279170848854e+18
func (s WatcherEpisodeContextSearchImpl) EpisodeID() SnowflakeID {
	return s.EpisodeIDValue
}

// Unique identifier of the episode. Must be created by the system that first creates this episode.
// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
// handle very long integers.
// Format: snowflake_id (snowflake_id)
// Examples: 1.722279170848854e+18
func (s *WatcherEpisodeContextSearchImpl) SetEpisodeID(v SnowflakeID) WatcherEpisodeContextSearch {
	if s == nil {
		return nil
	}
	s.EpisodeIDValue = v
	return s
}

// Episode matches context search text query
func (s WatcherEpisodeContextSearchImpl) EpisodeType() *string {
	return s.EpisodeTypeValue
}

// Episode matches context search text query
func (s *WatcherEpisodeContextSearchImpl) SetEpisodeType(v string) WatcherEpisodeContextSearch {
	if s == nil {
		return nil
	}
	s.EpisodeTypeValue = &v
	return s
}

// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
// Format: base64 (base64)
func (s WatcherEpisodeContextSearchImpl) FramePreview() *Base64 {
	return s.FramePreviewValue
}

// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
// Format: base64 (base64)
func (s *WatcherEpisodeContextSearchImpl) SetFramePreview(v Base64) WatcherEpisodeContextSearch {
	if s == nil {
		return nil
	}
	s.FramePreviewValue = &v
	return s
}

// Whether the episode is added to favorites.
// Example: false
func (s WatcherEpisodeContextSearchImpl) IsFavorite() *bool {
	return s.IsFavoriteValue
}

// Whether the episode is added to favorites.
// Example: false
func (s *WatcherEpisodeContextSearchImpl) SetIsFavorite(v bool) WatcherEpisodeContextSearch {
	if s == nil {
		return nil
	}
	s.IsFavoriteValue = &v
	return s
}

// Maximum matching score between the text query and episode.
// Examples: 0.2345
func (s WatcherEpisodeContextSearchImpl) MatchScore() *float64 {
	return s.MatchScoreValue
}

// Maximum matching score between the text query and episode.
// Examples: 0.2345
func (s *WatcherEpisodeContextSearchImpl) SetMatchScore(v float64) WatcherEpisodeContextSearch {
	if s == nil {
		return nil
	}
	s.MatchScoreValue = &v
	return s
}

// Stream name on which this episode exists.
// Format: media_name (media_name)
func (s WatcherEpisodeContextSearchImpl) Media() MediaName {
	return s.MediaValue
}

// Stream name on which this episode exists.
// Format: media_name (media_name)
func (s *WatcherEpisodeContextSearchImpl) SetMedia(v MediaName) WatcherEpisodeContextSearch {
	if s == nil {
		return nil
	}
	s.MediaValue = v
	return s
}

// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
// sort as by `opened_at`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s WatcherEpisodeContextSearchImpl) OpenedAt() UtcMs {
	return s.OpenedAtValue
}

// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
// sort as by `opened_at`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *WatcherEpisodeContextSearchImpl) SetOpenedAt(v UtcMs) WatcherEpisodeContextSearch {
	if s == nil {
		return nil
	}
	s.OpenedAtValue = v
	return s
}

// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
// Example: onetime_token
func (s WatcherEpisodeContextSearchImpl) PlaybackToken() *string {
	return s.PlaybackTokenValue
}

// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
// Example: onetime_token
func (s *WatcherEpisodeContextSearchImpl) SetPlaybackToken(v string) WatcherEpisodeContextSearch {
	if s == nil {
		return nil
	}
	s.PlaybackTokenValue = &v
	return s
}

// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Format: base64 (base64)
func (s WatcherEpisodeContextSearchImpl) Preview() *Base64 {
	return s.PreviewValue
}

// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Format: base64 (base64)
func (s *WatcherEpisodeContextSearchImpl) SetPreview(v Base64) WatcherEpisodeContextSearch {
	if s == nil {
		return nil
	}
	s.PreviewValue = &v
	return s
}

// The time when the preview of this episode is available.
// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
// for details.
// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s WatcherEpisodeContextSearchImpl) PreviewTimestamp() *UtcMs {
	return s.PreviewTimestampValue
}

// The time when the preview of this episode is available.
// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
// for details.
// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *WatcherEpisodeContextSearchImpl) SetPreviewTimestamp(v UtcMs) WatcherEpisodeContextSearch {
	if s == nil {
		return nil
	}
	s.PreviewTimestampValue = &v
	return s
}

// This field can be used as indication of the fact that some system have checked and ensured that
// this episode has really started at some time, that may differ from `opened_at`.
// For example video analytics will use this field for the time when this episode was confirmed as confident.
// May be not relevant for television systems.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s WatcherEpisodeContextSearchImpl) StartedAt() *UtcMs {
	return s.StartedAtValue
}

// This field can be used as indication of the fact that some system have checked and ensured that
// this episode has really started at some time, that may differ from `opened_at`.
// For example video analytics will use this field for the time when this episode was confirmed as confident.
// May be not relevant for television systems.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *WatcherEpisodeContextSearchImpl) SetStartedAt(v UtcMs) WatcherEpisodeContextSearch {
	if s == nil {
		return nil
	}
	s.StartedAtValue = &v
	return s
}

// Details about stream related to the episode.
func (s WatcherEpisodeContextSearchImpl) Stream() EpisodeStreamDetailsStream {
	return s.StreamValue
}

// Details about stream related to the episode.
func (s *WatcherEpisodeContextSearchImpl) SetStream(v EpisodeStreamDetailsStream) WatcherEpisodeContextSearch {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*EpisodeStreamDetailsStreamImpl); ok {
		s.StreamValue = impl
	}
	return s
}

// HTTP(s) URL that can be used for streaming API of this episode
// Example: https://streamer.example.com
func (s WatcherEpisodeContextSearchImpl) StreamingEndpoint() *string {
	return s.StreamingEndpointValue
}

// HTTP(s) URL that can be used for streaming API of this episode
// Example: https://streamer.example.com
func (s *WatcherEpisodeContextSearchImpl) SetStreamingEndpoint(v string) WatcherEpisodeContextSearch {
	if s == nil {
		return nil
	}
	s.StreamingEndpointValue = &v
	return s
}

// Optional title of the episode. Can be used to provide a human-readable name for the episode.
// Example: Visitor at main entrance
func (s WatcherEpisodeContextSearchImpl) Title() *string {
	return s.TitleValue
}

// Optional title of the episode. Can be used to provide a human-readable name for the episode.
// Example: Visitor at main entrance
func (s *WatcherEpisodeContextSearchImpl) SetTitle(v string) WatcherEpisodeContextSearch {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// The time of last change of the episode.
// System that processes episodes and can send them to other systems, MUST update this field
// on any changes in this episode.
// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
// this `updated_at` can be used as a sort key for fetching fresh updates.
// Consumer of the episodes can use `updated_at` in the following scenario:
// * fetch all exisiting episodes from the source
// * take biggest `updated_at` from this dataset, it will be T
// * ask source for all episodes with `updated_at > T`
// This algorithm can be used for fetching update stream from the source.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637098611e+12
func (s WatcherEpisodeContextSearchImpl) UpdatedAt() UtcMs {
	return s.UpdatedAtValue
}

// The time of last change of the episode.
// System that processes episodes and can send them to other systems, MUST update this field
// on any changes in this episode.
// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
// this `updated_at` can be used as a sort key for fetching fresh updates.
// Consumer of the episodes can use `updated_at` in the following scenario:
// * fetch all exisiting episodes from the source
// * take biggest `updated_at` from this dataset, it will be T
// * ask source for all episodes with `updated_at > T`
// This algorithm can be used for fetching update stream from the source.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637098611e+12
func (s *WatcherEpisodeContextSearchImpl) SetUpdatedAt(v UtcMs) WatcherEpisodeContextSearch {
	if s == nil {
		return nil
	}
	s.UpdatedAtValue = v
	return s
}

// NewWatcherEpisodeCustom creates a new WatcherEpisodeCustom instance
func NewWatcherEpisodeCustom() WatcherEpisodeCustom {
	return &WatcherEpisodeCustomImpl{}
}

// The reason for closing the episode.
func (s WatcherEpisodeCustomImpl) CloseReason() *EpisodeCloseReason {
	return s.CloseReasonValue
}

// The reason for closing the episode.
func (s *WatcherEpisodeCustomImpl) SetCloseReason(v EpisodeCloseReason) WatcherEpisodeCustom {
	if s == nil {
		return nil
	}
	s.CloseReasonValue = &v
	return s
}

// Episode emitter can decide that episode considered closed and will not grow further.
// `closed_at` MUST NOT change, it must be emitted only once.
// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
// of the episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s WatcherEpisodeCustomImpl) ClosedAt() *UtcMs {
	return s.ClosedAtValue
}

// Episode emitter can decide that episode considered closed and will not grow further.
// `closed_at` MUST NOT change, it must be emitted only once.
// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
// of the episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *WatcherEpisodeCustomImpl) SetClosedAt(v UtcMs) WatcherEpisodeCustom {
	if s == nil {
		return nil
	}
	s.ClosedAtValue = &v
	return s
}

// Optional description of the episode. Can be used to provide additional context or details about the episode.
// Example: Person detected at the main entrance, stayed for 30 seconds
func (s WatcherEpisodeCustomImpl) Description() *string {
	return s.DescriptionValue
}

// Optional description of the episode. Can be used to provide additional context or details about the episode.
// Example: Person detected at the main entrance, stayed for 30 seconds
func (s *WatcherEpisodeCustomImpl) SetDescription(v string) WatcherEpisodeCustom {
	if s == nil {
		return nil
	}
	s.DescriptionValue = &v
	return s
}

// Duration of the episode in milliseconds.
// Format: milliseconds (milliseconds)
// Example: 10500
func (s WatcherEpisodeCustomImpl) Duration() *Milliseconds {
	return s.DurationValue
}

// Duration of the episode in milliseconds.
// Format: milliseconds (milliseconds)
// Example: 10500
func (s *WatcherEpisodeCustomImpl) SetDuration(v Milliseconds) WatcherEpisodeCustom {
	if s == nil {
		return nil
	}
	s.DurationValue = &v
	return s
}

// The time when the episode appeared in the service relative to the server time.
func (s WatcherEpisodeCustomImpl) EpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps {
	return s.EpisodeAppearanceTimestampsValue
}

// The time when the episode appeared in the service relative to the server time.
func (s *WatcherEpisodeCustomImpl) SetEpisodeAppearanceTimestamps(v EpisodeAppearanceTimestamps) WatcherEpisodeCustom {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*EpisodeAppearanceTimestampsImpl); ok {
		s.EpisodeAppearanceTimestampsValue = impl
	}
	return s
}

// Unique identifier of the episode. Must be created by the system that first creates this episode.
// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
// handle very long integers.
// Format: snowflake_id (snowflake_id)
// Examples: 1.722279170848854e+18
func (s WatcherEpisodeCustomImpl) EpisodeID() SnowflakeID {
	return s.EpisodeIDValue
}

// Unique identifier of the episode. Must be created by the system that first creates this episode.
// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
// handle very long integers.
// Format: snowflake_id (snowflake_id)
// Examples: 1.722279170848854e+18
func (s *WatcherEpisodeCustomImpl) SetEpisodeID(v SnowflakeID) WatcherEpisodeCustom {
	if s == nil {
		return nil
	}
	s.EpisodeIDValue = v
	return s
}

// Custom episode type.
// Use this field to define your own episode types when integrating custom analytics.
// If episode type is not specified, episode will be saved with `generic` type.
func (s WatcherEpisodeCustomImpl) EpisodeType() *string {
	return s.EpisodeTypeValue
}

// Custom episode type.
// Use this field to define your own episode types when integrating custom analytics.
// If episode type is not specified, episode will be saved with `generic` type.
func (s *WatcherEpisodeCustomImpl) SetEpisodeType(v string) WatcherEpisodeCustom {
	if s == nil {
		return nil
	}
	s.EpisodeTypeValue = &v
	return s
}

// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
// Format: base64 (base64)
func (s WatcherEpisodeCustomImpl) FramePreview() *Base64 {
	return s.FramePreviewValue
}

// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
// Format: base64 (base64)
func (s *WatcherEpisodeCustomImpl) SetFramePreview(v Base64) WatcherEpisodeCustom {
	if s == nil {
		return nil
	}
	s.FramePreviewValue = &v
	return s
}

// Whether the episode is added to favorites.
// Example: false
func (s WatcherEpisodeCustomImpl) IsFavorite() *bool {
	return s.IsFavoriteValue
}

// Whether the episode is added to favorites.
// Example: false
func (s *WatcherEpisodeCustomImpl) SetIsFavorite(v bool) WatcherEpisodeCustom {
	if s == nil {
		return nil
	}
	s.IsFavoriteValue = &v
	return s
}

// Stream name on which this episode exists.
// Format: media_name (media_name)
func (s WatcherEpisodeCustomImpl) Media() MediaName {
	return s.MediaValue
}

// Stream name on which this episode exists.
// Format: media_name (media_name)
func (s *WatcherEpisodeCustomImpl) SetMedia(v MediaName) WatcherEpisodeCustom {
	if s == nil {
		return nil
	}
	s.MediaValue = v
	return s
}

// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
// sort as by `opened_at`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s WatcherEpisodeCustomImpl) OpenedAt() UtcMs {
	return s.OpenedAtValue
}

// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
// sort as by `opened_at`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *WatcherEpisodeCustomImpl) SetOpenedAt(v UtcMs) WatcherEpisodeCustom {
	if s == nil {
		return nil
	}
	s.OpenedAtValue = v
	return s
}

// Custom episode payload. Use this field to provide additional information about the episode.
func (s WatcherEpisodeCustomImpl) Payload() any {
	return s.PayloadValue
}

// Custom episode payload. Use this field to provide additional information about the episode.
func (s *WatcherEpisodeCustomImpl) SetPayload(v any) WatcherEpisodeCustom {
	if s == nil {
		return nil
	}
	s.PayloadValue = v
	return s
}

// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
// Example: onetime_token
func (s WatcherEpisodeCustomImpl) PlaybackToken() *string {
	return s.PlaybackTokenValue
}

// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
// Example: onetime_token
func (s *WatcherEpisodeCustomImpl) SetPlaybackToken(v string) WatcherEpisodeCustom {
	if s == nil {
		return nil
	}
	s.PlaybackTokenValue = &v
	return s
}

// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Format: base64 (base64)
func (s WatcherEpisodeCustomImpl) Preview() *Base64 {
	return s.PreviewValue
}

// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Format: base64 (base64)
func (s *WatcherEpisodeCustomImpl) SetPreview(v Base64) WatcherEpisodeCustom {
	if s == nil {
		return nil
	}
	s.PreviewValue = &v
	return s
}

// The time when the preview of this episode is available.
// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
// for details.
// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s WatcherEpisodeCustomImpl) PreviewTimestamp() *UtcMs {
	return s.PreviewTimestampValue
}

// The time when the preview of this episode is available.
// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
// for details.
// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *WatcherEpisodeCustomImpl) SetPreviewTimestamp(v UtcMs) WatcherEpisodeCustom {
	if s == nil {
		return nil
	}
	s.PreviewTimestampValue = &v
	return s
}

// This field can be used as indication of the fact that some system have checked and ensured that
// this episode has really started at some time, that may differ from `opened_at`.
// For example video analytics will use this field for the time when this episode was confirmed as confident.
// May be not relevant for television systems.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s WatcherEpisodeCustomImpl) StartedAt() *UtcMs {
	return s.StartedAtValue
}

// This field can be used as indication of the fact that some system have checked and ensured that
// this episode has really started at some time, that may differ from `opened_at`.
// For example video analytics will use this field for the time when this episode was confirmed as confident.
// May be not relevant for television systems.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *WatcherEpisodeCustomImpl) SetStartedAt(v UtcMs) WatcherEpisodeCustom {
	if s == nil {
		return nil
	}
	s.StartedAtValue = &v
	return s
}

// Details about stream related to the episode.
func (s WatcherEpisodeCustomImpl) Stream() EpisodeStreamDetailsStream {
	return s.StreamValue
}

// Details about stream related to the episode.
func (s *WatcherEpisodeCustomImpl) SetStream(v EpisodeStreamDetailsStream) WatcherEpisodeCustom {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*EpisodeStreamDetailsStreamImpl); ok {
		s.StreamValue = impl
	}
	return s
}

// HTTP(s) URL that can be used for streaming API of this episode
// Example: https://streamer.example.com
func (s WatcherEpisodeCustomImpl) StreamingEndpoint() *string {
	return s.StreamingEndpointValue
}

// HTTP(s) URL that can be used for streaming API of this episode
// Example: https://streamer.example.com
func (s *WatcherEpisodeCustomImpl) SetStreamingEndpoint(v string) WatcherEpisodeCustom {
	if s == nil {
		return nil
	}
	s.StreamingEndpointValue = &v
	return s
}

// Optional title of the episode. Can be used to provide a human-readable name for the episode.
// Example: Visitor at main entrance
func (s WatcherEpisodeCustomImpl) Title() *string {
	return s.TitleValue
}

// Optional title of the episode. Can be used to provide a human-readable name for the episode.
// Example: Visitor at main entrance
func (s *WatcherEpisodeCustomImpl) SetTitle(v string) WatcherEpisodeCustom {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// The time of last change of the episode.
// System that processes episodes and can send them to other systems, MUST update this field
// on any changes in this episode.
// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
// this `updated_at` can be used as a sort key for fetching fresh updates.
// Consumer of the episodes can use `updated_at` in the following scenario:
// * fetch all exisiting episodes from the source
// * take biggest `updated_at` from this dataset, it will be T
// * ask source for all episodes with `updated_at > T`
// This algorithm can be used for fetching update stream from the source.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637098611e+12
func (s WatcherEpisodeCustomImpl) UpdatedAt() UtcMs {
	return s.UpdatedAtValue
}

// The time of last change of the episode.
// System that processes episodes and can send them to other systems, MUST update this field
// on any changes in this episode.
// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
// this `updated_at` can be used as a sort key for fetching fresh updates.
// Consumer of the episodes can use `updated_at` in the following scenario:
// * fetch all exisiting episodes from the source
// * take biggest `updated_at` from this dataset, it will be T
// * ask source for all episodes with `updated_at > T`
// This algorithm can be used for fetching update stream from the source.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637098611e+12
func (s *WatcherEpisodeCustomImpl) SetUpdatedAt(v UtcMs) WatcherEpisodeCustom {
	if s == nil {
		return nil
	}
	s.UpdatedAtValue = v
	return s
}

// NewWatcherEpisodeFace creates a new WatcherEpisodeFace instance
func NewWatcherEpisodeFace() WatcherEpisodeFace {
	return &WatcherEpisodeFaceImpl{}
}

// The reason for closing the episode.
func (s WatcherEpisodeFaceImpl) CloseReason() *EpisodeCloseReason {
	return s.CloseReasonValue
}

// The reason for closing the episode.
func (s *WatcherEpisodeFaceImpl) SetCloseReason(v EpisodeCloseReason) WatcherEpisodeFace {
	if s == nil {
		return nil
	}
	s.CloseReasonValue = &v
	return s
}

// Episode emitter can decide that episode considered closed and will not grow further.
// `closed_at` MUST NOT change, it must be emitted only once.
// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
// of the episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s WatcherEpisodeFaceImpl) ClosedAt() *UtcMs {
	return s.ClosedAtValue
}

// Episode emitter can decide that episode considered closed and will not grow further.
// `closed_at` MUST NOT change, it must be emitted only once.
// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
// of the episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *WatcherEpisodeFaceImpl) SetClosedAt(v UtcMs) WatcherEpisodeFace {
	if s == nil {
		return nil
	}
	s.ClosedAtValue = &v
	return s
}

// Optional description of the episode. Can be used to provide additional context or details about the episode.
// Example: Person detected at the main entrance, stayed for 30 seconds
func (s WatcherEpisodeFaceImpl) Description() *string {
	return s.DescriptionValue
}

// Optional description of the episode. Can be used to provide additional context or details about the episode.
// Example: Person detected at the main entrance, stayed for 30 seconds
func (s *WatcherEpisodeFaceImpl) SetDescription(v string) WatcherEpisodeFace {
	if s == nil {
		return nil
	}
	s.DescriptionValue = &v
	return s
}

// Detections associated with this episode
func (s WatcherEpisodeFaceImpl) Detections() []VisionDetectedFace {
	if s.DetectionsValue == nil {
		return nil
	}
	result := make([]VisionDetectedFace, len(s.DetectionsValue))
	for i, item := range s.DetectionsValue {
		result[i] = item
	}
	return result
}

// Detections associated with this episode
func (s *WatcherEpisodeFaceImpl) SetDetections(v []VisionDetectedFace) WatcherEpisodeFace {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*VisionDetectedFaceImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*VisionDetectedFaceImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.DetectionsValue = impl
	}
	return s
}

// Duration of the episode in milliseconds.
// Format: milliseconds (milliseconds)
// Example: 10500
func (s WatcherEpisodeFaceImpl) Duration() *Milliseconds {
	return s.DurationValue
}

// Duration of the episode in milliseconds.
// Format: milliseconds (milliseconds)
// Example: 10500
func (s *WatcherEpisodeFaceImpl) SetDuration(v Milliseconds) WatcherEpisodeFace {
	if s == nil {
		return nil
	}
	s.DurationValue = &v
	return s
}

// The time when the episode appeared in the service relative to the server time.
func (s WatcherEpisodeFaceImpl) EpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps {
	return s.EpisodeAppearanceTimestampsValue
}

// The time when the episode appeared in the service relative to the server time.
func (s *WatcherEpisodeFaceImpl) SetEpisodeAppearanceTimestamps(v EpisodeAppearanceTimestamps) WatcherEpisodeFace {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*EpisodeAppearanceTimestampsImpl); ok {
		s.EpisodeAppearanceTimestampsValue = impl
	}
	return s
}

// Unique identifier of the episode. Must be created by the system that first creates this episode.
// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
// handle very long integers.
// Format: snowflake_id (snowflake_id)
// Examples: 1.722279170848854e+18
func (s WatcherEpisodeFaceImpl) EpisodeID() SnowflakeID {
	return s.EpisodeIDValue
}

// Unique identifier of the episode. Must be created by the system that first creates this episode.
// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
// handle very long integers.
// Format: snowflake_id (snowflake_id)
// Examples: 1.722279170848854e+18
func (s *WatcherEpisodeFaceImpl) SetEpisodeID(v SnowflakeID) WatcherEpisodeFace {
	if s == nil {
		return nil
	}
	s.EpisodeIDValue = v
	return s
}

// Face is detected
func (s WatcherEpisodeFaceImpl) EpisodeType() *string {
	return s.EpisodeTypeValue
}

// Face is detected
func (s *WatcherEpisodeFaceImpl) SetEpisodeType(v string) WatcherEpisodeFace {
	if s == nil {
		return nil
	}
	s.EpisodeTypeValue = &v
	return s
}

// The fingerprint of the detected face
func (s WatcherEpisodeFaceImpl) Fingerprint() VisionFaceFingerprint {
	return s.FingerprintValue
}

// The fingerprint of the detected face
func (s *WatcherEpisodeFaceImpl) SetFingerprint(v VisionFaceFingerprint) WatcherEpisodeFace {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*VisionFaceFingerprintImpl); ok {
		s.FingerprintValue = impl
	}
	return s
}

// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
// Format: base64 (base64)
func (s WatcherEpisodeFaceImpl) FramePreview() *Base64 {
	return s.FramePreviewValue
}

// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
// Format: base64 (base64)
func (s *WatcherEpisodeFaceImpl) SetFramePreview(v Base64) WatcherEpisodeFace {
	if s == nil {
		return nil
	}
	s.FramePreviewValue = &v
	return s
}

// Whether the episode is added to favorites.
// Example: false
func (s WatcherEpisodeFaceImpl) IsFavorite() *bool {
	return s.IsFavoriteValue
}

// Whether the episode is added to favorites.
// Example: false
func (s *WatcherEpisodeFaceImpl) SetIsFavorite(v bool) WatcherEpisodeFace {
	if s == nil {
		return nil
	}
	s.IsFavoriteValue = &v
	return s
}

// List of matched persons with similarity metric.
// Videoanalytics identification service enriches episode's data and fills this field
// with the list of persons that are similar to the face detected in this episode.
func (s WatcherEpisodeFaceImpl) MatchedPersons() []VisionPersonMatch {
	if s.MatchedPersonsValue == nil {
		return nil
	}
	result := make([]VisionPersonMatch, len(s.MatchedPersonsValue))
	for i, item := range s.MatchedPersonsValue {
		result[i] = item
	}
	return result
}

// List of matched persons with similarity metric.
// Videoanalytics identification service enriches episode's data and fills this field
// with the list of persons that are similar to the face detected in this episode.
func (s *WatcherEpisodeFaceImpl) SetMatchedPersons(v []VisionPersonMatch) WatcherEpisodeFace {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*VisionPersonMatchImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*VisionPersonMatchImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.MatchedPersonsValue = impl
	}
	return s
}

// Stream name on which this episode exists.
// Format: media_name (media_name)
func (s WatcherEpisodeFaceImpl) Media() MediaName {
	return s.MediaValue
}

// Stream name on which this episode exists.
// Format: media_name (media_name)
func (s *WatcherEpisodeFaceImpl) SetMedia(v MediaName) WatcherEpisodeFace {
	if s == nil {
		return nil
	}
	s.MediaValue = v
	return s
}

// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
// sort as by `opened_at`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s WatcherEpisodeFaceImpl) OpenedAt() UtcMs {
	return s.OpenedAtValue
}

// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
// sort as by `opened_at`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *WatcherEpisodeFaceImpl) SetOpenedAt(v UtcMs) WatcherEpisodeFace {
	if s == nil {
		return nil
	}
	s.OpenedAtValue = v
	return s
}

// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
// Example: onetime_token
func (s WatcherEpisodeFaceImpl) PlaybackToken() *string {
	return s.PlaybackTokenValue
}

// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
// Example: onetime_token
func (s *WatcherEpisodeFaceImpl) SetPlaybackToken(v string) WatcherEpisodeFace {
	if s == nil {
		return nil
	}
	s.PlaybackTokenValue = &v
	return s
}

// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Preview contains an image of person's face and has a resolution about 200 x 200 pixels with maximum size about 10 kilobytes.
// Format: base64 (base64)
func (s WatcherEpisodeFaceImpl) Preview() Base64 {
	return s.PreviewValue
}

// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Preview contains an image of person's face and has a resolution about 200 x 200 pixels with maximum size about 10 kilobytes.
// Format: base64 (base64)
func (s *WatcherEpisodeFaceImpl) SetPreview(v Base64) WatcherEpisodeFace {
	if s == nil {
		return nil
	}
	s.PreviewValue = v
	return s
}

// The time when the preview of this episode is available.
// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
// for details.
// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s WatcherEpisodeFaceImpl) PreviewTimestamp() *UtcMs {
	return s.PreviewTimestampValue
}

// The time when the preview of this episode is available.
// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
// for details.
// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *WatcherEpisodeFaceImpl) SetPreviewTimestamp(v UtcMs) WatcherEpisodeFace {
	if s == nil {
		return nil
	}
	s.PreviewTimestampValue = &v
	return s
}

// This field can be used as indication of the fact that some system have checked and ensured that
// this episode has really started at some time, that may differ from `opened_at`.
// For example video analytics will use this field for the time when this episode was confirmed as confident.
// May be not relevant for television systems.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s WatcherEpisodeFaceImpl) StartedAt() *UtcMs {
	return s.StartedAtValue
}

// This field can be used as indication of the fact that some system have checked and ensured that
// this episode has really started at some time, that may differ from `opened_at`.
// For example video analytics will use this field for the time when this episode was confirmed as confident.
// May be not relevant for television systems.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *WatcherEpisodeFaceImpl) SetStartedAt(v UtcMs) WatcherEpisodeFace {
	if s == nil {
		return nil
	}
	s.StartedAtValue = &v
	return s
}

// Details about stream related to the episode.
func (s WatcherEpisodeFaceImpl) Stream() EpisodeStreamDetailsStream {
	return s.StreamValue
}

// Details about stream related to the episode.
func (s *WatcherEpisodeFaceImpl) SetStream(v EpisodeStreamDetailsStream) WatcherEpisodeFace {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*EpisodeStreamDetailsStreamImpl); ok {
		s.StreamValue = impl
	}
	return s
}

// HTTP(s) URL that can be used for streaming API of this episode
// Example: https://streamer.example.com
func (s WatcherEpisodeFaceImpl) StreamingEndpoint() *string {
	return s.StreamingEndpointValue
}

// HTTP(s) URL that can be used for streaming API of this episode
// Example: https://streamer.example.com
func (s *WatcherEpisodeFaceImpl) SetStreamingEndpoint(v string) WatcherEpisodeFace {
	if s == nil {
		return nil
	}
	s.StreamingEndpointValue = &v
	return s
}

// Optional title of the episode. Can be used to provide a human-readable name for the episode.
// Example: Visitor at main entrance
func (s WatcherEpisodeFaceImpl) Title() *string {
	return s.TitleValue
}

// Optional title of the episode. Can be used to provide a human-readable name for the episode.
// Example: Visitor at main entrance
func (s *WatcherEpisodeFaceImpl) SetTitle(v string) WatcherEpisodeFace {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// The time of last change of the episode.
// System that processes episodes and can send them to other systems, MUST update this field
// on any changes in this episode.
// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
// this `updated_at` can be used as a sort key for fetching fresh updates.
// Consumer of the episodes can use `updated_at` in the following scenario:
// * fetch all exisiting episodes from the source
// * take biggest `updated_at` from this dataset, it will be T
// * ask source for all episodes with `updated_at > T`
// This algorithm can be used for fetching update stream from the source.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637098611e+12
func (s WatcherEpisodeFaceImpl) UpdatedAt() UtcMs {
	return s.UpdatedAtValue
}

// The time of last change of the episode.
// System that processes episodes and can send them to other systems, MUST update this field
// on any changes in this episode.
// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
// this `updated_at` can be used as a sort key for fetching fresh updates.
// Consumer of the episodes can use `updated_at` in the following scenario:
// * fetch all exisiting episodes from the source
// * take biggest `updated_at` from this dataset, it will be T
// * ask source for all episodes with `updated_at > T`
// This algorithm can be used for fetching update stream from the source.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637098611e+12
func (s *WatcherEpisodeFaceImpl) SetUpdatedAt(v UtcMs) WatcherEpisodeFace {
	if s == nil {
		return nil
	}
	s.UpdatedAtValue = v
	return s
}

// NewWatcherEpisodeGeneric creates a new WatcherEpisodeGeneric instance
func NewWatcherEpisodeGeneric() WatcherEpisodeGeneric {
	return &WatcherEpisodeGenericImpl{}
}

// The reason for closing the episode.
func (s WatcherEpisodeGenericImpl) CloseReason() *EpisodeCloseReason {
	return s.CloseReasonValue
}

// The reason for closing the episode.
func (s *WatcherEpisodeGenericImpl) SetCloseReason(v EpisodeCloseReason) WatcherEpisodeGeneric {
	if s == nil {
		return nil
	}
	s.CloseReasonValue = &v
	return s
}

// Episode emitter can decide that episode considered closed and will not grow further.
// `closed_at` MUST NOT change, it must be emitted only once.
// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
// of the episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s WatcherEpisodeGenericImpl) ClosedAt() *UtcMs {
	return s.ClosedAtValue
}

// Episode emitter can decide that episode considered closed and will not grow further.
// `closed_at` MUST NOT change, it must be emitted only once.
// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
// of the episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *WatcherEpisodeGenericImpl) SetClosedAt(v UtcMs) WatcherEpisodeGeneric {
	if s == nil {
		return nil
	}
	s.ClosedAtValue = &v
	return s
}

// Optional description of the episode. Can be used to provide additional context or details about the episode.
// Example: Person detected at the main entrance, stayed for 30 seconds
func (s WatcherEpisodeGenericImpl) Description() *string {
	return s.DescriptionValue
}

// Optional description of the episode. Can be used to provide additional context or details about the episode.
// Example: Person detected at the main entrance, stayed for 30 seconds
func (s *WatcherEpisodeGenericImpl) SetDescription(v string) WatcherEpisodeGeneric {
	if s == nil {
		return nil
	}
	s.DescriptionValue = &v
	return s
}

// Duration of the episode in milliseconds.
// Format: milliseconds (milliseconds)
// Example: 10500
func (s WatcherEpisodeGenericImpl) Duration() *Milliseconds {
	return s.DurationValue
}

// Duration of the episode in milliseconds.
// Format: milliseconds (milliseconds)
// Example: 10500
func (s *WatcherEpisodeGenericImpl) SetDuration(v Milliseconds) WatcherEpisodeGeneric {
	if s == nil {
		return nil
	}
	s.DurationValue = &v
	return s
}

// The time when the episode appeared in the service relative to the server time.
func (s WatcherEpisodeGenericImpl) EpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps {
	return s.EpisodeAppearanceTimestampsValue
}

// The time when the episode appeared in the service relative to the server time.
func (s *WatcherEpisodeGenericImpl) SetEpisodeAppearanceTimestamps(v EpisodeAppearanceTimestamps) WatcherEpisodeGeneric {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*EpisodeAppearanceTimestampsImpl); ok {
		s.EpisodeAppearanceTimestampsValue = impl
	}
	return s
}

// Unique identifier of the episode. Must be created by the system that first creates this episode.
// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
// handle very long integers.
// Format: snowflake_id (snowflake_id)
// Examples: 1.722279170848854e+18
func (s WatcherEpisodeGenericImpl) EpisodeID() SnowflakeID {
	return s.EpisodeIDValue
}

// Unique identifier of the episode. Must be created by the system that first creates this episode.
// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
// handle very long integers.
// Format: snowflake_id (snowflake_id)
// Examples: 1.722279170848854e+18
func (s *WatcherEpisodeGenericImpl) SetEpisodeID(v SnowflakeID) WatcherEpisodeGeneric {
	if s == nil {
		return nil
	}
	s.EpisodeIDValue = v
	return s
}

// Generic stream episode
func (s WatcherEpisodeGenericImpl) EpisodeType() *string {
	return s.EpisodeTypeValue
}

// Generic stream episode
func (s *WatcherEpisodeGenericImpl) SetEpisodeType(v string) WatcherEpisodeGeneric {
	if s == nil {
		return nil
	}
	s.EpisodeTypeValue = &v
	return s
}

// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
// Format: base64 (base64)
func (s WatcherEpisodeGenericImpl) FramePreview() *Base64 {
	return s.FramePreviewValue
}

// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
// Format: base64 (base64)
func (s *WatcherEpisodeGenericImpl) SetFramePreview(v Base64) WatcherEpisodeGeneric {
	if s == nil {
		return nil
	}
	s.FramePreviewValue = &v
	return s
}

// Whether the episode is added to favorites.
// Example: false
func (s WatcherEpisodeGenericImpl) IsFavorite() *bool {
	return s.IsFavoriteValue
}

// Whether the episode is added to favorites.
// Example: false
func (s *WatcherEpisodeGenericImpl) SetIsFavorite(v bool) WatcherEpisodeGeneric {
	if s == nil {
		return nil
	}
	s.IsFavoriteValue = &v
	return s
}

// Stream name on which this episode exists.
// Format: media_name (media_name)
func (s WatcherEpisodeGenericImpl) Media() MediaName {
	return s.MediaValue
}

// Stream name on which this episode exists.
// Format: media_name (media_name)
func (s *WatcherEpisodeGenericImpl) SetMedia(v MediaName) WatcherEpisodeGeneric {
	if s == nil {
		return nil
	}
	s.MediaValue = v
	return s
}

// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
// sort as by `opened_at`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s WatcherEpisodeGenericImpl) OpenedAt() UtcMs {
	return s.OpenedAtValue
}

// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
// sort as by `opened_at`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *WatcherEpisodeGenericImpl) SetOpenedAt(v UtcMs) WatcherEpisodeGeneric {
	if s == nil {
		return nil
	}
	s.OpenedAtValue = v
	return s
}

// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
// Example: onetime_token
func (s WatcherEpisodeGenericImpl) PlaybackToken() *string {
	return s.PlaybackTokenValue
}

// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
// Example: onetime_token
func (s *WatcherEpisodeGenericImpl) SetPlaybackToken(v string) WatcherEpisodeGeneric {
	if s == nil {
		return nil
	}
	s.PlaybackTokenValue = &v
	return s
}

// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Format: base64 (base64)
func (s WatcherEpisodeGenericImpl) Preview() *Base64 {
	return s.PreviewValue
}

// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Format: base64 (base64)
func (s *WatcherEpisodeGenericImpl) SetPreview(v Base64) WatcherEpisodeGeneric {
	if s == nil {
		return nil
	}
	s.PreviewValue = &v
	return s
}

// The time when the preview of this episode is available.
// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
// for details.
// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s WatcherEpisodeGenericImpl) PreviewTimestamp() *UtcMs {
	return s.PreviewTimestampValue
}

// The time when the preview of this episode is available.
// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
// for details.
// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *WatcherEpisodeGenericImpl) SetPreviewTimestamp(v UtcMs) WatcherEpisodeGeneric {
	if s == nil {
		return nil
	}
	s.PreviewTimestampValue = &v
	return s
}

// This field can be used as indication of the fact that some system have checked and ensured that
// this episode has really started at some time, that may differ from `opened_at`.
// For example video analytics will use this field for the time when this episode was confirmed as confident.
// May be not relevant for television systems.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s WatcherEpisodeGenericImpl) StartedAt() *UtcMs {
	return s.StartedAtValue
}

// This field can be used as indication of the fact that some system have checked and ensured that
// this episode has really started at some time, that may differ from `opened_at`.
// For example video analytics will use this field for the time when this episode was confirmed as confident.
// May be not relevant for television systems.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *WatcherEpisodeGenericImpl) SetStartedAt(v UtcMs) WatcherEpisodeGeneric {
	if s == nil {
		return nil
	}
	s.StartedAtValue = &v
	return s
}

// Details about stream related to the episode.
func (s WatcherEpisodeGenericImpl) Stream() EpisodeStreamDetailsStream {
	return s.StreamValue
}

// Details about stream related to the episode.
func (s *WatcherEpisodeGenericImpl) SetStream(v EpisodeStreamDetailsStream) WatcherEpisodeGeneric {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*EpisodeStreamDetailsStreamImpl); ok {
		s.StreamValue = impl
	}
	return s
}

// HTTP(s) URL that can be used for streaming API of this episode
// Example: https://streamer.example.com
func (s WatcherEpisodeGenericImpl) StreamingEndpoint() *string {
	return s.StreamingEndpointValue
}

// HTTP(s) URL that can be used for streaming API of this episode
// Example: https://streamer.example.com
func (s *WatcherEpisodeGenericImpl) SetStreamingEndpoint(v string) WatcherEpisodeGeneric {
	if s == nil {
		return nil
	}
	s.StreamingEndpointValue = &v
	return s
}

// Optional title of the episode. Can be used to provide a human-readable name for the episode.
// Example: Visitor at main entrance
func (s WatcherEpisodeGenericImpl) Title() *string {
	return s.TitleValue
}

// Optional title of the episode. Can be used to provide a human-readable name for the episode.
// Example: Visitor at main entrance
func (s *WatcherEpisodeGenericImpl) SetTitle(v string) WatcherEpisodeGeneric {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// The time of last change of the episode.
// System that processes episodes and can send them to other systems, MUST update this field
// on any changes in this episode.
// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
// this `updated_at` can be used as a sort key for fetching fresh updates.
// Consumer of the episodes can use `updated_at` in the following scenario:
// * fetch all exisiting episodes from the source
// * take biggest `updated_at` from this dataset, it will be T
// * ask source for all episodes with `updated_at > T`
// This algorithm can be used for fetching update stream from the source.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637098611e+12
func (s WatcherEpisodeGenericImpl) UpdatedAt() UtcMs {
	return s.UpdatedAtValue
}

// The time of last change of the episode.
// System that processes episodes and can send them to other systems, MUST update this field
// on any changes in this episode.
// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
// this `updated_at` can be used as a sort key for fetching fresh updates.
// Consumer of the episodes can use `updated_at` in the following scenario:
// * fetch all exisiting episodes from the source
// * take biggest `updated_at` from this dataset, it will be T
// * ask source for all episodes with `updated_at > T`
// This algorithm can be used for fetching update stream from the source.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637098611e+12
func (s *WatcherEpisodeGenericImpl) SetUpdatedAt(v UtcMs) WatcherEpisodeGeneric {
	if s == nil {
		return nil
	}
	s.UpdatedAtValue = v
	return s
}

// NewWatcherEpisodeHuman creates a new WatcherEpisodeHuman instance
func NewWatcherEpisodeHuman() WatcherEpisodeHuman {
	return &WatcherEpisodeHumanImpl{}
}

// The reason for closing the episode.
func (s WatcherEpisodeHumanImpl) CloseReason() *EpisodeCloseReason {
	return s.CloseReasonValue
}

// The reason for closing the episode.
func (s *WatcherEpisodeHumanImpl) SetCloseReason(v EpisodeCloseReason) WatcherEpisodeHuman {
	if s == nil {
		return nil
	}
	s.CloseReasonValue = &v
	return s
}

// Episode emitter can decide that episode considered closed and will not grow further.
// `closed_at` MUST NOT change, it must be emitted only once.
// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
// of the episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s WatcherEpisodeHumanImpl) ClosedAt() *UtcMs {
	return s.ClosedAtValue
}

// Episode emitter can decide that episode considered closed and will not grow further.
// `closed_at` MUST NOT change, it must be emitted only once.
// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
// of the episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *WatcherEpisodeHumanImpl) SetClosedAt(v UtcMs) WatcherEpisodeHuman {
	if s == nil {
		return nil
	}
	s.ClosedAtValue = &v
	return s
}

// Optional description of the episode. Can be used to provide additional context or details about the episode.
// Example: Person detected at the main entrance, stayed for 30 seconds
func (s WatcherEpisodeHumanImpl) Description() *string {
	return s.DescriptionValue
}

// Optional description of the episode. Can be used to provide additional context or details about the episode.
// Example: Person detected at the main entrance, stayed for 30 seconds
func (s *WatcherEpisodeHumanImpl) SetDescription(v string) WatcherEpisodeHuman {
	if s == nil {
		return nil
	}
	s.DescriptionValue = &v
	return s
}

// Detections associated with this episode
func (s WatcherEpisodeHumanImpl) Detections() []VisionDetectedObjectBase {
	if s.DetectionsValue == nil {
		return nil
	}
	result := make([]VisionDetectedObjectBase, len(s.DetectionsValue))
	for i, item := range s.DetectionsValue {
		result[i] = item
	}
	return result
}

// Detections associated with this episode
func (s *WatcherEpisodeHumanImpl) SetDetections(v []VisionDetectedObjectBase) WatcherEpisodeHuman {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*VisionDetectedObjectBaseImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*VisionDetectedObjectBaseImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.DetectionsValue = impl
	}
	return s
}

// Duration of the episode in milliseconds.
// Format: milliseconds (milliseconds)
// Example: 10500
func (s WatcherEpisodeHumanImpl) Duration() *Milliseconds {
	return s.DurationValue
}

// Duration of the episode in milliseconds.
// Format: milliseconds (milliseconds)
// Example: 10500
func (s *WatcherEpisodeHumanImpl) SetDuration(v Milliseconds) WatcherEpisodeHuman {
	if s == nil {
		return nil
	}
	s.DurationValue = &v
	return s
}

// The time when the episode appeared in the service relative to the server time.
func (s WatcherEpisodeHumanImpl) EpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps {
	return s.EpisodeAppearanceTimestampsValue
}

// The time when the episode appeared in the service relative to the server time.
func (s *WatcherEpisodeHumanImpl) SetEpisodeAppearanceTimestamps(v EpisodeAppearanceTimestamps) WatcherEpisodeHuman {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*EpisodeAppearanceTimestampsImpl); ok {
		s.EpisodeAppearanceTimestampsValue = impl
	}
	return s
}

// Unique identifier of the episode. Must be created by the system that first creates this episode.
// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
// handle very long integers.
// Format: snowflake_id (snowflake_id)
// Examples: 1.722279170848854e+18
func (s WatcherEpisodeHumanImpl) EpisodeID() SnowflakeID {
	return s.EpisodeIDValue
}

// Unique identifier of the episode. Must be created by the system that first creates this episode.
// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
// handle very long integers.
// Format: snowflake_id (snowflake_id)
// Examples: 1.722279170848854e+18
func (s *WatcherEpisodeHumanImpl) SetEpisodeID(v SnowflakeID) WatcherEpisodeHuman {
	if s == nil {
		return nil
	}
	s.EpisodeIDValue = v
	return s
}

// Human is detected
func (s WatcherEpisodeHumanImpl) EpisodeType() *string {
	return s.EpisodeTypeValue
}

// Human is detected
func (s *WatcherEpisodeHumanImpl) SetEpisodeType(v string) WatcherEpisodeHuman {
	if s == nil {
		return nil
	}
	s.EpisodeTypeValue = &v
	return s
}

// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
// Format: base64 (base64)
func (s WatcherEpisodeHumanImpl) FramePreview() *Base64 {
	return s.FramePreviewValue
}

// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
// Format: base64 (base64)
func (s *WatcherEpisodeHumanImpl) SetFramePreview(v Base64) WatcherEpisodeHuman {
	if s == nil {
		return nil
	}
	s.FramePreviewValue = &v
	return s
}

// Whether the episode is added to favorites.
// Example: false
func (s WatcherEpisodeHumanImpl) IsFavorite() *bool {
	return s.IsFavoriteValue
}

// Whether the episode is added to favorites.
// Example: false
func (s *WatcherEpisodeHumanImpl) SetIsFavorite(v bool) WatcherEpisodeHuman {
	if s == nil {
		return nil
	}
	s.IsFavoriteValue = &v
	return s
}

// Stream name on which this episode exists.
// Format: media_name (media_name)
func (s WatcherEpisodeHumanImpl) Media() MediaName {
	return s.MediaValue
}

// Stream name on which this episode exists.
// Format: media_name (media_name)
func (s *WatcherEpisodeHumanImpl) SetMedia(v MediaName) WatcherEpisodeHuman {
	if s == nil {
		return nil
	}
	s.MediaValue = v
	return s
}

// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
// sort as by `opened_at`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s WatcherEpisodeHumanImpl) OpenedAt() UtcMs {
	return s.OpenedAtValue
}

// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
// sort as by `opened_at`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *WatcherEpisodeHumanImpl) SetOpenedAt(v UtcMs) WatcherEpisodeHuman {
	if s == nil {
		return nil
	}
	s.OpenedAtValue = v
	return s
}

// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
// Example: onetime_token
func (s WatcherEpisodeHumanImpl) PlaybackToken() *string {
	return s.PlaybackTokenValue
}

// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
// Example: onetime_token
func (s *WatcherEpisodeHumanImpl) SetPlaybackToken(v string) WatcherEpisodeHuman {
	if s == nil {
		return nil
	}
	s.PlaybackTokenValue = &v
	return s
}

// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Format: base64 (base64)
func (s WatcherEpisodeHumanImpl) Preview() *Base64 {
	return s.PreviewValue
}

// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Format: base64 (base64)
func (s *WatcherEpisodeHumanImpl) SetPreview(v Base64) WatcherEpisodeHuman {
	if s == nil {
		return nil
	}
	s.PreviewValue = &v
	return s
}

// The time when the preview of this episode is available.
// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
// for details.
// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s WatcherEpisodeHumanImpl) PreviewTimestamp() *UtcMs {
	return s.PreviewTimestampValue
}

// The time when the preview of this episode is available.
// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
// for details.
// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *WatcherEpisodeHumanImpl) SetPreviewTimestamp(v UtcMs) WatcherEpisodeHuman {
	if s == nil {
		return nil
	}
	s.PreviewTimestampValue = &v
	return s
}

// This field can be used as indication of the fact that some system have checked and ensured that
// this episode has really started at some time, that may differ from `opened_at`.
// For example video analytics will use this field for the time when this episode was confirmed as confident.
// May be not relevant for television systems.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s WatcherEpisodeHumanImpl) StartedAt() *UtcMs {
	return s.StartedAtValue
}

// This field can be used as indication of the fact that some system have checked and ensured that
// this episode has really started at some time, that may differ from `opened_at`.
// For example video analytics will use this field for the time when this episode was confirmed as confident.
// May be not relevant for television systems.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *WatcherEpisodeHumanImpl) SetStartedAt(v UtcMs) WatcherEpisodeHuman {
	if s == nil {
		return nil
	}
	s.StartedAtValue = &v
	return s
}

// Details about stream related to the episode.
func (s WatcherEpisodeHumanImpl) Stream() EpisodeStreamDetailsStream {
	return s.StreamValue
}

// Details about stream related to the episode.
func (s *WatcherEpisodeHumanImpl) SetStream(v EpisodeStreamDetailsStream) WatcherEpisodeHuman {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*EpisodeStreamDetailsStreamImpl); ok {
		s.StreamValue = impl
	}
	return s
}

// HTTP(s) URL that can be used for streaming API of this episode
// Example: https://streamer.example.com
func (s WatcherEpisodeHumanImpl) StreamingEndpoint() *string {
	return s.StreamingEndpointValue
}

// HTTP(s) URL that can be used for streaming API of this episode
// Example: https://streamer.example.com
func (s *WatcherEpisodeHumanImpl) SetStreamingEndpoint(v string) WatcherEpisodeHuman {
	if s == nil {
		return nil
	}
	s.StreamingEndpointValue = &v
	return s
}

// Optional title of the episode. Can be used to provide a human-readable name for the episode.
// Example: Visitor at main entrance
func (s WatcherEpisodeHumanImpl) Title() *string {
	return s.TitleValue
}

// Optional title of the episode. Can be used to provide a human-readable name for the episode.
// Example: Visitor at main entrance
func (s *WatcherEpisodeHumanImpl) SetTitle(v string) WatcherEpisodeHuman {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// The time of last change of the episode.
// System that processes episodes and can send them to other systems, MUST update this field
// on any changes in this episode.
// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
// this `updated_at` can be used as a sort key for fetching fresh updates.
// Consumer of the episodes can use `updated_at` in the following scenario:
// * fetch all exisiting episodes from the source
// * take biggest `updated_at` from this dataset, it will be T
// * ask source for all episodes with `updated_at > T`
// This algorithm can be used for fetching update stream from the source.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637098611e+12
func (s WatcherEpisodeHumanImpl) UpdatedAt() UtcMs {
	return s.UpdatedAtValue
}

// The time of last change of the episode.
// System that processes episodes and can send them to other systems, MUST update this field
// on any changes in this episode.
// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
// this `updated_at` can be used as a sort key for fetching fresh updates.
// Consumer of the episodes can use `updated_at` in the following scenario:
// * fetch all exisiting episodes from the source
// * take biggest `updated_at` from this dataset, it will be T
// * ask source for all episodes with `updated_at > T`
// This algorithm can be used for fetching update stream from the source.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637098611e+12
func (s *WatcherEpisodeHumanImpl) SetUpdatedAt(v UtcMs) WatcherEpisodeHuman {
	if s == nil {
		return nil
	}
	s.UpdatedAtValue = v
	return s
}

// NewWatcherEpisodeQrCode creates a new WatcherEpisodeQrCode instance
func NewWatcherEpisodeQrCode() WatcherEpisodeQrCode {
	return &WatcherEpisodeQrCodeImpl{}
}

// The reason for closing the episode.
func (s WatcherEpisodeQrCodeImpl) CloseReason() *EpisodeCloseReason {
	return s.CloseReasonValue
}

// The reason for closing the episode.
func (s *WatcherEpisodeQrCodeImpl) SetCloseReason(v EpisodeCloseReason) WatcherEpisodeQrCode {
	if s == nil {
		return nil
	}
	s.CloseReasonValue = &v
	return s
}

// Episode emitter can decide that episode considered closed and will not grow further.
// `closed_at` MUST NOT change, it must be emitted only once.
// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
// of the episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s WatcherEpisodeQrCodeImpl) ClosedAt() *UtcMs {
	return s.ClosedAtValue
}

// Episode emitter can decide that episode considered closed and will not grow further.
// `closed_at` MUST NOT change, it must be emitted only once.
// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
// of the episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *WatcherEpisodeQrCodeImpl) SetClosedAt(v UtcMs) WatcherEpisodeQrCode {
	if s == nil {
		return nil
	}
	s.ClosedAtValue = &v
	return s
}

// Optional description of the episode. Can be used to provide additional context or details about the episode.
// Example: Person detected at the main entrance, stayed for 30 seconds
func (s WatcherEpisodeQrCodeImpl) Description() *string {
	return s.DescriptionValue
}

// Optional description of the episode. Can be used to provide additional context or details about the episode.
// Example: Person detected at the main entrance, stayed for 30 seconds
func (s *WatcherEpisodeQrCodeImpl) SetDescription(v string) WatcherEpisodeQrCode {
	if s == nil {
		return nil
	}
	s.DescriptionValue = &v
	return s
}

// Duration of the episode in milliseconds.
// Format: milliseconds (milliseconds)
// Example: 10500
func (s WatcherEpisodeQrCodeImpl) Duration() *Milliseconds {
	return s.DurationValue
}

// Duration of the episode in milliseconds.
// Format: milliseconds (milliseconds)
// Example: 10500
func (s *WatcherEpisodeQrCodeImpl) SetDuration(v Milliseconds) WatcherEpisodeQrCode {
	if s == nil {
		return nil
	}
	s.DurationValue = &v
	return s
}

// The time when the episode appeared in the service relative to the server time.
func (s WatcherEpisodeQrCodeImpl) EpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps {
	return s.EpisodeAppearanceTimestampsValue
}

// The time when the episode appeared in the service relative to the server time.
func (s *WatcherEpisodeQrCodeImpl) SetEpisodeAppearanceTimestamps(v EpisodeAppearanceTimestamps) WatcherEpisodeQrCode {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*EpisodeAppearanceTimestampsImpl); ok {
		s.EpisodeAppearanceTimestampsValue = impl
	}
	return s
}

// Unique identifier of the episode. Must be created by the system that first creates this episode.
// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
// handle very long integers.
// Format: snowflake_id (snowflake_id)
// Examples: 1.722279170848854e+18
func (s WatcherEpisodeQrCodeImpl) EpisodeID() SnowflakeID {
	return s.EpisodeIDValue
}

// Unique identifier of the episode. Must be created by the system that first creates this episode.
// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
// handle very long integers.
// Format: snowflake_id (snowflake_id)
// Examples: 1.722279170848854e+18
func (s *WatcherEpisodeQrCodeImpl) SetEpisodeID(v SnowflakeID) WatcherEpisodeQrCode {
	if s == nil {
		return nil
	}
	s.EpisodeIDValue = v
	return s
}

// QR-code is detected
func (s WatcherEpisodeQrCodeImpl) EpisodeType() *string {
	return s.EpisodeTypeValue
}

// QR-code is detected
func (s *WatcherEpisodeQrCodeImpl) SetEpisodeType(v string) WatcherEpisodeQrCode {
	if s == nil {
		return nil
	}
	s.EpisodeTypeValue = &v
	return s
}

// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
// Format: base64 (base64)
func (s WatcherEpisodeQrCodeImpl) FramePreview() *Base64 {
	return s.FramePreviewValue
}

// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
// Format: base64 (base64)
func (s *WatcherEpisodeQrCodeImpl) SetFramePreview(v Base64) WatcherEpisodeQrCode {
	if s == nil {
		return nil
	}
	s.FramePreviewValue = &v
	return s
}

// Whether the episode is added to favorites.
// Example: false
func (s WatcherEpisodeQrCodeImpl) IsFavorite() *bool {
	return s.IsFavoriteValue
}

// Whether the episode is added to favorites.
// Example: false
func (s *WatcherEpisodeQrCodeImpl) SetIsFavorite(v bool) WatcherEpisodeQrCode {
	if s == nil {
		return nil
	}
	s.IsFavoriteValue = &v
	return s
}

// Stream name on which this episode exists.
// Format: media_name (media_name)
func (s WatcherEpisodeQrCodeImpl) Media() MediaName {
	return s.MediaValue
}

// Stream name on which this episode exists.
// Format: media_name (media_name)
func (s *WatcherEpisodeQrCodeImpl) SetMedia(v MediaName) WatcherEpisodeQrCode {
	if s == nil {
		return nil
	}
	s.MediaValue = v
	return s
}

// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
// sort as by `opened_at`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s WatcherEpisodeQrCodeImpl) OpenedAt() UtcMs {
	return s.OpenedAtValue
}

// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
// sort as by `opened_at`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *WatcherEpisodeQrCodeImpl) SetOpenedAt(v UtcMs) WatcherEpisodeQrCode {
	if s == nil {
		return nil
	}
	s.OpenedAtValue = v
	return s
}

// Raw data extracted from QR-code
// Example: WIFI:T:WPA;S:MyOfficeWiFi;P:Mypassword;H:;
func (s WatcherEpisodeQrCodeImpl) Payload() *string {
	return s.PayloadValue
}

// Raw data extracted from QR-code
// Example: WIFI:T:WPA;S:MyOfficeWiFi;P:Mypassword;H:;
func (s *WatcherEpisodeQrCodeImpl) SetPayload(v string) WatcherEpisodeQrCode {
	if s == nil {
		return nil
	}
	s.PayloadValue = &v
	return s
}

// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
// Example: onetime_token
func (s WatcherEpisodeQrCodeImpl) PlaybackToken() *string {
	return s.PlaybackTokenValue
}

// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
// Example: onetime_token
func (s *WatcherEpisodeQrCodeImpl) SetPlaybackToken(v string) WatcherEpisodeQrCode {
	if s == nil {
		return nil
	}
	s.PlaybackTokenValue = &v
	return s
}

// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Format: base64 (base64)
func (s WatcherEpisodeQrCodeImpl) Preview() *Base64 {
	return s.PreviewValue
}

// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Format: base64 (base64)
func (s *WatcherEpisodeQrCodeImpl) SetPreview(v Base64) WatcherEpisodeQrCode {
	if s == nil {
		return nil
	}
	s.PreviewValue = &v
	return s
}

// The time when the preview of this episode is available.
// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
// for details.
// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s WatcherEpisodeQrCodeImpl) PreviewTimestamp() *UtcMs {
	return s.PreviewTimestampValue
}

// The time when the preview of this episode is available.
// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
// for details.
// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *WatcherEpisodeQrCodeImpl) SetPreviewTimestamp(v UtcMs) WatcherEpisodeQrCode {
	if s == nil {
		return nil
	}
	s.PreviewTimestampValue = &v
	return s
}

// This field can be used as indication of the fact that some system have checked and ensured that
// this episode has really started at some time, that may differ from `opened_at`.
// For example video analytics will use this field for the time when this episode was confirmed as confident.
// May be not relevant for television systems.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s WatcherEpisodeQrCodeImpl) StartedAt() *UtcMs {
	return s.StartedAtValue
}

// This field can be used as indication of the fact that some system have checked and ensured that
// this episode has really started at some time, that may differ from `opened_at`.
// For example video analytics will use this field for the time when this episode was confirmed as confident.
// May be not relevant for television systems.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *WatcherEpisodeQrCodeImpl) SetStartedAt(v UtcMs) WatcherEpisodeQrCode {
	if s == nil {
		return nil
	}
	s.StartedAtValue = &v
	return s
}

// Details about stream related to the episode.
func (s WatcherEpisodeQrCodeImpl) Stream() EpisodeStreamDetailsStream {
	return s.StreamValue
}

// Details about stream related to the episode.
func (s *WatcherEpisodeQrCodeImpl) SetStream(v EpisodeStreamDetailsStream) WatcherEpisodeQrCode {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*EpisodeStreamDetailsStreamImpl); ok {
		s.StreamValue = impl
	}
	return s
}

// HTTP(s) URL that can be used for streaming API of this episode
// Example: https://streamer.example.com
func (s WatcherEpisodeQrCodeImpl) StreamingEndpoint() *string {
	return s.StreamingEndpointValue
}

// HTTP(s) URL that can be used for streaming API of this episode
// Example: https://streamer.example.com
func (s *WatcherEpisodeQrCodeImpl) SetStreamingEndpoint(v string) WatcherEpisodeQrCode {
	if s == nil {
		return nil
	}
	s.StreamingEndpointValue = &v
	return s
}

// Optional title of the episode. Can be used to provide a human-readable name for the episode.
// Example: Visitor at main entrance
func (s WatcherEpisodeQrCodeImpl) Title() *string {
	return s.TitleValue
}

// Optional title of the episode. Can be used to provide a human-readable name for the episode.
// Example: Visitor at main entrance
func (s *WatcherEpisodeQrCodeImpl) SetTitle(v string) WatcherEpisodeQrCode {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// The time of last change of the episode.
// System that processes episodes and can send them to other systems, MUST update this field
// on any changes in this episode.
// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
// this `updated_at` can be used as a sort key for fetching fresh updates.
// Consumer of the episodes can use `updated_at` in the following scenario:
// * fetch all exisiting episodes from the source
// * take biggest `updated_at` from this dataset, it will be T
// * ask source for all episodes with `updated_at > T`
// This algorithm can be used for fetching update stream from the source.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637098611e+12
func (s WatcherEpisodeQrCodeImpl) UpdatedAt() UtcMs {
	return s.UpdatedAtValue
}

// The time of last change of the episode.
// System that processes episodes and can send them to other systems, MUST update this field
// on any changes in this episode.
// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
// this `updated_at` can be used as a sort key for fetching fresh updates.
// Consumer of the episodes can use `updated_at` in the following scenario:
// * fetch all exisiting episodes from the source
// * take biggest `updated_at` from this dataset, it will be T
// * ask source for all episodes with `updated_at > T`
// This algorithm can be used for fetching update stream from the source.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637098611e+12
func (s *WatcherEpisodeQrCodeImpl) SetUpdatedAt(v UtcMs) WatcherEpisodeQrCode {
	if s == nil {
		return nil
	}
	s.UpdatedAtValue = v
	return s
}

// NewWatcherEpisodeVehicle creates a new WatcherEpisodeVehicle instance
func NewWatcherEpisodeVehicle() WatcherEpisodeVehicle {
	return &WatcherEpisodeVehicleImpl{}
}

// The reason for closing the episode.
func (s WatcherEpisodeVehicleImpl) CloseReason() *EpisodeCloseReason {
	return s.CloseReasonValue
}

// The reason for closing the episode.
func (s *WatcherEpisodeVehicleImpl) SetCloseReason(v EpisodeCloseReason) WatcherEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.CloseReasonValue = &v
	return s
}

// Episode emitter can decide that episode considered closed and will not grow further.
// `closed_at` MUST NOT change, it must be emitted only once.
// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
// of the episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s WatcherEpisodeVehicleImpl) ClosedAt() *UtcMs {
	return s.ClosedAtValue
}

// Episode emitter can decide that episode considered closed and will not grow further.
// `closed_at` MUST NOT change, it must be emitted only once.
// Episode can live without `closed_at`, in this case you should use `updated_at` as the last time
// of the episode.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *WatcherEpisodeVehicleImpl) SetClosedAt(v UtcMs) WatcherEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.ClosedAtValue = &v
	return s
}

// Optional description of the episode. Can be used to provide additional context or details about the episode.
// Example: Person detected at the main entrance, stayed for 30 seconds
func (s WatcherEpisodeVehicleImpl) Description() *string {
	return s.DescriptionValue
}

// Optional description of the episode. Can be used to provide additional context or details about the episode.
// Example: Person detected at the main entrance, stayed for 30 seconds
func (s *WatcherEpisodeVehicleImpl) SetDescription(v string) WatcherEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.DescriptionValue = &v
	return s
}

// Detections associated with this episode
func (s WatcherEpisodeVehicleImpl) Detections() []any {
	return s.DetectionsValue
}

// Detections associated with this episode
func (s *WatcherEpisodeVehicleImpl) SetDetections(v []any) WatcherEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.DetectionsValue = v
	return s
}

// Duration of the episode in milliseconds.
// Format: milliseconds (milliseconds)
// Example: 10500
func (s WatcherEpisodeVehicleImpl) Duration() *Milliseconds {
	return s.DurationValue
}

// Duration of the episode in milliseconds.
// Format: milliseconds (milliseconds)
// Example: 10500
func (s *WatcherEpisodeVehicleImpl) SetDuration(v Milliseconds) WatcherEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.DurationValue = &v
	return s
}

// The time when the episode appeared in the service relative to the server time.
func (s WatcherEpisodeVehicleImpl) EpisodeAppearanceTimestamps() EpisodeAppearanceTimestamps {
	return s.EpisodeAppearanceTimestampsValue
}

// The time when the episode appeared in the service relative to the server time.
func (s *WatcherEpisodeVehicleImpl) SetEpisodeAppearanceTimestamps(v EpisodeAppearanceTimestamps) WatcherEpisodeVehicle {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*EpisodeAppearanceTimestampsImpl); ok {
		s.EpisodeAppearanceTimestampsValue = impl
	}
	return s
}

// Unique identifier of the episode. Must be created by the system that first creates this episode.
// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
// handle very long integers.
// Format: snowflake_id (snowflake_id)
// Examples: 1.722279170848854e+18
func (s WatcherEpisodeVehicleImpl) EpisodeID() SnowflakeID {
	return s.EpisodeIDValue
}

// Unique identifier of the episode. Must be created by the system that first creates this episode.
// Please, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),
// so you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly
// handle very long integers.
// Format: snowflake_id (snowflake_id)
// Examples: 1.722279170848854e+18
func (s *WatcherEpisodeVehicleImpl) SetEpisodeID(v SnowflakeID) WatcherEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.EpisodeIDValue = v
	return s
}

// Vehicle is detected
func (s WatcherEpisodeVehicleImpl) EpisodeType() *string {
	return s.EpisodeTypeValue
}

// Vehicle is detected
func (s *WatcherEpisodeVehicleImpl) SetEpisodeType(v string) WatcherEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.EpisodeTypeValue = &v
	return s
}

// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
// Format: base64 (base64)
func (s WatcherEpisodeVehicleImpl) FramePreview() *Base64 {
	return s.FramePreviewValue
}

// Small inline image of the entire frame used for direct display in web-browser UI or mobile application.
// Frame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.
// Format: base64 (base64)
func (s *WatcherEpisodeVehicleImpl) SetFramePreview(v Base64) WatcherEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.FramePreviewValue = &v
	return s
}

// Whether the episode is added to favorites.
// Example: false
func (s WatcherEpisodeVehicleImpl) IsFavorite() *bool {
	return s.IsFavoriteValue
}

// Whether the episode is added to favorites.
// Example: false
func (s *WatcherEpisodeVehicleImpl) SetIsFavorite(v bool) WatcherEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.IsFavoriteValue = &v
	return s
}

// Indicates if no license plate is detected on this vehicle
func (s WatcherEpisodeVehicleImpl) LicensePlateMissing() *bool {
	return s.LicensePlateMissingValue
}

// Indicates if no license plate is detected on this vehicle
func (s *WatcherEpisodeVehicleImpl) SetLicensePlateMissing(v bool) WatcherEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.LicensePlateMissingValue = &v
	return s
}

// Recognized vehicle's license plate number
func (s WatcherEpisodeVehicleImpl) LicensePlateText() *string {
	return s.LicensePlateTextValue
}

// Recognized vehicle's license plate number
func (s *WatcherEpisodeVehicleImpl) SetLicensePlateText(v string) WatcherEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.LicensePlateTextValue = &v
	return s
}

// Stream name on which this episode exists.
// Format: media_name (media_name)
func (s WatcherEpisodeVehicleImpl) Media() MediaName {
	return s.MediaValue
}

// Stream name on which this episode exists.
// Format: media_name (media_name)
func (s *WatcherEpisodeVehicleImpl) SetMedia(v MediaName) WatcherEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.MediaValue = v
	return s
}

// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
// sort as by `opened_at`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s WatcherEpisodeVehicleImpl) OpenedAt() UtcMs {
	return s.OpenedAtValue
}

// The time when this episode was created. Naming is standard for whole flussonic ecosystem.
// Usually this time will be the same as `started_at`, but can differ, refer to the description of that field.
// The value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same
// sort as by `opened_at`
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *WatcherEpisodeVehicleImpl) SetOpenedAt(v UtcMs) WatcherEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.OpenedAtValue = v
	return s
}

// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
// Example: onetime_token
func (s WatcherEpisodeVehicleImpl) PlaybackToken() *string {
	return s.PlaybackTokenValue
}

// Temporary token for playback requests (Media Server Streaming API, Central Streaming API).
// Example: onetime_token
func (s *WatcherEpisodeVehicleImpl) SetPlaybackToken(v string) WatcherEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.PlaybackTokenValue = &v
	return s
}

// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Preview contains an image of vehicle's license plate and has a resolution about 160 x 64 pixels with maximum size about 10 kilobytes.
// Format: base64 (base64)
func (s WatcherEpisodeVehicleImpl) Preview() Base64 {
	return s.PreviewValue
}

// Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.
// Preview contains an image of vehicle's license plate and has a resolution about 160 x 64 pixels with maximum size about 10 kilobytes.
// Format: base64 (base64)
func (s *WatcherEpisodeVehicleImpl) SetPreview(v Base64) WatcherEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.PreviewValue = v
	return s
}

// The time when the preview of this episode is available.
// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
// for details.
// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s WatcherEpisodeVehicleImpl) PreviewTimestamp() *UtcMs {
	return s.PreviewTimestampValue
}

// The time when the preview of this episode is available.
// Use it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).
// Visit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article
// and [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference
// for details.
// This field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *WatcherEpisodeVehicleImpl) SetPreviewTimestamp(v UtcMs) WatcherEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.PreviewTimestampValue = &v
	return s
}

// This field can be used as indication of the fact that some system have checked and ensured that
// this episode has really started at some time, that may differ from `opened_at`.
// For example video analytics will use this field for the time when this episode was confirmed as confident.
// May be not relevant for television systems.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s WatcherEpisodeVehicleImpl) StartedAt() *UtcMs {
	return s.StartedAtValue
}

// This field can be used as indication of the fact that some system have checked and ensured that
// this episode has really started at some time, that may differ from `opened_at`.
// For example video analytics will use this field for the time when this episode was confirmed as confident.
// May be not relevant for television systems.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *WatcherEpisodeVehicleImpl) SetStartedAt(v UtcMs) WatcherEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.StartedAtValue = &v
	return s
}

// Details about stream related to the episode.
func (s WatcherEpisodeVehicleImpl) Stream() EpisodeStreamDetailsStream {
	return s.StreamValue
}

// Details about stream related to the episode.
func (s *WatcherEpisodeVehicleImpl) SetStream(v EpisodeStreamDetailsStream) WatcherEpisodeVehicle {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*EpisodeStreamDetailsStreamImpl); ok {
		s.StreamValue = impl
	}
	return s
}

// HTTP(s) URL that can be used for streaming API of this episode
// Example: https://streamer.example.com
func (s WatcherEpisodeVehicleImpl) StreamingEndpoint() *string {
	return s.StreamingEndpointValue
}

// HTTP(s) URL that can be used for streaming API of this episode
// Example: https://streamer.example.com
func (s *WatcherEpisodeVehicleImpl) SetStreamingEndpoint(v string) WatcherEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.StreamingEndpointValue = &v
	return s
}

// Optional title of the episode. Can be used to provide a human-readable name for the episode.
// Example: Visitor at main entrance
func (s WatcherEpisodeVehicleImpl) Title() *string {
	return s.TitleValue
}

// Optional title of the episode. Can be used to provide a human-readable name for the episode.
// Example: Visitor at main entrance
func (s *WatcherEpisodeVehicleImpl) SetTitle(v string) WatcherEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.TitleValue = &v
	return s
}

// The time of last change of the episode.
// System that processes episodes and can send them to other systems, MUST update this field
// on any changes in this episode.
// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
// this `updated_at` can be used as a sort key for fetching fresh updates.
// Consumer of the episodes can use `updated_at` in the following scenario:
// * fetch all exisiting episodes from the source
// * take biggest `updated_at` from this dataset, it will be T
// * ask source for all episodes with `updated_at > T`
// This algorithm can be used for fetching update stream from the source.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637098611e+12
func (s WatcherEpisodeVehicleImpl) UpdatedAt() UtcMs {
	return s.UpdatedAtValue
}

// The time of last change of the episode.
// System that processes episodes and can send them to other systems, MUST update this field
// on any changes in this episode.
// This field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that
// this `updated_at` can be used as a sort key for fetching fresh updates.
// Consumer of the episodes can use `updated_at` in the following scenario:
// * fetch all exisiting episodes from the source
// * take biggest `updated_at` from this dataset, it will be T
// * ask source for all episodes with `updated_at > T`
// This algorithm can be used for fetching update stream from the source.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637098611e+12
func (s *WatcherEpisodeVehicleImpl) SetUpdatedAt(v UtcMs) WatcherEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.UpdatedAtValue = v
	return s
}

// Emergency type of the vehicle.
func (s WatcherEpisodeVehicleImpl) VehicleEmergencySubtype() *VisionVehicleEmergencySubtype {
	return s.VehicleEmergencySubtypeValue
}

// Emergency type of the vehicle.
func (s *WatcherEpisodeVehicleImpl) SetVehicleEmergencySubtype(v VisionVehicleEmergencySubtype) WatcherEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.VehicleEmergencySubtypeValue = &v
	return s
}

// Shows from which side the vehicle was detected.
func (s WatcherEpisodeVehicleImpl) VehicleFacingSide() *VisionVehicleFacingSide {
	return s.VehicleFacingSideValue
}

// Shows from which side the vehicle was detected.
func (s *WatcherEpisodeVehicleImpl) SetVehicleFacingSide(v VisionVehicleFacingSide) WatcherEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.VehicleFacingSideValue = &v
	return s
}

// The purpose of the vehicle, e.g. emergency or regular.
func (s WatcherEpisodeVehicleImpl) VehiclePurpose() *VisionVehiclePurpose {
	return s.VehiclePurposeValue
}

// The purpose of the vehicle, e.g. emergency or regular.
func (s *WatcherEpisodeVehicleImpl) SetVehiclePurpose(v VisionVehiclePurpose) WatcherEpisodeVehicle {
	if s == nil {
		return nil
	}
	s.VehiclePurposeValue = &v
	return s
}

// NewWatcherStreamConfig creates a new WatcherStreamConfig instance
func NewWatcherStreamConfig() WatcherStreamConfig {
	return &WatcherStreamConfigImpl{}
}

// Audio settings for the stream.
func (s WatcherStreamConfigImpl) Audio() WatcherStreamConfigAudio {
	return s.AudioValue
}

// Audio settings for the stream.
func (s *WatcherStreamConfigImpl) SetAudio(v WatcherStreamConfigAudio) WatcherStreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*WatcherStreamConfigAudioImpl); ok {
		s.AudioValue = impl
	}
	return s
}

// A publishable stream.
// Example: false
func (s WatcherStreamConfigImpl) CanPublish() *bool {
	return s.CanPublishValue
}

// A publishable stream.
// Example: false
func (s *WatcherStreamConfigImpl) SetCanPublish(v bool) WatcherStreamConfig {
	if s == nil {
		return nil
	}
	s.CanPublishValue = &v
	return s
}

// Camera coordinates on a map or a floor plan.
func (s WatcherStreamConfigImpl) Coordinates() MapSpec {
	return s.CoordinatesValue
}

// Camera coordinates on a map or a floor plan.
func (s *WatcherStreamConfigImpl) SetCoordinates(v MapSpec) WatcherStreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*MapSpecImpl); ok {
		s.CoordinatesValue = impl
	}
	return s
}

// The date and time when the steam was created.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.672531199e+12
func (s WatcherStreamConfigImpl) CreatedAt() *UtcMs {
	return s.CreatedAtValue
}

// The date and time when the steam was created.
// Format: utc_ms (Unix timestamp in milliseconds)
// Example: 1.672531199e+12
func (s *WatcherStreamConfigImpl) SetCreatedAt(v UtcMs) WatcherStreamConfig {
	if s == nil {
		return nil
	}
	s.CreatedAtValue = &v
	return s
}

// Duration of the firmware update. If this field is present, the update process is ongoing.
// Format: milliseconds (milliseconds)
func (s WatcherStreamConfigImpl) FirmwareUpdateDuration() *Milliseconds {
	return s.FirmwareUpdateDurationValue
}

// Duration of the firmware update. If this field is present, the update process is ongoing.
// Format: milliseconds (milliseconds)
func (s *WatcherStreamConfigImpl) SetFirmwareUpdateDuration(v Milliseconds) WatcherStreamConfig {
	if s == nil {
		return nil
	}
	s.FirmwareUpdateDurationValue = &v
	return s
}

// Folder identificator.
func (s WatcherStreamConfigImpl) FolderID() *int {
	return s.FolderIDValue
}

// Folder identificator.
func (s *WatcherStreamConfigImpl) SetFolderID(v int) WatcherStreamConfig {
	if s == nil {
		return nil
	}
	s.FolderIDValue = &v
	return s
}

// The stream is added to favorites list.
func (s WatcherStreamConfigImpl) IsFavourite() *bool {
	return s.IsFavouriteValue
}

// The stream is added to favorites list.
func (s *WatcherStreamConfigImpl) SetIsFavourite(v bool) WatcherStreamConfig {
	if s == nil {
		return nil
	}
	s.IsFavouriteValue = &v
	return s
}

// Information about the latest changes made to the camera configuration.
func (s WatcherStreamConfigImpl) LastChange() AuditLogRecord {
	return s.LastChangeValue
}

// Information about the latest changes made to the camera configuration.
func (s *WatcherStreamConfigImpl) SetLastChange(v AuditLogRecord) WatcherStreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*AuditLogRecordImpl); ok {
		s.LastChangeValue = impl
	}
	return s
}

// The time when the last episode occurred.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s WatcherStreamConfigImpl) LastEpisodeAt() *UtcMs {
	return s.LastEpisodeAtValue
}

// The time when the last episode occurred.
// Format: utc_ms (Unix timestamp in milliseconds)
// Examples: 1.637094994e+12
func (s *WatcherStreamConfigImpl) SetLastEpisodeAt(v UtcMs) WatcherStreamConfig {
	if s == nil {
		return nil
	}
	s.LastEpisodeAtValue = &v
	return s
}

// Deprecated field. Will be deleted at 24.12
// Camera coordinates on a map or a floor plan. Deprecated. Use coordinates instead.
func (s WatcherStreamConfigImpl) MapCoordinates() MapSpec {
	return s.MapCoordinatesValue
}

// Deprecated field. Will be deleted at 24.12
// Camera coordinates on a map or a floor plan. Deprecated. Use coordinates instead.
func (s *WatcherStreamConfigImpl) SetMapCoordinates(v MapSpec) WatcherStreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*MapSpecImpl); ok {
		s.MapCoordinatesValue = impl
	}
	return s
}

// Notifications are enabled for the camera.
func (s WatcherStreamConfigImpl) NotificationsEnabled() *bool {
	return s.NotificationsEnabledValue
}

// Notifications are enabled for the camera.
func (s *WatcherStreamConfigImpl) SetNotificationsEnabled(v bool) WatcherStreamConfig {
	if s == nil {
		return nil
	}
	s.NotificationsEnabledValue = &v
	return s
}

// Onvif configuration
func (s WatcherStreamConfigImpl) Onvif() StreamOnvifConfig {
	return s.OnvifValue
}

// Onvif configuration
func (s *WatcherStreamConfigImpl) SetOnvif(v StreamOnvifConfig) WatcherStreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*StreamOnvifConfigImpl); ok {
		s.OnvifValue = impl
	}
	return s
}

// Organization the stream belongs to.
func (s WatcherStreamConfigImpl) Organization() OrganizationStream {
	return s.OrganizationValue
}

// Organization the stream belongs to.
func (s *WatcherStreamConfigImpl) SetOrganization(v OrganizationStream) WatcherStreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*OrganizationStreamImpl); ok {
		s.OrganizationValue = impl
	}
	return s
}

// Deprecated field. Will be deleted at 25.11
// ID of the organization the stream belongs to.
// Only organization owner or domain administrator could change it.
// Example: 9
func (s WatcherStreamConfigImpl) OrganizationID() *int {
	return s.OrganizationIDValue
}

// Deprecated field. Will be deleted at 25.11
// ID of the organization the stream belongs to.
// Only organization owner or domain administrator could change it.
// Example: 9
func (s *WatcherStreamConfigImpl) SetOrganizationID(v int) WatcherStreamConfig {
	if s == nil {
		return nil
	}
	s.OrganizationIDValue = &v
	return s
}

// Contains path to stream as a list.
// Each item of the list can be interpreted as a node in a folders tree.
func (s WatcherStreamConfigImpl) Path() []StreamPathItem {
	if s.PathValue == nil {
		return nil
	}
	result := make([]StreamPathItem, len(s.PathValue))
	for i, item := range s.PathValue {
		result[i] = item
	}
	return result
}

// Contains path to stream as a list.
// Each item of the list can be interpreted as a node in a folders tree.
func (s *WatcherStreamConfigImpl) SetPath(v []StreamPathItem) WatcherStreamConfig {
	if s == nil {
		return nil
	}
	if v != nil {
		impl := make([]*StreamPathItemImpl, len(v))
		for i, item := range v {
			if itemImpl, ok := item.(*StreamPathItemImpl); ok {
				impl[i] = itemImpl
			}
		}
		s.PathValue = impl
	}
	return s
}

// Camera adress on a map.
func (s WatcherStreamConfigImpl) PostalAddress() *string {
	return s.PostalAddressValue
}

// Camera adress on a map.
func (s *WatcherStreamConfigImpl) SetPostalAddress(v string) WatcherStreamConfig {
	if s == nil {
		return nil
	}
	s.PostalAddressValue = &v
	return s
}

// Preset settings.
func (s WatcherStreamConfigImpl) Preset() StreamPreset {
	return s.PresetValue
}

// Preset settings.
func (s *WatcherStreamConfigImpl) SetPreset(v StreamPreset) WatcherStreamConfig {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*StreamPresetImpl); ok {
		s.PresetValue = impl
	}
	return s
}

// Deprecated field. Will be deleted at 26.01
// Preset identificator.
func (s WatcherStreamConfigImpl) PresetID() *int {
	return s.PresetIDValue
}

// Deprecated field. Will be deleted at 26.01
// Preset identificator.
func (s *WatcherStreamConfigImpl) SetPresetID(v int) WatcherStreamConfig {
	if s == nil {
		return nil
	}
	s.PresetIDValue = &v
	return s
}

// NewWatcherStreamConfigAudio creates a new WatcherStreamConfigAudio instance
func NewWatcherStreamConfigAudio() WatcherStreamConfigAudio {
	return &WatcherStreamConfigAudioImpl{}
}

// A flag showing if the audio is captured (false) or not (true) from the stream.
// Example: false
func (s WatcherStreamConfigAudioImpl) Disabled() *bool {
	return s.DisabledValue
}

// A flag showing if the audio is captured (false) or not (true) from the stream.
// Example: false
func (s *WatcherStreamConfigAudioImpl) SetDisabled(v bool) WatcherStreamConfigAudio {
	if s == nil {
		return nil
	}
	s.DisabledValue = &v
	return s
}

// Audio codec (the AAC codec is used by default).
func (s WatcherStreamConfigAudioImpl) TranscodeAudioCodec() *FrameAudioCodec {
	return s.TranscodeAudioCodecValue
}

// Audio codec (the AAC codec is used by default).
func (s *WatcherStreamConfigAudioImpl) SetTranscodeAudioCodec(v FrameAudioCodec) WatcherStreamConfigAudio {
	if s == nil {
		return nil
	}
	s.TranscodeAudioCodecValue = &v
	return s
}

// NewWebPushSubscription creates a new WebPushSubscription instance
func NewWebPushSubscription() WebPushSubscription {
	return &WebPushSubscriptionImpl{}
}

// Endpoint on which Billing will send Push Messages
// Format: uri (uri)
// Example: https://fcm.googleapis.com/fcm/send/${token}
func (s WebPushSubscriptionImpl) Endpoint() URI {
	return s.EndpointValue
}

// Endpoint on which Billing will send Push Messages
// Format: uri (uri)
// Example: https://fcm.googleapis.com/fcm/send/${token}
func (s *WebPushSubscriptionImpl) SetEndpoint(v URI) WebPushSubscription {
	if s == nil {
		return nil
	}
	s.EndpointValue = v
	return s
}

// NewWebPushSubscriptionCreate creates a new WebPushSubscriptionCreate instance
func NewWebPushSubscriptionCreate() WebPushSubscriptionCreate {
	return &WebPushSubscriptionCreateImpl{}
}

// Endpoint on which Billing will send Push Messages
// Format: uri (uri)
// Example: https://fcm.googleapis.com/fcm/send/${token}
func (s WebPushSubscriptionCreateImpl) Endpoint() URI {
	return s.EndpointValue
}

// Endpoint on which Billing will send Push Messages
// Format: uri (uri)
// Example: https://fcm.googleapis.com/fcm/send/${token}
func (s *WebPushSubscriptionCreateImpl) SetEndpoint(v URI) WebPushSubscriptionCreate {
	if s == nil {
		return nil
	}
	s.EndpointValue = v
	return s
}

// Keys that are used to encrypt the payload
func (s WebPushSubscriptionCreateImpl) Keys() WebPushSubscriptionCreateKeys {
	return s.KeysValue
}

// Keys that are used to encrypt the payload
func (s *WebPushSubscriptionCreateImpl) SetKeys(v WebPushSubscriptionCreateKeys) WebPushSubscriptionCreate {
	if s == nil {
		return nil
	}
	if impl, ok := v.(*WebPushSubscriptionCreateKeysImpl); ok {
		s.KeysValue = impl
	}
	return s
}

// NewWebPushSubscriptionCreateKeys creates a new WebPushSubscriptionCreateKeys instance
func NewWebPushSubscriptionCreateKeys() WebPushSubscriptionCreateKeys {
	return &WebPushSubscriptionCreateKeysImpl{}
}

// Authentication secret
func (s WebPushSubscriptionCreateKeysImpl) Auth() string {
	return s.AuthValue
}

// Authentication secret
func (s *WebPushSubscriptionCreateKeysImpl) SetAuth(v string) WebPushSubscriptionCreateKeys {
	if s == nil {
		return nil
	}
	s.AuthValue = v
	return s
}

// Public key
func (s WebPushSubscriptionCreateKeysImpl) P256dh() string {
	return s.P256dhValue
}

// Public key
func (s *WebPushSubscriptionCreateKeysImpl) SetP256dh(v string) WebPushSubscriptionCreateKeys {
	if s == nil {
		return nil
	}
	s.P256dhValue = v
	return s
}
