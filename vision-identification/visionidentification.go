// Code generated by cmd/main. DO NOT EDIT.
package visionidentification

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"iter"
	"net/http"
	"net/url"
	"strconv"

	"github.com/flussonic/go-flussonic/authorization"
	"github.com/flussonic/go-flussonic/config"
	"github.com/flussonic/go-flussonic/internal/baseclient"
	"github.com/flussonic/go-flussonic/internal/cursors"
	model "github.com/flussonic/go-flussonic/vision-identification/model"
)

// VisionIdentification defines the interface for interacting with VisionIdentification API.
type VisionIdentification interface {
	// EpisodesIdentify Identify persons in episodes
	// Your application shall make this request to Identification service  to identify the face fingerprints by comparing them with the database of persons.  Supply the whole result of `episodes_list` to this method.  It will return a list of matched persons with corresponding match score.  Pay attention to `identification_error`.  Try to repeat the request for the episodes with errors in one or two minutes: the error may resolve because a better picture of face may be received in the same or other episodes.
	EpisodesIdentify(ctx context.Context, body model.EpisodeIdentificationRequest) (model.IdentifiedEpisodesList, error)
	// IdentificationMetricsGet Prometheus metrics
	// Provides endpoint for Prometheus scraper.
	IdentificationMetricsGet(ctx context.Context) (model.IdentificationMetrics, error)
	// LivenessProbe Liveness probe
	// Liveness probe.
	LivenessProbe(ctx context.Context) (model.VisionServerInfo, error)
	// PersonDelete Delete person
	// Delete a person with the supplied identifier
	PersonDelete(ctx context.Context, person_id string) error
	// PersonGet Get person
	// Returns the person by its identifier
	PersonGet(ctx context.Context, person_id string) (model.VisionPerson, error)
	// PersonSave Save person
	// Create or update existing person by its identifier
	PersonSave(ctx context.Context, person_id string, body model.VisionPerson) (model.VisionPerson, error)
	// PersonsList List of persons
	// Returns a list of persons
	PersonsList(ctx context.Context, query *PersonsListQuery) (model.VisionPersonsList, error)
	// PersonsListIterator iterates through all items using cursor pagination
	PersonsListIterator(ctx context.Context, query *PersonsListQuery) iter.Seq2[model.VisionPerson, error]
}

// PersonsListQuery represents query parameters for PersonsList method
type PersonsListQuery struct {
	Cursor string
	Limit  int
	Select string
	Sort   string
	Extra  map[string]string
}

// ToQueryString converts PersonsListQuery to a valid query string.
// It validates required parameters and returns an error if any are missing.
func (q *PersonsListQuery) ToQueryString() (string, error) {
	if q == nil {
		return "", nil
	}
	values := url.Values{}
	if q.Select != "" {
		values.Set("select", q.Select)
	}
	if q.Sort != "" {
		values.Set("sort", q.Sort)
	}
	if q.Limit > 0 {
		values.Set("limit", strconv.Itoa(q.Limit))
	}
	if q.Cursor != "" {
		values.Set("cursor", q.Cursor)
	}
	for key, value := range q.Extra {
		values.Set(key, value)
	}
	return values.Encode(), nil
}

// SetCursor sets the cursor for pagination.
func (q *PersonsListQuery) SetCursor(cursor *string) {
	if cursor != nil {
		q.Cursor = *cursor
	} else {
		q.Cursor = ""
	}
}

// BaseClientFactory is a factory function type for creating base HTTP clients.
type BaseClientFactory func(cfg *config.Config, apiURL string, authKey authorization.AuthKey) baseclient.BaseClient

// defaultBaseClientFactory creates a default base client instance.
func defaultBaseClientFactory(cfg *config.Config, apiURL string, authKey authorization.AuthKey) baseclient.BaseClient {
	return baseclient.New(cfg.HTTPClient, apiURL, authKey, cfg.Originator, cfg.Retry)
}

// Client is the concrete implementation of the VisionIdentification interface.
type Client struct {
	base   baseclient.BaseClient
	apiURL string
}

// NewWithBaseFactory creates a new VisionIdentification client with a custom base client factory.
// This is primarily used for testing or when custom HTTP client behavior is needed.
func NewWithBaseFactory(cfg *config.Config, baseFactory BaseClientFactory) (VisionIdentification, error) {
	if cfg.Hostname == "" {
		return nil, fmt.Errorf("hostname is required")
	}

	if cfg.Protocol == "" {
		cfg.Protocol = "http"
	}

	if cfg.Port == 0 {
		if cfg.Protocol == "https" {
			cfg.Port = 443
		} else {
			cfg.Port = 80
		}
	}

	apiURL := fmt.Sprintf("%s://%s:%d", cfg.Protocol, cfg.Hostname, cfg.Port)

	var authKey authorization.AuthKey
	if cfg.Auth != nil {
		authKey = cfg.Auth
	} else if cfg.ClusterKey != "" {
		authKey = authorization.ClusterKey(cfg.ClusterKey)
	}

	if cfg.Originator == "" {
		cfg.Originator = config.DefaultOriginator
	}

	base := baseFactory(cfg, apiURL, authKey)

	return &Client{
		base:   base,
		apiURL: apiURL,
	}, nil
}

// New creates a new VisionIdentification client with default settings.
func New(cfg *config.Config) (VisionIdentification, error) {
	return NewWithBaseFactory(cfg, defaultBaseClientFactory)
}

// doGet performs a GET request and unmarshals the response into result.
func (c *Client) doGet(ctx context.Context, path string, result any) error {
	request, err := http.NewRequestWithContext(ctx, http.MethodGet, c.apiURL+path, http.NoBody)
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}
	request.Header.Set("Content-Type", "application/json")
	return c.base.Request(ctx, request, result)
}

// doPost performs a POST request with a JSON body and unmarshals the response into result.
func (c *Client) doPost(ctx context.Context, path string, body any, result any) error {
	bodyBytes, err := json.Marshal(body)
	if err != nil {
		return fmt.Errorf("failed to marshal request body: %w", err)
	}
	request, err := http.NewRequestWithContext(ctx, http.MethodPost, c.apiURL+path, bytes.NewBuffer(bodyBytes))
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}
	request.Header.Set("Content-Type", "application/json")
	return c.base.Request(ctx, request, result)
}

// doPut performs a PUT request with a JSON body and unmarshals the response into result.
func (c *Client) doPut(ctx context.Context, path string, body any, result any) error {
	bodyBytes, err := json.Marshal(body)
	if err != nil {
		return fmt.Errorf("failed to marshal request body: %w", err)
	}
	request, err := http.NewRequestWithContext(ctx, http.MethodPut, c.apiURL+path, bytes.NewBuffer(bodyBytes))
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}
	request.Header.Set("Content-Type", "application/json")
	return c.base.Request(ctx, request, result)
}

// doDelete performs a DELETE request.
func (c *Client) doDelete(ctx context.Context, path string) error {
	request, err := http.NewRequestWithContext(ctx, http.MethodDelete, c.apiURL+path, http.NoBody)
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}
	request.Header.Set("Content-Type", "application/json")
	return c.base.Request(ctx, request, nil)
}

// doList performs a GET request with query parameters and unmarshals the response into result.
func (c *Client) doList(ctx context.Context, path string, query interface{ ToQueryString() (string, error) }, result any) error {
	if query == nil {
		request, err := http.NewRequestWithContext(ctx, http.MethodGet, c.apiURL+path, http.NoBody)
		if err != nil {
			return fmt.Errorf("failed to create request: %w", err)
		}
		request.Header.Set("Content-Type", "application/json")
		return c.base.Request(ctx, request, result)
	}
	queryString, err := query.ToQueryString()
	if err != nil {
		return fmt.Errorf("failed to build query string: %w", err)
	}
	requestURL := c.apiURL + path
	if queryString != "" {
		requestURL += "?" + queryString
	}
	request, err := http.NewRequestWithContext(ctx, http.MethodGet, requestURL, http.NoBody)
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}
	request.Header.Set("Content-Type", "application/json")
	return c.base.Request(ctx, request, result)
}

// EpisodesIdentify Identify persons in episodes
// Your application shall make this request to Identification service  to identify the face fingerprints by comparing them with the database of persons.  Supply the whole result of `episodes_list` to this method.  It will return a list of matched persons with corresponding match score.  Pay attention to `identification_error`.  Try to repeat the request for the episodes with errors in one or two minutes: the error may resolve because a better picture of face may be received in the same or other episodes.
func (c *Client) EpisodesIdentify(ctx context.Context, body model.EpisodeIdentificationRequest) (model.IdentifiedEpisodesList, error) {
	path := "/vision/api/v3/episodes/identify"
	result := &model.IdentifiedEpisodesListImpl{}
	if err := c.doPost(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// IdentificationMetricsGet Prometheus metrics
// Provides endpoint for Prometheus scraper.
func (c *Client) IdentificationMetricsGet(ctx context.Context) (model.IdentificationMetrics, error) {
	path := "/vision/api/v3/monitoring/metrics"
	result := &model.IdentificationMetricsImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// LivenessProbe Liveness probe
// Liveness probe.
func (c *Client) LivenessProbe(ctx context.Context) (model.VisionServerInfo, error) {
	path := "/vision/api/v3/monitoring/liveness"
	result := &model.VisionServerInfoImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// PersonDelete Delete person
// Delete a person with the supplied identifier
func (c *Client) PersonDelete(ctx context.Context, person_id string) error {
	path := fmt.Sprintf("/vision/api/v3/persons/%s", person_id)
	if err := c.doDelete(ctx, path); err != nil {
		return err
	}
	return nil
}

// PersonGet Get person
// Returns the person by its identifier
func (c *Client) PersonGet(ctx context.Context, person_id string) (model.VisionPerson, error) {
	path := fmt.Sprintf("/vision/api/v3/persons/%s", person_id)
	result := &model.VisionPersonImpl{}
	if err := c.doGet(ctx, path, result); err != nil {
		return nil, err
	}
	return result, nil
}

// PersonSave Save person
// Create or update existing person by its identifier
func (c *Client) PersonSave(ctx context.Context, person_id string, body model.VisionPerson) (model.VisionPerson, error) {
	path := fmt.Sprintf("/vision/api/v3/persons/%s", person_id)
	result := &model.VisionPersonImpl{}
	if err := c.doPut(ctx, path, body, result); err != nil {
		return nil, err
	}
	return result, nil
}

// PersonsList List of persons
// Returns a list of persons
func (c *Client) PersonsList(ctx context.Context, query *PersonsListQuery) (model.VisionPersonsList, error) {
	path := "/vision/api/v3/persons"
	result := &model.VisionPersonsListImpl{}
	if err := c.doList(ctx, path, query, result); err != nil {
		return nil, err
	}
	return result, nil
}

// PersonsListIterator iterates through all VisionPerson items using cursor pagination.
func (c *Client) PersonsListIterator(ctx context.Context, query *PersonsListQuery) iter.Seq2[model.VisionPerson, error] {
	return cursors.Iterator(ctx, c.PersonsList, query)
}
